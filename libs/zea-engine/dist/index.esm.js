function isIOSDevice() {
  return (
    (navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i)) != null
  )
}

function isMobileDevice() {
  return (
    (navigator.userAgent.match(/Android/i) ||
      navigator.userAgent.match(/webOS/i) ||
      navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i) ||
      navigator.userAgent.match(/BlackBerry/i) ||
      navigator.userAgent.match(/Pixel/i) ||
      navigator.userAgent.match(/Windows Phone/i)) != null
  )
}

function getBrowserDesc() {
  const nAgt = navigator.userAgent;
  let browserName = navigator.appName;
  let fullVersion = '' + parseFloat(navigator.appVersion);
  let majorVersion = parseInt(navigator.appVersion, 10);
  let nameOffset;
  let verOffset;
  let ix;

  if (navigator.brave) {
    browserName = 'Brave';
    verOffset = nAgt.indexOf('Chrome');
    fullVersion = nAgt.substring(verOffset + 7, nAgt.indexOf(' ', verOffset + 7));
  }

  // In Opera, the true version is after "Opera" or after "Version"
  else if ((verOffset = nAgt.indexOf('Opera')) != -1) {
    browserName = 'Opera';
    fullVersion = nAgt.substring(verOffset + 6);
    if ((verOffset = nAgt.indexOf('Version')) != -1) fullVersion = nAgt.substring(verOffset + 8);
  }
  // In MSIE, the true version is after "MSIE" in userAgent
  else if ((verOffset = nAgt.indexOf('MSIE')) != -1) {
    browserName = 'Microsoft Internet Explorer';
    fullVersion = nAgt.substring(verOffset + 5);
  } else if ((verOffset = nAgt.indexOf('Edge')) != -1) {
    browserName = 'Edge';
    fullVersion = nAgt.substring(verOffset + 4);
  }
  // In Chrome, the true version is after "Chrome"
  else if ((verOffset = nAgt.indexOf('Chrome')) != -1) {
    browserName = 'Chrome';
    fullVersion = nAgt.substring(verOffset + 7, nAgt.indexOf(' ', verOffset + 7));
  }

  // TOOD: Parse Samsung userAgent
  // https://developer.samsung.com/technical-doc/view.do?v=T000000203

  // In Safari, the true version is after "Safari" or after "Version"
  else if ((verOffset = nAgt.indexOf('Safari')) != -1) {
    browserName = 'Safari';
    fullVersion = nAgt.substring(verOffset + 7);
    if ((verOffset = nAgt.indexOf('Version')) != -1) fullVersion = nAgt.substring(verOffset + 8);
  }
  // In Firefox, the true version is after "Firefox"
  else if ((verOffset = nAgt.indexOf('Firefox')) != -1) {
    browserName = 'Firefox';
    fullVersion = nAgt.substring(verOffset + 8);
  }
  // In most other browsers, "name/version" is at the end of userAgent
  else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
    browserName = nAgt.substring(nameOffset, verOffset);
    fullVersion = nAgt.substring(verOffset + 1);
    if (browserName.toLowerCase() == browserName.toUpperCase()) {
      browserName = navigator.appName;
    }
  }
  // trim the fullVersion string at semicolon/space if present
  if ((ix = fullVersion.indexOf(';')) != -1) fullVersion = fullVersion.substring(0, ix);
  if ((ix = fullVersion.indexOf(' ')) != -1) fullVersion = fullVersion.substring(0, ix);

  majorVersion = parseInt('' + fullVersion, 10);
  if (isNaN(majorVersion)) {
    fullVersion = '' + parseFloat(navigator.appVersion);
    majorVersion = parseInt(navigator.appVersion, 10);
  }

  return {
    browserName,
    fullVersion,
    majorVersion,
    appName: navigator.appName,
    userAgent: navigator.userAgent,
  }
}

function getGPUDesc() {
  let webgl;
  try {
    webgl = document.createElement('canvas').getContext('webgl');
  } catch (e) {}
  if (!webgl) return
  let webgl2;
  try {
    webgl2 = document.createElement('canvas').getContext('webgl2');
  } catch (e) {}

  const debugInfo = webgl.getExtension('WEBGL_debug_renderer_info');
  if (!debugInfo) {
    console.warn('Unable to determine GPU Info:');
    return {
      vendor: 'Unknown',
      renderer: 'Unknown',
      gpuVendor: 'Unknown',
      maxTextureSize: 'Unknown',
      supportsWebGL2: webgl2 != undefined,
    }
  }

  const vendor = webgl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
  const renderer = webgl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
  const maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
  let gpuVendor;
  if (renderer.match(/NVIDIA/i)) {
    gpuVendor = 'NVidia';
  } else if (renderer.match(/AMD/i) || renderer.match(/Radeon/i)) {
    gpuVendor = 'AMD';
  } else if (renderer.match(/Intel/i)) {
    gpuVendor = 'Intel';
  } else if (renderer.match(/Mali/i)) {
    gpuVendor = 'ARM';
  } else if (renderer.match(/Adreno/i)) {
    gpuVendor = 'Adreno';
  } else {
    console.warn('Unable to determine GPU vendor:', renderer);
  }

  return {
    vendor,
    renderer,
    gpuVendor,
    maxTextureSize,
    supportsWebGL2: webgl2 != undefined,
  }
}

const SystemDesc = (function () {
  if (!globalThis.navigator) {
    return {
      isMobileDevice: false,
      isIOSDevice: false,
      browserName: 'Node',
      webGLSupported: false,
      gpuDesc: null,
      deviceCategory: 'High',
    }
  }
  const isMobile = isMobileDevice();
  const browserDesc = getBrowserDesc();
  const gpuDesc = getGPUDesc();

  let deviceCategory = 'Low';
  if (gpuDesc) {
    // We divide devices into 3 categories.
    // 0: low end, we dial everything down as much as possible
    // 1: mid-range, Enb maps and Textures go to mid-lods.
    //    Typically these devices are laptops, so the textures can't be too blurry
    // 2: High-end: turn up as much as needed.
    if (!isMobile) {
      // Remove braces and split into parts
      const parts = gpuDesc.renderer.replace(/[()]/g, '').split(' ');
      if (gpuDesc.gpuVendor == 'NVidia') {
        const gtxIdx = parts.indexOf('GTX');
        if (gtxIdx != -1) {
          const model = parts[gtxIdx + 1];
          if (model.endsWith('M')) {
            // laptop GPU.
            const modelNumber = parseInt(model.substring(0, model.length - 2));
            if (modelNumber >= 900) {
              deviceCategory = 'Medium';
            } else {
              deviceCategory = 'Low';
            }
          } else {
            const modelNumber = parseInt(model);
            if (modelNumber >= 1030) {
              deviceCategory = 'High';
            } else {
              deviceCategory = 'Medium';
            }
          }
        } else {
          if (parts.indexOf('TITAN') != -1 || parts.indexOf('Quadro') != -1) {
            deviceCategory = 'High';
          } else {
            deviceCategory = 'Low';
          }
        }
      } else if (gpuDesc.gpuVendor == 'AMD') {
        const radeonIdx = parts.indexOf('Radeon');
        if (radeonIdx != -1) {
          const rxIdx = parts.indexOf('RX');
          if (rxIdx != -1) {
            if (parts[rxIdx + 1] == 'Vega') {
              deviceCategory = 'High';
            } else {
              const model = parts[rxIdx + 1];
              let modelNumber;
              if (model.endsWith('X')) {
                modelNumber = parseInt(model.substring(0, model.length - 2));
                deviceCategory = 'High';
              } else {
                modelNumber = parseInt(model);
              }

              if (modelNumber >= 480) {
                deviceCategory = 'High';
              } else {
                deviceCategory = 'Medium';
              }
            }
          } else if (parts[radeonIdx + 1] == 'Pro') {
            const modelNumber = parseInt(parts[rxIdx + 1]);
            if (modelNumber >= 450) {
              deviceCategory = 'Medium';
            } else {
              deviceCategory = 'Low';
            }
          } else if (parts[radeonIdx + 1] == 'Sky') {
            const modelNumber = parseInt(parts[rxIdx + 1]);
            if (modelNumber >= 700) {
              deviceCategory = 'Medium';
            } else {
              deviceCategory = 'Low';
            }
          } else {
            deviceCategory = 'Low';
          }
        } else {
          if (parts.indexOf('FirePro') != -1 || parts.indexOf('Quadro') != -1) {
            deviceCategory = 'High';
          } else {
            deviceCategory = 'Low';
          }
        }
      } else if (gpuDesc.gpuVendor == 'Adreno') {
        deviceCategory = 'Low';
      } else if (gpuDesc.gpuVendor == 'Intel') {
        deviceCategory = 'Low';
      }
    } else {
      deviceCategory = 'Low';
    }
  }

  return {
    isMobileDevice: isMobile,
    isIOSDevice: isIOSDevice(),
    browserName: browserDesc.browserName,
    fullVersion: browserDesc.fullVersion,
    majorVersion: browserDesc.majorVersion,
    appName: browserDesc.appName,
    userAgent: browserDesc.userAgent,
    webGLSupported: gpuDesc != undefined,
    gpuDesc,
    deviceCategory,
  }
})();

if (!globalThis.ZeaSystemDesc) {
  globalThis.ZeaSystemDesc = SystemDesc;
}

const UInt8 = 0;
const SInt8 = 1;
const UInt16 = 2;
const SInt16 = 3;
const UInt32 = 4;
const SInt32 = 5;
const Float32 = 6;

/**
 * Math Functions
 */
class MathFunctions {
  /**
   * Converts Radians to Degrees
   *
   * @static
   * @param {number} rad - Radians value
   * @return {number} - Degrees equivalent
   */
  static radToDeg(rad) {
    return rad / (Math.PI / 180)
  }

  /**
   * Converts Degrees to Radiants
   *
   * @static
   * @param {number} deg - Degrees value
   * @return {number} -  Radians equivalent
   */
  static degToRad(deg) {
    return deg * (Math.PI / 180)
  }

  /**
   * Verifies if the specified parameter is numeric.
   *
   * @static
   * @param {number|any} number - Number to test
   * @return {boolean} - `true` when is a valid number
   */
  static isNumeric(number) {
    return !isNaN(parseFloat(number)) && isFinite(number)
  }

  /**
   * Generates and returns a random integer within the specified range.
   *
   * @static
   * @param {number} min - Lower value random int can be.
   * @param {number} max - Highest value random int can be.
   * @return {number} - Random number inside range.
   */
  static randomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min
  }

  /**
   * Calculates a lineal interpolation between two inputs for the specified parameter(t).
   *
   * @static
   * @param {number} v0 -
   * @param {number} v1 -
   * @param {number} t -
   * @return {number} -
   */
  static lerp(v0, v1, t) {
    return v0 + t * (v1 - v0)
  }

  /**
   * Restricts the specified value between two numbers
   *
   * @static
   * @param {number} value
   * @param {number} min
   * @param {number} max
   * @return {number}
   */
  static clamp(value, min, max) {
    return Math.min(Math.max(value, min), max)
  }

  /**
   * Returns the nearest pow of two value of the specified number.
   *
   * @static
   * @param {number} value -
   * @return {number} -
   */
  static nearestPow2(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.log(2)))
  }

  /**
   * Returns the nearest pow of ten value of the specified number.
   *
   * @static
   * @param {number} value -
   * @return {number} -
   */
  static nearestPow10(value) {
    return Math.pow(10, Math.round(Math.log10(value) / Math.log10(10)))
  }

  /**
   * Returns the next pow of two value of the specified number.
   *
   * @static
   * @param {number} value -
   * @return {number} -
   */
  static nextPow2(value) {
    let exp = 0;

    while (value > 0) {
      exp++;
      value = value >> 1;
    }

    return 1 << exp
  }

  /**
   * Returns the fractional component of a number
   *
   * @static
   * @param {number} value -
   * @return {number} -
   */
  static fract(value) {
    if (value == 0) return 0
    if (value < 0) {
      if (value > -1.0) return -value
      return -value % Math.floor(-value)
    }
    if (value < 1.0) return value
    return value % Math.floor(value)
  }

  /**
   * Moves the specified value from one numeric domain(range) to another.
   *
   * @static
   * @param {number} value -
   * @param {number} start1 -
   * @param {number} end1 -
   * @param {number} start2 -
   * @param {number} end2 -
   * @return {number} -
   */
  static remap(value, start1, end1, start2, end2) {
    return start2 + (end2 - start2) * ((value - start1) / (end1 - start1))
  }

  /**
   * Perform Hermite interpolation between two values
   *
   * @static
   * @param {number} edge0 -
   * @param {number} edge1 -
   * @param {number} x -
   * @return {number} -
   */
  static smoothStep(edge0, edge1, x) {
    const t = this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t)
  }

  /**
   * Performs - interpolation between two values
   *
   * @static
   * @param {number} edge0 -
   * @param {number} edge1 -
   * @param {number} x -
   * @return {number} -
   */
  static linStep(edge0, edge1, x) {
    return this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0)
  }

  /**
   * Decodes a Float16 from two unsigned Int8
   *
   * @static
   * @param {Uint8Array} c - Array with the two UInt8
   * @return {number} - Decoded Float16
   */
  static decode16BitFloatFrom2xUInt8(c) {
    const ix = c[0]; // 1st byte: 1 bit signed num, 4 bits exponent, 3 bits mantissa (MSB)
    const iy = c[1]; // 2nd byte: 8 bit mantissa (LSB)

    const s = ix & 0x80 ? 1 : -1; // get bit 8
    const iexp = (ix & 0x78) >> 3; // mask bits 7-4
    const msb = ix & 0x7; // mask bits 3-1

    let norm = iexp == 0 ? 0 : 2048; // distinguish between normalized and sub-normalized numbers
    const mantissa = norm + (msb << 8) + iy; // implicit preceding 1 or 0 added here
    norm = iexp == 0 ? 1 : 0; // normalization toggle
    const exponent = Math.pow(2, iexp + norm - 16); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa
    const v = s * mantissa * exponent;

    return v
  }

  /**
   * Encodes an array of two unsigned Int8 to a Float16
   *
   * @static
   * @param {number} v - Float16 number
   * @return {Uint8Array} - Encoded Unsigned Int8 array
   */
  static encode16BitFloatInto2xUInt8(v) {
    const c = new Uint8Array(2);
    // const c = [0, 0];
    const signum = v >= 0 ? 128 : 0;
    v = Math.abs(v);
    let exponent = 15;
    let limit = 1024; // considering the bias from 2^-5 to 2^10 (==1024)
    for (let exp = 15; exp > 0; exp--) {
      if (v < limit) {
        limit /= 2;
        exponent--;
      }
    }

    let rest;
    if (exponent == 0) {
      rest = v / limit / 2; // "sub-normalize" implicit preceding 0.
    } else {
      rest = (v - limit) / limit; // normalize accordingly to implicit preceding 1.
    }

    const mantissa = Math.round(rest * 2048); // 2048 = 2^11 for the (split) 11 bit mantissa
    const msb = mantissa / 256; // the most significant 3 bits go into the lower part of the first byte
    const lsb = mantissa - msb * 256; // there go the other 8 bit of the lower significance

    c[0] = signum + exponent * 8 + msb; // color normalization for texture2D
    c[1] = lsb;

    if (v >= 2048) {
      c[0] = 255;
    }

    return c
  }

  /**
   * Transforms a 16 bit float to an encoded integer.
   *
   * @static
   * @param {number} v - Float16 number to encode
   * @return {number} - Encoded number
   */
  static encode16BitFloat(v) {
    const float32Array = new Float32Array(1);
    float32Array[0] = v;
    const int32View = new Int32Array(float32Array.buffer);

    const toUInt16 = (x) => {
      let bits = (x >> 16) & 0x8000; /* Get the sign */
      let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
      const e = (x >> 23) & 0xff; /* Using int is faster here */

      /* If zero, or de-normal, or exponent underflows too much for a de-normal
       * half, return signed zero. */
      if (e < 103) {
        return bits
      }

      /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
      if (e > 142) {
        bits |= 0x7c00;
        /* If exponent was 0xff and one mantissa bit was set, it means NaN,
         * not Inf, so make sure we set one mantissa bit too. */
        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
        return bits
      }

      /* If exponent underflows but not too much, return a de-normal */
      if (e < 113) {
        m |= 0x0800;
        /* Extra rounding may overflow and set mantissa to 0 and exponent
         * to 1, which is OK. */
        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
        return bits
      }

      bits |= ((e - 112) << 10) | (m >> 1);
      /* Extra rounding. An overflow will set mantissa to 0 and increment
       * the exponent, which is OK. */
      bits += m & 1;

      return bits
    };

    return toUInt16(int32View[0])
  }

  /**
   * As opposite of the `encode16BitFloat` method, this takes an encoded integer value,
   * and returns the 16 bit float.
   *
   * @static
   * @param {number} h - Encoded integer
   * @return {number} - Decoded 16 bit float.
   */
  static decode16BitFloat(h) {
    const s = (h & 0x8000) >> 15;
    const e = (h & 0x7c00) >> 10;
    const f = h & 0x03ff;

    if (e == 0) {
      return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10))
    } else if (e == 0x1f) {
      return f ? NaN : (s ? -1 : 1) * Infinity
    }

    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10))
  }

  /**
   * Transforms an array of Float 32 to an array of unsigned Int16.
   *
   * @static
   * @param {Float32Array} float32Array -
   * @return {Uint16Array} - Unsigned Int16 array representative of the Float32Array
   */
  static convertFloat32ArrayToUInt16Array(float32Array) {
    const unit16s = new Uint16Array(float32Array.length);
    const int32View = new Int32Array(float32Array.buffer);
    const toUInt16 = (x) => {
      let bits = (x >> 16) & 0x8000; /* Get the sign */
      let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
      const e = (x >> 23) & 0xff; /* Using int is faster here */

      /* If zero, or de-normal, or exponent underflows too much for a de-normal
       * half, return signed zero. */
      if (e < 103) {
        return bits
      }

      /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
      if (e > 142) {
        bits |= 0x7c00;
        /* If exponent was 0xff and one mantissa bit was set, it means NaN,
         * not Inf, so make sure we set one mantissa bit too. */
        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
        return bits
      }

      /* If exponent underflows but not too much, return a de-normal */
      if (e < 113) {
        m |= 0x0800;
        /* Extra rounding may overflow and set mantissa to 0 and exponent
         * to 1, which is OK. */
        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
        return bits
      }

      bits |= ((e - 112) << 10) | (m >> 1);
      /* Extra rounding. An overflow will set mantissa to 0 and increment
       * the exponent, which is OK. */
      bits += m & 1;

      return bits
    };
    for (let i = 0; i < float32Array.length; i++) {
      unit16s[i] = toUInt16(int32View[i]);
    }
    return unit16s
  }
}

let _registeredBlueprints = {};
let _blueprintNames = {};
let _blueprints = [];

/**
 * Registry is a static factory that handles registration/reconstruction of
 * persisted type of data, this includes classes and types.
 *
 * Note: blueprintName is required because on minification process
 * the name of classes change and we can't simply use '....constructor.name'.
 * So, we need a way of relating minified blueprint names to the one stored for persistency.
 * <br>
 * i.e.
 * ```javascript
 * // Import registry class
 * class Foo() {}
 *
 * Registry.register('Foo', Foo)
 * // In case 'Foo' class gets its name changed to 'c' on minification,
 * // and the persisted data type is 'Foo', we would know how to relate them.
 * ```
 *
 * @static
 * @class Registry
 */
const Registry = {
  /**
   * Registers a new blueprint in the factory.
   *
   * @param {string} blueprintName - Name of the registered blueprint(Class, type, etc)
   * @param {function|number|any} blueprint - Blueprint representation(Class function, type)
   */
  register: (blueprintName, blueprint) => {
    if (_registeredBlueprints[blueprintName]) throw new Error(`There's a class registered with '${blueprintName}' name`)
    _registeredBlueprints[blueprintName] = { blueprint, callbacks: [] };

    // Note: To provide backwards compatibility, same blueprint can be stored under multiple names.
    // Thats the reason behind using indexes instead of the blueprint.
    const blueprintIndex = _blueprints.length;
    _blueprints.push(blueprint);
    _blueprintNames[blueprintIndex] = blueprintName;
  },
  /**
   * Returns blueprint function/type by specifying its name.
   *
   * @param {string} blueprintName - Name of the registered blueprint(Class, type, etc)
   * @return {function|number|any} - Blueprint representation(Class function, type)
   */
  getBlueprint: (blueprintName) => {
    if (_registeredBlueprints[blueprintName]) return _registeredBlueprints[blueprintName].blueprint

    throw new Error(`${blueprintName} blueprint is not registered`)
  },
  /**
   * Returns class name using passing an instantiated object.
   * If it is not registered, the name in constructor is returned.
   *
   * @param {function|number|any|undefined} blueprintInstance - Blueprint representation(Class function, type)
   * @return {string} - Name of the registered blueprint(Class, type, etc)
   */
  getBlueprintName: (blueprintInstance) => {
    let blueprint = blueprintInstance;
    let blueprintName = blueprintInstance;

    if (typeof blueprintInstance === 'object') {
      blueprint = blueprintInstance.constructor;
      blueprintName = blueprint.name;
    }

    const blueprintId = _blueprints.indexOf(blueprint);
    if (blueprintId >= 0 && _blueprintNames[blueprintId]) return _blueprintNames[blueprintId]

    throw new Error(`${blueprintName} blueprint is not registered`)
  },
  /**
   * Accepting the class name and `N` number of arguments, instantiates a new object of the specified class.
   * If the class is not registered, then `null` is returned.
   * <br>
   * **Note:** Although the class arguments are not literally specified in the parameters,
   * you can pass them(As many as needed).
   *
   * @param {string} blueprintName - Name of the registered blueprint(Class, type, etc)
   * @return {object|null} - Instantiated object of the specified class
   */
  constructClass: (blueprintName, ...args) => {
    const blueprintData = _registeredBlueprints[blueprintName];
    if (!blueprintData) throw new Error(`${blueprintName} blueprint is not registered`)

    // eslint-disable-next-line new-cap
    return new blueprintData.blueprint(...args)
  },
  /**
   * For testing purpose only, never call this outside of the test scope.
   *
   * @private
   */
  flush: () => {
    _registeredBlueprints = {};
    _blueprintNames = {};
    _blueprints = [];
  },
};

Registry.register('UInt8', UInt8);
Registry.register('SInt8', SInt8);
Registry.register('UInt16', UInt16);
Registry.register('SInt16', SInt16);
Registry.register('UInt32', UInt32);
Registry.register('SInt32', SInt32);
Registry.register('Float32', Float32);

/**
 * String functions
 *
 */
class StringFunctions {
  /**
   * Replaces all matches in a string.
   *
   * @static
   * @param {string} str -
   * @param {string|RegExp} pattern -
   * @param {string} replacement -
   * @return {string} -
   */
  static replaceAll(str, pattern, replacement) {
    return str.replace(new RegExp(pattern, 'g'), replacement)
  }

  /**
   * Returns JSON object as a formatted string, but the numeric values are fixed to the specified precision.
   *
   * @static
   * @param {object} val -
   * @param {number} [space=0] -
   * @param {number} [precision=5] -
   * @return {string} -
   */
  static stringifyJSONWithFixedPrecision(val, space = 0, precision = 5) {
    return JSON.stringify(
      val,
      (key, val) => {
        return val ? (val.toFixed ? Number(val.toFixed(precision)) : val) : val
      },
      space
    )
  }

  /**
   * Transforms the given string into a numeric value.
   *
   * @static
   * @param {*} str -
   * @return {number} -
   */
  static hashStr(str) {
    let hash = 0;
    let i;
    let chr;
    let len;
    if (str.length === 0) return hash
    for (i = 0, len = str.length; i < len; i++) {
      chr = str.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash)
  }
}

// eslint-disable-next-line camelcase

/**
 * Base class for Math types that can be stored in vertex attributes.
 * <br>
 * **Note:** These values use {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} values to store their data.
 */
class AttrValue {
  /**
   * Verifies if the values stored in this Math type are valid numeric values.
   * Returns `false` If at least one of the values is either {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity|Infinity} or
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referencia/Objetos_globales/NaN|NaN}.
   *
   * @return {boolean} - Returns the result as a boolean.
   */
  isValid() {
    for (const v of this.__data) {
      if (v == Infinity || isNaN(v)) return false
    }

    return true
  }

  /**
   * This method is a factory function for creating new instances of math types, given an existing Float32Array buffer.
   * Each Math type implements this function to return an constructed value.
   *
   * @param {ArrayBuffer} buffer - the buffer value.
   * @param {number} offset - the offset value.
   * @return {AttrValue} - Returns the constructed value.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset) {
    throw new Error('Not yet implemented for this type:' + this.constructor.name)
  }

  /**
   * This method is a factory function for creating new instances of math types, given an existing ArrayBuffer.
   * Each Math type implements this function to return an constructed value.
   *
   * @static
   * @param {ArrayBuffer} buffer
   * @param {number} byteOffset
   * @return {AttrValue} - Returns the constructed value.
   */
  static createFromBuffer(buffer, byteOffset) {
    throw new Error('Not yet implemented for this type:' + this.constructor.name)
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - Returns the number of float values stored in this math type.
   */
  static numElements() {
    throw new Error('Not yet implemented for this type:' + this.constructor.name)
  }

  /**
   * Returns current Math type data as array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns the result as an array.
   */
  asArray() {
    return this.__data
  }

  /**
   * Converts this Math type to a string in JSON format.
   *
   * @return {string} - The return value.
   */
  toString() {
    // eslint-disable-next-line new-cap
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }

  /**
   * Converts this Math type to a JSON object.
   * @return {object} - The json object.
   */
  toJSON() {
    throw new Error('Not yet implemented for this type:' + this.constructor.name)
  }
}

/**
 * Representing a Vec2(two-dimensional floating point vector). A Vec2 is for representing 2 dimensional values, such as screen coordinates or pixel coordinates within an image.
 *
 * Math types internally store values in {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} and
 * expose getters and setters for the component values.
 *
 * @extends AttrValue
 */
class Vec2 extends AttrValue {
  /**
   * Creates a Vec2.
   *
   * The type of values of the `(x, y)` coordinates can be {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array|Uint32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array|Int32Array} and
   * {@link https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/ArrayBuffer|ArrayBuffer}.
   * <br>
   *
   * ```javascript
   *  const myVec2 = new Vec2(1.2, 3.4)
   * ```
   *
   * Given an array of floats, create a Vec2 that wraps some part of it.
   * ```javascript
   *  const floatArray = new Float32Array(6)
   *  floatArray[0] = 1.2
   *  floatArray[1] = 3.4
   *  const myVec2 = new Vec2(floatArray)
   *  console.log(myVec2.toJSON())
   * ```
   * The resulting output
   * ```json
   *  > { x:1.2, y:3.4 }
   * ```
   *
   * Given an array of floats, create a Vec2 that wraps some part of it.
   * ```javascript
   *  const floatArray = new Float32Array(6)
   *  floatArray[0] = 1.2
   *  floatArray[1] = 3.4
   *  floatArray[2] = 5.6
   *  floatArray[3] = 7.8
   *  floatArray[4] = 9.0
   *  floatArray[5] = 1.9
   *  const myVec2 = new Vec2(floatArray.buffer, 8)
   *  console.log(myVec2.toJSON())
   * ```
   * The resulting output
   * ```json
   *  > { x:5.6, y:7.8 }
   * ```
   *
   * You can also pass one JSON object parameter.
   * ```javascript
   *  const myVec2 = new Vec2({ x:1.2, y:3.4 })
   * ```
   *
   * @param {Number|Float32Array|Uint32Array|json} x - The x value. Default is 0.
   * @param {Number} y - The y value. Default is 0.
   */
  constructor(x = 0, y = 0) {
    super();

    if (x instanceof Float32Array || x instanceof Uint32Array || x instanceof Int32Array) {
      this.__data = x;
    } else if (x instanceof ArrayBuffer) {
      console.warn(`deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))`);
      const buffer = x;
      const byteOffset = y;
      this.__data = new Float32Array(buffer, byteOffset, 2);
    } else if (x != null && typeof x == 'object') {
      this.__data = new Float32Array(2);
      this.fromJSON(x);
    } else {
      this.__data = new Float32Array(2);
      this.__data[0] = x;
      this.__data[1] = y;
    }
  }

  /**
   * Getter for `x` component.
   * @return {number} - Returns the x component.
   */
  get x() {
    return this.__data[0]
  }

  /**
   * Setter for `x` component.
   * @param {number} val - The val param.
   */
  set x(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for `y` component.
   * @return {number} - Returns the y component.
   */
  get y() {
    return this.__data[1]
  }

  /**
   * Setter for `y` component.
   * @param {number} val - The val param.
   */
  set y(val) {
    this.__data[1] = val;
  }

  /**
   * Setter from scalar components.
   * @param {number} x - The x component.
   * @param {number} y  - The y component.
   */
  set(x, y) {
    this.__data[0] = x;
    this.__data[1] = y;
  }

  /**
   * Replaces this Vec2 data with the Vec2 data passed as parameter.
   *
   * @param {Vec2} other - The other Vec2 to set from.
   */
  setFromOther(other) {
    this.x = other.x;
    this.y = other.y;
  }

  /**
   * Checks if this Vec2 is exactly the same as another Vec2.
   *
   * @deprecated
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {boolean} - Returns `true` if are the same Vector, otherwise, `false`.
   */
  equal(other) {
    console.warn('Deprecated. Use #isEqual instead.');
    return this.isEqual(other)
  }

  /**
   * Checks if this Vec2 is exactly the same as another Vec2.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {boolean} - Returns `true` if are the same Vector, otherwise, `false`.
   */
  isEqual(other) {
    return this.x == other.x && this.y == other.y
  }

  /**
   * Checks if this Vec2 is different from another Vec2.
   *
   * @deprecated
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {boolean} - Returns `true` if the Vec2s are different, otherwise, `false`.
   */
  notEquals(other) {
    console.warn('Deprecated. Use #notEqual instead.');
    return this.notEqual(other)
  }

  /**
   * Checks if this Vec2 is different from another Vec2.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {boolean} - Returns `true` if the Vec2s are different, otherwise, `false`.
   */
  notEqual(other) {
    return this.x != other.x && this.y != other.y
  }

  /**
   * Returns true if this Vec2 is approximately the same as other.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return Math.abs(this.x - other.x) < precision && Math.abs(this.y - other.y) < precision
  }

  /**
   * Adds other to this Vec2 and returns the result as a new Vec2.
   *
   * @param {Vec2} other - The other Vec2 to add.
   * @return {Vec2} - Returns a new Vec2.
   */
  add(other) {
    return new Vec2(this.x + other.x, this.y + other.y)
  }

  /**
   * Adds a Vec2 to this Vec2.
   *
   * @param {Vec2} other - The other Vec2 to add.
   */
  addInPlace(other) {
    this.x += other.x;
    this.y += other.y;
  }

  /**
   * Subtracts a Vec2 from this Vec2 and returns the result as a new Vec2.
   *
   * @param {Vec2} other - The other Vec2 to subtract.
   * @return {Vec2} - Returns a new Vec2.
   */
  subtract(other) {
    return new Vec2(this.x - other.x, this.y - other.y)
  }

  /**
   * Subtracts a Vec2 from this Vec2.
   *
   * @param {Vec2} other - The other Vec2 to subtract.
   * @return {Vec2} - Returns a new Vec2.
   */
  subtractInPlace(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this
  }

  /**
   * Scales this Vec2 by scalar and returns the result as a new Vec2.
   *
   * @param {number} scalar - The scalar value.
   * @return {Vec2} - Returns a new Vec2.
   */
  scale(scalar) {
    return new Vec2(this.x * scalar, this.y * scalar)
  }

  /**
   * Scales this Vec2 by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  }

  /**
   * Inverts this Vec2 and returns the result as a new Vec2.
   *
   * @return {Vec2} - Returns a new Vec2.
   */
  invert() {
    return new Vec2(1.0 / this.x, 1.0 / this.y)
  }

  /**
   * Inverts this Vec2.
   *
   * @return {Vec2} - The return value.
   */
  invertInPlace() {
    this.x = 1.0 / this.x;
    this.y = 1.0 / this.y;
    return this
  }

  /**
   * Multiplies a Vec2 with this Vec2 and returns the result as a new Vec2.
   *
   * @param {Vec2} other - The other Vec2 to multiply with.
   * @return {Vec2} - Returns a new Vec2.
   */
  multiply(other) {
    return new Vec2(this.x * other.x, this.y * other.y)
  }

  /**
   * Multiplies a Vec2 with this Vec2.
   *
   * @param {Vec2} other - The other Vec2 to multiply with.
   */
  multiplyInPlace(other) {
    this.x *= other.x;
    this.y *= other.y;
  }

  /**
   * Calculates the squared length of this Vec2.
   *
   * @return {number} - Returns the length squared.
   */
  lengthSquared() {
    const x = this.__data[0];
    const y = this.__data[1];
    return x * x + y * y
  }

  /**
   * Calculates the length of this Vec2.
   *
   * @return {number} - Returns the length.
   */
  length() {
    return Math.sqrt(this.lengthSquared())
  }

  /**
   * Calculates the distance to another vector.
   *
   * @param {Vec2} other - The other value.
   * @return {number} - Returns the distance between vectors.
   */
  distanceTo(other) {
    const x = this.__data[0] - other.x;
    const y = this.__data[1] - other.y;
    return Math.sqrt(x * x + y * y)
  }

  /**
   * Normalizes the Vec2 and returns it as a new Vec2.
   * Multiplies coordenates value by the inverse of the vector length.
   *
   * @return {Vec2} - Returns the Vec2 normalized.
   */
  normalize() {
    const x = this.__data[0];
    const y = this.__data[1];
    let len = x * x + y * y;
    if (len < Number.EPSILON) {
      return new Vec2()
    }

    // TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    return new Vec2(x * len, y * len)
  }

  /**
   * Normalizes this Vec2 multiplying coordenate values by the inverse of the vector length.
   */
  normalizeInPlace() {
    const x = this.__data[0];
    const y = this.__data[1];
    let len = x * x + y * y;
    if (len < Number.EPSILON) {
      return
    }
    len = 1 / Math.sqrt(len);
    this.set(x * len, y * len);
  }

  /**
   * Calculates the dot product of this Vec2 against another Vec2.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {number} - Returns the dot product.
   */
  dot(other) {
    return this.x * other.x + this.y * other.y
  }

  /**
   * Calculates the cross product of this Vec2 against another Vec2.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {number} - Returns the cross product.
   */
  cross(other) {
    // just calculate the z-component
    return this.x * other.y - this.y * other.x
  }

  /**
   * Gets the angle between this Vec2 and other assuming both are normalized vectors.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {number} - Returns the angle in radians.
   */
  angleTo(other) {
    const cosine = this.normalize().dot(other.normalize());
    if (cosine > 1.0) return 0.0
    else if (cosine < -1.0) return Math.PI
    else return Math.acos(cosine)
  }

  /**
   * Gets the angle between this Vec2 and other.
   *
   * @param {Vec2} other - The other Vec2 to compare with.
   * @return {number} - Returns the angle in radians.
   */
  signedAngleTo(other) {
    const angle = this.angleTo(other);
    if (this.cross(other) < 0.0) return -angle
    else return angle
  }

  /**
   * Rotates a Vec2 in a clockwise direction and returns a new rotated Vec2.
   *
   * @param {number} angle - The angle of rotation.
   * @return {Vec2} - Returns the rotated vect  or.
   */
  rotate(angle) {
    const cosa = Math.cos(angle);
    const sina = Math.sin(angle);
    return new Vec2(this.x * cosa - this.y * sina, this.x * sina + this.y * cosa)
  }

  /**
   * Performs a linear interpolation between this Vec2 and other Vec2.
   *
   * @param {Vec2} other - The other Vec2 to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {Vec2} - Returns a new Vec2.
   */
  lerp(other, t) {
    const ax = this.x;
    const ay = this.y;
    return new Vec2(ax + t * (other.x - ax), ay + t * (other.y - ay))
  }

  /**
   * Generates a random vector with the given scale.
   *
   * @param {number} scale - Length of the resulting vector. If ommitted, a unit vector will be returned.
   * @return {Vec2} - The return value.
   */
  setRandomDir(scale = 1.0) {
    const r = Math.random() * 2.0 * Math.PI;
    this.__data[0] = Math.cos(r) * zScale;
    this.__data[1] = Math.sin(r) * zScale;
    return this
  }

  /**
   * Randomizes the scale of this Vec2 coordenates.
   *
   * @param {number} scale - The scale value.
   * @return {Vec2} - The return value.
   */
  setRandom(scale = 1.0) {
    this.__data[0] = Math.random() * scale;
    this.__data[1] = Math.random() * scale;
    return this
  }

  /**
   * Clones this Vec2 and returns a new Vec2.
   *
   * @return {Vec2} - Returns a new Vec2.
   */
  clone() {
    return new Vec2(this.__data[0], this.__data[1])
  }

  /**
   * Returns current Vec2 data as array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as an array.
   */
  asArray() {
    return this.__data
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Vec2.
   * @see `new Vec2`
   *
   * @param {...object} ...args - The ...args param.
   * @return {Vec2} - Returns a new Vec2.
   * @private
   */
  static create(...args) {
    return new Vec2(...args)
  }

  /**
   * Creates a new Vec2 to wrap existing memory in a buffer.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Vec2} - Returns a new Vec2.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Vec2` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Vec2} - Returns a new Vec2.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Vec2(new Float32Array(buffer, byteOffset, 2)) // 4 bytes per 32bit float
  }

  /**
   * The createFromFloat32Array method.
   * @param {Float32Array} array - The array value.
   * @return {Vec2} - Returns a new Vec2.
   * @private
   */
  static createFromFloat32Array(array) {
    return new Vec2(array)
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requi
   * ents for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 2
  }

  // ///////////////////////////
  // Persistence

  /**
   * Encodes Vec2 Class as a JSON object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
    }
  }

  /**
   * Decodes a JSON object to set the state of this class.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.x = j.x;
    this.y = j.y;
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.x = reader.loadFloat32();
    this.y = reader.loadFloat32();
  }
}

Registry.register('Vec2', Vec2);

/**
 * Represents a three dimensional coordinate, such as 3D scene values, or mesh vertex positions.
 *
 * Math types internally store values in {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} and
 * expose getters and setters for the component values.
 *
 * @extends AttrValue
 */
class Vec3$1 extends AttrValue {
  /**
   * Creates a Vec3.
   *
   * The type of values of the `(x, y, z)` coordenates can be {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array|Uint32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array|Int32Array} and
   * {@link https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/ArrayBuffer|ArrayBuffer}.
   * <br>
   * You can also pass one JSON object parameter.
   *
   * @param {Number|Float32Array|json} x - The x value. Default is 0.
   * @param {number} y - The y value. Default is 0.
   * @param {number} z - The z value. Default is 0.
   */
  constructor(x = 0, y = 0, z = 0) {
    super();
    if (x instanceof Float32Array || x instanceof Uint32Array) {
      this.__data = x;
    } else if (x instanceof ArrayBuffer) {
      console.warn(`deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 3))`);
      const buffer = x;
      const byteOffset = y;
      this.__data = new Float32Array(buffer, byteOffset, 3);
    } else if (x != null && typeof x == 'object') {
      this.__data = new Float32Array(3);
      this.fromJSON(x);
    } else {
      this.__data = new Float32Array(3);
      this.__data[0] = x;
      this.__data[1] = y;
      this.__data[2] = z;
    }
  }

  /**
   * Getter for `x` component.
   *
   * @return {number} - Returns the x component.
   */
  get x() {
    return this.__data[0]
  }

  /**
   * Setter for `x` component.
   *
   * @param {number} val - The val param.
   */
  set x(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for `y` component.
   *
   * @return {number} - Returns the y component.
   */
  get y() {
    return this.__data[1]
  }

  /**
   * Setter for `y` component.
   *
   * @param {number} val - The val param.
   */
  set y(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for `z` component.
   *
   * @return {number} - Returns the z component.
   */
  get z() {
    return this.__data[2]
  }

  /**
   * Setter for `z` component.
   *
   * @param {number} val - The val param.
   */
  set z(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for `xy` swizzel.
   *
   * @return {Vec2} - Returns the z component.
   */
  get xy() {
    return new Vec2(this.__data[0], this.__data[1])
  }

  /**
   * Getter for `yz` swizzel.
   *
   * @return {Vec2} - Returns the z component.
   */
  get yz() {
    return new Vec2(this.__data[1], this.__data[2])
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} x - The x component.
   * @param {number} y - The y component.
   * @param {number} z - The y component.
   */
  set(x, y, z) {
    this.x = x;
    this.y = y !== undefined ? y : x;
    this.z = z !== undefined ? z : x;
  }

  /**
   * Sets the state of a Vec3 Object.
   *
   * @param {Float32Array} float32Array - The float32Array value.
   */
  setDataArray(float32Array) {
    this.__data = float32Array;
  }

  /**
   * Sets the state of a Vec3 Object from another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to set from.
   */
  setFromOther(other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
  }

  /**
   * Checks if the coordenates of this Vec3 are 0 0 0.
   *
   * @return {boolean} - Returns `true` if the coordenates are(0, 0, 0), otherwise, `false`.
   */
  isNull() {
    return Math.abs(this.x) < Number.EPSILON && Math.abs(this.y) < Number.EPSILON && Math.abs(this.z) < Number.EPSILON
  }

  /**
   * Checks if the coordenates of this Vec3 are 1 1 1.
   *
   * @return {boolean} - Returns `true` if the coordenates are(1, 1, 1), otherwise, `false`.
   */
  is111() {
    return (
      Math.abs(1.0 - this.x) < Number.EPSILON &&
      Math.abs(1.0 - this.y) < Number.EPSILON &&
      Math.abs(1.0 - this.z) < Number.EPSILON
    )
  }

  /**
   * @deprecated
   * Checks if this Vec3 is exactly the same as another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {boolean} - Returns `true` if are the same Vector, otherwise, `false`.
   */
  equal(other) {
    console.warn('Deprecated. Use #isEqual instead.');
    return this.equals(other)
  }

  /**
   * Checks if this Vec3 is exactly the same as another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {boolean} - Returns `true` if are the same Vector, otherwise, `false`.
   */
  isEqual(other) {
    return this.x == other.x && this.y == other.y && this.z == other.z
  }

  /**
   * @deprecated
   * Checks if this Vec2 is different from another Vec2.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {boolean} - Returns `true` if the Vec3s are different, otherwise, `false`.
   */
  notEquals(other) {
    console.warn('Deprecated. Use #notEqual instead.');
    return this.notEqual(other)
  }

  /**
   * Checks if this Vec2 is different from another Vec2.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {boolean} - Returns `true` if the Vec3s are different, otherwise, `false`.
   */
  notEqual(other) {
    return this.x != other.x && this.y != other.y && this.z != other.z
  }

  /**
   * Returns true if this Vec2 is approximately the same as other.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      Math.abs(this.x - other.x) < precision &&
      Math.abs(this.y - other.y) < precision &&
      Math.abs(this.z - other.z) < precision
    )
  }

  /**
   * Adds other to this Vec3 and return the result as a new Vec3.
   *
   * @param {Vec3} other - The other Vec3 to add.
   * @return {Vec3} - Returns a new Vec3.
   */
  add(other) {
    return new Vec3$1(this.x + other.x, this.y + other.y, this.z + other.z)
  }

  /**
   * Adds other to this Vec3.
   *
   * @param {Vec3} other - The other Vec3 to add.
   */
  addInPlace(other) {
    this.x += other.x;
    this.y += other.y;
    this.z += other.z;
  }

  /**
   * Subtracts other from this Vec3 and returns the result as a new Vec3.
   *
   * @param {Vec3} other - The other Vec3 to subtract.
   * @return {Vec3} - Returns a new Vec3.
   */
  subtract(other) {
    return new Vec3$1(this.x - other.x, this.y - other.y, this.z - other.z)
  }

  /**
   * Subtracts other from this Vec3.
   *
   * @param {Vec3} other - The other Vec3 to subtract.
   */
  subtractInPlace(other) {
    this.x -= other.x;
    this.y -= other.y;
    this.z -= other.z;
  }

  /**
   * Multiplies two Vec3s and returns the result as a new Vec3.
   *
   * @param {Vec3} other - The other Vec3 to multiply with.
   * @return {Vec3} - Returns a new Vec3.
   */
  multiply(other) {
    return new Vec3$1(this.x * other.x, this.y * other.y, this.z * other.z)
  }

  /**
   * Multiplies two Vec3s.
   *
   * @param {Vec3} other - The other Vec3 to multiply with.
   */
  multiplyInPlace(other) {
    this.x *= other.x;
    this.y *= other.y;
    this.z *= other.z;
  }

  /**
   * Divides two Vec3s and returns the result as a new Vec3.
   *
   * @param {Vec3} vec3 - The other Vec3 to divide by.
   * @return {Vec3} - Returns a new Vec3.
   */
  divide(vec3) {
    return new Vec3$1(this.x / vec3.x, this.y / vec3.y, this.z / vec3.z)
  }

  /**
   * Divides two Vec3s.
   *
   * @param {Vec3} vec3 - The other Vec3 to divide by.
   */
  divideInPlace(vec3) {
    this.x /= vec3.x;
    this.y /= vec3.y;
    this.z /= vec3.z;
  }

  /**
   * Scales this Vec3 by scalar and returns the result as a new Vec3.
   *
   * @param {number} scalar - The scalar value.
   * @return {Vec3} - Returns a new Vec3.
   */
  scale(scalar) {
    return new Vec3$1(this.x * scalar, this.y * scalar, this.z * scalar)
  }

  /**
   * Scales this Vec3 by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  }

  /**
   * Negates this Vec3 (x = -x, y = -y and z = -z), but returns the result as a new Vec3.
   *
   * @return {Vec3} - Returns a new Vec3.
   */
  negate() {
    return new Vec3$1(-this.x, -this.y, -this.z)
  }

  /**
   * Returns the inverse of this Vec3, but returns. the result as a new Vec3
   *
   * @return {Vec3} - Returns a new Vec3.
   */
  inverse() {
    return new Vec3$1(1.0 / this.x, 1.0 / this.y, 1.0 / this.z)
  }

  /**
   * Calculates the squared length of this Vec3.
   *
   * @return {number} - Returns the length.
   */
  lengthSquared() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    return x * x + y * y + z * z
  }

  /**
   * Calculates the length of this Vec3.
   *
   * @return {number} - Returns the length.
   */
  length() {
    return Math.sqrt(this.lengthSquared())
  }

  /**
   * Calculates the distance to another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to calculate the distance to.
   * @return {number} - Returns the distance between vectors.
   */
  distanceTo(other) {
    const x = this.__data[0] - other.x;
    const y = this.__data[1] - other.y;
    const z = this.__data[2] - other.z;
    return Math.sqrt(x * x + y * y + z * z)
  }

  /**
   * Normalizes the Vec3 and returns it as a new Vec3.
   * Multiplies coordenates value by the inverse of the vector length.
   *
   * @return {Vec3} - Returns the Vec3 normalized.
   */
  normalize() {
    let len = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
    if (len < Number.EPSILON) {
      return new Vec3$1()
    }

    // TODO: evaluate use of glm_invsqrt here?
    len = 1.0 / Math.sqrt(len);
    return new Vec3$1(this.__data[0] * len, this.__data[1] * len, this.__data[2] * len)
  }

  /**
   * Normalizes this Vec3 multiplying coordenate values by the inverse of the vector length.
   *
   * @return {number} - The return value.
   */
  normalizeInPlace() {
    let len = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
    if (len < Number.EPSILON) {
      return
    }
    len = Math.sqrt(len);
    const tmp = 1.0 / len;
    this.__data[0] *= tmp;
    this.__data[1] *= tmp;
    this.__data[2] *= tmp;

    return len
  }

  /**
   * Creates and returns a new Vec3 with the new coordenates(calculated with this Vec3 coordenates and the specified length).
   *
   * @param {number} length - The length value.
   * @return {Vec3} - The return value.
   */
  resize(length) {
    const currlen = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
    if (currlen < Number.EPSILON) {
      return
    }
    const scl = length / Math.sqrt(currlen);
    return new Vec3$1(this.__data[0] * scl, this.__data[1] * scl, this.__data[2] * scl)
  }

  /**
   * Modifies current coordenates using the specified length.
   *
   * @param {number} length - The length value.
   */
  resizeInPlace(length) {
    const currlen = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
    if (currlen < Number.EPSILON) {
      return
    }
    const scl = length / Math.sqrt(currlen);
    this.__data[0] *= scl;
    this.__data[1] *= scl;
    this.__data[2] *= scl;
  }

  /**
   * Calculates the dot product of this Vec3 against another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {number} - Returns the dot product.
   */
  dot(other) {
    return this.x * other.x + this.y * other.y + this.z * other.z
  }

  /**
   * Calculates the cross product of two Vec3s and returns the result as a new Vec3.
   *
   * @param {Vec3} other - The other Vec3 to calculate with.
   * @return {Vec3} - Returns the cross product as a new Vec3.
   */
  cross(other) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const bx = other.x;
    const by = other.y;
    const bz = other.z;

    return new Vec3$1(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)
  }

  /**
   * Gets the angle between this Vec3 and b.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {number} - Returns the angle in radians.
   */
  angleTo(other) {
    const cosine = this.dot(other);
    if (cosine > 1.0) {
      return 0
    } else {
      return Math.acos(cosine)
    }
  }

  /**
   * Performs a linear interpolation between this Vec3 and other.
   *
   * @param {Vec3} other - The other Vec3 to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {Vec3} - Returns a new Vec3.
   */
  lerp(other, t) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    return new Vec3$1(ax + t * (other.x - ax), ay + t * (other.y - ay), az + t * (other.z - az))
  }

  /**
   * Returns a new Vec3 whose component values are the abs of this Vec3s component values.
   *
   * @return {Vec3} - Returns a new Vec3.
   */
  abs() {
    return new Vec3$1(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z))
  }

  /**
   * Sets the vector a random vector on the surface of a sphere with the radius of the givenn scale value.
   *
   * @param {number} scale - The radius of the surface sphere.
   * @return {Vec3} - The random Vec3.
   */
  setRandomDir(scale = 1.0) {
    const r = Math.random() * 2.0 * Math.PI;
    const z = Math.random() * 2.0 - 1.0;
    const zScale = Math.sqrt(1.0 - z * z) * scale;

    this.__data[0] = Math.cos(r) * zScale;
    this.__data[1] = Math.sin(r) * zScale;
    this.__data[2] = z * scale;
    return this
  }

  /**
   * Generates a randome vector anywhere in the sphere defined by the provided scale value.
   *
   * @param {number} scale - The radius of the bounding sphere.
   * @return {Vec3} - The random Vec3.
   */
  setRandom(scale = 1.0) {
    this.__data[0] = (Math.random() - 0.5) * scale;
    this.__data[1] = (Math.random() - 0.5) * scale;
    this.__data[2] = (Math.random() - 0.5) * scale;
    return this
  }

  /**
   * Clones this Vec3 and returns a new Vec3.
   *
   * @return {Vec3} - Returns a new Vec3.
   */
  clone() {
    return new Vec3$1(this.__data[0], this.__data[1], this.__data[2])
  }

  /**
   * Returns the type as an array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as an array.
   */
  asArray() {
    return this.__data
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Vec3.
   *
   * @param {...object} ...args - The ...args param.
   * @return {Vec3} - Returns a new Vec3.
   * @private
   */
  static create(...args) {
    return new Vec3$1(...args)
  }

  /**
   * The createFromJSON method.
   * @param {object} json - The json param.
   * @return {Vec3} - The return value.
   * @private
   */
  static createFromJSON(json) {
    const result = new Vec3$1();
    result.fromJSON(json);
    return result
  }

  /**
   * The createFromFloat32Buffer method.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Vec3} - Returns a new Vec3.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Vec3` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Vec3} - Returns a new Vec3.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Vec3$1(new Float32Array(buffer, byteOffset, 3)) // 4 bytes per 32bit float
  }

  /**
   * The createFromFloat32Array method.
   * @param {Float32Array} array - A Float32Array value
   * @return {Vec3} - Returns a new Vec3.
   * @private
   */
  static createFromFloat32Array(array) {
    return new Vec3$1(array)
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 3
  }

  // ///////////////////////////
  // Persistence

  /**
   * Encodes Vec3 Class as a JSON object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    }
  }

  /**
   * Decodes a JSON object to set the state of this class.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.x = j.x;
    this.y = j.y;
    this.z = j.z;
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.x = reader.loadFloat32();
    this.y = reader.loadFloat32();
    this.z = reader.loadFloat32();
  }
}

Registry.register('Vec3', Vec3$1);

/* eslint-disable new-cap */
/**
 * Represents a four-dimensional coordinate.
 * Math types internally store values in {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} and
 * expose getters and setters for the component values.
 *
 * @extends AttrValue
 */
class Vec4$1 extends AttrValue {
  /**
   /**
   * Creates a Vec4.
   *
   * The type of values of the `(x, y, z, t)` coordinates can be {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array|Uint32Array},
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array|Int32Array} and
   * {@link https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/ArrayBuffer|ArrayBuffer}.
   * <br>
   * You can also pass one JSON object parameter.
   * 
   * @param {Number|Float32Array|json} x - The x value. Default is 0.
   * @param {number} y - The y value. Default is 0.
   * @param {number} z - The y value. Default is 0.
   * @param {number} t - The t value. Default is 0.
   */
  constructor(x = 0, y = 0, z = 0, t = 0) {
    super();

    if (x instanceof Float32Array || x instanceof Uint32Array) {
      this.__data = x;
    } else if (x instanceof ArrayBuffer) {
      console.warn(`deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))`);
      const buffer = x;
      const byteOffset = y;
      this.__data = new Float32Array(buffer, byteOffset, 4);
    } else if (x != null && typeof x == 'object') {
      this.__data = new Float32Array(4);
      this.fromJSON(x);
    } else {
      this.__data = new Float32Array(4);
      this.__data[0] = x;
      this.__data[1] = y;
      this.__data[2] = z;
      this.__data[3] = t;
    }
  }

  /**
   * Getter for `x` value.
   *
   * @return {number} - Returns the x value.
   */
  get x() {
    return this.__data[0]
  }

  /**
   * Setter for `x` value.
   *
   * @param {number} val - The val param.
   */
  set x(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for `y` value.
   *
   * @return {number} - Returns the y value.
   */
  get y() {
    return this.__data[1]
  }

  /**
   * Setter for `y` value.
   *
   * @param {number} val - The val param.
   */
  set y(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for `z` value.
   *
   * @param {number} val - The val param.
   */
  get z() {
    return this.__data[2]
  }

  /**
   * Setter for `z` value.
   *
   * @param {number} val - The val param.
   */
  set z(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for `t` value.
   *
   * @param {number} val - The val param.
   */
  get t() {
    return this.__data[3]
  }

  /**
   * Setter for `t` value.
   *
   * @param {number} val - The val param.
   */
  set t(val) {
    this.__data[3] = val;
  }

  /**
   * Getter for `xy` swizzel.
   *
   * @return {number} - Returns the z value.
   */
  get xyz() {
    return new Vec3$1(this.__data[0], this.__data[1], this.__data[2])
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} x - The x value.
   * @param {number} y  - The y value.
   * @param {number} z  - The y value.
   * @param {number} t  - The t value.
   */
  set(x, y, z, t) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.t = t;
  }

  /**
   * Sets the state of a Vec4 Object from another Vec4.
   *
   * @param {Vec4} other - The other Vec4 to set from.
   */
  setFromOther(other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
    this.t = other.t;
  }

  /**
   * Checks if this Vec4 is exactly the same as another Vec4.
   *
   * @deprecated
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {boolean} - Returns true or false.
   */
  equal(other) {
    console.warn('Deprecated. Use #isEqual instead.');
    return this.isEqual(other)
  }

  /**
   * Checks if this Vec4 is exactly the same as another Vec4.
   *
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {boolean} - Returns true or false.
   */
  isEqual(other) {
    return this.x == other.x && this.y == other.y && this.z == other.z && this.t == other.t
  }

  /**
   * Checks if this Vec4 is different from another Vec4.
   *
   * @deprecated
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {boolean} - Returns true or false.
   */
  notEquals(other) {
    console.warn('Deprecated. Use #notEqual instead.');
    return this.notEqual(other)
  }

  /**
   * Checks if this Vec4 is different from another Vec4.
   *
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {boolean} - Returns true or false.
   */
  notEqual(other) {
    return this.x != other.x && this.y != other.y && this.z != other.z && this.t != other.t
  }

  /**
   * Returns true if this Vec4 is approximately the same as other.
   *
   * @param {Vec4} other - The other Vec4 to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - The return value.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      Math.abs(this.x - other.x) < precision &&
      Math.abs(this.y - other.y) < precision &&
      Math.abs(this.z - other.z) < precision &&
      Math.abs(this.t - other.t) < precision
    )
  }

  /**
   * Adds other to this Vec4 and returns the result as a new Vec4.
   *
   * @param {Vec4} other - The other Vec4 to add.
   * @return {Vec4} - Returns a new Vec4.
   */
  add(other) {
    return new Vec4$1(this.x + other.x, this.y + other.y, this.z + other.z, this.t + other.t)
  }

  /**
   * Adds other to this Vec4 mutating the values of this instance
   *
   * @param {Vec4} other - The other Vec4 to add.
   */
  addInPlace(other) {
    this.x += other.x;
    this.y += other.y;
    this.z += other.z;
    this.t += other.t;
  }

  /**
   * Subtracts other from this Vec4 and returns then result as a new Vec4.
   *
   * @param {Vec4} other - The other Vec4 to subtract.
   * @return {Vec4} - Returns a new Vec4.
   */
  subtract(other) {
    return new Vec4$1(this.x - other.x, this.y - other.y, this.z - other.z, this.t - other.t)
  }

  /**
   * Subtracts other from this Vec4 mutating the values of this instance
   *
   * @param {Vec4} other - The other Vec4 to subtract.
   */
  subtractInPlace(other) {
    this.x -= other.x;
    this.y -= other.y;
    this.z -= other.z;
    this.t -= other.t;
  }

  /**
   * Multiplies two Vec4s and returns the result as a new Vec4.
   *
   * @param {Vec4} other - The other Vec4 to multiply with.
   * @return {Vec4} - Returns a new Vec4.
   */
  multiply(other) {
    return new Vec4$1(this.x * other.x, this.y * other.y, this.z * other.z, this.t * other.t)
  }

  /**
   * Multiplies two Vec4s mutating the values of this instance
   *
   * @param {Vec4} other - The other Vec4 to multiply with.
   */
  multiplyInPlace(other) {
    this.x *= other.x;
    this.y *= other.y;
    this.z *= other.z;
    this.t *= other.t;
  }

  /**
   * Divides two Vec4s and returns the result as a new Vec4.
   *
   * @param {Vec4} other - The other Vec4 to divide by.
   * @return {Vec4} - Returns a new Vec4.
   */
  divide(other) {
    return new Vec4$1(this.x / other.x, this.y / other.y, this.z / other.z, this.t / other.t)
  }

  /**
   * Divides two Vec4s.
   *
   * @param {Vec4} other - The other Vec4 to divide by.
   */
  divideInPlace(other) {
    this.x /= other.x;
    this.y /= other.y;
    this.z /= other.z;
    this.t /= other.t;
  }

  /**
   * Scales this Vec4 by scalar and returns the result as a new Vec4.
   *
   * @param {number} scalar - The scalar value.
   * @return {Vec4} - The return value.
   */
  scale(scalar) {
    return new Vec4$1(this.x * scalar, this.y * scalar, this.z * scalar, this.t * scalar)
  }

  /**
   * Scales this Vec4 by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.set(this.x * scalar, this.y * scalar, this.z * scalar, this.t * scalar);
  }

  /**
   * Calculates the length of this Vec4.
   *
   * @return {number} - Returns the length.
   */
  length() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const t = this.__data[2];
    return Math.sqrt(x * x + y * y + z * z + t * t)
  }

  /**
   * Calculates the squared length of this Vec4.
   *
   * @return {number} - Returns the length.
   */
  lengthSquared() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const t = this.__data[3];
    return x * x + y * y + z * z + t * t
  }

  /**
   * Normalizes the Vec4 and returns it as a new Vec4.
   * Multiplies coordenates value by the inverse of the vector length.
   *
   * @return {Vec4} - Returns the Vec4 normalized.
   */
  normalize() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const t = this.__data[3];
    let len = x * x + y * y + z * z + t * t;
    if (len < Number.EPSILON) {
      return new Vec4$1()
    }

    // TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    return new Vec4$1(x * len, y * len, z * len)
  }

  /**
   * Normalizes this Vec4 multiplying coordenate values by the inverse of the vector length.
   */
  normalizeInPlace() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const t = this.__data[3];
    let len = x * x + y * y + z * z + t * t;
    if (len < Number.EPSILON) {
      return
    }
    len = 1 / Math.sqrt(len);
    this.set(x * len, y * len, z * len, t * len);
  }

  /**
   * Calculates the dot product of this Vec4 against another Vec4.
   *
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {number} - Returns the dot product.
   */
  dot(other) {
    return this.x * other.x + this.y * other.y + this.z * other.z + this.t * b.t
  }

  /**
   * Calculates the cross product of two Vec4s and returns the result as a new Vec4.
   *
   * @param {Vec4} other - The other Vec4 to calculate with.
   * @return {Vec4} - Returns the cross product as a new Vec4.
   */
  cross(other) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const at = this.t;
    const bx = other.x;
    const by = other.y;
    const bz = other.z;
    const bt = other.t;

    return new Vec4$1(ay * bz - az * by, az * bt - at * bz, at * bx - ax * bt, ax * by - ay * bx)
  }

  /**
   * Gets the angle between this Vec4 and b.
   *
   * @param {Vec4} other - The other Vec4 to compare with.
   * @return {number} - Returns the angle in radians.
   */
  angleTo(other) {
    const tempA = this.normalize();
    const tempB = other.normalize();
    const cosine = tempA.dot(tempB);

    if (cosine > 1.0) {
      return 0
    } else {
      return Math.acos(cosine)
    }
  }

  /**
   * Performs a linear interpolation between this Vec4 and other.
   *
   * @param {Vec4} other - The other Vec4 to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {Vec4} - Returns a new Vec4.
   */
  lerp(other, t) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    at = this.t;
    return new Vec4$1(ax + t * (other.x - ax), ay + t * (other.y - ay), az + t * (other.z - az), at + t * (other.t - at))
  }

  /**
   * Generates a random vector with the given scale.
   *
   * @param {number} scale - Length of the resulting vector. If ommitted, a unit vector will be returned.
   * @return {Vec4} - The return value.
   */
  random(scale = 1.0) {
    const r = glMatrix.RANDOM() * 2.0 * Math.PI;
    const z = glMatrix.RANDOM() * 2.0 - 1.0;
    const zScale = Math.sqrt(1.0 - z * z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out
  }

  /**
   * Clones this Vec4 and returns a new Vec4.
   *
   * @return {Vec4} - Returns a new Vec4.
   */
  clone() {
    return new Vec4$1(this.__data[0], this.__data[1], this.__data[2], this.__data[3])
  }

  /**
   * Converts this Vec4 into a Vec3.
   *
   * @return {Vec3} - Returns the value as a new Vec3.
   */
  toVec3() {
    return new Vec3$1(this.__data[0], this.__data[1], this.__data[2])
  }

  /**
   * Returns the type as an array. Often used to pass types to the GPU.
   *
   * @return {aray} - Returns as an array.
   */
  asArray() {
    return this.__data
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Vec3.
   * @param {...object} ...args - The ...args param.
   * @return {Vec3} - Returns a new Vec3.
   * @private
   */
  static create(...args) {
    return new Vec3$1(...args)
  }

  /**
   * Creates a new Vec4 to wrap existing memory in a buffer.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Vec4} - Returns a new Vec3.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return new Vec4$1(new Float32Array(buffer, offset * 4, 4)) // 4 bytes per 32bit float
  }

  /**
   * Creates an instance of a `Vec4` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Vec4} - Returns a new Vec4.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Vec4$1(new Float32Array(buffer, byteOffset, 4)) // 4 bytes per 32bit float
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 4
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      t: this.t,
    }
  }

  /**
   * Decodes a JSON object to set the state of this class.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.x = j.x;
    this.y = j.y;
    this.z = j.z;
    this.t = j.t;
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.x = reader.loadFloat32();
    this.y = reader.loadFloat32();
    this.z = reader.loadFloat32();
    this.t = reader.loadFloat32();
  }
}

Registry.register('Vec4', Vec4$1);

/* eslint-disable require-jsdoc */

/**
 * Class representing the red, green, blue and alpha channel of a color.
 *
 * @extends AttrValue
 */
class RGBA extends AttrValue {
  /**
   * Create a RGBA.
   * @param {number | string | Float32Array | ArrayBuffer} r - The red channel of a color.
   * @param {number} g - The green channel of a color.
   * @param {number} b - The blue channel of a color.
   * @param {number} a - The alpha (transparency) channel of a color.
   */
  constructor(r = 0, g = 0, b = 0, a = 255) {
    super();

    if (r instanceof Uint8Array) {
      this.__data = r;
    } else if (r instanceof ArrayBuffer) {
      const buffer = r;
      const byteOffset = g;
      this.__data = new Uint8Array(buffer, byteOffset, 4);
    } else {
      this.__data = new Uint8Array(4);
      if (typeof r == 'string') {
        if (r.startsWith('#')) {
          this.setFromHex(r);
        } else {
          this.setFromCSSColorName(r);
        }
      } else {
        this.__data[0] = r;
        this.__data[1] = g;
        this.__data[2] = b;
        this.__data[3] = a;
      }
    }
  }

  /**
   * Getter for red channel.
   *
   * @return {RGBA} - Returns the red channel.
   */
  get r() {
    return this.__data[0]
  }

  /**
   * Setter for red channel.
   *
   * @param {number} val - The val param.
   */
  set r(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for green channel.
   *
   * @return {RGBA} - Returns the green channel.
   */
  get g() {
    return this.__data[1]
  }

  /**
   * Setter for green channel.
   *
   * @param {number} val - The val param.
   */
  set g(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for blue channel.
   *
   * @return {RGBA} - Returns the blue channel.
   */
  get b() {
    return this.__data[2]
  }

  /**
   * Setter for blue channel.
   *
   * @param {number} val - The val param.
   */
  set b(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for alpha channel.
   *
   * @return {RGBA} - Returns the alpha channel.
   */
  get a() {
    return this.__data[3]
  }
  /**
   * Setter for alpha value.
   *
   * @param {number} val - The val param.
   */
  set a(val) {
    this.__data[3] = val;
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} r - The red channel.
   * @param {number} g  - The green channel.
   * @param {number} b  - The blue channel.
   * @param {number} a  - The alpha channel.
   */
  set(r, g, b, a = 255) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  /**
   * Setter from another RGBA color.
   *
   * @param {RGBA} other - The other RGBA to set from.
   */
  setFromOther(other) {
    this.r = other.r;
    this.g = other.g;
    this.b = other.b;
    this.a = other.a;
  }

  /**
   * Setter from a scalar array.
   *
   * @param {array} vals - The vals param.
   */
  setFromArray(vals) {
    this.r = vals[0];
    this.g = vals[1];
    this.b = vals[2];
    this.a = vals.length == 4 ? vals[3] : 1.0;
  }

  /**
   * Setter from a hexadecimal value.
   * E.g. #ff0000
   *
   * @param {number} hex - The hex value.
   */
  setFromHex(hex) {
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : null
    }
    const rgb = hexToRgb(hex);
    if (!rgb) {
      console.warn('Invalid hex code:' + hex);
      return
    }
    this.set(rgb.r, rgb.g, rgb.b);
  }

  /**
   * Setter from a CSS color name.
   * E.g. "red"
   *
   * @param {string} name - The CSS color name.
   */
  setFromCSSColorName(name) {
    const colourNameToHex = (colour) => {
      const colors = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        'indianred ': '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgrey: '#d3d3d3',
        lightgreen: '#90ee90',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370d8',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#d87093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
      };

      if (typeof colors[colour.toLowerCase()] != 'undefined') return colors[colour.toLowerCase()]

      return false
    };
    if (name.startsWith('#')) {
      this.setFromHex(name);
    } else {
      this.setFromHex(colourNameToHex(name));
    }
  }

  /**
   * Returns the hexadecimal value of this RGBA color.
   *
   * @return {string} - Returns the hex value.
   */
  toHex() {
    function componentToHex(int) {
      const hex = int.toString(16);
      return hex.length == 1 ? '0' + hex : hex
    }
    return '#' + componentToHex(this.r) + componentToHex(this.g) + componentToHex(this.b)
  }

  /**
   * Returns true if this RGBA color is exactly the same as other.
   *
   * @param {RGBA} other - The other RGBA to compare with.
   * @return {boolean} - Returns true or false.
   */
  equal(other) {
    return this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a
  }

  /**
   * Returns true if this RGBA color is NOT exactly the same as other.
   *
   * @param {RGBA} other -  The other RGBA to compare with.
   * @return {boolean} - Returns true or false.
   */
  notEquals(other) {
    return this.r != other.r && this.g != other.g && this.b != other.b && this.a != other.a
  }

  /**
   * Returns true if this RGBA color is approximately the same as other.
   *
   * @param {RGBA} other - The other RGBA to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      Math.abs(this.r - other.r) < precision &&
      Math.abs(this.g - other.g) < precision &&
      Math.abs(this.b - other.b) < precision &&
      Math.abs(this.a - other.a) < precision
    )
  }

  /**
   * Returns a new RGBA color which is this RGBA color added to other.
   *
   * @param {RGBA} other - The other RGBA to add.
   * @return {RGBA} - Returns a new RGBA.
   */
  add(other) {
    return new RGBA(this.r + other.r, this.g + other.g, this.b + other.b, this.a + other.a)
  }

  /**
   * Returns a new RGBA color which is this RGBA color subtracted from other.
   *
   * @param {RGBA} other - The other RGBA to subtract.
   * @return {RGBA} - Returns a new RGBA.
   */
  subtract(other) {
    return new RGBA(this.r - other.r, this.g - other.g, this.b - other.b, this.a - other.a)
  }

  /**
   * Returns a new RGBA color which is this vector scaled by scalar.
   *
   * @param {number} scalar - The scalar value.
   * @return {RGBA} - Returns a new RGBA.
   */
  scale(scalar) {
    return new RGBA(this.r * scalar, this.g * scalar, this.b * scalar, this.a * scalar)
  }

  /**
   * Scales this RGBA color by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.r *= scalar;
    this.g *= scalar;
    this.b *= scalar;
    this.a *= scalar;
  }

  /**
   * Apply gamma correction to this RGBA color.
   *
   * @param {number} gamma - The gamma value.
   */
  applyGamma(gamma) {
    this.set(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
  }

  /**
   * Converts to linear color space and returns a new color.
   * @param {number} gamma - The gamma value.
   * @return {Color} - Returns a new RGBA.
   */
  toLinear(gamma = 2.2) {
    return new RGBA(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a)
  }

  /**
   * Converts to gamma color space and returns a new RGBA color.
   *
   * @param {number} gamma - The gamma value.
   * @return {RGBA} - Returns a new RGBA.
   */
  toGamma(gamma = 2.2) {
    return new RGBA(Math.pow(this.r, 1.0 / gamma), Math.pow(this.g, 1.0 / gamma), Math.pow(this.b, 1.0 / gamma), this.a)
  }

  /**
   * Calculates and returns the relative luminance of the linear RGB component.
   *
   * @return {number} - The return value.
   */
  luminance() {
    return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b
  }

  /**
   * Performs a linear interpolation between this RGBA color and other.
   *
   * @param {RGBA} other - The other RGBA to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {RGBA} - Returns a new RGBA.
   */
  lerp(other, t) {
    const ar = this.r;
    const ag = this.g;
    const ab = this.b;
    const aa = this.a;
    return new RGBA(ar + t * (other.r - ar), ag + t * (other.g - ag), ab + t * (other.b - ab), aa + t * (other.a - aa))
  }

  /**
   * Creates a random RGBA.
   *
   * @param {number} gammaOffset - The gamma offset.
   * @param {boolean} randomAlpha - Determines whether the alpha channel is random.
   * @return {RGBA} - Returns a new random RGBA.
   */
  static random(gammaOffset = 0.0, randomAlpha = false) {
    if (gammaOffset > 0.0) {
      return new RGBA(
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        randomAlpha ? gammaOffset + Math.random() * (1.0 - gammaOffset) : 1.0
      )
    } else if (gammaOffset < 0.0) {
      return new RGBA(
        Math.random() * (1.0 + gammaOffset),
        Math.random() * (1.0 + gammaOffset),
        Math.random() * (1.0 + gammaOffset),
        randomAlpha ? Math.random() * (1.0 + gammaOffset) : 1.0
      )
    } else {
      return new RGBA(Math.random(), Math.random(), Math.random(), randomAlpha ? Math.random() : 1.0)
    }
  }

  /**
   * Clones this RGBA color and returns a new RGBA color.
   *
   * @return {RGBA} - Returns a new RGBA.
   */
  clone() {
    return new RGBA(this.__data[0], this.__data[1], this.__data[2], this.__data[3])
  }

  /**
   * Returns the type as an array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as an array.
   */
  asArray() {
    return this.__data
  }

  /**
   * Returns the type as a 3 component array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as a 3 component array.
   */
  as3ComponentArray() {
    return [this.__data[0], this.__data[1], this.__data[2]]
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new RGBA color.
   * @param {...object} ...args - The ...args param.
   * @return {RGBA} - Returns a new RGBA.
   * @private
   */
  static create(...args) {
    return new RGBA(...args)
  }

  /**
   * The createFromFloat32Buffer method.
   *
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {RGBA} - Returns a new color.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `RGBA` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {RGBA} - Returns a new RGBA.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new RGBA(new Uint8Array(buffer, byteOffset, 4)) // 4 bytes per 32bit float
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 4
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.r = j.r;
    this.g = j.g;
    this.b = j.b;
    this.a = j.a;
  }

  /**
   * Returns the CSS rgba string.
   *
   * @return {string} - The return value.
   */
  toCSSString() {
    return (
      'rgba(' +
      Math.round(this.r * 255) +
      ', ' +
      Math.round(this.g * 255) +
      ', ' +
      Math.round(this.b * 255) +
      ', ' +
      this.a +
      ')'
    )
  }
}

Registry.register('RGBA', RGBA);

/* eslint-disable require-jsdoc */

/**
 * Class representing a color as 4 floating point values.
 *
 * @extends AttrValue
 */
class Color extends AttrValue {
  /**
   * Creates a `Color` object with an RGBA structure.
   *
   * @param {number | string | Float32Array | ArrayBuffer} r - The red channel of a color.
   * @param {number} g - The green channel of a color.
   * @param {number} b - The blue channel of a color.
   * @param {number} a - The alpha (transparency) channel of a color.
   */
  constructor(r = 0, g = 0, b = 0, a = 1.0) {
    super();

    if (r instanceof Float32Array) {
      this.__data = r;
    } else if (r instanceof ArrayBuffer) {
      console.warn(`deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))`);
      const buffer = r;
      const byteOffset = g;
      this.__data = new Float32Array(buffer, byteOffset, 4);
    } else {
      this.__data = new Float32Array(4);
      if (typeof r == 'string') {
        if (r.startsWith('#')) {
          this.setFromHex(r);
        } else {
          this.setFromCSSColorName(r);
        }
      } else {
        this.__data[0] = r;
        this.__data[1] = g;
        this.__data[2] = b;
        this.__data[3] = a;
      }
    }
  }

  /**
   * Getter for red channel.
   *
   * @return {number} - Returns the red channel.
   */
  get r() {
    return this.__data[0]
  }

  /**
   * Setter for red channel.
   *
   * @param {number} val - The val param.
   */
  set r(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for green channel.
   *
   * @return {number} - Returns the green channel.
   */
  get g() {
    return this.__data[1]
  }

  /**
   * Setter for green channel.
   * @param {number} val - The val param.
   */
  set g(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for blue channel.
   *
   * @return {number} - Returns the blue channel.
   */
  get b() {
    return this.__data[2]
  }

  /**
   * Setter for blue channel.
   *
   * @param {number} val - The val param.
   */
  set b(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for alpha channel.
   *
   * @return {number} - Returns the alpha channel.
   */
  get a() {
    return this.__data[3]
  }
  /**
   * Setter for alpha value.
   *
   * @param {number} val - The val param.
   */
  set a(val) {
    this.__data[3] = val;
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} r - The red channel.
   * @param {number} g  - The green channel.
   * @param {number} b  - The blue channel.
   * @param {number} a  - The alpha channel.
   */
  set(r, g, b, a = 1.0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  /**
   * Sets current color state with another `Color` object.
   *
   * @param {Color} other - The other color to set from.
   */
  setFromOther(other) {
    this.r = other.r;
    this.g = other.g;
    this.b = other.b;
    this.a = other.a;
  }

  /**
   * Setter from a scalar array.
   *
   * @param {Float32Array} vals - The vals param.
   */
  setFromScalarArray(vals) {
    this.r = vals[0];
    this.g = vals[1];
    this.b = vals[2];
    this.a = vals.length == 4 ? vals[3] : 1.0;
  }

  /**
   * Getter from an RGB array.
   *
   * @return {array} - The return value.
   */
  getAsRGBArray() {
    return [this.r * 255, this.g * 255, this.b * 255]
  }

  /**
   * Getter from an RGB dict.
   *
   * @return {object} - The return value.
   */
  getAsRGBDict() {
    return {
      r: this.r * 255,
      g: this.g * 255,
      b: this.b * 255,
    }
  }

  /**
   * Setter from a RGB value.
   *
   * @param {number} r - The red channel.
   * @param {number} g  - The green channel.
   * @param {number} b  - The blue channel.
   * @param {number} a  - The alpha channel.
   */
  setFromRGB(r, g, b, a) {
    this.r = r / 255;
    this.g = g / 255;
    this.b = b / 255;
    this.a = a ? a / 255 : 1.0;
  }

  /**
   * Setter from an RGB array.
   *
   * @param {Float32Array} vals - The vals param.
   */
  setFromRGBArray(vals) {
    this.r = vals[0] / 255;
    this.g = vals[1] / 255;
    this.b = vals[2] / 255;
    this.a = vals.length == 4 ? vals[3] / 255 : 1.0;
  }

  /**
   * Setter from an RGB dict.
   *
   * @param {Float32Array} vals - The vals param.
   */
  setFromRGBDict(vals) {
    this.r = vals.r / 255;
    this.g = vals.g / 255;
    this.b = vals.b / 255;
    this.a = vals.a == 4 ? vals.a / 255 : 1.0;
  }

  /**
   * Setter from a hexadecimal value.
   * E.g. #ff0000
   * @param {number} hex - The hex value.
   */
  setFromHex(hex) {
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : null
    }
    const rgb = hexToRgb(hex);
    if (!rgb) {
      console.warn('Invalid hex code:' + hex);
      return
    }
    this.setFromRGB(rgb.r, rgb.g, rgb.b);
  }

  /**
   * Setter from a CSS color name.
   * E.g. "red"
   * @param {string} name - The CSS color name.
   */
  setFromCSSColorName(name) {
    const colourNameToHex = (colour) => {
      const colors = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        'indianred ': '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgrey: '#d3d3d3',
        lightgreen: '#90ee90',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370d8',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#d87093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
      };

      if (typeof colors[colour.toLowerCase()] != 'undefined') return colors[colour.toLowerCase()]

      return false
    };
    if (name.startsWith('#')) {
      this.setFromHex(name);
    } else {
      this.setFromHex(colourNameToHex(name));
    }
  }

  /**
   * Returns the hexadecimal value of this color.
   *
   * @return {string} - Returns the hex value.
   */
  toHex() {
    function componentToHex(c) {
      const int = Math.round(c * 255);
      const hex = int.toString(16);
      return hex.length == 1 ? '0' + hex : hex
    }
    return '#' + componentToHex(this.r) + componentToHex(this.g) + componentToHex(this.b)
  }

  /**
   * Returns true if this color is exactly the same as other.
   *
   * @param {Color} other - The other color to compare with.
   * @return {boolean} - Returns true or false.
   */
  equal(other) {
    return this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a
  }

  /**
   * Returns true if this color is NOT exactly the same as other.
   *
   * @param {Color} other - The other color to compare with.
   * @return {boolean} - Returns true or false.
   */
  notEquals(other) {
    return this.r != other.r && this.g != other.g && this.b != other.b && this.a != other.a
  }

  /**
   * Returns true if this color is approximately the same as other.
   *
   * @param {Color} other - The other color to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      Math.abs(this.r - other.r) < precision &&
      Math.abs(this.g - other.g) < precision &&
      Math.abs(this.b - other.b) < precision &&
      Math.abs(this.a - other.a) < precision
    )
  }

  /**
   * Returns a new Color which is this Color added to other.
   *
   * @param {Color} other - The other color to add.
   * @return {Color} - Returns a new color.
   */
  add(other) {
    return new Color(this.r + other.r, this.g + other.g, this.b + other.b, this.a + other.a)
  }

  /**
   * Returns a new color which is this color subtracted from other.
   *
   * @param {Color} other - The other color to subtract.
   * @return {Color} - Returns a new color.
   */
  subtract(other) {
    return new Color(this.r - other.r, this.g - other.g, this.b - other.b, this.a - other.a)
  }

  /**
   * Scales this color by scalar and return the result as a new Vec4.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} - Returns a new color.
   */
  scale(scalar) {
    return new Color(this.r * scalar, this.g * scalar, this.b * scalar, this.a * scalar)
  }

  /**
   * Scales this color by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.r *= scalar;
    this.g *= scalar;
    this.b *= scalar;
    this.a *= scalar;
  }

  /**
   * Apply gamma correction to this color
   *
   * @param {number} gamma - The gamma value.
   */
  applyGamma(gamma) {
    this.set(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
  }

  /**
   * Converts to linear color space and returns a new color
   *
   * @param {number} gamma - The gamma value.
   * @return {Color} - Returns a new color.
   */
  toLinear(gamma = 2.2) {
    return new Color(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a)
  }

  /**
   * Converts to gamma color space and returns a new color.
   *
   * @param {number} gamma - The gamma value.
   * @return {Color} - Returns a new color.
   */
  toGamma(gamma = 2.2) {
    return new Color(
      Math.pow(this.r, 1.0 / gamma),
      Math.pow(this.g, 1.0 / gamma),
      Math.pow(this.b, 1.0 / gamma),
      this.a
    )
  }

  /**
   * Calculates and returns the relative luminance of the linear RGB component.
   *
   * @return {number} - The return value.
   */
  luminance() {
    return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b
  }

  /**
   * Performs a linear interpolation between this color and other.
   *
   * @param {Color} other - The other color to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {Color} - Returns a new color.
   */
  lerp(other, t) {
    const ar = this.r;
    const ag = this.g;
    const ab = this.b;
    const aa = this.a;
    return new Color(ar + t * (other.r - ar), ag + t * (other.g - ag), ab + t * (other.b - ab), aa + t * (other.a - aa))
  }

  /**
   * Creates a random color.
   *
   * @param {number} gammaOffset - The gamma offset.
   * @param {boolean} randomAlpha - Determines whether the alpha channel is random.
   * @return {Color} - Returns a new random color.
   */
  static random(gammaOffset = 0.0, randomAlpha = false) {
    if (gammaOffset > 0.0) {
      return new Color(
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        gammaOffset + Math.random() * (1.0 - gammaOffset),
        randomAlpha ? gammaOffset + Math.random() * (1.0 - gammaOffset) : 1.0
      )
    } else if (gammaOffset < 0.0) {
      return new Color(
        Math.random() * (1.0 + gammaOffset),
        Math.random() * (1.0 + gammaOffset),
        Math.random() * (1.0 + gammaOffset),
        randomAlpha ? Math.random() * (1.0 + gammaOffset) : 1.0
      )
    } else {
      return new Color(Math.random(), Math.random(), Math.random(), randomAlpha ? Math.random() : 1.0)
    }
  }

  /**
   * Clones this color and returns a new color.
   *
   * @return {Color} - Returns a new color.
   */
  clone() {
    return new Color(this.__data[0], this.__data[1], this.__data[2], this.__data[3])
  }

  /**
   * Returns the type as an array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as an array.
   */
  asArray() {
    return this.__data
  }

  /**
   * Returns the type as a 3 component array. Often used to pass types to the GPU.
   *
   * @return {array} - Returns as a 3 component array.
   * @private
   */
  as3ComponentArray() {
    return [this.__data[0], this.__data[1], this.__data[2]]
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new color.
   * @param {...object} ...args - The ...args param.
   * @return {Color} - Returns a new color.
   * @private
   */
  static create(...args) {
    return new Color(...args)
  }

  /**
   * The createFromFloat32Buffer method.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Color} - Returns a new color.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Color` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Color} - Returns a new color.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Color(new Float32Array(buffer, byteOffset, 4)) // 4 bytes per 32bit float
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 4
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.r = j.r;
    this.g = j.g;
    this.b = j.b;
    this.a = j.a;
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.r = reader.loadFloat32();
    this.g = reader.loadFloat32();
    this.b = reader.loadFloat32();
    this.a = reader.loadFloat32();
  }

  /**
   * Returns the CSS rgba string.
   *
   * @return {string} - The return value.
   */
  toCSSString() {
    return (
      'rgba(' +
      Math.round(this.r * 255) +
      ', ' +
      Math.round(this.g * 255) +
      ', ' +
      Math.round(this.b * 255) +
      ', ' +
      this.a +
      ')'
    )
  }
}

Registry.register('Color', Color);

/**
 * Class representing euler angles. Euler angles describe rotating an object
 * around its various axis in a specified axis order.
 *
 * @extends AttrValue
 */
class EulerAngles extends AttrValue {
  /**
   * Create a euler angle. Receives the xyz values in degrees and the order that the rotations are applied.
   * <br>
   * Order parameter values: `XYZ: 0`, `YZX: 1`, `ZXY: 2`, `XZY: 3`, `ZYX: 4`, `YXZ: 5`
   * <br>
   * It could be either the `string` or the `number` value.
   *
   * @param {number} x - The angle of the x axis in degrees. Default is 0.
   * @param {number} y - The angle of the y axis in degrees. Default is 0.
   * @param {number} z - The angle of the z axis in degrees. Default is 0.
   * @param {number | string} order - The order in which the rotations are applied.
   */
  constructor(x = 0, y = 0, z = 0, order = 0) {
    super();

    if (!isNaN(order)) this.order = order;
    else {
      switch (order) {
        case 'XYZ':
          this.order = 0;
          break
        case 'YZX':
          this.order = 1;
          break
        case 'ZXY':
          this.order = 2;
          break
        case 'XZY':
          this.order = 3;
          break
        case 'ZYX':
          this.order = 4;
          break
        case 'YXZ':
          this.order = 5;
          break
        default:
          throw new Error('Invalid Euler Angles Order:' + order)
      }
    }
    if (x instanceof ArrayBuffer) {
      const buffer = x;
      const byteOffset = y;
      this.__data = new Float32Array(buffer, byteOffset, 4);
    } else {
      this.__data = new Float32Array(3);
      this.__data[0] = x;
      this.__data[1] = y;
      this.__data[2] = z;
    }
  }

  /**
   * Getter for x axis rotation.
   *
   * @return {number} - Returns the x axis rotation.
   */
  get x() {
    return this.__data[0]
  }

  /**
   * Setter for x axis rotation.
   *
   * @param {number} val - The val param.
   */
  set x(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for y axis rotation.
   *
   * @return {number} - Returns the y axis rotation.
   */
  get y() {
    return this.__data[1]
  }

  /**
   * Setter for y axis rotation.
   *
   * @param {number} val - The val param.
   */
  set y(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for z axis rotation.
   *
   * @return {number} - Returns the z axis rotation.
   */
  get z() {
    return this.__data[2]
  }

  /**
   * Setter for z axis rotation.
   *
   * @param {number} val - The val param.
   */
  set z(val) {
    this.__data[2] = val;
  }

  /**
   * Sets the EulerAngles
   *
   * @param {number} x - The x axis rotation.
   * @param {number} y  - The y axis rotation.
   * @param {number} z  - The z axis rotation.
   */
  set(x, y, z) {
    this.__data[0] = x;
    this.__data[1] = y;
    this.__data[2] = z;
  }
}

Registry.register('EulerAngles', EulerAngles);

/* eslint-disable new-cap */

/**
 * A class representing a 3x3 matrix.
 * This matrix class is based on GLM, and is column major.
 *
 * @extends AttrValue
 */
class Mat3$1 extends AttrValue {
  /**
   * Initializes the Mat3 class with given data.
   *
   * @param {number | ArrayBuffer} m00 - Row 0, column 0.
   * @param {number} m01 - Row 0, column 1.
   * @param {number} m02 - Row 0, column 2.
   * @param {number} m10 - Row 1, column 0.
   * @param {number} m11 - Row 1, column 1.
   * @param {number} m12 - Row 1, column 2.
   * @param {number} m20 - Row 2, column 0.
   * @param {number} m21 - Row 2, column 1.
   * @param {number} m22 - Row 2, column 2.
   */
  constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
    super();

    if (m00 instanceof Float32Array || m00 instanceof Uint32Array) {
      this.__data = m00;
    } else if (m00 instanceof ArrayBuffer) {
      console.warn(`Deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 9))`);
      const buffer = m00;
      const byteOffset = m01;
      this.__data = new Float32Array(buffer, byteOffset, 9);
    } else {
      this.__data = new Float32Array(9);
      this.set(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
  }

  // /////////////////////////////////////////
  // properties

  /**
   * Getter for row 0, column 0.
   * @return {number} - Returns the m00 value.
   */
  get m00() {
    return this.__data[0]
  }

  /**
   * Setter for row 0, column 0.
   *
   * @param {number} val - The val param.
   */
  set m00(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for row 0, column 1.
   *
   * @return {number} - Returns the m01 value.
   */
  get m01() {
    return this.__data[1]
  }

  /**
   * Setter for row 0, column 1.
   *
   * @param {number} val - The val param.
   */
  set m01(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for row 0, column 2.
   *
   * @return {number} - Returns the m02 value.
   */
  get m02() {
    return this.__data[2]
  }

  /**
   * Setter for row 0, column 2.
   *
   * @param {number} val - The val param.
   */
  set m02(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for row 1, column 0.
   *
   * @return {number} - Returns the m10 value.
   */
  get m10() {
    return this.__data[3]
  }

  /**
   * Setter for row 1, column 0.
   *
   * @param {number} val - The val param.
   */
  set m10(val) {
    this.__data[3] = val;
  }

  /**
   * Getter for row 1, column 1
   *
   * @return {number} - Returns the m11 value.
   */
  get m11() {
    return this.__data[4]
  }

  /**
   * Setter for row 1, column 1.
   *
   * @param {number} val - The val param.
   */
  set m11(val) {
    this.__data[4] = val;
  }

  /**
   * Getter for row 1, column 2.
   *
   * @return {number} - Returns the m12 value.
   */
  get m12() {
    return this.__data[5]
  }

  /**
   * Setter for row 1, column 2.
   *
   * @param {number} val - The val param.
   */
  set m12(val) {
    this.__data[5] = val;
  }

  /**
   * Getter for row 2, column 0.
   *
   * @return {number} - Returns the m20 value.
   */
  get m20() {
    return this.__data[6]
  }

  /**
   * Setter for row 2, column 0.
   *
   * @param {number} val - The val param.
   */
  set m20(val) {
    this.__data[6] = val;
  }

  /**
   * Getter for row 2, column 1.
   *
   * @return {number} - Returns the m21 value.
   */
  get m21() {
    return this.__data[7]
  }

  /**
   * Setter for row 2, column 1.
   *
   * @param {number} val - The val param.
   */
  set m21(val) {
    this.__data[7] = val;
  }

  /**
   * Getter for row 2, column 2.
   *
   * @return {number} - Returns the m22 value.
   */
  get m22() {
    return this.__data[8]
  }

  /**
   * Setter for row 2, column 2.
   *
   * @param {number} val - The val param.
   */
  set m22(val) {
    this.__data[8] = val;
  }

  /**
   * Getter for the `x` axis.
   *
   * @return {Vec3} - Returns the `x` axis as a Vec3.
   */
  get xAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 0)
  }

  /**
   * Setter for the `x` axis.
   *
   * @param {Vec3} vec3 - The vec3 value.
   */
  set xAxis(vec3) {
    this.xAxis.set(vec3.x, vec3.y, vec3.z);
  }

  /**
   * Getter for the `y` axis.
   * * @return {Vec3} - Returns the `y` axis as a Vec3.
   */
  get yAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 3 * 4)
  }

  /**
   * Setter for the `y` axis.
   * @param {Vec3} vec3 - The vec3 value.
   */
  set yAxis(vec3) {
    this.yAxis.set(vec3.x, vec3.y, vec3.z);
  }

  /**
   * Getter for the `z` axis.
   * * @return {Vec3} - Returns the `z` axis as a Vec3.
   */
  get zAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 6 * 4)
  }

  /**
   * Setter for the `z` axis.
   * @param {Vec3} vec3 - The vec3 value.
   */
  set zAxis(vec3) {
    this.zAxis.set(vec3.x, vec3.y, vec3.z);
  }

  // /////////////////////////////////////////
  // Setters

  /**
   * Sets the state of the Mat3 class
   *
   * @param {number} m00 - Row 0, column 0.
   * @param {number} m01 - Row 0, column 1.
   * @param {number} m02 - Row 0, column 2.
   * @param {number} m10 - Row 1, column 0.
   * @param {number} m11 - Row 1, column 1.
   * @param {number} m12 - Row 1, column 2.
   * @param {number} m20 - Row 2, column 0.
   * @param {number} m21 - Row 2, column 1.
   * @param {number} m22 - Row 2, column 2.
   */
  set(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
    this.__data[0] = m00;
    this.__data[1] = m01;
    this.__data[2] = m02;
    this.__data[3] = m10;
    this.__data[4] = m11;
    this.__data[5] = m12;
    this.__data[6] = m20;
    this.__data[7] = m21;
    this.__data[8] = m22;
  }

  /**
   * Sets state of the Mat3 with the identity  Matrix
   */
  setIdentity() {
    this.set();
  }

  /**
   * Sets state of the Mat3 from another Mat3
   * <br>
   * Note: works with either Mat3 or Mat4.
   *
   * @param {Mat3} mat - The mat value.
   */
  setFromMat(mat) {
    this.__data[0] = mat.m00;
    this.__data[1] = mat.m01;
    this.__data[2] = mat.m02;
    this.__data[3] = mat.m10;
    this.__data[4] = mat.m11;
    this.__data[5] = mat.m12;
    this.__data[6] = mat.m20;
    this.__data[7] = mat.m21;
    this.__data[8] = mat.m22;
  }

  /**
   * Scales and calculates the cross product of the `Vec3` and sets the result in the Mat3
   *
   * @param {Vec3} dir - The dir value.
   * @param {Vec3} up - The up value.
   */
  setFromDirectionAndUpvector(dir, up) {
    const zAxis = dir;
    const zLen = zAxis.length();
    if (zLen < Number.EPSILON) {
      this.setIdentity();
      return
    }
    zAxis.scaleInPlace(1 / zLen);

    const xAxis = up.cross(zAxis);
    const xLen = xAxis.length();
    if (xLen > Number.EPSILON) xAxis.scaleInPlace(1 / xLen);

    const yAxis = zAxis.cross(xAxis);
    const yLen = yAxis.length();
    if (yLen > Number.EPSILON) yAxis.scaleInPlace(1 / yLen);

    this.set(xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
  }

  /**
   * Inverts a Mat3 and returns the result as a new instance.
   *
   * @return {Mat3} - Returns a new Mat3.
   */
  inverse() {
    const a00 = this.__data[0];
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a10 = this.__data[3];
    const a11 = this.__data[4];
    const a12 = this.__data[5];
    const a20 = this.__data[6];
    const a21 = this.__data[7];
    const a22 = this.__data[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    const det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      console.warn('Unable to invert Mat3');
      return null
    }
    det = 1.0 / det;

    return new Mat3$1(
      b01 * det,
      (-a22 * a01 + a02 * a21) * det,
      (a12 * a01 - a02 * a11) * det,
      b11 * det,
      (a22 * a00 - a02 * a20) * det,
      (-a12 * a00 + a02 * a10) * det,
      b21 * det,
      (-a21 * a00 + a01 * a20) * det,
      (a11 * a00 - a01 * a10) * det
    )
  }

  /**
   * Inverts a Mat3.
   *
   * @return {boolean} - The return value.
   */
  invertInPlace() {
    const a00 = this.__data[0];
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a10 = this.__data[3];
    const a11 = this.__data[4];
    const a12 = this.__data[5];
    const a20 = this.__data[6];
    const a21 = this.__data[7];
    const a22 = this.__data[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    const det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      console.warn('Unable to invert Mat3');
      return false
    }
    det = 1.0 / det;

    this.set(
      b01 * det,
      (-a22 * a01 + a02 * a21) * det,
      (a12 * a01 - a02 * a11) * det,
      b11 * det,
      (a22 * a00 - a02 * a20) * det,
      (-a12 * a00 + a02 * a10) * det,
      b21 * det,
      (-a21 * a00 + a01 * a20) * det,
      (a11 * a00 - a01 * a10) * det
    );
    return true
  }

  /**
   * Transposes (exchanges columns with rows) this matrix
   * and returns the result as a new instance.
   *
   * @return {Mat3} - Return a new transposed Mat3.
   */
  transpose() {
    return Mat3$1(
      this.__data[0],
      this.__data[3],
      this.__data[6],
      this.__data[1],
      this.__data[4],
      this.__data[7],
      this.__data[2],
      this.__data[5],
      this.__data[8]
    )
  }

  /**
   * Transposes (exchanges columns with rows) this matrix.
   */
  transposeInPlace() {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a12 = this.__data[5];

    this.__data[1] = this.__data[3];
    this.__data[2] = this.__data[6];
    this.__data[3] = a01;
    this.__data[5] = this.__data[7];
    this.__data[6] = a02;
    this.__data[7] = a12;
  }

  /**
   * Transforms the Vec3 with a Mat3.
   *
   * @param {Vec3} vec3 - The vec3 value.
   * @return {Vec3} - Return the result as a new Vec3.
   */
  transformVec3(vec3) {
    return new Vec3$1(
      this.__data[0] * vec3.x + this.__data[1] * vec3.y + this.__data[2] * vec3.z,
      this.__data[3] * vec3.x + this.__data[4] * vec3.y + this.__data[5] * vec3.z,
      this.__data[6] * vec3.x + this.__data[7] * vec3.y + this.__data[8] * vec3.z
    )
  }

  /**
   * Clones this Mat3 returning a new instance.
   *
   * @return {Mat3} - Returns a new Mat3.
   */
  clone() {
    return new Mat3$1(
      this.__data[0],
      this.__data[1],
      this.__data[2],
      this.__data[3],
      this.__data[4],
      this.__data[5],
      this.__data[6],
      this.__data[7],
      this.__data[8],
      this.__data[9]
    )
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Create a new Mat3.
   * @param {...object} ...args - The ...args param.
   * @return {Mat3} - Returns a new Mat3.
   * @private
   */
  static create(...args) {
    return new Mat3$1(...args)
  }

  /**
   * Creates a new Mat3 to wrap existing memory in a buffer.
   *
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Mat3} - Returns a new Mat3.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Mat3` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Mat3} - Returns a new Mat3.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Mat3$1(new Float32Array(buffer, byteOffset, 9)) // 4 bytes per 32bit float
  }

  // ///////////////////////////
  // Persistence

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.__data = reader.loadFloat32Array(9);
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return this.__data
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json param.
   */
  fromJSON(json) {
    this.__data = new Float32Array(json);
  }

  // ///////////////////////////
  // Debugging

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    return this.toJSON().toString()
  }
}

Registry.register('Mat3', Mat3$1);

/**
 * A class representing a 4x4 matrix.
 * This matrix class is based on GLM, and is column major.
 *
 * @extends AttrValue
 */
class Mat4 extends AttrValue {
  /**
   * Initializes the Mat3 class with given data.
   *
   * @param {number | Float32Array | ArrayBuffer} m00 - Row 0, column 0.
   * @param {number} m01 - Row 0, column 1.
   * @param {number} m02 - Row 0, column 2.
   * @param {number} m03 - Row 0, column 3.
   * @param {number} m10 - Row 1, column 0.
   * @param {number} m11 - Row 1, column 1.
   * @param {number} m12 - Row 1, column 2.
   * @param {number} m13 - Row 1, column 3.
   * @param {number} m20 - Row 2, column 0.
   * @param {number} m21 - Row 2, column 1.
   * @param {number} m22 - Row 2, column 2.
   * @param {number} m23 - Row 2, column 3.
   * @param {number} m30 - Row 3, column 0.
   * @param {number} m31 - Row 3, column 1.
   * @param {number} m32 - Row 3, column 2.
   * @param {number} m33 - Row 3, column 3.
   */
  constructor(
    m00 = 1,
    m01 = 0,
    m02 = 0,
    m03 = 0,
    m10 = 0,
    m11 = 1,
    m12 = 0,
    m13 = 0,
    m20 = 0,
    m21 = 0,
    m22 = 1,
    m23 = 0,
    m30 = 0,
    m31 = 0,
    m32 = 0,
    m33 = 1
  ) {
    super();

    if (m00 instanceof Float32Array) {
      this.__data = m00;
    } else if (m00 instanceof ArrayBuffer) {
      const buffer = m00;
      const byteOffset = m01;
      this.__data = new Float32Array(buffer, byteOffset, 16);
    } else {
      this.__data = new Float32Array(16);
      this.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    }
  }

  // /////////////////////////////////////////
  // properties

  /**
   * Getter for row 0, column 0.
   *
   * @return {number} - Returns the m00 value.
   */
  get m00() {
    return this.__data[0]
  }

  /**
   * Setter for row 0, column 0.
   *
   * @param {number} val - The val param.
   */
  set m00(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for row 0, column 1.
   *
   * @return {number} - Returns the m01 value.
   */
  get m01() {
    return this.__data[1]
  }

  /**
   * Setter for row 0, column 1.
   *
   * @param {number} val - The val param.
   */
  set m01(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for row 0, column 2.
   *
   * @return {number} - Returns the m02 value.
   */
  get m02() {
    return this.__data[2]
  }

  /**
   * Setter for row 0, column 2.
   *
   * @param {number} val - The val param.
   */
  set m02(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for row 0, column 3.
   *
   * @return {number} - Returns the m03 value.
   */
  get m03() {
    return this.__data[3]
  }

  /**
   * Setter for row 0, column 3.
   *
   * @param {number} val - The val param.
   */
  set m03(val) {
    this.__data[3] = val;
  }

  /**
   * Getter for row 1, column 0.
   *
   * @return {number} - Returns the m10 value.
   */
  get m10() {
    return this.__data[4]
  }

  /**
   * Setter for row 1, column 0.
   *
   * @param {number} val - The val param.
   */
  set m10(val) {
    this.__data[4] = val;
  }

  /**
   * Getter for row 1, column 1.
   *
   * @return {number} - Returns the m11 value.
   */
  get m11() {
    return this.__data[5]
  }

  /**
   * Setter for row 1, column 1.
   *
   * @param {number} val - The val param.
   */
  set m11(val) {
    this.__data[5] = val;
  }

  /**
   * Getter for row 1, column 2.
   *
   * @return {number} - Returns the m12 value.
   */
  get m12() {
    return this.__data[6]
  }

  /**
   * Setter for row 1, column 2.
   *
   * @param {number} val - The val param.
   */
  set m12(val) {
    this.__data[6] = val;
  }

  /**
   * Getter for row 1, column 3.
   *
   * @return {number} - Returns the m13 value.
   */
  get m13() {
    return this.__data[7]
  }

  /**
   * Setter for row 1, column 3.
   *
   * @param {number} val - The val param.
   */
  set m13(val) {
    this.__data[7] = val;
  }

  /**
   * Getter for row 2, column 0.
   *
   * @return {number} - Returns the m20 value.
   */
  get m20() {
    return this.__data[8]
  }

  /**
   * Setter for row 2, column 0.
   *
   * @param {number} val - The val param.
   */
  set m20(val) {
    this.__data[8] = val;
  }

  /**
   * Getter for row 2, column 1.
   *
   * @return {number} - Returns the m21 value.
   */
  get m21() {
    return this.__data[9]
  }

  /**
   * Setter for row 2, column 1
   *
   * @param {number} val - The val param.
   */
  set m21(val) {
    this.__data[9] = val;
  }

  /**
   * Getter for row 2, column 2.
   *
   * @return {number} - Returns the m22 value.
   */
  get m22() {
    return this.__data[10]
  }

  /**
   * Setter for row 2, column 2.
   *
   * @param {number} val - The val param.
   */
  set m22(val) {
    this.__data[10] = val;
  }

  /**
   * Getter for row 2, column 3.
   *
   * @return {number} - Returns the m23 value.
   */
  get m23() {
    return this.__data[11]
  }

  /**
   * Setter for row 2, column 3.
   *
   * @param {number} val - The val param.
   */
  set m23(val) {
    this.__data[11] = val;
  }

  /**
   * Getter for row 3, column 0
   *
   * @return {number} - Returns the m30 value.
   */
  get m30() {
    return this.__data[12]
  }

  /**
   * Setter for row 3, column 0.
   *
   * @param {number} val - The val param.
   */
  set m30(val) {
    this.__data[12] = val;
  }

  /**
   * Getter for row 3, column 1.
   *
   * @return {number} - Returns the m31 value.
   */
  get m31() {
    return this.__data[13]
  }

  /**
   * Setter for row 3, column 1.
   *
   * @param {number} val - The val param.
   */
  set m31(val) {
    this.__data[13] = val;
  }

  /**
   * Getter for row 3, column 2.
   *
   * @return {number} - Returns the m32 value.
   */
  get m32() {
    return this.__data[14]
  }

  /**
   * Setter for row 3, column 2.
   *
   * @param {number} val - The val param.
   */
  set m32(val) {
    this.__data[14] = val;
  }

  /**
   * Getter for row 3, column 3.
   *
   * @return {number} - Returns the m33 value.
   */
  get m33() {
    return this.__data[15]
  }

  /**
   * Setter for row 3, column 3.
   *
   * @param {number} val - The val param.
   */
  set m33(val) {
    this.__data[15] = val;
  }

  /**
   * Getter for the `x` axis.
   *
   * @return {Vec3} - Returns the `x` axis as a Vec3.
   */
  get xAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 0)
  }

  /**
   * Setter for the `x` axis.
   *
   * @param {Vec3} vec3 - The vec3 value.
   */
  set xAxis(vec3) {
    this.xAxis.set(vec3.x, vec3.y, vec3.z);
  }

  /**
   * Getter for the `y` axis.
   *
   * @return {Vec3} - Returns the `y` axis as a Vec3.
   */
  get yAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 4 * 4)
  }

  /**
   * Setter for the `y` axis.
   *
   * @param {Vec3} vec3 - The vec3 value.
   */
  set yAxis(vec3) {
    this.yAxis.set(vec3.x, vec3.y, vec3.z);
  }

  /**
   * Getter for the `z` axis.
   *
   * @return {Vec3} - Returns the `z` axis as a Vec3.
   */
  get zAxis() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 8 * 4)
  }

  /**
   * Setter for the `z` axis.
   *
   * @param {Vec3} vec3 - The vec3 value.
   */
  set zAxis(vec3) {
    this.zAxis.set(vec3.x, vec3.y, vec3.z);
  }

  /**
   * Getter for the translation of the matrix.
   *
   * @return {Vec3} - Returns the translation.
   */
  get translation() {
    return Vec3$1.createFromBuffer(this.__data.buffer, 12 * 4)
  }

  /**
   * Setter for the translation of the matrix.
   *
   * @param {Vec3} vec3 - The translation.
   */
  set translation(vec3) {
    this.translation.set(vec3.x, vec3.y, vec3.z);
  }

  // /////////////////////////////////////////
  // Setters

  /**
   * Sets the state of the Mat4 class
   *
   * @param {number} m00 - Row 0, column 0.
   * @param {number} m01 - Row 0, column 1.
   * @param {number} m02 - Row 0, column 2.
   * @param {number} m03 - Row 0, column 3.
   * @param {number} m10 - Row 1, column 0.
   * @param {number} m11 - Row 1, column 1.
   * @param {number} m12 - Row 1, column 2.
   * @param {number} m13 - Row 1, column 3.
   * @param {number} m20 - Row 2, column 0.
   * @param {number} m21 - Row 2, column 1.
   * @param {number} m22 - Row 2, column 2.
   * @param {number} m23 - Row 2, column 3.
   * @param {number} m30 - Row 3, column 0.
   * @param {number} m31 - Row 3, column 1.
   * @param {number} m32 - Row 3, column 2.
   * @param {number} m33 - Row 3, column 3.
   */
  set(
    m00 = 1,
    m01 = 0,
    m02 = 0,
    m03 = 0,
    m10 = 0,
    m11 = 1,
    m12 = 0,
    m13 = 0,
    m20 = 0,
    m21 = 0,
    m22 = 1,
    m23 = 0,
    m30 = 0,
    m31 = 0,
    m32 = 0,
    m33 = 1
  ) {
    this.__data[0] = m00;
    this.__data[1] = m01;
    this.__data[2] = m02;
    this.__data[3] = m03;
    this.__data[4] = m10;
    this.__data[5] = m11;
    this.__data[6] = m12;
    this.__data[7] = m13;
    this.__data[8] = m20;
    this.__data[9] = m21;
    this.__data[10] = m22;
    this.__data[11] = m23;
    this.__data[12] = m30;
    this.__data[13] = m31;
    this.__data[14] = m32;
    this.__data[15] = m33;
  }

  /**
   * Sets state of the Mat4 with the identity  Matrix
   */
  setIdentity() {
    this.set();
  }

  /**
   * Sets the state of the Mat4 Object.
   *
   * @param {Float32Array} float32Array - The float32Array value.
   */
  setDataArray(float32Array) {
    this.__data = float32Array;
  }

  /**
   * Sets state of the Mat4 from another Mat4
   * <br>
   * Note: works with either Mat3 or Mat4.
   *
   * @param {Mat4} mat4 - The mat4 value.
   */
  setFromMat4(mat4) {
    this.__data[0] = mat4.m00;
    this.__data[1] = mat4.m01;
    this.__data[2] = mat4.m02;
    this.__data[3] = mat4.m03;
    this.__data[4] = mat4.m10;
    this.__data[5] = mat4.m11;
    this.__data[6] = mat4.m12;
    this.__data[7] = mat4.m13;
    this.__data[8] = mat4.m20;
    this.__data[9] = mat4.m21;
    this.__data[10] = mat4.m22;
    this.__data[11] = mat4.m23;
    this.__data[12] = mat4.m30;
    this.__data[13] = mat4.m31;
    this.__data[14] = mat4.m32;
    this.__data[15] = mat4.m33;
  }

  /**
   * Converts a Mat4 to a Mat3.
   *
   * @param {Mat4} mat4 - The Mat4 value to convert.
   * @return {Mat3} - Returns a new Mat3.
   */
  toMat3(mat4) {
    return new Mat3$1(
      this.__data[0],
      this.__data[1],
      this.__data[2],
      this.__data[4],
      this.__data[5],
      this.__data[6],
      this.__data[8],
      this.__data[9],
      this.__data[10]
    )
  }

  /**
   * Transposes (exchanges columns with rows) this matrix.
   */
  transposeInPlace() {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a03 = this.__data[3];
    const a12 = this.__data[6];
    const a13 = this.__data[7];
    const a23 = this.__data[11];

    this.__data[1] = this.__data[4];
    this.__data[2] = this.__data[8];
    this.__data[3] = this.__data[12];
    this.__data[4] = a01;
    this.__data[6] = this.__data[9];
    this.__data[7] = this.__data[13];
    this.__data[8] = a02;
    this.__data[9] = a12;
    this.__data[11] = this.__data[14];
    this.__data[12] = a03;
    this.__data[13] = a13;
    this.__data[14] = a23;
  }

  /**
   * Transposes (exchanges columns with rows) this matrix
   * and returns the result as a new instance.
   *
   * @return {Mat4} - Return a new transposed Mat4.
   */
  transpose() {
    return new Mat4(
      this.__data[0],
      this.__data[4],
      this.__data[8],
      this.__data[12],
      this.__data[1],
      this.__data[5],
      this.__data[9],
      this.__data[13],
      this.__data[2],
      this.__data[6],
      this.__data[10],
      this.__data[14],
      this.__data[3],
      this.__data[7],
      this.__data[11],
      this.__data[15]
    )
  }

  /**
   * Inverts a Mat4 not using SIMD and returns the result as a new instance.
   *
   * @return {Mat4} - Returns a new Mat4.
   */
  inverse() {
    const a00 = this.__data[0];
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a03 = this.__data[3];
    const a10 = this.__data[4];
    const a11 = this.__data[5];
    const a12 = this.__data[6];
    const a13 = this.__data[7];
    const a20 = this.__data[8];
    const a21 = this.__data[9];
    const a22 = this.__data[10];
    const a23 = this.__data[11];
    const a30 = this.__data[12];
    const a31 = this.__data[13];
    const a32 = this.__data[14];
    const a33 = this.__data[15];

    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      console.warn('Unable to invert Mat4');
      return null
    }
    det = 1.0 / det;

    return new Mat4(
      (a11 * b11 - a12 * b10 + a13 * b09) * det,
      (a02 * b10 - a01 * b11 - a03 * b09) * det,
      (a31 * b05 - a32 * b04 + a33 * b03) * det,
      (a22 * b04 - a21 * b05 - a23 * b03) * det,
      (a12 * b08 - a10 * b11 - a13 * b07) * det,
      (a00 * b11 - a02 * b08 + a03 * b07) * det,
      (a32 * b02 - a30 * b05 - a33 * b01) * det,
      (a20 * b05 - a22 * b02 + a23 * b01) * det,
      (a10 * b10 - a11 * b08 + a13 * b06) * det,
      (a01 * b08 - a00 * b10 - a03 * b06) * det,
      (a30 * b04 - a31 * b02 + a33 * b00) * det,
      (a21 * b02 - a20 * b04 - a23 * b00) * det,
      (a11 * b07 - a10 * b09 - a12 * b06) * det,
      (a00 * b09 - a01 * b07 + a02 * b06) * det,
      (a31 * b01 - a30 * b03 - a32 * b00) * det,
      (a20 * b03 - a21 * b01 + a22 * b00) * det
    )
  }

  /**
   * Inverts a Mat4.
   *
   * @return {boolean} - The return value.
   */
  invertInPlace() {
    const a00 = this.__data[0];
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a03 = this.__data[3];
    const a10 = this.__data[4];
    const a11 = this.__data[5];
    const a12 = this.__data[6];
    const a13 = this.__data[7];
    const a20 = this.__data[8];
    const a21 = this.__data[9];
    const a22 = this.__data[10];
    const a23 = this.__data[11];
    const a30 = this.__data[12];
    const a31 = this.__data[13];
    const a32 = this.__data[14];
    const a33 = this.__data[15];

    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      console.warn('Unable to invert Mat4');
      return false
    }
    det = 1.0 / det;

    this.set(
      (a11 * b11 - a12 * b10 + a13 * b09) * det,
      (a02 * b10 - a01 * b11 - a03 * b09) * det,
      (a31 * b05 - a32 * b04 + a33 * b03) * det,
      (a22 * b04 - a21 * b05 - a23 * b03) * det,
      (a12 * b08 - a10 * b11 - a13 * b07) * det,
      (a00 * b11 - a02 * b08 + a03 * b07) * det,
      (a32 * b02 - a30 * b05 - a33 * b01) * det,
      (a20 * b05 - a22 * b02 + a23 * b01) * det,
      (a10 * b10 - a11 * b08 + a13 * b06) * det,
      (a01 * b08 - a00 * b10 - a03 * b06) * det,
      (a30 * b04 - a31 * b02 + a33 * b00) * det,
      (a21 * b02 - a20 * b04 - a23 * b00) * det,
      (a11 * b07 - a10 * b09 - a12 * b06) * det,
      (a00 * b09 - a01 * b07 + a02 * b06) * det,
      (a31 * b01 - a30 * b03 - a32 * b00) * det,
      (a20 * b03 - a21 * b01 + a22 * b00) * det
    );
    return true
  }

  /**
   * Sets this matrix as the inverse of the given Mat4.
   *
   * @param {Mat4} mat4 - The mat4 value.
   * @return {null} - In case the `determinant` can't be calculated, a `null` will be returned, otherwise, nothing is returned
   */
  setInverse(mat4) {
    const a00 = mat4.__data[0];
    const a01 = mat4.__data[1];
    const a02 = mat4.__data[2];
    const a03 = mat4.__data[3];
    const a10 = mat4.__data[4];
    const a11 = mat4.__data[5];
    const a12 = mat4.__data[6];
    const a13 = mat4.__data[7];
    const a20 = mat4.__data[8];
    const a21 = mat4.__data[9];
    const a22 = mat4.__data[10];
    const a23 = mat4.__data[11];
    const a30 = mat4.__data[12];
    const a31 = mat4.__data[13];
    const a32 = mat4.__data[14];
    const a33 = mat4.__data[15];

    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      throw new Error('Unable to invert Mat4')
    }
    det = 1.0 / det;

    this.set(
      (a11 * b11 - a12 * b10 + a13 * b09) * det,
      (a02 * b10 - a01 * b11 - a03 * b09) * det,
      (a31 * b05 - a32 * b04 + a33 * b03) * det,
      (a22 * b04 - a21 * b05 - a23 * b03) * det,
      (a12 * b08 - a10 * b11 - a13 * b07) * det,
      (a00 * b11 - a02 * b08 + a03 * b07) * det,
      (a32 * b02 - a30 * b05 - a33 * b01) * det,
      (a20 * b05 - a22 * b02 + a23 * b01) * det,
      (a10 * b10 - a11 * b08 + a13 * b06) * det,
      (a01 * b08 - a00 * b10 - a03 * b06) * det,
      (a30 * b04 - a31 * b02 + a33 * b00) * det,
      (a21 * b02 - a20 * b04 - a23 * b00) * det,
      (a11 * b07 - a10 * b09 - a12 * b06) * det,
      (a00 * b09 - a01 * b07 + a02 * b06) * det,
      (a31 * b01 - a30 * b03 - a32 * b00) * det,
      (a20 * b03 - a21 * b01 + a22 * b00) * det
    );
  }

  /**
   * Multiplies two Mat4s not using SIMD and returns the result as a new instance.
   *
   * @param {Mat4} other - The other Mat4 to multiply with.
   * @return {Mat4} - Returns a new Mat4.
   */
  multiply(other) {
    const a00 = this.__data[0];
    const a01 = this.__data[1];
    const a02 = this.__data[2];
    const a03 = this.__data[3];
    const a10 = this.__data[4];
    const a11 = this.__data[5];
    const a12 = this.__data[6];
    const a13 = this.__data[7];
    const a20 = this.__data[8];
    const a21 = this.__data[9];
    const a22 = this.__data[10];
    const a23 = this.__data[11];
    const a30 = this.__data[12];
    const a31 = this.__data[13];
    const a32 = this.__data[14];
    const a33 = this.__data[15];

    // Cache only the current line of the second matrix
    const b = other.asArray();
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    const result = new Mat4();
    result.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    result.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    result.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    result.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    result.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    result.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    result.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    result.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    result.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    result.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    result.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    result.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    result.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    result.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    result.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    result.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return result
  }

  /**
   * Multiplies two Mat4s in place explicitly not using SIMD.
   *
   * @param {Mat4} other - The other Mat4 to multiply with.
   * @return {Mat4} - Returns a new Mat4.
   */
  multiplyInPlace(other) {
    const a = this.asArray();
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    const b = other.asArray();
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    this.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    this.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    this.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return this
  }

  /**
   * Post multiplies two Mat4s in place explicitly not using SIMD.
   *
   * @param {Mat4} other - The other Mat4 to multiply with.
   * @return {Mat3} - Returns the result as a new Mat4.
   */
  postmultiplyInPlace(other) {
    const a = other.asArray();
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    const b = this.asArray();
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    this.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    this.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    this.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    this.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    this.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    this.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return this
  }

  /**
   * Translate a Mat4 by the given vector not using SIMD.
   *
   * @param {Vec3} v3 - The given vector to translate along.
   * @return {Mat4} - The return value.
   */
  translateInPlace(v3) {
    const a = this.__data;
    const x = v3.x;
    const y = v3.y;
    const z = v3.z;
    a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return this
  }

  /**
   * Generates a look-at matrix with the given position, focal point, and up axis.
   *
   * @param {Vec3} pos - Position of the viewer.
   * @param {Vec3} target - Point the viewer is looking at.
   * @param {Vec3} up - Vec3 pointing up.
   */
  setLookAt(pos, target, up) {
    const zAxis = pos.subtract(target);
    const zLen = zAxis.length();
    if (zLen < Number.EPSILON) {
      this.setIdentity();
      return
    }
    zAxis.scaleInPlace(1.0 / zLen);

    const xAxis = up.cross(zAxis);
    const xLen = xAxis.length();
    if (xLen > Number.EPSILON) xAxis.scaleInPlace(1.0 / xLen);

    const yAxis = zAxis.cross(xAxis);
    const yLen = yAxis.length();
    if (yLen > Number.EPSILON) yAxis.scaleInPlace(1.0 / yLen);

    /* eslint-disable prettier/prettier*/
    this.set(
      xAxis.x,
      xAxis.y,
      xAxis.z,
      0,
      yAxis.x,
      yAxis.y,
      yAxis.z,
      0,
      zAxis.x,
      zAxis.y,
      zAxis.z,
      0,
      pos.x,
      pos.y,
      pos.z,
      1
    );
    /* eslint-enable prettier/prettier*/
  }

  /**
   * Creates a matrix from a given angle around a given axis.
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {Vec3} axis - The axis to rotate around.
   * @param {number} rad - The angle to rotate the matrix by.
   * @return {Mat4} - The return value.
   */
  setRotation(axis, rad) {
    const len = axis.length();

    if (Math.abs(len) < Number.EPSILON) {
      return null
    }

    const x = axis.x / len;
    const y = axis.y / len;
    const z = axis.z / len;

    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;

    // Perform rotation-specific matrix multiplication
    const a = this.__data;
    a[0] = x * x * t + c;
    a[1] = y * x * t + z * s;
    a[2] = z * x * t - y * s;
    a[3] = 0;
    a[4] = x * y * t - z * s;
    a[5] = y * y * t + c;
    a[6] = z * y * t + x * s;
    a[7] = 0;
    a[8] = x * z * t + y * s;
    a[9] = y * z * t - x * s;
    a[10] = z * z * t + c;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return this
  }

  /**
   * Creates a matrix from the given angle around the X axis.
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {number} rad - The angle to rotate the matrix by.
   * @return {Mat4} - The return value.
   */
  setXRotation(rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    const a = this.__data;
    /* eslint-disable prettier/prettier*/
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = c;
    a[6] = s;
    a[7] = 0;
    a[8] = 0;
    a[9] = -s;
    a[10] = c;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    /* eslint-enable prettier/prettier*/
    return this
  }

  /**
   * Creates a matrix from the given angle around the Y axis.
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {number} rad - The angle to rotate the matrix by.
   * @return {Mat4} - The return value.
   */
  setYRotation(rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    const a = this.__data;
    /* eslint-disable prettier/prettier*/
    a[0] = c;
    a[1] = 0;
    a[2] = -s;
    a[3] = 0;
    a[4] = 0;
    a[5] = 1;
    a[6] = 0;
    a[7] = 0;
    a[8] = s;
    a[9] = 0;
    a[10] = c;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    /* eslint-enable prettier/prettier*/
    return this
  }

  /**
   * Creates a matrix from the given angle around the Z axis.
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {number} rad - The angle to rotate the matrix by.
   * @return {Mat4} - The return value.
   */
  setZRotation(rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    const a = this.__data;
    /* eslint-disable prettier/prettier*/
    a[0] = c;
    a[1] = s;
    a[2] = 0;
    a[3] = 0;
    a[4] = -s;
    a[5] = c;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 1;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    /* eslint-enable prettier/prettier*/
    return this
  }

  /**
   * Transforms the Vec4 with a Mat4.
   *
   * @param {Vec4} vec - The vec value.
   * @return {Vec4} - Return the result as a new Vec4.
   */
  transformVec4(vec) {
    const a = this.__data;
    const x = vec.x;
    const y = vec.y;
    const z = vec.z;
    const w = vec.t;
    return new Vec4(
      a[0] * x + a[4] * y + a[8] * z + a[12] * w,
      a[1] * x + a[5] * y + a[9] * z + a[13] * w,
      a[2] * x + a[6] * y + a[10] * z + a[14] * w,
      a[3] * x + a[7] * y + a[11] * z + a[15] * w
    )
  }

  /**
   * Transforms the Vec3 with a Mat4.
   *
   * @param {Vec3} vec - The vec value.
   * @return {Vec3} - Return the result as a new Vec3.
   */
  transformVec3(vec) {
    const a = this.__data;
    const x = vec.x;
    const y = vec.y;
    const z = vec.z;
    return new Vec3$1(
      a[0] * x + a[4] * y + a[8] * z + a[12],
      a[1] * x + a[5] * y + a[9] * z + a[13],
      a[2] * x + a[6] * y + a[10] * z + a[14]
    )
  }

  /**
   * Rotates a given `Vec3` and the result is returned as a new `Vec3`
   * @param {Vec3} vec - The vec value.
   * @return {Vec3} - Return the result as a new Vec3.
   */
  rotateVec3(vec) {
    const a = this.__data;
    const x = vec.x;
    const y = vec.y;
    const z = vec.z;
    return new Vec3$1(a[0] * x + a[4] * y + a[8] * z, a[1] * x + a[5] * y + a[9] * z, a[2] * x + a[6] * y + a[10] * z)
  }

  /**
   * Set the perspective from a Mat4.
   *
   * @param {number} fovy - The fovy value.
   * @param {number} aspect - The aspect value.
   * @param {number} near - The near value.
   * @param {number} far - The far value.
   */
  setPerspectiveMatrix(fovy, aspect, near, far) {
    const f = Math.tan(Math.PI * 0.5 - 0.5 * fovy);
    const rangeInv = 1.0 / (near - far);
    /* eslint-disable prettier/prettier*/
    this.set(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (near + far) * rangeInv, -1, 0, 0, near * far * rangeInv * 2, 0);
    /* eslint-enable prettier/prettier*/
  }

  /**
   * Calculates the orthographic matrix and sets the state of the Mat4 class
   *
   * @param {number} left - The left value.
   * @param {number} right - The right value.
   * @param {number} bottom - The bottom value.
   * @param {number} top - The top value.
   * @param {number} near - The near value.
   * @param {number} far - The far value.
   */
  setOrthographicMatrix(left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    /* eslint-disable prettier/prettier*/
    this.set(
      -2 * lr,
      0,
      0,
      0,
      0,
      -2 * bt,
      0,
      0,
      0,
      0,
      2 * nf,
      0,
      (left + right) * lr,
      (top + bottom) * bt,
      (far + near) * nf,
      1
    );
    /* eslint-enable prettier/prettier*/
  }

  /**
   * Scales Mat4 Matrix
   *
   * @param {number} x - The x value.
   * @param {number} y - The y value.
   * @param {number} z - The z value.
   */
  setScale(x, y, z) {
    /* eslint-disable prettier/prettier*/
    if (x instanceof Vec3$1) {
      this.set(x.x, 0, 0, 0, 0, x.y, 0, 0, 0, 0, x.z, 0, 0, 0, 0, 1);
    } else {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    }
    /* eslint-enable prettier/prettier*/
  }

  /**
   * Transforms a 3x4 matrix into a 4x4 matrix and set the result to the Math4 state.
   *
   * @param {array} m3x4 - The m3x4 value.
   */
  setFromMat3x4Array(m3x4) {
    /* eslint-disable prettier/prettier*/
    this.set(
      m3x4[0],
      m3x4[1],
      m3x4[2],
      0,
      m3x4[3],
      m3x4[4],
      m3x4[5],
      0,
      m3x4[6],
      m3x4[7],
      m3x4[8],
      0,
      m3x4[9],
      m3x4[10],
      m3x4[11],
      1
    );
    /* eslint-enable prettier/prettier*/
  }

  /**
   * Creates a new Mat4 to wrap existing memory in a buffer.
   *
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Mat4} - Returns a new Mat4.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Mat4` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Mat4} - Returns a new Mat4.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Mat4(new Float32Array(buffer, byteOffset, 16)) // 4 bytes per 32bit float
  }

  /**
   * Clones this Mat4 returning a new instance.
   *
   * @return {Mat4} - Returns a new Mat4.
   */
  clone() {
    return new Mat4(
      this.__data[0],
      this.__data[1],
      this.__data[2],
      this.__data[3],
      this.__data[4],
      this.__data[5],
      this.__data[6],
      this.__data[7],
      this.__data[8],
      this.__data[9],
      this.__data[10],
      this.__data[11],
      this.__data[12],
      this.__data[13],
      this.__data[14],
      this.__data[15]
    )
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Mat4.
   * @param {...object} ...args - The ...args param.
   * @return {Mat4} - Returns a new Mat4.
   * @private
   */
  static create(...args) {
    return new Mat4(...args)
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return this.__data
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json param.
   */
  fromJSON(json) {
    this.__data = new Float32Array(json);
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.__data = reader.loadFloat32Array(16);
  }
}

Registry.register('Mat4', Mat4);

/* eslint-disable no-unused-vars */

/**
 * Class representing a quaternion. Quaternions are used to represent rotations
 * without encountering gimble lock. Based on complex numbers that are not easy
 * to understand intuitively.
 *
 * @extends AttrValue
 */
class Quat extends AttrValue {
  /**
   * Creates a quaternion.
   *
   * @param {number | ArrayBuffer | object} x - The angle of the x axis. Default is 0.
   * @param {number} y - The angle of the y axis. Default is 0.
   * @param {number} z - The angle of the z axis. Default is 0.
   * @param {number} w - The w value. Default is 1.
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super();

    if (x instanceof Float32Array) {
      this.__data = x;
    } else if (x instanceof ArrayBuffer) {
      console.warn(`deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))`);
      const buffer = x;
      const byteOffset = y;
      this.__data = new Float32Array(buffer, byteOffset, 4);
    } else {
      this.__data = new Float32Array(4);
      if (typeof x === 'object') {
        this.__data[0] = 0;
        this.__data[1] = 0;
        this.__data[2] = 0;
        this.__data[3] = 1;
        for (const key in x) {
          if (Array.isArray(x[key])) this[key].call(this, ...x[key]);
          else this[key].call(this, x[key]);
        }
      } else {
        this.__data[0] = x;
        this.__data[1] = y;
        this.__data[2] = z;
        this.__data[3] = w;
      }
    }
  }

  /**
   * Getter for `x` axis rotation.
   *
   * @return {number} - Returns the x axis rotation.
   */
  get x() {
    return this.__data[0]
  }

  /**
   * Setter for `x` axis rotation.
   *
   * @param {number} val - The val param.
   */
  set x(val) {
    this.__data[0] = val;
  }

  /**
   * Getter for `y` axis rotation.
   *
   * @return {number} - Returns the y axis rotation.
   */
  get y() {
    return this.__data[1]
  }

  /**
   * Setter for `y` axis rotation.
   *
   * @param {number} val - The val param.
   */
  set y(val) {
    this.__data[1] = val;
  }

  /**
   * Getter for `z` axis rotation.
   *
   * @return {number} - Returns the z axis rotation.
   */
  get z() {
    return this.__data[2]
  }

  /**
   * Setter for `z` axis rotation.
   *
   * @param {number} val - The val param.
   */
  set z(val) {
    this.__data[2] = val;
  }

  /**
   * Getter for `w` value.
   *
   * @return {number} - Returns the w value.
   */
  get w() {
    return this.__data[3]
  }

  /**
   * Setter for `w`.
   * @param {number} val - The val param.
   */
  set w(val) {
    this.__data[3] = val;
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} x - The x axis rotation.
   * @param {number} y  - The y axis rotation.
   * @param {number} z  - The z axis rotation.
   * @param {number} w  - The w value.
   */
  set(x, y, z, w) {
    this.__data[0] = x;
    this.__data[1] = y;
    this.__data[2] = z;
    this.__data[3] = w;
  }

  /**
   * Sets the state of the Quat class using a Float32Array.
   *
   * @param {Float32Array} float32Array - The float32Array value.
   */
  setDataArray(float32Array) {
    this.__data = float32Array;
  }

  /**
   * Setter from another vector.
   *
   * @param {Quat} other - The other vector to set from.
   */
  setFromOther(other) {
    this.__data[0] = other.x;
    this.__data[1] = other.y;
    this.__data[2] = other.z;
    this.__data[3] = other.w;
  }

  /**
   * Set this quat from a euler rotation.
   *
   * @param {EulerAngles} eulerAngles - The euler angles rotation.
   */
  setFromEulerAngles(eulerAngles) {
    const ordered = new Vec3$1();

    switch (eulerAngles.order) {
      case 0:
        /* 'XYZ' */
        ordered.set(eulerAngles.x, -eulerAngles.y, eulerAngles.z);
        break
      case 1:
        /* 'YZX' */
        ordered.set(eulerAngles.y, -eulerAngles.z, eulerAngles.x);
        break
      case 2:
        /* 'ZXY' */
        ordered.set(eulerAngles.z, -eulerAngles.x, eulerAngles.y);
        break
      case 3:
        /* 'XZY' */
        ordered.set(eulerAngles.x, eulerAngles.z, eulerAngles.y);
        break
      case 4:
        /* 'ZYX' */
        ordered.set(eulerAngles.z, eulerAngles.y, eulerAngles.x);
        break
      case 5:
        /* 'YXZ' */
        ordered.set(eulerAngles.y, eulerAngles.x, eulerAngles.z);
        break
      default:
        throw new Error('sdrty')
    }

    const ti = ordered.x * 0.5;
    const tj = ordered.y * 0.5;
    const tk = ordered.z * 0.5;
    const ci = Math.cos(ti);
    const cj = Math.cos(tj);
    const ck = Math.cos(tk);
    const si = Math.sin(ti);
    const sj = Math.sin(tj);
    const sk = Math.sin(tk);
    const cc = ci * ck;
    const cs = ci * sk;
    const sc = si * ck;
    const ss = si * sk;
    const ai = cj * sc - sj * cs;
    const aj = cj * ss + sj * cc;
    const ak = cj * cs - sj * sc;

    this.w = cj * cc + sj * ss;

    switch (eulerAngles.order) {
      case 0:
        /* ' XYZ' */
        this.x = ai;
        this.y = -aj;
        this.z = ak;
        break
      case 1:
        /* 'YZX' */
        this.x = ak;
        this.y = ai;
        this.z = -aj;
        break
      case 2:
        /* 'ZXY' */
        this.x = -aj;
        this.y = ak;
        this.z = ai;
        break
      case 3:
        /* 'XZY' */
        this.x = ai;
        this.y = ak;
        this.z = aj;
        break
      case 4:
        /* 'ZYX' */
        this.x = ak;
        this.y = aj;
        this.z = ai;
        break
      case 5:
        /* 'YXZ' */
        this.x = aj;
        this.y = ai;
        this.z = ak;
        break
      default:
        throw new Error('sdrty')
    }
  }

  /**
   * Converts Quat to an EulerAngles
   *
   * @param {number | string} rotationOrder - The order in which the rotations are applied.
   * @return {EulerAngles} - The return value.
   */
  toEulerAngles(rotationOrder) {
    const ordered = new Vec3$1();
    switch (rotationOrder) {
      case 0:
        /* ' XYZ' */
        ordered.set(this.z, this.x, this.y);
        break
      case 1:
        /* 'YZX' */
        ordered.set(this.x, this.y, this.z);
        break
      case 2:
        /* 'ZXY' */
        ordered.set(this.y, this.z, this.x);
        break
      case 3:
        /* 'XZY' */
        ordered.set(this.y, -this.x, this.z);
        break
      case 4:
        /* 'ZYX' */
        ordered.set(this.x, -this.z, this.y);
        break
      case 5:
        /* 'YXZ' */
        ordered.set(this.z, -this.y, this.x);
        break
      default:
        throw new Error('Invalid rotation order:' + rotationOrder)
    }

    const euler = new Vec3$1();
    const test = ordered.x * ordered.y + ordered.z * this.w;
    if (test > 0.49999) {
      // singularity at north pole
      euler.y = 2.0 * Math.atan2(ordered.x, this.w);
      euler.z = Math.PI * 0.5;
      euler.x = 0.0;
    } else if (test < -0.49999) {
      // singularity at south pole
      euler.y = -2.0 * Math.atan2(ordered.x, this.w);
      euler.z = Math.PI * -0.5;
      euler.x = 0.0;
    } else {
      const sqx = ordered.x * ordered.x;
      const sqy = ordered.y * ordered.y;
      const sqz = ordered.z * ordered.z;
      euler.y = Math.atan2(2.0 * ordered.y * this.w - 2.0 * ordered.x * ordered.z, 1.0 - 2.0 * sqy - 2.0 * sqz);
      euler.z = Math.asin(2.0 * test);
      euler.x = Math.atan2(2.0 * ordered.x * this.w - 2.0 * ordered.y * ordered.z, 1.0 - 2.0 * sqx - 2.0 * sqz);
    }

    switch (rotationOrder) {
      case 0:
        /* ' XYZ' */
        return new EulerAngles(euler.y, euler.z, euler.x, rotationOrder)
      case 1:
        /* 'YZX' */
        return new EulerAngles(euler.x, euler.y, euler.z, rotationOrder)
      case 2:
        /* 'ZXY' */
        return new EulerAngles(euler.z, euler.x, euler.y, rotationOrder)
      case 3:
        /* 'XZY' */
        return new EulerAngles(-euler.y, euler.x, euler.z, rotationOrder)
      case 4:
        /* 'ZYX' */
        return new EulerAngles(euler.x, euler.z, -euler.y, rotationOrder)
      case 5:
        /* 'YXZ' */
        return new EulerAngles(euler.z, -euler.y, euler.x, rotationOrder)
    }
  }

  /**
   * Set this quat to a rotation defined by an axis and an angle (in radians).
   *
   * @param {Vec3} axis - The axis value.
   * @param {number} angle - The axis angle.
   */
  setFromAxisAndAngle(axis, angle) {
    const halfAngle = angle / 2.0;
    const vec = axis.normalize().scale(Math.sin(halfAngle));
    this.set(vec.x, vec.y, vec.z, Math.cos(halfAngle));
  }

  /**
   * Scales and calculates the cross product of the `Vec3` and sets the result in the Mat3
   *
   * @param {Vec3} dir - The direction value.
   * @param {Vec3} up - The up angle.
   */
  setFromDirectionAndUpvector(dir, up) {
    const mat3 = new Mat3$1();
    mat3.setFromDirectionAndUpvector(dir, up);
    this.setFromMat3(mat3);
  }

  /**
   * Sets the state of the `Quat` from two `Vec3`.
   *
   * @param {Vec3} v0 - The v0 unit vector.
   * @param {Vec3} v1 - The v1 unit vector.
   */
  setFrom2Vectors(v0, v1) {
    const c = v0.cross(v1);
    const d = v0.dot(v1);
    const s = Math.sqrt((1 + d) * 2);
    // this.set( s/2, c.x / s, c.y / s, c.z / s );
    this.set(c.x / s, c.y / s, c.z / s, s / 2);
    this.normalizeInPlace();
  }

  /**
   * Set the quat from a Mat3.
   *
   * @param {Mat3} mat3 - The mat3 value.
   */
  setFromMat3(mat3) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    const fTrace = mat3.__data[0] + mat3.__data[4] + mat3.__data[8];
    let fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1); // 2w
      this.__data[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)
      this.__data[0] = (mat3.__data[5] - mat3.__data[7]) * fRoot;
      this.__data[1] = (mat3.__data[6] - mat3.__data[2]) * fRoot;
      this.__data[2] = (mat3.__data[1] - mat3.__data[3]) * fRoot;
    } else {
      // |w| <= 1/2
      let i = 0;
      if (mat3.__data[4] > mat3.__data[0]) i = 1;
      if (mat3.__data[8] > mat3.__data[i * 3 + i]) i = 2;
      const j = (i + 1) % 3;
      const k = (i + 2) % 3;

      fRoot = Math.sqrt(mat3.__data[i * 3 + i] - mat3.__data[j * 3 + j] - mat3.__data[k * 3 + k] + 1.0);
      this.__data[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      this.__data[3] = (mat3.__data[j * 3 + k] - mat3.__data[k * 3 + j]) * fRoot;
      this.__data[j] = (mat3.__data[j * 3 + i] + mat3.__data[i * 3 + j]) * fRoot;
      this.__data[k] = (mat3.__data[k * 3 + i] + mat3.__data[i * 3 + k]) * fRoot;
    }
    this.normalizeInPlace();
  }

  /**
   * Set the quat from a Mat4.
   *
   * @param {Mat4} mat4 - The mat4 value.
   */
  setFromMat4(mat4) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    const fTrace = mat4.__data[0] + mat4.__data[5] + mat4.__data[10];
    let fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1); // 2w
      this.__data[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)
      this.__data[0] = (mat4.__data[6] - mat4.__data[9]) * fRoot;
      this.__data[1] = (mat4.__data[8] - mat4.__data[2]) * fRoot;
      this.__data[2] = (mat4.__data[1] - mat4.__data[4]) * fRoot;
    } else {
      // |w| <= 1/2
      let i = 0;
      if (mat4.__data[5] > mat4.__data[0]) i = 1;
      if (mat4.__data[10] > mat4.__data[i * 4 + i]) i = 2;
      const j = (i + 1) % 3;
      const k = (i + 2) % 3;

      fRoot = Math.sqrt(mat4.__data[i * 4 + i] - mat4.__data[j * 4 + j] - mat4.__data[k * 4 + k] + 1.0);
      this.__data[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      this.__data[3] = (mat4.__data[j * 4 + k] - mat4.__data[k * 4 + j]) * fRoot;
      this.__data[j] = (mat4.__data[j * 4 + i] + mat4.__data[i * 4 + j]) * fRoot;
      this.__data[k] = (mat4.__data[k * 4 + i] + mat4.__data[i * 4 + k]) * fRoot;
    }
    this.normalizeInPlace();
  }

  /**
   * Checks if the angle of the Quat is less that ` Number.EPSILON`
   *
   * @return {boolean} - Returns true or false.
   */
  isIdentity() {
    return this.getAngle() < Number.EPSILON
  }

  /**
   * Return the angle of the Quat.
   *
   * @return {number} - The return value.
   */
  getAngle() {
    return Math.acos(this.w) * 2.0
  }

  /**
   * Returns true if this Quat is exactly the same as other.
   *
   * @param {Quat} other - The other Quat to compare with.
   * @return {boolean} - Returns true or false.
   */
  equal(other) {
    return this.x == other.x && this.y == other.y && this.z == other.z && this.w == other.w
  }

  /**
   * Returns true if this Quat is NOT exactly the same other.
   *
   * @param {Quat} other - The other Quat to compare with.
   * @return {boolean} - Returns true or false.
   */
  notEquals(other) {
    return this.x != other.x && this.y != other.y && this.z != other.z && this.w != other.w
  }

  /**
   * Returns true if this Quat is approximately the same as other
   *
   * @param {Quat} other - The other Quat to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      Math.abs(this.x - other.x) < precision &&
      Math.abs(this.y - other.y) < precision &&
      Math.abs(this.z - other.z) < precision &&
      Math.abs(this.w - other.w) < precision
    )
  }

  /**
   * Adds other to this Quat and return the result as a new Quat.
   *
   * @param {Quat} other - The other Quat to add.
   * @return {Quat} - Returns a new Quat.
   */
  add(other) {
    return new Quat(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w)
  }

  /**
   * Adds other to this Quat.
   *
   * @param {Quat} other - The other Quat to add.
   */
  addInPlace(other) {
    this.x += other.x;
    this.y += other.y;
    this.z += other.z;
    this.w += other.w;
  }

  /**
   * Subtracts other from this Quat and returns the result as a new Quat.
   *
   * @param {Quat} other - The other Quat to subtract.
   * @return {Quat} - Returns a new Quat.
   */
  subtract(other) {
    return new Quat(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w)
  }

  /**
   * Scales this Quat by scalar and returns the result as a new Quat.
   *
   * @param {number} scalar - The scalar value.
   * @return {Quat} - Returns a new Vec3.
   */
  scale(scalar) {
    return new Quat(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar)
  }

  /**
   * Scales this Quat by scalar.
   *
   * @param {number} scalar - The scalar value.
   */
  scaleInPlace(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
  }

  /**
   * Calculates the length of this Quat.
   *
   * @return {number} - Returns the length.
   */
  length() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const w = this.__data[3];
    return Math.sqrt(x * x + y * y + z * z + w * w)
  }

  /**
   * Calculates the squared length of this Quat.
   *
   * @return {number} - Returns the length.
   */
  lengthSquared() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const w = this.__data[3];
    return x * x + y * y + z * z + w * w
  }

  /**
   * Normalizes the Quat and returns it as a new Quat.
   *
   * @return {Quat} - Returns the Quat normalized.
   */
  normalize() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const w = this.__data[3];
    let len = x * x + y * y + z * z + w * w;
    if (len < Number.EPSILON) {
      return new Quat()
    }

    // TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    return new Quat(x * len, y * len, z * len)
  }

  /**
   * Normalizes the Quat, modifying it and returning it normalized.
   */
  normalizeInPlace() {
    const x = this.__data[0];
    const y = this.__data[1];
    const z = this.__data[2];
    const w = this.__data[3];
    let len = x * x + y * y + z * z + w * w;
    if (len < Number.EPSILON) {
      return
    }
    len = 1 / Math.sqrt(len);
    this.set(x * len, y * len, z * len, w * len);
  }

  /**
   * Calculates the dot product of two Quats.
   *
   * @param {Quat} other - The other Quat to compare with.
   * @return {number} - Returns the dot product.
   */
  dot(other) {
    return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w
  }

  /**
   * Calculates the cross product of two Quats and returns the result as a new Quat.
   *
   * @param {Quat} other - The other Quat to calculate with.
   * @return {Quat} - Returns the cross product as a new Quat.
   */
  cross(other) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const at = this.w;
    const bx = other.x;
    const by = other.y;
    const bz = other.z;
    const bt = other.w;

    return new Quat(ay * bz - az * by, az * bt - at * bz, at * bx - ax * bt, ax * by - ay * bx)
  }

  /**
   * Returns the rotational conjugate of this Quat.
   * Conjugation represents the same rotation of the Quat but
   * in the opposite direction around the rotational axis.
   *
   * @return {Quat} - the return value.
   */
  conjugate() {
    return new Quat(-this.x, -this.y, -this.z, this.w)
  }

  /**
   * Return the inverse of the `Quat`
   *
   * @return {Quat} - Returns a new Quat.
   */
  inverse() {
    return this.conjugate()
  }

  /**
   * Aligns this quaternion with another one ensuring that the delta between
   * the Quat values is the shortest path over the hypersphere.
   *
   *  @param {Quat} other - The other Quat to divide by.
   */
  alignWith(other) {
    if (this.dot(other) < 0.0) {
      this.set(-this.x, -this.y, -this.z, -this.w);
    }
  }

  // multiply(quat) {
  //     return new Quat(
  //         this.x * quat.w + this.w * quat.x + this.y * quat.z - this.z * quat.y,
  //         this.y * quat.w + this.w * quat.y + this.z * quat.x - this.x * quat.z,
  //         this.z * quat.w + this.w * quat.z + this.x * quat.y - this.y * quat.x,
  //         this.w * quat.w - this.x * quat.x - this.y * quat.y - this.z * quat.z
  //     );
  // }

  /**
   * Multiplies two Quats and returns the result as a new Quat.
   *
   * @param {Quat} other - The other Quat to multiply.
   * @return {Quat} - Returns a new Quat.
   */
  multiply(other) {
    const ax = this.__data[0];
    const ay = this.__data[1];
    const az = this.__data[2];
    const aw = this.__data[3];
    const bx = other.__data[0];
    const by = other.__data[1];
    const bz = other.__data[2];
    const bw = other.__data[3];

    return new Quat(
      ax * bw + aw * bx + ay * bz - az * by,
      ay * bw + aw * by + az * bx - ax * bz,
      az * bw + aw * bz + ax * by - ay * bx,
      aw * bw - ax * bx - ay * by - az * bz
    )
  }

  /**
   * Multiplies two Quats.
   *
   * @param {Quat} other - The other Quat to multiply.
   */
  multiplyInPlace(other) {
    const ax = this.__data[0];
    const ay = this.__data[1];
    const az = this.__data[2];
    const aw = this.__data[3];
    const bx = other.__data[0];
    const by = other.__data[1];
    const bz = other.__data[2];
    const bw = other.__data[3];

    this.set(
      ax * bw + aw * bx + ay * bz - az * by,
      ay * bw + aw * by + az * bx - ax * bz,
      az * bw + aw * bz + ax * by - ay * bx,
      aw * bw - ax * bx - ay * by - az * bz
    );
  }

  /**
   * Rotates a vector by this quaterion.
   * Don't forget to normalize the quaternion unless
   * you want axial translation as well as rotation.
   *
   * @param {Vec3} vec3 - The vec3 value.
   * @return {Vec3} - Returns a new Vec3.
   */
  rotateVec3(vec3) {
    const vq = new Quat(vec3.x, vec3.y, vec3.z, 0.0);
    const pq = this.multiply(vq).multiply(this.conjugate());
    return new Vec3$1(pq.x, pq.y, pq.z)
  }

  /**
   * Rotates a quaternion by the given angle about the X axis.
   *
   * @param {number} rad - Angle (in radians) to rotate.
   */
  rotateX(rad) {
    rad *= 0.5;

    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);

    this.x = ax * bw + aw * bx;
    this.y = ay * bw + az * bx;
    this.z = az * bw - ay * bx;
    this.w = aw * bw - ax * bx;
  }

  /**
   * Rotates a quaternion by the given angle about the Y axis.
   *
   * @param {number} rad - Angle (in radians) to rotate.
   */
  rotateY(rad) {
    rad *= 0.5;

    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const by = Math.sin(rad);
    const bw = Math.cos(rad);

    this.x = ax * bw - az * by;
    this.y = ay * bw + aw * by;
    this.z = az * bw + ax * by;
    this.w = aw * bw - ay * by;
  }

  /**
   * Rotates a quaternion by the given angle about the Z axis.
   *
   * @param {number} rad - Angle (in radians) to rotate.
   */
  rotateZ(rad) {
    rad *= 0.5;

    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);

    this.x = ax * bw + ay * bz;
    this.y = ay * bw - ax * bz;
    this.z = az * bw + aw * bz;
    this.w = aw * bw - az * bz;
  }

  /**
   * Converts this Quat to a Mat3 (a 3x3 matrix).
   *
   * @return {Mat3} - TReturns a new Mat3.
   */
  toMat3() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;

    const mat3 = new Mat3$1();
    mat3.__data[0] = 1 - yy - zz;
    mat3.__data[3] = yx - wz;
    mat3.__data[6] = zx + wy;

    mat3.__data[1] = yx + wz;
    mat3.__data[4] = 1 - xx - zz;
    mat3.__data[7] = zy - wx;

    mat3.__data[2] = zx - wy;
    mat3.__data[5] = zy + wx;
    mat3.__data[8] = 1 - xx - yy;

    return mat3
  }

  /**
   * Returns the X axis of this quaternion.
   *
   * @return {Vec3} - Returns the X axis as a Vec3.
   */
  getXaxis() {
    const xy = this.x * this.y;
    const xz = this.x * this.z;
    const yy = this.y * this.y;
    const yw = this.y * this.w;
    const zz = this.z * this.z;
    const zw = this.z * this.w;

    return new Vec3$1(1.0 - 2.0 * (zz + yy), 2.0 * (xy + zw), 2.0 * (xz - yw))
  }

  /**
   * Returns the Y axis of this quaternion.
   *
   * @return {Vec3} - Returns the Y axis as a Vec3.
   */
  getYaxis() {
    const xx = this.x * this.x;
    const xy = this.x * this.y;
    const xw = this.x * this.w;
    const yz = this.y * this.z;
    const zz = this.z * this.z;
    const zw = this.z * this.w;

    return new Vec3$1(2.0 * (xy - zw), 1.0 - 2.0 * (zz + xx), 2.0 * (yz + xw))
  }

  /**
   * Returns the Z axis of this quaternion.
   *
   * @return {Vec3} - Returns the Z axis as a Vec3.
   */
  getZaxis() {
    const xx = this.x * this.x;
    const xz = this.x * this.z;
    const xw = this.x * this.w;

    const yy = this.y * this.y;
    const yz = this.y * this.z;
    const yw = this.y * this.w;
    const temp = new Vec3$1();

    return new Vec3$1(2.0 * (yw + xz), 2.0 * (yz - xw), 1.0 - 2.0 * (yy + xx))
  }

  /**
   * Reflects this quaternion according to the axis provided.
   *
   * @param {number} axisIndex - An integer with value of 0 for the X axis, 1 for the Y axis, and 2 for the Z axis.
   * @return {Quat} - Returns a new Quat.
   */
  mirror(axisIndex) {
    switch (axisIndex) {
      case 0:
        return new Quat(this.z, this.w, this.x, this.y)
      case 1:
        return new Quat(-this.w, this.z, this.y, -this.x)
      case 2:
        return new Quat(this.x, this.y, this.z, -this.w)
    }
  }

  /**
   * Converts this Quat to a Mat4 (a 4x4 matrix).
   *
   * @return {Mat4} - Returns a new Mat4.
   */
  toMat4() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;

    // Set the columns
    const mat4 = new Mat4();
    mat4.__data[0] = 1 - yy - zz;
    mat4.__data[4] = yx - wz;
    mat4.__data[8] = zx + wy;

    mat4.__data[1] = yx + wz;
    mat4.__data[5] = 1 - xx - zz;
    mat4.__data[9] = zy - wx;

    mat4.__data[2] = zx - wy;
    mat4.__data[6] = zy + wx;
    mat4.__data[10] = 1 - xx - yy;

    return mat4
  }

  /**
   * Performs a linear interpolation between two Quats.
   *
   * @param {Quat} other  - The other Quat to interpolate between.
   * @param {number} t - Interpolation amount between the two inputs.
   * @return {Quat} - Returns a new Quat.
   */
  lerp(other, t) {
    const result = new Quat(
      this.x + t * (other.x - this.x),
      this.y + t * (other.y - this.y),
      this.z + t * (other.z - this.z),
      this.w + t * (other.w - this.w)
    );
    result.normalizeInPlace();
    return result
  }

  // /**
  //  * Generates a random vector with the given scale.
  //  * @param {number} scale -  Length of the resulting vector. If ommitted, a unit vector will be returned.
  //  * @returns {vec4} - The return value.
  //  */
  // random(scale = 1.0) {
  //     const r = glMatrix.RANDOM() * 2.0 * Math.PI;
  //     const z = (glMatrix.RANDOM() * 2.0) - 1.0;
  //     const zScale = Math.sqrt(1.0 - z * z) * scale;

  //     out[0] = Math.cos(r) * zScale;
  //     out[1] = Math.sin(r) * zScale;
  //     out[2] = z * scale;
  //     return out;
  // }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Quat.
   * @param {...object} ...args - The ...args param.
   * @return {Quat} - Returns a new Quat.
   * @private
   */
  static create(...args) {
    return new Quat(...args)
  }

  /**
   * Creates a new Quat to wrap existing memory in a buffer.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} offset - The offset value.
   * @return {Quat} - Returns a new Quat.
   * @deprecated
   * @private
   */
  static createFromFloat32Buffer(buffer, offset = 0) {
    console.warn('Deprecated, use #createFromBuffer instead');
    return this.createFromBuffer(buffer, offset * 4)
  }

  /**
   * Creates an instance of a `Quat` using an ArrayBuffer.
   *
   * @static
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {number} byteOffset - The offset value.
   * @return {Quat} - Returns a new Quat.
   */
  static createFromBuffer(buffer, byteOffset) {
    return new Quat(new Float32Array(buffer, byteOffset, 4)) // 4 bytes per 32bit float
  }

  /**
   * Returns the number of Float32 elements used by this type. Used to calculate storage requirements for large arrays of this type.
   * @return {number} - The return value.
   * @private
   */
  static numElements() {
    return 4
  }

  /**
   * Clones this Quat and returns a new Quat.
   *
   * @return {Quat} - Returns a new Quat.
   */
  clone() {
    return new Quat(this.__data[0], this.__data[1], this.__data[2], this.__data[3])
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.__data[0] = j.x;
    this.__data[1] = j.y;
    this.__data[2] = j.z;
    this.__data[3] = j.w;
    this.normalizeInPlace();
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.x = reader.loadFloat32();
    this.y = reader.loadFloat32();
    this.z = reader.loadFloat32();
    this.w = reader.loadFloat32();
  }
}

Registry.register('Quat', Quat);

/* eslint-disable new-cap */

/**
 * Class representing a ray that emits from an origin in a specified direction.
 */
class Ray {
  /**
   * Create a ray.
   *
   * @param {Vec3} start - The origin of the ray.
   * @param {Vec3} dir - The direction of the ray.
   */
  constructor(start = undefined, dir = undefined) {
    if (start instanceof Vec3$1) {
      this.start = start;
    } else {
      this.start = new Vec3$1();
    }
    if (dir instanceof Vec3$1) {
      this.dir = dir;
    } else {
      this.dir = new Vec3$1();
    }
  }

  /**
   * Get the closest point.
   *
   * @param {Vec3} point - The point in 3D space.
   * @return {Ray} - Returns a Ray.
   */
  closestPoint(point) {
    const w = point.subtract(this.start);
    const c1 = w.dot(this.dir);
    if (c1 < Number.EPSILON) return this.start
    const c2 = this.dir.dot(this.dir);
    // if (c2 < Number.EPSILON) return this.start
    const fract = c1 / c2;
    return this.start.add(this.dir.scale(fract))
  }

  /**
   * Get the closest point at a distance.
   *
   * @param {Vec3} dist - The distance value.
   * @return {Ray} - Returns a Ray.
   */
  pointAtDist(dist) {
    return this.start.add(this.dir.scale(dist))
  }

  /**
   * Returns the two ray params that represent the closest point between the two rays.
   *
   * @param {Ray} ray - The ray value.
   * @return {Ray} - Returns a Ray.
   */
  intersectRayVector(ray) {
    const u = this.dir;
    const v = ray.dir;
    const w = this.start.subtract(ray.start);
    const a = u.dot(u); // always >= 0
    const b = u.dot(v);
    const c = v.dot(v); // always >= 0
    const d = u.dot(w);
    const e = v.dot(w);
    if (a == 0.0 && c == 0.0) {
      return this.start.distanceTo(ray.start)
    }
    if (a == 0.0) {
      return ray.closestPoint(this.start)
    }
    if (c == 0.0) {
      return this.closestPoint(ray.start)
    }
    const D = a * c - b * b; // always >= 0

    // compute the ray parameters of the two closest points
    let this_t;
    let ray_t;
    if (D < 0.001) {
      // the lines are almost parallel
      this_t = 0.0;
      if (b > c) {
        // use the largest denominator
        ray_t = d / b;
      } else {
        ray_t = e / c;
      }
    } else {
      this_t = (b * e - c * d) / D;
      ray_t = (a * e - b * d) / D;
    }
    return [this_t, ray_t]
  }

  /**
   * Returns one ray param representing the intersection
   * of this ray against the plane defined by the given ray.
   *
   * @param {Vec3} plane - The plane to intersect with.
   * @return {number} - The return value.
   */
  intersectRayPlane(plane) {
    const w = this.start.subtract(plane.start);
    const D = plane.dir.dot(this.dir);
    const N = -plane.dir.dot(w);

    if (Math.abs(D) < Number.PRECISION) {
      // segment is parallel to plane
      if (N == 0.0) return -1.0
      // segment lies in plane
      else return -1.0 // no intersection
    }
    // they are not parallel
    // compute intersect param
    const sI = N / D;
    if (sI < -Number.PRECISION) {
      return -1 // no intersection
    }
    return sI
  }

  /**
   * Clones this Ray and returns a new Ray.
   *
   * @return {Ray} - Returns a new Ray.
   */
  clone() {
    return new Ray(this.start.clone(), this.dir.clone())
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Ray.
   * @param {...object} ...args - The ...args param.
   * @return {Ray} - Returns a new Ray.
   * @private
   */
  static create(...args) {
    return new Ray(...args)
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      start: this.start,
      dir: this.dir,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.start.fromJSON(j.start);
    this.dir.fromJSON(j.dir);
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('Ray', Ray);

/* eslint-disable no-unused-vars */

const sc_helper = new Vec3$1(1, 1, 1);

/**
 * Class representing an Xfo transform, which is a transformation decomposed into 3 component values. Translation, Orientation, and Scaling.
 */
class Xfo {
  /**
   * Initializes the Xfo object.
   * <br>
   * **Note:** You can leave it empty and use other methods ti set the state of the class.
   *
   * @see [`setFromOther`](#setFromOther) [`fromMat4`](#fromMat4) [`setFromFloat32Array`](#setFromFloat32Array) [`fromJSON`](#fromJSON)
   *
   * @param {Float32Array | Vec3} tr - The translation value.
   * @param {Quat} ori - The orientation value.
   * @param {Vec3} sc - The scaling value.
   */
  constructor(tr = undefined, ori = undefined, sc = undefined) {
    if (tr instanceof Float32Array) {
      this.setFromFloat32Array(tr);
      return
    }
    if (tr instanceof Vec3$1) {
      this.tr = tr;
    } else if (tr instanceof Quat && ori == undefined && sc == undefined) {
      this.tr = new Vec3$1();
      this.ori = tr; // Xfo constructor with just a Quat.
      this.sc = new Vec3$1(1, 1, 1);
      return
    } else {
      this.tr = new Vec3$1();
    }
    if (ori instanceof Quat) {
      this.ori = ori;
    } else {
      this.ori = new Quat();
    }
    if (sc instanceof Vec3$1) {
      this.sc = sc;
    } else {
      this.sc = new Vec3$1(1, 1, 1);
    }
  }

  /**
   * Sets the state of the Xfo object.
   *
   * @param {Vec3} tr - The translation value.
   * @param {Quat} ori - The orientation value.
   * @param {Vec3} sc - The scaling value.
   */
  set(tr, ori, sc = undefined) {
    this.tr = tr;
    this.ori = ori;
    if (sc instanceof Vec3$1) this.sc = sc;
  }

  /**
   * Sets the state of the Xfo object using another Xfo object.
   *
   * @param {Xfo} other - The other Xfo to set from.
   */
  setFromOther(other) {
    this.tr = other.tr;
    this.ori = other.ori;
    this.sc = other.sc;
  }

  /**
   * Verifies that the Xfo object is an `identity`, checking that the translation, orientation and scaling attributes are in their initial state.
   *
   * @return {boolean} - The return value.
   */
  isIdentity() {
    return this.tr.isNull() && this.ori.isIdentity() && this.sc.is111()
  }

  /**
   * Checks if this Vec3 is exactly the same as another Vec3.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @return {boolean} - Returns `true` if are the same Vector, otherwise, `false`.
   */
  isEqual(other) {
    return this.tr.isEqual(other.tr) && this.ori.isEqual(other.ori) && this.sc.isEqual(other.sc)
  }

  /**
   * Returns true if this Vec2 is approximately the same as other.
   *
   * @param {Vec3} other - The other Vec3 to compare with.
   * @param {number} precision - The precision to which the values must match.
   * @return {boolean} - Returns true or false.
   */
  approxEqual(other, precision = Number.EPSILON) {
    return (
      (other.tr ? this.tr.approxEqual(other.tr, precision) : true) &&
      (other.ori ? this.ori.approxEqual(other.ori, precision) : true) &&
      (other.sc ? this.sc.approxEqual(other.sc, precision) : true)
    )
  }

  /**
   * The setLookAt method.
   * @param {Vec3} pos - The position value.
   * @param {Vec3} target - The target value.
   * @param {Vec3} up - The up value.
   */
  setLookAt(pos, target, up) {
    // Note: We look along the -z axis. Negate the direction.
    const dir = pos.subtract(target);
    const dirLen = dir.length();
    if (dirLen < Number.EPSILON) {
      throw new Error('Invalid dir')
    }
    this.ori.setFromDirectionAndUpvector(dir, up);
    this.tr = pos;
  }

  /**
   * Multiplies two Xfo transforms.
   *
   * @param {Xfo} xfo - The xfo to multiply with.
   * @return {Xfo} - Returns an Xfo.
   */
  multiply(xfo) {
    let this_sc = this.sc;
    if (this.sc.x != this.sc.y || this.sc.x != this.sc.z) {
      this_sc = xfo.ori.rotateVec3(this.sc);
      if (Math.sign(this_sc.x) != Math.sign(this.sc.x)) this_sc.x = -this_sc.x;
      if (Math.sign(this_sc.y) != Math.sign(this.sc.y)) this_sc.y = -this_sc.y;
      if (Math.sign(this_sc.z) != Math.sign(this.sc.z)) this_sc.z = -this_sc.z;
    }
    const result = new Xfo(
      this.tr.add(this.ori.rotateVec3(this_sc.multiply(xfo.tr))),
      this.ori.multiply(xfo.ori),
      this_sc.multiply(xfo.sc)
    );
    return result
  }

  /**
   * Returns the inverse of the Xfo object, but returns. the result as a new Xfo.
   *
   * @return {Xfo} - Returns a new Xfo.
   */
  inverse() {
    const result = new Xfo();
    result.ori = this.ori.inverse();

    if (this.sc.x != this.sc.y || this.sc.x != this.sc.z) {
      // Note: the following code has not been tested and
      // may not be quite correct. We need to setup
      // unit tests for this kind of sample.
      // An example would be to lay out some boxes on different rotations
      // and with non-uniform scale. Then parent them together. If they
      // remain stationary, after parenting, then this math is correct.
      result.sc = result.ori.rotateVec3(this.sc);
      if (Math.sign(result.sc.x) != Math.sign(this.sc.x)) result.sc.x = -result.sc.x;
      if (Math.sign(result.sc.y) != Math.sign(this.sc.y)) result.sc.y = -result.sc.y;
      if (Math.sign(result.sc.z) != Math.sign(this.sc.z)) result.sc.z = -result.sc.z;
    } else {
      result.sc = this.sc.inverse();
    }
    result.tr = result.ori.rotateVec3(this.tr.negate().multiply(result.sc));
    return result
  }

  /**
   * Transforms Xfo object using a `Vec3` object. First scaling it, then rotating and finally adding the result to current translation object.
   *
   * @param {Vec3} vec3 - The vec3 value.
   * @return {Vec3} - The return value.
   */
  transformVec3(vec3) {
    return this.tr.add(this.ori.rotateVec3(this.sc.multiply(vec3)))
  }

  /**
   * Converts this Xfo to a Mat4 (a 4x4 matrix).
   *
   * @return {Mat4} - Returns a new Mat4.
   */
  toMat4() {
    const scl = new Mat4(this.sc.x, 0, 0, 0, 0, this.sc.y, 0, 0, 0, 0, this.sc.z, 0, 0, 0, 0, 1.0);

    const rot = this.ori.toMat4();

    const trn = new Mat4();
    trn.translation = this.tr;

    return trn.multiply(rot).multiply(scl)
  }

  /**
   * Sets the state of the Xfo object using Mat4.
   *
   * @param {Mat4} mat4 - The mat4 value.
   */
  fromMat4(mat4) {
    this.tr = mat4.translation;
    this.ori.setFromMat4(mat4);
  }

  /**
   * Sets the state of the Xfo object using an `Float32array`.
   * <br>
   * **Note:** You can set the byteOffset in your `Float32array` object
   *
   * @param {Float32Array} float32array - The float32array value.
   */
  setFromFloat32Array(float32array) {
    if (float32array.length == 7) {
      this.tr = new Vec3$1(float32array.buffer, float32array.byteOffset);
      this.ori = new Quat(float32array.buffer, float32array.byteOffset + 12);
      this.sc = new Vec3$1(1, 1, 1);
      return
    }
    if (float32array.length == 8) {
      this.tr = new Vec3$1(float32array.buffer, float32array.byteOffset);
      this.ori = new Quat(float32array.buffer, float32array.byteOffset + 12);
      const scl = float32array[7];
      this.sc = new Vec3$1(scl, scl, scl);
      return
    }
    if (float32array.length == 10) {
      this.tr = new Vec3$1(float32array.buffer, float32array.byteOffset);
      this.ori = new Quat(float32array.buffer, float32array.byteOffset + 12);
      this.sc = new Vec3$1(float32array.buffer, float32array.byteOffset + 21);
      return
    }
  }

  /**
   * Clones this Xfo and returns a new Xfo.
   *
   * @return {Xfo} - Returns a new Xfo.
   */
  clone() {
    return new Xfo(this.tr.clone(), this.ori.clone(), this.sc.clone())
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Xfo.
   * @param {...object} ...args - The ...args param.
   * @return {Xfo} - eturns a new Xfo.
   * @private
   */
  static create(...args) {
    return new Xfo(...args)
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    const j = {
      tr: this.tr.toJSON(),
      ori: this.ori.toJSON(),
    };
    if (!this.sc.is111()) j.sc = this.sc.toJSON();
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.tr.fromJSON(j.tr);
    this.ori.fromJSON(j.ori);
    if (j.sc) {
      this.sc.fromJSON(j.sc);
    }
  }

  /**
   * Loads the state of the value from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  readBinary(reader) {
    this.tr.readBinary(reader);
    this.ori.readBinary(reader);
    this.sc.readBinary(reader);
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @return {string} - The return value.
   */
  toString() {
    // eslint-disable-next-line new-cap
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('Xfo', Xfo);

/* eslint-disable camelcase */

/**
 * Represents a box in 2D space. Needing two Vec2 vectors describing the corners
 */
class Box2 {
  /**
   * Creates a Box2 object using Vec2s.
   * In case the parameters are not passed by, their values are pre-defined:
   * <br>
   * p0 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
   * <br>
   * p1 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
   *
   * @param {Vec2} p0 - A point representing the corners of a 2D box.
   * @param {Vec2} p1 - A point representing the corners of a 2D box.
   */
  constructor(p0 = undefined, p1 = undefined) {
    if (p0 instanceof Vec2) {
      this.p0 = p0;
    } else {
      this.p0 = new Vec2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
    }
    if (p1 instanceof Vec2) {
      this.p1 = p1;
    } else {
      this.p1 = new Vec2(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
  }

  /**
   * Sets both Vect2 points
   *
   * @param {Vec2} p0 - A point representing the corners of a 2D box.
   * @param {Vec2} p1 - A point representing the corners of a 2D box.
   */
  set(p0, p1) {
    this.p0 = p0;
    this.p1 = p1;
  }

  /**
   * Resets the box2 back to an uninitialized state.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
   * and {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
   */
  reset() {
    this.p0.x = Number.POSITIVE_INFINITY;
    this.p1.x = Number.NEGATIVE_INFINITY;
    this.p0.y = Number.POSITIVE_INFINITY;
    this.p1.y = Number.NEGATIVE_INFINITY;
  }

  /**
   * Returns `true` if the box has been expanded to contain a point.
   *
   * @return {boolean} - The return value.
   */
  isValid() {
    return (
      this.p0.x != Number.POSITIVE_INFINITY &&
      this.p1.x != Number.NEGATIVE_INFINITY &&
      this.p0.y != Number.POSITIVE_INFINITY &&
      this.p1.y != Number.NEGATIVE_INFINITY
    )
  }

  /**
   * Expands the Box2 to contain the new point.
   *
   * @param {Vec2} point - A point represents the corners of a 2D box.
   */
  addPoint(point) {
    if (this.p0.x == Number.POSITIVE_INFINITY || point.x < this.p0.x) this.p0.x = point.x;
    if (this.p0.y == Number.POSITIVE_INFINITY || point.y < this.p0.y) this.p0.y = point.y;

    if (this.p1.y == Number.NEGATIVE_INFINITY || point.x > this.p1.x) this.p1.x = point.x;
    if (this.p1.y == Number.NEGATIVE_INFINITY || point.y > this.p1.y) this.p1.y = point.y;
  }

  /**
   * Returns the size of a Box2.
   *
   * @return {Box2} - Returns a Box2.
   */
  size() {
    return this.p1.subtract(this.p0)
  }

  /**
   * Returns the size of a Box2 - the same as size().
   *
   * @return {Box2} - Returns a Box2.
   */
  diagonal() {
    return this.p1.subtract(this.p0)
  }

  /**
   * Returns the center point of a Box2.
   *
   * @return {Vec2} - Returns a Vec2.
   */
  center() {
    const result = this.p1.subtract(this.p0);
    result.scaleInPlace(0.5);
    result.addInPlace(this.p0);
    return result
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Box2.
   * @param {...object} ...args - The ...args param.
   * @return {Box2} - Returns a new Box2.
   * @private
   */
  static create(...args) {
    return new Box2(...args)
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Encodes `Box2` Class as a JSON object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      p0: this.p0.toJSON(),
      p1: this.p1.toJSON(),
    }
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    // eslint-disable-next-line new-cap
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('Box2', Box2);

/* eslint-disable new-cap */

/**
 * Class representing a sphere.
 *
 * @extends AttrValue
 */
class SphereType extends AttrValue {
  /**
   * Create a sphere.
   * @param {Vec3} pos - The position of the sphere.
   * @param {number} radius - The radius of the sphere.
   */
  constructor(pos, radius = 0) {
    super();
    if (pos instanceof Vec3$1) {
      this.pos = pos;
    } else {
      this.pos = new Vec3$1();
    }
    this.radius = radius;
  }

  /**
   * Clones this sphere and returns a new sphere.
   *
   * @return {Sphere} - Returns a new sphere.
   */
  clone() {
    return new Sphere(this.pos.clone(), this.radius)
  }

  /**
   * Checks if this sphere intersects a box.
   *
   * @param {Box3} box - The box value.
   * @return {boolean} - The return value.
   */
  intersectsBox(box) {
    return box.intersectsSphere(this)
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      pos: this.pos.toJSON(),
      radius: this.radius,
    }
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new sphere.
   *
   * @param {...object} ...args - The ...args param.
   * @return {Sphere} - Returns a new sphere.
   * @private
   */
  static create(...args) {
    return new Sphere(...args)
  }
}

Registry.register('SphereType', SphereType);

/* eslint-disable camelcase */

/**
 * Class representing a box in 3D space.
 * Represents a box in 3D space defined by two Vec3 values which define opposing corners of the box.
 */
class Box3$1 {
  /**
   * Creates a Box3 object using Vec3s.
   * In case the parameters are not passed by, their values are pre-defined:
   * <br>
   * p0 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
   * <br>
   * p1 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
   *
   * @param {Vec3} p0 - A point representing the corners of a 3D box.
   * @param {Vec3} p1 - A point representing the corners of a 3D box.
   */
  constructor(p0 = undefined, p1 = undefined) {
    if (p0 instanceof Float32Array) {
      this.setFromFloat32Array(p0);
      return
    }
    if (p0 instanceof Vec3$1) {
      this.p0 = p0;
    } else {
      this.p0 = new Vec3$1(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
    }
    if (p1 instanceof Vec3$1) {
      this.p1 = p1;
    } else {
      this.p1 = new Vec3$1(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
  }

  /**
   * Getter for the lower (x, y, z) boundary of the box.
   *
   * @return {Vec3} - Returns the minumum Vec3.
   */
  get min() {
    return this.p0
  }

  /**
   * Getter for the upper (x, y, z) boundary of the box.
   *
   * @return {Vec3} - Returns the minumum Vec3.
   */
  get max() {
    return this.p1
  }

  /**
   * Sets both Vect3 points
   *
   * @param {Vec3} p0 - A point representing the corners of a 3D box.
   * @param {Vec3} p1 - A point representing the corners of a 3D box.
   */
  set(p0, p1) {
    this.p0 = p0;
    this.p1 = p1;
  }

  /**
   * Resets the box3 back to an uninitialized state.
   */
  reset() {
    this.p0.x = Number.POSITIVE_INFINITY;
    this.p1.x = Number.NEGATIVE_INFINITY;
    this.p0.y = Number.POSITIVE_INFINITY;
    this.p1.y = Number.NEGATIVE_INFINITY;
    this.p0.z = Number.POSITIVE_INFINITY;
    this.p1.z = Number.NEGATIVE_INFINITY;
  }

  /**
   * Returns `true` if the box has been expanded to contain a point.
   *
   * @return {boolean} - The return value.
   */
  isValid() {
    return (
      this.p0.x != Number.POSITIVE_INFINITY &&
      this.p1.x != Number.NEGATIVE_INFINITY &&
      this.p0.y != Number.POSITIVE_INFINITY &&
      this.p1.y != Number.NEGATIVE_INFINITY &&
      this.p0.z != Number.POSITIVE_INFINITY &&
      this.p1.z != Number.NEGATIVE_INFINITY
    )
  }

  /**
   * Expands the Box3 to contain the new point.
   *
   * @param {Vec3} point - A point represents the corners of a 3D box.
   */
  addPoint(point) {
    if (point.x != Number.POSITIVE_INFINITY && point.x != Number.NEGATIVE_INFINITY) {
      if (point.x < this.p0.x) this.p0.x = point.x;
      if (point.x > this.p1.x) this.p1.x = point.x;
    }
    if (point.y != Number.POSITIVE_INFINITY && point.y != Number.NEGATIVE_INFINITY) {
      if (point.y < this.p0.y) this.p0.y = point.y;
      if (point.y > this.p1.y) this.p1.y = point.y;
    }
    if (point.z != Number.POSITIVE_INFINITY && point.z != Number.NEGATIVE_INFINITY) {
      if (point.z < this.p0.z) this.p0.z = point.z;
      if (point.z > this.p1.z) this.p1.z = point.z;
    }
  }

  /**
   * Adds `Box3` to this `Box3`, of the Xfo instance is passed in the parameters
   * it proceeds to apply the transform for the Vec3.
   *
   * @param {Box3} box3 - A 3D box.
   * @param {Xfo} xfo - A 3D transform.
   */
  addBox3(box3, xfo = undefined) {
    if (xfo) {
      // Transform each corner of the Box3 into the new coordinate system.
      this.addPoint(xfo.transformVec3(box3.p0));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p0.x, box3.p0.y, box3.p1.z)));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p0.x, box3.p1.y, box3.p0.z)));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p1.x, box3.p0.y, box3.p0.z)));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p0.x, box3.p1.y, box3.p1.z)));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p1.x, box3.p0.y, box3.p1.z)));
      this.addPoint(xfo.transformVec3(new Vec3$1(box3.p1.x, box3.p1.y, box3.p0.z)));
      this.addPoint(xfo.transformVec3(box3.p1));
    } else {
      this.addPoint(box3.p0);
      this.addPoint(box3.p1);
    }
  }

  /**
   * Returns the size of the Box3.
   *
   * @return {Box3} - Returns a Box3.
   */
  size() {
    return this.p1.subtract(this.p0)
  }

  /**
   * Returns the size of a Box3 - the same as size().
   *
   * @return {Box3} - Returns a Box3.
   */
  diagonal() {
    return this.p1.subtract(this.p0)
  }

  /**
   * Returns the center point of a Box3.
   *
   * @return {Vec3} - Returns a Vec3.
   */
  center() {
    const result = this.p1.subtract(this.p0);
    result.scaleInPlace(0.5);
    result.addInPlace(this.p0);
    return result
  }

  /**
   * Converts this Box3 to a Mat4 (a 4x4 matrix).
   *
   * @return {Mat4} - Returns a new Mat4.
   */
  toMat4() {
    const scx = this.p1.x - this.p0.x;
    const scy = this.p1.y - this.p0.y;
    const scz = this.p1.z - this.p0.z;
    return new Mat4(scx, 0, 0, 0, 0, scy, 0, 0, 0, 0, scz, 0, this.p0.x, this.p0.y, this.p0.z, 1.0)
  }

  /**
   * Calculates and returns the bounding Sphere of the Box3
   *
   * @return {SphereType} - The return value.
   */
  getBoundingSphere() {
    return new SphereType(this.center(), this.diagonal().length() * 0.5)
  }

  /**
   * Determines if this Box3 intersects a plane.
   *
   * @param {Box3} box - The box to check for intersection against.
   * @return {boolean} - The return value.
   */
  intersectsBox(box) {
    // Using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y ||
      box.max.z < this.min.z ||
      box.min.z > this.max.z
      ? false
      : true
  }

  /**
   * Determines if this Box3 intersects a sphere.
   *
   * @param {Sphere} sphere - The sphere to check for intersection against.
   * @return {boolean} - The return value.
   */
  intersectsSphere(sphere) {
    // var closestPoint = new Vector3();

    // Find the point on the AABB closest to the sphere center.
    // this.clampPoint( sphere.center, closestPoint );

    // If that point is inside the sphere, the AABB and sphere intersect.
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
  }

  /**
   * Determines if this Box3 intersects a plane.
   *
   * @param {Plane} plane - The plane to check for intersection against.
   * @return {boolean} - The return value.
   */
  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.

    let min;
    let max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant
  }

  /**
   * Clones this Box3 and returns a new Box3.
   * @return {Box3} - Returns a new Box3.
   */
  clone() {
    return new Box3$1(this.p0.clone(), this.p1.clone())
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new Box3.
   * @param {...object} ...args - The ...args param.
   * @return {Box3} - Returns a new Box3.
   * @private
   */
  static create(...args) {
    return new Box3$1(...args)
  }

  /**
   * The sizeInBytes method.
   * @return {any} - The return value.
   * @private
   */
  static sizeInBytes() {
    return 24
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Encodes `Box3` Class as a JSON object for persistence.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      p0: this.p0.toJSON(),
      p1: this.p1.toJSON(),
    }
  }

  /**
   * Decodes a JSON object to set the state of this class.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    // We need to verify that p0 and p1 axes are numeric, so in case they are not, we restore them to their default values.
    // This, because 'Infinity' and '-Infinity' are stringified as 'null'.
    const p0 = {
      x: MathFunctions.isNumeric(j.p0.x) ? j.p0.x : Number.POSITIVE_INFINITY,
      y: MathFunctions.isNumeric(j.p0.y) ? j.p0.y : Number.POSITIVE_INFINITY,
      z: MathFunctions.isNumeric(j.p0.z) ? j.p0.z : Number.POSITIVE_INFINITY,
    };
    const p1 = {
      x: MathFunctions.isNumeric(j.p1.x) ? j.p1.x : Number.NEGATIVE_INFINITY,
      y: MathFunctions.isNumeric(j.p1.y) ? j.p1.y : Number.NEGATIVE_INFINITY,
      z: MathFunctions.isNumeric(j.p1.z) ? j.p1.z : Number.NEGATIVE_INFINITY,
    };
    this.p0.fromJSON(p0);
    this.p1.fromJSON(p1);
  }

  /**
   * The loadBin method.
   * @param {any} data - The data value.
   * @param {any} byteOffset - The byteOffset value.
   * @private
   */
  loadBin(data, byteOffset) {
    this.p0.loadBin(data, byteOffset);
    this.p0.loadBin(data, byteOffset + 12);
  }

  /**
   * The setFromFloat32Array method.
   * @param {Float32Array} float32array - The float32array value.
   * @private
   */
  setFromFloat32Array(float32array) {
    this.p0 = new Vec3$1(float32array.buffer, float32array.byteOffset);
    this.p1 = new Vec3$1(float32array.buffer, float32array.byteOffset + 12);
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    // eslint-disable-next-line new-cap
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('Box3', Box3$1);

/* eslint-disable new-cap */

/**
 * Class representing a plane.
 *
 * @extends AttrValue
 */
class PlaneType extends AttrValue {
  /**
   * Create a plane.
   *
   * @param {Vec3} normal - The normal of the plane.
   * @param {number} w - The w value.
   */
  constructor(normal, w = 0) {
    super();
    if (normal instanceof Vec3$1) {
      this.normal = normal;
    } else {
      this.normal = new Vec3$1();
    }
    this.w = w;
  }

  /**
   * Setter from scalar components.
   *
   * @param {number} x - The x value.
   * @param {number} y - The y value.
   * @param {number} z - The z value.
   * @param {number} w - The w value.
   */
  set(x, y, z, w) {
    this.normal.set(x, y, z);
    this.w = w;
  }

  /**
   * Thet divideScalar method
   *
   * @param {number} value - The value value.
   */
  divideScalar(value) {
    this.normal.scaleInPlace(1 / value);
    this.w /= value;
  }

  /**
   * Calculates the distance from a point to this place.
   *
   * @param {Vec3} point - The point value.
   * @return {number} - The rreturn value.
   */
  distanceToPoint(point) {
    return point.dot(this.normal) + this.w
  }

  /**
   * Normalize this plane in place modifying its values.
   */
  normalizeInPlace() {
    const inverseNormalLength = 1.0 / this.normal.length();
    this.normal.scaleInPlace(inverseNormalLength);
    this.w *= inverseNormalLength;
  }

  /**
   * Clones this plane and returns a new plane.
   *
   * @return {Plane} - Returns a new plane.
   */
  clone() {
    return new Plane(this.normal.clone(), this.w)
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * Creates a new plane.
   * @param {...object} ...args - The ...args param.
   * @return {Plane} - Returns a new plane.
   * @private
   */
  static create(...args) {
    return new Plane(...args)
  }

  // ///////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      normal: this.normal.toJSON(),
      w: this.w,
    }
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('PlaneType', PlaneType);

/* eslint-disable new-cap */

/**
 * Class representing a Frustum. Frustums are used to determine what
 * is inside the camera's field of view.
 * @private
 * */
class Frustum {
  /**
   * Create a Frustum
   * @param {PlaneType} p0 - the p0 value.
   * @param {PlaneType} p1 - the p1 value.
   * @param {PlaneType} p2 - the p2 value.
   * @param {PlaneType} p3 - the p3 value.
   * @param {PlaneType} p4 - the p4 value.
   * @param {PlaneType} p5 - the p5 value.
   */
  constructor(p0, p1, p2, p3, p4, p5) {
    this.planes = [
      p0 || new PlaneType(),
      p1 || new PlaneType(),
      p2 || new PlaneType(),
      p3 || new PlaneType(),
      p4 || new PlaneType(),
      p5 || new PlaneType(),
    ];
  }

  /**
   * The setFromMatrix configures a Frustum object using a matrix.
   * Typically the matrix is a model view projection matrix.
   * @param {Mat4} mat4 - The matrix to use.
   */
  setFromMatrix(mat4) {
    const m = mat4;
    const planes = this.planes;
    planes[0].set(m.m03 - m.m00, m.m13 - m.m10, m.m23 - m.m20, m.m33 - m.m30);
    planes[1].set(m.m03 + m.m00, m.m13 + m.m10, m.m23 + m.m20, m.m33 + m.m30);
    planes[2].set(m.m03 + m.m01, m.m13 + m.m11, m.m23 + m.m21, m.m33 + m.m31);
    planes[3].set(m.m03 - m.m01, m.m13 - m.m11, m.m23 - m.m21, m.m33 - m.m31);
    planes[4].set(m.m03 - m.m02, m.m13 - m.m12, m.m23 - m.m22, m.m33 - m.m32);
    planes[5].set(m.m03 + m.m02, m.m13 + m.m12, m.m23 + m.m22, m.m33 + m.m32);

    planes.forEach((plane) => plane.normalizeInPlace());
  }

  /**
   * Tests a box to see if it is entirely within the frustum.
   * @param {Box3} box3 - The box to test.
   * @return {boolean} - True if the frustum intersects the box.
   */
  intersectsBox(box3) {
    const p = new Vec3$1();
    const planes = this.planes;
    const { min, max } = box3;

    for (let i = 0; i < 6; i++) {
      const plane = planes[i];

      // corner at max distance
      p.x = plane.normal.x > 0 ? max.x : min.x;
      p.y = plane.normal.y > 0 ? max.y : min.y;
      p.z = plane.normal.z > 0 ? max.z : min.z;

      if (plane.distanceToPoint(p) < 0) return false
    }
    return true
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   *
   * @return {object} - The json object.
   */
  toJSON() {
    return {
      p0: this.p0.toJSON(),
      p1: this.p1.toJSON(),
      p2: this.p2.toJSON(),
      p3: this.p3.toJSON(),
      p4: this.p4.toJSON(),
      p5: this.p5.toJSON(),
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object.
   */
  fromJSON(j) {
    this.p0.fromJSON(j.p0);
    this.p1.fromJSON(j.p1);
    this.p2.fromJSON(j.p2);
    this.p3.fromJSON(j.p3);
    this.p4.fromJSON(j.p4);
    this.p5.fromJSON(j.p5);
  }

  /**
   * Calls `toJSON` method and stringifies it.
   *
   * @return {string} - The return value.
   */
  toString() {
    return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON())
  }
}

Registry.register('Frustum', Frustum);

var Math$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AttrValue: AttrValue,
  Vec2: Vec2,
  Vec3: Vec3$1,
  Vec4: Vec4$1,
  RGBA: RGBA,
  Color: Color,
  EulerAngles: EulerAngles,
  Quat: Quat,
  Ray: Ray,
  Mat3: Mat3$1,
  Mat4: Mat4,
  Xfo: Xfo,
  Box2: Box2,
  Box3: Box3$1,
  Frustum: Frustum,
  PlaneType: PlaneType,
  SphereType: SphereType
});

/**
 * Provides an interface for emitting events under given names, and registering listeners to those events.
 * This is a base class for most classes in the Scene Tree and Renderer, enabling observers to listen to changes throughout the system.
 * The interface exposed is similar to [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter) in Node.
 *
 * Similar to how the DOM event system in the browser works, events are registered by name.
 * Example: Registering a listener for a custom event, and then emitting that event.
 * ```javascript
 *  const ee = new EventEmitter()
 *
 *  ee.on('myEvent', (event) => {
 *    console.log('My Event was emitted:', event)
 *  })
 *
 *  ee.emit('myEvent', { data: 42 })
 * ```
 *
 *
 */
class EventEmitter {
  /**
   * Initializes an empty `listeners` map that will host all the events,
   * which implies that it doesn't allow multiple events with the same name.
   * <br>
   */
  constructor() {
    this.listeners = {};
  }

  /**
   * Adds a listener function for a given event name.
   *
   * @param {string} eventName - The name of the event.
   * @param {function} listener - The listener function(callback).
   * @return {number} - Id to reference the listener.
   */
  on(eventName, listener) {
    if (!listener) {
      throw new Error('Missing callback function (listener).')
    }

    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }

    const listeners = this.listeners[eventName];

    if (listeners.indexOf(listener) != -1) {
      throw new Error(`Listener "${listener.name}" already connected to event "${eventName}".`)
    }

    // TODO: Deprecate alongside #addListener.
    const id = listeners.length;
    listeners[id] = listener;

    return id
  }

  /**
   * Similar to the `on` method with the difference that when the event is triggered,
   * it is automatically unregistered meaning that the event listener will be triggered at most one time.
   *
   * Useful for events that we expect to trigger one time, such as when assets load.
   * ```javascript
   * const asset = new Asset();
   * asset.once('loaded', () => {
   *   console.log("Yay! the asset is loaded")
   * })
   * ```
   *
   */
  once(eventName, listener) {
    const cb = (event) => {
      listener(event);
      this.off(eventName, cb);
    };

    this.on(eventName, cb);
  }

  /**
   * Removes a listener function from the specified event, using either the function or the index id. Depends on what is passed in.
   *
   * @param {string} eventName - The name of the event.
   * @param {function|number} listener - The listener function or the id number.
   */
  off(eventName, listener) {
    if (!listener) {
      throw new Error('Missing callback function (listener).')
    }

    if (typeof listener == 'number') {
      console.warn('Deprecated. Un-register using the original listener instead.');
      this.removeListenerById(eventName, listener);
      return
    }

    const listeners = this.listeners[eventName] || [];

    const ids = [];

    listeners.forEach((e, i) => {
      if (e === listener) {
        ids.push(i);
      }
    });

    if (ids.length == 0) {
      throw new Error(`Listener "${listener.name}" is not connected to "${eventName}" event`)
    } else {
      for (const id of ids) {
        listeners[id] = undefined;
      }
    }
  }

  /**
   * @deprecated Use #on instead.
   *
   * @param {string} eventName - The name of the event.
   * @param {function} listener - The listener function(callback).
   * @return {number} - Id to reference the listener.
   */
  addListener(eventName, listener) {
    console.warn('Deprecated. Use #on instead.');

    return this.on(eventName, listener)
  }

  /**
   * @deprecated Use #off instead.
   *
   * @param {string} eventName - The name of the event.
   * @param {function} listener - The listener function.
   */
  removeListener(eventName, listener) {
    console.warn('Deprecated. Use #off instead.');

    this.off(eventName, listener);
  }

  /**
   * @deprecated Use #off, passing the listener itself instead of the id.
   *
   * @param {string} eventName - The name of the event.
   * @param {number} id - The id returned by addListener
   */
  removeListenerById(eventName, id) {
    console.warn('Deprecated. Use #off, passing the listener itself instead of the id.');

    const listeners = this.listeners[eventName];

    if (!listeners) {
      console.warn('callback :' + id + ' was not connected to this signal:' + eventName);
      return
    }

    if (!listeners[id]) throw new Error('Invalid ID')

    listeners[id] = undefined;
  }

  /**
   * Triggers all listener functions in an event.
   *
   * @param {string} eventName - The name of the event.
   * @param {object|string|any} event - The data you want to pass down to all listener functions as parameter.
   */
  emit(eventName, event) {
    const listeners = this.listeners[eventName] || [];

    listeners.forEach((fn) => {
      // Skip disconnected listeners.
      if (fn) {
        fn(event);
      }
    });
  }
}

// Taken from here: https://github.com/jakesgordon/bin-packing/blob/master/js/packer.growing.js

/******************************************************************************

This is a binary tree based bin packing algorithm that is more complex than
the simple Packer (packer.js). Instead of starting off with a fixed width and
height, it starts with the width and height of the first block passed and then
grows as necessary to accomodate each subsequent block. As it grows it attempts
to maintain a roughly square ratio by making 'smart' choices about whether to
grow right or down.

When growing, the algorithm can only grow to the right OR down. Therefore, if
the new block is BOTH wider and taller than the current target then it will be
rejected. This makes it very important to initialize with a sensible starting
width and height. If you are providing sorted input (largest first) then this
will not be an issue.

A potential way to solve this limitation would be to allow growth in BOTH
directions at once, but this requires maintaining a more complex tree
with 3 children (down, right and center) and that complexity can be avoided
by simply chosing a sensible starting block.

Best results occur when the input blocks are sorted by height, or even better
when sorted by max(width,height).

Inputs:
------

  blocks: array of any objects that have .w and .h attributes

Outputs:
-------

  marks each block that fits with a .fit attribute pointing to a
  node with .x and .y coordinates

Example:
-------

  var blocks = [
    { w: 100, h: 100 },
    { w: 100, h: 100 },
    { w:  80, h:  80 },
    { w:  80, h:  80 },
    etc
    etc
  ];

  var packer = new GrowingPacker();
  packer.fit(blocks);

  for(var n = 0 ; n < blocks.length ; n++) {
    var block = blocks[n];
    if (block.fit) {
      Draw(block.fit.x, block.fit.y, block.w, block.h);
    }
  }


******************************************************************************/

class GrowingPacker extends EventEmitter {
  constructor(w = 0, h = 0) {
    super();
    this.root = {
      x: 0,
      y: 0,
      w: w,
      h: h,
    };
  }

  fit(blocks) {
    const len = blocks.length;
    if (len == 0) return
    let resized = false;
    if (this.root.w < blocks[0].w) {
      this.root.w = blocks[0].w;
      resized = true;
    }
    if (this.root.h < blocks[0].h) {
      this.root.h = blocks[0].h;
      resized = true;
    }
    if (resized) {
      this.emit('resized', { width: this.root.w, height: this.root.h });
    }
    const eachBlock = (block) => {
      block.fit = this.__addBlock(block);
    };
    blocks.forEach(eachBlock);
  }

  __addBlock(block) {
    const node = this.findNode(this.root, block.w, block.h);
    if (node) return this.splitNode(node, block.w, block.h)
    else return this.growNode(block.w, block.h)
  }

  addBlock(block) {
    let resized = false;
    if (this.root.w < block.w) {
      this.root.w = block.w;
      resized = true;
    }
    if (this.root.h < block.h) {
      this.root.h = block.h;
      resized = true;
    }
    if (resized) {
      this.emit('resized', { width: this.root.w, height: this.root.h });
    }
    const node = this.findNode(this.root, block.w, block.h);
    if (node) return this.splitNode(node, block.w, block.h)
    else return this.growNode(block.w, block.h)
  }

  findNode(root, w, h) {
    if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h)
    else if (w <= root.w && h <= root.h) return root
    else return null
  }

  splitNode(node, w, h) {
    node.used = true;
    node.down = {
      x: node.x,
      y: node.y + h,
      w: node.w,
      h: node.h - h,
    };
    node.right = {
      x: node.x + w,
      y: node.y,
      w: node.w - w,
      h: h,
    };
    return node
  }

  growNode(w, h) {
    const canGrowDown = w <= this.root.w;
    const canGrowRight = h <= this.root.h;

    const shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width
    const shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height

    if (shouldGrowRight) return this.growRight(w, h)
    else if (shouldGrowDown) return this.growDown(w, h)
    else if (canGrowRight) return this.growRight(w, h)
    else if (canGrowDown) return this.growDown(w, h)
    else return null // need to ensure sensible root starting size to avoid this happening
  }

  growRight(w, h) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      w: this.root.w + w,
      h: this.root.h,
      down: this.root,
      right: {
        x: this.root.w,
        y: 0,
        w: w,
        h: this.root.h,
      },
    };
    const node = this.findNode(this.root, w, h);
    let res;
    if (node) res = this.splitNode(node, w, h);
    this.emit('resized', { width: this.root.w, height: this.root.h });
    return res
  }

  growDown(w, h) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      w: this.root.w,
      h: this.root.h + h,
      down: {
        x: 0,
        y: this.root.h,
        w: this.root.w,
        h: h,
      },
      right: this.root,
    };
    const node = this.findNode(this.root, w, h);
    let res;
    if (node) res = this.splitNode(node, w, h);
    this.emit('resized', { width: this.root.w, height: this.root.h });
    return res
  }
}

/* eslint-disable require-jsdoc */

// Note: this class will be deprecated soon.
// Please avoid using it in your code.
class Async extends EventEmitter {
  constructor(asyncCount = 0) {
    super();
    this.__asyncCount = asyncCount;
    this.ready = false;

    this.incAsyncCount = (count = 1) => {
      this.__asyncCount += count;
      this.ready = false;
    };

    this.decAsyncCount = () => {
      if (this.__asyncCount > 0) {
        this.__asyncCount--;
        if (this.__asyncCount == 0) {
          this.__asyncsCompleted();
        }
      }
    };

    this.__asyncsCompleted = () => {
      this.emit('ready', {});
    };
  }

  get count() {
    return this.__asyncCount
  }
}

const decodeText = (chars) => {
  if (window.TextDecoder) return new TextDecoder('utf-8').decode(chars)
  else {
    let result = '';
    for (let i = 0; i < chars.length; i++) result += String.fromCharCode(chars[i]);
    return result
  }
};

var Utilities = /*#__PURE__*/Object.freeze({
  __proto__: null,
  GrowingPacker: GrowingPacker,
  Async: Async,
  EventEmitter: EventEmitter,
  decodeText: decodeText,
  StringFunctions: StringFunctions,
  UInt8: UInt8,
  SInt8: SInt8,
  SInt16: SInt16,
  UInt16: UInt16,
  SInt32: SInt32,
  UInt32: UInt32,
  Float32: Float32,
  MathFunctions: MathFunctions
});

let counter = 0;

/** Class representing a ref counted object. RefCounted
 *  objects track ownership and allow explicit cleanup
 *  of resources. This is necessary when JavaScript
 *  objects own references to GPU resources that need to
 *  be cleaned up when the JavaScript object is destroyed.
 * @private
 */
class RefCounted extends EventEmitter {
  /**
   * Create a ref counted object.
   */
  constructor() {
    super();
    if (this.constructor.name == 'RefCounted') {
      throw new Error('RefCounted should not be instantiated directly.')
    }
    this.__id = ++counter;
    this.__refs = [];
    this.__destroyed = false;
  }

  /**
   * Returns the unique id of the object. Every Object has a unique
   * identifier which is based on a counter that is incremented.
   * @return {any} - The return value.
   */
  getId() {
    return this.__id
  }

  /**
   * The numRefs method.
   * @return {number} - The return value.
   */
  numRefs() {
    return this.__refs.length
  }

  /**
   * The addRef method.
   * @param {any} referer - The referer value.
   * @return {boolean} - The return value.
   */
  addRef(referer) {
    if (!referer) throw new Error('Error in RefCounted.addRef: Must provide a referer')

    // Note: an object can be reffeed multiple times.
    // e.g. we can create a temporary ref while we re-attach a tree item to a new parent.
    this.__refs.push(referer);
    return true
  }

  /**
   * The removeRef method.
   * @param {any} referer - The referer value.
   */
  removeRef(referer) {
    if (!referer) throw new Error('Error in RefCounted.removeRef: Must provide a referer')
    const index = this.__refs.indexOf(referer);
    if (index == -1) throw new Error('Error in RefCounted.removeRef: referer not found in refs list.')

    this.__refs.splice(index, 1);
    if (this.__refs.length == 0) {
      this.destroy();
    }
  }

  /**
   * The getRefer method.
   * @param {number} index - The index value.
   * @return {any} - The return value.
   */
  getRefer(index) {
    return this.__refs[index]
  }

  /**
   * The getRefIndex method.
   * @param {any} referer - The referer value.
   * @return {any} - The return value.
   */
  getRefIndex(referer) {
    return this.__refs.indexOf(referer)
  }

  /**
   * Returns true if this object has already been destroyed.
   * @return {boolean} - Returns true or false.
   */
  isDestroyed() {
    return this.__destroyed
  }

  /**
   * The destroy method is invoked when the last owner
   * is removed from a RefCounted object. Derived objects can
   * override this method to perform explicit cleanup.
   * The destructing signal is triggered so observers can
   * respond to this objects destruction.
   */
  destroy() {
    this.__destroyed = true;
    // console.log(this.constructor.name + " destructing");
    this.emit('destructing', {});
  }
}

/* eslint-disable guard-for-in */

// Explicit import of files to avoid importing all the parameter types.
// Note: Soon these imports should be removed, once all code avoids calling
// 'addParameter' without the parameter instance.

let counter$1 = 0;

/**
 * Class that allows other classes to be parameterized by `Parameter` type of objects.
 * Not only hosting parameters, but their events.
 *
 * @extends {EventEmitter}
 */
class ParameterOwner extends EventEmitter {
  /**
   * Creates an instance of ParameterOwner by initializing parameter hosting mappings and events.
   * <br>
   * Every Object has a unique identifier which is based on a counter that is incremented.
   */
  constructor() {
    super();
    this.__id = ++counter$1;

    this.__params = [];
    this.__paramMapping = {};
    this.__paramEventHandlers = {};
  }

  /**
   * Returns the unique id of the object.
   * @private
   * @return {number} - The Id of the ParameterOwner object.
   */
  getId() {
    return this.__id
  }

  // --- Params ---

  /**
   * @deprecated
   * Returns the number of parameters current object has.
   *
   * @return {number} - Amount of parameters in current object.
   */
  numParameters() {
    console.warn('Deprecated. Use #getNumParameters instead.');
    return this.getNumParameters()
  }

  /**
   * Returns the number of parameters current object has.
   *
   * @return {number} - Amount of parameters in current object.
   */
  getNumParameters() {
    return this.__params.length
  }

  /**
   * Returns all the parameters of the object.
   *
   * @return {array} - Parameter List
   */
  getParameters() {
    return this.__params
  }

  /**
   * Returns the index of a parameter in parameter list.
   *
   * @param {string} paramName - Name of the parameter.
   * @return {number} - Position in the array
   */
  getParameterIndex(paramName) {
    return this.__paramMapping[paramName]
  }

  /**
   * Returns `Parameter` object in a given index
   *
   * @param {number} index - Position of the parameter in the array
   * @return {Parameter} - Parameter object value
   */
  getParameterByIndex(index) {
    return this.__params[index]
  }

  /**
   * Validates if the specified parameter exists in the object.
   *
   * @param {string} paramName - The parameter name.
   * @return {boolean} - The return value.
   */
  hasParameter(paramName) {
    return paramName in this.__paramMapping
  }

  /**
   * Returns `Parameter` object using the given name
   *
   * @param {string} paramName - The parameter name.
   * @return {Parameter} - Parameter object value
   */
  getParameter(paramName) {
    const index = this.__paramMapping[paramName];
    if (index == -1) return null
    return this.__params[index]
  }

  /**
   * This method can be overridden in derived classes
   * to perform general updates (see GLPass or BaseItem).
   * @param {object} event - The event object emitted by the parameter.
   * @private
   */
  __parameterValueChanged(event) {
    this.emit('parameterValueChanged', event);
  }

  /**
   * Adds `Parameter` object to the owner's parameter list.
   *
   * @emits `parameterAdded` with the name of the param.
   * @param {Parameter} param - The parameter to add.
   * @return {Parameter} - With `owner` and `valueChanged` event set.
   */
  addParameter(param) {
    return this.insertParameter(param, this.__params.length)
  }

  /**
   * Adds `Parameter` object to the owner's parameter list using the index.
   * It replaces the event in the specified index.
   *
   *
   * @emits `parameterAdded` with the name of the param.
   * @param {Parameter} param - The parameter to insert.
   * @param {number} index - The index value.
   * @return {Parameter} - With `owner` and `valueChanged` event set.
   */
  insertParameter(param, index) {
    const name = param.getName();
    if (this.__paramMapping[name] != undefined) {
      console.warn('Replacing Parameter:' + name);
      this.removeParameter(name);
    }
    param.setOwner(this);
    const paramChangedHandler = (event) => this.__parameterValueChanged({ ...event, param });
    param.on('valueChanged', paramChangedHandler);
    this.__paramEventHandlers[name] = paramChangedHandler;
    this.__params.splice(index, 0, param);

    for (let i = index; i < this.__params.length; i++) {
      this.__paramMapping[this.__params[i].getName()] = i;
    }
    this.emit('parameterAdded', { name });
    return param
  }

  /**
   * Removes `Parameter` from owner, by using parameter's name.
   * @emits `parameterRemoved` with the name of the param.
   * @param {string} name - The parameter name.
   */
  removeParameter(name) {
    if (this.__paramMapping[name] == undefined) {
      throw new Error('Unable to remove Parameter:' + name)
    }
    const index = this.__paramMapping[name];
    const param = this.__params[this.__paramMapping[name]];

    param.off('valueChanged', this.__paramEventHandlers[name]);
    this.__params.splice(index, 1);

    delete this.__paramMapping[name];
    for (let i = index; i < this.__params.length; i++) {
      this.__paramMapping[this.__params[i].getName()] = i;
    }

    this.emit('parameterRemoved', { name });
  }

  /**
   * Replaces old `Parameter` by passing a new one with the same name.
   *
   * @param {Parameter} param - The parameter to replace.
   * @return {Parameter} - `Parameter` with `valueChanged` event set.
   */
  replaceParameter(param) {
    const name = param.getName();
    if (this.__paramMapping[name] == undefined) {
      throw new Error('Unable to replace Parameter:' + paramName)
    }
    const index = this.__paramMapping[name];
    this.removeParameter(name);
    this.insertParameter(param, index);
    return param
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const json = {};
    const paramsJSON = {};
    let savedParams = 0;
    for (const param of this.__params) {
      const paramJSON = param.toJSON(context);
      if (paramJSON) {
        paramsJSON[param.getName()] = paramJSON;
        savedParams++;
      }
    }
    if (savedParams > 0) json.params = paramsJSON;
    return json
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.params) {
      for (const key in j.params) {
        const pj = j.params[key];
        const param = this.getParameter(key);
        if (!param) console.warn('Param not found:' + key);
        else {
          if (pj.paramPath) {
            context.resolvePath(
              pj.paramPath,
              (param) => {
                this.replaceParameter(param);
              },
              (reason) => {
                console.warn('Unable to resolve shared parameter:' + pj.paramPath);
              }
            );
          } else {
            param.fromJSON(pj, context);
          }
        }
      }
    }
  }

  /**
   * Uses passed in BinReader object(containing an Int32 array with all the parameters) to reconstruct all parameters state.
   * <br>
   * In each iteration of the array, propType and propName are extracted and
   * used to build the right `Parameter` class. Then all of them are added to the object.
   *
   * @emits `parameterAdded` with the name of the param.
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    // TODO: make this work

    if (context.versions['zea-engine'].compare([0, 0, 3]) >= 0) {
      const numProps = reader.loadUInt32();
      for (let i = 0; i < numProps; i++) {
        const propType = reader.loadStr();
        const propName = reader.loadStr();
        let param = this.getParameter(propName);
        if (!param) {
          param = Registry.constructClass(propType, propName);
          if (!param) {
            console.error('Unable to construct prop:' + propName + ' of type:' + propType);
            continue
          }
          this.addParameter(param);
        }
        param.readBinary(reader, context);
      }
    }
  }

  /**
   * Converts object's JSON value and converts it to a string.
   *
   * @return {string} - String of object's parameter list state.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * Copies Parameters from another `ParameterOwner` to current object.
   *
   * @param {ParameterOwner} src - The ParameterOwner copy from.
   */
  copyFrom(src) {
    // Note: Loop over the parameters in reverse order,
    // this is because often, parameter dependencies
    // are bottom to top (bottom params dependent on higher params).
    // This means that as a parameter is set with a new value
    // it will dirty the params below it.
    let i = src.getNumParameters();
    while (i--) {
      const srcParam = src.getParameterByIndex(i);
      const param = this.getParameter(srcParam.getName());
      if (param) {
        // Note: we are not cloning the values.
        param.loadValue(srcParam.getValue());
      } else {
        this.addParameter(srcParam.clone());
      }
    }
  }
}

/* eslint-disable no-unused-vars */

/**
 * Reads binary data in a specific encoding. Used in loading binary data such as zcad files.
 */
class BinReader {
  /**
   * Create a bin reader.
   *
   * @param {Buffer} data - The data buffer.
   * @param {number} byteOffset - The byte offset value to start reading the buffer.
   * @param {boolean} isMobileDevice - The isMobileDevice value.
   */
  constructor(data, byteOffset = 0, isMobileDevice = true) {
    this.__data = data;
    this.__byteOffset = byteOffset;
    this.__dataView = new DataView(this.__data);
    this.__isMobileDevice = isMobileDevice;
    this.utf8decoder = new TextDecoder();
  }

  /**
   * Returns state of whether or not the `BinReader` object was instanciated from a mobile device.
   *
   * @return {Boolean} - Returns true is a mobile device is detected.
   */
  get isMobileDevice() {
    return this.__isMobileDevice
  }

  /**
   * Returns the data buffer we're reading from.
   *
   * @return {Buffer} - The data buffer we are reading from,
   */
  get data() {
    return this.__data
  }

  /**
   * Returns the length of the buffer.
   *
   * @return {number} - The total length of the buffer
   */
  get byteLength() {
    return this.__dataView.byteLength
  }

  /**
   * Returns remaining length of the buffer to read.
   *
   * @return {number} - The reemaining length of the buffer to read.
   */
  get remainingByteLength() {
    return this.__dataView.byteLength - this.__byteOffset
  }

  /**
   * Returns current byte offset in the buffer.
   * @return {number} - The current offset in the binary buffer
   */
  pos() {
    return this.__byteOffset
  }

  /**
   * Sets the byte offset value.
   * @param {number} byteOffset - The byteOffset param.
   */
  seek(byteOffset) {
    this.__byteOffset = byteOffset;
  }

  /**
   * Adds offset bytes to current offset value.
   *
   * @param {number} byteOffset - The byte Offset amount.
   */
  advance(byteOffset) {
    this.__byteOffset += byteOffset;
  }

  /**
   * Returns the unsigned Uint8 value at current byte offset position,
   * and adds one byte to the offset.
   *
   * @return {number} - The return value.
   */
  loadUInt8() {
    const result = this.__dataView.getUint8(this.__byteOffset);
    this.__byteOffset += 1;
    return result
  }

  /**
   * Returns the unsigned Uint16 value at current byte offset position,
   * and adds two bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadUInt16() {
    const result = this.__dataView.getUint16(this.__byteOffset, true);
    this.__byteOffset += 2;
    return result
  }

  /**
   * Returns the unsigned Uint32 value at current byte offset position,
   * and adds four bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadUInt32() {
    const result = this.__dataView.getUint32(this.__byteOffset, true);
    this.__byteOffset += 4;
    return result
  }

  /**
   * Returns the signed Int32 value at current byte offset position,
   * and adds four bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadSInt32() {
    const result = this.__dataView.getInt32(this.__byteOffset, true);
    this.__byteOffset += 4;
    return result
  }

  /**
   * Returns the Float16 value at current byte offset position,
   * and adds four bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadFloat16() {
    const uint16 = this.loadUInt16();
    return MathFunctions.decode16BitFloat(uint16)
  }

  /**
   * Returns the Float16 value at current byte offset position,
   * and adds two bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadUFloat16() {
    const result = this.loadFloat16();
    if (result < 0.0) {
      return 2048.0 - result // Note: subtract a negative number to add it.
    } else {
      return result
    }
  }

  /**
   * Returns a single signed Float16 value at current byte offset position from 2 unsigned Int8 values,
   * and adds two bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadFloat16From2xUInt8() {
    const result = this.__dataView.getFloat16(this.__byteOffset, true);
    // const uint8s = this.loadUInt8Array(2);
    // return Math.decode16BitFloat(uint8s);
    this.__byteOffset += 2;
    return result
  }

  /**
   * Loads and returns a single Signed integer value from 2 Unsigned Float16 values.
   * @return {number} - The return value.
   */
  loadUInt32From2xUFloat16() {
    const partA = this.loadUFloat16();
    const partB = this.loadUFloat16();
    return partA + partB * 4096
  }

  /**
   * Loads and returns a single Signed integer value from 2 signed Float16 values.
   * @return {number} - The return value.
   */
  loadSInt32From2xFloat16() {
    const partA = this.loadFloat16();
    const partB = this.loadFloat16();
    return partA + partB * 2048
  }

  /**
   * Returns the Float32 value at current byte offset position,
   * and adds four bytes to the offset.
   *
   * @return {number} - The return value.
   */
  loadFloat32() {
    const result = this.__dataView.getFloat32(this.__byteOffset, true);
    this.__byteOffset += 4;
    return result
  }

  /**
   * Reads buffer and return an unsinged Int8 array with the specified size,
   * starting from current byte offset.<br>
   * Byte offset is increased by the specified byte size.
   *
   * @param {number} size - The size param.
   * @param {boolean} clone - The clone param.
   * @return {Uint8Array} - The return value.
   */
  loadUInt8Array(size = undefined, clone = false) {
    if (size == undefined) size = this.loadUInt32();
    const result = new Uint8Array(this.__data, this.__byteOffset, size);
    this.__byteOffset += size;
    const padd = this.__byteOffset % 4;
    // this.readPadd();
    return result
  }

  /**
   * Reads buffer and return an unsinged Int16 array with the specified size,
   * starting from current byte offset.<br>
   * Byte offset is increased by the specified byte size x 2.
   *
   * @param {number} size - The size param.
   * @param {boolean} clone - The clone param.
   * @return {Uint16Array} - The return value.
   */
  loadUInt16Array(size = undefined, clone = false) {
    if (size == undefined) size = this.loadUInt32();
    if (size == 0) return new Uint16Array()
    this.readPadd(2);
    let result;
    if (this.__isMobileDevice) {
      result = new Uint16Array(size);
      for (let i = 0; i < size; i++) {
        result[i] = this.__dataView.getUint16(this.__byteOffset, true);
        this.__byteOffset += 2;
      }
    } else {
      result = new Uint16Array(this.__data, this.__byteOffset, size);
      this.__byteOffset += size * 2;
    }
    // this.readPadd();
    return result
  }

  /**
   * Reads buffer and return an unsinged Int32 array with the specified size,
   * starting from current byte offset.<br>
   * Byte offset is increased by the specified byte size x 4.
   *
   * @param {number} size - The size param.
   * @param {boolean} clone - The clone param.
   * @return {Uint32Array} - The return value.
   */
  loadUInt32Array(size = undefined, clone = false) {
    if (size == undefined) size = this.loadUInt32();
    if (size == 0) return new Uint32Array()
    this.readPadd(4);
    let result;
    if (this.__isMobileDevice) {
      result = new Uint32Array(size);
      for (let i = 0; i < size; i++) {
        result[i] = this.__dataView.getUint32(this.__byteOffset, true);
        this.__byteOffset += 4;
      }
    } else {
      result = new Uint32Array(this.__data, this.__byteOffset, size);
      this.__byteOffset += size * 4;
    }
    return result
  }

  /**
   * Reads buffer and return a Float32 array with the specified size,
   * starting from current byte offset.<br>
   * Byte offset is increased by the specified byte size x 4.
   *
   * @param {number} size - The size param.
   * @param {boolean} clone - The clone param.
   * @return {Float32Array} - The return value.
   */
  loadFloat32Array(size = undefined, clone = false) {
    if (size == undefined) size = this.loadUInt32();
    if (size == 0) return new Float32Array()
    this.readPadd(4);
    let result;
    if (this.__isMobileDevice) {
      result = new Float32Array(size);
      for (let i = 0; i < size; i++) {
        result[i] = this.__dataView.getFloat32(this.__byteOffset, true);
        this.__byteOffset += 4;
      }
    } else {
      result = new Float32Array(this.__data, this.__byteOffset, size);
      this.__byteOffset += size * 4;
    }
    return result
  }

  /**
   * Returns next string.
   * First looks for the string length description in the next four bytes in the buffer(Starting from byte offset).
   *
   * @return {string} - The return value.
   */
  loadStr() {
    const numChars = this.loadUInt32();
    const chars = new Uint8Array(this.__data, this.__byteOffset, numChars);
    this.__byteOffset += numChars;
    return this.utf8decoder.decode(chars)
  }

  /**
   * Returns an array of strings.
   * First reading the size of the array then reading each string.
   *
   * @return {Array} - The return value.
   */
  loadStrArray() {
    const size = this.loadUInt32();
    const result = [];
    for (let i = 0; i < size; i++) {
      result[i] = this.loadStr();
    }
    return result
  }

  /**
   * Creates and returns a `Vec2` object with the next two signed Int32 values in the buffer.
   *
   * @return {Vec2} - Returns a Vec2.
   */
  loadSInt32Vec2() {
    const x = this.loadSInt32();
    const y = this.loadSInt32();
    return new Vec2(x, y)
  }

  /**
   * Creates and returns a `Vec2` object with the next two unsigned Int32 values in the buffer.
   * @return {Vec2} - Returns a Vec2.
   */
  loadUInt32Vec2() {
    const x = this.loadUInt32();
    const y = this.loadUInt32();
    return new Vec2(x, y)
  }

  /**
   * Creates and returns a `Vec2` object with the next two Float16 values in the buffer.
   *
   * @return {Vec2} - Returns a Vec2.
   */
  loadFloat16Vec2() {
    const x = this.loadFloat16();
    const y = this.loadFloat16();
    return new Vec2(x, y)
  }

  /**
   * Creates and returns a `Vec2` object with the next two Float32 values in the buffer.
   * @return {Vec2} - Returns a Vec2.
   */
  loadFloat32Vec2() {
    const x = this.loadFloat32();
    const y = this.loadFloat32();
    return new Vec2(x, y)
  }

  /**
   * Creates and returns a `Vec3` object with the next three Float16 values in the buffer.
   *
   * @return {Vec3} - Returns a Vec3.
   */
  loadFloat16Vec3() {
    const x = this.loadFloat16();
    const y = this.loadFloat16();
    const z = this.loadFloat16();
    return new Vec3$1(x, y, z)
  }

  /**
   * Creates and returns a `Vec3` object with the next three Float32 values in the buffer.
   *
   * @return {Vec3} - Returns a Vec3.
   */
  loadFloat32Vec3() {
    const x = this.loadFloat32();
    const y = this.loadFloat32();
    const z = this.loadFloat32();
    return new Vec3$1(x, y, z)
  }

  /**
   * Creates and returns a `Quat` object with the next four Float16 values in the buffer.
   *
   * @return {Quat} - Returns a Quat.
   */
  loadFloat16Quat() {
    const x = this.loadFloat16();
    const y = this.loadFloat16();
    const z = this.loadFloat16();
    const w = this.loadFloat16();
    return new Quat(x, y, z, w)
  }

  /**
   * Creates and returns a `Quat` object with the next four Float32 values in the buffer.
   * @return {Quat} - Returns a Quat.
   */
  loadFloat32Quat() {
    const x = this.loadFloat32();
    const y = this.loadFloat32();
    const z = this.loadFloat32();
    const w = this.loadFloat32();
    return new Quat(x, y, z, w)
  }

  /**
   * Creates and returns a `Color` object with the next three Float32 values in the buffer.
   *
   * @return {Color} - Returns a Color.
   */
  loadRGBFloat32Color() {
    const r = this.loadFloat32();
    const g = this.loadFloat32();
    const b = this.loadFloat32();
    return new Color(r, g, b)
  }

  /**
   * Creates and returns a RGBA `Color` object with the next four Float32 values in the buffer.
   * @return {Color} - Returns a Color.
   */
  loadRGBAFloat32Color() {
    const r = this.loadFloat32();
    const g = this.loadFloat32();
    const b = this.loadFloat32();
    const a = this.loadFloat32();
    return new Color(r, g, b, a)
  }

  /**
   * Creates and returns a `Color` object with the next three unsigned Int8 values in the buffer.
   * @return {Color} - Returns a Color.
   */
  loadRGBUInt8Color() {
    const r = this.loadUInt8();
    const g = this.loadUInt8();
    const b = this.loadUInt8();
    return new Color(r / 255, g / 255, b / 255)
  }

  /**
   * Creates and returns a RGBA `Color` object with the next four unsigned Int8 values in the buffer.
   * @return {Color} - Returns a Color.
   */
  loadRGBAUInt8Color() {
    const r = this.loadUInt8();
    const g = this.loadUInt8();
    const b = this.loadUInt8();
    const a = this.loadUInt8();
    return new Color(r / 255, g / 255, b / 255, a / 255)
  }

  /**
   * Creates and returns a `Box2` object with the next four Float32 values in the buffer.
   * Next four because it creates two Vec2.
   *
   * @return {Box2} - Returns a Box2.
   */
  loadBox2() {
    return new Box2(this.loadFloat32Vec2(), this.loadFloat32Vec2())
  }

  /**
   * Creates and returns a `Box2` object with the next six Float32 values in the buffer.
   * Next four because it creates two Vec3.
   *
   * @return {Box3} - Returns a Box3.
   */
  loadBox3() {
    return new Box3$1(this.loadFloat32Vec3(), this.loadFloat32Vec3())
  }

  /**
   * The readPadd method.
   * @param {number} stride - The stride param.
   */
  readPadd(stride) {
    const padd = this.__byteOffset % stride;
    if (padd != 0) this.__byteOffset += stride - padd;
  }
}

/* eslint-disable no-unused-vars */

let numBaseItems = 0;

/**
 * Base class for Items in the scene. It can be parameterized and can emit events.
 *
 * **Events**
 * * **nameChanged:** Emitted every time the Item's name is change. mostly in `setName` method.
 * * **selectedChanged:** Emitted `selected` status changes, mostly in `setSelected` method.
 *
 * @extends {ParameterOwner}
 */
class BaseItem extends ParameterOwner {
  /**
   * Create a base item by defining its name.
   *
   * @param {string} name - The name of the base item.
   */
  constructor(name) {
    super();
    this.__name = name ? name : '';
    this.__path = [this.__name];
    this.__ownerItem = undefined; // TODO: will create a circular ref. Figure out and use weak refs

    // Note: one day we will remove the concept of 'selection' from the engine
    // and keep it only in UX. to Select an item, we will add it to the selection
    // in the selection manager. Then the selection group will apply a highlight.
    this.__selectable = true;
    this.__selected = false;

    this.__metaData = {};

    numBaseItems++;
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * The getNumBaseItems method returns the total number of base items created.
   * This method is used in debugging memory consumption.
   *
   * @return {number} - Returns the total number of base items created.
   */
  static getNumBaseItems() {
    return numBaseItems
  }

  // ////////////////////////////////////////
  // Name and Path

  /**
   * Returns the name of the base item.
   *
   * @return {string} - Returns the base item name.
   */
  getName() {
    return this.__name
  }

  /**
   * Sets the name of the base item(Updates path).
   *
   * @emits `nameChanged` with `newName` and `oldName` data.
   * @param {string} name - The base item name.
   */
  setName(name) {
    if (this.__name != name) {
      const oldName = this.__name;
      this.__name = name;
      this.__updatePath();
      this.emit('nameChanged', { newName: name, oldName });
    }
  }

  /**
   * When the name or the hierarchy changes, this method
   * recomputes and caches the path of this item.
   * @private
   */
  __updatePath() {
    if (this.__ownerItem == undefined) this.__path = [this.__name];
    else {
      this.__path = [...this.__ownerItem.getPath(), this.__name];
    }
  }

  /**
   * Returns the current path of the item in the tree as an array of names.
   *
   * @return {array} - Returns an array.
   */
  getPath() {
    return this.__path
  }

  // Path Traversal

  /**
   * The resolvePath method traverses the subtree from this item down
   * matching each name in the path with a child until it reaches the
   * end of the path.
   *
   * @param {array} path - The path value.
   * @param {number} index - The index value.
   * @return {BaseItem|Parameter} - The return value.
   */
  resolvePath(path, index = 0) {
    if (index == 0) {
      if (path[0] == '.' || path[0] == this.__name) index++;
    }
    if (index == path.length) {
      return this
    }
    if (path[index] == '>' && index == path.length - 1) {
      return this.getParameter(path[index + 1])
    }

    // Maybe the name is a parameter name.
    const param = this.getParameter(path[index]);
    if (param) {
      return param
    }
    throw new Error('Invalid path:' + path + '[' + index + '] member not found')
  }

  // ////////////////////////////////////////
  // Owner Item

  /**
   * The getOwner method returns the current owner of the item.
   * The item is a child of the current owner.
   *
   * @return {object} - Returns the current owner.
   */
  getOwner() {
    // return this.__private.get('ownerItem');
    return this.__ownerItem
  }

  /**
   * The setOwner method assigns a new owner to the item.
   *
   * @param {object} ownerItem - The new owner item.
   */
  setOwner(ownerItem) {
    // this.__private.set(ownerItem, ownerItem);
    if (this.__ownerItem !== ownerItem) {
      this.__ownerItem = ownerItem;
      this.__updatePath();
    }
  }

  // ////////////////////////////////////////
  // Selectability and Selection

  /**
   * Returns a boolean indicating if this item is selectable.
   *
   * @return {boolean} - Returns a boolean indicating if the item is selectable.
   */
  getSelectable() {
    return this.__selectable
  }

  /**
   * Modifies the selectability of this item.
   *
   * @param {boolean} val - A boolean indicating the selectability of the item.
   * @return {boolean} - Returns true if value changed.
   */
  setSelectable(val) {
    if (this.__selectable != val) {
      this.__selectable = val;
      return true
    }
    return false
  }

  /**
   * The isSelected method.
   * @deprecated
   * @see `getSelected` method
   * @return {boolean} - The return value.
   */
  isSelected() {
    return this.__selected
  }

  /**
   * Returns `true` if this item has been selected.
   *
   * @return {boolean} - The current selection state.
   */
  getSelected() {
    return this.__selected
  }

  /**
   * Changes the current state of the selection of this item.
   *
   * @emits `selectedChanged` with selected state
   * @param {boolean} sel - Boolean indicating the new selection state.
   */
  setSelected(sel) {
    this.__selected = sel;
    this.emit('selectedChanged', { selected: this.__selected });
  }

  // ////////////////////////////////////////
  // Metadata

  /**
   * Gets Item's meta-data value by passing the `key` string.
   *
   * @param {string} key - The key value under which to check for metadata.
   * @return {object|string|any} - Returns the metadata associated with the given key.
   */
  getMetadata(key) {
    return this.__metaData[key]
  }

  /**
   * Checks to see if there is metadata for a given key.
   *
   * @param {string} key - The key value under which to check for metadata.
   * @return {boolean} - Returns `true` if metadata exists under the given key, otherwise returns `false`.
   */
  hasMetadata(key) {
    return key in this.__metaData
  }

  /**
   * Assigns metadata to a given key.
   *
   * @param {string} key - The key value under which the metadata is is going to be saved.
   * @param {object} metaData - The metaData value.
   */
  setMetadata(key, metaData) {
    this.__metaData[key] = metaData;
  }

  /**
   * Removes metadata for a given key.
   *
   * @param {string} key - The key value.
   */
  deleteMetadata(key) {
    delete this.__metaData[key];
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Encodes the current object as a json object.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    j.name = this.__name;
    j.type = Registry.getBlueprintName(this);
    return j
  }

  /**
   * Decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.name) this.__name = j.name;
    super.fromJSON(j, context);
  }

  /**
   * Sets state of current Item(Including parameters) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    const type = reader.loadStr();
    this.setName(reader.loadStr());

    // Note: parameters follow name...
    super.readBinary(reader, context);
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * Clones this base item and returns a new base item.
   * <br>
   * **Note:** Each class should implement clone to be clonable.
   */
  clone() {
    throw new Error(this.constructor.name + ' does not implement its clone method')
  }

  /**
   * When a BaseItem is cloned, initially the constructor is
   * called to generate a new instance. This instance then copies
   * its values from the source using this method.
   * This method copies any relevant data from the source object to
   * ensure that it represents a valid clone.
   * Derived classes override this method to copy any relevant
   * data from the source object.
   *
   * @param {BaseItem} src - The BaseItem to copy from.
   */
  copyFrom(src) {
    super.copyFrom(src);
    this.setName(src.getName());
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
  }
}

const getFileFolder = function (filePath) {
  return filePath.substring(0, filePath.lastIndexOf('/')) + '/'
};

const loadfile = function (url, responseType, onSucceed, onFail, onProgress) {
  try {
    const xhr = new XMLHttpRequest();
    xhr.responseType = responseType;
    xhr.addEventListener('timeout', function (event) {
      throw new Error('The request for ' + url + ' timed out.')
    });
    xhr.addEventListener('error', function (event) {
      throw new Error('The request for ' + url + ': xhr.readyState:' + xhr.readyState)
      onFail(xhr.statusText);
    });
    xhr.addEventListener('abort', function (event) {
      throw new Error('The request for ' + url + ': xhr.readyState:' + xhr.readyState)
      onFail(xhr.statusText);
    });
    xhr.addEventListener('loadend', function (event) {
      if (xhr.status == 200) onSucceed(xhr);
      else onFail(xhr.statusText);
    });
    xhr.open('GET', url, true);
    xhr.send();
    // xhr.open();
  } catch (err) {
    onFail(err);
  }
};

const loadTextfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
  loadfile(
    url,
    'text',
    (xhr) => {
      onSucceed(xhr.responseText);
    },
    (statusText) => {
      if (onFail != undefined) onFail(statusText);
      else {
        throw new Error('Unable to XHR File:' + url)
      }
    });
};

const loadJSONfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
  loadfile(
    url,
    'json',
    (xhr) => {
      onSucceed(xhr.response, xhr);
    },
    (statusText) => {
      if (onFail != undefined) onFail(statusText);
      else {
        throw new Error('Unable to XHR File:' + url)
      }
    });
};

const loadXMLfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
  loadfile(
    url,
    'document',
    (xhr) => {
      onSucceed(xhr.responseXML);
    },
    (statusText) => {
      if (onFail != undefined) onFail(statusText);
      else {
        throw new Error('Unable to XHR File:' + url)
      }
    });
};

const loadBinfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
  loadfile(
    url,
    'arraybuffer',
    (xhr) => {
      onSucceed(xhr.response);
    },
    (statusText) => {
      if (onFail != undefined) onFail(statusText);
      else {
        throw new Error('Unable to XHR File:' + url)
      }
    });
};

var WorkerClass = null;

try {
    var WorkerThreads =
        typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
        typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
        typeof require === 'function' && require('worker_threads');
    WorkerClass = WorkerThreads.Worker;
} catch(e) {} // eslint-disable-line

function decodeBase64(base64, enableUnicode) {
    return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    return function WorkerFactory(options) {
        return new WorkerClass(body, Object.assign({}, options, { eval: true }));
    };
}

function decodeBase64$1(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64$1(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    var blob = new Blob([body], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}

var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

function isNodeJS() {
    return kIsNodeJS;
}

function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
    if (isNodeJS()) {
        return createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg);
    }
    return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
}

var WorkerFactory = createBase64WorkerFactory$2('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwovKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jICovDQovKiogU3luY2hyb25vdXNseSBpbml0aWFsaXplIHRoZSBmb2xsb3dpbmcgc2NyaXB0cyBpbiBvcmRlci4gDQogKiBAcHJpdmF0ZQ0KKi8NCk1vZHVsZSA9IHsNCiAgRU5WSVJPTk1FTlQ6ICdXT1JLRVInDQp9Ow0KDQpjb25zdCBXb3JrZXJTY29wZSA9IHt9Ow0KDQovLy0tLS0tLS0tLS0tLS0tLS0tLS0tdW5wYWNrQnJpZGdlLmpzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KIWZ1bmN0aW9uKHQsZSl7DQogIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBoYXMgYmVlbiBfY2FyZWZ1bGx5XyBtb2RpZmllZCBieSBoYW5kLg0KICAvLyBUaGVyZSB3ZXJlIHZhcmlvdXMgY2FzZXMgZm9yIGluIHdoYXQgY29udGV4dCB0aGUgY29kZSBtaWdodCANCiAgLy8gYmUgcnVuLCBhbmQgSSByZW1vdmVkIGFsbCBidXQgdGhlIHdlYndvcmtlciBjYXNlLiANCiAgLy8gVGhlcmUgd2FzIGNvZGUgdG8gaGFuZGxlIGxvYWRpbmcgaW4gYSBub2RlSlMgY29udGV4dCwgdGhhdCB0cmllZCB0byBpbXBvcnQoImZzIikNCiAgLy8gV2ViUGFjayBrZXB0cyB0cmlwcGluZyB1cCBvbiB0aGF0IGNvZGUgaW4gaXRzIHN0YXRpYyBhbmFseXNpcyBvZiB0aGUgY29kZSwgc28NCiAgLy8gSSBjYXJlZnVsbHkgcmVtb3ZlZCBpdC4NCiAgdC51bnBhY2tCcmlkZ2UgPSBlKHQuZnMpOw0KfShXb3JrZXJTY29wZSxmdW5jdGlvbih0KXsNCiAgcmV0dXJuIGZ1bmN0aW9uKHQpew0KICAgIHZhciBlPXt9O2Z1bmN0aW9uIHIobil7aWYoZVtuXSlyZXR1cm4gZVtuXS5leHBvcnRzO3ZhciBpPWVbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHIpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHIubT10LHIuYz1lLHIuZD1mdW5jdGlvbih0LGUsbil7ci5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Om59KTt9LHIucj1mdW5jdGlvbih0KXsidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOiJNb2R1bGUifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO30sci50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1yKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiYib2JqZWN0Ij09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobiwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmInN0cmluZyIhPXR5cGVvZiB0KWZvcih2YXIgaSBpbiB0KXIuZChuLGksZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gci5kKGUsImEiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPSIiLHIoci5zPTIpfShbZnVuY3Rpb24odCxlLHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMSksaT17MDoiRVJBUl9TVUNDRVNTIiwxMDoiRVJBUl9FTkRfQVJDSElWRSIsMTE6IkVSQVJfTk9fTUVNT1JZIiwxMjoiRVJBUl9CQURfREFUQSIsMTM6IkVSQVJfQkFEX0FSQ0hJVkUiLDE0OiJFUkFSX1VOS05PV05fRk9STUFUIiwxNToiRVJBUl9FT1BFTiIsMTY6IkVSQVJfRUNSRUFURSIsMTc6IkVSQVJfRUNMT1NFIiwxODoiRVJBUl9FUkVBRCIsMTk6IkVSQVJfRVdSSVRFIiwyMDoiRVJBUl9TTUFMTF9CVUYiLDIxOiJFUkFSX1VOS05PV04iLDIyOiJFUkFSX01JU1NJTkdfUEFTU1dPUkQiLDIzOiJFUkFSX0VSRUZFUkVOQ0UiLDI0OiJFUkFSX0JBRF9QQVNTV09SRCJ9LG89ezA6IlN1Y2Nlc3MiLDExOiJOb3QgZW5vdWdoIG1lbW9yeSIsMTI6IkFyY2hpdmUgaGVhZGVyIG9yIGRhdGEgYXJlIGRhbWFnZWQiLDEzOiJGaWxlIGlzIG5vdCBSQVIgYXJjaGl2ZSIsMTQ6IlVua25vd24gYXJjaGl2ZSBmb3JtYXQiLDE1OiJGaWxlIG9wZW4gZXJyb3IiLDE2OiJGaWxlIGNyZWF0ZSBlcnJvciIsMTc6IkZpbGUgY2xvc2UgZXJyb3IiLDE4OiJGaWxlIHJlYWQgZXJyb3IiLDE5OiJGaWxlIHdyaXRlIGVycm9yIiwyMDoiQnVmZmVyIGZvciBhcmNoaXZlIGNvbW1lbnQgaXMgdG9vIHNtYWxsLCBjb21tZW50IHRydW5jYXRlZCIsMjE6IlVua25vd24gZXJyb3IiLDIyOiJQYXNzd29yZCBmb3IgZW5jcnlwdGVkIGZpbGUgb3IgaGVhZGVyIGlzIG5vdCBzcGVjaWZpZWQiLDIzOiJDYW5ub3Qgb3BlbiBmaWxlIHNvdXJjZSBmb3IgcmVmZXJlbmNlIHJlY29yZCIsMjQ6Ildyb25nIHBhc3N3b3JkIGlzIHNwZWNpZmllZCJ9O2NsYXNzIHN7Y29uc3RydWN0b3IodD0iIil7dGhpcy5fcGFzc3dvcmQ9dCx0aGlzLl9hcmNoaXZlPW51bGw7fWdldEZpbGVMaXN0KCl7bGV0IHQsW2Uscl09dGhpcy5vcGVuQXJjKCEwKTtpZigiU1VDQ0VTUyIhPT1lLnN0YXRlKXQ9W2UsbnVsbF07ZWxzZSB7bGV0IGUsbixpPVtdO2Zvcig7W2Usbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUoKCk9PiEwKSwiU1VDQ0VTUyI9PT1lLnN0YXRlOylpLnB1c2gobi5maWxlSGVhZGVyKTt0PSJFUkFSX0VORF9BUkNISVZFIiE9PWUucmVhc29uP1tlLG51bGxdOlt7c3RhdGU6IlNVQ0NFU1MifSx7YXJjSGVhZGVyOnIsZmlsZUhlYWRlcnM6aX1dO31yZXR1cm4gdGhpcy5jbG9zZUFyYygpLHR9ZXh0cmFjdEFsbCgpe2xldCB0LFtlLHJdPXRoaXMub3BlbkFyYyghMSk7aWYoIlNVQ0NFU1MiIT09ZS5zdGF0ZSl0PVtlLG51bGxdO2Vsc2Uge2xldCBlLG4saT1bXTtmb3IoO1tlLG5dPXRoaXMucHJvY2Vzc05leHRGaWxlKCgpPT4hMSksIlNVQ0NFU1MiPT09ZS5zdGF0ZTspaS5wdXNoKG4pO3Q9IkVSQVJfRU5EX0FSQ0hJVkUiIT09ZS5yZWFzb24/W2UsbnVsbF06W3tzdGF0ZToiU1VDQ0VTUyJ9LHthcmNIZWFkZXI6cixmaWxlczppfV07fXJldHVybiB0aGlzLmNsb3NlQXJjKCksdH1leHRyYWN0RmlsZXModCxlKXtsZXQgcixbbixpXT10aGlzLm9wZW5BcmMoITEsZSksbz17fTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoOysrZSlvW3RbZV1dPWU7aWYoIlNVQ0NFU1MiIT09bi5zdGF0ZSlyPVtuLG51bGxdO2Vsc2Uge2xldCBlLG4scz1BcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSx1PTA7Zm9yKDs7KXtsZXQgcj0hMSxpPW51bGw7aWYoW2Usbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUodD0+dCBpbiBvPyhpPW9bdF0sITEpOihyPSEwLCEwKSksIlNVQ0NFU1MiIT09ZS5zdGF0ZSlicmVhaztpZighciYmKHNbaV09biwrK3U9PT10Lmxlbmd0aCkpe2UucmVhc29uPSJFUkFSX0VORF9BUkNISVZFIjticmVha319cj0iRVJBUl9FTkRfQVJDSElWRSIhPT1lLnJlYXNvbj9bZSxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2FyY0hlYWRlcjppLGZpbGVzOnN9XTt9cmV0dXJuIHRoaXMuY2xvc2VBcmMoKSxyfWZpbGVDcmVhdGVkKHQpe31jbG9zZSh0KXt0aGlzLl9sYXN0RmlsZUNvbnRlbnQ9dGhpcy5jbG9zZUZpbGUodCk7fW9wZW5BcmModCxlKXtuLkV4dC5jdXJyZW50PXRoaXMsdGhpcy5fYXJjaGl2ZT1uZXcgdW5wYWNrLlJhckFyY2hpdmU7bGV0IHIsaT10aGlzLl9hcmNoaXZlLm9wZW4odGhpcy5fZmlsZVBhdGgsZXx8dGhpcy5fcGFzc3dvcmQsdCk7cmV0dXJuIHI9MCE9PWkuc3RhdGUuZXJyQ29kZT9bdGhpcy5nZXRGYWlsSW5mbyhpLnN0YXRlLmVyckNvZGUsaS5zdGF0ZS5lcnJUeXBlKSxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2NvbW1lbnQ6aS5jb21tZW50LGZsYWdzOnt2b2x1bWU6MCE9KDEmaS5mbGFncyksbG9jazowIT0oNCZpLmZsYWdzKSxzb2xpZDowIT0oOCZpLmZsYWdzKSxhdXRoSW5mbzowIT0oMzImaS5mbGFncykscmVjb3ZlcnlSZWNvcmQ6MCE9KDY0JmkuZmxhZ3MpLGhlYWRlckVuY3J5cHRlZDowIT0oMTI4JmkuZmxhZ3MpfX1dLG4uRXh0LmN1cnJlbnQ9bnVsbCxyfXByb2Nlc3NOZXh0RmlsZSh0KXtsZXQgZTtuLkV4dC5jdXJyZW50PXRoaXM7bGV0IHI9dGhpcy5fYXJjaGl2ZS5nZXRGaWxlSGVhZGVyKCksaT1be3N0YXRlOiJTVUNDRVNTIn0sbnVsbF07aWYoMD09PXIuc3RhdGUuZXJyQ29kZSl7bGV0IGU9dChyLm5hbWUpO3RoaXMuX2xhc3RGaWxlQ29udGVudD1udWxsO2xldCBuPXRoaXMuX2FyY2hpdmUucmVhZEZpbGUoZSk7MD09PW4uZXJyQ29kZXx8ZXx8KGlbMF09dGhpcy5nZXRGYWlsSW5mbyhuLmVyckNvZGUsbi5lcnJUeXBlKSwyMj09PW4uZXJyQ29kZT9uPXRoaXMuX2FyY2hpdmUucmVhZEZpbGUoITApOm4uZXJyQ29kZT0wKSwwPT09bi5lcnJDb2RlP2lbMV09dGhpcy5fbGFzdEZpbGVDb250ZW50OihyLnN0YXRlLmVyckNvZGU9bi5lcnJDb2RlLHIuc3RhdGUuZXJyVHlwZT1uLmVyclR5cGUpLHRoaXMuX2xhc3RGaWxlQ29udGVudD1udWxsO31yZXR1cm4gZT0wIT09ci5zdGF0ZS5lcnJDb2RlP1t0aGlzLmdldEZhaWxJbmZvKHIuc3RhdGUuZXJyQ29kZSxyLnN0YXRlLmVyclR5cGUpLG51bGxdOlt7c3RhdGU6IlNVQ0NFU1MifSx7ZmlsZUhlYWRlcjp7bmFtZTpyLm5hbWUsZmxhZ3M6e2VuY3J5cHRlZDowIT0oNCZyLmZsYWdzKSxzb2xpZDowIT0oMTYmci5mbGFncyksZGlyZWN0b3J5OjAhPSgzMiZyLmZsYWdzKX0scGFja1NpemU6ci5wYWNrU2l6ZSx1bnBTaXplOnIudW5wU2l6ZSxjcmM6ci5jcmMsdGltZTpmdW5jdGlvbih0KXtjb25zdCBlPVs1LDYsNSw1LDQsN107bGV0IHI9W107Zm9yKGxldCBuIG9mIGUpci5wdXNoKHQmKDE8PG4pLTEpLHQ+Pj1uO2xldCBuPXQ9PnQ8MTA/IjAiK3Q6IiIrdDtyZXR1cm4gYCR7MTk4MCsocj1yLnJldmVyc2UoKSlbMF19LSR7bihyWzFdKX0tJHtuKHJbMl0pfWArYFQke24oclszXSl9OiR7bihyWzRdKX06JHtuKDIqcls1XSl9LjAwMGB9KHIudGltZSksdW5wVmVyOmAke01hdGguZmxvb3Ioci51bnBWZXIvMTApfS4ke3IudW5wVmVyJTEwfWAsbWV0aG9kOmZ1bmN0aW9uKHQpe3JldHVybiB7NDg6IlN0b3JpbmciLDQ5OiJGYXN0ZXN0Iiw1MDoiRmFzdCIsNTE6Ik5vcm1hbCIsNTI6Ikdvb2QiLDUzOiJCZXN0In1bdF18fCJVbmtub3duIn0oci5tZXRob2QpfSxleHRyYWN0Oml9XSxuLkV4dC5jdXJyZW50PW51bGwsZX1jbG9zZUFyYygpe24uRXh0LmN1cnJlbnQ9dGhpcyx0aGlzLl9hcmNoaXZlLmRlbGV0ZSgpLG4uRXh0LmN1cnJlbnQ9bnVsbCx0aGlzLl9hcmNoaXZlPW51bGw7fWdldEZhaWxJbmZvKHQsZSl7cmV0dXJuIHtzdGF0ZToiRkFJTCIscmVhc29uOmlbdF0sbXNnOm9bdF19fX1zLl9jdXJyZW50PW51bGwsZS5FeHRyYWN0b3I9czt9LGZ1bmN0aW9uKHQsZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZS5FeHQ9e2N1cnJlbnQ6bnVsbH07fSxmdW5jdGlvbih0LGUscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLGZ1bmN0aW9uKHQpe2Zvcih2YXIgciBpbiB0KWUuaGFzT3duUHJvcGVydHkocil8fChlW3JdPXRbcl0pO30ocigzKSk7dmFyIG49cigxKTtlLkV4dD1uLkV4dDt9LGZ1bmN0aW9uKHQsZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDQpLGk9cig2KTtlLmNyZWF0ZUV4dHJhY3RvckZyb21EYXRhPWZ1bmN0aW9uKHQsZT0iIil7cmV0dXJuIG5ldyBuLkRhdGFFeHRyYWN0b3IodCxlKX0sZS5jcmVhdGVFeHRyYWN0b3JGcm9tRmlsZT1mdW5jdGlvbih0LGU9IiIscj0iIil7cmV0dXJuIG5ldyBpLkZpbGVFeHRyYWN0b3IodCxlLHIpfTt9LGZ1bmN0aW9uKHQsZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDUpLGk9cigwKTtlLkRhdGFFeHRyYWN0b3I9Y2xhc3MgZXh0ZW5kcyBpLkV4dHJhY3Rvcntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKGUpLHRoaXMuZGF0YUZpbGVzPXt9LHRoaXMuZGF0YUZpbGVNYXA9e30sdGhpcy5jdXJyZW50RmQ9MTtsZXQgcj17ZmlsZTpuZXcgbi5EYXRhRmlsZShuZXcgVWludDhBcnJheSh0KSksZmQ6dGhpcy5jdXJyZW50RmQrK307dGhpcy5fZmlsZVBhdGg9Il9kZWZhdWx0VW5yYXJKU18ucmFyIix0aGlzLmRhdGFGaWxlc1t0aGlzLl9maWxlUGF0aF09cix0aGlzLmRhdGFGaWxlTWFwW3IuZmRdPXRoaXMuX2ZpbGVQYXRoO31vcGVuKHQpe2xldCBlPXRoaXMuZGF0YUZpbGVzW3RdO3JldHVybiBlP2UuZmQ6MH1jcmVhdGUodCl7bGV0IGU9dGhpcy5jdXJyZW50RmQrKztyZXR1cm4gdGhpcy5kYXRhRmlsZXNbdF09e2ZpbGU6bmV3IG4uRGF0YUZpbGUsZmQ6dGhpcy5jdXJyZW50RmQrK30sdGhpcy5kYXRhRmlsZU1hcFtlXT10LGV9Y2xvc2VGaWxlKHQpe2xldCBlPXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dO2lmKCFlKXJldHVybiBudWxsO2xldCByPWUuZmlsZS5yZWFkQWxsKCk7cmV0dXJuIDEhPT10PyhkZWxldGUgdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV0sZGVsZXRlIHRoaXMuZGF0YUZpbGVNYXBbdF0pOmUuZmlsZS5zZWVrKDAsIlNFVCIpLHJ9cmVhZCh0LGUscil7bGV0IG49dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07aWYoIW4pcmV0dXJuIC0xO2xldCBpPW4uZmlsZS5yZWFkKHIpO3JldHVybiBudWxsPT09aT8tMToodW5wYWNrLkhFQVBVOC5zZXQoaSxlKSxpLmJ5dGVMZW5ndGgpfXdyaXRlKHQsZSxyKXtsZXQgbj10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTtyZXR1cm4gISFuJiYobi5maWxlLndyaXRlKHVucGFjay5IRUFQVTguc2xpY2UoZSxlK3IpKSwhMCl9dGVsbCh0KXtsZXQgZT10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTtyZXR1cm4gZT9lLmZpbGUudGVsbCgpOi0xfXNlZWsodCxlLHIpe2xldCBuPXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dO3JldHVybiAhIW4mJm4uZmlsZS5zZWVrKGUscil9fTt9LGZ1bmN0aW9uKHQsZSxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7ZS5EYXRhRmlsZT1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJ1ZmZlcnM9W10sdGhpcy5wb3M9MCx0aGlzLnNpemU9MCx0JiYodGhpcy5idWZmZXJzLnB1c2godCksdGhpcy5zaXplPXQuYnl0ZUxlbmd0aCx0aGlzLnBvcz0wKTt9cmVhZCh0KXtpZih0aGlzLmZsYXR0ZW4oKSx0K3RoaXMucG9zPnRoaXMuc2l6ZSlyZXR1cm4gbnVsbDtsZXQgZT10aGlzLnBvcztyZXR1cm4gdGhpcy5wb3MrPXQsdGhpcy5idWZmZXJzWzBdLnNsaWNlKGUsdGhpcy5wb3MpfXJlYWRBbGwoKXtyZXR1cm4gdGhpcy5mbGF0dGVuKCksdGhpcy5idWZmZXJzWzBdfXdyaXRlKHQpe3JldHVybiB0aGlzLmJ1ZmZlcnMucHVzaCh0KSx0aGlzLnNpemUrPXQuYnl0ZUxlbmd0aCx0aGlzLnBvcys9dC5ieXRlTGVuZ3RoLCEwfXRlbGwoKXtyZXR1cm4gdGhpcy5wb3N9c2Vlayh0LGUpe2xldCByPXRoaXMucG9zO3JldHVybiAiU0VUIj09PWU/cj10OiJDVVIiPT09ZT9yKz10OnI9dGhpcy5zaXplLXQsIShyPDB8fHI+dGhpcy5zaXplfHwodGhpcy5wb3M9ciwwKSl9ZmxhdHRlbigpe2lmKHRoaXMuYnVmZmVycy5sZW5ndGg8PTEpcmV0dXJuO2xldCB0PW5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSksZT0wO2ZvcihsZXQgciBvZiB0aGlzLmJ1ZmZlcnMpdC5zZXQocixlKSxlKz1yLmJ5dGVMZW5ndGg7dGhpcy5idWZmZXJzPVt0XTt9fTt9LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigxMiksaT1yKDEzKSxvPXIoMCk7ZS5GaWxlRXh0cmFjdG9yPWNsYXNzIGV4dGVuZHMgby5FeHRyYWN0b3J7Y29uc3RydWN0b3IodCxlLHIpe3N1cGVyKHIpLHRoaXMuX2ZpbGVQYXRoPXQsdGhpcy5maWxlTWFwPXt9LHRoaXMuX3RhcmdldD1lO31vcGVuKHQpe2xldCBlPW4ub3BlblN5bmModCwiciIpO3JldHVybiB0aGlzLmZpbGVNYXBbZV09e3NpemU6bi5mc3RhdFN5bmMoZSkuc2l6ZSxwb3M6MCxuYW1lOnR9LGV9Y3JlYXRlKHQpe2xldCBlPWkuam9pbih0aGlzLl90YXJnZXQsdCk7aS5wYXJzZShlKS5kaXIuc3BsaXQoIi8iKS5yZWR1Y2UoKHQsZSk9Pih0Kz1lKyIvIixuLmV4aXN0c1N5bmModCl8fG4ubWtkaXJTeW5jKHQpLHQpLCIiKTtsZXQgcj1uLm9wZW5TeW5jKGUsInciKTtyZXR1cm4gdGhpcy5maWxlTWFwW3JdPXtzaXplOjAscG9zOjAsbmFtZTp0fSxyfWNsb3NlRmlsZSh0KXtyZXR1cm4gZGVsZXRlIHRoaXMuZmlsZU1hcFt0XSxuLmNsb3NlU3luYyh0KSxudWxsfXJlYWQoZSxyLGkpe2xldCBvPXRoaXMuZmlsZU1hcFtlXSxzPW5ldyB0KGkpLHU9bi5yZWFkU3luYyhlLHMsMCxpLG8ucG9zKTtyZXR1cm4gdW5wYWNrLkhFQVBVOC5zZXQocyxyKSxvLnBvcys9dSx1fXdyaXRlKGUscixpKXtsZXQgbz10aGlzLmZpbGVNYXBbZV0scz1uLndyaXRlU3luYyhlLG5ldyB0KHVucGFjay5IRUFQVTguc3ViYXJyYXkocixyK2kpKSwwLGkpO3JldHVybiBvLnBvcys9cyxvLnNpemUrPXMscz09PWl9dGVsbCh0KXtyZXR1cm4gdGhpcy5maWxlTWFwW3RdLnBvc31zZWVrKHQsZSxyKXtsZXQgbj10aGlzLmZpbGVNYXBbdF0saT1uLnBvcztyZXR1cm4gIlNFVCI9PT1yP2k9MDoiRU5EIj09PXImJihpPW4uc2l6ZSksISgoaSs9ZSk8MHx8aT5uLnNpemV8fChuLnBvcz1pLDApKX19O30pLmNhbGwodGhpcyxyKDcpLkJ1ZmZlcik7fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpew0KLyohDQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4NCiAqDQogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz4NCiAqIEBsaWNlbnNlICBNSVQNCiAqLw0KdmFyIG49cig5KSxpPXIoMTApLG89cigxMSk7ZnVuY3Rpb24gcygpe3JldHVybiBhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIHUodCxlKXtpZihzKCk8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgiKTtyZXR1cm4gYS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0PW5ldyBVaW50OEFycmF5KGUpKS5fX3Byb3RvX189YS5wcm90b3R5cGU6KG51bGw9PT10JiYodD1uZXcgYShlKSksdC5sZW5ndGg9ZSksdH1mdW5jdGlvbiBhKHQsZSxyKXtpZighKGEuVFlQRURfQVJSQVlfU1VQUE9SVHx8dGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYSh0LGUscik7aWYoIm51bWJlciI9PXR5cGVvZiB0KXtpZigic3RyaW5nIj09dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCJJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyIpO3JldHVybiBsKHRoaXMsdCl9cmV0dXJuIGYodGhpcyx0LGUscil9ZnVuY3Rpb24gZih0LGUscixuKXtpZigibnVtYmVyIj09dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVybiAidW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/ZnVuY3Rpb24odCxlLHIsbil7aWYoZS5ieXRlTGVuZ3RoLHI8MHx8ZS5ieXRlTGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHMiKTtpZihlLmJ5dGVMZW5ndGg8cisobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHMiKTtlPXZvaWQgMD09PXImJnZvaWQgMD09PW4/bmV3IFVpbnQ4QXJyYXkoZSk6dm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlLHIpOm5ldyBVaW50OEFycmF5KGUscixuKTthLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHQ9ZSkuX19wcm90b19fPWEucHJvdG90eXBlOnQ9Yyh0LGUpO3JldHVybiB0fSh0LGUscixuKToic3RyaW5nIj09dHlwZW9mIGU/ZnVuY3Rpb24odCxlLHIpeyJzdHJpbmciPT10eXBlb2YgciYmIiIhPT1yfHwocj0idXRmOCIpO2lmKCFhLmlzRW5jb2RpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcignImVuY29kaW5nIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHxnKGUsciksaT0odD11KHQsbikpLndyaXRlKGUscik7aSE9PW4mJih0PXQuc2xpY2UoMCxpKSk7cmV0dXJuIHR9KHQsZSxyKTpmdW5jdGlvbih0LGUpe2lmKGEuaXNCdWZmZXIoZSkpe3ZhciByPTB8cChlLmxlbmd0aCk7cmV0dXJuIDA9PT0odD11KHQscikpLmxlbmd0aD90OihlLmNvcHkodCwwLDAsciksdCl9aWYoZSl7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8Imxlbmd0aCJpbiBlKXJldHVybiAibnVtYmVyIiE9dHlwZW9mIGUubGVuZ3RofHxmdW5jdGlvbih0KXtyZXR1cm4gdCE9dH0oZS5sZW5ndGgpP3UodCwwKTpjKHQsZSk7aWYoIkJ1ZmZlciI9PT1lLnR5cGUmJm8oZS5kYXRhKSlyZXR1cm4gYyh0LGUuZGF0YSl9dGhyb3cgbmV3IFR5cGVFcnJvcigiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LiIpfSh0LGUpfWZ1bmN0aW9uIGgodCl7aWYoIm51bWJlciIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKX1mdW5jdGlvbiBsKHQsZSl7aWYoaChlKSx0PXUodCxlPDA/MDowfHAoZSkpLCFhLlRZUEVEX0FSUkFZX1NVUFBPUlQpZm9yKHZhciByPTA7cjxlOysrcil0W3JdPTA7cmV0dXJuIHR9ZnVuY3Rpb24gYyh0LGUpe3ZhciByPWUubGVuZ3RoPDA/MDowfHAoZS5sZW5ndGgpO3Q9dSh0LHIpO2Zvcih2YXIgbj0wO248cjtuKz0xKXRbbl09MjU1JmVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gcCh0KXtpZih0Pj1zKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgiK3MoKS50b1N0cmluZygxNikrIiBieXRlcyIpO3JldHVybiAwfHR9ZnVuY3Rpb24gZyh0LGUpe2lmKGEuaXNCdWZmZXIodCkpcmV0dXJuIHQubGVuZ3RoO2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgQXJyYXlCdWZmZXImJiJmdW5jdGlvbiI9PXR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcmJihBcnJheUJ1ZmZlci5pc1ZpZXcodCl8fHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpcmV0dXJuIHQuYnl0ZUxlbmd0aDsic3RyaW5nIiE9dHlwZW9mIHQmJih0PSIiK3QpO3ZhciByPXQubGVuZ3RoO2lmKDA9PT1yKXJldHVybiAwO2Zvcih2YXIgbj0hMTs7KXN3aXRjaChlKXtjYXNlImFzY2lpIjpjYXNlImxhdGluMSI6Y2FzZSJiaW5hcnkiOnJldHVybiByO2Nhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6Y2FzZSB2b2lkIDA6cmV0dXJuIGsodCkubGVuZ3RoO2Nhc2UidWNzMiI6Y2FzZSJ1Y3MtMiI6Y2FzZSJ1dGYxNmxlIjpjYXNlInV0Zi0xNmxlIjpyZXR1cm4gMipyO2Nhc2UiaGV4IjpyZXR1cm4gcj4+PjE7Y2FzZSJiYXNlNjQiOnJldHVybiBqKHQpLmxlbmd0aDtkZWZhdWx0OmlmKG4pcmV0dXJuIGsodCkubGVuZ3RoO2U9KCIiK2UpLnRvTG93ZXJDYXNlKCksbj0hMDt9fWZ1bmN0aW9uIGQodCxlLHIpe3ZhciBuPXRbZV07dFtlXT10W3JdLHRbcl09bjt9ZnVuY3Rpb24geSh0LGUscixuLGkpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gLTE7aWYoInN0cmluZyI9PXR5cGVvZiByPyhuPXIscj0wKTpyPjIxNDc0ODM2NDc/cj0yMTQ3NDgzNjQ3OnI8LTIxNDc0ODM2NDgmJihyPS0yMTQ3NDgzNjQ4KSxyPStyLGlzTmFOKHIpJiYocj1pPzA6dC5sZW5ndGgtMSkscjwwJiYocj10Lmxlbmd0aCtyKSxyPj10Lmxlbmd0aCl7aWYoaSlyZXR1cm4gLTE7cj10Lmxlbmd0aC0xO31lbHNlIGlmKHI8MCl7aWYoIWkpcmV0dXJuIC0xO3I9MDt9aWYoInN0cmluZyI9PXR5cGVvZiBlJiYoZT1hLmZyb20oZSxuKSksYS5pc0J1ZmZlcihlKSlyZXR1cm4gMD09PWUubGVuZ3RoPy0xOncodCxlLHIsbixpKTtpZigibnVtYmVyIj09dHlwZW9mIGUpcmV0dXJuIGUmPTI1NSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQmJiJmdW5jdGlvbiI9PXR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP2k/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHQsZSxyKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKHQsZSxyKTp3KHQsW2VdLHIsbixpKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKX1mdW5jdGlvbiB3KHQsZSxyLG4saSl7dmFyIG8scz0xLHU9dC5sZW5ndGgsYT1lLmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoInVjczIiPT09KG49U3RyaW5nKG4pLnRvTG93ZXJDYXNlKCkpfHwidWNzLTIiPT09bnx8InV0ZjE2bGUiPT09bnx8InV0Zi0xNmxlIj09PW4pKXtpZih0Lmxlbmd0aDwyfHxlLmxlbmd0aDwyKXJldHVybiAtMTtzPTIsdS89MixhLz0yLHIvPTI7fWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4gMT09PXM/dFtlXTp0LnJlYWRVSW50MTZCRShlKnMpfWlmKGkpe3ZhciBoPS0xO2ZvcihvPXI7bzx1O28rKylpZihmKHQsbyk9PT1mKGUsLTE9PT1oPzA6by1oKSl7aWYoLTE9PT1oJiYoaD1vKSxvLWgrMT09PWEpcmV0dXJuIGgqc31lbHNlIC0xIT09aCYmKG8tPW8taCksaD0tMTt9ZWxzZSBmb3IocithPnUmJihyPXUtYSksbz1yO28+PTA7by0tKXtmb3IodmFyIGw9ITAsYz0wO2M8YTtjKyspaWYoZih0LG8rYykhPT1mKGUsYykpe2w9ITE7YnJlYWt9aWYobClyZXR1cm4gb31yZXR1cm4gLTF9ZnVuY3Rpb24gRSh0LGUscixuKXtyPU51bWJlcihyKXx8MDt2YXIgaT10Lmxlbmd0aC1yO24/KG49TnVtYmVyKG4pKT5pJiYobj1pKTpuPWk7dmFyIG89ZS5sZW5ndGg7aWYobyUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgaGV4IHN0cmluZyIpO24+by8yJiYobj1vLzIpO2Zvcih2YXIgcz0wO3M8bjsrK3Mpe3ZhciB1PXBhcnNlSW50KGUuc3Vic3RyKDIqcywyKSwxNik7aWYoaXNOYU4odSkpcmV0dXJuIHM7dFtyK3NdPXU7fXJldHVybiBzfWZ1bmN0aW9uIHYodCxlLHIsbil7cmV0dXJuIHooayhlLHQubGVuZ3RoLXIpLHQscixuKX1mdW5jdGlvbiBBKHQsZSxyLG4pe3JldHVybiB6KGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTA7cjx0Lmxlbmd0aDsrK3IpZS5wdXNoKDI1NSZ0LmNoYXJDb2RlQXQocikpO3JldHVybiBlfShlKSx0LHIsbil9ZnVuY3Rpb24gXyh0LGUscixuKXtyZXR1cm4gQSh0LGUscixuKX1mdW5jdGlvbiBiKHQsZSxyLG4pe3JldHVybiB6KGooZSksdCxyLG4pfWZ1bmN0aW9uIG0odCxlLHIsbil7cmV0dXJuIHooZnVuY3Rpb24odCxlKXtmb3IodmFyIHIsbixpLG89W10scz0wO3M8dC5sZW5ndGgmJiEoKGUtPTIpPDApOysrcylyPXQuY2hhckNvZGVBdChzKSxuPXI+PjgsaT1yJTI1NixvLnB1c2goaSksby5wdXNoKG4pO3JldHVybiBvfShlLHQubGVuZ3RoLXIpLHQscixuKX1mdW5jdGlvbiBSKHQsZSxyKXtyZXR1cm4gMD09PWUmJnI9PT10Lmxlbmd0aD9uLmZyb21CeXRlQXJyYXkodCk6bi5mcm9tQnl0ZUFycmF5KHQuc2xpY2UoZSxyKSl9ZnVuY3Rpb24gUyh0LGUscil7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIG49W10saT1lO2k8cjspe3ZhciBvLHMsdSxhLGY9dFtpXSxoPW51bGwsbD1mPjIzOT80OmY+MjIzPzM6Zj4xOTE/MjoxO2lmKGkrbDw9cilzd2l0Y2gobCl7Y2FzZSAxOmY8MTI4JiYoaD1mKTticmVhaztjYXNlIDI6MTI4PT0oMTkyJihvPXRbaSsxXSkpJiYoYT0oMzEmZik8PDZ8NjMmbyk+MTI3JiYoaD1hKTticmVhaztjYXNlIDM6bz10W2krMV0scz10W2krMl0sMTI4PT0oMTkyJm8pJiYxMjg9PSgxOTImcykmJihhPSgxNSZmKTw8MTJ8KDYzJm8pPDw2fDYzJnMpPjIwNDcmJihhPDU1Mjk2fHxhPjU3MzQzKSYmKGg9YSk7YnJlYWs7Y2FzZSA0Om89dFtpKzFdLHM9dFtpKzJdLHU9dFtpKzNdLDEyOD09KDE5MiZvKSYmMTI4PT0oMTkyJnMpJiYxMjg9PSgxOTImdSkmJihhPSgxNSZmKTw8MTh8KDYzJm8pPDwxMnwoNjMmcyk8PDZ8NjMmdSk+NjU1MzUmJmE8MTExNDExMiYmKGg9YSk7fW51bGw9PT1oPyhoPTY1NTMzLGw9MSk6aD42NTUzNSYmKGgtPTY1NTM2LG4ucHVzaChoPj4+MTAmMTAyM3w1NTI5NiksaD01NjMyMHwxMDIzJmgpLG4ucHVzaChoKSxpKz1sO31yZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZTw9VClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsdCk7dmFyIHI9IiIsbj0wO2Zvcig7bjxlOylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0LnNsaWNlKG4sbis9VCkpO3JldHVybiByfShuKX1lLkJ1ZmZlcj1hLGUuU2xvd0J1ZmZlcj1mdW5jdGlvbih0KXsrdCE9dCYmKHQ9MCk7cmV0dXJuIGEuYWxsb2MoK3QpfSxlLklOU1BFQ1RfTUFYX0JZVEVTPTUwLGEuVFlQRURfQVJSQVlfU1VQUE9SVD12b2lkIDAhPT10LlRZUEVEX0FSUkFZX1NVUFBPUlQ/dC5UWVBFRF9BUlJBWV9TVVBQT1JUOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW5ldyBVaW50OEFycmF5KDEpO3JldHVybiB0Ll9fcHJvdG9fXz17X19wcm90b19fOlVpbnQ4QXJyYXkucHJvdG90eXBlLGZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19LDQyPT09dC5mb28oKSYmImZ1bmN0aW9uIj09dHlwZW9mIHQuc3ViYXJyYXkmJjA9PT10LnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaCh0KXtyZXR1cm4gITF9fSgpLGUua01heExlbmd0aD1zKCksYS5wb29sU2l6ZT04MTkyLGEuX2F1Z21lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19fPWEucHJvdG90eXBlLHR9LGEuZnJvbT1mdW5jdGlvbih0LGUscil7cmV0dXJuIGYobnVsbCx0LGUscil9LGEuVFlQRURfQVJSQVlfU1VQUE9SVCYmKGEucHJvdG90eXBlLl9fcHJvdG9fXz1VaW50OEFycmF5LnByb3RvdHlwZSxhLl9fcHJvdG9fXz1VaW50OEFycmF5LCJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuc3BlY2llcyYmYVtTeW1ib2wuc3BlY2llc109PT1hJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxTeW1ib2wuc3BlY2llcyx7dmFsdWU6bnVsbCxjb25maWd1cmFibGU6ITB9KSksYS5hbGxvYz1mdW5jdGlvbih0LGUscil7cmV0dXJuIGZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiBoKGUpLGU8PTA/dSh0LGUpOnZvaWQgMCE9PXI/InN0cmluZyI9PXR5cGVvZiBuP3UodCxlKS5maWxsKHIsbik6dSh0LGUpLmZpbGwocik6dSh0LGUpfShudWxsLHQsZSxyKX0sYS5hbGxvY1Vuc2FmZT1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSxhLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSxhLmlzQnVmZmVyPWZ1bmN0aW9uKHQpe3JldHVybiAhKG51bGw9PXR8fCF0Ll9pc0J1ZmZlcil9LGEuY29tcGFyZT1mdW5jdGlvbih0LGUpe2lmKCFhLmlzQnVmZmVyKHQpfHwhYS5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzIik7aWYodD09PWUpcmV0dXJuIDA7Zm9yKHZhciByPXQubGVuZ3RoLG49ZS5sZW5ndGgsaT0wLG89TWF0aC5taW4ocixuKTtpPG87KytpKWlmKHRbaV0hPT1lW2ldKXtyPXRbaV0sbj1lW2ldO2JyZWFrfXJldHVybiByPG4/LTE6bjxyPzE6MH0sYS5pc0VuY29kaW5nPWZ1bmN0aW9uKHQpe3N3aXRjaChTdHJpbmcodCkudG9Mb3dlckNhc2UoKSl7Y2FzZSJoZXgiOmNhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6Y2FzZSJhc2NpaSI6Y2FzZSJsYXRpbjEiOmNhc2UiYmluYXJ5IjpjYXNlImJhc2U2NCI6Y2FzZSJ1Y3MyIjpjYXNlInVjcy0yIjpjYXNlInV0ZjE2bGUiOmNhc2UidXRmLTE2bGUiOnJldHVybiAhMDtkZWZhdWx0OnJldHVybiAhMX19LGEuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoIW8odCkpdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gYS5hbGxvYygwKTt2YXIgcjtpZih2b2lkIDA9PT1lKWZvcihlPTAscj0wO3I8dC5sZW5ndGg7KytyKWUrPXRbcl0ubGVuZ3RoO3ZhciBuPWEuYWxsb2NVbnNhZmUoZSksaT0wO2ZvcihyPTA7cjx0Lmxlbmd0aDsrK3Ipe3ZhciBzPXRbcl07aWYoIWEuaXNCdWZmZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO3MuY29weShuLGkpLGkrPXMubGVuZ3RoO31yZXR1cm4gbn0sYS5ieXRlTGVuZ3RoPWcsYS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLGEucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9MilkKHRoaXMsZSxlKzEpO3JldHVybiB0aGlzfSxhLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTQhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzIik7Zm9yKHZhciBlPTA7ZTx0O2UrPTQpZCh0aGlzLGUsZSszKSxkKHRoaXMsZSsxLGUrMik7cmV0dXJuIHRoaXN9LGEucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlOCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9OClkKHRoaXMsZSxlKzcpLGQodGhpcyxlKzEsZSs2KSxkKHRoaXMsZSsyLGUrNSksZCh0aGlzLGUrMyxlKzQpO3JldHVybiB0aGlzfSxhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT10PyIiOjA9PT1hcmd1bWVudHMubGVuZ3RoP1ModGhpcywwLHQpOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj0hMTtpZigodm9pZCAwPT09ZXx8ZTwwKSYmKGU9MCksZT50aGlzLmxlbmd0aClyZXR1cm4gIiI7aWYoKHZvaWQgMD09PXJ8fHI+dGhpcy5sZW5ndGgpJiYocj10aGlzLmxlbmd0aCkscjw9MClyZXR1cm4gIiI7aWYoKHI+Pj49MCk8PShlPj4+PTApKXJldHVybiAiIjtmb3IodHx8KHQ9InV0ZjgiKTs7KXN3aXRjaCh0KXtjYXNlImhleCI6cmV0dXJuIFUodGhpcyxlLHIpO2Nhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6cmV0dXJuIFModGhpcyxlLHIpO2Nhc2UiYXNjaWkiOnJldHVybiBQKHRoaXMsZSxyKTtjYXNlImxhdGluMSI6Y2FzZSJiaW5hcnkiOnJldHVybiBDKHRoaXMsZSxyKTtjYXNlImJhc2U2NCI6cmV0dXJuIFIodGhpcyxlLHIpO2Nhc2UidWNzMiI6Y2FzZSJ1Y3MtMiI6Y2FzZSJ1dGYxNmxlIjpjYXNlInV0Zi0xNmxlIjpyZXR1cm4gQih0aGlzLGUscik7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIrdCk7dD0odCsiIikudG9Mb3dlckNhc2UoKSxuPSEwO319LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sYS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKHQpe2lmKCFhLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTtyZXR1cm4gdGhpcz09PXR8fDA9PT1hLmNvbXBhcmUodGhpcyx0KX0sYS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciB0PSIiLHI9ZS5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gdGhpcy5sZW5ndGg+MCYmKHQ9dGhpcy50b1N0cmluZygiaGV4IiwwLHIpLm1hdGNoKC8uezJ9L2cpLmpvaW4oIiAiKSx0aGlzLmxlbmd0aD5yJiYodCs9IiAuLi4gIikpLCI8QnVmZmVyICIrdCsiPiJ9LGEucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLHIsbixpKXtpZighYS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIik7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09ciYmKHI9dD90Lmxlbmd0aDowKSx2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1pJiYoaT10aGlzLmxlbmd0aCksZTwwfHxyPnQubGVuZ3RofHxuPDB8fGk+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm91dCBvZiByYW5nZSBpbmRleCIpO2lmKG4+PWkmJmU+PXIpcmV0dXJuIDA7aWYobj49aSlyZXR1cm4gLTE7aWYoZT49cilyZXR1cm4gMTtpZihlPj4+PTAscj4+Pj0wLG4+Pj49MCxpPj4+PTAsdGhpcz09PXQpcmV0dXJuIDA7Zm9yKHZhciBvPWktbixzPXItZSx1PU1hdGgubWluKG8scyksZj10aGlzLnNsaWNlKG4saSksaD10LnNsaWNlKGUsciksbD0wO2w8dTsrK2wpaWYoZltsXSE9PWhbbF0pe289ZltsXSxzPWhbbF07YnJlYWt9cmV0dXJuIG88cz8tMTpzPG8/MTowfSxhLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuIC0xIT09dGhpcy5pbmRleE9mKHQsZSxyKX0sYS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbih0LGUscil7cmV0dXJuIHkodGhpcyx0LGUsciwhMCl9LGEucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4geSh0aGlzLHQsZSxyLCExKX0sYS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLHIsbil7aWYodm9pZCAwPT09ZSluPSJ1dGY4IixyPXRoaXMubGVuZ3RoLGU9MDtlbHNlIGlmKHZvaWQgMD09PXImJiJzdHJpbmciPT10eXBlb2YgZSluPWUscj10aGlzLmxlbmd0aCxlPTA7ZWxzZSB7aWYoIWlzRmluaXRlKGUpKXRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTtlfD0wLGlzRmluaXRlKHIpPyhyfD0wLHZvaWQgMD09PW4mJihuPSJ1dGY4IikpOihuPXIscj12b2lkIDApO312YXIgaT10aGlzLmxlbmd0aC1lO2lmKCh2b2lkIDA9PT1yfHxyPmkpJiYocj1pKSx0Lmxlbmd0aD4wJiYocjwwfHxlPDApfHxlPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyIpO258fChuPSJ1dGY4Iik7Zm9yKHZhciBvPSExOzspc3dpdGNoKG4pe2Nhc2UiaGV4IjpyZXR1cm4gRSh0aGlzLHQsZSxyKTtjYXNlInV0ZjgiOmNhc2UidXRmLTgiOnJldHVybiB2KHRoaXMsdCxlLHIpO2Nhc2UiYXNjaWkiOnJldHVybiBBKHRoaXMsdCxlLHIpO2Nhc2UibGF0aW4xIjpjYXNlImJpbmFyeSI6cmV0dXJuIF8odGhpcyx0LGUscik7Y2FzZSJiYXNlNjQiOnJldHVybiBiKHRoaXMsdCxlLHIpO2Nhc2UidWNzMiI6Y2FzZSJ1Y3MtMiI6Y2FzZSJ1dGYxNmxlIjpjYXNlInV0Zi0xNmxlIjpyZXR1cm4gbSh0aGlzLHQsZSxyKTtkZWZhdWx0OmlmKG8pdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIituKTtuPSgiIituKS50b0xvd2VyQ2FzZSgpLG89ITA7fX0sYS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHt0eXBlOiJCdWZmZXIiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07dmFyIFQ9NDA5NjtmdW5jdGlvbiBQKHQsZSxyKXt2YXIgbj0iIjtyPU1hdGgubWluKHQubGVuZ3RoLHIpO2Zvcih2YXIgaT1lO2k8cjsrK2kpbis9U3RyaW5nLmZyb21DaGFyQ29kZSgxMjcmdFtpXSk7cmV0dXJuIG59ZnVuY3Rpb24gQyh0LGUscil7dmFyIG49IiI7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIGk9ZTtpPHI7KytpKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUodFtpXSk7cmV0dXJuIG59ZnVuY3Rpb24gVSh0LGUscil7dmFyIG49dC5sZW5ndGg7KCFlfHxlPDApJiYoZT0wKSwoIXJ8fHI8MHx8cj5uKSYmKHI9bik7Zm9yKHZhciBpPSIiLG89ZTtvPHI7KytvKWkrPU4odFtvXSk7cmV0dXJuIGl9ZnVuY3Rpb24gQih0LGUscil7Zm9yKHZhciBuPXQuc2xpY2UoZSxyKSxpPSIiLG89MDtvPG4ubGVuZ3RoO28rPTIpaSs9U3RyaW5nLmZyb21DaGFyQ29kZShuW29dKzI1NipuW28rMV0pO3JldHVybiBpfWZ1bmN0aW9uIEYodCxlLHIpe2lmKHQlMSE9MHx8dDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCJvZmZzZXQgaXMgbm90IHVpbnQiKTtpZih0K2U+cil0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpfWZ1bmN0aW9uIE0odCxlLHIsbixpLG8pe2lmKCFhLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihlPml8fGU8byl0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYocituPnQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB4KHQsZSxyLG4pe2U8MCYmKGU9NjU1MzUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsMik7aTxvOysraSl0W3IraV09KGUmMjU1PDw4KihuP2k6MS1pKSk+Pj44KihuP2k6MS1pKTt9ZnVuY3Rpb24gSSh0LGUscixuKXtlPDAmJihlPTQyOTQ5NjcyOTUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsNCk7aTxvOysraSl0W3IraV09ZT4+PjgqKG4/aTozLWkpJjI1NTt9ZnVuY3Rpb24gTyh0LGUscixuLGksbyl7aWYocituPnQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIFkodCxlLHIsbixvKXtyZXR1cm4gb3x8Tyh0LDAsciw0KSxpLndyaXRlKHQsZSxyLG4sMjMsNCkscis0fWZ1bmN0aW9uIEwodCxlLHIsbixvKXtyZXR1cm4gb3x8Tyh0LDAsciw4KSxpLndyaXRlKHQsZSxyLG4sNTIsOCkscis4fWEucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbj10aGlzLmxlbmd0aDtpZih0PX5+dCxlPXZvaWQgMD09PWU/bjp+fmUsdDwwPyh0Kz1uKTwwJiYodD0wKTp0Pm4mJih0PW4pLGU8MD8oZSs9bik8MCYmKGU9MCk6ZT5uJiYoZT1uKSxlPHQmJihlPXQpLGEuVFlQRURfQVJSQVlfU1VQUE9SVCkocj10aGlzLnN1YmFycmF5KHQsZSkpLl9fcHJvdG9fXz1hLnByb3RvdHlwZTtlbHNlIHt2YXIgaT1lLXQ7cj1uZXcgYShpLHZvaWQgMCk7Zm9yKHZhciBvPTA7bzxpOysrbylyW29dPXRoaXNbbyt0XTt9cmV0dXJuIHJ9LGEucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24odCxlLHIpe3R8PTAsZXw9MCxyfHxGKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdF0saT0xLG89MDsrK288ZSYmKGkqPTI1Nik7KW4rPXRoaXNbdCtvXSppO3JldHVybiBufSxhLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8Rih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3QrLS1lXSxpPTE7ZT4wJiYoaSo9MjU2KTspbis9dGhpc1t0Ky0tZV0qaTtyZXR1cm4gbn0sYS5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCwxLHRoaXMubGVuZ3RoKSx0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSxhLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDh8dGhpc1t0KzFdfSxhLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDQsdGhpcy5sZW5ndGgpLCh0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2KSsxNjc3NzIxNip0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxGKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0sYS5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8Rih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3RdLGk9MSxvPTA7KytvPGUmJihpKj0yNTYpOyluKz10aGlzW3Qrb10qaTtyZXR1cm4gbj49KGkqPTEyOCkmJihuLT1NYXRoLnBvdygyLDgqZSkpLG59LGEucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbih0LGUscil7dHw9MCxlfD0wLHJ8fEYodCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49ZSxpPTEsbz10aGlzW3QrLS1uXTtuPjAmJihpKj0yNTYpOylvKz10aGlzW3QrLS1uXSppO3JldHVybiBvPj0oaSo9MTI4KSYmKG8tPU1hdGgucG93KDIsOCplKSksb30sYS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fEYodCwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0sYS5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxGKHQsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LGEucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LGEucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDIzLDQpfSxhLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxGKHQsNCx0aGlzLmxlbmd0aCksaS5yZWFkKHRoaXMsdCwhMSwyMyw0KX0sYS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw4LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDUyLDgpfSxhLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDgsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLHQsITEsNTIsOCl9LGEucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxyLG4peyh0PSt0LGV8PTAscnw9MCxuKXx8TSh0aGlzLHQsZSxyLE1hdGgucG93KDIsOCpyKS0xLDApO3ZhciBpPTEsbz0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrbzxyJiYoaSo9MjU2KTspdGhpc1tlK29dPXQvaSYyNTU7cmV0dXJuIGUrcn0sYS5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24odCxlLHIsbil7KHQ9K3QsZXw9MCxyfD0wLG4pfHxNKHRoaXMsdCxlLHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIGk9ci0xLG89MTtmb3IodGhpc1tlK2ldPTI1NSZ0Oy0taT49MCYmKG8qPTI1Nik7KXRoaXNbZStpXT10L28mMjU1O3JldHVybiBlK3J9LGEucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSwxLDI1NSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHRoaXNbZV09MjU1JnQsZSsxfSxhLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsMiw2NTUzNSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTp4KHRoaXMsdCxlLCEwKSxlKzJ9LGEucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSwyLDY1NTM1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOngodGhpcyx0LGUsITEpLGUrMn0sYS5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDQsNDI5NDk2NzI5NSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZSszXT10Pj4+MjQsdGhpc1tlKzJdPXQ+Pj4xNix0aGlzW2UrMV09dD4+PjgsdGhpc1tlXT0yNTUmdCk6SSh0aGlzLHQsZSwhMCksZSs0fSxhLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpJKHRoaXMsdCxlLCExKSxlKzR9LGEucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24odCxlLHIsbil7aWYodD0rdCxlfD0wLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtNKHRoaXMsdCxlLHIsaS0xLC1pKTt9dmFyIG89MCxzPTEsdT0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrbzxyJiYocyo9MjU2KTspdDwwJiYwPT09dSYmMCE9PXRoaXNbZStvLTFdJiYodT0xKSx0aGlzW2Urb109KHQvcz4+MCktdSYyNTU7cmV0dXJuIGUrcn0sYS5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbih0LGUscixuKXtpZih0PSt0LGV8PTAsIW4pe3ZhciBpPU1hdGgucG93KDIsOCpyLTEpO00odGhpcyx0LGUscixpLTEsLWkpO312YXIgbz1yLTEscz0xLHU9MDtmb3IodGhpc1tlK29dPTI1NSZ0Oy0tbz49MCYmKHMqPTI1Nik7KXQ8MCYmMD09PXUmJjAhPT10aGlzW2UrbysxXSYmKHU9MSksdGhpc1tlK29dPSh0L3M+PjApLXUmMjU1O3JldHVybiBlK3J9LGEucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDEsMTI3LC0xMjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVHx8KHQ9TWF0aC5mbG9vcih0KSksdDwwJiYodD0yNTUrdCsxKSx0aGlzW2VdPTI1NSZ0LGUrMX0sYS5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsMiwzMjc2NywtMzI3NjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT0yNTUmdCx0aGlzW2UrMV09dD4+PjgpOngodGhpcyx0LGUsITApLGUrMn0sYS5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsMiwzMjc2NywtMzI3NjgpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOngodGhpcyx0LGUsITEpLGUrMn0sYS5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzNdPXQ+Pj4yNCk6SSh0aGlzLHQsZSwhMCksZSs0fSxhLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLHQ8MCYmKHQ9NDI5NDk2NzI5NSt0KzEpLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpJKHRoaXMsdCxlLCExKSxlKzR9LGEucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIFkodGhpcyx0LGUsITAscil9LGEucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIFkodGhpcyx0LGUsITEscil9LGEucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBMKHRoaXMsdCxlLCEwLHIpfSxhLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTCh0aGlzLHQsZSwhMSxyKX0sYS5wcm90b3R5cGUuY29weT1mdW5jdGlvbih0LGUscixuKXtpZihyfHwocj0wKSxufHwwPT09bnx8KG49dGhpcy5sZW5ndGgpLGU+PXQubGVuZ3RoJiYoZT10Lmxlbmd0aCksZXx8KGU9MCksbj4wJiZuPHImJihuPXIpLG49PT1yKXJldHVybiAwO2lmKDA9PT10Lmxlbmd0aHx8MD09PXRoaXMubGVuZ3RoKXJldHVybiAwO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcyIpO2lmKHI8MHx8cj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMiKTtpZihuPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzIik7bj50aGlzLmxlbmd0aCYmKG49dGhpcy5sZW5ndGgpLHQubGVuZ3RoLWU8bi1yJiYobj10Lmxlbmd0aC1lK3IpO3ZhciBpLG89bi1yO2lmKHRoaXM9PT10JiZyPGUmJmU8bilmb3IoaT1vLTE7aT49MDstLWkpdFtpK2VdPXRoaXNbaStyXTtlbHNlIGlmKG88MWUzfHwhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvcihpPTA7aTxvOysraSl0W2krZV09dGhpc1tpK3JdO2Vsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodCx0aGlzLnN1YmFycmF5KHIscitvKSxlKTtyZXR1cm4gb30sYS5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUscixuKXtpZigic3RyaW5nIj09dHlwZW9mIHQpe2lmKCJzdHJpbmciPT10eXBlb2YgZT8obj1lLGU9MCxyPXRoaXMubGVuZ3RoKToic3RyaW5nIj09dHlwZW9mIHImJihuPXIscj10aGlzLmxlbmd0aCksMT09PXQubGVuZ3RoKXt2YXIgaT10LmNoYXJDb2RlQXQoMCk7aTwyNTYmJih0PWkpO31pZih2b2lkIDAhPT1uJiYic3RyaW5nIiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcigiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZyIpO2lmKCJzdHJpbmciPT10eXBlb2YgbiYmIWEuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiK24pfWVsc2UgIm51bWJlciI9PXR5cGVvZiB0JiYodCY9MjU1KTtpZihlPDB8fHRoaXMubGVuZ3RoPGV8fHRoaXMubGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk91dCBvZiByYW5nZSBpbmRleCIpO2lmKHI8PWUpcmV0dXJuIHRoaXM7dmFyIG87aWYoZT4+Pj0wLHI9dm9pZCAwPT09cj90aGlzLmxlbmd0aDpyPj4+MCx0fHwodD0wKSwibnVtYmVyIj09dHlwZW9mIHQpZm9yKG89ZTtvPHI7KytvKXRoaXNbb109dDtlbHNlIHt2YXIgcz1hLmlzQnVmZmVyKHQpP3Q6ayhuZXcgYSh0LG4pLnRvU3RyaW5nKCkpLHU9cy5sZW5ndGg7Zm9yKG89MDtvPHItZTsrK28pdGhpc1tvK2VdPXNbbyV1XTt9cmV0dXJuIHRoaXN9O3ZhciBEPS9bXitcLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIE4odCl7cmV0dXJuIHQ8MTY/IjAiK3QudG9TdHJpbmcoMTYpOnQudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIGsodCxlKXt2YXIgcjtlPWV8fDEvMDtmb3IodmFyIG49dC5sZW5ndGgsaT1udWxsLG89W10scz0wO3M8bjsrK3Mpe2lmKChyPXQuY2hhckNvZGVBdChzKSk+NTUyOTUmJnI8NTczNDQpe2lmKCFpKXtpZihyPjU2MzE5KXsoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aWYocysxPT09bil7KGUtPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWk9cjtjb250aW51ZX1pZihyPDU2MzIwKXsoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSksaT1yO2NvbnRpbnVlfXI9NjU1MzYrKGktNTUyOTY8PDEwfHItNTYzMjApO31lbHNlIGkmJihlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtpZihpPW51bGwscjwxMjgpe2lmKChlLT0xKTwwKWJyZWFrO28ucHVzaChyKTt9ZWxzZSBpZihyPDIwNDgpe2lmKChlLT0yKTwwKWJyZWFrO28ucHVzaChyPj42fDE5Miw2MyZyfDEyOCk7fWVsc2UgaWYocjw2NTUzNil7aWYoKGUtPTMpPDApYnJlYWs7by5wdXNoKHI+PjEyfDIyNCxyPj42JjYzfDEyOCw2MyZyfDEyOCk7fWVsc2Uge2lmKCEocjwxMTE0MTEyKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29kZSBwb2ludCIpO2lmKChlLT00KTwwKWJyZWFrO28ucHVzaChyPj4xOHwyNDAscj4+MTImNjN8MTI4LHI+PjYmNjN8MTI4LDYzJnJ8MTI4KTt9fXJldHVybiBvfWZ1bmN0aW9uIGoodCl7cmV0dXJuIG4udG9CeXRlQXJyYXkoZnVuY3Rpb24odCl7aWYoKHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbT90LnRyaW0oKTp0LnJlcGxhY2UoL15ccyt8XHMrJC9nLCIiKX0odCkucmVwbGFjZShELCIiKSkubGVuZ3RoPDIpcmV0dXJuICIiO2Zvcig7dC5sZW5ndGglNCE9MDspdCs9Ij0iO3JldHVybiB0fSh0KSl9ZnVuY3Rpb24geih0LGUscixuKXtmb3IodmFyIGk9MDtpPG4mJiEoaStyPj1lLmxlbmd0aHx8aT49dC5sZW5ndGgpOysraSllW2krcl09dFtpXTtyZXR1cm4gaX19KS5jYWxsKHRoaXMscig4KSk7fSxmdW5jdGlvbih0LGUpe3ZhciByO3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7cj1yfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpfHwoMCxldmFsKSgidGhpcyIpO31jYXRjaCh0KXsib2JqZWN0Ij09dHlwZW9mIHdpbmRvdyYmKHI9d2luZG93KTt9dC5leHBvcnRzPXI7fSxmdW5jdGlvbih0LGUscil7ZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPWYodCkscj1lWzBdLG49ZVsxXTtyZXR1cm4gMyoocituKS80LW59LGUudG9CeXRlQXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9Zih0KSxuPXJbMF0scz1yWzFdLHU9bmV3IG8oZnVuY3Rpb24odCxlLHIpe3JldHVybiAzKihlK3IpLzQtcn0oMCxuLHMpKSxhPTAsaD1zPjA/bi00Om4sbD0wO2w8aDtsKz00KWU9aVt0LmNoYXJDb2RlQXQobCldPDwxOHxpW3QuY2hhckNvZGVBdChsKzEpXTw8MTJ8aVt0LmNoYXJDb2RlQXQobCsyKV08PDZ8aVt0LmNoYXJDb2RlQXQobCszKV0sdVthKytdPWU+PjE2JjI1NSx1W2ErK109ZT4+OCYyNTUsdVthKytdPTI1NSZlOzI9PT1zJiYoZT1pW3QuY2hhckNvZGVBdChsKV08PDJ8aVt0LmNoYXJDb2RlQXQobCsxKV0+PjQsdVthKytdPTI1NSZlKTsxPT09cyYmKGU9aVt0LmNoYXJDb2RlQXQobCldPDwxMHxpW3QuY2hhckNvZGVBdChsKzEpXTw8NHxpW3QuY2hhckNvZGVBdChsKzIpXT4+Mix1W2ErK109ZT4+OCYyNTUsdVthKytdPTI1NSZlKTtyZXR1cm4gdX0sZS5mcm9tQnl0ZUFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPXQubGVuZ3RoLGk9ciUzLG89W10scz0wLHU9ci1pO3M8dTtzKz0xNjM4MylvLnB1c2gobCh0LHMscysxNjM4Mz51P3U6cysxNjM4MykpOzE9PT1pPyhlPXRbci0xXSxvLnB1c2gobltlPj4yXStuW2U8PDQmNjNdKyI9PSIpKToyPT09aSYmKGU9KHRbci0yXTw8OCkrdFtyLTFdLG8ucHVzaChuW2U+PjEwXStuW2U+PjQmNjNdK25bZTw8MiY2M10rIj0iKSk7cmV0dXJuIG8uam9pbigiIil9O2Zvcih2YXIgbj1bXSxpPVtdLG89InVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXkscz0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIsdT0wLGE9cy5sZW5ndGg7dTxhOysrdSluW3VdPXNbdV0saVtzLmNoYXJDb2RlQXQodSldPXU7ZnVuY3Rpb24gZih0KXt2YXIgZT10Lmxlbmd0aDtpZihlJTQ+MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQiKTt2YXIgcj10LmluZGV4T2YoIj0iKTtyZXR1cm4gLTE9PT1yJiYocj1lKSxbcixyPT09ZT8wOjQtciU0XX1mdW5jdGlvbiBoKHQpe3JldHVybiBuW3Q+PjE4JjYzXStuW3Q+PjEyJjYzXStuW3Q+PjYmNjNdK25bNjMmdF19ZnVuY3Rpb24gbCh0LGUscil7Zm9yKHZhciBuLGk9W10sbz1lO288cjtvKz0zKW49KHRbb108PDE2JjE2NzExNjgwKSsodFtvKzFdPDw4JjY1MjgwKSsoMjU1JnRbbysyXSksaS5wdXNoKGgobikpO3JldHVybiBpLmpvaW4oIiIpfWlbIi0iLmNoYXJDb2RlQXQoMCldPTYyLGlbIl8iLmNoYXJDb2RlQXQoMCldPTYzO30sZnVuY3Rpb24odCxlKXtlLnJlYWQ9ZnVuY3Rpb24odCxlLHIsbixpKXt2YXIgbyxzLHU9OCppLW4tMSxhPSgxPDx1KS0xLGY9YT4+MSxoPS03LGw9cj9pLTE6MCxjPXI/LTE6MSxwPXRbZStsXTtmb3IobCs9YyxvPXAmKDE8PC1oKS0xLHA+Pj0taCxoKz11O2g+MDtvPTI1NipvK3RbZStsXSxsKz1jLGgtPTgpO2ZvcihzPW8mKDE8PC1oKS0xLG8+Pj0taCxoKz1uO2g+MDtzPTI1NipzK3RbZStsXSxsKz1jLGgtPTgpO2lmKDA9PT1vKW89MS1mO2Vsc2Uge2lmKG89PT1hKXJldHVybiBzP05hTjoxLzAqKHA/LTE6MSk7cys9TWF0aC5wb3coMixuKSxvLT1mO31yZXR1cm4gKHA/LTE6MSkqcypNYXRoLnBvdygyLG8tbil9LGUud3JpdGU9ZnVuY3Rpb24odCxlLHIsbixpLG8pe3ZhciBzLHUsYSxmPTgqby1pLTEsaD0oMTw8ZiktMSxsPWg+PjEsYz0yMz09PWk/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLHA9bj8wOm8tMSxnPW4/MTotMSxkPWU8MHx8MD09PWUmJjEvZTwwPzE6MDtmb3IoZT1NYXRoLmFicyhlKSxpc05hTihlKXx8ZT09PTEvMD8odT1pc05hTihlKT8xOjAscz1oKToocz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKSxlKihhPU1hdGgucG93KDIsLXMpKTwxJiYocy0tLGEqPTIpLChlKz1zK2w+PTE/Yy9hOmMqTWF0aC5wb3coMiwxLWwpKSphPj0yJiYocysrLGEvPTIpLHMrbD49aD8odT0wLHM9aCk6cytsPj0xPyh1PShlKmEtMSkqTWF0aC5wb3coMixpKSxzKz1sKToodT1lKk1hdGgucG93KDIsbC0xKSpNYXRoLnBvdygyLGkpLHM9MCkpO2k+PTg7dFtyK3BdPTI1NSZ1LHArPWcsdS89MjU2LGktPTgpO2ZvcihzPXM8PGl8dSxmKz1pO2Y+MDt0W3IrcF09MjU1JnMscCs9ZyxzLz0yNTYsZi09OCk7dFtyK3AtZ118PTEyOCpkO307fSxmdW5jdGlvbih0LGUpe3ZhciByPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm4gIltvYmplY3QgQXJyYXldIj09ci5jYWxsKHQpfTt9LGZ1bmN0aW9uKGUscil7ZS5leHBvcnRzPXQ7fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCxlKXtmb3IodmFyIHI9MCxuPXQubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBpPXRbbl07Ii4iPT09aT90LnNwbGljZShuLDEpOiIuLiI9PT1pPyh0LnNwbGljZShuLDEpLHIrKyk6ciYmKHQuc3BsaWNlKG4sMSksci0tKTt9aWYoZSlmb3IoO3ItLTtyKXQudW5zaGlmdCgiLi4iKTtyZXR1cm4gdH12YXIgbj0vXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC8saT1mdW5jdGlvbih0KXtyZXR1cm4gbi5leGVjKHQpLnNsaWNlKDEpfTtmdW5jdGlvbiBvKHQsZSl7aWYodC5maWx0ZXIpcmV0dXJuIHQuZmlsdGVyKGUpO2Zvcih2YXIgcj1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZSh0W25dLG4sdCkmJnIucHVzaCh0W25dKTtyZXR1cm4gcn1lLnJlc29sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9IiIsbj0hMSxpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIW47aS0tKXt2YXIgcz1pPj0wP2FyZ3VtZW50c1tpXTp0LmN3ZCgpO2lmKCJzdHJpbmciIT10eXBlb2Ygcyl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpO3MmJihlPXMrIi8iK2Usbj0iLyI9PT1zLmNoYXJBdCgwKSk7fXJldHVybiBlPXIobyhlLnNwbGl0KCIvIiksZnVuY3Rpb24odCl7cmV0dXJuICEhdH0pLCFuKS5qb2luKCIvIiksKG4/Ii8iOiIiKStlfHwiLiJ9LGUubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3ZhciBuPWUuaXNBYnNvbHV0ZSh0KSxpPSIvIj09PXModCwtMSk7cmV0dXJuICh0PXIobyh0LnNwbGl0KCIvIiksZnVuY3Rpb24odCl7cmV0dXJuICEhdH0pLCFuKS5qb2luKCIvIikpfHxufHwodD0iLiIpLHQmJmkmJih0Kz0iLyIpLChuPyIvIjoiIikrdH0sZS5pc0Fic29sdXRlPWZ1bmN0aW9uKHQpe3JldHVybiAiLyI9PT10LmNoYXJBdCgwKX0sZS5qb2luPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiBlLm5vcm1hbGl6ZShvKHQsZnVuY3Rpb24odCxlKXtpZigic3RyaW5nIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gdH0pLmpvaW4oIi8iKSl9LGUucmVsYXRpdmU9ZnVuY3Rpb24odCxyKXtmdW5jdGlvbiBuKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGgmJiIiPT09dFtlXTtlKyspO2Zvcih2YXIgcj10Lmxlbmd0aC0xO3I+PTAmJiIiPT09dFtyXTtyLS0pO3JldHVybiBlPnI/W106dC5zbGljZShlLHItZSsxKX10PWUucmVzb2x2ZSh0KS5zdWJzdHIoMSkscj1lLnJlc29sdmUocikuc3Vic3RyKDEpO2Zvcih2YXIgaT1uKHQuc3BsaXQoIi8iKSksbz1uKHIuc3BsaXQoIi8iKSkscz1NYXRoLm1pbihpLmxlbmd0aCxvLmxlbmd0aCksdT1zLGE9MDthPHM7YSsrKWlmKGlbYV0hPT1vW2FdKXt1PWE7YnJlYWt9dmFyIGY9W107Zm9yKGE9dTthPGkubGVuZ3RoO2ErKylmLnB1c2goIi4uIik7cmV0dXJuIChmPWYuY29uY2F0KG8uc2xpY2UodSkpKS5qb2luKCIvIil9LGUuc2VwPSIvIixlLmRlbGltaXRlcj0iOiIsZS5kaXJuYW1lPWZ1bmN0aW9uKHQpe3ZhciBlPWkodCkscj1lWzBdLG49ZVsxXTtyZXR1cm4gcnx8bj8obiYmKG49bi5zdWJzdHIoMCxuLmxlbmd0aC0xKSkscituKToiLiJ9LGUuYmFzZW5hbWU9ZnVuY3Rpb24odCxlKXt2YXIgcj1pKHQpWzJdO3JldHVybiBlJiZyLnN1YnN0cigtMSplLmxlbmd0aCk9PT1lJiYocj1yLnN1YnN0cigwLHIubGVuZ3RoLWUubGVuZ3RoKSkscn0sZS5leHRuYW1lPWZ1bmN0aW9uKHQpe3JldHVybiBpKHQpWzNdfTt2YXIgcz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LnN1YnN0cihlLHIpfTpmdW5jdGlvbih0LGUscil7cmV0dXJuIGU8MCYmKGU9dC5sZW5ndGgrZSksdC5zdWJzdHIoZSxyKX07fSkuY2FsbCh0aGlzLHIoMTQpKTt9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpPXQuZXhwb3J0cz17fTtmdW5jdGlvbiBvKCl7dGhyb3cgbmV3IEVycm9yKCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gcygpe3Rocm93IG5ldyBFcnJvcigiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkIil9ZnVuY3Rpb24gdSh0KXtpZihyPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dCh0LDApO2lmKChyPT09b3x8IXIpJiZzZXRUaW1lb3V0KXJldHVybiByPXNldFRpbWVvdXQsc2V0VGltZW91dCh0LDApO3RyeXtyZXR1cm4gcih0LDApfWNhdGNoKGUpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsdCwwKX1jYXRjaChlKXtyZXR1cm4gci5jYWxsKHRoaXMsdCwwKX19fSFmdW5jdGlvbigpe3RyeXtyPSJmdW5jdGlvbiI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6bzt9Y2F0Y2godCl7cj1vO310cnl7bj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpzO31jYXRjaCh0KXtuPXM7fX0oKTt2YXIgYSxmPVtdLGg9ITEsbD0tMTtmdW5jdGlvbiBjKCl7aCYmYSYmKGg9ITEsYS5sZW5ndGg/Zj1hLmNvbmNhdChmKTpsPS0xLGYubGVuZ3RoJiZwKCkpO31mdW5jdGlvbiBwKCl7aWYoIWgpe3ZhciB0PXUoYyk7aD0hMDtmb3IodmFyIGU9Zi5sZW5ndGg7ZTspe2ZvcihhPWYsZj1bXTsrK2w8ZTspYSYmYVtsXS5ydW4oKTtsPS0xLGU9Zi5sZW5ndGg7fWE9bnVsbCxoPSExLGZ1bmN0aW9uKHQpe2lmKG49PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dCh0KTtpZigobj09PXN8fCFuKSYmY2xlYXJUaW1lb3V0KXJldHVybiBuPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQodCk7dHJ5e24odCk7fWNhdGNoKGUpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsdCl9Y2F0Y2goZSl7cmV0dXJuIG4uY2FsbCh0aGlzLHQpfX19KHQpO319ZnVuY3Rpb24gZyh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lO31mdW5jdGlvbiBkKCl7fWkubmV4dFRpY2s9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTtmLnB1c2gobmV3IGcodCxlKSksMSE9PWYubGVuZ3RofHxofHx1KHApO30sZy5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KTt9LGkudGl0bGU9ImJyb3dzZXIiLGkuYnJvd3Nlcj0hMCxpLmVudj17fSxpLmFyZ3Y9W10saS52ZXJzaW9uPSIiLGkudmVyc2lvbnM9e30saS5vbj1kLGkuYWRkTGlzdGVuZXI9ZCxpLm9uY2U9ZCxpLm9mZj1kLGkucmVtb3ZlTGlzdGVuZXI9ZCxpLnJlbW92ZUFsbExpc3RlbmVycz1kLGkuZW1pdD1kLGkucHJlcGVuZExpc3RlbmVyPWQsaS5wcmVwZW5kT25jZUxpc3RlbmVyPWQsaS5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuIFtdfSxpLmJpbmRpbmc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCIpfSxpLmN3ZD1mdW5jdGlvbigpe3JldHVybiAiLyJ9LGkuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0saS51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfTt9XSl9KTsNCi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQpjb25zdCB1bnBhY2tCcmlkZ2UgPSBXb3JrZXJTY29wZS51bnBhY2tCcmlkZ2U7DQoNCmxldCB1bnBhY2s7DQoNCi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXVucGFjay0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQp2YXIgaW5pdHVucGFjayA9IGZ1bmN0aW9uKHdhc21CaW5hcnlGaWxlKSB7DQogIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBoYXMgYmVlbiBfY2FyZWZ1bGx5XyBtb2RpZmllZCBieSBoYW5kLg0KICAvLyBEdWUgdG8gV2ViUGFjayBlbWJlZGRpbmcgdGhpcyBzY3JpcHQgaW50byB0aGUgWmVhIGVuZ2luZQ0KICAvLyBidWlsZCwgY2VydGFpbiBmZWF0dXJlcyBicm9rZS4NCiAgLy8gVGhlcmUgd2FzIGNvZGUgdG8gaGFuZGxlIGxvYWRpbmcgaW4gYSBub2RlSlMgY29udGV4dCwgdGhhdCB0cmllZCB0byBpbXBvcnQoImZzIikNCiAgLy8gV2ViUGFjayBrZXB0cyB0cmlwcGluZyB1cCBvbiB0aGF0IGNvZGUgaW4gaXRzIHN0YXRpYyBhbmFseXNpcyBvZiB0aGUgY29kZSwgc28NCiAgLy8gSSBjYXJlZnVsbHkgcmVtb3ZlZCBpdC4NCiAgLy8gVGhlIGdsb2JhbCBzY29wZSBvZiB0aGUgc2NyaXB0IHNlZW1zIHRvIGJlIGRpZmZlcmVudCwgc28gdW5wYWNrQnJpZGdlIHdhcyBub3QgYXZhaWxhYmxlLg0KICAvLyBUaGUgdW5wYWNrQnJpZGdlIGNvZGUgYXNzaWducyB1bnBhY2tCcmlkZ2UgdG8gdGhlIHBhc3NlZCBpbiBzY29wZSwgd2hpY2ggaXMgJ3RoaXMnLCBidXQgdGhhdA0KICAvLyBzY29wZSBpc24ndCBhdmFpbGFibGUgaW5zaWRlIHRoaXMgJ3VucGFjaycgZnVuY3Rpb24uDQogIGNvbnN0IHVucGFjayA9IHt9Ow0KDQogIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgaXMgdGhlIFVSTCBvZiB0aGUgdW5wYWNrLndhc20gZmlsZSBpbiBvdXIgWmVhRW5naW5lIHByb2plY3Qgb24gb3VyDQogIC8vIHNlcnZlci4gSWRlYWxseSB3ZSBjb3VsZCB1c2UgYSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIFplYUVuZ2luZSBmaWxlLCBidXQNCiAgLy8gdGhhdCBpc24ndCBwb3NzaWJsZSB5ZXQuIChUT0RPOiBBc2sgTWF1cm8gYWJvdXQgdGhpcykNCiAgY3JlZGVudGlhbHMgPSAib21pdCI7DQogIC8vIHZhciB3YXNtQmluYXJ5RmlsZT0idW5wYWNrLndhc20iOw0KDQp2YXIgTW9kdWxlPXR5cGVvZiB1bnBhY2shPT0idW5kZWZpbmVkIj91bnBhY2s6e307dmFyIEV4dD11bnBhY2tCcmlkZ2UuRXh0O3ZhciBqc0FQST17b3BlbjooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQub3Blbi5hcHBseShFeHQuY3VycmVudCxhcmd1bWVudHMpfSksY2xvc2U6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LmNsb3NlLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KSxyZWFkOihmdW5jdGlvbigpe3JldHVybiBFeHQuY3VycmVudC5yZWFkLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KSx3cml0ZTooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQud3JpdGUuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLHRlbGw6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LnRlbGwuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLHNlZWs6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LnNlZWsuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLGNyZWF0ZTooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQuY3JlYXRlLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KX07dmFyIG1vZHVsZU92ZXJyaWRlcz17fTt2YXIga2V5O2ZvcihrZXkgaW4gTW9kdWxlKXtpZihNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSl7bW9kdWxlT3ZlcnJpZGVzW2tleV09TW9kdWxlW2tleV07fX1Nb2R1bGVbImFyZ3VtZW50cyJdPVtdO01vZHVsZVsidGhpc1Byb2dyYW0iXT0iLi90aGlzLnByb2dyYW0iO01vZHVsZVsicXVpdCJdPShmdW5jdGlvbihzdGF0dXMsdG9UaHJvdyl7dGhyb3cgdG9UaHJvd30pO01vZHVsZVsicHJlUnVuIl09W107TW9kdWxlWyJwb3N0UnVuIl09W107dmFyIEVOVklST05NRU5UX0lTX1dFQj1mYWxzZTt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19OT0RFPWZhbHNlO2lmKE1vZHVsZVsiRU5WSVJPTk1FTlQiXSl7aWYoTW9kdWxlWyJFTlZJUk9OTUVOVCJdPT09IldFQiIpe0VOVklST05NRU5UX0lTX1dFQj10cnVlO31lbHNlIGlmKE1vZHVsZVsiRU5WSVJPTk1FTlQiXT09PSJXT1JLRVIiKXtFTlZJUk9OTUVOVF9JU19XT1JLRVI9dHJ1ZTt9ZWxzZSBpZihNb2R1bGVbIkVOVklST05NRU5UIl09PT0iTk9ERSIpe0VOVklST05NRU5UX0lTX05PREU9dHJ1ZTt9ZWxzZSBpZihNb2R1bGVbIkVOVklST05NRU5UIl09PT0iU0hFTEwiKTtlbHNlIHt0aHJvdyBuZXcgRXJyb3IoIk1vZHVsZVsnRU5WSVJPTk1FTlQnXSB2YWx1ZSBpcyBub3QgdmFsaWQuIG11c3QgYmUgb25lIG9mOiBXRUJ8V09SS0VSfE5PREV8U0hFTEwuIil9fWVsc2Uge0VOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT09Im9iamVjdCI7RU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT09ImZ1bmN0aW9uIjtFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT09Im9iamVjdCImJnR5cGVvZiByZXF1aXJlPT09ImZ1bmN0aW9uIiYmIUVOVklST05NRU5UX0lTX1dFQiYmIUVOVklST05NRU5UX0lTX1dPUktFUjt9DQppZihFTlZJUk9OTUVOVF9JU19XRUJ8fEVOVklST05NRU5UX0lTX1dPUktFUil7TW9kdWxlWyJyZWFkIl09ZnVuY3Rpb24gc2hlbGxfcmVhZCh1cmwpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9O2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7TW9kdWxlWyJyZWFkQmluYXJ5Il09ZnVuY3Rpb24gcmVhZEJpbmFyeSh1cmwpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfTt9TW9kdWxlWyJyZWFkQXN5bmMiXT1mdW5jdGlvbiByZWFkQXN5bmModXJsLG9ubG9hZCxvbmVycm9yKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsdHJ1ZSk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5vbmxvYWQ9ZnVuY3Rpb24geGhyX29ubG9hZCgpe2lmKHhoci5zdGF0dXM9PTIwMHx8eGhyLnN0YXR1cz09MCYmeGhyLnJlc3BvbnNlKXtvbmxvYWQoeGhyLnJlc3BvbnNlKTtyZXR1cm59b25lcnJvcigpO307eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKTt9O01vZHVsZVsic2V0V2luZG93VGl0bGUiXT0oZnVuY3Rpb24odGl0bGUpe2RvY3VtZW50LnRpdGxlPXRpdGxlO30pO31Nb2R1bGVbInByaW50Il09dHlwZW9mIGNvbnNvbGUhPT0idW5kZWZpbmVkIj9jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpOnR5cGVvZiBwcmludCE9PSJ1bmRlZmluZWQiP3ByaW50Om51bGw7TW9kdWxlWyJwcmludEVyciJdPXR5cGVvZiBwcmludEVyciE9PSJ1bmRlZmluZWQiP3ByaW50RXJyOnR5cGVvZiBjb25zb2xlIT09InVuZGVmaW5lZCImJmNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpfHxNb2R1bGVbInByaW50Il07TW9kdWxlLnByaW50PU1vZHVsZVsicHJpbnQiXTtNb2R1bGUucHJpbnRFcnI9TW9kdWxlWyJwcmludEVyciJdO2ZvcihrZXkgaW4gbW9kdWxlT3ZlcnJpZGVzKXtpZihtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSl7TW9kdWxlW2tleV09bW9kdWxlT3ZlcnJpZGVzW2tleV07fX1tb2R1bGVPdmVycmlkZXM9dW5kZWZpbmVkO3ZhciBTVEFDS19BTElHTj0xNjtmdW5jdGlvbiBzdGF0aWNBbGxvYyhzaXplKXthc3NlcnQoIXN0YXRpY1NlYWxlZCk7dmFyIHJldD1TVEFUSUNUT1A7U1RBVElDVE9QPVNUQVRJQ1RPUCtzaXplKzE1Ji0xNjtyZXR1cm4gcmV0fWZ1bmN0aW9uIGR5bmFtaWNBbGxvYyhzaXplKXthc3NlcnQoRFlOQU1JQ1RPUF9QVFIpO3ZhciByZXQ9SEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXTt2YXIgZW5kPXJldCtzaXplKzE1Ji0xNjtIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdPWVuZDtpZihlbmQ+PVRPVEFMX01FTU9SWSl7dmFyIHN1Y2Nlc3M9ZW5sYXJnZU1lbW9yeSgpO2lmKCFzdWNjZXNzKXtIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdPXJldDtyZXR1cm4gMH19cmV0dXJuIHJldH1mdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLGZhY3Rvcil7aWYoIWZhY3RvcilmYWN0b3I9U1RBQ0tfQUxJR047dmFyIHJldD1zaXplPU1hdGguY2VpbChzaXplL2ZhY3RvcikqZmFjdG9yO3JldHVybiByZXR9ZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSl7c3dpdGNoKHR5cGUpe2Nhc2UiaTEiOmNhc2UiaTgiOnJldHVybiAxO2Nhc2UiaTE2IjpyZXR1cm4gMjtjYXNlImkzMiI6cmV0dXJuIDQ7Y2FzZSJpNjQiOnJldHVybiA4O2Nhc2UiZmxvYXQiOnJldHVybiA0O2Nhc2UiZG91YmxlIjpyZXR1cm4gODtkZWZhdWx0OntpZih0eXBlW3R5cGUubGVuZ3RoLTFdPT09IioiKXtyZXR1cm4gNH1lbHNlIGlmKHR5cGVbMF09PT0iaSIpe3ZhciBiaXRzPXBhcnNlSW50KHR5cGUuc3Vic3RyKDEpKTthc3NlcnQoYml0cyU4PT09MCk7cmV0dXJuIGJpdHMvOH1lbHNlIHtyZXR1cm4gMH19fX12YXIgZnVuY3Rpb25Qb2ludGVycz1uZXcgQXJyYXkoMCk7dmFyIEdMT0JBTF9CQVNFPTEwMjQ7dmFyIEFCT1JUPTA7ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbix0ZXh0KXtpZighY29uZGl0aW9uKXthYm9ydCgiQXNzZXJ0aW9uIGZhaWxlZDogIit0ZXh0KTt9fWZ1bmN0aW9uIHNldFZhbHVlKHB0cix2YWx1ZSx0eXBlLG5vU2FmZSl7dHlwZT10eXBlfHwiaTgiO2lmKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoLTEpPT09IioiKXR5cGU9ImkzMiI7c3dpdGNoKHR5cGUpe2Nhc2UiaTEiOkhFQVA4W3B0cj4+MF09dmFsdWU7YnJlYWs7Y2FzZSJpOCI6SEVBUDhbcHRyPj4wXT12YWx1ZTticmVhaztjYXNlImkxNiI6SEVBUDE2W3B0cj4+MV09dmFsdWU7YnJlYWs7Y2FzZSJpMzIiOkhFQVAzMltwdHI+PjJdPXZhbHVlO2JyZWFrO2Nhc2UiaTY0Ijp0ZW1wSTY0PVt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsK01hdGhfYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8oTWF0aF9taW4oK01hdGhfZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KXwwKT4+PjA6fn4rTWF0aF9jZWlsKCh0ZW1wRG91YmxlLSArKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltwdHI+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW3B0cis0Pj4yXT10ZW1wSTY0WzFdO2JyZWFrO2Nhc2UiZmxvYXQiOkhFQVBGMzJbcHRyPj4yXT12YWx1ZTticmVhaztjYXNlImRvdWJsZSI6SEVBUEY2NFtwdHI+PjNdPXZhbHVlO2JyZWFrO2RlZmF1bHQ6YWJvcnQoImludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICIrdHlwZSk7fX12YXIgQUxMT0NfTk9STUFMPTA7dmFyIEFMTE9DX1NUQVRJQz0yO3ZhciBBTExPQ19OT05FPTQ7ZnVuY3Rpb24gYWxsb2NhdGUoc2xhYix0eXBlcyxhbGxvY2F0b3IscHRyKXt2YXIgemVyb2luaXQsc2l6ZTtpZih0eXBlb2Ygc2xhYj09PSJudW1iZXIiKXt6ZXJvaW5pdD10cnVlO3NpemU9c2xhYjt9ZWxzZSB7emVyb2luaXQ9ZmFsc2U7c2l6ZT1zbGFiLmxlbmd0aDt9dmFyIHNpbmdsZVR5cGU9dHlwZW9mIHR5cGVzPT09InN0cmluZyI/dHlwZXM6bnVsbDt2YXIgcmV0O2lmKGFsbG9jYXRvcj09QUxMT0NfTk9ORSl7cmV0PXB0cjt9ZWxzZSB7cmV0PVt0eXBlb2YgX21hbGxvYz09PSJmdW5jdGlvbiI/X21hbGxvYzpzdGF0aWNBbGxvYyxzdGFja0FsbG9jLHN0YXRpY0FsbG9jLGR5bmFtaWNBbGxvY11bYWxsb2NhdG9yPT09dW5kZWZpbmVkP0FMTE9DX1NUQVRJQzphbGxvY2F0b3JdKE1hdGgubWF4KHNpemUsc2luZ2xlVHlwZT8xOnR5cGVzLmxlbmd0aCkpO31pZih6ZXJvaW5pdCl7dmFyIHN0b3A7cHRyPXJldDthc3NlcnQoKHJldCYzKT09MCk7c3RvcD1yZXQrKHNpemUmfjMpO2Zvcig7cHRyPHN0b3A7cHRyKz00KXtIRUFQMzJbcHRyPj4yXT0wO31zdG9wPXJldCtzaXplO3doaWxlKHB0cjxzdG9wKXtIRUFQOFtwdHIrKz4+MF09MDt9cmV0dXJuIHJldH1pZihzaW5nbGVUeXBlPT09Imk4Iil7aWYoc2xhYi5zdWJhcnJheXx8c2xhYi5zbGljZSl7SEVBUFU4LnNldChzbGFiLHJldCk7fWVsc2Uge0hFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoc2xhYikscmV0KTt9cmV0dXJuIHJldH12YXIgaT0wLHR5cGUsdHlwZVNpemUscHJldmlvdXNUeXBlO3doaWxlKGk8c2l6ZSl7dmFyIGN1cnI9c2xhYltpXTt0eXBlPXNpbmdsZVR5cGV8fHR5cGVzW2ldO2lmKHR5cGU9PT0wKXtpKys7Y29udGludWV9aWYodHlwZT09Imk2NCIpdHlwZT0iaTMyIjtzZXRWYWx1ZShyZXQraSxjdXJyLHR5cGUpO2lmKHByZXZpb3VzVHlwZSE9PXR5cGUpe3R5cGVTaXplPWdldE5hdGl2ZVR5cGVTaXplKHR5cGUpO3ByZXZpb3VzVHlwZT10eXBlO31pKz10eXBlU2l6ZTt9cmV0dXJuIHJldH1mdW5jdGlvbiBQb2ludGVyX3N0cmluZ2lmeShwdHIsbGVuZ3RoKXtpZihsZW5ndGg9PT0wfHwhcHRyKXJldHVybiAiIjt2YXIgaGFzVXRmPTA7dmFyIHQ7dmFyIGk9MDt3aGlsZSgxKXt0PUhFQVBVOFtwdHIraT4+MF07aGFzVXRmfD10O2lmKHQ9PTAmJiFsZW5ndGgpYnJlYWs7aSsrO2lmKGxlbmd0aCYmaT09bGVuZ3RoKWJyZWFrfWlmKCFsZW5ndGgpbGVuZ3RoPWk7dmFyIHJldD0iIjtpZihoYXNVdGY8MTI4KXt2YXIgTUFYX0NIVU5LPTEwMjQ7dmFyIGN1cnI7d2hpbGUobGVuZ3RoPjApe2N1cnI9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsSEVBUFU4LnN1YmFycmF5KHB0cixwdHIrTWF0aC5taW4obGVuZ3RoLE1BWF9DSFVOSykpKTtyZXQ9cmV0P3JldCtjdXJyOmN1cnI7cHRyKz1NQVhfQ0hVTks7bGVuZ3RoLT1NQVhfQ0hVTks7fXJldHVybiByZXR9cmV0dXJuIFVURjhUb1N0cmluZyhwdHIpfXZhciBVVEY4RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp1bmRlZmluZWQ7ZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSxpZHgpe3ZhciBlbmRQdHI9aWR4O3doaWxlKHU4QXJyYXlbZW5kUHRyXSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZ1OEFycmF5LnN1YmFycmF5JiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZSh1OEFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX1lbHNlIHt2YXIgdTAsdTEsdTIsdTMsdTQsdTU7dmFyIHN0cj0iIjt3aGlsZSgxKXt1MD11OEFycmF5W2lkeCsrXTtpZighdTApcmV0dXJuIHN0cjtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dTE9dThBcnJheVtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfXUyPXU4QXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyO31lbHNlIHt1Mz11OEFycmF5W2lkeCsrXSY2MztpZigodTAmMjQ4KT09MjQwKXt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8Nnx1Mzt9ZWxzZSB7dTQ9dThBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI1Mik9PTI0OCl7dTA9KHUwJjMpPDwyNHx1MTw8MTh8dTI8PDEyfHUzPDw2fHU0O31lbHNlIHt1NT11OEFycmF5W2lkeCsrXSY2Mzt1MD0odTAmMSk8PDMwfHUxPDwyNHx1Mjw8MTh8dTM8PDEyfHU0PDw2fHU1O319fWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO31lbHNlIHt2YXIgY2g9dTAtNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKTt9fX19ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cil7cmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIpfWZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0cixvdXRVOEFycmF5LG91dElkeCxtYXhCeXRlc1RvV3JpdGUpe2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXU9NjU1MzYrKCh1JjEwMjMpPDwxMCl8c3RyLmNoYXJDb2RlQXQoKytpKSYxMDIzO2lmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109dTt9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTE5Mnx1Pj42O291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzO31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTIyNHx1Pj4xMjtvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+NiY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dSY2Mzt9ZWxzZSBpZih1PD0yMDk3MTUxKXtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTI0MHx1Pj4xODtvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTImNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjYmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2UgaWYodTw9NjcxMDg4NjMpe2lmKG91dElkeCs0Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MjQ4fHU+PjI0O291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4xOCY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTImNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjYmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2Uge2lmKG91dElkeCs1Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MjUyfHU+PjMwO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4yNCY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTgmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjEyJjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj42JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzO319b3V0VThBcnJheVtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH1mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpe3JldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpfWZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpe3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpdT02NTUzNisoKHUmMTAyMyk8PDEwKXxzdHIuY2hhckNvZGVBdCgrK2kpJjEwMjM7aWYodTw9MTI3KXsrK2xlbjt9ZWxzZSBpZih1PD0yMDQ3KXtsZW4rPTI7fWVsc2UgaWYodTw9NjU1MzUpe2xlbis9Mzt9ZWxzZSBpZih1PD0yMDk3MTUxKXtsZW4rPTQ7fWVsc2UgaWYodTw9NjcxMDg4NjMpe2xlbis9NTt9ZWxzZSB7bGVuKz02O319cmV0dXJuIGxlbn12YXIgVVRGMTZEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9PSJ1bmRlZmluZWQiP25ldyBUZXh0RGVjb2RlcigidXRmLTE2bGUiKTp1bmRlZmluZWQ7ZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIpe3ZhciBpPTA7dmFyIHN0cj0iIjt3aGlsZSgxKXt2YXIgdXRmMzI9SEVBUDMyW3B0citpKjQ+PjJdO2lmKHV0ZjMyPT0wKXJldHVybiBzdHI7KytpO2lmKHV0ZjMyPj02NTUzNil7dmFyIGNoPXV0ZjMyLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7fX19ZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cil7dmFyIHNpemU9bGVuZ3RoQnl0ZXNVVEY4KHN0cikrMTt2YXIgcmV0PV9tYWxsb2Moc2l6ZSk7aWYocmV0KXN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQOCxyZXQsc2l6ZSk7cmV0dXJuIHJldH1mdW5jdGlvbiBkZW1hbmdsZShmdW5jKXtyZXR1cm4gZnVuY31mdW5jdGlvbiBkZW1hbmdsZUFsbCh0ZXh0KXt2YXIgcmVnZXg9L19fWltcd1xkX10rL2c7cmV0dXJuIHRleHQucmVwbGFjZShyZWdleCwoZnVuY3Rpb24oeCl7dmFyIHk9ZGVtYW5nbGUoeCk7cmV0dXJuIHg9PT15P3g6eCsiIFsiK3krIl0ifSkpfWZ1bmN0aW9uIGpzU3RhY2tUcmFjZSgpe3ZhciBlcnI9bmV3IEVycm9yO2lmKCFlcnIuc3RhY2spe3RyeXt0aHJvdyBuZXcgRXJyb3IoMCl9Y2F0Y2goZSl7ZXJyPWU7fWlmKCFlcnIuc3RhY2spe3JldHVybiAiKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSkifX1yZXR1cm4gZXJyLnN0YWNrLnRvU3RyaW5nKCl9ZnVuY3Rpb24gc3RhY2tUcmFjZSgpe3ZhciBqcz1qc1N0YWNrVHJhY2UoKTtpZihNb2R1bGVbImV4dHJhU3RhY2tUcmFjZSJdKWpzKz0iXG4iK01vZHVsZVsiZXh0cmFTdGFja1RyYWNlIl0oKTtyZXR1cm4gZGVtYW5nbGVBbGwoanMpfXZhciBXQVNNX1BBR0VfU0laRT02NTUzNjt2YXIgQVNNSlNfUEFHRV9TSVpFPTE2Nzc3MjE2O3ZhciBNSU5fVE9UQUxfTUVNT1JZPTE2Nzc3MjE2O2Z1bmN0aW9uIGFsaWduVXAoeCxtdWx0aXBsZSl7aWYoeCVtdWx0aXBsZT4wKXt4Kz1tdWx0aXBsZS14JW11bHRpcGxlO31yZXR1cm4geH12YXIgYnVmZmVyLEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyKGJ1Zil7TW9kdWxlWyJidWZmZXIiXT1idWZmZXI9YnVmO31mdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpe01vZHVsZVsiSEVBUDgiXT1IRUFQOD1uZXcgSW50OEFycmF5KGJ1ZmZlcik7TW9kdWxlWyJIRUFQMTYiXT1IRUFQMTY9bmV3IEludDE2QXJyYXkoYnVmZmVyKTtNb2R1bGVbIkhFQVAzMiJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShidWZmZXIpO01vZHVsZVsiSEVBUFU4Il09SEVBUFU4PW5ldyBVaW50OEFycmF5KGJ1ZmZlcik7TW9kdWxlWyJIRUFQVTE2Il09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYnVmZmVyKTtNb2R1bGVbIkhFQVBVMzIiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShidWZmZXIpO01vZHVsZVsiSEVBUEYzMiJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShidWZmZXIpO01vZHVsZVsiSEVBUEY2NCJdPUhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShidWZmZXIpO312YXIgU1RBVElDX0JBU0UsU1RBVElDVE9QLHN0YXRpY1NlYWxlZDt2YXIgU1RBQ0tfQkFTRSxTVEFDS1RPUCxTVEFDS19NQVg7dmFyIERZTkFNSUNfQkFTRSxEWU5BTUlDVE9QX1BUUjtTVEFUSUNfQkFTRT1TVEFUSUNUT1A9U1RBQ0tfQkFTRT1TVEFDS1RPUD1TVEFDS19NQVg9RFlOQU1JQ19CQVNFPURZTkFNSUNUT1BfUFRSPTA7c3RhdGljU2VhbGVkPWZhbHNlO2Z1bmN0aW9uIGFib3J0T25DYW5ub3RHcm93TWVtb3J5KCl7YWJvcnQoIkNhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICIrVE9UQUxfTUVNT1JZKyIsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICIpO31pZighTW9kdWxlWyJyZWFsbG9jQnVmZmVyIl0pTW9kdWxlWyJyZWFsbG9jQnVmZmVyIl09KGZ1bmN0aW9uKHNpemUpe3ZhciByZXQ7dHJ5e2lmKEFycmF5QnVmZmVyLnRyYW5zZmVyKXtyZXQ9QXJyYXlCdWZmZXIudHJhbnNmZXIoYnVmZmVyLHNpemUpO31lbHNlIHt2YXIgb2xkSEVBUDg9SEVBUDg7cmV0PW5ldyBBcnJheUJ1ZmZlcihzaXplKTt2YXIgdGVtcD1uZXcgSW50OEFycmF5KHJldCk7dGVtcC5zZXQob2xkSEVBUDgpO319Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfXZhciBzdWNjZXNzPV9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5KHJldCk7aWYoIXN1Y2Nlc3MpcmV0dXJuIGZhbHNlO3JldHVybiByZXR9KTtmdW5jdGlvbiBlbmxhcmdlTWVtb3J5KCl7dmFyIFBBR0VfTVVMVElQTEU9TW9kdWxlWyJ1c2luZ1dhc20iXT9XQVNNX1BBR0VfU0laRTpBU01KU19QQUdFX1NJWkU7dmFyIExJTUlUPTIxNDc0ODM2NDgtUEFHRV9NVUxUSVBMRTtpZihIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdPkxJTUlUKXtyZXR1cm4gZmFsc2V9dmFyIE9MRF9UT1RBTF9NRU1PUlk9VE9UQUxfTUVNT1JZO1RPVEFMX01FTU9SWT1NYXRoLm1heChUT1RBTF9NRU1PUlksTUlOX1RPVEFMX01FTU9SWSk7d2hpbGUoVE9UQUxfTUVNT1JZPEhFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml0pe2lmKFRPVEFMX01FTU9SWTw9NTM2ODcwOTEyKXtUT1RBTF9NRU1PUlk9YWxpZ25VcCgyKlRPVEFMX01FTU9SWSxQQUdFX01VTFRJUExFKTt9ZWxzZSB7VE9UQUxfTUVNT1JZPU1hdGgubWluKGFsaWduVXAoKDMqVE9UQUxfTUVNT1JZKzIxNDc0ODM2NDgpLzQsUEFHRV9NVUxUSVBMRSksTElNSVQpO319dmFyIHJlcGxhY2VtZW50PU1vZHVsZVsicmVhbGxvY0J1ZmZlciJdKFRPVEFMX01FTU9SWSk7aWYoIXJlcGxhY2VtZW50fHxyZXBsYWNlbWVudC5ieXRlTGVuZ3RoIT1UT1RBTF9NRU1PUlkpe1RPVEFMX01FTU9SWT1PTERfVE9UQUxfTUVNT1JZO3JldHVybiBmYWxzZX11cGRhdGVHbG9iYWxCdWZmZXIocmVwbGFjZW1lbnQpO3VwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7cmV0dXJuIHRydWV9dmFyIGJ5dGVMZW5ndGg7dHJ5e2J5dGVMZW5ndGg9RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFycmF5QnVmZmVyLnByb3RvdHlwZSwiYnl0ZUxlbmd0aCIpLmdldCk7Ynl0ZUxlbmd0aChuZXcgQXJyYXlCdWZmZXIoNCkpO31jYXRjaChlKXtieXRlTGVuZ3RoPShmdW5jdGlvbihidWZmZXIpe3JldHVybiBidWZmZXIuYnl0ZUxlbmd0aH0pO312YXIgVE9UQUxfU1RBQ0s9TW9kdWxlWyJUT1RBTF9TVEFDSyJdfHw1MjQyODgwO3ZhciBUT1RBTF9NRU1PUlk9TW9kdWxlWyJUT1RBTF9NRU1PUlkiXXx8MTY3NzcyMTY7aWYoVE9UQUxfTUVNT1JZPFRPVEFMX1NUQUNLKU1vZHVsZS5wcmludEVycigiVE9UQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICIrVE9UQUxfTUVNT1JZKyIhIChUT1RBTF9TVEFDSz0iK1RPVEFMX1NUQUNLKyIpIik7aWYoTW9kdWxlWyJidWZmZXIiXSl7YnVmZmVyPU1vZHVsZVsiYnVmZmVyIl07fWVsc2Uge2lmKHR5cGVvZiBXZWJBc3NlbWJseT09PSJvYmplY3QiJiZ0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5PT09ImZ1bmN0aW9uIil7TW9kdWxlWyJ3YXNtTWVtb3J5Il09bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7ImluaXRpYWwiOlRPVEFMX01FTU9SWS9XQVNNX1BBR0VfU0laRX0pO2J1ZmZlcj1Nb2R1bGVbIndhc21NZW1vcnkiXS5idWZmZXI7fWVsc2Uge2J1ZmZlcj1uZXcgQXJyYXlCdWZmZXIoVE9UQUxfTUVNT1JZKTt9TW9kdWxlWyJidWZmZXIiXT1idWZmZXI7fXVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7ZnVuY3Rpb24gZ2V0VG90YWxNZW1vcnkoKXtyZXR1cm4gVE9UQUxfTUVNT1JZfUhFQVAzMlswXT0xNjY4NTA5MDI5O0hFQVAxNlsxXT0yNTQ1OTtpZihIRUFQVThbMl0hPT0xMTV8fEhFQVBVOFszXSE9PTk5KXRocm93ICJSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hIjtmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3Mpe3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7dmFyIGNhbGxiYWNrPWNhbGxiYWNrcy5zaGlmdCgpO2lmKHR5cGVvZiBjYWxsYmFjaz09ImZ1bmN0aW9uIil7Y2FsbGJhY2soKTtjb250aW51ZX12YXIgZnVuYz1jYWxsYmFjay5mdW5jO2lmKHR5cGVvZiBmdW5jPT09Im51bWJlciIpe2lmKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZCl7TW9kdWxlWyJkeW5DYWxsX3YiXShmdW5jKTt9ZWxzZSB7TW9kdWxlWyJkeW5DYWxsX3ZpIl0oZnVuYyxjYWxsYmFjay5hcmcpO319ZWxzZSB7ZnVuYyhjYWxsYmFjay5hcmc9PT11bmRlZmluZWQ/bnVsbDpjYWxsYmFjay5hcmcpO319fXZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRNQUlOX189W107dmFyIF9fQVRFWElUX189W107dmFyIF9fQVRQT1NUUlVOX189W107dmFyIHJ1bnRpbWVJbml0aWFsaXplZD1mYWxzZTtmdW5jdGlvbiBwcmVSdW4oKXtpZihNb2R1bGVbInByZVJ1biJdKXtpZih0eXBlb2YgTW9kdWxlWyJwcmVSdW4iXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZVJ1biJdPVtNb2R1bGVbInByZVJ1biJdXTt3aGlsZShNb2R1bGVbInByZVJ1biJdLmxlbmd0aCl7YWRkT25QcmVSdW4oTW9kdWxlWyJwcmVSdW4iXS5zaGlmdCgpKTt9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7fWZ1bmN0aW9uIGVuc3VyZUluaXRSdW50aW1lKCl7aWYocnVudGltZUluaXRpYWxpemVkKXJldHVybjtydW50aW1lSW5pdGlhbGl6ZWQ9dHJ1ZTtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTt9ZnVuY3Rpb24gcHJlTWFpbigpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pO31mdW5jdGlvbiBleGl0UnVudGltZSgpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRFWElUX18pO31mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlWyJwb3N0UnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInBvc3RSdW4iXT09ImZ1bmN0aW9uIilNb2R1bGVbInBvc3RSdW4iXT1bTW9kdWxlWyJwb3N0UnVuIl1dO3doaWxlKE1vZHVsZVsicG9zdFJ1biJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVsicG9zdFJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7fWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTt9ZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixidWZmZXIsZG9udEFkZE51bGwpe2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0hFQVA4W2J1ZmZlcisrPj4wXT1zdHIuY2hhckNvZGVBdChpKTt9aWYoIWRvbnRBZGROdWxsKUhFQVA4W2J1ZmZlcj4+MF09MDt9dmFyIE1hdGhfYWJzPU1hdGguYWJzO3ZhciBNYXRoX2NlaWw9TWF0aC5jZWlsO3ZhciBNYXRoX2Zsb29yPU1hdGguZmxvb3I7dmFyIE1hdGhfbWluPU1hdGgubWluO3ZhciBydW5EZXBlbmRlbmNpZXM9MDt2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7ZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0pe01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdKHJ1bkRlcGVuZGVuY2llcyk7fX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXSl7TW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0ocnVuRGVwZW5kZW5jaWVzKTt9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihkZXBlbmRlbmNpZXNGdWxmaWxsZWQpe3ZhciBjYWxsYmFjaz1kZXBlbmRlbmNpZXNGdWxmaWxsZWQ7ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7Y2FsbGJhY2soKTt9fX1Nb2R1bGVbInByZWxvYWRlZEltYWdlcyJdPXt9O01vZHVsZVsicHJlbG9hZGVkQXVkaW9zIl09e307dmFyIGRhdGFVUklQcmVmaXg9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO2Z1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9maWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpOmZpbGVuYW1lLmluZGV4T2YoZGF0YVVSSVByZWZpeCk9PT0wfWZ1bmN0aW9uIGludGVncmF0ZVdhc21KUygpe3ZhciB3YXNtVGV4dEZpbGU9InVucGFjay53YXN0Ijt2YXIgYXNtanNDb2RlRmlsZT0idW5wYWNrLnRlbXAuYXNtLmpzIjtpZih0eXBlb2YgTW9kdWxlWyJsb2NhdGVGaWxlIl09PT0iZnVuY3Rpb24iKXtpZighaXNEYXRhVVJJKHdhc21UZXh0RmlsZSkpe3dhc21UZXh0RmlsZT1Nb2R1bGVbImxvY2F0ZUZpbGUiXSh3YXNtVGV4dEZpbGUpO31pZighaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSl7d2FzbUJpbmFyeUZpbGU9TW9kdWxlWyJsb2NhdGVGaWxlIl0od2FzbUJpbmFyeUZpbGUpO31pZighaXNEYXRhVVJJKGFzbWpzQ29kZUZpbGUpKXthc21qc0NvZGVGaWxlPU1vZHVsZVsibG9jYXRlRmlsZSJdKGFzbWpzQ29kZUZpbGUpO319dmFyIHdhc21QYWdlU2l6ZT02NCoxMDI0O3ZhciBpbmZvPXsiZ2xvYmFsIjpudWxsLCJlbnYiOm51bGwsImFzbTJ3YXNtIjp7ImY2NC1yZW0iOihmdW5jdGlvbih4LHkpe3JldHVybiB4JXl9KSwiZGVidWdnZXIiOihmdW5jdGlvbigpe2RlYnVnZ2VyfSl9LCJwYXJlbnQiOk1vZHVsZX07dmFyIGV4cG9ydHM9bnVsbDtmdW5jdGlvbiBtZXJnZU1lbW9yeShuZXdCdWZmZXIpe3ZhciBvbGRCdWZmZXI9TW9kdWxlWyJidWZmZXIiXTtpZihuZXdCdWZmZXIuYnl0ZUxlbmd0aDxvbGRCdWZmZXIuYnl0ZUxlbmd0aCl7TW9kdWxlWyJwcmludEVyciJdKCJ0aGUgbmV3IGJ1ZmZlciBpbiBtZXJnZU1lbW9yeSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIG9uZS4gaW4gbmF0aXZlIHdhc20sIHdlIHNob3VsZCBncm93IG1lbW9yeSBoZXJlIik7fXZhciBvbGRWaWV3PW5ldyBJbnQ4QXJyYXkob2xkQnVmZmVyKTt2YXIgbmV3Vmlldz1uZXcgSW50OEFycmF5KG5ld0J1ZmZlcik7bmV3Vmlldy5zZXQob2xkVmlldyk7dXBkYXRlR2xvYmFsQnVmZmVyKG5ld0J1ZmZlcik7dXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTt9ZnVuY3Rpb24gZml4SW1wb3J0cyhpbXBvcnRzKXtyZXR1cm4gaW1wb3J0c31mdW5jdGlvbiBnZXRCaW5hcnkoKXt0cnl7aWYoTW9kdWxlWyJ3YXNtQmluYXJ5Il0pe3JldHVybiBuZXcgVWludDhBcnJheShNb2R1bGVbIndhc21CaW5hcnkiXSl9aWYoTW9kdWxlWyJyZWFkQmluYXJ5Il0pe3JldHVybiBNb2R1bGVbInJlYWRCaW5hcnkiXSh3YXNtQmluYXJ5RmlsZSl9ZWxzZSB7dGhyb3cgIm9uIHRoZSB3ZWIsIHdlIG5lZWQgdGhlIHdhc20gYmluYXJ5IHRvIGJlIHByZWxvYWRlZCBhbmQgc2V0IG9uIE1vZHVsZVsnd2FzbUJpbmFyeSddLiBlbWNjLnB5IHdpbGwgZG8gdGhhdCBmb3IgeW91IHdoZW4gZ2VuZXJhdGluZyBIVE1MIChidXQgbm90IEpTKSJ9fWNhdGNoKGVycil7YWJvcnQoZXJyKTt9fWZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKXtpZighTW9kdWxlWyJ3YXNtQmluYXJ5Il0mJihFTlZJUk9OTUVOVF9JU19XRUJ8fEVOVklST05NRU5UX0lTX1dPUktFUikmJnR5cGVvZiBmZXRjaD09PSJmdW5jdGlvbiIpe3JldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSx7Y3JlZGVudGlhbHN9KS50aGVuKChmdW5jdGlvbihyZXNwb25zZSl7aWYoIXJlc3BvbnNlWyJvayJdKXt0aHJvdyAiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnIit3YXNtQmluYXJ5RmlsZSsiJyJ9cmV0dXJuIHJlc3BvbnNlWyJhcnJheUJ1ZmZlciJdKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIGdldEJpbmFyeSgpfSkpfXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3Jlc29sdmUoZ2V0QmluYXJ5KCkpO30pKX1mdW5jdGlvbiBkb05hdGl2ZVdhc20oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcil7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT09Im9iamVjdCIpe01vZHVsZVsicHJpbnRFcnIiXSgibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3JldHVybiBmYWxzZX1pZighKE1vZHVsZVsid2FzbU1lbW9yeSJdaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5NZW1vcnkpKXtNb2R1bGVbInByaW50RXJyIl0oIm5vIG5hdGl2ZSB3YXNtIE1lbW9yeSBpbiB1c2UiKTtyZXR1cm4gZmFsc2V9ZW52WyJtZW1vcnkiXT1Nb2R1bGVbIndhc21NZW1vcnkiXTtpbmZvWyJnbG9iYWwiXT17Ik5hTiI6TmFOLCJJbmZpbml0eSI6SW5maW5pdHl9O2luZm9bImdsb2JhbC5NYXRoIl09TWF0aDtpbmZvWyJlbnYiXT1lbnY7ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7ZXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO2lmKGV4cG9ydHMubWVtb3J5KW1lcmdlTWVtb3J5KGV4cG9ydHMubWVtb3J5KTtNb2R1bGVbImFzbSJdPWV4cG9ydHM7TW9kdWxlWyJ1c2luZ1dhc20iXT10cnVlO3JlbW92ZVJ1bkRlcGVuZGVuY3koKTt9YWRkUnVuRGVwZW5kZW5jeSgpO2lmKE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0pe3RyeXtyZXR1cm4gTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7TW9kdWxlWyJwcmludEVyciJdKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpO3JldHVybiBmYWxzZX19ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZShvdXRwdXQpe3JlY2VpdmVJbnN0YW5jZShvdXRwdXRbImluc3RhbmNlIl0sb3V0cHV0WyJtb2R1bGUiXSk7fWZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpe2dldEJpbmFyeVByb21pc2UoKS50aGVuKChmdW5jdGlvbihiaW5hcnkpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW5mbyl9KSkudGhlbihyZWNlaXZlcikuY2F0Y2goKGZ1bmN0aW9uKHJlYXNvbil7TW9kdWxlWyJwcmludEVyciJdKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK3JlYXNvbik7YWJvcnQocmVhc29uKTt9KSk7fWlmKCFNb2R1bGVbIndhc21CaW5hcnkiXSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT09ImZ1bmN0aW9uIiYmIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkmJnR5cGVvZiBmZXRjaD09PSJmdW5jdGlvbiIpe1dlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKHdhc21CaW5hcnlGaWxlLHtjcmVkZW50aWFsc30pLGluZm8pLnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSkuY2F0Y2goKGZ1bmN0aW9uKHJlYXNvbil7TW9kdWxlWyJwcmludEVyciJdKCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogIityZWFzb24pO01vZHVsZVsicHJpbnRFcnIiXSgiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24iKTtpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpO30pKTt9ZWxzZSB7aW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTt9cmV0dXJuIHt9fU1vZHVsZVsiYXNtUHJlbG9hZCJdPU1vZHVsZVsiYXNtIl07dmFyIHdhc21SZWFsbG9jQnVmZmVyPShmdW5jdGlvbihzaXplKXt2YXIgUEFHRV9NVUxUSVBMRT1Nb2R1bGVbInVzaW5nV2FzbSJdP1dBU01fUEFHRV9TSVpFOkFTTUpTX1BBR0VfU0laRTtzaXplPWFsaWduVXAoc2l6ZSxQQUdFX01VTFRJUExFKTt2YXIgb2xkPU1vZHVsZVsiYnVmZmVyIl07dmFyIG9sZFNpemU9b2xkLmJ5dGVMZW5ndGg7aWYoTW9kdWxlWyJ1c2luZ1dhc20iXSl7dHJ5e3ZhciByZXN1bHQ9TW9kdWxlWyJ3YXNtTWVtb3J5Il0uZ3Jvdygoc2l6ZS1vbGRTaXplKS93YXNtUGFnZVNpemUpO2lmKHJlc3VsdCE9PSgtMXwwKSl7cmV0dXJuIE1vZHVsZVsiYnVmZmVyIl09TW9kdWxlWyJ3YXNtTWVtb3J5Il0uYnVmZmVyfWVsc2Uge3JldHVybiBudWxsfX1jYXRjaChlKXtyZXR1cm4gbnVsbH19fSk7TW9kdWxlWyJyZWFsbG9jQnVmZmVyIl09KGZ1bmN0aW9uKHNpemUpe3tyZXR1cm4gd2FzbVJlYWxsb2NCdWZmZXIoc2l6ZSl9fSk7TW9kdWxlWyJhc20iXT0oZnVuY3Rpb24oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcil7ZW52PWZpeEltcG9ydHMoZW52KTtpZighZW52WyJ0YWJsZSJdKXt2YXIgVEFCTEVfU0laRT1Nb2R1bGVbIndhc21UYWJsZVNpemUiXTtpZihUQUJMRV9TSVpFPT09dW5kZWZpbmVkKVRBQkxFX1NJWkU9MTAyNDt2YXIgTUFYX1RBQkxFX1NJWkU9TW9kdWxlWyJ3YXNtTWF4VGFibGVTaXplIl07aWYodHlwZW9mIFdlYkFzc2VtYmx5PT09Im9iamVjdCImJnR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZT09PSJmdW5jdGlvbiIpe2lmKE1BWF9UQUJMRV9TSVpFIT09dW5kZWZpbmVkKXtlbnZbInRhYmxlIl09bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsiaW5pdGlhbCI6VEFCTEVfU0laRSwibWF4aW11bSI6TUFYX1RBQkxFX1NJWkUsImVsZW1lbnQiOiJhbnlmdW5jIn0pO31lbHNlIHtlbnZbInRhYmxlIl09bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsiaW5pdGlhbCI6VEFCTEVfU0laRSxlbGVtZW50OiJhbnlmdW5jIn0pO319ZWxzZSB7ZW52WyJ0YWJsZSJdPW5ldyBBcnJheShUQUJMRV9TSVpFKTt9TW9kdWxlWyJ3YXNtVGFibGUiXT1lbnZbInRhYmxlIl07fWlmKCFlbnZbIm1lbW9yeUJhc2UiXSl7ZW52WyJtZW1vcnlCYXNlIl09TW9kdWxlWyJTVEFUSUNfQkFTRSJdO31pZighZW52WyJ0YWJsZUJhc2UiXSl7ZW52WyJ0YWJsZUJhc2UiXT0wO312YXIgZXhwb3J0cztleHBvcnRzPWRvTmF0aXZlV2FzbShnbG9iYWwsZW52KTtpZighZXhwb3J0cylhYm9ydCgibm8gYmluYXJ5ZW4gbWV0aG9kIHN1Y2NlZWRlZC4gY29uc2lkZXIgZW5hYmxpbmcgbW9yZSBvcHRpb25zLCBsaWtlIGludGVycHJldGluZywgaWYgeW91IHdhbnQgdGhhdDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi93aWtpL1dlYkFzc2VtYmx5I2JpbmFyeWVuLW1ldGhvZHMiKTtyZXR1cm4gZXhwb3J0c30pO31pbnRlZ3JhdGVXYXNtSlMoKTtTVEFUSUNfQkFTRT1HTE9CQUxfQkFTRTtTVEFUSUNUT1A9U1RBVElDX0JBU0UrNjY5NjA7X19BVElOSVRfXy5wdXNoKHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwKCk7fSl9LHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9jcmNfY3BwKCk7fSl9LHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9icmlkZ2VfY3BwKCk7fSl9LHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9iaW5kX2NwcCgpO30pfSk7dmFyIFNUQVRJQ19CVU1QPTY2OTYwO01vZHVsZVsiU1RBVElDX0JBU0UiXT1TVEFUSUNfQkFTRTtNb2R1bGVbIlNUQVRJQ19CVU1QIl09U1RBVElDX0JVTVA7U1RBVElDVE9QKz0xNjtmdW5jdGlvbiBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uKHNpemUpe3JldHVybiBfbWFsbG9jKHNpemUpfXZhciBFWENFUFRJT05TPXtsYXN0OjAsY2F1Z2h0OltdLGluZm9zOnt9LGRlQWRqdXN0OihmdW5jdGlvbihhZGp1c3RlZCl7aWYoIWFkanVzdGVkfHxFWENFUFRJT05TLmluZm9zW2FkanVzdGVkXSlyZXR1cm4gYWRqdXN0ZWQ7Zm9yKHZhciBrZXkgaW4gRVhDRVBUSU9OUy5pbmZvcyl7dmFyIHB0cj0ra2V5O3ZhciBpbmZvPUVYQ0VQVElPTlMuaW5mb3NbcHRyXTtpZihpbmZvLmFkanVzdGVkPT09YWRqdXN0ZWQpe3JldHVybiBwdHJ9fXJldHVybiBhZGp1c3RlZH0pLGFkZFJlZjooZnVuY3Rpb24ocHRyKXtpZighcHRyKXJldHVybjt2YXIgaW5mbz1FWENFUFRJT05TLmluZm9zW3B0cl07aW5mby5yZWZjb3VudCsrO30pLGRlY1JlZjooZnVuY3Rpb24ocHRyKXtpZighcHRyKXJldHVybjt2YXIgaW5mbz1FWENFUFRJT05TLmluZm9zW3B0cl07YXNzZXJ0KGluZm8ucmVmY291bnQ+MCk7aW5mby5yZWZjb3VudC0tO2lmKGluZm8ucmVmY291bnQ9PT0wJiYhaW5mby5yZXRocm93bil7aWYoaW5mby5kZXN0cnVjdG9yKXtNb2R1bGVbImR5bkNhbGxfdmkiXShpbmZvLmRlc3RydWN0b3IscHRyKTt9ZGVsZXRlIEVYQ0VQVElPTlMuaW5mb3NbcHRyXTtfX19jeGFfZnJlZV9leGNlcHRpb24ocHRyKTt9fSksY2xlYXJSZWY6KGZ1bmN0aW9uKHB0cil7aWYoIXB0cilyZXR1cm47dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1twdHJdO2luZm8ucmVmY291bnQ9MDt9KX07ZnVuY3Rpb24gX19fY3hhX2JlZ2luX2NhdGNoKHB0cil7dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1twdHJdO2lmKGluZm8mJiFpbmZvLmNhdWdodCl7aW5mby5jYXVnaHQ9dHJ1ZTt9aWYoaW5mbylpbmZvLnJldGhyb3duPWZhbHNlO0VYQ0VQVElPTlMuY2F1Z2h0LnB1c2gocHRyKTtFWENFUFRJT05TLmFkZFJlZihFWENFUFRJT05TLmRlQWRqdXN0KHB0cikpO3JldHVybiBwdHJ9ZnVuY3Rpb24gX19fY3hhX2ZyZWVfZXhjZXB0aW9uKHB0cil7dHJ5e3JldHVybiBfZnJlZShwdHIpfWNhdGNoKGUpe319ZnVuY3Rpb24gX19fY3hhX2VuZF9jYXRjaCgpe01vZHVsZVsic2V0VGhyZXciXSgwKTt2YXIgcHRyPUVYQ0VQVElPTlMuY2F1Z2h0LnBvcCgpO2lmKHB0cil7RVhDRVBUSU9OUy5kZWNSZWYoRVhDRVBUSU9OUy5kZUFkanVzdChwdHIpKTtFWENFUFRJT05TLmxhc3Q9MDt9fWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzQoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX3Jlc3VtZUV4Y2VwdGlvbihwdHIpe2lmKCFFWENFUFRJT05TLmxhc3Qpe0VYQ0VQVElPTlMubGFzdD1wdHI7fXRocm93IHB0cn1mdW5jdGlvbiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaCgpe3ZhciB0aHJvd249RVhDRVBUSU9OUy5sYXN0O2lmKCF0aHJvd24pe3JldHVybiAoc2V0VGVtcFJldDAoMCksMCl8MH12YXIgaW5mbz1FWENFUFRJT05TLmluZm9zW3Rocm93bl07dmFyIHRocm93bnR5cGU9aW5mby50eXBlO2lmKCF0aHJvd250eXBlKXtyZXR1cm4gKHNldFRlbXBSZXQwKDApLHRocm93bil8MH12YXIgdHlwZUFycmF5PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7dmFyIHBvaW50ZXI9TW9kdWxlWyJfX19jeGFfaXNfcG9pbnRlcl90eXBlIl0odGhyb3dudHlwZSk7aWYoIV9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlcilfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaC5idWZmZXI9X21hbGxvYyg0KTtIRUFQMzJbX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyPj4yXT10aHJvd247dGhyb3duPV9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlcjtmb3IodmFyIGk9MDtpPHR5cGVBcnJheS5sZW5ndGg7aSsrKXtpZih0eXBlQXJyYXlbaV0mJk1vZHVsZVsiX19fY3hhX2Nhbl9jYXRjaCJdKHR5cGVBcnJheVtpXSx0aHJvd250eXBlLHRocm93bikpe3Rocm93bj1IRUFQMzJbdGhyb3duPj4yXTtpbmZvLmFkanVzdGVkPXRocm93bjtyZXR1cm4gKHNldFRlbXBSZXQwKHR5cGVBcnJheVtpXSksdGhyb3duKXwwfX10aHJvd249SEVBUDMyW3Rocm93bj4+Ml07cmV0dXJuIChzZXRUZW1wUmV0MCh0aHJvd250eXBlKSx0aHJvd24pfDB9ZnVuY3Rpb24gX19fY3hhX3Rocm93KHB0cix0eXBlLGRlc3RydWN0b3Ipe0VYQ0VQVElPTlMuaW5mb3NbcHRyXT17cHRyOnB0cixhZGp1c3RlZDpwdHIsdHlwZTp0eXBlLGRlc3RydWN0b3I6ZGVzdHJ1Y3RvcixyZWZjb3VudDowLGNhdWdodDpmYWxzZSxyZXRocm93bjpmYWxzZX07RVhDRVBUSU9OUy5sYXN0PXB0cjt0aHJvdyBwdHJ9ZnVuY3Rpb24gX19fbG9jaygpe312YXIgRVJSTk9fQ09ERVM9e0VQRVJNOjEsRU5PRU5UOjIsRVNSQ0g6MyxFSU5UUjo0LEVJTzo1LEVOWElPOjYsRTJCSUc6NyxFTk9FWEVDOjgsRUJBREY6OSxFQ0hJTEQ6MTAsRUFHQUlOOjExLEVXT1VMREJMT0NLOjExLEVOT01FTToxMixFQUNDRVM6MTMsRUZBVUxUOjE0LEVOT1RCTEs6MTUsRUJVU1k6MTYsRUVYSVNUOjE3LEVYREVWOjE4LEVOT0RFVjoxOSxFTk9URElSOjIwLEVJU0RJUjoyMSxFSU5WQUw6MjIsRU5GSUxFOjIzLEVNRklMRToyNCxFTk9UVFk6MjUsRVRYVEJTWToyNixFRkJJRzoyNyxFTk9TUEM6MjgsRVNQSVBFOjI5LEVST0ZTOjMwLEVNTElOSzozMSxFUElQRTozMixFRE9NOjMzLEVSQU5HRTozNCxFTk9NU0c6NDIsRUlEUk06NDMsRUNIUk5HOjQ0LEVMMk5TWU5DOjQ1LEVMM0hMVDo0NixFTDNSU1Q6NDcsRUxOUk5HOjQ4LEVVTkFUQ0g6NDksRU5PQ1NJOjUwLEVMMkhMVDo1MSxFREVBRExLOjM1LEVOT0xDSzozNyxFQkFERTo1MixFQkFEUjo1MyxFWEZVTEw6NTQsRU5PQU5POjU1LEVCQURSUUM6NTYsRUJBRFNMVDo1NyxFREVBRExPQ0s6MzUsRUJGT05UOjU5LEVOT1NUUjo2MCxFTk9EQVRBOjYxLEVUSU1FOjYyLEVOT1NSOjYzLEVOT05FVDo2NCxFTk9QS0c6NjUsRVJFTU9URTo2NixFTk9MSU5LOjY3LEVBRFY6NjgsRVNSTU5UOjY5LEVDT01NOjcwLEVQUk9UTzo3MSxFTVVMVElIT1A6NzIsRURPVERPVDo3MyxFQkFETVNHOjc0LEVOT1RVTklROjc2LEVCQURGRDo3NyxFUkVNQ0hHOjc4LEVMSUJBQ0M6NzksRUxJQkJBRDo4MCxFTElCU0NOOjgxLEVMSUJNQVg6ODIsRUxJQkVYRUM6ODMsRU5PU1lTOjM4LEVOT1RFTVBUWTozOSxFTkFNRVRPT0xPTkc6MzYsRUxPT1A6NDAsRU9QTk9UU1VQUDo5NSxFUEZOT1NVUFBPUlQ6OTYsRUNPTk5SRVNFVDoxMDQsRU5PQlVGUzoxMDUsRUFGTk9TVVBQT1JUOjk3LEVQUk9UT1RZUEU6OTEsRU5PVFNPQ0s6ODgsRU5PUFJPVE9PUFQ6OTIsRVNIVVRET1dOOjEwOCxFQ09OTlJFRlVTRUQ6MTExLEVBRERSSU5VU0U6OTgsRUNPTk5BQk9SVEVEOjEwMyxFTkVUVU5SRUFDSDoxMDEsRU5FVERPV046MTAwLEVUSU1FRE9VVDoxMTAsRUhPU1RET1dOOjExMixFSE9TVFVOUkVBQ0g6MTEzLEVJTlBST0dSRVNTOjExNSxFQUxSRUFEWToxMTQsRURFU1RBRERSUkVROjg5LEVNU0dTSVpFOjkwLEVQUk9UT05PU1VQUE9SVDo5MyxFU09DS1ROT1NVUFBPUlQ6OTQsRUFERFJOT1RBVkFJTDo5OSxFTkVUUkVTRVQ6MTAyLEVJU0NPTk46MTA2LEVOT1RDT05OOjEwNyxFVE9PTUFOWVJFRlM6MTA5LEVVU0VSUzo4NyxFRFFVT1Q6MTIyLEVTVEFMRToxMTYsRU5PVFNVUDo5NSxFTk9NRURJVU06MTIzLEVJTFNFUTo4NCxFT1ZFUkZMT1c6NzUsRUNBTkNFTEVEOjEyNSxFTk9UUkVDT1ZFUkFCTEU6MTMxLEVPV05FUkRFQUQ6MTMwLEVTVFJQSVBFOjg2fTtmdW5jdGlvbiBfX19zZXRFcnJObyh2YWx1ZSl7aWYoTW9kdWxlWyJfX19lcnJub19sb2NhdGlvbiJdKUhFQVAzMltNb2R1bGVbIl9fX2Vycm5vX2xvY2F0aW9uIl0oKT4+Ml09dmFsdWU7cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIF9fX21hcF9maWxlKHBhdGhuYW1lLHNpemUpe19fX3NldEVyck5vKEVSUk5PX0NPREVTLkVQRVJNKTtyZXR1cm4gLTF9dmFyIEVSUk5PX01FU1NBR0VTPXswOiJTdWNjZXNzIiwxOiJOb3Qgc3VwZXItdXNlciIsMjoiTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSIsMzoiTm8gc3VjaCBwcm9jZXNzIiw0OiJJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbCIsNToiSS9PIGVycm9yIiw2OiJObyBzdWNoIGRldmljZSBvciBhZGRyZXNzIiw3OiJBcmcgbGlzdCB0b28gbG9uZyIsODoiRXhlYyBmb3JtYXQgZXJyb3IiLDk6IkJhZCBmaWxlIG51bWJlciIsMTA6Ik5vIGNoaWxkcmVuIiwxMToiTm8gbW9yZSBwcm9jZXNzZXMiLDEyOiJOb3QgZW5vdWdoIGNvcmUiLDEzOiJQZXJtaXNzaW9uIGRlbmllZCIsMTQ6IkJhZCBhZGRyZXNzIiwxNToiQmxvY2sgZGV2aWNlIHJlcXVpcmVkIiwxNjoiTW91bnQgZGV2aWNlIGJ1c3kiLDE3OiJGaWxlIGV4aXN0cyIsMTg6IkNyb3NzLWRldmljZSBsaW5rIiwxOToiTm8gc3VjaCBkZXZpY2UiLDIwOiJOb3QgYSBkaXJlY3RvcnkiLDIxOiJJcyBhIGRpcmVjdG9yeSIsMjI6IkludmFsaWQgYXJndW1lbnQiLDIzOiJUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbSIsMjQ6IlRvbyBtYW55IG9wZW4gZmlsZXMiLDI1OiJOb3QgYSB0eXBld3JpdGVyIiwyNjoiVGV4dCBmaWxlIGJ1c3kiLDI3OiJGaWxlIHRvbyBsYXJnZSIsMjg6Ik5vIHNwYWNlIGxlZnQgb24gZGV2aWNlIiwyOToiSWxsZWdhbCBzZWVrIiwzMDoiUmVhZCBvbmx5IGZpbGUgc3lzdGVtIiwzMToiVG9vIG1hbnkgbGlua3MiLDMyOiJCcm9rZW4gcGlwZSIsMzM6Ik1hdGggYXJnIG91dCBvZiBkb21haW4gb2YgZnVuYyIsMzQ6Ik1hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlIiwzNToiRmlsZSBsb2NraW5nIGRlYWRsb2NrIGVycm9yIiwzNjoiRmlsZSBvciBwYXRoIG5hbWUgdG9vIGxvbmciLDM3OiJObyByZWNvcmQgbG9ja3MgYXZhaWxhYmxlIiwzODoiRnVuY3Rpb24gbm90IGltcGxlbWVudGVkIiwzOToiRGlyZWN0b3J5IG5vdCBlbXB0eSIsNDA6IlRvbyBtYW55IHN5bWJvbGljIGxpbmtzIiw0MjoiTm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUiLDQzOiJJZGVudGlmaWVyIHJlbW92ZWQiLDQ0OiJDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2UiLDQ1OiJMZXZlbCAyIG5vdCBzeW5jaHJvbml6ZWQiLDQ2OiJMZXZlbCAzIGhhbHRlZCIsNDc6IkxldmVsIDMgcmVzZXQiLDQ4OiJMaW5rIG51bWJlciBvdXQgb2YgcmFuZ2UiLDQ5OiJQcm90b2NvbCBkcml2ZXIgbm90IGF0dGFjaGVkIiw1MDoiTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGUiLDUxOiJMZXZlbCAyIGhhbHRlZCIsNTI6IkludmFsaWQgZXhjaGFuZ2UiLDUzOiJJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvciIsNTQ6IkV4Y2hhbmdlIGZ1bGwiLDU1OiJObyBhbm9kZSIsNTY6IkludmFsaWQgcmVxdWVzdCBjb2RlIiw1NzoiSW52YWxpZCBzbG90Iiw1OToiQmFkIGZvbnQgZmlsZSBmbXQiLDYwOiJEZXZpY2Ugbm90IGEgc3RyZWFtIiw2MToiTm8gZGF0YSAoZm9yIG5vIGRlbGF5IGlvKSIsNjI6IlRpbWVyIGV4cGlyZWQiLDYzOiJPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMiLDY0OiJNYWNoaW5lIGlzIG5vdCBvbiB0aGUgbmV0d29yayIsNjU6IlBhY2thZ2Ugbm90IGluc3RhbGxlZCIsNjY6IlRoZSBvYmplY3QgaXMgcmVtb3RlIiw2NzoiVGhlIGxpbmsgaGFzIGJlZW4gc2V2ZXJlZCIsNjg6IkFkdmVydGlzZSBlcnJvciIsNjk6IlNybW91bnQgZXJyb3IiLDcwOiJDb21tdW5pY2F0aW9uIGVycm9yIG9uIHNlbmQiLDcxOiJQcm90b2NvbCBlcnJvciIsNzI6Ik11bHRpaG9wIGF0dGVtcHRlZCIsNzM6IkNyb3NzIG1vdW50IHBvaW50IChub3QgcmVhbGx5IGVycm9yKSIsNzQ6IlRyeWluZyB0byByZWFkIHVucmVhZGFibGUgbWVzc2FnZSIsNzU6IlZhbHVlIHRvbyBsYXJnZSBmb3IgZGVmaW5lZCBkYXRhIHR5cGUiLDc2OiJHaXZlbiBsb2cuIG5hbWUgbm90IHVuaXF1ZSIsNzc6ImYuZC4gaW52YWxpZCBmb3IgdGhpcyBvcGVyYXRpb24iLDc4OiJSZW1vdGUgYWRkcmVzcyBjaGFuZ2VkIiw3OToiQ2FuICAgYWNjZXNzIGEgbmVlZGVkIHNoYXJlZCBsaWIiLDgwOiJBY2Nlc3NpbmcgYSBjb3JydXB0ZWQgc2hhcmVkIGxpYiIsODE6Ii5saWIgc2VjdGlvbiBpbiBhLm91dCBjb3JydXB0ZWQiLDgyOiJBdHRlbXB0aW5nIHRvIGxpbmsgaW4gdG9vIG1hbnkgbGlicyIsODM6IkF0dGVtcHRpbmcgdG8gZXhlYyBhIHNoYXJlZCBsaWJyYXJ5Iiw4NDoiSWxsZWdhbCBieXRlIHNlcXVlbmNlIiw4NjoiU3RyZWFtcyBwaXBlIGVycm9yIiw4NzoiVG9vIG1hbnkgdXNlcnMiLDg4OiJTb2NrZXQgb3BlcmF0aW9uIG9uIG5vbi1zb2NrZXQiLDg5OiJEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkIiw5MDoiTWVzc2FnZSB0b28gbG9uZyIsOTE6IlByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldCIsOTI6IlByb3RvY29sIG5vdCBhdmFpbGFibGUiLDkzOiJVbmtub3duIHByb3RvY29sIiw5NDoiU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZCIsOTU6Ik5vdCBzdXBwb3J0ZWQiLDk2OiJQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZCIsOTc6IkFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wgZmFtaWx5Iiw5ODoiQWRkcmVzcyBhbHJlYWR5IGluIHVzZSIsOTk6IkFkZHJlc3Mgbm90IGF2YWlsYWJsZSIsMTAwOiJOZXR3b3JrIGludGVyZmFjZSBpcyBub3QgY29uZmlndXJlZCIsMTAxOiJOZXR3b3JrIGlzIHVucmVhY2hhYmxlIiwxMDI6IkNvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yayIsMTAzOiJDb25uZWN0aW9uIGFib3J0ZWQiLDEwNDoiQ29ubmVjdGlvbiByZXNldCBieSBwZWVyIiwxMDU6Ik5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUiLDEwNjoiU29ja2V0IGlzIGFscmVhZHkgY29ubmVjdGVkIiwxMDc6IlNvY2tldCBpcyBub3QgY29ubmVjdGVkIiwxMDg6IkNhbid0IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duIiwxMDk6IlRvbyBtYW55IHJlZmVyZW5jZXMiLDExMDoiQ29ubmVjdGlvbiB0aW1lZCBvdXQiLDExMToiQ29ubmVjdGlvbiByZWZ1c2VkIiwxMTI6Ikhvc3QgaXMgZG93biIsMTEzOiJIb3N0IGlzIHVucmVhY2hhYmxlIiwxMTQ6IlNvY2tldCBhbHJlYWR5IGNvbm5lY3RlZCIsMTE1OiJDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MiLDExNjoiU3RhbGUgZmlsZSBoYW5kbGUiLDEyMjoiUXVvdGEgZXhjZWVkZWQiLDEyMzoiTm8gbWVkaXVtIChpbiB0YXBlIGRyaXZlKSIsMTI1OiJPcGVyYXRpb24gY2FuY2VsZWQiLDEzMDoiUHJldmlvdXMgb3duZXIgZGllZCIsMTMxOiJTdGF0ZSBub3QgcmVjb3ZlcmFibGUifTt2YXIgUEFUSD17c3BsaXRQYXRoOihmdW5jdGlvbihmaWxlbmFtZSl7dmFyIHNwbGl0UGF0aFJlPS9eKFwvP3wpKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteXC9dKz98KShcLlteLlwvXSp8KSkoPzpbXC9dKikkLztyZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSl9KSxub3JtYWxpemVBcnJheTooZnVuY3Rpb24ocGFydHMsYWxsb3dBYm92ZVJvb3Qpe3ZhciB1cD0wO2Zvcih2YXIgaT1wYXJ0cy5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIGxhc3Q9cGFydHNbaV07aWYobGFzdD09PSIuIil7cGFydHMuc3BsaWNlKGksMSk7fWVsc2UgaWYobGFzdD09PSIuLiIpe3BhcnRzLnNwbGljZShpLDEpO3VwKys7fWVsc2UgaWYodXApe3BhcnRzLnNwbGljZShpLDEpO3VwLS07fX1pZihhbGxvd0Fib3ZlUm9vdCl7Zm9yKDt1cDt1cC0tKXtwYXJ0cy51bnNoaWZ0KCIuLiIpO319cmV0dXJuIHBhcnRzfSksbm9ybWFsaXplOihmdW5jdGlvbihwYXRoKXt2YXIgaXNBYnNvbHV0ZT1wYXRoLmNoYXJBdCgwKT09PSIvIix0cmFpbGluZ1NsYXNoPXBhdGguc3Vic3RyKC0xKT09PSIvIjtwYXRoPVBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdCgiLyIpLmZpbHRlcigoZnVuY3Rpb24ocCl7cmV0dXJuICEhcH0pKSwhaXNBYnNvbHV0ZSkuam9pbigiLyIpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD0iLiI7fWlmKHBhdGgmJnRyYWlsaW5nU2xhc2gpe3BhdGgrPSIvIjt9cmV0dXJuIChpc0Fic29sdXRlPyIvIjoiIikrcGF0aH0pLGRpcm5hbWU6KGZ1bmN0aW9uKHBhdGgpe3ZhciByZXN1bHQ9UEFUSC5zcGxpdFBhdGgocGF0aCkscm9vdD1yZXN1bHRbMF0sZGlyPXJlc3VsdFsxXTtpZighcm9vdCYmIWRpcil7cmV0dXJuICIuIn1pZihkaXIpe2Rpcj1kaXIuc3Vic3RyKDAsZGlyLmxlbmd0aC0xKTt9cmV0dXJuIHJvb3QrZGlyfSksYmFzZW5hbWU6KGZ1bmN0aW9uKHBhdGgpe2lmKHBhdGg9PT0iLyIpcmV0dXJuICIvIjt2YXIgbGFzdFNsYXNoPXBhdGgubGFzdEluZGV4T2YoIi8iKTtpZihsYXN0U2xhc2g9PT0tMSlyZXR1cm4gcGF0aDtyZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoKzEpfSksZXh0bmFtZTooZnVuY3Rpb24ocGF0aCl7cmV0dXJuIFBBVEguc3BsaXRQYXRoKHBhdGgpWzNdfSksam9pbjooZnVuY3Rpb24oKXt2YXIgcGF0aHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiBQQVRILm5vcm1hbGl6ZShwYXRocy5qb2luKCIvIikpfSksam9pbjI6KGZ1bmN0aW9uKGwscil7cmV0dXJuIFBBVEgubm9ybWFsaXplKGwrIi8iK3IpfSkscmVzb2x2ZTooZnVuY3Rpb24oKXt2YXIgcmVzb2x2ZWRQYXRoPSIiLHJlc29sdmVkQWJzb2x1dGU9ZmFsc2U7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXJlc29sdmVkQWJzb2x1dGU7aS0tKXt2YXIgcGF0aD1pPj0wP2FyZ3VtZW50c1tpXTpGUy5jd2QoKTtpZih0eXBlb2YgcGF0aCE9PSJzdHJpbmciKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpfWVsc2UgaWYoIXBhdGgpe3JldHVybiAiIn1yZXNvbHZlZFBhdGg9cGF0aCsiLyIrcmVzb2x2ZWRQYXRoO3Jlc29sdmVkQWJzb2x1dGU9cGF0aC5jaGFyQXQoMCk9PT0iLyI7fXJlc29sdmVkUGF0aD1QQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdCgiLyIpLmZpbHRlcigoZnVuY3Rpb24ocCl7cmV0dXJuICEhcH0pKSwhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbigiLyIpO3JldHVybiAocmVzb2x2ZWRBYnNvbHV0ZT8iLyI6IiIpK3Jlc29sdmVkUGF0aHx8Ii4ifSkscmVsYXRpdmU6KGZ1bmN0aW9uKGZyb20sdG8pe2Zyb209UEFUSC5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTt0bz1QQVRILnJlc29sdmUodG8pLnN1YnN0cigxKTtmdW5jdGlvbiB0cmltKGFycil7dmFyIHN0YXJ0PTA7Zm9yKDtzdGFydDxhcnIubGVuZ3RoO3N0YXJ0Kyspe2lmKGFycltzdGFydF0hPT0iIilicmVha312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT0iIilicmVha31pZihzdGFydD5lbmQpcmV0dXJuIFtdO3JldHVybiBhcnIuc2xpY2Uoc3RhcnQsZW5kLXN0YXJ0KzEpfXZhciBmcm9tUGFydHM9dHJpbShmcm9tLnNwbGl0KCIvIikpO3ZhciB0b1BhcnRzPXRyaW0odG8uc3BsaXQoIi8iKSk7dmFyIGxlbmd0aD1NYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLHRvUGFydHMubGVuZ3RoKTt2YXIgc2FtZVBhcnRzTGVuZ3RoPWxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe2lmKGZyb21QYXJ0c1tpXSE9PXRvUGFydHNbaV0pe3NhbWVQYXJ0c0xlbmd0aD1pO2JyZWFrfX12YXIgb3V0cHV0UGFydHM9W107Zm9yKHZhciBpPXNhbWVQYXJ0c0xlbmd0aDtpPGZyb21QYXJ0cy5sZW5ndGg7aSsrKXtvdXRwdXRQYXJ0cy5wdXNoKCIuLiIpO31vdXRwdXRQYXJ0cz1vdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtyZXR1cm4gb3V0cHV0UGFydHMuam9pbigiLyIpfSl9O3ZhciBUVFk9e3R0eXM6W10saW5pdDooZnVuY3Rpb24oKXt9KSxzaHV0ZG93bjooZnVuY3Rpb24oKXt9KSxyZWdpc3RlcjooZnVuY3Rpb24oZGV2LG9wcyl7VFRZLnR0eXNbZGV2XT17aW5wdXQ6W10sb3V0cHV0OltdLG9wczpvcHN9O0ZTLnJlZ2lzdGVyRGV2aWNlKGRldixUVFkuc3RyZWFtX29wcyk7fSksc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgdHR5PVRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO2lmKCF0dHkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVil9c3RyZWFtLnR0eT10dHk7c3RyZWFtLnNlZWthYmxlPWZhbHNlO30pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpO30pLGZsdXNoOihmdW5jdGlvbihzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpO30pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe2lmKCFzdHJlYW0udHR5fHwhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOWElPKX12YXIgYnl0ZXNSZWFkPTA7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt2YXIgcmVzdWx0O3RyeXtyZXN1bHQ9c3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIoc3RyZWFtLnR0eSk7fWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9aWYocmVzdWx0PT09dW5kZWZpbmVkJiZieXRlc1JlYWQ9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQUdBSU4pfWlmKHJlc3VsdD09PW51bGx8fHJlc3VsdD09PXVuZGVmaW5lZClicmVhaztieXRlc1JlYWQrKztidWZmZXJbb2Zmc2V0K2ldPXJlc3VsdDt9aWYoYnl0ZXNSZWFkKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKTt9cmV0dXJuIGJ5dGVzUmVhZH0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtpZighc3RyZWFtLnR0eXx8IXN0cmVhbS50dHkub3BzLnB1dF9jaGFyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTlhJTyl9Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt0cnl7c3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSxidWZmZXJbb2Zmc2V0K2ldKTt9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX19aWYobGVuZ3RoKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKTt9cmV0dXJuIGl9KX0sZGVmYXVsdF90dHlfb3BzOntnZXRfY2hhcjooZnVuY3Rpb24odHR5KXtpZighdHR5LmlucHV0Lmxlbmd0aCl7dmFyIHJlc3VsdD1udWxsO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBCVUZTSVpFPTI1Njt2YXIgYnVmPW5ldyBCdWZmZXIoQlVGU0laRSk7dmFyIGJ5dGVzUmVhZD0wO3ZhciBpc1Bvc2l4UGxhdGZvcm09cHJvY2Vzcy5wbGF0Zm9ybSE9IndpbjMyIjt2YXIgZmQ9cHJvY2Vzcy5zdGRpbi5mZDtpZihpc1Bvc2l4UGxhdGZvcm0pe3ZhciB1c2luZ0RldmljZT1mYWxzZTt0cnl7ZmQ9ZnMub3BlblN5bmMoIi9kZXYvc3RkaW4iLCJyIik7dXNpbmdEZXZpY2U9dHJ1ZTt9Y2F0Y2goZSl7fX10cnl7Ynl0ZXNSZWFkPWZzLnJlYWRTeW5jKGZkLGJ1ZiwwLEJVRlNJWkUsbnVsbCk7fWNhdGNoKGUpe2lmKGUudG9TdHJpbmcoKS5pbmRleE9mKCJFT0YiKSE9LTEpYnl0ZXNSZWFkPTA7ZWxzZSB0aHJvdyBlfWlmKHVzaW5nRGV2aWNlKXtmcy5jbG9zZVN5bmMoZmQpO31pZihieXRlc1JlYWQ+MCl7cmVzdWx0PWJ1Zi5zbGljZSgwLGJ5dGVzUmVhZCkudG9TdHJpbmcoInV0Zi04Iik7fWVsc2Uge3Jlc3VsdD1udWxsO319ZWxzZSBpZih0eXBlb2Ygd2luZG93IT0idW5kZWZpbmVkIiYmdHlwZW9mIHdpbmRvdy5wcm9tcHQ9PSJmdW5jdGlvbiIpe3Jlc3VsdD13aW5kb3cucHJvbXB0KCJJbnB1dDogIik7aWYocmVzdWx0IT09bnVsbCl7cmVzdWx0Kz0iXG4iO319ZWxzZSBpZih0eXBlb2YgcmVhZGxpbmU9PSJmdW5jdGlvbiIpe3Jlc3VsdD1yZWFkbGluZSgpO2lmKHJlc3VsdCE9PW51bGwpe3Jlc3VsdCs9IlxuIjt9fWlmKCFyZXN1bHQpe3JldHVybiBudWxsfXR0eS5pbnB1dD1pbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LHRydWUpO31yZXR1cm4gdHR5LmlucHV0LnNoaWZ0KCl9KSxwdXRfY2hhcjooZnVuY3Rpb24odHR5LHZhbCl7aWYodmFsPT09bnVsbHx8dmFsPT09MTApe01vZHVsZVsicHJpbnQiXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LDApKTt0dHkub3V0cHV0PVtdO31lbHNlIHtpZih2YWwhPTApdHR5Lm91dHB1dC5wdXNoKHZhbCk7fX0pLGZsdXNoOihmdW5jdGlvbih0dHkpe2lmKHR0eS5vdXRwdXQmJnR0eS5vdXRwdXQubGVuZ3RoPjApe01vZHVsZVsicHJpbnQiXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LDApKTt0dHkub3V0cHV0PVtdO319KX0sZGVmYXVsdF90dHkxX29wczp7cHV0X2NoYXI6KGZ1bmN0aW9uKHR0eSx2YWwpe2lmKHZhbD09PW51bGx8fHZhbD09PTEwKXtNb2R1bGVbInByaW50RXJyIl0oVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXTt9ZWxzZSB7aWYodmFsIT0wKXR0eS5vdXRwdXQucHVzaCh2YWwpO319KSxmbHVzaDooZnVuY3Rpb24odHR5KXtpZih0dHkub3V0cHV0JiZ0dHkub3V0cHV0Lmxlbmd0aD4wKXtNb2R1bGVbInByaW50RXJyIl0oVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXTt9fSl9fTt2YXIgTUVNRlM9e29wc190YWJsZTpudWxsLG1vdW50OihmdW5jdGlvbihtb3VudCl7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwiLyIsMTYzODR8NTExLDApfSksY3JlYXRlTm9kZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxkZXYpe2lmKEZTLmlzQmxrZGV2KG1vZGUpfHxGUy5pc0ZJRk8obW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1pZighTUVNRlMub3BzX3RhYmxlKXtNRU1GUy5vcHNfdGFibGU9e2Rpcjp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cixsb29rdXA6TUVNRlMubm9kZV9vcHMubG9va3VwLG1rbm9kOk1FTUZTLm5vZGVfb3BzLm1rbm9kLHJlbmFtZTpNRU1GUy5ub2RlX29wcy5yZW5hbWUsdW5saW5rOk1FTUZTLm5vZGVfb3BzLnVubGluayxybWRpcjpNRU1GUy5ub2RlX29wcy5ybWRpcixyZWFkZGlyOk1FTUZTLm5vZGVfb3BzLnJlYWRkaXIsc3ltbGluazpNRU1GUy5ub2RlX29wcy5zeW1saW5rfSxzdHJlYW06e2xsc2VlazpNRU1GUy5zdHJlYW1fb3BzLmxsc2Vla319LGZpbGU6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTp7bGxzZWVrOk1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLHJlYWQ6TUVNRlMuc3RyZWFtX29wcy5yZWFkLHdyaXRlOk1FTUZTLnN0cmVhbV9vcHMud3JpdGUsYWxsb2NhdGU6TUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxtbWFwOk1FTUZTLnN0cmVhbV9vcHMubW1hcCxtc3luYzpNRU1GUy5zdHJlYW1fb3BzLm1zeW5jfX0sbGluazp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cixyZWFkbGluazpNRU1GUy5ub2RlX29wcy5yZWFkbGlua30sc3RyZWFtOnt9fSxjaHJkZXY6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTpGUy5jaHJkZXZfc3RyZWFtX29wc319O312YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUsZGV2KTtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5kaXIubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07bm9kZS5jb250ZW50cz17fTt9ZWxzZSBpZihGUy5pc0ZpbGUobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07bm9kZS51c2VkQnl0ZXM9MDtub2RlLmNvbnRlbnRzPW51bGw7fWVsc2UgaWYoRlMuaXNMaW5rKG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO31lbHNlIGlmKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTt9bm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKTtpZihwYXJlbnQpe3BhcmVudC5jb250ZW50c1tuYW1lXT1ub2RlO31yZXR1cm4gbm9kZX0pLGdldEZpbGVEYXRhQXNSZWd1bGFyQXJyYXk6KGZ1bmN0aW9uKG5vZGUpe2lmKG5vZGUuY29udGVudHMmJm5vZGUuY29udGVudHMuc3ViYXJyYXkpe3ZhciBhcnI9W107Zm9yKHZhciBpPTA7aTxub2RlLnVzZWRCeXRlczsrK2kpYXJyLnB1c2gobm9kZS5jb250ZW50c1tpXSk7cmV0dXJuIGFycn1yZXR1cm4gbm9kZS5jb250ZW50c30pLGdldEZpbGVEYXRhQXNUeXBlZEFycmF5OihmdW5jdGlvbihub2RlKXtpZighbm9kZS5jb250ZW50cylyZXR1cm4gbmV3IFVpbnQ4QXJyYXk7aWYobm9kZS5jb250ZW50cy5zdWJhcnJheSlyZXR1cm4gbm9kZS5jb250ZW50cy5zdWJhcnJheSgwLG5vZGUudXNlZEJ5dGVzKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyl9KSxleHBhbmRGaWxlU3RvcmFnZTooZnVuY3Rpb24obm9kZSxuZXdDYXBhY2l0eSl7aWYobm9kZS5jb250ZW50cyYmbm9kZS5jb250ZW50cy5zdWJhcnJheSYmbmV3Q2FwYWNpdHk+bm9kZS5jb250ZW50cy5sZW5ndGgpe25vZGUuY29udGVudHM9TUVNRlMuZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheShub2RlKTtub2RlLnVzZWRCeXRlcz1ub2RlLmNvbnRlbnRzLmxlbmd0aDt9aWYoIW5vZGUuY29udGVudHN8fG5vZGUuY29udGVudHMuc3ViYXJyYXkpe3ZhciBwcmV2Q2FwYWNpdHk9bm9kZS5jb250ZW50cz9ub2RlLmNvbnRlbnRzLmxlbmd0aDowO2lmKHByZXZDYXBhY2l0eT49bmV3Q2FwYWNpdHkpcmV0dXJuO3ZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVg9MTAyNCoxMDI0O25ld0NhcGFjaXR5PU1hdGgubWF4KG5ld0NhcGFjaXR5LHByZXZDYXBhY2l0eSoocHJldkNhcGFjaXR5PENBUEFDSVRZX0RPVUJMSU5HX01BWD8yOjEuMTI1KXwwKTtpZihwcmV2Q2FwYWNpdHkhPTApbmV3Q2FwYWNpdHk9TWF0aC5tYXgobmV3Q2FwYWNpdHksMjU2KTt2YXIgb2xkQ29udGVudHM9bm9kZS5jb250ZW50cztub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTtpZihub2RlLnVzZWRCeXRlcz4wKW5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsbm9kZS51c2VkQnl0ZXMpLDApO3JldHVybn1pZighbm9kZS5jb250ZW50cyYmbmV3Q2FwYWNpdHk+MClub2RlLmNvbnRlbnRzPVtdO3doaWxlKG5vZGUuY29udGVudHMubGVuZ3RoPG5ld0NhcGFjaXR5KW5vZGUuY29udGVudHMucHVzaCgwKTt9KSxyZXNpemVGaWxlU3RvcmFnZTooZnVuY3Rpb24obm9kZSxuZXdTaXplKXtpZihub2RlLnVzZWRCeXRlcz09bmV3U2l6ZSlyZXR1cm47aWYobmV3U2l6ZT09MCl7bm9kZS5jb250ZW50cz1udWxsO25vZGUudXNlZEJ5dGVzPTA7cmV0dXJufWlmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgb2xkQ29udGVudHM9bm9kZS5jb250ZW50cztub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKSk7aWYob2xkQ29udGVudHMpe25vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsTWF0aC5taW4obmV3U2l6ZSxub2RlLnVzZWRCeXRlcykpKTt9bm9kZS51c2VkQnl0ZXM9bmV3U2l6ZTtyZXR1cm59aWYoIW5vZGUuY29udGVudHMpbm9kZS5jb250ZW50cz1bXTtpZihub2RlLmNvbnRlbnRzLmxlbmd0aD5uZXdTaXplKW5vZGUuY29udGVudHMubGVuZ3RoPW5ld1NpemU7ZWxzZSB3aGlsZShub2RlLmNvbnRlbnRzLmxlbmd0aDxuZXdTaXplKW5vZGUuY29udGVudHMucHVzaCgwKTtub2RlLnVzZWRCeXRlcz1uZXdTaXplO30pLG5vZGVfb3BzOntnZXRhdHRyOihmdW5jdGlvbihub2RlKXt2YXIgYXR0cj17fTthdHRyLmRldj1GUy5pc0NocmRldihub2RlLm1vZGUpP25vZGUuaWQ6MTthdHRyLmlubz1ub2RlLmlkO2F0dHIubW9kZT1ub2RlLm1vZGU7YXR0ci5ubGluaz0xO2F0dHIudWlkPTA7YXR0ci5naWQ9MDthdHRyLnJkZXY9bm9kZS5yZGV2O2lmKEZTLmlzRGlyKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT00MDk2O31lbHNlIGlmKEZTLmlzRmlsZShub2RlLm1vZGUpKXthdHRyLnNpemU9bm9kZS51c2VkQnl0ZXM7fWVsc2UgaWYoRlMuaXNMaW5rKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT1ub2RlLmxpbmsubGVuZ3RoO31lbHNlIHthdHRyLnNpemU9MDt9YXR0ci5hdGltZT1uZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7YXR0ci5tdGltZT1uZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7YXR0ci5jdGltZT1uZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7YXR0ci5ibGtzaXplPTQwOTY7YXR0ci5ibG9ja3M9TWF0aC5jZWlsKGF0dHIuc2l6ZS9hdHRyLmJsa3NpemUpO3JldHVybiBhdHRyfSksc2V0YXR0cjooZnVuY3Rpb24obm9kZSxhdHRyKXtpZihhdHRyLm1vZGUhPT11bmRlZmluZWQpe25vZGUubW9kZT1hdHRyLm1vZGU7fWlmKGF0dHIudGltZXN0YW1wIT09dW5kZWZpbmVkKXtub2RlLnRpbWVzdGFtcD1hdHRyLnRpbWVzdGFtcDt9aWYoYXR0ci5zaXplIT09dW5kZWZpbmVkKXtNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLGF0dHIuc2l6ZSk7fX0pLGxvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3Rocm93IEZTLmdlbmVyaWNFcnJvcnNbRVJSTk9fQ09ERVMuRU5PRU5UXX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpfSkscmVuYW1lOihmdW5jdGlvbihvbGRfbm9kZSxuZXdfZGlyLG5ld19uYW1lKXtpZihGUy5pc0RpcihvbGRfbm9kZS5tb2RlKSl7dmFyIG5ld19ub2RlO3RyeXtuZXdfbm9kZT1GUy5sb29rdXBOb2RlKG5ld19kaXIsbmV3X25hbWUpO31jYXRjaChlKXt9aWYobmV3X25vZGUpe2Zvcih2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cyl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVEVNUFRZKX19fWRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07b2xkX25vZGUubmFtZT1uZXdfbmFtZTtuZXdfZGlyLmNvbnRlbnRzW25ld19uYW1lXT1vbGRfbm9kZTtvbGRfbm9kZS5wYXJlbnQ9bmV3X2Rpcjt9KSx1bmxpbms6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXtkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO30pLHJtZGlyOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIG5vZGU9RlMubG9va3VwTm9kZShwYXJlbnQsbmFtZSk7Zm9yKHZhciBpIGluIG5vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSl9ZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTt9KSxyZWFkZGlyOihmdW5jdGlvbihub2RlKXt2YXIgZW50cmllcz1bIi4iLCIuLiJdO2Zvcih2YXIga2V5IGluIG5vZGUuY29udGVudHMpe2lmKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpe2NvbnRpbnVlfWVudHJpZXMucHVzaChrZXkpO31yZXR1cm4gZW50cmllc30pLHN5bWxpbms6KGZ1bmN0aW9uKHBhcmVudCxuZXduYW1lLG9sZHBhdGgpe3ZhciBub2RlPU1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LG5ld25hbWUsNTExfDQwOTYwLDApO25vZGUubGluaz1vbGRwYXRoO3JldHVybiBub2RlfSkscmVhZGxpbms6KGZ1bmN0aW9uKG5vZGUpe2lmKCFGUy5pc0xpbmsobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1yZXR1cm4gbm9kZS5saW5rfSl9LHN0cmVhbV9vcHM6e3JlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKHBvc2l0aW9uPj1zdHJlYW0ubm9kZS51c2VkQnl0ZXMpcmV0dXJuIDA7dmFyIHNpemU9TWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzLXBvc2l0aW9uLGxlbmd0aCk7YXNzZXJ0KHNpemU+PTApO2lmKHNpemU+OCYmY29udGVudHMuc3ViYXJyYXkpe2J1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24scG9zaXRpb24rc2l6ZSksb2Zmc2V0KTt9ZWxzZSB7Zm9yKHZhciBpPTA7aTxzaXplO2krKylidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzW3Bvc2l0aW9uK2ldO31yZXR1cm4gc2l6ZX0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKXtpZighbGVuZ3RoKXJldHVybiAwO3ZhciBub2RlPXN0cmVhbS5ub2RlO25vZGUudGltZXN0YW1wPURhdGUubm93KCk7aWYoYnVmZmVyLnN1YmFycmF5JiYoIW5vZGUuY29udGVudHN8fG5vZGUuY29udGVudHMuc3ViYXJyYXkpKXtpZihjYW5Pd24pe25vZGUuY29udGVudHM9YnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKTtub2RlLnVzZWRCeXRlcz1sZW5ndGg7cmV0dXJuIGxlbmd0aH1lbHNlIGlmKG5vZGUudXNlZEJ5dGVzPT09MCYmcG9zaXRpb249PT0wKXtub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsb2Zmc2V0K2xlbmd0aCkpO25vZGUudXNlZEJ5dGVzPWxlbmd0aDtyZXR1cm4gbGVuZ3RofWVsc2UgaWYocG9zaXRpb24rbGVuZ3RoPD1ub2RlLnVzZWRCeXRlcyl7bm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbik7cmV0dXJuIGxlbmd0aH19TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSxwb3NpdGlvbitsZW5ndGgpO2lmKG5vZGUuY29udGVudHMuc3ViYXJyYXkmJmJ1ZmZlci5zdWJhcnJheSlub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LG9mZnNldCtsZW5ndGgpLHBvc2l0aW9uKTtlbHNlIHtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe25vZGUuY29udGVudHNbcG9zaXRpb24raV09YnVmZmVyW29mZnNldCtpXTt9fW5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KG5vZGUudXNlZEJ5dGVzLHBvc2l0aW9uK2xlbmd0aCk7cmV0dXJuIGxlbmd0aH0pLGxsc2VlazooZnVuY3Rpb24oc3RyZWFtLG9mZnNldCx3aGVuY2Upe3ZhciBwb3NpdGlvbj1vZmZzZXQ7aWYod2hlbmNlPT09MSl7cG9zaXRpb24rPXN0cmVhbS5wb3NpdGlvbjt9ZWxzZSBpZih3aGVuY2U9PT0yKXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3Bvc2l0aW9uKz1zdHJlYW0ubm9kZS51c2VkQnl0ZXM7fX1pZihwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfXJldHVybiBwb3NpdGlvbn0pLGFsbG9jYXRlOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsb2Zmc2V0K2xlbmd0aCk7c3RyZWFtLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxvZmZzZXQrbGVuZ3RoKTt9KSxtbWFwOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl7aWYoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKX12YXIgcHRyO3ZhciBhbGxvY2F0ZWQ7dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKCEoZmxhZ3MmMikmJihjb250ZW50cy5idWZmZXI9PT1idWZmZXJ8fGNvbnRlbnRzLmJ1ZmZlcj09PWJ1ZmZlci5idWZmZXIpKXthbGxvY2F0ZWQ9ZmFsc2U7cHRyPWNvbnRlbnRzLmJ5dGVPZmZzZXQ7fWVsc2Uge2lmKHBvc2l0aW9uPjB8fHBvc2l0aW9uK2xlbmd0aDxzdHJlYW0ubm9kZS51c2VkQnl0ZXMpe2lmKGNvbnRlbnRzLnN1YmFycmF5KXtjb250ZW50cz1jb250ZW50cy5zdWJhcnJheShwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpO31lbHNlIHtjb250ZW50cz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cyxwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpO319YWxsb2NhdGVkPXRydWU7cHRyPV9tYWxsb2MobGVuZ3RoKTtpZighcHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9NRU0pfWJ1ZmZlci5zZXQoY29udGVudHMscHRyKTt9cmV0dXJuIHtwdHI6cHRyLGFsbG9jYXRlZDphbGxvY2F0ZWR9fSksbXN5bmM6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxtbWFwRmxhZ3Mpe2lmKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVil9aWYobW1hcEZsYWdzJjIpe3JldHVybiAwfXZhciBieXRlc1dyaXR0ZW49TUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sYnVmZmVyLDAsbGVuZ3RoLG9mZnNldCxmYWxzZSk7cmV0dXJuIDB9KX19O3ZhciBJREJGUz17ZGJzOnt9LGluZGV4ZWREQjooZnVuY3Rpb24oKXtpZih0eXBlb2YgaW5kZXhlZERCIT09InVuZGVmaW5lZCIpcmV0dXJuIGluZGV4ZWREQjt2YXIgcmV0PW51bGw7aWYodHlwZW9mIHdpbmRvdz09PSJvYmplY3QiKXJldD13aW5kb3cuaW5kZXhlZERCfHx3aW5kb3cubW96SW5kZXhlZERCfHx3aW5kb3cud2Via2l0SW5kZXhlZERCfHx3aW5kb3cubXNJbmRleGVkREI7YXNzZXJ0KHJldCwiSURCRlMgdXNlZCwgYnV0IGluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIik7cmV0dXJuIHJldH0pLERCX1ZFUlNJT046MjEsREJfU1RPUkVfTkFNRToiRklMRV9EQVRBIixtb3VudDooZnVuY3Rpb24obW91bnQpe3JldHVybiBNRU1GUy5tb3VudC5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxzeW5jZnM6KGZ1bmN0aW9uKG1vdW50LHBvcHVsYXRlLGNhbGxiYWNrKXtJREJGUy5nZXRMb2NhbFNldChtb3VudCwoZnVuY3Rpb24oZXJyLGxvY2FsKXtpZihlcnIpcmV0dXJuIGNhbGxiYWNrKGVycik7SURCRlMuZ2V0UmVtb3RlU2V0KG1vdW50LChmdW5jdGlvbihlcnIscmVtb3RlKXtpZihlcnIpcmV0dXJuIGNhbGxiYWNrKGVycik7dmFyIHNyYz1wb3B1bGF0ZT9yZW1vdGU6bG9jYWw7dmFyIGRzdD1wb3B1bGF0ZT9sb2NhbDpyZW1vdGU7SURCRlMucmVjb25jaWxlKHNyYyxkc3QsY2FsbGJhY2spO30pKTt9KSk7fSksZ2V0REI6KGZ1bmN0aW9uKG5hbWUsY2FsbGJhY2spe3ZhciBkYj1JREJGUy5kYnNbbmFtZV07aWYoZGIpe3JldHVybiBjYWxsYmFjayhudWxsLGRiKX12YXIgcmVxO3RyeXtyZXE9SURCRlMuaW5kZXhlZERCKCkub3BlbihuYW1lLElEQkZTLkRCX1ZFUlNJT04pO31jYXRjaChlKXtyZXR1cm4gY2FsbGJhY2soZSl9aWYoIXJlcSl7cmV0dXJuIGNhbGxiYWNrKCJVbmFibGUgdG8gY29ubmVjdCB0byBJbmRleGVkREIiKX1yZXEub251cGdyYWRlbmVlZGVkPShmdW5jdGlvbihlKXt2YXIgZGI9ZS50YXJnZXQucmVzdWx0O3ZhciB0cmFuc2FjdGlvbj1lLnRhcmdldC50cmFuc2FjdGlvbjt2YXIgZmlsZVN0b3JlO2lmKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoSURCRlMuREJfU1RPUkVfTkFNRSkpe2ZpbGVTdG9yZT10cmFuc2FjdGlvbi5vYmplY3RTdG9yZShJREJGUy5EQl9TVE9SRV9OQU1FKTt9ZWxzZSB7ZmlsZVN0b3JlPWRiLmNyZWF0ZU9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpO31pZighZmlsZVN0b3JlLmluZGV4TmFtZXMuY29udGFpbnMoInRpbWVzdGFtcCIpKXtmaWxlU3RvcmUuY3JlYXRlSW5kZXgoInRpbWVzdGFtcCIsInRpbWVzdGFtcCIse3VuaXF1ZTpmYWxzZX0pO319KTtyZXEub25zdWNjZXNzPShmdW5jdGlvbigpe2RiPXJlcS5yZXN1bHQ7SURCRlMuZGJzW25hbWVdPWRiO2NhbGxiYWNrKG51bGwsZGIpO30pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCk7fSk7fSksZ2V0TG9jYWxTZXQ6KGZ1bmN0aW9uKG1vdW50LGNhbGxiYWNrKXt2YXIgZW50cmllcz17fTtmdW5jdGlvbiBpc1JlYWxEaXIocCl7cmV0dXJuIHAhPT0iLiImJnAhPT0iLi4ifWZ1bmN0aW9uIHRvQWJzb2x1dGUocm9vdCl7cmV0dXJuKGZ1bmN0aW9uKHApe3JldHVybiBQQVRILmpvaW4yKHJvb3QscCl9KX12YXIgY2hlY2s9RlMucmVhZGRpcihtb3VudC5tb3VudHBvaW50KS5maWx0ZXIoaXNSZWFsRGlyKS5tYXAodG9BYnNvbHV0ZShtb3VudC5tb3VudHBvaW50KSk7d2hpbGUoY2hlY2subGVuZ3RoKXt2YXIgcGF0aD1jaGVjay5wb3AoKTt2YXIgc3RhdDt0cnl7c3RhdD1GUy5zdGF0KHBhdGgpO31jYXRjaChlKXtyZXR1cm4gY2FsbGJhY2soZSl9aWYoRlMuaXNEaXIoc3RhdC5tb2RlKSl7Y2hlY2sucHVzaC5hcHBseShjaGVjayxGUy5yZWFkZGlyKHBhdGgpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKHBhdGgpKSk7fWVudHJpZXNbcGF0aF09e3RpbWVzdGFtcDpzdGF0Lm10aW1lfTt9cmV0dXJuIGNhbGxiYWNrKG51bGwse3R5cGU6ImxvY2FsIixlbnRyaWVzOmVudHJpZXN9KX0pLGdldFJlbW90ZVNldDooZnVuY3Rpb24obW91bnQsY2FsbGJhY2spe3ZhciBlbnRyaWVzPXt9O0lEQkZTLmdldERCKG1vdW50Lm1vdW50cG9pbnQsKGZ1bmN0aW9uKGVycixkYil7aWYoZXJyKXJldHVybiBjYWxsYmFjayhlcnIpO3RyeXt2YXIgdHJhbnNhY3Rpb249ZGIudHJhbnNhY3Rpb24oW0lEQkZTLkRCX1NUT1JFX05BTUVdLCJyZWFkb25seSIpO3RyYW5zYWN0aW9uLm9uZXJyb3I9KGZ1bmN0aW9uKGUpe2NhbGxiYWNrKHRoaXMuZXJyb3IpO2UucHJldmVudERlZmF1bHQoKTt9KTt2YXIgc3RvcmU9dHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSk7dmFyIGluZGV4PXN0b3JlLmluZGV4KCJ0aW1lc3RhbXAiKTtpbmRleC5vcGVuS2V5Q3Vyc29yKCkub25zdWNjZXNzPShmdW5jdGlvbihldmVudCl7dmFyIGN1cnNvcj1ldmVudC50YXJnZXQucmVzdWx0O2lmKCFjdXJzb3Ipe3JldHVybiBjYWxsYmFjayhudWxsLHt0eXBlOiJyZW1vdGUiLGRiOmRiLGVudHJpZXM6ZW50cmllc30pfWVudHJpZXNbY3Vyc29yLnByaW1hcnlLZXldPXt0aW1lc3RhbXA6Y3Vyc29yLmtleX07Y3Vyc29yLmNvbnRpbnVlKCk7fSk7fWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX19KSk7fSksbG9hZExvY2FsRW50cnk6KGZ1bmN0aW9uKHBhdGgsY2FsbGJhY2spe3ZhciBzdGF0LG5vZGU7dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoKTtub2RlPWxvb2t1cC5ub2RlO3N0YXQ9RlMuc3RhdChwYXRoKTt9Y2F0Y2goZSl7cmV0dXJuIGNhbGxiYWNrKGUpfWlmKEZTLmlzRGlyKHN0YXQubW9kZSkpe3JldHVybiBjYWxsYmFjayhudWxsLHt0aW1lc3RhbXA6c3RhdC5tdGltZSxtb2RlOnN0YXQubW9kZX0pfWVsc2UgaWYoRlMuaXNGaWxlKHN0YXQubW9kZSkpe25vZGUuY29udGVudHM9TUVNRlMuZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSk7cmV0dXJuIGNhbGxiYWNrKG51bGwse3RpbWVzdGFtcDpzdGF0Lm10aW1lLG1vZGU6c3RhdC5tb2RlLGNvbnRlbnRzOm5vZGUuY29udGVudHN9KX1lbHNlIHtyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZCIpKX19KSxzdG9yZUxvY2FsRW50cnk6KGZ1bmN0aW9uKHBhdGgsZW50cnksY2FsbGJhY2spe3RyeXtpZihGUy5pc0RpcihlbnRyeS5tb2RlKSl7RlMubWtkaXIocGF0aCxlbnRyeS5tb2RlKTt9ZWxzZSBpZihGUy5pc0ZpbGUoZW50cnkubW9kZSkpe0ZTLndyaXRlRmlsZShwYXRoLGVudHJ5LmNvbnRlbnRzLHtjYW5Pd246dHJ1ZX0pO31lbHNlIHtyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZCIpKX1GUy5jaG1vZChwYXRoLGVudHJ5Lm1vZGUpO0ZTLnV0aW1lKHBhdGgsZW50cnkudGltZXN0YW1wLGVudHJ5LnRpbWVzdGFtcCk7fWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1jYWxsYmFjayhudWxsKTt9KSxyZW1vdmVMb2NhbEVudHJ5OihmdW5jdGlvbihwYXRoLGNhbGxiYWNrKXt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgpO3ZhciBzdGF0PUZTLnN0YXQocGF0aCk7aWYoRlMuaXNEaXIoc3RhdC5tb2RlKSl7RlMucm1kaXIocGF0aCk7fWVsc2UgaWYoRlMuaXNGaWxlKHN0YXQubW9kZSkpe0ZTLnVubGluayhwYXRoKTt9fWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1jYWxsYmFjayhudWxsKTt9KSxsb2FkUmVtb3RlRW50cnk6KGZ1bmN0aW9uKHN0b3JlLHBhdGgsY2FsbGJhY2spe3ZhciByZXE9c3RvcmUuZ2V0KHBhdGgpO3JlcS5vbnN1Y2Nlc3M9KGZ1bmN0aW9uKGV2ZW50KXtjYWxsYmFjayhudWxsLGV2ZW50LnRhcmdldC5yZXN1bHQpO30pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCk7fSk7fSksc3RvcmVSZW1vdGVFbnRyeTooZnVuY3Rpb24oc3RvcmUscGF0aCxlbnRyeSxjYWxsYmFjayl7dmFyIHJlcT1zdG9yZS5wdXQoZW50cnkscGF0aCk7cmVxLm9uc3VjY2Vzcz0oZnVuY3Rpb24oKXtjYWxsYmFjayhudWxsKTt9KTtyZXEub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpO30pO30pLHJlbW92ZVJlbW90ZUVudHJ5OihmdW5jdGlvbihzdG9yZSxwYXRoLGNhbGxiYWNrKXt2YXIgcmVxPXN0b3JlLmRlbGV0ZShwYXRoKTtyZXEub25zdWNjZXNzPShmdW5jdGlvbigpe2NhbGxiYWNrKG51bGwpO30pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCk7fSk7fSkscmVjb25jaWxlOihmdW5jdGlvbihzcmMsZHN0LGNhbGxiYWNrKXt2YXIgdG90YWw9MDt2YXIgY3JlYXRlPVtdO09iamVjdC5rZXlzKHNyYy5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpe3ZhciBlPXNyYy5lbnRyaWVzW2tleV07dmFyIGUyPWRzdC5lbnRyaWVzW2tleV07aWYoIWUyfHxlLnRpbWVzdGFtcD5lMi50aW1lc3RhbXApe2NyZWF0ZS5wdXNoKGtleSk7dG90YWwrKzt9fSkpO3ZhciByZW1vdmU9W107T2JqZWN0LmtleXMoZHN0LmVudHJpZXMpLmZvckVhY2goKGZ1bmN0aW9uKGtleSl7dmFyIGU9ZHN0LmVudHJpZXNba2V5XTt2YXIgZTI9c3JjLmVudHJpZXNba2V5XTtpZighZTIpe3JlbW92ZS5wdXNoKGtleSk7dG90YWwrKzt9fSkpO2lmKCF0b3RhbCl7cmV0dXJuIGNhbGxiYWNrKG51bGwpfXZhciBjb21wbGV0ZWQ9MDt2YXIgZGI9c3JjLnR5cGU9PT0icmVtb3RlIj9zcmMuZGI6ZHN0LmRiO3ZhciB0cmFuc2FjdGlvbj1kYi50cmFuc2FjdGlvbihbSURCRlMuREJfU1RPUkVfTkFNRV0sInJlYWR3cml0ZSIpO3ZhciBzdG9yZT10cmFuc2FjdGlvbi5vYmplY3RTdG9yZShJREJGUy5EQl9TVE9SRV9OQU1FKTtmdW5jdGlvbiBkb25lKGVycil7aWYoZXJyKXtpZighZG9uZS5lcnJvcmVkKXtkb25lLmVycm9yZWQ9dHJ1ZTtyZXR1cm4gY2FsbGJhY2soZXJyKX1yZXR1cm59aWYoKytjb21wbGV0ZWQ+PXRvdGFsKXtyZXR1cm4gY2FsbGJhY2sobnVsbCl9fXRyYW5zYWN0aW9uLm9uZXJyb3I9KGZ1bmN0aW9uKGUpe2RvbmUodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpO30pO2NyZWF0ZS5zb3J0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocGF0aCl7aWYoZHN0LnR5cGU9PT0ibG9jYWwiKXtJREJGUy5sb2FkUmVtb3RlRW50cnkoc3RvcmUscGF0aCwoZnVuY3Rpb24oZXJyLGVudHJ5KXtpZihlcnIpcmV0dXJuIGRvbmUoZXJyKTtJREJGUy5zdG9yZUxvY2FsRW50cnkocGF0aCxlbnRyeSxkb25lKTt9KSk7fWVsc2Uge0lEQkZTLmxvYWRMb2NhbEVudHJ5KHBhdGgsKGZ1bmN0aW9uKGVycixlbnRyeSl7aWYoZXJyKXJldHVybiBkb25lKGVycik7SURCRlMuc3RvcmVSZW1vdGVFbnRyeShzdG9yZSxwYXRoLGVudHJ5LGRvbmUpO30pKTt9fSkpO3JlbW92ZS5zb3J0KCkucmV2ZXJzZSgpLmZvckVhY2goKGZ1bmN0aW9uKHBhdGgpe2lmKGRzdC50eXBlPT09ImxvY2FsIil7SURCRlMucmVtb3ZlTG9jYWxFbnRyeShwYXRoLGRvbmUpO31lbHNlIHtJREJGUy5yZW1vdmVSZW1vdGVFbnRyeShzdG9yZSxwYXRoLGRvbmUpO319KSk7fSl9O3ZhciBOT0RFRlM9e2lzV2luZG93czpmYWxzZSxzdGF0aWNJbml0OihmdW5jdGlvbigpe05PREVGUy5pc1dpbmRvd3M9ISFwcm9jZXNzLnBsYXRmb3JtLm1hdGNoKC9ed2luLyk7dmFyIGZsYWdzPXByb2Nlc3NbImJpbmRpbmciXSgiY29uc3RhbnRzIik7aWYoZmxhZ3NbImZzIl0pe2ZsYWdzPWZsYWdzWyJmcyJdO31OT0RFRlMuZmxhZ3NGb3JOb2RlTWFwPXsiMTAyNCI6ZmxhZ3NbIk9fQVBQRU5EIl0sIjY0IjpmbGFnc1siT19DUkVBVCJdLCIxMjgiOmZsYWdzWyJPX0VYQ0wiXSwiMCI6ZmxhZ3NbIk9fUkRPTkxZIl0sIjIiOmZsYWdzWyJPX1JEV1IiXSwiNDA5NiI6ZmxhZ3NbIk9fU1lOQyJdLCI1MTIiOmZsYWdzWyJPX1RSVU5DIl0sIjEiOmZsYWdzWyJPX1dST05MWSJdfTt9KSxidWZmZXJGcm9tOihmdW5jdGlvbihhcnJheUJ1ZmZlcil7cmV0dXJuIEJ1ZmZlci5hbGxvYz9CdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik6bmV3IEJ1ZmZlcihhcnJheUJ1ZmZlcil9KSxtb3VudDooZnVuY3Rpb24obW91bnQpe2Fzc2VydChFTlZJUk9OTUVOVF9JU19OT0RFKTtyZXR1cm4gTk9ERUZTLmNyZWF0ZU5vZGUobnVsbCwiLyIsTk9ERUZTLmdldE1vZGUobW91bnQub3B0cy5yb290KSwwKX0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2KXtpZighRlMuaXNEaXIobW9kZSkmJiFGUy5pc0ZpbGUobW9kZSkmJiFGUy5pc0xpbmsobW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIG5vZGU9RlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlKTtub2RlLm5vZGVfb3BzPU5PREVGUy5ub2RlX29wcztub2RlLnN0cmVhbV9vcHM9Tk9ERUZTLnN0cmVhbV9vcHM7cmV0dXJuIG5vZGV9KSxnZXRNb2RlOihmdW5jdGlvbihwYXRoKXt2YXIgc3RhdDt0cnl7c3RhdD1mcy5sc3RhdFN5bmMocGF0aCk7aWYoTk9ERUZTLmlzV2luZG93cyl7c3RhdC5tb2RlPXN0YXQubW9kZXwoc3RhdC5tb2RlJjI5Mik+PjI7fX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9cmV0dXJuIHN0YXQubW9kZX0pLHJlYWxQYXRoOihmdW5jdGlvbihub2RlKXt2YXIgcGFydHM9W107d2hpbGUobm9kZS5wYXJlbnQhPT1ub2RlKXtwYXJ0cy5wdXNoKG5vZGUubmFtZSk7bm9kZT1ub2RlLnBhcmVudDt9cGFydHMucHVzaChub2RlLm1vdW50Lm9wdHMucm9vdCk7cGFydHMucmV2ZXJzZSgpO3JldHVybiBQQVRILmpvaW4uYXBwbHkobnVsbCxwYXJ0cyl9KSxmbGFnc0Zvck5vZGU6KGZ1bmN0aW9uKGZsYWdzKXtmbGFncyY9fjIwOTcxNTI7ZmxhZ3MmPX4yMDQ4O2ZsYWdzJj1+MzI3Njg7ZmxhZ3MmPX41MjQyODg7dmFyIG5ld0ZsYWdzPTA7Zm9yKHZhciBrIGluIE5PREVGUy5mbGFnc0Zvck5vZGVNYXApe2lmKGZsYWdzJmspe25ld0ZsYWdzfD1OT0RFRlMuZmxhZ3NGb3JOb2RlTWFwW2tdO2ZsYWdzXj1rO319aWYoIWZsYWdzKXtyZXR1cm4gbmV3RmxhZ3N9ZWxzZSB7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX19KSxub2RlX29wczp7Z2V0YXR0cjooZnVuY3Rpb24obm9kZSl7dmFyIHBhdGg9Tk9ERUZTLnJlYWxQYXRoKG5vZGUpO3ZhciBzdGF0O3RyeXtzdGF0PWZzLmxzdGF0U3luYyhwYXRoKTt9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfWlmKE5PREVGUy5pc1dpbmRvd3MmJiFzdGF0LmJsa3NpemUpe3N0YXQuYmxrc2l6ZT00MDk2O31pZihOT0RFRlMuaXNXaW5kb3dzJiYhc3RhdC5ibG9ja3Mpe3N0YXQuYmxvY2tzPShzdGF0LnNpemUrc3RhdC5ibGtzaXplLTEpL3N0YXQuYmxrc2l6ZXwwO31yZXR1cm4ge2RldjpzdGF0LmRldixpbm86c3RhdC5pbm8sbW9kZTpzdGF0Lm1vZGUsbmxpbms6c3RhdC5ubGluayx1aWQ6c3RhdC51aWQsZ2lkOnN0YXQuZ2lkLHJkZXY6c3RhdC5yZGV2LHNpemU6c3RhdC5zaXplLGF0aW1lOnN0YXQuYXRpbWUsbXRpbWU6c3RhdC5tdGltZSxjdGltZTpzdGF0LmN0aW1lLGJsa3NpemU6c3RhdC5ibGtzaXplLGJsb2NrczpzdGF0LmJsb2Nrc319KSxzZXRhdHRyOihmdW5jdGlvbihub2RlLGF0dHIpe3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7aWYoYXR0ci5tb2RlIT09dW5kZWZpbmVkKXtmcy5jaG1vZFN5bmMocGF0aCxhdHRyLm1vZGUpO25vZGUubW9kZT1hdHRyLm1vZGU7fWlmKGF0dHIudGltZXN0YW1wIT09dW5kZWZpbmVkKXt2YXIgZGF0ZT1uZXcgRGF0ZShhdHRyLnRpbWVzdGFtcCk7ZnMudXRpbWVzU3luYyhwYXRoLGRhdGUsZGF0ZSk7fWlmKGF0dHIuc2l6ZSE9PXVuZGVmaW5lZCl7ZnMudHJ1bmNhdGVTeW5jKHBhdGgsYXR0ci5zaXplKTt9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxsb29rdXA6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgcGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPU5PREVGUy5nZXRNb2RlKHBhdGgpO3JldHVybiBOT0RFRlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlKX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7dmFyIG5vZGU9Tk9ERUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpO3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7ZnMubWtkaXJTeW5jKHBhdGgsbm9kZS5tb2RlKTt9ZWxzZSB7ZnMud3JpdGVGaWxlU3luYyhwYXRoLCIiLHttb2RlOm5vZGUubW9kZX0pO319Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfXJldHVybiBub2RlfSkscmVuYW1lOihmdW5jdGlvbihvbGROb2RlLG5ld0RpcixuZXdOYW1lKXt2YXIgb2xkUGF0aD1OT0RFRlMucmVhbFBhdGgob2xkTm9kZSk7dmFyIG5ld1BhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgobmV3RGlyKSxuZXdOYW1lKTt0cnl7ZnMucmVuYW1lU3luYyhvbGRQYXRoLG5ld1BhdGgpO31jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSksdW5saW5rOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIHBhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSxuYW1lKTt0cnl7ZnMudW5saW5rU3luYyhwYXRoKTt9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHJtZGlyOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIHBhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSxuYW1lKTt0cnl7ZnMucm1kaXJTeW5jKHBhdGgpO31jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSkscmVhZGRpcjooZnVuY3Rpb24obm9kZSl7dmFyIHBhdGg9Tk9ERUZTLnJlYWxQYXRoKG5vZGUpO3RyeXtyZXR1cm4gZnMucmVhZGRpclN5bmMocGF0aCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHN5bWxpbms6KGZ1bmN0aW9uKHBhcmVudCxuZXdOYW1lLG9sZFBhdGgpe3ZhciBuZXdQYXRoPVBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKHBhcmVudCksbmV3TmFtZSk7dHJ5e2ZzLnN5bWxpbmtTeW5jKG9sZFBhdGgsbmV3UGF0aCk7fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxyZWFkbGluazooZnVuY3Rpb24obm9kZSl7dmFyIHBhdGg9Tk9ERUZTLnJlYWxQYXRoKG5vZGUpO3RyeXtwYXRoPWZzLnJlYWRsaW5rU3luYyhwYXRoKTtwYXRoPU5PREVKU19QQVRILnJlbGF0aXZlKE5PREVKU19QQVRILnJlc29sdmUobm9kZS5tb3VudC5vcHRzLnJvb3QpLHBhdGgpO3JldHVybiBwYXRofWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KX0sc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgcGF0aD1OT0RFRlMucmVhbFBhdGgoc3RyZWFtLm5vZGUpO3RyeXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3N0cmVhbS5uZmQ9ZnMub3BlblN5bmMocGF0aCxOT0RFRlMuZmxhZ3NGb3JOb2RlKHN0cmVhbS5mbGFncykpO319Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe3RyeXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkmJnN0cmVhbS5uZmQpe2ZzLmNsb3NlU3luYyhzdHJlYW0ubmZkKTt9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKGxlbmd0aD09PTApcmV0dXJuIDA7dHJ5e3JldHVybiBmcy5yZWFkU3luYyhzdHJlYW0ubmZkLE5PREVGUy5idWZmZXJGcm9tKGJ1ZmZlci5idWZmZXIpLG9mZnNldCxsZW5ndGgscG9zaXRpb24pfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe3RyeXtyZXR1cm4gZnMud3JpdGVTeW5jKHN0cmVhbS5uZmQsTk9ERUZTLmJ1ZmZlckZyb20oYnVmZmVyLmJ1ZmZlciksb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSksbGxzZWVrOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7dmFyIHBvc2l0aW9uPW9mZnNldDtpZih3aGVuY2U9PT0xKXtwb3NpdGlvbis9c3RyZWFtLnBvc2l0aW9uO31lbHNlIGlmKHdoZW5jZT09PTIpe2lmKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7dHJ5e3ZhciBzdGF0PWZzLmZzdGF0U3luYyhzdHJlYW0ubmZkKTtwb3NpdGlvbis9c3RhdC5zaXplO31jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19fWlmKHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9cmV0dXJuIHBvc2l0aW9ufSl9fTt2YXIgV09SS0VSRlM9e0RJUl9NT0RFOjE2ODk1LEZJTEVfTU9ERTozMzI3OSxyZWFkZXI6bnVsbCxtb3VudDooZnVuY3Rpb24obW91bnQpe2Fzc2VydChFTlZJUk9OTUVOVF9JU19XT1JLRVIpO2lmKCFXT1JLRVJGUy5yZWFkZXIpV09SS0VSRlMucmVhZGVyPW5ldyBGaWxlUmVhZGVyU3luYzt2YXIgcm9vdD1XT1JLRVJGUy5jcmVhdGVOb2RlKG51bGwsIi8iLFdPUktFUkZTLkRJUl9NT0RFLDApO3ZhciBjcmVhdGVkUGFyZW50cz17fTtmdW5jdGlvbiBlbnN1cmVQYXJlbnQocGF0aCl7dmFyIHBhcnRzPXBhdGguc3BsaXQoIi8iKTt2YXIgcGFyZW50PXJvb3Q7Zm9yKHZhciBpPTA7aTxwYXJ0cy5sZW5ndGgtMTtpKyspe3ZhciBjdXJyPXBhcnRzLnNsaWNlKDAsaSsxKS5qb2luKCIvIik7aWYoIWNyZWF0ZWRQYXJlbnRzW2N1cnJdKXtjcmVhdGVkUGFyZW50c1tjdXJyXT1XT1JLRVJGUy5jcmVhdGVOb2RlKHBhcmVudCxwYXJ0c1tpXSxXT1JLRVJGUy5ESVJfTU9ERSwwKTt9cGFyZW50PWNyZWF0ZWRQYXJlbnRzW2N1cnJdO31yZXR1cm4gcGFyZW50fWZ1bmN0aW9uIGJhc2UocGF0aCl7dmFyIHBhcnRzPXBhdGguc3BsaXQoIi8iKTtyZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoLTFdfUFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobW91bnQub3B0c1siZmlsZXMiXXx8W10sKGZ1bmN0aW9uKGZpbGUpe1dPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KGZpbGUubmFtZSksYmFzZShmaWxlLm5hbWUpLFdPUktFUkZTLkZJTEVfTU9ERSwwLGZpbGUsZmlsZS5sYXN0TW9kaWZpZWREYXRlKTt9KSk7KG1vdW50Lm9wdHNbImJsb2JzIl18fFtdKS5mb3JFYWNoKChmdW5jdGlvbihvYmope1dPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KG9ialsibmFtZSJdKSxiYXNlKG9ialsibmFtZSJdKSxXT1JLRVJGUy5GSUxFX01PREUsMCxvYmpbImRhdGEiXSk7fSkpOyhtb3VudC5vcHRzWyJwYWNrYWdlcyJdfHxbXSkuZm9yRWFjaCgoZnVuY3Rpb24ocGFjayl7cGFja1sibWV0YWRhdGEiXS5maWxlcy5mb3JFYWNoKChmdW5jdGlvbihmaWxlKXt2YXIgbmFtZT1maWxlLmZpbGVuYW1lLnN1YnN0cigxKTtXT1JLRVJGUy5jcmVhdGVOb2RlKGVuc3VyZVBhcmVudChuYW1lKSxiYXNlKG5hbWUpLFdPUktFUkZTLkZJTEVfTU9ERSwwLHBhY2tbImJsb2IiXS5zbGljZShmaWxlLnN0YXJ0LGZpbGUuZW5kKSk7fSkpO30pKTtyZXR1cm4gcm9vdH0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2LGNvbnRlbnRzLG10aW1lKXt2YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUpO25vZGUubW9kZT1tb2RlO25vZGUubm9kZV9vcHM9V09SS0VSRlMubm9kZV9vcHM7bm9kZS5zdHJlYW1fb3BzPVdPUktFUkZTLnN0cmVhbV9vcHM7bm9kZS50aW1lc3RhbXA9KG10aW1lfHxuZXcgRGF0ZSkuZ2V0VGltZSgpO2Fzc2VydChXT1JLRVJGUy5GSUxFX01PREUhPT1XT1JLRVJGUy5ESVJfTU9ERSk7aWYobW9kZT09PVdPUktFUkZTLkZJTEVfTU9ERSl7bm9kZS5zaXplPWNvbnRlbnRzLnNpemU7bm9kZS5jb250ZW50cz1jb250ZW50czt9ZWxzZSB7bm9kZS5zaXplPTQwOTY7bm9kZS5jb250ZW50cz17fTt9aWYocGFyZW50KXtwYXJlbnQuY29udGVudHNbbmFtZV09bm9kZTt9cmV0dXJuIG5vZGV9KSxub2RlX29wczp7Z2V0YXR0cjooZnVuY3Rpb24obm9kZSl7cmV0dXJuIHtkZXY6MSxpbm86dW5kZWZpbmVkLG1vZGU6bm9kZS5tb2RlLG5saW5rOjEsdWlkOjAsZ2lkOjAscmRldjp1bmRlZmluZWQsc2l6ZTpub2RlLnNpemUsYXRpbWU6bmV3IERhdGUobm9kZS50aW1lc3RhbXApLG10aW1lOm5ldyBEYXRlKG5vZGUudGltZXN0YW1wKSxjdGltZTpuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksYmxrc2l6ZTo0MDk2LGJsb2NrczpNYXRoLmNlaWwobm9kZS5zaXplLzQwOTYpfX0pLHNldGF0dHI6KGZ1bmN0aW9uKG5vZGUsYXR0cil7aWYoYXR0ci5tb2RlIT09dW5kZWZpbmVkKXtub2RlLm1vZGU9YXR0ci5tb2RlO31pZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7bm9kZS50aW1lc3RhbXA9YXR0ci50aW1lc3RhbXA7fX0pLGxvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9KSxta25vZDooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxkZXYpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pLHJlbmFtZTooZnVuY3Rpb24ob2xkTm9kZSxuZXdEaXIsbmV3TmFtZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfSksdW5saW5rOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfSkscm1kaXI6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KSxyZWFkZGlyOihmdW5jdGlvbihub2RlKXt2YXIgZW50cmllcz1bIi4iLCIuLiJdO2Zvcih2YXIga2V5IGluIG5vZGUuY29udGVudHMpe2lmKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpe2NvbnRpbnVlfWVudHJpZXMucHVzaChrZXkpO31yZXR1cm4gZW50cmllc30pLHN5bWxpbms6KGZ1bmN0aW9uKHBhcmVudCxuZXdOYW1lLG9sZFBhdGgpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pLHJlYWRsaW5rOihmdW5jdGlvbihub2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KX0sc3RyZWFtX29wczp7cmVhZDooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXtpZihwb3NpdGlvbj49c3RyZWFtLm5vZGUuc2l6ZSlyZXR1cm4gMDt2YXIgY2h1bms9c3RyZWFtLm5vZGUuY29udGVudHMuc2xpY2UocG9zaXRpb24scG9zaXRpb24rbGVuZ3RoKTt2YXIgYWI9V09SS0VSRlMucmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtidWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFiKSxvZmZzZXQpO3JldHVybiBjaHVuay5zaXplfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX0pLGxsc2VlazooZnVuY3Rpb24oc3RyZWFtLG9mZnNldCx3aGVuY2Upe3ZhciBwb3NpdGlvbj1vZmZzZXQ7aWYod2hlbmNlPT09MSl7cG9zaXRpb24rPXN0cmVhbS5wb3NpdGlvbjt9ZWxzZSBpZih3aGVuY2U9PT0yKXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3Bvc2l0aW9uKz1zdHJlYW0ubm9kZS5zaXplO319aWYocG9zaXRpb248MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1yZXR1cm4gcG9zaXRpb259KX19O1NUQVRJQ1RPUCs9MTY7U1RBVElDVE9QKz0xNjtTVEFUSUNUT1ArPTE2O3ZhciBGUz17cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOnt9LHN0cmVhbXM6W10sbmV4dElub2RlOjEsbmFtZVRhYmxlOm51bGwsY3VycmVudFBhdGg6Ii8iLGluaXRpYWxpemVkOmZhbHNlLGlnbm9yZVBlcm1pc3Npb25zOnRydWUsdHJhY2tpbmdEZWxlZ2F0ZTp7fSx0cmFja2luZzp7b3BlbkZsYWdzOntSRUFEOjEsV1JJVEU6Mn19LEVycm5vRXJyb3I6bnVsbCxnZW5lcmljRXJyb3JzOnt9LGZpbGVzeXN0ZW1zOm51bGwsc3luY0ZTUmVxdWVzdHM6MCxoYW5kbGVGU0Vycm9yOihmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSl0aHJvdyBlKyIgOiAiK3N0YWNrVHJhY2UoKTtyZXR1cm4gX19fc2V0RXJyTm8oZS5lcnJubyl9KSxsb29rdXBQYXRoOihmdW5jdGlvbihwYXRoLG9wdHMpe3BhdGg9UEFUSC5yZXNvbHZlKEZTLmN3ZCgpLHBhdGgpO29wdHM9b3B0c3x8e307aWYoIXBhdGgpcmV0dXJuIHtwYXRoOiIiLG5vZGU6bnVsbH07dmFyIGRlZmF1bHRzPXtmb2xsb3dfbW91bnQ6dHJ1ZSxyZWN1cnNlX2NvdW50OjB9O2Zvcih2YXIga2V5IGluIGRlZmF1bHRzKXtpZihvcHRzW2tleV09PT11bmRlZmluZWQpe29wdHNba2V5XT1kZWZhdWx0c1trZXldO319aWYob3B0cy5yZWN1cnNlX2NvdW50Pjgpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVMT09QKX12YXIgcGFydHM9UEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCIvIikuZmlsdGVyKChmdW5jdGlvbihwKXtyZXR1cm4gISFwfSkpLGZhbHNlKTt2YXIgY3VycmVudD1GUy5yb290O3ZhciBjdXJyZW50X3BhdGg9Ii8iO2Zvcih2YXIgaT0wO2k8cGFydHMubGVuZ3RoO2krKyl7dmFyIGlzbGFzdD1pPT09cGFydHMubGVuZ3RoLTE7aWYoaXNsYXN0JiZvcHRzLnBhcmVudCl7YnJlYWt9Y3VycmVudD1GUy5sb29rdXBOb2RlKGN1cnJlbnQscGFydHNbaV0pO2N1cnJlbnRfcGF0aD1QQVRILmpvaW4yKGN1cnJlbnRfcGF0aCxwYXJ0c1tpXSk7aWYoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKXtpZighaXNsYXN0fHxpc2xhc3QmJm9wdHMuZm9sbG93X21vdW50KXtjdXJyZW50PWN1cnJlbnQubW91bnRlZC5yb290O319aWYoIWlzbGFzdHx8b3B0cy5mb2xsb3cpe3ZhciBjb3VudD0wO3doaWxlKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKXt2YXIgbGluaz1GUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO2N1cnJlbnRfcGF0aD1QQVRILnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksbGluayk7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCx7cmVjdXJzZV9jb3VudDpvcHRzLnJlY3Vyc2VfY291bnR9KTtjdXJyZW50PWxvb2t1cC5ub2RlO2lmKGNvdW50Kys+NDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVMT09QKX19fX1yZXR1cm4ge3BhdGg6Y3VycmVudF9wYXRoLG5vZGU6Y3VycmVudH19KSxnZXRQYXRoOihmdW5jdGlvbihub2RlKXt2YXIgcGF0aDt3aGlsZSh0cnVlKXtpZihGUy5pc1Jvb3Qobm9kZSkpe3ZhciBtb3VudD1ub2RlLm1vdW50Lm1vdW50cG9pbnQ7aWYoIXBhdGgpcmV0dXJuIG1vdW50O3JldHVybiBtb3VudFttb3VudC5sZW5ndGgtMV0hPT0iLyI/bW91bnQrIi8iK3BhdGg6bW91bnQrcGF0aH1wYXRoPXBhdGg/bm9kZS5uYW1lKyIvIitwYXRoOm5vZGUubmFtZTtub2RlPW5vZGUucGFyZW50O319KSxoYXNoTmFtZTooZnVuY3Rpb24ocGFyZW50aWQsbmFtZSl7dmFyIGhhc2g9MDtmb3IodmFyIGk9MDtpPG5hbWUubGVuZ3RoO2krKyl7aGFzaD0oaGFzaDw8NSktaGFzaCtuYW1lLmNoYXJDb2RlQXQoaSl8MDt9cmV0dXJuIChwYXJlbnRpZCtoYXNoPj4+MCklRlMubmFtZVRhYmxlLmxlbmd0aH0pLGhhc2hBZGROb2RlOihmdW5jdGlvbihub2RlKXt2YXIgaGFzaD1GUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCxub2RlLm5hbWUpO25vZGUubmFtZV9uZXh0PUZTLm5hbWVUYWJsZVtoYXNoXTtGUy5uYW1lVGFibGVbaGFzaF09bm9kZTt9KSxoYXNoUmVtb3ZlTm9kZTooZnVuY3Rpb24obm9kZSl7dmFyIGhhc2g9RlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsbm9kZS5uYW1lKTtpZihGUy5uYW1lVGFibGVbaGFzaF09PT1ub2RlKXtGUy5uYW1lVGFibGVbaGFzaF09bm9kZS5uYW1lX25leHQ7fWVsc2Uge3ZhciBjdXJyZW50PUZTLm5hbWVUYWJsZVtoYXNoXTt3aGlsZShjdXJyZW50KXtpZihjdXJyZW50Lm5hbWVfbmV4dD09PW5vZGUpe2N1cnJlbnQubmFtZV9uZXh0PW5vZGUubmFtZV9uZXh0O2JyZWFrfWN1cnJlbnQ9Y3VycmVudC5uYW1lX25leHQ7fX19KSxsb29rdXBOb2RlOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIGVycj1GUy5tYXlMb29rdXAocGFyZW50KTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycixwYXJlbnQpfXZhciBoYXNoPUZTLmhhc2hOYW1lKHBhcmVudC5pZCxuYW1lKTtmb3IodmFyIG5vZGU9RlMubmFtZVRhYmxlW2hhc2hdO25vZGU7bm9kZT1ub2RlLm5hbWVfbmV4dCl7dmFyIG5vZGVOYW1lPW5vZGUubmFtZTtpZihub2RlLnBhcmVudC5pZD09PXBhcmVudC5pZCYmbm9kZU5hbWU9PT1uYW1lKXtyZXR1cm4gbm9kZX19cmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsbmFtZSl9KSxjcmVhdGVOb2RlOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLHJkZXYpe2lmKCFGUy5GU05vZGUpe0ZTLkZTTm9kZT0oZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxyZGV2KXtpZighcGFyZW50KXtwYXJlbnQ9dGhpczt9dGhpcy5wYXJlbnQ9cGFyZW50O3RoaXMubW91bnQ9cGFyZW50Lm1vdW50O3RoaXMubW91bnRlZD1udWxsO3RoaXMuaWQ9RlMubmV4dElub2RlKys7dGhpcy5uYW1lPW5hbWU7dGhpcy5tb2RlPW1vZGU7dGhpcy5ub2RlX29wcz17fTt0aGlzLnN0cmVhbV9vcHM9e307dGhpcy5yZGV2PXJkZXY7fSk7RlMuRlNOb2RlLnByb3RvdHlwZT17fTt2YXIgcmVhZE1vZGU9MjkyfDczO3ZhciB3cml0ZU1vZGU9MTQ2O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTTm9kZS5wcm90b3R5cGUse3JlYWQ6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gKHRoaXMubW9kZSZyZWFkTW9kZSk9PT1yZWFkTW9kZX0pLHNldDooZnVuY3Rpb24odmFsKXt2YWw/dGhpcy5tb2RlfD1yZWFkTW9kZTp0aGlzLm1vZGUmPX5yZWFkTW9kZTt9KX0sd3JpdGU6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gKHRoaXMubW9kZSZ3cml0ZU1vZGUpPT09d3JpdGVNb2RlfSksc2V0OihmdW5jdGlvbih2YWwpe3ZhbD90aGlzLm1vZGV8PXdyaXRlTW9kZTp0aGlzLm1vZGUmPX53cml0ZU1vZGU7fSl9LGlzRm9sZGVyOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSl9KX0saXNEZXZpY2U6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gRlMuaXNDaHJkZXYodGhpcy5tb2RlKX0pfX0pO312YXIgbm9kZT1uZXcgRlMuRlNOb2RlKHBhcmVudCxuYW1lLG1vZGUscmRldik7RlMuaGFzaEFkZE5vZGUobm9kZSk7cmV0dXJuIG5vZGV9KSxkZXN0cm95Tm9kZTooZnVuY3Rpb24obm9kZSl7RlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7fSksaXNSb290OihmdW5jdGlvbihub2RlKXtyZXR1cm4gbm9kZT09PW5vZGUucGFyZW50fSksaXNNb3VudHBvaW50OihmdW5jdGlvbihub2RlKXtyZXR1cm4gISFub2RlLm1vdW50ZWR9KSxpc0ZpbGU6KGZ1bmN0aW9uKG1vZGUpe3JldHVybiAobW9kZSY2MTQ0MCk9PT0zMjc2OH0pLGlzRGlyOihmdW5jdGlvbihtb2RlKXtyZXR1cm4gKG1vZGUmNjE0NDApPT09MTYzODR9KSxpc0xpbms6KGZ1bmN0aW9uKG1vZGUpe3JldHVybiAobW9kZSY2MTQ0MCk9PT00MDk2MH0pLGlzQ2hyZGV2OihmdW5jdGlvbihtb2RlKXtyZXR1cm4gKG1vZGUmNjE0NDApPT09ODE5Mn0pLGlzQmxrZGV2OihmdW5jdGlvbihtb2RlKXtyZXR1cm4gKG1vZGUmNjE0NDApPT09MjQ1NzZ9KSxpc0ZJRk86KGZ1bmN0aW9uKG1vZGUpe3JldHVybiAobW9kZSY2MTQ0MCk9PT00MDk2fSksaXNTb2NrZXQ6KGZ1bmN0aW9uKG1vZGUpe3JldHVybiAobW9kZSY0OTE1Mik9PT00OTE1Mn0pLGZsYWdNb2Rlczp7InIiOjAsInJzIjoxMDUyNjcyLCJyKyI6MiwidyI6NTc3LCJ3eCI6NzA1LCJ4dyI6NzA1LCJ3KyI6NTc4LCJ3eCsiOjcwNiwieHcrIjo3MDYsImEiOjEwODksImF4IjoxMjE3LCJ4YSI6MTIxNywiYSsiOjEwOTAsImF4KyI6MTIxOCwieGErIjoxMjE4fSxtb2RlU3RyaW5nVG9GbGFnczooZnVuY3Rpb24oc3RyKXt2YXIgZmxhZ3M9RlMuZmxhZ01vZGVzW3N0cl07aWYodHlwZW9mIGZsYWdzPT09InVuZGVmaW5lZCIpe3Rocm93IG5ldyBFcnJvcigiVW5rbm93biBmaWxlIG9wZW4gbW9kZTogIitzdHIpfXJldHVybiBmbGFnc30pLGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOihmdW5jdGlvbihmbGFnKXt2YXIgcGVybXM9WyJyIiwidyIsInJ3Il1bZmxhZyYzXTtpZihmbGFnJjUxMil7cGVybXMrPSJ3Ijt9cmV0dXJuIHBlcm1zfSksbm9kZVBlcm1pc3Npb25zOihmdW5jdGlvbihub2RlLHBlcm1zKXtpZihGUy5pZ25vcmVQZXJtaXNzaW9ucyl7cmV0dXJuIDB9aWYocGVybXMuaW5kZXhPZigiciIpIT09LTEmJiEobm9kZS5tb2RlJjI5Mikpe3JldHVybiBFUlJOT19DT0RFUy5FQUNDRVN9ZWxzZSBpZihwZXJtcy5pbmRleE9mKCJ3IikhPT0tMSYmIShub2RlLm1vZGUmMTQ2KSl7cmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFU31lbHNlIGlmKHBlcm1zLmluZGV4T2YoIngiKSE9PS0xJiYhKG5vZGUubW9kZSY3Mykpe3JldHVybiBFUlJOT19DT0RFUy5FQUNDRVN9cmV0dXJuIDB9KSxtYXlMb29rdXA6KGZ1bmN0aW9uKGRpcil7dmFyIGVycj1GUy5ub2RlUGVybWlzc2lvbnMoZGlyLCJ4Iik7aWYoZXJyKXJldHVybiBlcnI7aWYoIWRpci5ub2RlX29wcy5sb29rdXApcmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFUztyZXR1cm4gMH0pLG1heUNyZWF0ZTooZnVuY3Rpb24oZGlyLG5hbWUpe3RyeXt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKGRpcixuYW1lKTtyZXR1cm4gRVJSTk9fQ09ERVMuRUVYSVNUfWNhdGNoKGUpe31yZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwid3giKX0pLG1heURlbGV0ZTooZnVuY3Rpb24oZGlyLG5hbWUsaXNkaXIpe3ZhciBub2RlO3RyeXtub2RlPUZTLmxvb2t1cE5vZGUoZGlyLG5hbWUpO31jYXRjaChlKXtyZXR1cm4gZS5lcnJub312YXIgZXJyPUZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsInd4Iik7aWYoZXJyKXtyZXR1cm4gZXJyfWlmKGlzZGlyKXtpZighRlMuaXNEaXIobm9kZS5tb2RlKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVOT1RESVJ9aWYoRlMuaXNSb290KG5vZGUpfHxGUy5nZXRQYXRoKG5vZGUpPT09RlMuY3dkKCkpe3JldHVybiBFUlJOT19DT0RFUy5FQlVTWX19ZWxzZSB7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVJU0RJUn19cmV0dXJuIDB9KSxtYXlPcGVuOihmdW5jdGlvbihub2RlLGZsYWdzKXtpZighbm9kZSl7cmV0dXJuIEVSUk5PX0NPREVTLkVOT0VOVH1pZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVMT09QfWVsc2UgaWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7aWYoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpIT09InIifHxmbGFncyY1MTIpe3JldHVybiBFUlJOT19DT0RFUy5FSVNESVJ9fXJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSxGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpfSksTUFYX09QRU5fRkRTOjQwOTYsbmV4dGZkOihmdW5jdGlvbihmZF9zdGFydCxmZF9lbmQpe2ZkX3N0YXJ0PWZkX3N0YXJ0fHwwO2ZkX2VuZD1mZF9lbmR8fEZTLk1BWF9PUEVOX0ZEUztmb3IodmFyIGZkPWZkX3N0YXJ0O2ZkPD1mZF9lbmQ7ZmQrKyl7aWYoIUZTLnN0cmVhbXNbZmRdKXtyZXR1cm4gZmR9fXRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVNRklMRSl9KSxnZXRTdHJlYW06KGZ1bmN0aW9uKGZkKXtyZXR1cm4gRlMuc3RyZWFtc1tmZF19KSxjcmVhdGVTdHJlYW06KGZ1bmN0aW9uKHN0cmVhbSxmZF9zdGFydCxmZF9lbmQpe2lmKCFGUy5GU1N0cmVhbSl7RlMuRlNTdHJlYW09KGZ1bmN0aW9uKCl7fSk7RlMuRlNTdHJlYW0ucHJvdG90eXBlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTU3RyZWFtLnByb3RvdHlwZSx7b2JqZWN0OntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0pLHNldDooZnVuY3Rpb24odmFsKXt0aGlzLm5vZGU9dmFsO30pfSxpc1JlYWQ6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0xfSl9LGlzV3JpdGU6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0wfSl9LGlzQXBwZW5kOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3MmMTAyNH0pfX0pO312YXIgbmV3U3RyZWFtPW5ldyBGUy5GU1N0cmVhbTtmb3IodmFyIHAgaW4gc3RyZWFtKXtuZXdTdHJlYW1bcF09c3RyZWFtW3BdO31zdHJlYW09bmV3U3RyZWFtO3ZhciBmZD1GUy5uZXh0ZmQoZmRfc3RhcnQsZmRfZW5kKTtzdHJlYW0uZmQ9ZmQ7RlMuc3RyZWFtc1tmZF09c3RyZWFtO3JldHVybiBzdHJlYW19KSxjbG9zZVN0cmVhbTooZnVuY3Rpb24oZmQpe0ZTLnN0cmVhbXNbZmRdPW51bGw7fSksY2hyZGV2X3N0cmVhbV9vcHM6e29wZW46KGZ1bmN0aW9uKHN0cmVhbSl7dmFyIGRldmljZT1GUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7c3RyZWFtLnN0cmVhbV9vcHM9ZGV2aWNlLnN0cmVhbV9vcHM7aWYoc3RyZWFtLnN0cmVhbV9vcHMub3Blbil7c3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pO319KSxsbHNlZWs6KGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX0pfSxtYWpvcjooZnVuY3Rpb24oZGV2KXtyZXR1cm4gZGV2Pj44fSksbWlub3I6KGZ1bmN0aW9uKGRldil7cmV0dXJuIGRldiYyNTV9KSxtYWtlZGV2OihmdW5jdGlvbihtYSxtaSl7cmV0dXJuIG1hPDw4fG1pfSkscmVnaXN0ZXJEZXZpY2U6KGZ1bmN0aW9uKGRldixvcHMpe0ZTLmRldmljZXNbZGV2XT17c3RyZWFtX29wczpvcHN9O30pLGdldERldmljZTooZnVuY3Rpb24oZGV2KXtyZXR1cm4gRlMuZGV2aWNlc1tkZXZdfSksZ2V0TW91bnRzOihmdW5jdGlvbihtb3VudCl7dmFyIG1vdW50cz1bXTt2YXIgY2hlY2s9W21vdW50XTt3aGlsZShjaGVjay5sZW5ndGgpe3ZhciBtPWNoZWNrLnBvcCgpO21vdW50cy5wdXNoKG0pO2NoZWNrLnB1c2guYXBwbHkoY2hlY2ssbS5tb3VudHMpO31yZXR1cm4gbW91bnRzfSksc3luY2ZzOihmdW5jdGlvbihwb3B1bGF0ZSxjYWxsYmFjayl7aWYodHlwZW9mIHBvcHVsYXRlPT09ImZ1bmN0aW9uIil7Y2FsbGJhY2s9cG9wdWxhdGU7cG9wdWxhdGU9ZmFsc2U7fUZTLnN5bmNGU1JlcXVlc3RzKys7aWYoRlMuc3luY0ZTUmVxdWVzdHM+MSl7Y29uc29sZS5sb2coIndhcm5pbmc6ICIrRlMuc3luY0ZTUmVxdWVzdHMrIiBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrIik7fXZhciBtb3VudHM9RlMuZ2V0TW91bnRzKEZTLnJvb3QubW91bnQpO3ZhciBjb21wbGV0ZWQ9MDtmdW5jdGlvbiBkb0NhbGxiYWNrKGVycil7YXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzPjApO0ZTLnN5bmNGU1JlcXVlc3RzLS07cmV0dXJuIGNhbGxiYWNrKGVycil9ZnVuY3Rpb24gZG9uZShlcnIpe2lmKGVycil7aWYoIWRvbmUuZXJyb3JlZCl7ZG9uZS5lcnJvcmVkPXRydWU7cmV0dXJuIGRvQ2FsbGJhY2soZXJyKX1yZXR1cm59aWYoKytjb21wbGV0ZWQ+PW1vdW50cy5sZW5ndGgpe2RvQ2FsbGJhY2sobnVsbCk7fX1tb3VudHMuZm9yRWFjaCgoZnVuY3Rpb24obW91bnQpe2lmKCFtb3VudC50eXBlLnN5bmNmcyl7cmV0dXJuIGRvbmUobnVsbCl9bW91bnQudHlwZS5zeW5jZnMobW91bnQscG9wdWxhdGUsZG9uZSk7fSkpO30pLG1vdW50OihmdW5jdGlvbih0eXBlLG9wdHMsbW91bnRwb2ludCl7dmFyIHJvb3Q9bW91bnRwb2ludD09PSIvIjt2YXIgcHNldWRvPSFtb3VudHBvaW50O3ZhciBub2RlO2lmKHJvb3QmJkZTLnJvb3Qpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX1lbHNlIGlmKCFyb290JiYhcHNldWRvKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgobW91bnRwb2ludCx7Zm9sbG93X21vdW50OmZhbHNlfSk7bW91bnRwb2ludD1sb29rdXAucGF0aDtub2RlPWxvb2t1cC5ub2RlO2lmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfWlmKCFGUy5pc0Rpcihub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URElSKX19dmFyIG1vdW50PXt0eXBlOnR5cGUsb3B0czpvcHRzLG1vdW50cG9pbnQ6bW91bnRwb2ludCxtb3VudHM6W119O3ZhciBtb3VudFJvb3Q9dHlwZS5tb3VudChtb3VudCk7bW91bnRSb290Lm1vdW50PW1vdW50O21vdW50LnJvb3Q9bW91bnRSb290O2lmKHJvb3Qpe0ZTLnJvb3Q9bW91bnRSb290O31lbHNlIGlmKG5vZGUpe25vZGUubW91bnRlZD1tb3VudDtpZihub2RlLm1vdW50KXtub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTt9fXJldHVybiBtb3VudFJvb3R9KSx1bm1vdW50OihmdW5jdGlvbihtb3VudHBvaW50KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgobW91bnRwb2ludCx7Zm9sbG93X21vdW50OmZhbHNlfSk7aWYoIUZTLmlzTW91bnRwb2ludChsb29rdXAubm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIG5vZGU9bG9va3VwLm5vZGU7dmFyIG1vdW50PW5vZGUubW91bnRlZDt2YXIgbW91bnRzPUZTLmdldE1vdW50cyhtb3VudCk7T2JqZWN0LmtleXMoRlMubmFtZVRhYmxlKS5mb3JFYWNoKChmdW5jdGlvbihoYXNoKXt2YXIgY3VycmVudD1GUy5uYW1lVGFibGVbaGFzaF07d2hpbGUoY3VycmVudCl7dmFyIG5leHQ9Y3VycmVudC5uYW1lX25leHQ7aWYobW91bnRzLmluZGV4T2YoY3VycmVudC5tb3VudCkhPT0tMSl7RlMuZGVzdHJveU5vZGUoY3VycmVudCk7fWN1cnJlbnQ9bmV4dDt9fSkpO25vZGUubW91bnRlZD1udWxsO3ZhciBpZHg9bm9kZS5tb3VudC5tb3VudHMuaW5kZXhPZihtb3VudCk7YXNzZXJ0KGlkeCE9PS0xKTtub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LDEpO30pLGxvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3JldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCxuYW1lKX0pLG1rbm9kOihmdW5jdGlvbihwYXRoLG1vZGUsZGV2KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OnRydWV9KTt2YXIgcGFyZW50PWxvb2t1cC5ub2RlO3ZhciBuYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7aWYoIW5hbWV8fG5hbWU9PT0iLiJ8fG5hbWU9PT0iLi4iKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfXZhciBlcnI9RlMubWF5Q3JlYXRlKHBhcmVudCxuYW1lKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9aWYoIXBhcmVudC5ub2RlX29wcy5ta25vZCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfXJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LG5hbWUsbW9kZSxkZXYpfSksY3JlYXRlOihmdW5jdGlvbihwYXRoLG1vZGUpe21vZGU9bW9kZSE9PXVuZGVmaW5lZD9tb2RlOjQzODttb2RlJj00MDk1O21vZGV8PTMyNzY4O3JldHVybiBGUy5ta25vZChwYXRoLG1vZGUsMCl9KSxta2RpcjooZnVuY3Rpb24ocGF0aCxtb2RlKXttb2RlPW1vZGUhPT11bmRlZmluZWQ/bW9kZTo1MTE7bW9kZSY9NTExfDUxMjttb2RlfD0xNjM4NDtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLDApfSksbWtkaXJUcmVlOihmdW5jdGlvbihwYXRoLG1vZGUpe3ZhciBkaXJzPXBhdGguc3BsaXQoIi8iKTt2YXIgZD0iIjtmb3IodmFyIGk9MDtpPGRpcnMubGVuZ3RoOysraSl7aWYoIWRpcnNbaV0pY29udGludWU7ZCs9Ii8iK2RpcnNbaV07dHJ5e0ZTLm1rZGlyKGQsbW9kZSk7fWNhdGNoKGUpe2lmKGUuZXJybm8hPUVSUk5PX0NPREVTLkVFWElTVCl0aHJvdyBlfX19KSxta2RldjooZnVuY3Rpb24ocGF0aCxtb2RlLGRldil7aWYodHlwZW9mIGRldj09PSJ1bmRlZmluZWQiKXtkZXY9bW9kZTttb2RlPTQzODt9bW9kZXw9ODE5MjtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLGRldil9KSxzeW1saW5rOihmdW5jdGlvbihvbGRwYXRoLG5ld3BhdGgpe2lmKCFQQVRILnJlc29sdmUob2xkcGF0aCkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKG5ld3BhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTtpZighcGFyZW50KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpfXZhciBuZXduYW1lPVBBVEguYmFzZW5hbWUobmV3cGF0aCk7dmFyIGVycj1GUy5tYXlDcmVhdGUocGFyZW50LG5ld25hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX1pZighcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1yZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LG5ld25hbWUsb2xkcGF0aCl9KSxyZW5hbWU6KGZ1bmN0aW9uKG9sZF9wYXRoLG5ld19wYXRoKXt2YXIgb2xkX2Rpcm5hbWU9UEFUSC5kaXJuYW1lKG9sZF9wYXRoKTt2YXIgbmV3X2Rpcm5hbWU9UEFUSC5kaXJuYW1lKG5ld19wYXRoKTt2YXIgb2xkX25hbWU9UEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7dmFyIG5ld19uYW1lPVBBVEguYmFzZW5hbWUobmV3X3BhdGgpO3ZhciBsb29rdXAsb2xkX2RpcixuZXdfZGlyO3RyeXtsb29rdXA9RlMubG9va3VwUGF0aChvbGRfcGF0aCx7cGFyZW50OnRydWV9KTtvbGRfZGlyPWxvb2t1cC5ub2RlO2xvb2t1cD1GUy5sb29rdXBQYXRoKG5ld19wYXRoLHtwYXJlbnQ6dHJ1ZX0pO25ld19kaXI9bG9va3VwLm5vZGU7fWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX1pZighb2xkX2Rpcnx8IW5ld19kaXIpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKTtpZihvbGRfZGlyLm1vdW50IT09bmV3X2Rpci5tb3VudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVhERVYpfXZhciBvbGRfbm9kZT1GUy5sb29rdXBOb2RlKG9sZF9kaXIsb2xkX25hbWUpO3ZhciByZWxhdGl2ZT1QQVRILnJlbGF0aXZlKG9sZF9wYXRoLG5ld19kaXJuYW1lKTtpZihyZWxhdGl2ZS5jaGFyQXQoMCkhPT0iLiIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9cmVsYXRpdmU9UEFUSC5yZWxhdGl2ZShuZXdfcGF0aCxvbGRfZGlybmFtZSk7aWYocmVsYXRpdmUuY2hhckF0KDApIT09Ii4iKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URU1QVFkpfXZhciBuZXdfbm9kZTt0cnl7bmV3X25vZGU9RlMubG9va3VwTm9kZShuZXdfZGlyLG5ld19uYW1lKTt9Y2F0Y2goZSl7fWlmKG9sZF9ub2RlPT09bmV3X25vZGUpe3JldHVybn12YXIgaXNkaXI9RlMuaXNEaXIob2xkX25vZGUubW9kZSk7dmFyIGVycj1GUy5tYXlEZWxldGUob2xkX2RpcixvbGRfbmFtZSxpc2Rpcik7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfWVycj1uZXdfbm9kZT9GUy5tYXlEZWxldGUobmV3X2RpcixuZXdfbmFtZSxpc2Rpcik6RlMubWF5Q3JlYXRlKG5ld19kaXIsbmV3X25hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX1pZighb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1pZihGUy5pc01vdW50cG9pbnQob2xkX25vZGUpfHxuZXdfbm9kZSYmRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfWlmKG5ld19kaXIhPT1vbGRfZGlyKXtlcnI9RlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsInciKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9fXRyeXtpZihGUy50cmFja2luZ0RlbGVnYXRlWyJ3aWxsTW92ZVBhdGgiXSl7RlMudHJhY2tpbmdEZWxlZ2F0ZVsid2lsbE1vdmVQYXRoIl0ob2xkX3BhdGgsbmV3X3BhdGgpO319Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxNb3ZlUGF0aCddKCciK29sZF9wYXRoKyInLCAnIituZXdfcGF0aCsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK2UubWVzc2FnZSk7fUZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTt0cnl7b2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsbmV3X2RpcixuZXdfbmFtZSk7fWNhdGNoKGUpe3Rocm93IGV9ZmluYWxseXtGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSk7fXRyeXtpZihGUy50cmFja2luZ0RlbGVnYXRlWyJvbk1vdmVQYXRoIl0pRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25Nb3ZlUGF0aCJdKG9sZF9wYXRoLG5ld19wYXRoKTt9Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uTW92ZVBhdGgnXSgnIitvbGRfcGF0aCsiJywgJyIrbmV3X3BhdGgrIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpO319KSxybWRpcjooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTt2YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO3ZhciBub2RlPUZTLmxvb2t1cE5vZGUocGFyZW50LG5hbWUpO3ZhciBlcnI9RlMubWF5RGVsZXRlKHBhcmVudCxuYW1lLHRydWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX1pZighcGFyZW50Lm5vZGVfb3BzLnJtZGlyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9aWYoRlMuaXNNb3VudHBvaW50KG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSl9dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbIndpbGxEZWxldGVQYXRoIl0pe0ZTLnRyYWNraW5nRGVsZWdhdGVbIndpbGxEZWxldGVQYXRoIl0ocGF0aCk7fX1jYXRjaChlKXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXSgnIitwYXRoKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKTt9cGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCxuYW1lKTtGUy5kZXN0cm95Tm9kZShub2RlKTt0cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25EZWxldGVQYXRoIl0pRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25EZWxldGVQYXRoIl0ocGF0aCk7fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbkRlbGV0ZVBhdGgnXSgnIitwYXRoKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKTt9fSkscmVhZGRpcjooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7aWYoIW5vZGUubm9kZV9vcHMucmVhZGRpcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9cmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKX0pLHVubGluazooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTt2YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO3ZhciBub2RlPUZTLmxvb2t1cE5vZGUocGFyZW50LG5hbWUpO3ZhciBlcnI9RlMubWF5RGVsZXRlKHBhcmVudCxuYW1lLGZhbHNlKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9aWYoIXBhcmVudC5ub2RlX29wcy51bmxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1pZihGUy5pc01vdW50cG9pbnQobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX10cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZVsid2lsbERlbGV0ZVBhdGgiXSl7RlMudHJhY2tpbmdEZWxlZ2F0ZVsid2lsbERlbGV0ZVBhdGgiXShwYXRoKTt9fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKCciK3BhdGgrIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpO31wYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCxuYW1lKTtGUy5kZXN0cm95Tm9kZShub2RlKTt0cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25EZWxldGVQYXRoIl0pRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25EZWxldGVQYXRoIl0ocGF0aCk7fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbkRlbGV0ZVBhdGgnXSgnIitwYXRoKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKTt9fSkscmVhZGxpbms6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoKTt2YXIgbGluaz1sb29rdXAubm9kZTtpZighbGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX1pZighbGluay5ub2RlX29wcy5yZWFkbGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1yZXR1cm4gUEFUSC5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluaykpfSksc3RhdDooZnVuY3Rpb24ocGF0aCxkb250Rm9sbG93KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250Rm9sbG93fSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7aWYoIW5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9aWYoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfXJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSl9KSxsc3RhdDooZnVuY3Rpb24ocGF0aCl7cmV0dXJuIEZTLnN0YXQocGF0aCx0cnVlKX0pLGNobW9kOihmdW5jdGlvbihwYXRoLG1vZGUsZG9udEZvbGxvdyl7dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PT0ic3RyaW5nIil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO25vZGU9bG9va3VwLm5vZGU7fWVsc2Uge25vZGU9cGF0aDt9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfW5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHttb2RlOm1vZGUmNDA5NXxub2RlLm1vZGUmfjQwOTUsdGltZXN0YW1wOkRhdGUubm93KCl9KTt9KSxsY2htb2Q6KGZ1bmN0aW9uKHBhdGgsbW9kZSl7RlMuY2htb2QocGF0aCxtb2RlLHRydWUpO30pLGZjaG1vZDooZnVuY3Rpb24oZmQsbW9kZSl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1GUy5jaG1vZChzdHJlYW0ubm9kZSxtb2RlKTt9KSxjaG93bjooZnVuY3Rpb24ocGF0aCx1aWQsZ2lkLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09InN0cmluZyIpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRGb2xsb3d9KTtub2RlPWxvb2t1cC5ub2RlO31lbHNlIHtub2RlPXBhdGg7fWlmKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1ub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSx7dGltZXN0YW1wOkRhdGUubm93KCl9KTt9KSxsY2hvd246KGZ1bmN0aW9uKHBhdGgsdWlkLGdpZCl7RlMuY2hvd24ocGF0aCx1aWQsZ2lkLHRydWUpO30pLGZjaG93bjooZnVuY3Rpb24oZmQsdWlkLGdpZCl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1GUy5jaG93bihzdHJlYW0ubm9kZSx1aWQsZ2lkKTt9KSx0cnVuY2F0ZTooZnVuY3Rpb24ocGF0aCxsZW4pe2lmKGxlbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfXZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09InN0cmluZyIpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO25vZGU9bG9va3VwLm5vZGU7fWVsc2Uge25vZGU9cGF0aDt9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfWlmKEZTLmlzRGlyKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUil9aWYoIUZTLmlzRmlsZShub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfXZhciBlcnI9RlMubm9kZVBlcm1pc3Npb25zKG5vZGUsInciKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3NpemU6bGVuLHRpbWVzdGFtcDpEYXRlLm5vdygpfSk7fSksZnRydW5jYXRlOihmdW5jdGlvbihmZCxsZW4pe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtKGZkKTtpZighc3RyZWFtKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9RlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsbGVuKTt9KSx1dGltZTooZnVuY3Rpb24ocGF0aCxhdGltZSxtdGltZSl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3RpbWVzdGFtcDpNYXRoLm1heChhdGltZSxtdGltZSl9KTt9KSxvcGVuOihmdW5jdGlvbihwYXRoLGZsYWdzLG1vZGUsZmRfc3RhcnQsZmRfZW5kKXtpZihwYXRoPT09IiIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9ZmxhZ3M9dHlwZW9mIGZsYWdzPT09InN0cmluZyI/RlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpOmZsYWdzO21vZGU9dHlwZW9mIG1vZGU9PT0idW5kZWZpbmVkIj80Mzg6bW9kZTtpZihmbGFncyY2NCl7bW9kZT1tb2RlJjQwOTV8MzI3Njg7fWVsc2Uge21vZGU9MDt9dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PT0ib2JqZWN0Iil7bm9kZT1wYXRoO31lbHNlIHtwYXRoPVBBVEgubm9ybWFsaXplKHBhdGgpO3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiEoZmxhZ3MmMTMxMDcyKX0pO25vZGU9bG9va3VwLm5vZGU7fWNhdGNoKGUpe319dmFyIGNyZWF0ZWQ9ZmFsc2U7aWYoZmxhZ3MmNjQpe2lmKG5vZGUpe2lmKGZsYWdzJjEyOCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUVYSVNUKX19ZWxzZSB7bm9kZT1GUy5ta25vZChwYXRoLG1vZGUsMCk7Y3JlYXRlZD10cnVlO319aWYoIW5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9aWYoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSl7ZmxhZ3MmPX41MTI7fWlmKGZsYWdzJjY1NTM2JiYhRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9aWYoIWNyZWF0ZWQpe3ZhciBlcnI9RlMubWF5T3Blbihub2RlLGZsYWdzKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9fWlmKGZsYWdzJjUxMil7RlMudHJ1bmNhdGUobm9kZSwwKTt9ZmxhZ3MmPX4oMTI4fDUxMik7dmFyIHN0cmVhbT1GUy5jcmVhdGVTdHJlYW0oe25vZGU6bm9kZSxwYXRoOkZTLmdldFBhdGgobm9kZSksZmxhZ3M6ZmxhZ3Msc2Vla2FibGU6dHJ1ZSxwb3NpdGlvbjowLHN0cmVhbV9vcHM6bm9kZS5zdHJlYW1fb3BzLHVuZ290dGVuOltdLGVycm9yOmZhbHNlfSxmZF9zdGFydCxmZF9lbmQpO2lmKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pe3N0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTt9aWYoTW9kdWxlWyJsb2dSZWFkRmlsZXMiXSYmIShmbGFncyYxKSl7aWYoIUZTLnJlYWRGaWxlcylGUy5yZWFkRmlsZXM9e307aWYoIShwYXRoIGluIEZTLnJlYWRGaWxlcykpe0ZTLnJlYWRGaWxlc1twYXRoXT0xO01vZHVsZVsicHJpbnRFcnIiXSgicmVhZCBmaWxlOiAiK3BhdGgpO319dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbIm9uT3BlbkZpbGUiXSl7dmFyIHRyYWNraW5nRmxhZ3M9MDtpZigoZmxhZ3MmMjA5NzE1NSkhPT0xKXt0cmFja2luZ0ZsYWdzfD1GUy50cmFja2luZy5vcGVuRmxhZ3MuUkVBRDt9aWYoKGZsYWdzJjIwOTcxNTUpIT09MCl7dHJhY2tpbmdGbGFnc3w9RlMudHJhY2tpbmcub3BlbkZsYWdzLldSSVRFO31GUy50cmFja2luZ0RlbGVnYXRlWyJvbk9wZW5GaWxlIl0ocGF0aCx0cmFja2luZ0ZsYWdzKTt9fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbk9wZW5GaWxlJ10oJyIrcGF0aCsiJywgZmxhZ3MpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpO31yZXR1cm4gc3RyZWFtfSksY2xvc2U6KGZ1bmN0aW9uKHN0cmVhbSl7aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKHN0cmVhbS5nZXRkZW50cylzdHJlYW0uZ2V0ZGVudHM9bnVsbDt0cnl7aWYoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Upe3N0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7fX1jYXRjaChlKXt0aHJvdyBlfWZpbmFsbHl7RlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTt9c3RyZWFtLmZkPW51bGw7fSksaXNDbG9zZWQ6KGZ1bmN0aW9uKHN0cmVhbSl7cmV0dXJuIHN0cmVhbS5mZD09PW51bGx9KSxsbHNlZWs6KGZ1bmN0aW9uKHN0cmVhbSxvZmZzZXQsd2hlbmNlKXtpZihGUy5pc0Nsb3NlZChzdHJlYW0pKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoIXN0cmVhbS5zZWVrYWJsZXx8IXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX1zdHJlYW0ucG9zaXRpb249c3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSxvZmZzZXQsd2hlbmNlKTtzdHJlYW0udW5nb3R0ZW49W107cmV0dXJuIHN0cmVhbS5wb3NpdGlvbn0pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7aWYobGVuZ3RoPDB8fHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0xKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUil9aWYoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIHNlZWtpbmc9dHlwZW9mIHBvc2l0aW9uIT09InVuZGVmaW5lZCI7aWYoIXNlZWtpbmcpe3Bvc2l0aW9uPXN0cmVhbS5wb3NpdGlvbjt9ZWxzZSBpZighc3RyZWFtLnNlZWthYmxlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FU1BJUEUpfXZhciBieXRlc1JlYWQ9c3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pO2lmKCFzZWVraW5nKXN0cmVhbS5wb3NpdGlvbis9Ynl0ZXNSZWFkO3JldHVybiBieXRlc1JlYWR9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uLGNhbk93bil7aWYobGVuZ3RoPDB8fHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUil9aWYoIXN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfWlmKHN0cmVhbS5mbGFncyYxMDI0KXtGUy5sbHNlZWsoc3RyZWFtLDAsMik7fXZhciBzZWVraW5nPXR5cGVvZiBwb3NpdGlvbiE9PSJ1bmRlZmluZWQiO2lmKCFzZWVraW5nKXtwb3NpdGlvbj1zdHJlYW0ucG9zaXRpb247fWVsc2UgaWYoIXN0cmVhbS5zZWVrYWJsZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX12YXIgYnl0ZXNXcml0dGVuPXN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixjYW5Pd24pO2lmKCFzZWVraW5nKXN0cmVhbS5wb3NpdGlvbis9Ynl0ZXNXcml0dGVuO3RyeXtpZihzdHJlYW0ucGF0aCYmRlMudHJhY2tpbmdEZWxlZ2F0ZVsib25Xcml0ZVRvRmlsZSJdKUZTLnRyYWNraW5nRGVsZWdhdGVbIm9uV3JpdGVUb0ZpbGUiXShzdHJlYW0ucGF0aCk7fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbldyaXRlVG9GaWxlJ10oJyIrcGF0aCsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK2UubWVzc2FnZSk7fXJldHVybiBieXRlc1dyaXR0ZW59KSxhbGxvY2F0ZTooZnVuY3Rpb24oc3RyZWFtLG9mZnNldCxsZW5ndGgpe2lmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1pZihvZmZzZXQ8MHx8bGVuZ3RoPD0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSYmIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU9QTk9UU1VQUCl9c3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLG9mZnNldCxsZW5ndGgpO30pLG1tYXA6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUFDQ0VTKX1pZighc3RyZWFtLnN0cmVhbV9vcHMubW1hcCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKX1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl9KSxtc3luYzooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl7aWYoIXN0cmVhbXx8IXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKXtyZXR1cm4gMH1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl9KSxtdW5tYXA6KGZ1bmN0aW9uKHN0cmVhbSl7cmV0dXJuIDB9KSxpb2N0bDooZnVuY3Rpb24oc3RyZWFtLGNtZCxhcmcpe2lmKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVFRZKX1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLGNtZCxhcmcpfSkscmVhZEZpbGU6KGZ1bmN0aW9uKHBhdGgsb3B0cyl7b3B0cz1vcHRzfHx7fTtvcHRzLmZsYWdzPW9wdHMuZmxhZ3N8fCJyIjtvcHRzLmVuY29kaW5nPW9wdHMuZW5jb2Rpbmd8fCJiaW5hcnkiO2lmKG9wdHMuZW5jb2RpbmchPT0idXRmOCImJm9wdHMuZW5jb2RpbmchPT0iYmluYXJ5Iil7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHR5cGUgIicrb3B0cy5lbmNvZGluZysnIicpfXZhciByZXQ7dmFyIHN0cmVhbT1GUy5vcGVuKHBhdGgsb3B0cy5mbGFncyk7dmFyIHN0YXQ9RlMuc3RhdChwYXRoKTt2YXIgbGVuZ3RoPXN0YXQuc2l6ZTt2YXIgYnVmPW5ldyBVaW50OEFycmF5KGxlbmd0aCk7RlMucmVhZChzdHJlYW0sYnVmLDAsbGVuZ3RoLDApO2lmKG9wdHMuZW5jb2Rpbmc9PT0idXRmOCIpe3JldD1VVEY4QXJyYXlUb1N0cmluZyhidWYsMCk7fWVsc2UgaWYob3B0cy5lbmNvZGluZz09PSJiaW5hcnkiKXtyZXQ9YnVmO31GUy5jbG9zZShzdHJlYW0pO3JldHVybiByZXR9KSx3cml0ZUZpbGU6KGZ1bmN0aW9uKHBhdGgsZGF0YSxvcHRzKXtvcHRzPW9wdHN8fHt9O29wdHMuZmxhZ3M9b3B0cy5mbGFnc3x8InciO3ZhciBzdHJlYW09RlMub3BlbihwYXRoLG9wdHMuZmxhZ3Msb3B0cy5tb2RlKTtpZih0eXBlb2YgZGF0YT09PSJzdHJpbmciKXt2YXIgYnVmPW5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSsxKTt2YXIgYWN0dWFsTnVtQnl0ZXM9c3RyaW5nVG9VVEY4QXJyYXkoZGF0YSxidWYsMCxidWYubGVuZ3RoKTtGUy53cml0ZShzdHJlYW0sYnVmLDAsYWN0dWFsTnVtQnl0ZXMsdW5kZWZpbmVkLG9wdHMuY2FuT3duKTt9ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpe0ZTLndyaXRlKHN0cmVhbSxkYXRhLDAsZGF0YS5ieXRlTGVuZ3RoLHVuZGVmaW5lZCxvcHRzLmNhbk93bik7fWVsc2Uge3Rocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIil9RlMuY2xvc2Uoc3RyZWFtKTt9KSxjd2Q6KGZ1bmN0aW9uKCl7cmV0dXJuIEZTLmN1cnJlbnRQYXRofSksY2hkaXI6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO2lmKGxvb2t1cC5ub2RlPT09bnVsbCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX1pZighRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpfXZhciBlcnI9RlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCJ4Iik7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfUZTLmN1cnJlbnRQYXRoPWxvb2t1cC5wYXRoO30pLGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczooZnVuY3Rpb24oKXtGUy5ta2RpcigiL3RtcCIpO0ZTLm1rZGlyKCIvaG9tZSIpO0ZTLm1rZGlyKCIvaG9tZS93ZWJfdXNlciIpO30pLGNyZWF0ZURlZmF1bHREZXZpY2VzOihmdW5jdGlvbigpe0ZTLm1rZGlyKCIvZGV2Iik7RlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLDMpLHtyZWFkOihmdW5jdGlvbigpe3JldHVybiAwfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe3JldHVybiBsZW5ndGh9KX0pO0ZTLm1rZGV2KCIvZGV2L251bGwiLEZTLm1ha2VkZXYoMSwzKSk7VFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwwKSxUVFkuZGVmYXVsdF90dHlfb3BzKTtUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LDApLFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtGUy5ta2RldigiL2Rldi90dHkiLEZTLm1ha2VkZXYoNSwwKSk7RlMubWtkZXYoIi9kZXYvdHR5MSIsRlMubWFrZWRldig2LDApKTt2YXIgcmFuZG9tX2RldmljZTtpZih0eXBlb2YgY3J5cHRvIT09InVuZGVmaW5lZCIpe3ZhciByYW5kb21CdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMSk7cmFuZG9tX2RldmljZT0oZnVuY3Rpb24oKXtjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7cmV0dXJuIHJhbmRvbUJ1ZmZlclswXX0pO31lbHNlIGlmKEVOVklST05NRU5UX0lTX05PREUpe3JhbmRvbV9kZXZpY2U9KGZ1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoImNyeXB0byIpWyJyYW5kb21CeXRlcyJdKDEpWzBdfSk7fWVsc2Uge3JhbmRvbV9kZXZpY2U9KGZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkqMjU2fDB9KTt9RlMuY3JlYXRlRGV2aWNlKCIvZGV2IiwicmFuZG9tIixyYW5kb21fZGV2aWNlKTtGUy5jcmVhdGVEZXZpY2UoIi9kZXYiLCJ1cmFuZG9tIixyYW5kb21fZGV2aWNlKTtGUy5ta2RpcigiL2Rldi9zaG0iKTtGUy5ta2RpcigiL2Rldi9zaG0vdG1wIik7fSksY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOihmdW5jdGlvbigpe0ZTLm1rZGlyKCIvcHJvYyIpO0ZTLm1rZGlyKCIvcHJvYy9zZWxmIik7RlMubWtkaXIoIi9wcm9jL3NlbGYvZmQiKTtGUy5tb3VudCh7bW91bnQ6KGZ1bmN0aW9uKCl7dmFyIG5vZGU9RlMuY3JlYXRlTm9kZSgiL3Byb2Mvc2VsZiIsImZkIiwxNjM4NHw1MTEsNzMpO25vZGUubm9kZV9vcHM9e2xvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3ZhciBmZD0rbmFtZTt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShmZCk7aWYoIXN0cmVhbSl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERik7dmFyIHJldD17cGFyZW50Om51bGwsbW91bnQ6e21vdW50cG9pbnQ6ImZha2UifSxub2RlX29wczp7cmVhZGxpbms6KGZ1bmN0aW9uKCl7cmV0dXJuIHN0cmVhbS5wYXRofSl9fTtyZXQucGFyZW50PXJldDtyZXR1cm4gcmV0fSl9O3JldHVybiBub2RlfSl9LHt9LCIvcHJvYy9zZWxmL2ZkIik7fSksY3JlYXRlU3RhbmRhcmRTdHJlYW1zOihmdW5jdGlvbigpe2lmKE1vZHVsZVsic3RkaW4iXSl7RlMuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkaW4iLE1vZHVsZVsic3RkaW4iXSk7fWVsc2Uge0ZTLnN5bWxpbmsoIi9kZXYvdHR5IiwiL2Rldi9zdGRpbiIpO31pZihNb2R1bGVbInN0ZG91dCJdKXtGUy5jcmVhdGVEZXZpY2UoIi9kZXYiLCJzdGRvdXQiLG51bGwsTW9kdWxlWyJzdGRvdXQiXSk7fWVsc2Uge0ZTLnN5bWxpbmsoIi9kZXYvdHR5IiwiL2Rldi9zdGRvdXQiKTt9aWYoTW9kdWxlWyJzdGRlcnIiXSl7RlMuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkZXJyIixudWxsLE1vZHVsZVsic3RkZXJyIl0pO31lbHNlIHtGUy5zeW1saW5rKCIvZGV2L3R0eTEiLCIvZGV2L3N0ZGVyciIpO312YXIgc3RkaW49RlMub3BlbigiL2Rldi9zdGRpbiIsInIiKTthc3NlcnQoc3RkaW4uZmQ9PT0wLCJpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW4gKCIrc3RkaW4uZmQrIikiKTt2YXIgc3Rkb3V0PUZTLm9wZW4oIi9kZXYvc3Rkb3V0IiwidyIpO2Fzc2VydChzdGRvdXQuZmQ9PT0xLCJpbnZhbGlkIGhhbmRsZSBmb3Igc3Rkb3V0ICgiK3N0ZG91dC5mZCsiKSIpO3ZhciBzdGRlcnI9RlMub3BlbigiL2Rldi9zdGRlcnIiLCJ3Iik7YXNzZXJ0KHN0ZGVyci5mZD09PTIsImludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCIrc3RkZXJyLmZkKyIpIik7fSksZW5zdXJlRXJybm9FcnJvcjooZnVuY3Rpb24oKXtpZihGUy5FcnJub0Vycm9yKXJldHVybjtGUy5FcnJub0Vycm9yPWZ1bmN0aW9uIEVycm5vRXJyb3IoZXJybm8sbm9kZSl7dGhpcy5ub2RlPW5vZGU7dGhpcy5zZXRFcnJubz0oZnVuY3Rpb24oZXJybm8pe3RoaXMuZXJybm89ZXJybm87Zm9yKHZhciBrZXkgaW4gRVJSTk9fQ09ERVMpe2lmKEVSUk5PX0NPREVTW2tleV09PT1lcnJubyl7dGhpcy5jb2RlPWtleTticmVha319fSk7dGhpcy5zZXRFcnJubyhlcnJubyk7dGhpcy5tZXNzYWdlPUVSUk5PX01FU1NBR0VTW2Vycm5vXTtpZih0aGlzLnN0YWNrKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdGFjayIse3ZhbHVlOihuZXcgRXJyb3IpLnN0YWNrLHdyaXRhYmxlOnRydWV9KTt9O0ZTLkVycm5vRXJyb3IucHJvdG90eXBlPW5ldyBFcnJvcjtGUy5FcnJub0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1GUy5FcnJub0Vycm9yO1tFUlJOT19DT0RFUy5FTk9FTlRdLmZvckVhY2goKGZ1bmN0aW9uKGNvZGUpe0ZTLmdlbmVyaWNFcnJvcnNbY29kZV09bmV3IEZTLkVycm5vRXJyb3IoY29kZSk7RlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjaz0iPGdlbmVyaWMgZXJyb3IsIG5vIHN0YWNrPiI7fSkpO30pLHN0YXRpY0luaXQ6KGZ1bmN0aW9uKCl7RlMuZW5zdXJlRXJybm9FcnJvcigpO0ZTLm5hbWVUYWJsZT1uZXcgQXJyYXkoNDA5Nik7RlMubW91bnQoTUVNRlMse30sIi8iKTtGUy5jcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKTtGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO0ZTLmNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpO0ZTLmZpbGVzeXN0ZW1zPXsiTUVNRlMiOk1FTUZTLCJJREJGUyI6SURCRlMsIk5PREVGUyI6Tk9ERUZTLCJXT1JLRVJGUyI6V09SS0VSRlN9O30pLGluaXQ6KGZ1bmN0aW9uKGlucHV0LG91dHB1dCxlcnJvcil7YXNzZXJ0KCFGUy5pbml0LmluaXRpYWxpemVkLCJGUy5pbml0IHdhcyBwcmV2aW91c2x5IGNhbGxlZC4gSWYgeW91IHdhbnQgdG8gaW5pdGlhbGl6ZSBsYXRlciB3aXRoIGN1c3RvbSBwYXJhbWV0ZXJzLCByZW1vdmUgYW55IGVhcmxpZXIgY2FsbHMgKG5vdGUgdGhhdCBvbmUgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgZ2VuZXJhdGVkIGNvZGUpIik7RlMuaW5pdC5pbml0aWFsaXplZD10cnVlO0ZTLmVuc3VyZUVycm5vRXJyb3IoKTtNb2R1bGVbInN0ZGluIl09aW5wdXR8fE1vZHVsZVsic3RkaW4iXTtNb2R1bGVbInN0ZG91dCJdPW91dHB1dHx8TW9kdWxlWyJzdGRvdXQiXTtNb2R1bGVbInN0ZGVyciJdPWVycm9yfHxNb2R1bGVbInN0ZGVyciJdO0ZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcygpO30pLHF1aXQ6KGZ1bmN0aW9uKCl7RlMuaW5pdC5pbml0aWFsaXplZD1mYWxzZTt2YXIgZmZsdXNoPU1vZHVsZVsiX2ZmbHVzaCJdO2lmKGZmbHVzaClmZmx1c2goMCk7Zm9yKHZhciBpPTA7aTxGUy5zdHJlYW1zLmxlbmd0aDtpKyspe3ZhciBzdHJlYW09RlMuc3RyZWFtc1tpXTtpZighc3RyZWFtKXtjb250aW51ZX1GUy5jbG9zZShzdHJlYW0pO319KSxnZXRNb2RlOihmdW5jdGlvbihjYW5SZWFkLGNhbldyaXRlKXt2YXIgbW9kZT0wO2lmKGNhblJlYWQpbW9kZXw9MjkyfDczO2lmKGNhbldyaXRlKW1vZGV8PTE0NjtyZXR1cm4gbW9kZX0pLGpvaW5QYXRoOihmdW5jdGlvbihwYXJ0cyxmb3JjZVJlbGF0aXZlKXt2YXIgcGF0aD1QQVRILmpvaW4uYXBwbHkobnVsbCxwYXJ0cyk7aWYoZm9yY2VSZWxhdGl2ZSYmcGF0aFswXT09Ii8iKXBhdGg9cGF0aC5zdWJzdHIoMSk7cmV0dXJuIHBhdGh9KSxhYnNvbHV0ZVBhdGg6KGZ1bmN0aW9uKHJlbGF0aXZlLGJhc2Upe3JldHVybiBQQVRILnJlc29sdmUoYmFzZSxyZWxhdGl2ZSl9KSxzdGFuZGFyZGl6ZVBhdGg6KGZ1bmN0aW9uKHBhdGgpe3JldHVybiBQQVRILm5vcm1hbGl6ZShwYXRoKX0pLGZpbmRPYmplY3Q6KGZ1bmN0aW9uKHBhdGgsZG9udFJlc29sdmVMYXN0TGluayl7dmFyIHJldD1GUy5hbmFseXplUGF0aChwYXRoLGRvbnRSZXNvbHZlTGFzdExpbmspO2lmKHJldC5leGlzdHMpe3JldHVybiByZXQub2JqZWN0fWVsc2Uge19fX3NldEVyck5vKHJldC5lcnJvcik7cmV0dXJuIG51bGx9fSksYW5hbHl6ZVBhdGg6KGZ1bmN0aW9uKHBhdGgsZG9udFJlc29sdmVMYXN0TGluayl7dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRSZXNvbHZlTGFzdExpbmt9KTtwYXRoPWxvb2t1cC5wYXRoO31jYXRjaChlKXt9dmFyIHJldD17aXNSb290OmZhbHNlLGV4aXN0czpmYWxzZSxlcnJvcjowLG5hbWU6bnVsbCxwYXRoOm51bGwsb2JqZWN0Om51bGwscGFyZW50RXhpc3RzOmZhbHNlLHBhcmVudFBhdGg6bnVsbCxwYXJlbnRPYmplY3Q6bnVsbH07dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3JldC5wYXJlbnRFeGlzdHM9dHJ1ZTtyZXQucGFyZW50UGF0aD1sb29rdXAucGF0aDtyZXQucGFyZW50T2JqZWN0PWxvb2t1cC5ub2RlO3JldC5uYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7bG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250UmVzb2x2ZUxhc3RMaW5rfSk7cmV0LmV4aXN0cz10cnVlO3JldC5wYXRoPWxvb2t1cC5wYXRoO3JldC5vYmplY3Q9bG9va3VwLm5vZGU7cmV0Lm5hbWU9bG9va3VwLm5vZGUubmFtZTtyZXQuaXNSb290PWxvb2t1cC5wYXRoPT09Ii8iO31jYXRjaChlKXtyZXQuZXJyb3I9ZS5lcnJubzt9cmV0dXJuIHJldH0pLGNyZWF0ZUZvbGRlcjooZnVuY3Rpb24ocGFyZW50LG5hbWUsY2FuUmVhZCxjYW5Xcml0ZSl7dmFyIHBhdGg9UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT09InN0cmluZyI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KSxuYW1lKTt2YXIgbW9kZT1GUy5nZXRNb2RlKGNhblJlYWQsY2FuV3JpdGUpO3JldHVybiBGUy5ta2RpcihwYXRoLG1vZGUpfSksY3JlYXRlUGF0aDooZnVuY3Rpb24ocGFyZW50LHBhdGgsY2FuUmVhZCxjYW5Xcml0ZSl7cGFyZW50PXR5cGVvZiBwYXJlbnQ9PT0ic3RyaW5nIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpO3ZhciBwYXJ0cz1wYXRoLnNwbGl0KCIvIikucmV2ZXJzZSgpO3doaWxlKHBhcnRzLmxlbmd0aCl7dmFyIHBhcnQ9cGFydHMucG9wKCk7aWYoIXBhcnQpY29udGludWU7dmFyIGN1cnJlbnQ9UEFUSC5qb2luMihwYXJlbnQscGFydCk7dHJ5e0ZTLm1rZGlyKGN1cnJlbnQpO31jYXRjaChlKXt9cGFyZW50PWN1cnJlbnQ7fXJldHVybiBjdXJyZW50fSksY3JlYXRlRmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUscHJvcGVydGllcyxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT0ic3RyaW5nIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPUZTLmdldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7cmV0dXJuIEZTLmNyZWF0ZShwYXRoLG1vZGUpfSksY3JlYXRlRGF0YUZpbGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLGRhdGEsY2FuUmVhZCxjYW5Xcml0ZSxjYW5Pd24pe3ZhciBwYXRoPW5hbWU/UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT09InN0cmluZyI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KSxuYW1lKTpwYXJlbnQ7dmFyIG1vZGU9RlMuZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTt2YXIgbm9kZT1GUy5jcmVhdGUocGF0aCxtb2RlKTtpZihkYXRhKXtpZih0eXBlb2YgZGF0YT09PSJzdHJpbmciKXt2YXIgYXJyPW5ldyBBcnJheShkYXRhLmxlbmd0aCk7Zm9yKHZhciBpPTAsbGVuPWRhdGEubGVuZ3RoO2k8bGVuOysraSlhcnJbaV09ZGF0YS5jaGFyQ29kZUF0KGkpO2RhdGE9YXJyO31GUy5jaG1vZChub2RlLG1vZGV8MTQ2KTt2YXIgc3RyZWFtPUZTLm9wZW4obm9kZSwidyIpO0ZTLndyaXRlKHN0cmVhbSxkYXRhLDAsZGF0YS5sZW5ndGgsMCxjYW5Pd24pO0ZTLmNsb3NlKHN0cmVhbSk7RlMuY2htb2Qobm9kZSxtb2RlKTt9cmV0dXJuIG5vZGV9KSxjcmVhdGVEZXZpY2U6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLGlucHV0LG91dHB1dCl7dmFyIHBhdGg9UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT09InN0cmluZyI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KSxuYW1lKTt2YXIgbW9kZT1GUy5nZXRNb2RlKCEhaW5wdXQsISFvdXRwdXQpO2lmKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpRlMuY3JlYXRlRGV2aWNlLm1ham9yPTY0O3ZhciBkZXY9RlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywwKTtGUy5yZWdpc3RlckRldmljZShkZXYse29wZW46KGZ1bmN0aW9uKHN0cmVhbSl7c3RyZWFtLnNlZWthYmxlPWZhbHNlO30pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe2lmKG91dHB1dCYmb3V0cHV0LmJ1ZmZlciYmb3V0cHV0LmJ1ZmZlci5sZW5ndGgpe291dHB1dCgxMCk7fX0pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe3ZhciBieXRlc1JlYWQ9MDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciByZXN1bHQ7dHJ5e3Jlc3VsdD1pbnB1dCgpO31jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfWlmKHJlc3VsdD09PXVuZGVmaW5lZCYmYnl0ZXNSZWFkPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUFHQUlOKX1pZihyZXN1bHQ9PT1udWxsfHxyZXN1bHQ9PT11bmRlZmluZWQpYnJlYWs7Ynl0ZXNSZWFkKys7YnVmZmVyW29mZnNldCtpXT1yZXN1bHQ7fWlmKGJ5dGVzUmVhZCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCk7fXJldHVybiBieXRlc1JlYWR9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt0cnl7b3V0cHV0KGJ1ZmZlcltvZmZzZXQraV0pO31jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfX1pZihsZW5ndGgpe3N0cmVhbS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpO31yZXR1cm4gaX0pfSk7cmV0dXJuIEZTLm1rZGV2KHBhdGgsbW9kZSxkZXYpfSksY3JlYXRlTGluazooZnVuY3Rpb24ocGFyZW50LG5hbWUsdGFyZ2V0LGNhblJlYWQsY2FuV3JpdGUpe3ZhciBwYXRoPVBBVEguam9pbjIodHlwZW9mIHBhcmVudD09PSJzdHJpbmciP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7cmV0dXJuIEZTLnN5bWxpbmsodGFyZ2V0LHBhdGgpfSksZm9yY2VMb2FkRmlsZTooZnVuY3Rpb24ob2JqKXtpZihvYmouaXNEZXZpY2V8fG9iai5pc0ZvbGRlcnx8b2JqLmxpbmt8fG9iai5jb250ZW50cylyZXR1cm4gdHJ1ZTt2YXIgc3VjY2Vzcz10cnVlO2lmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCE9PSJ1bmRlZmluZWQiKXt0aHJvdyBuZXcgRXJyb3IoIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLiIpfWVsc2UgaWYoTW9kdWxlWyJyZWFkIl0pe3RyeXtvYmouY29udGVudHM9aW50QXJyYXlGcm9tU3RyaW5nKE1vZHVsZVsicmVhZCJdKG9iai51cmwpLHRydWUpO29iai51c2VkQnl0ZXM9b2JqLmNvbnRlbnRzLmxlbmd0aDt9Y2F0Y2goZSl7c3VjY2Vzcz1mYWxzZTt9fWVsc2Uge3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IGxvYWQgd2l0aG91dCByZWFkKCkgb3IgWE1MSHR0cFJlcXVlc3QuIil9aWYoIXN1Y2Nlc3MpX19fc2V0RXJyTm8oRVJSTk9fQ09ERVMuRUlPKTtyZXR1cm4gc3VjY2Vzc30pLGNyZWF0ZUxhenlGaWxlOihmdW5jdGlvbihwYXJlbnQsbmFtZSx1cmwsY2FuUmVhZCxjYW5Xcml0ZSl7ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXkoKXt0aGlzLmxlbmd0aEtub3duPWZhbHNlO3RoaXMuY2h1bmtzPVtdO31MYXp5VWludDhBcnJheS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uIExhenlVaW50OEFycmF5X2dldChpZHgpe2lmKGlkeD50aGlzLmxlbmd0aC0xfHxpZHg8MCl7cmV0dXJuIHVuZGVmaW5lZH12YXIgY2h1bmtPZmZzZXQ9aWR4JXRoaXMuY2h1bmtTaXplO3ZhciBjaHVua051bT1pZHgvdGhpcy5jaHVua1NpemV8MDtyZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XX07TGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldERhdGFHZXR0ZXI9ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlcihnZXR0ZXIpe3RoaXMuZ2V0dGVyPWdldHRlcjt9O0xhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aD1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9jYWNoZUxlbmd0aCgpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJIRUFEIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO2lmKCEoeGhyLnN0YXR1cz49MjAwJiZ4aHIuc3RhdHVzPDMwMHx8eGhyLnN0YXR1cz09PTMwNCkpdGhyb3cgbmV3IEVycm9yKCJDb3VsZG4ndCBsb2FkICIrdXJsKyIuIFN0YXR1czogIit4aHIuc3RhdHVzKTt2YXIgZGF0YWxlbmd0aD1OdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCJDb250ZW50LWxlbmd0aCIpKTt2YXIgaGVhZGVyO3ZhciBoYXNCeXRlU2VydmluZz0oaGVhZGVyPXhoci5nZXRSZXNwb25zZUhlYWRlcigiQWNjZXB0LVJhbmdlcyIpKSYmaGVhZGVyPT09ImJ5dGVzIjt2YXIgdXNlc0d6aXA9KGhlYWRlcj14aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtRW5jb2RpbmciKSkmJmhlYWRlcj09PSJnemlwIjt2YXIgY2h1bmtTaXplPTEwMjQqMTAyNDtpZighaGFzQnl0ZVNlcnZpbmcpY2h1bmtTaXplPWRhdGFsZW5ndGg7dmFyIGRvWEhSPShmdW5jdGlvbihmcm9tLHRvKXtpZihmcm9tPnRvKXRocm93IG5ldyBFcnJvcigiaW52YWxpZCByYW5nZSAoIitmcm9tKyIsICIrdG8rIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkISIpO2lmKHRvPmRhdGFsZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoIm9ubHkgIitkYXRhbGVuZ3RoKyIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yISIpO3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCxmYWxzZSk7aWYoZGF0YWxlbmd0aCE9PWNodW5rU2l6ZSl4aHIuc2V0UmVxdWVzdEhlYWRlcigiUmFuZ2UiLCJieXRlcz0iK2Zyb20rIi0iK3RvKTtpZih0eXBlb2YgVWludDhBcnJheSE9InVuZGVmaW5lZCIpeGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO2lmKHhoci5vdmVycmlkZU1pbWVUeXBlKXt4aHIub3ZlcnJpZGVNaW1lVHlwZSgidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCIpO314aHIuc2VuZChudWxsKTtpZighKHhoci5zdGF0dXM+PTIwMCYmeGhyLnN0YXR1czwzMDB8fHhoci5zdGF0dXM9PT0zMDQpKXRocm93IG5ldyBFcnJvcigiQ291bGRuJ3QgbG9hZCAiK3VybCsiLiBTdGF0dXM6ICIreGhyLnN0YXR1cyk7aWYoeGhyLnJlc3BvbnNlIT09dW5kZWZpbmVkKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlfHxbXSl9ZWxzZSB7cmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0fHwiIix0cnVlKX19KTt2YXIgbGF6eUFycmF5PXRoaXM7bGF6eUFycmF5LnNldERhdGFHZXR0ZXIoKGZ1bmN0aW9uKGNodW5rTnVtKXt2YXIgc3RhcnQ9Y2h1bmtOdW0qY2h1bmtTaXplO3ZhciBlbmQ9KGNodW5rTnVtKzEpKmNodW5rU2l6ZS0xO2VuZD1NYXRoLm1pbihlbmQsZGF0YWxlbmd0aC0xKTtpZih0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV09PT0idW5kZWZpbmVkIil7bGF6eUFycmF5LmNodW5rc1tjaHVua051bV09ZG9YSFIoc3RhcnQsZW5kKTt9aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT09InVuZGVmaW5lZCIpdGhyb3cgbmV3IEVycm9yKCJkb1hIUiBmYWlsZWQhIik7cmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dfSkpO2lmKHVzZXNHemlwfHwhZGF0YWxlbmd0aCl7Y2h1bmtTaXplPWRhdGFsZW5ndGg9MTtkYXRhbGVuZ3RoPXRoaXMuZ2V0dGVyKDApLmxlbmd0aDtjaHVua1NpemU9ZGF0YWxlbmd0aDtjb25zb2xlLmxvZygiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIik7fXRoaXMuX2xlbmd0aD1kYXRhbGVuZ3RoO3RoaXMuX2NodW5rU2l6ZT1jaHVua1NpemU7dGhpcy5sZW5ndGhLbm93bj10cnVlO307aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT09InVuZGVmaW5lZCIpe2lmKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpdGhyb3cgIkNhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MiO3ZhciBsYXp5QXJyYXk9bmV3IExhenlVaW50OEFycmF5O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSx7bGVuZ3RoOntnZXQ6KGZ1bmN0aW9uKCl7aWYoIXRoaXMubGVuZ3RoS25vd24pe3RoaXMuY2FjaGVMZW5ndGgoKTt9cmV0dXJuIHRoaXMuX2xlbmd0aH0pfSxjaHVua1NpemU6e2dldDooZnVuY3Rpb24oKXtpZighdGhpcy5sZW5ndGhLbm93bil7dGhpcy5jYWNoZUxlbmd0aCgpO31yZXR1cm4gdGhpcy5fY2h1bmtTaXplfSl9fSk7dmFyIHByb3BlcnRpZXM9e2lzRGV2aWNlOmZhbHNlLGNvbnRlbnRzOmxhenlBcnJheX07fWVsc2Uge3ZhciBwcm9wZXJ0aWVzPXtpc0RldmljZTpmYWxzZSx1cmw6dXJsfTt9dmFyIG5vZGU9RlMuY3JlYXRlRmlsZShwYXJlbnQsbmFtZSxwcm9wZXJ0aWVzLGNhblJlYWQsY2FuV3JpdGUpO2lmKHByb3BlcnRpZXMuY29udGVudHMpe25vZGUuY29udGVudHM9cHJvcGVydGllcy5jb250ZW50czt9ZWxzZSBpZihwcm9wZXJ0aWVzLnVybCl7bm9kZS5jb250ZW50cz1udWxsO25vZGUudXJsPXByb3BlcnRpZXMudXJsO31PYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLHt1c2VkQnl0ZXM6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGh9KX19KTt2YXIgc3RyZWFtX29wcz17fTt2YXIga2V5cz1PYmplY3Qua2V5cyhub2RlLnN0cmVhbV9vcHMpO2tleXMuZm9yRWFjaCgoZnVuY3Rpb24oa2V5KXt2YXIgZm49bm9kZS5zdHJlYW1fb3BzW2tleV07c3RyZWFtX29wc1trZXldPWZ1bmN0aW9uIGZvcmNlTG9hZExhenlGaWxlKCl7aWYoIUZTLmZvcmNlTG9hZEZpbGUobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9cmV0dXJuIGZuLmFwcGx5KG51bGwsYXJndW1lbnRzKX07fSkpO3N0cmVhbV9vcHMucmVhZD1mdW5jdGlvbiBzdHJlYW1fb3BzX3JlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXtpZighRlMuZm9yY2VMb2FkRmlsZShub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX12YXIgY29udGVudHM9c3RyZWFtLm5vZGUuY29udGVudHM7aWYocG9zaXRpb24+PWNvbnRlbnRzLmxlbmd0aClyZXR1cm4gMDt2YXIgc2l6ZT1NYXRoLm1pbihjb250ZW50cy5sZW5ndGgtcG9zaXRpb24sbGVuZ3RoKTthc3NlcnQoc2l6ZT49MCk7aWYoY29udGVudHMuc2xpY2Upe2Zvcih2YXIgaT0wO2k8c2l6ZTtpKyspe2J1ZmZlcltvZmZzZXQraV09Y29udGVudHNbcG9zaXRpb24raV07fX1lbHNlIHtmb3IodmFyIGk9MDtpPHNpemU7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzLmdldChwb3NpdGlvbitpKTt9fXJldHVybiBzaXplfTtub2RlLnN0cmVhbV9vcHM9c3RyZWFtX29wcztyZXR1cm4gbm9kZX0pLGNyZWF0ZVByZWxvYWRlZEZpbGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLHVybCxjYW5SZWFkLGNhbldyaXRlLG9ubG9hZCxvbmVycm9yLGRvbnRDcmVhdGVGaWxlLGNhbk93bixwcmVGaW5pc2gpe0Jyb3dzZXIuaW5pdCgpO3ZhciBmdWxsbmFtZT1uYW1lP1BBVEgucmVzb2x2ZShQQVRILmpvaW4yKHBhcmVudCxuYW1lKSk6cGFyZW50O2Z1bmN0aW9uIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSl7ZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSl7aWYocHJlRmluaXNoKXByZUZpbmlzaCgpO2lmKCFkb250Q3JlYXRlRmlsZSl7RlMuY3JlYXRlRGF0YUZpbGUocGFyZW50LG5hbWUsYnl0ZUFycmF5LGNhblJlYWQsY2FuV3JpdGUsY2FuT3duKTt9aWYob25sb2FkKW9ubG9hZCgpO3JlbW92ZVJ1bkRlcGVuZGVuY3koKTt9dmFyIGhhbmRsZWQ9ZmFsc2U7TW9kdWxlWyJwcmVsb2FkUGx1Z2lucyJdLmZvckVhY2goKGZ1bmN0aW9uKHBsdWdpbil7aWYoaGFuZGxlZClyZXR1cm47aWYocGx1Z2luWyJjYW5IYW5kbGUiXShmdWxsbmFtZSkpe3BsdWdpblsiaGFuZGxlIl0oYnl0ZUFycmF5LGZ1bGxuYW1lLGZpbmlzaCwoZnVuY3Rpb24oKXtpZihvbmVycm9yKW9uZXJyb3IoKTtyZW1vdmVSdW5EZXBlbmRlbmN5KCk7fSkpO2hhbmRsZWQ9dHJ1ZTt9fSkpO2lmKCFoYW5kbGVkKWZpbmlzaChieXRlQXJyYXkpO31hZGRSdW5EZXBlbmRlbmN5KCk7aWYodHlwZW9mIHVybD09InN0cmluZyIpe0Jyb3dzZXIuYXN5bmNMb2FkKHVybCwoZnVuY3Rpb24oYnl0ZUFycmF5KXtwcm9jZXNzRGF0YShieXRlQXJyYXkpO30pLG9uZXJyb3IpO31lbHNlIHtwcm9jZXNzRGF0YSh1cmwpO319KSxpbmRleGVkREI6KGZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5pbmRleGVkREJ8fHdpbmRvdy5tb3pJbmRleGVkREJ8fHdpbmRvdy53ZWJraXRJbmRleGVkREJ8fHdpbmRvdy5tc0luZGV4ZWREQn0pLERCX05BTUU6KGZ1bmN0aW9uKCl7cmV0dXJuICJFTV9GU18iK3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0pLERCX1ZFUlNJT046MjAsREJfU1RPUkVfTkFNRToiRklMRV9EQVRBIixzYXZlRmlsZXNUb0RCOihmdW5jdGlvbihwYXRocyxvbmxvYWQsb25lcnJvcil7b25sb2FkPW9ubG9hZHx8KGZ1bmN0aW9uKCl7fSk7b25lcnJvcj1vbmVycm9yfHwoZnVuY3Rpb24oKXt9KTt2YXIgaW5kZXhlZERCPUZTLmluZGV4ZWREQigpO3RyeXt2YXIgb3BlblJlcXVlc3Q9aW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLEZTLkRCX1ZFUlNJT04pO31jYXRjaChlKXtyZXR1cm4gb25lcnJvcihlKX1vcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24gb3BlblJlcXVlc3Rfb251cGdyYWRlbmVlZGVkKCl7Y29uc29sZS5sb2coImNyZWF0aW5nIGRiIik7dmFyIGRiPW9wZW5SZXF1ZXN0LnJlc3VsdDtkYi5jcmVhdGVPYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTt9O29wZW5SZXF1ZXN0Lm9uc3VjY2Vzcz1mdW5jdGlvbiBvcGVuUmVxdWVzdF9vbnN1Y2Nlc3MoKXt2YXIgZGI9b3BlblJlcXVlc3QucmVzdWx0O3ZhciB0cmFuc2FjdGlvbj1kYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sInJlYWR3cml0ZSIpO3ZhciBmaWxlcz10cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTt2YXIgb2s9MCxmYWlsPTAsdG90YWw9cGF0aHMubGVuZ3RoO2Z1bmN0aW9uIGZpbmlzaCgpe2lmKGZhaWw9PTApb25sb2FkKCk7ZWxzZSBvbmVycm9yKCk7fXBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHBhdGgpe3ZhciBwdXRSZXF1ZXN0PWZpbGVzLnB1dChGUy5hbmFseXplUGF0aChwYXRoKS5vYmplY3QuY29udGVudHMscGF0aCk7cHV0UmVxdWVzdC5vbnN1Y2Nlc3M9ZnVuY3Rpb24gcHV0UmVxdWVzdF9vbnN1Y2Nlc3MoKXtvaysrO2lmKG9rK2ZhaWw9PXRvdGFsKWZpbmlzaCgpO307cHV0UmVxdWVzdC5vbmVycm9yPWZ1bmN0aW9uIHB1dFJlcXVlc3Rfb25lcnJvcigpe2ZhaWwrKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKTt9O30pKTt0cmFuc2FjdGlvbi5vbmVycm9yPW9uZXJyb3I7fTtvcGVuUmVxdWVzdC5vbmVycm9yPW9uZXJyb3I7fSksbG9hZEZpbGVzRnJvbURCOihmdW5jdGlvbihwYXRocyxvbmxvYWQsb25lcnJvcil7b25sb2FkPW9ubG9hZHx8KGZ1bmN0aW9uKCl7fSk7b25lcnJvcj1vbmVycm9yfHwoZnVuY3Rpb24oKXt9KTt2YXIgaW5kZXhlZERCPUZTLmluZGV4ZWREQigpO3RyeXt2YXIgb3BlblJlcXVlc3Q9aW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLEZTLkRCX1ZFUlNJT04pO31jYXRjaChlKXtyZXR1cm4gb25lcnJvcihlKX1vcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQ9b25lcnJvcjtvcGVuUmVxdWVzdC5vbnN1Y2Nlc3M9ZnVuY3Rpb24gb3BlblJlcXVlc3Rfb25zdWNjZXNzKCl7dmFyIGRiPW9wZW5SZXF1ZXN0LnJlc3VsdDt0cnl7dmFyIHRyYW5zYWN0aW9uPWRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwicmVhZG9ubHkiKTt9Y2F0Y2goZSl7b25lcnJvcihlKTtyZXR1cm59dmFyIGZpbGVzPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO3ZhciBvaz0wLGZhaWw9MCx0b3RhbD1wYXRocy5sZW5ndGg7ZnVuY3Rpb24gZmluaXNoKCl7aWYoZmFpbD09MClvbmxvYWQoKTtlbHNlIG9uZXJyb3IoKTt9cGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24ocGF0aCl7dmFyIGdldFJlcXVlc3Q9ZmlsZXMuZ2V0KHBhdGgpO2dldFJlcXVlc3Qub25zdWNjZXNzPWZ1bmN0aW9uIGdldFJlcXVlc3Rfb25zdWNjZXNzKCl7aWYoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKXtGUy51bmxpbmsocGF0aCk7fUZTLmNyZWF0ZURhdGFGaWxlKFBBVEguZGlybmFtZShwYXRoKSxQQVRILmJhc2VuYW1lKHBhdGgpLGdldFJlcXVlc3QucmVzdWx0LHRydWUsdHJ1ZSx0cnVlKTtvaysrO2lmKG9rK2ZhaWw9PXRvdGFsKWZpbmlzaCgpO307Z2V0UmVxdWVzdC5vbmVycm9yPWZ1bmN0aW9uIGdldFJlcXVlc3Rfb25lcnJvcigpe2ZhaWwrKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKTt9O30pKTt0cmFuc2FjdGlvbi5vbmVycm9yPW9uZXJyb3I7fTtvcGVuUmVxdWVzdC5vbmVycm9yPW9uZXJyb3I7fSl9O3ZhciBTWVNDQUxMUz17REVGQVVMVF9QT0xMTUFTSzo1LG1hcHBpbmdzOnt9LHVtYXNrOjUxMSxjYWxjdWxhdGVBdDooZnVuY3Rpb24oZGlyZmQscGF0aCl7aWYocGF0aFswXSE9PSIvIil7dmFyIGRpcjtpZihkaXJmZD09PS0xMDApe2Rpcj1GUy5jd2QoKTt9ZWxzZSB7dmFyIGRpcnN0cmVhbT1GUy5nZXRTdHJlYW0oZGlyZmQpO2lmKCFkaXJzdHJlYW0pdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO2Rpcj1kaXJzdHJlYW0ucGF0aDt9cGF0aD1QQVRILmpvaW4yKGRpcixwYXRoKTt9cmV0dXJuIHBhdGh9KSxkb1N0YXQ6KGZ1bmN0aW9uKGZ1bmMscGF0aCxidWYpe3RyeXt2YXIgc3RhdD1mdW5jKHBhdGgpO31jYXRjaChlKXtpZihlJiZlLm5vZGUmJlBBVEgubm9ybWFsaXplKHBhdGgpIT09UEFUSC5ub3JtYWxpemUoRlMuZ2V0UGF0aChlLm5vZGUpKSl7cmV0dXJuIC1FUlJOT19DT0RFUy5FTk9URElSfXRocm93IGV9SEVBUDMyW2J1Zj4+Ml09c3RhdC5kZXY7SEVBUDMyW2J1Zis0Pj4yXT0wO0hFQVAzMltidWYrOD4+Ml09c3RhdC5pbm87SEVBUDMyW2J1ZisxMj4+Ml09c3RhdC5tb2RlO0hFQVAzMltidWYrMTY+PjJdPXN0YXQubmxpbms7SEVBUDMyW2J1ZisyMD4+Ml09c3RhdC51aWQ7SEVBUDMyW2J1ZisyND4+Ml09c3RhdC5naWQ7SEVBUDMyW2J1ZisyOD4+Ml09c3RhdC5yZGV2O0hFQVAzMltidWYrMzI+PjJdPTA7SEVBUDMyW2J1ZiszNj4+Ml09c3RhdC5zaXplO0hFQVAzMltidWYrNDA+PjJdPTQwOTY7SEVBUDMyW2J1Zis0ND4+Ml09c3RhdC5ibG9ja3M7SEVBUDMyW2J1Zis0OD4+Ml09c3RhdC5hdGltZS5nZXRUaW1lKCkvMWUzfDA7SEVBUDMyW2J1Zis1Mj4+Ml09MDtIRUFQMzJbYnVmKzU2Pj4yXT1zdGF0Lm10aW1lLmdldFRpbWUoKS8xZTN8MDtIRUFQMzJbYnVmKzYwPj4yXT0wO0hFQVAzMltidWYrNjQ+PjJdPXN0YXQuY3RpbWUuZ2V0VGltZSgpLzFlM3wwO0hFQVAzMltidWYrNjg+PjJdPTA7SEVBUDMyW2J1Zis3Mj4+Ml09c3RhdC5pbm87cmV0dXJuIDB9KSxkb01zeW5jOihmdW5jdGlvbihhZGRyLHN0cmVhbSxsZW4sZmxhZ3Mpe3ZhciBidWZmZXI9bmV3IFVpbnQ4QXJyYXkoSEVBUFU4LnN1YmFycmF5KGFkZHIsYWRkcitsZW4pKTtGUy5tc3luYyhzdHJlYW0sYnVmZmVyLDAsbGVuLGZsYWdzKTt9KSxkb01rZGlyOihmdW5jdGlvbihwYXRoLG1vZGUpe3BhdGg9UEFUSC5ub3JtYWxpemUocGF0aCk7aWYocGF0aFtwYXRoLmxlbmd0aC0xXT09PSIvIilwYXRoPXBhdGguc3Vic3RyKDAscGF0aC5sZW5ndGgtMSk7RlMubWtkaXIocGF0aCxtb2RlLDApO3JldHVybiAwfSksZG9Na25vZDooZnVuY3Rpb24ocGF0aCxtb2RlLGRldil7c3dpdGNoKG1vZGUmNjE0NDApe2Nhc2UgMzI3Njg6Y2FzZSA4MTkyOmNhc2UgMjQ1NzY6Y2FzZSA0MDk2OmNhc2UgNDkxNTI6YnJlYWs7ZGVmYXVsdDpyZXR1cm4gLUVSUk5PX0NPREVTLkVJTlZBTH1GUy5ta25vZChwYXRoLG1vZGUsZGV2KTtyZXR1cm4gMH0pLGRvUmVhZGxpbms6KGZ1bmN0aW9uKHBhdGgsYnVmLGJ1ZnNpemUpe2lmKGJ1ZnNpemU8PTApcmV0dXJuIC1FUlJOT19DT0RFUy5FSU5WQUw7dmFyIHJldD1GUy5yZWFkbGluayhwYXRoKTt2YXIgbGVuPU1hdGgubWluKGJ1ZnNpemUsbGVuZ3RoQnl0ZXNVVEY4KHJldCkpO3ZhciBlbmRDaGFyPUhFQVA4W2J1ZitsZW5dO3N0cmluZ1RvVVRGOChyZXQsYnVmLGJ1ZnNpemUrMSk7SEVBUDhbYnVmK2xlbl09ZW5kQ2hhcjtyZXR1cm4gbGVufSksZG9BY2Nlc3M6KGZ1bmN0aW9uKHBhdGgsYW1vZGUpe2lmKGFtb2RlJn43KXtyZXR1cm4gLUVSUk5PX0NPREVTLkVJTlZBTH12YXIgbm9kZTt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTtub2RlPWxvb2t1cC5ub2RlO3ZhciBwZXJtcz0iIjtpZihhbW9kZSY0KXBlcm1zKz0iciI7aWYoYW1vZGUmMilwZXJtcys9InciO2lmKGFtb2RlJjEpcGVybXMrPSJ4IjtpZihwZXJtcyYmRlMubm9kZVBlcm1pc3Npb25zKG5vZGUscGVybXMpKXtyZXR1cm4gLUVSUk5PX0NPREVTLkVBQ0NFU31yZXR1cm4gMH0pLGRvRHVwOihmdW5jdGlvbihwYXRoLGZsYWdzLHN1Z2dlc3RGRCl7dmFyIHN1Z2dlc3Q9RlMuZ2V0U3RyZWFtKHN1Z2dlc3RGRCk7aWYoc3VnZ2VzdClGUy5jbG9zZShzdWdnZXN0KTtyZXR1cm4gRlMub3BlbihwYXRoLGZsYWdzLDAsc3VnZ2VzdEZELHN1Z2dlc3RGRCkuZmR9KSxkb1JlYWR2OihmdW5jdGlvbihzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpe3ZhciByZXQ9MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUDMyW2lvditpKjg+PjJdO3ZhciBsZW49SEVBUDMyW2lvdisoaSo4KzQpPj4yXTt2YXIgY3Vycj1GUy5yZWFkKHN0cmVhbSxIRUFQOCxwdHIsbGVuLG9mZnNldCk7aWYoY3VycjwwKXJldHVybiAtMTtyZXQrPWN1cnI7aWYoY3VycjxsZW4pYnJlYWt9cmV0dXJuIHJldH0pLGRvV3JpdGV2OihmdW5jdGlvbihzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpe3ZhciByZXQ9MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUDMyW2lvditpKjg+PjJdO3ZhciBsZW49SEVBUDMyW2lvdisoaSo4KzQpPj4yXTt2YXIgY3Vycj1GUy53cml0ZShzdHJlYW0sSEVBUDgscHRyLGxlbixvZmZzZXQpO2lmKGN1cnI8MClyZXR1cm4gLTE7cmV0Kz1jdXJyO31yZXR1cm4gcmV0fSksdmFyYXJnczowLGdldDooZnVuY3Rpb24odmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncys9NDt2YXIgcmV0PUhFQVAzMltTWVNDQUxMUy52YXJhcmdzLTQ+PjJdO3JldHVybiByZXR9KSxnZXRTdHI6KGZ1bmN0aW9uKCl7dmFyIHJldD1Qb2ludGVyX3N0cmluZ2lmeShTWVNDQUxMUy5nZXQoKSk7cmV0dXJuIHJldH0pLGdldFN0cmVhbUZyb21GRDooZnVuY3Rpb24oKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShTWVNDQUxMUy5nZXQoKSk7aWYoIXN0cmVhbSl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERik7cmV0dXJuIHN0cmVhbX0pLGdldFNvY2tldEZyb21GRDooZnVuY3Rpb24oKXt2YXIgc29ja2V0PVNPQ0tGUy5nZXRTb2NrZXQoU1lTQ0FMTFMuZ2V0KCkpO2lmKCFzb2NrZXQpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO3JldHVybiBzb2NrZXR9KSxnZXRTb2NrZXRBZGRyZXNzOihmdW5jdGlvbihhbGxvd051bGwpe3ZhciBhZGRycD1TWVNDQUxMUy5nZXQoKSxhZGRybGVuPVNZU0NBTExTLmdldCgpO2lmKGFsbG93TnVsbCYmYWRkcnA9PT0wKXJldHVybiBudWxsO3ZhciBpbmZvPV9fcmVhZF9zb2NrYWRkcihhZGRycCxhZGRybGVuKTtpZihpbmZvLmVycm5vKXRocm93IG5ldyBGUy5FcnJub0Vycm9yKGluZm8uZXJybm8pO2luZm8uYWRkcj1ETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKXx8aW5mby5hZGRyO3JldHVybiBpbmZvfSksZ2V0NjQ6KGZ1bmN0aW9uKCl7dmFyIGxvdz1TWVNDQUxMUy5nZXQoKSxoaWdoPVNZU0NBTExTLmdldCgpO2lmKGxvdz49MClhc3NlcnQoaGlnaD09PTApO2Vsc2UgYXNzZXJ0KGhpZ2g9PT0tMSk7cmV0dXJuIGxvd30pLGdldFplcm86KGZ1bmN0aW9uKCl7YXNzZXJ0KFNZU0NBTExTLmdldCgpPT09MCk7fSl9O2Z1bmN0aW9uIF9fX3N5c2NhbGwxNDAod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLG9mZnNldF9oaWdoPVNZU0NBTExTLmdldCgpLG9mZnNldF9sb3c9U1lTQ0FMTFMuZ2V0KCkscmVzdWx0PVNZU0NBTExTLmdldCgpLHdoZW5jZT1TWVNDQUxMUy5nZXQoKTt2YXIgb2Zmc2V0PW9mZnNldF9sb3c7RlMubGxzZWVrKHN0cmVhbSxvZmZzZXQsd2hlbmNlKTtIRUFQMzJbcmVzdWx0Pj4yXT1zdHJlYW0ucG9zaXRpb247aWYoc3RyZWFtLmdldGRlbnRzJiZvZmZzZXQ9PT0wJiZ3aGVuY2U9PT0wKXN0cmVhbS5nZXRkZW50cz1udWxsO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDUod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLGlvdj1TWVNDQUxMUy5nZXQoKSxpb3ZjbnQ9U1lTQ0FMTFMuZ2V0KCk7cmV0dXJuIFNZU0NBTExTLmRvUmVhZHYoc3RyZWFtLGlvdixpb3ZjbnQpfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDYod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLGlvdj1TWVNDQUxMUy5nZXQoKSxpb3ZjbnQ9U1lTQ0FMTFMuZ2V0KCk7cmV0dXJuIFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSxpb3YsaW92Y250KX1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT0idW5kZWZpbmVkInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuIC1lLmVycm5vfX1mdW5jdGlvbiBfX19zeXNjYWxsMTgzKHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIGJ1Zj1TWVNDQUxMUy5nZXQoKSxzaXplPVNZU0NBTExTLmdldCgpO2lmKHNpemU9PT0wKXJldHVybiAtRVJSTk9fQ09ERVMuRUlOVkFMO3ZhciBjd2Q9RlMuY3dkKCk7dmFyIGN3ZExlbmd0aEluQnl0ZXM9bGVuZ3RoQnl0ZXNVVEY4KGN3ZCk7aWYoc2l6ZTxjd2RMZW5ndGhJbkJ5dGVzKzEpcmV0dXJuIC1FUlJOT19DT0RFUy5FUkFOR0U7c3RyaW5nVG9VVEY4KGN3ZCxidWYsc2l6ZSk7cmV0dXJuIGJ1Zn1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT0idW5kZWZpbmVkInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuIC1lLmVycm5vfX1mdW5jdGlvbiBfX19zeXNjYWxsMTk4KHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHBhdGg9U1lTQ0FMTFMuZ2V0U3RyKCksb3duZXI9U1lTQ0FMTFMuZ2V0KCksZ3JvdXA9U1lTQ0FMTFMuZ2V0KCk7RlMuY2hvd24ocGF0aCxvd25lcixncm91cCk7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09InVuZGVmaW5lZCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybiAtZS5lcnJub319dmFyIFBST0NJTkZPPXtwcGlkOjEscGlkOjQyLHNpZDo0MixwZ2lkOjQyfTtmdW5jdGlvbiBfX19zeXNjYWxsMjAod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXtyZXR1cm4gUFJPQ0lORk8ucGlkfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw2KHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKTtGUy5jbG9zZShzdHJlYW0pO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw2MCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBtYXNrPVNZU0NBTExTLmdldCgpO3ZhciBvbGQ9U1lTQ0FMTFMudW1hc2s7U1lTQ0FMTFMudW1hc2s9bWFzaztyZXR1cm4gb2xkfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw4Myh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciB0YXJnZXQ9U1lTQ0FMTFMuZ2V0U3RyKCksbGlua3BhdGg9U1lTQ0FMTFMuZ2V0U3RyKCk7RlMuc3ltbGluayh0YXJnZXQsbGlua3BhdGgpO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PSJ1bmRlZmluZWQifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4gLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw5MSh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBhZGRyPVNZU0NBTExTLmdldCgpLGxlbj1TWVNDQUxMUy5nZXQoKTt2YXIgaW5mbz1TWVNDQUxMUy5tYXBwaW5nc1thZGRyXTtpZighaW5mbylyZXR1cm4gMDtpZihsZW49PT1pbmZvLmxlbil7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oaW5mby5mZCk7U1lTQ0FMTFMuZG9Nc3luYyhhZGRyLHN0cmVhbSxsZW4saW5mby5mbGFncyk7RlMubXVubWFwKHN0cmVhbSk7U1lTQ0FMTFMubWFwcGluZ3NbYWRkcl09bnVsbDtpZihpbmZvLmFsbG9jYXRlZCl7X2ZyZWUoaW5mby5tYWxsb2MpO319cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09InVuZGVmaW5lZCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybiAtZS5lcnJub319ZnVuY3Rpb24gX19fdW5sb2NrKCl7fXZhciBzdHJ1Y3RSZWdpc3RyYXRpb25zPXt9O2Z1bmN0aW9uIHJ1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKXt3aGlsZShkZXN0cnVjdG9ycy5sZW5ndGgpe3ZhciBwdHI9ZGVzdHJ1Y3RvcnMucG9wKCk7dmFyIGRlbD1kZXN0cnVjdG9ycy5wb3AoKTtkZWwocHRyKTt9fWZ1bmN0aW9uIHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX12YXIgYXdhaXRpbmdEZXBlbmRlbmNpZXM9e307dmFyIHJlZ2lzdGVyZWRUeXBlcz17fTt2YXIgdHlwZURlcGVuZGVuY2llcz17fTt2YXIgY2hhcl8wPTQ4O3ZhciBjaGFyXzk9NTc7ZnVuY3Rpb24gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpe2lmKHVuZGVmaW5lZD09PW5hbWUpe3JldHVybiAiX3Vua25vd24ifW5hbWU9bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csIiQiKTt2YXIgZj1uYW1lLmNoYXJDb2RlQXQoMCk7aWYoZj49Y2hhcl8wJiZmPD1jaGFyXzkpe3JldHVybiAiXyIrbmFtZX1lbHNlIHtyZXR1cm4gbmFtZX19ZnVuY3Rpb24gY3JlYXRlTmFtZWRGdW5jdGlvbihuYW1lLGJvZHkpe25hbWU9bWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO3JldHVybiAobmV3IEZ1bmN0aW9uKCJib2R5IiwicmV0dXJuIGZ1bmN0aW9uICIrbmFtZSsiKCkge1xuIisnICAgICJ1c2Ugc3RyaWN0IjsnKyIgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiIrIn07XG4iKSkoYm9keSl9ZnVuY3Rpb24gZXh0ZW5kRXJyb3IoYmFzZUVycm9yVHlwZSxlcnJvck5hbWUpe3ZhciBlcnJvckNsYXNzPWNyZWF0ZU5hbWVkRnVuY3Rpb24oZXJyb3JOYW1lLChmdW5jdGlvbihtZXNzYWdlKXt0aGlzLm5hbWU9ZXJyb3JOYW1lO3RoaXMubWVzc2FnZT1tZXNzYWdlO3ZhciBzdGFjaz0obmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztpZihzdGFjayE9PXVuZGVmaW5lZCl7dGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrIlxuIitzdGFjay5yZXBsYWNlKC9eRXJyb3IoOlteXG5dKik/XG4vLCIiKTt9fSkpO2Vycm9yQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYmFzZUVycm9yVHlwZS5wcm90b3R5cGUpO2Vycm9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPWVycm9yQ2xhc3M7ZXJyb3JDbGFzcy5wcm90b3R5cGUudG9TdHJpbmc9KGZ1bmN0aW9uKCl7aWYodGhpcy5tZXNzYWdlPT09dW5kZWZpbmVkKXtyZXR1cm4gdGhpcy5uYW1lfWVsc2Uge3JldHVybiB0aGlzLm5hbWUrIjogIit0aGlzLm1lc3NhZ2V9fSk7cmV0dXJuIGVycm9yQ2xhc3N9dmFyIEludGVybmFsRXJyb3I9dW5kZWZpbmVkO2Z1bmN0aW9uIHRocm93SW50ZXJuYWxFcnJvcihtZXNzYWdlKXt0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihtZXNzYWdlKX1mdW5jdGlvbiB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChteVR5cGVzLGRlcGVuZGVudFR5cGVzLGdldFR5cGVDb252ZXJ0ZXJzKXtteVR5cGVzLmZvckVhY2goKGZ1bmN0aW9uKHR5cGUpe3R5cGVEZXBlbmRlbmNpZXNbdHlwZV09ZGVwZW5kZW50VHlwZXM7fSkpO2Z1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpe3ZhciBteVR5cGVDb252ZXJ0ZXJzPWdldFR5cGVDb252ZXJ0ZXJzKHR5cGVDb252ZXJ0ZXJzKTtpZihteVR5cGVDb252ZXJ0ZXJzLmxlbmd0aCE9PW15VHlwZXMubGVuZ3RoKXt0aHJvd0ludGVybmFsRXJyb3IoIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnQiKTt9Zm9yKHZhciBpPTA7aTxteVR5cGVzLmxlbmd0aDsrK2kpe3JlZ2lzdGVyVHlwZShteVR5cGVzW2ldLG15VHlwZUNvbnZlcnRlcnNbaV0pO319dmFyIHR5cGVDb252ZXJ0ZXJzPW5ldyBBcnJheShkZXBlbmRlbnRUeXBlcy5sZW5ndGgpO3ZhciB1bnJlZ2lzdGVyZWRUeXBlcz1bXTt2YXIgcmVnaXN0ZXJlZD0wO2RlcGVuZGVudFR5cGVzLmZvckVhY2goKGZ1bmN0aW9uKGR0LGkpe2lmKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShkdCkpe3R5cGVDb252ZXJ0ZXJzW2ldPXJlZ2lzdGVyZWRUeXBlc1tkdF07fWVsc2Uge3VucmVnaXN0ZXJlZFR5cGVzLnB1c2goZHQpO2lmKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpe2F3YWl0aW5nRGVwZW5kZW5jaWVzW2R0XT1bXTt9YXdhaXRpbmdEZXBlbmRlbmNpZXNbZHRdLnB1c2goKGZ1bmN0aW9uKCl7dHlwZUNvbnZlcnRlcnNbaV09cmVnaXN0ZXJlZFR5cGVzW2R0XTsrK3JlZ2lzdGVyZWQ7aWYocmVnaXN0ZXJlZD09PXVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCl7b25Db21wbGV0ZSh0eXBlQ29udmVydGVycyk7fX0pKTt9fSkpO2lmKDA9PT11bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpe29uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpO319ZnVuY3Rpb24gX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0KHN0cnVjdFR5cGUpe3ZhciByZWc9c3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXTtkZWxldGUgc3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXTt2YXIgcmF3Q29uc3RydWN0b3I9cmVnLnJhd0NvbnN0cnVjdG9yO3ZhciByYXdEZXN0cnVjdG9yPXJlZy5yYXdEZXN0cnVjdG9yO3ZhciBmaWVsZFJlY29yZHM9cmVnLmZpZWxkczt2YXIgZmllbGRUeXBlcz1maWVsZFJlY29yZHMubWFwKChmdW5jdGlvbihmaWVsZCl7cmV0dXJuIGZpZWxkLmdldHRlclJldHVyblR5cGV9KSkuY29uY2F0KGZpZWxkUmVjb3Jkcy5tYXAoKGZ1bmN0aW9uKGZpZWxkKXtyZXR1cm4gZmllbGQuc2V0dGVyQXJndW1lbnRUeXBlfSkpKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbc3RydWN0VHlwZV0sZmllbGRUeXBlcywoZnVuY3Rpb24oZmllbGRUeXBlcyl7dmFyIGZpZWxkcz17fTtmaWVsZFJlY29yZHMuZm9yRWFjaCgoZnVuY3Rpb24oZmllbGQsaSl7dmFyIGZpZWxkTmFtZT1maWVsZC5maWVsZE5hbWU7dmFyIGdldHRlclJldHVyblR5cGU9ZmllbGRUeXBlc1tpXTt2YXIgZ2V0dGVyPWZpZWxkLmdldHRlcjt2YXIgZ2V0dGVyQ29udGV4dD1maWVsZC5nZXR0ZXJDb250ZXh0O3ZhciBzZXR0ZXJBcmd1bWVudFR5cGU9ZmllbGRUeXBlc1tpK2ZpZWxkUmVjb3Jkcy5sZW5ndGhdO3ZhciBzZXR0ZXI9ZmllbGQuc2V0dGVyO3ZhciBzZXR0ZXJDb250ZXh0PWZpZWxkLnNldHRlckNvbnRleHQ7ZmllbGRzW2ZpZWxkTmFtZV09e3JlYWQ6KGZ1bmN0aW9uKHB0cil7cmV0dXJuIGdldHRlclJldHVyblR5cGVbImZyb21XaXJlVHlwZSJdKGdldHRlcihnZXR0ZXJDb250ZXh0LHB0cikpfSksd3JpdGU6KGZ1bmN0aW9uKHB0cixvKXt2YXIgZGVzdHJ1Y3RvcnM9W107c2V0dGVyKHNldHRlckNvbnRleHQscHRyLHNldHRlckFyZ3VtZW50VHlwZVsidG9XaXJlVHlwZSJdKGRlc3RydWN0b3JzLG8pKTtydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7fSl9O30pKTtyZXR1cm4gW3tuYW1lOnJlZy5uYW1lLCJmcm9tV2lyZVR5cGUiOihmdW5jdGlvbihwdHIpe3ZhciBydj17fTtmb3IodmFyIGkgaW4gZmllbGRzKXtydltpXT1maWVsZHNbaV0ucmVhZChwdHIpO31yYXdEZXN0cnVjdG9yKHB0cik7cmV0dXJuIHJ2fSksInRvV2lyZVR5cGUiOihmdW5jdGlvbihkZXN0cnVjdG9ycyxvKXtmb3IodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpe2lmKCEoZmllbGROYW1lIGluIG8pKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJNaXNzaW5nIGZpZWxkIil9fXZhciBwdHI9cmF3Q29uc3RydWN0b3IoKTtmb3IoZmllbGROYW1lIGluIGZpZWxkcyl7ZmllbGRzW2ZpZWxkTmFtZV0ud3JpdGUocHRyLG9bZmllbGROYW1lXSk7fWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChyYXdEZXN0cnVjdG9yLHB0cik7fXJldHVybiBwdHJ9KSwiYXJnUGFja0FkdmFuY2UiOjgsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246cmF3RGVzdHJ1Y3Rvcn1dfSkpO31mdW5jdGlvbiBnZXRTaGlmdEZyb21TaXplKHNpemUpe3N3aXRjaChzaXplKXtjYXNlIDE6cmV0dXJuIDA7Y2FzZSAyOnJldHVybiAxO2Nhc2UgNDpyZXR1cm4gMjtjYXNlIDg6cmV0dXJuIDM7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIHR5cGUgc2l6ZTogIitzaXplKX19ZnVuY3Rpb24gZW1iaW5kX2luaXRfY2hhckNvZGVzKCl7dmFyIGNvZGVzPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgaT0wO2k8MjU2OysraSl7Y29kZXNbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKTt9ZW1iaW5kX2NoYXJDb2Rlcz1jb2Rlczt9dmFyIGVtYmluZF9jaGFyQ29kZXM9dW5kZWZpbmVkO2Z1bmN0aW9uIHJlYWRMYXRpbjFTdHJpbmcocHRyKXt2YXIgcmV0PSIiO3ZhciBjPXB0cjt3aGlsZShIRUFQVThbY10pe3JldCs9ZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV07fXJldHVybiByZXR9dmFyIEJpbmRpbmdFcnJvcj11bmRlZmluZWQ7ZnVuY3Rpb24gdGhyb3dCaW5kaW5nRXJyb3IobWVzc2FnZSl7dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihtZXNzYWdlKX1mdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zfHx7fTtpZighKCJhcmdQYWNrQWR2YW5jZSJpbiByZWdpc3RlcmVkSW5zdGFuY2UpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIil9dmFyIG5hbWU9cmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7aWYoIXJhd1R5cGUpe3Rocm93QmluZGluZ0Vycm9yKCd0eXBlICInK25hbWUrJyIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcicpO31pZihyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe2lmKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucyl7cmV0dXJufWVsc2Uge3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnIituYW1lKyInIHR3aWNlIik7fX1yZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV09cmVnaXN0ZXJlZEluc3RhbmNlO2RlbGV0ZSB0eXBlRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2lmKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXt2YXIgY2FsbGJhY2tzPWF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2RlbGV0ZSBhd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtjYWxsYmFja3MuZm9yRWFjaCgoZnVuY3Rpb24oY2Ipe2NiKCk7fSkpO319ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfYm9vbChyYXdUeXBlLG5hbWUsc2l6ZSx0cnVlVmFsdWUsZmFsc2VWYWx1ZSl7dmFyIHNoaWZ0PWdldFNoaWZ0RnJvbVNpemUoc2l6ZSk7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6KGZ1bmN0aW9uKHd0KXtyZXR1cm4gISF3dH0pLCJ0b1dpcmVUeXBlIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7cmV0dXJuIG8/dHJ1ZVZhbHVlOmZhbHNlVmFsdWV9KSwiYXJnUGFja0FkdmFuY2UiOjgsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjooZnVuY3Rpb24ocG9pbnRlcil7dmFyIGhlYXA7aWYoc2l6ZT09PTEpe2hlYXA9SEVBUDg7fWVsc2UgaWYoc2l6ZT09PTIpe2hlYXA9SEVBUDE2O31lbHNlIGlmKHNpemU9PT00KXtoZWFwPUhFQVAzMjt9ZWxzZSB7dGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBib29sZWFuIHR5cGUgc2l6ZTogIituYW1lKX1yZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oaGVhcFtwb2ludGVyPj5zaGlmdF0pfSksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9ZnVuY3Rpb24gQ2xhc3NIYW5kbGVfaXNBbGlhc09mKG90aGVyKXtpZighKHRoaXMgaW5zdGFuY2VvZiBDbGFzc0hhbmRsZSkpe3JldHVybiBmYWxzZX1pZighKG90aGVyIGluc3RhbmNlb2YgQ2xhc3NIYW5kbGUpKXtyZXR1cm4gZmFsc2V9dmFyIGxlZnRDbGFzcz10aGlzLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3ZhciBsZWZ0PXRoaXMuJCQucHRyO3ZhciByaWdodENsYXNzPW90aGVyLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3ZhciByaWdodD1vdGhlci4kJC5wdHI7d2hpbGUobGVmdENsYXNzLmJhc2VDbGFzcyl7bGVmdD1sZWZ0Q2xhc3MudXBjYXN0KGxlZnQpO2xlZnRDbGFzcz1sZWZ0Q2xhc3MuYmFzZUNsYXNzO313aGlsZShyaWdodENsYXNzLmJhc2VDbGFzcyl7cmlnaHQ9cmlnaHRDbGFzcy51cGNhc3QocmlnaHQpO3JpZ2h0Q2xhc3M9cmlnaHRDbGFzcy5iYXNlQ2xhc3M7fXJldHVybiBsZWZ0Q2xhc3M9PT1yaWdodENsYXNzJiZsZWZ0PT09cmlnaHR9ZnVuY3Rpb24gc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIobyl7cmV0dXJuIHtjb3VudDpvLmNvdW50LGRlbGV0ZVNjaGVkdWxlZDpvLmRlbGV0ZVNjaGVkdWxlZCxwcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZTpvLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlLHB0cjpvLnB0cixwdHJUeXBlOm8ucHRyVHlwZSxzbWFydFB0cjpvLnNtYXJ0UHRyLHNtYXJ0UHRyVHlwZTpvLnNtYXJ0UHRyVHlwZX19ZnVuY3Rpb24gdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKG9iail7ZnVuY3Rpb24gZ2V0SW5zdGFuY2VUeXBlTmFtZShoYW5kbGUpe3JldHVybiBoYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZX10aHJvd0JpbmRpbmdFcnJvcihnZXRJbnN0YW5jZVR5cGVOYW1lKG9iaikrIiBpbnN0YW5jZSBhbHJlYWR5IGRlbGV0ZWQiKTt9ZnVuY3Rpb24gQ2xhc3NIYW5kbGVfY2xvbmUoKXtpZighdGhpcy4kJC5wdHIpe3Rocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTt9aWYodGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSl7dGhpcy4kJC5jb3VudC52YWx1ZSs9MTtyZXR1cm4gdGhpc31lbHNlIHt2YXIgY2xvbmU9T2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykseyQkOnt2YWx1ZTpzaGFsbG93Q29weUludGVybmFsUG9pbnRlcih0aGlzLiQkKX19KTtjbG9uZS4kJC5jb3VudC52YWx1ZSs9MTtjbG9uZS4kJC5kZWxldGVTY2hlZHVsZWQ9ZmFsc2U7cmV0dXJuIGNsb25lfX1mdW5jdGlvbiBydW5EZXN0cnVjdG9yKGhhbmRsZSl7dmFyICQkPWhhbmRsZS4kJDtpZigkJC5zbWFydFB0cil7JCQuc21hcnRQdHJUeXBlLnJhd0Rlc3RydWN0b3IoJCQuc21hcnRQdHIpO31lbHNlIHskJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5yYXdEZXN0cnVjdG9yKCQkLnB0cik7fX1mdW5jdGlvbiBDbGFzc0hhbmRsZV9kZWxldGUoKXtpZighdGhpcy4kJC5wdHIpe3Rocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTt9aWYodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKXt0aHJvd0JpbmRpbmdFcnJvcigiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpO310aGlzLiQkLmNvdW50LnZhbHVlLT0xO3ZhciB0b0RlbGV0ZT0wPT09dGhpcy4kJC5jb3VudC52YWx1ZTtpZih0b0RlbGV0ZSl7cnVuRGVzdHJ1Y3Rvcih0aGlzKTt9aWYoIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpe3RoaXMuJCQuc21hcnRQdHI9dW5kZWZpbmVkO3RoaXMuJCQucHRyPXVuZGVmaW5lZDt9fWZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzRGVsZXRlZCgpe3JldHVybiAhdGhpcy4kJC5wdHJ9dmFyIGRlbGF5RnVuY3Rpb249dW5kZWZpbmVkO3ZhciBkZWxldGlvblF1ZXVlPVtdO2Z1bmN0aW9uIGZsdXNoUGVuZGluZ0RlbGV0ZXMoKXt3aGlsZShkZWxldGlvblF1ZXVlLmxlbmd0aCl7dmFyIG9iaj1kZWxldGlvblF1ZXVlLnBvcCgpO29iai4kJC5kZWxldGVTY2hlZHVsZWQ9ZmFsc2U7b2JqWyJkZWxldGUiXSgpO319ZnVuY3Rpb24gQ2xhc3NIYW5kbGVfZGVsZXRlTGF0ZXIoKXtpZighdGhpcy4kJC5wdHIpe3Rocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTt9aWYodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKXt0aHJvd0JpbmRpbmdFcnJvcigiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpO31kZWxldGlvblF1ZXVlLnB1c2godGhpcyk7aWYoZGVsZXRpb25RdWV1ZS5sZW5ndGg9PT0xJiZkZWxheUZ1bmN0aW9uKXtkZWxheUZ1bmN0aW9uKGZsdXNoUGVuZGluZ0RlbGV0ZXMpO310aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZD10cnVlO3JldHVybiB0aGlzfWZ1bmN0aW9uIGluaXRfQ2xhc3NIYW5kbGUoKXtDbGFzc0hhbmRsZS5wcm90b3R5cGVbImlzQWxpYXNPZiJdPUNsYXNzSGFuZGxlX2lzQWxpYXNPZjtDbGFzc0hhbmRsZS5wcm90b3R5cGVbImNsb25lIl09Q2xhc3NIYW5kbGVfY2xvbmU7Q2xhc3NIYW5kbGUucHJvdG90eXBlWyJkZWxldGUiXT1DbGFzc0hhbmRsZV9kZWxldGU7Q2xhc3NIYW5kbGUucHJvdG90eXBlWyJpc0RlbGV0ZWQiXT1DbGFzc0hhbmRsZV9pc0RlbGV0ZWQ7Q2xhc3NIYW5kbGUucHJvdG90eXBlWyJkZWxldGVMYXRlciJdPUNsYXNzSGFuZGxlX2RlbGV0ZUxhdGVyO31mdW5jdGlvbiBDbGFzc0hhbmRsZSgpe312YXIgcmVnaXN0ZXJlZFBvaW50ZXJzPXt9O2Z1bmN0aW9uIGVuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpe2lmKHVuZGVmaW5lZD09PXByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpe3ZhciBwcmV2RnVuYz1wcm90b1ttZXRob2ROYW1lXTtwcm90b1ttZXRob2ROYW1lXT0oZnVuY3Rpb24oKXtpZighcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHMubGVuZ3RoKSl7dGhyb3dCaW5kaW5nRXJyb3IoIkZ1bmN0aW9uICciK2h1bWFuTmFtZSsiJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCIrYXJndW1lbnRzLmxlbmd0aCsiKSAtIGV4cGVjdHMgb25lIG9mICgiK3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUrIikhIik7fXJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pO3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGU9W107cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVtwcmV2RnVuYy5hcmdDb3VudF09cHJldkZ1bmM7fX1mdW5jdGlvbiBleHBvc2VQdWJsaWNTeW1ib2wobmFtZSx2YWx1ZSxudW1Bcmd1bWVudHMpe2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7aWYodW5kZWZpbmVkPT09bnVtQXJndW1lbnRzfHx1bmRlZmluZWQhPT1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSYmdW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSl7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnIituYW1lKyInIHR3aWNlIik7fWVuc3VyZU92ZXJsb2FkVGFibGUoTW9kdWxlLG5hbWUsbmFtZSk7aWYoTW9kdWxlLmhhc093blByb3BlcnR5KG51bUFyZ3VtZW50cykpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICgiK251bUFyZ3VtZW50cysiKSEiKTt9TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXT12YWx1ZTt9ZWxzZSB7TW9kdWxlW25hbWVdPXZhbHVlO2lmKHVuZGVmaW5lZCE9PW51bUFyZ3VtZW50cyl7TW9kdWxlW25hbWVdLm51bUFyZ3VtZW50cz1udW1Bcmd1bWVudHM7fX19ZnVuY3Rpb24gUmVnaXN0ZXJlZENsYXNzKG5hbWUsY29uc3RydWN0b3IsaW5zdGFuY2VQcm90b3R5cGUscmF3RGVzdHJ1Y3RvcixiYXNlQ2xhc3MsZ2V0QWN0dWFsVHlwZSx1cGNhc3QsZG93bmNhc3Qpe3RoaXMubmFtZT1uYW1lO3RoaXMuY29uc3RydWN0b3I9Y29uc3RydWN0b3I7dGhpcy5pbnN0YW5jZVByb3RvdHlwZT1pbnN0YW5jZVByb3RvdHlwZTt0aGlzLnJhd0Rlc3RydWN0b3I9cmF3RGVzdHJ1Y3Rvcjt0aGlzLmJhc2VDbGFzcz1iYXNlQ2xhc3M7dGhpcy5nZXRBY3R1YWxUeXBlPWdldEFjdHVhbFR5cGU7dGhpcy51cGNhc3Q9dXBjYXN0O3RoaXMuZG93bmNhc3Q9ZG93bmNhc3Q7dGhpcy5wdXJlVmlydHVhbEZ1bmN0aW9ucz1bXTt9ZnVuY3Rpb24gdXBjYXN0UG9pbnRlcihwdHIscHRyQ2xhc3MsZGVzaXJlZENsYXNzKXt3aGlsZShwdHJDbGFzcyE9PWRlc2lyZWRDbGFzcyl7aWYoIXB0ckNsYXNzLnVwY2FzdCl7dGhyb3dCaW5kaW5nRXJyb3IoIkV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgIitkZXNpcmVkQ2xhc3MubmFtZSsiLCBnb3QgYW4gaW5zdGFuY2Ugb2YgIitwdHJDbGFzcy5uYW1lKTt9cHRyPXB0ckNsYXNzLnVwY2FzdChwdHIpO3B0ckNsYXNzPXB0ckNsYXNzLmJhc2VDbGFzczt9cmV0dXJuIHB0cn1mdW5jdGlvbiBjb25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycyxoYW5kbGUpe2lmKGhhbmRsZT09PW51bGwpe2lmKHRoaXMuaXNSZWZlcmVuY2Upe3Rocm93QmluZGluZ0Vycm9yKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKTt9cmV0dXJuIDB9aWYoIWhhbmRsZS4kJCl7dGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzICInK19lbWJpbmRfcmVwcihoYW5kbGUpKyciIGFzIGEgJyt0aGlzLm5hbWUpO31pZighaGFuZGxlLiQkLnB0cil7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICIrdGhpcy5uYW1lKTt9dmFyIGhhbmRsZUNsYXNzPWhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczt2YXIgcHRyPXVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0cixoYW5kbGVDbGFzcyx0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7cmV0dXJuIHB0cn1mdW5jdGlvbiBnZW5lcmljUG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsaGFuZGxlKXt2YXIgcHRyO2lmKGhhbmRsZT09PW51bGwpe2lmKHRoaXMuaXNSZWZlcmVuY2Upe3Rocm93QmluZGluZ0Vycm9yKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKTt9aWYodGhpcy5pc1NtYXJ0UG9pbnRlcil7cHRyPXRoaXMucmF3Q29uc3RydWN0b3IoKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLHB0cik7fXJldHVybiBwdHJ9ZWxzZSB7cmV0dXJuIDB9fWlmKCFoYW5kbGUuJCQpe3Rocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJytfZW1iaW5kX3JlcHIoaGFuZGxlKSsnIiBhcyBhICcrdGhpcy5uYW1lKTt9aWYoIWhhbmRsZS4kJC5wdHIpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7fWlmKCF0aGlzLmlzQ29uc3QmJmhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3Qpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICIrKGhhbmRsZS4kJC5zbWFydFB0clR5cGU/aGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lOmhhbmRsZS4kJC5wdHJUeXBlLm5hbWUpKyIgdG8gcGFyYW1ldGVyIHR5cGUgIit0aGlzLm5hbWUpO312YXIgaGFuZGxlQ2xhc3M9aGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3B0cj11cGNhc3RQb2ludGVyKGhhbmRsZS4kJC5wdHIsaGFuZGxlQ2xhc3MsdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO2lmKHRoaXMuaXNTbWFydFBvaW50ZXIpe2lmKHVuZGVmaW5lZD09PWhhbmRsZS4kJC5zbWFydFB0cil7dGhyb3dCaW5kaW5nRXJyb3IoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIik7fXN3aXRjaCh0aGlzLnNoYXJpbmdQb2xpY3kpe2Nhc2UgMDppZihoYW5kbGUuJCQuc21hcnRQdHJUeXBlPT09dGhpcyl7cHRyPWhhbmRsZS4kJC5zbWFydFB0cjt9ZWxzZSB7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIisoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZT9oYW5kbGUuJCQuc21hcnRQdHJUeXBlLm5hbWU6aGFuZGxlLiQkLnB0clR5cGUubmFtZSkrIiB0byBwYXJhbWV0ZXIgdHlwZSAiK3RoaXMubmFtZSk7fWJyZWFrO2Nhc2UgMTpwdHI9aGFuZGxlLiQkLnNtYXJ0UHRyO2JyZWFrO2Nhc2UgMjppZihoYW5kbGUuJCQuc21hcnRQdHJUeXBlPT09dGhpcyl7cHRyPWhhbmRsZS4kJC5zbWFydFB0cjt9ZWxzZSB7dmFyIGNsb25lZEhhbmRsZT1oYW5kbGVbImNsb25lIl0oKTtwdHI9dGhpcy5yYXdTaGFyZShwdHIsX19lbXZhbF9yZWdpc3RlcigoZnVuY3Rpb24oKXtjbG9uZWRIYW5kbGVbImRlbGV0ZSJdKCk7fSkpKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLHB0cik7fX1icmVhaztkZWZhdWx0OnRocm93QmluZGluZ0Vycm9yKCJVbnN1cHBvcnRpbmcgc2hhcmluZyBwb2xpY3kiKTt9fXJldHVybiBwdHJ9ZnVuY3Rpb24gbm9uQ29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsaGFuZGxlKXtpZihoYW5kbGU9PT1udWxsKXtpZih0aGlzLmlzUmVmZXJlbmNlKXt0aHJvd0JpbmRpbmdFcnJvcigibnVsbCBpcyBub3QgYSB2YWxpZCAiK3RoaXMubmFtZSk7fXJldHVybiAwfWlmKCFoYW5kbGUuJCQpe3Rocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJytfZW1iaW5kX3JlcHIoaGFuZGxlKSsnIiBhcyBhICcrdGhpcy5uYW1lKTt9aWYoIWhhbmRsZS4kJC5wdHIpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7fWlmKGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3Qpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICIraGFuZGxlLiQkLnB0clR5cGUubmFtZSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTt9dmFyIGhhbmRsZUNsYXNzPWhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczt2YXIgcHRyPXVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0cixoYW5kbGVDbGFzcyx0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7cmV0dXJuIHB0cn1mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlKHB0cil7aWYodGhpcy5yYXdHZXRQb2ludGVlKXtwdHI9dGhpcy5yYXdHZXRQb2ludGVlKHB0cik7fXJldHVybiBwdHJ9ZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZGVzdHJ1Y3RvcihwdHIpe2lmKHRoaXMucmF3RGVzdHJ1Y3Rvcil7dGhpcy5yYXdEZXN0cnVjdG9yKHB0cik7fX1mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3QoaGFuZGxlKXtpZihoYW5kbGUhPT1udWxsKXtoYW5kbGVbImRlbGV0ZSJdKCk7fX1mdW5jdGlvbiBkb3duY2FzdFBvaW50ZXIocHRyLHB0ckNsYXNzLGRlc2lyZWRDbGFzcyl7aWYocHRyQ2xhc3M9PT1kZXNpcmVkQ2xhc3Mpe3JldHVybiBwdHJ9aWYodW5kZWZpbmVkPT09ZGVzaXJlZENsYXNzLmJhc2VDbGFzcyl7cmV0dXJuIG51bGx9dmFyIHJ2PWRvd25jYXN0UG9pbnRlcihwdHIscHRyQ2xhc3MsZGVzaXJlZENsYXNzLmJhc2VDbGFzcyk7aWYocnY9PT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm4gZGVzaXJlZENsYXNzLmRvd25jYXN0KHJ2KX1mdW5jdGlvbiBnZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50KCl7cmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRJbnN0YW5jZXMpLmxlbmd0aH1mdW5jdGlvbiBnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzKCl7dmFyIHJ2PVtdO2Zvcih2YXIgayBpbiByZWdpc3RlcmVkSW5zdGFuY2VzKXtpZihyZWdpc3RlcmVkSW5zdGFuY2VzLmhhc093blByb3BlcnR5KGspKXtydi5wdXNoKHJlZ2lzdGVyZWRJbnN0YW5jZXNba10pO319cmV0dXJuIHJ2fWZ1bmN0aW9uIHNldERlbGF5RnVuY3Rpb24oZm4pe2RlbGF5RnVuY3Rpb249Zm47aWYoZGVsZXRpb25RdWV1ZS5sZW5ndGgmJmRlbGF5RnVuY3Rpb24pe2RlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyk7fX1mdW5jdGlvbiBpbml0X2VtYmluZCgpe01vZHVsZVsiZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCJdPWdldEluaGVyaXRlZEluc3RhbmNlQ291bnQ7TW9kdWxlWyJnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzIl09Z2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcztNb2R1bGVbImZsdXNoUGVuZGluZ0RlbGV0ZXMiXT1mbHVzaFBlbmRpbmdEZWxldGVzO01vZHVsZVsic2V0RGVsYXlGdW5jdGlvbiJdPXNldERlbGF5RnVuY3Rpb247fXZhciByZWdpc3RlcmVkSW5zdGFuY2VzPXt9O2Z1bmN0aW9uIGdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLHB0cil7aWYocHRyPT09dW5kZWZpbmVkKXt0aHJvd0JpbmRpbmdFcnJvcigicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkIik7fXdoaWxlKGNsYXNzXy5iYXNlQ2xhc3Mpe3B0cj1jbGFzc18udXBjYXN0KHB0cik7Y2xhc3NfPWNsYXNzXy5iYXNlQ2xhc3M7fXJldHVybiBwdHJ9ZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2UoY2xhc3NfLHB0cil7cHRyPWdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLHB0cik7cmV0dXJuIHJlZ2lzdGVyZWRJbnN0YW5jZXNbcHRyXX1mdW5jdGlvbiBtYWtlQ2xhc3NIYW5kbGUocHJvdG90eXBlLHJlY29yZCl7aWYoIXJlY29yZC5wdHJUeXBlfHwhcmVjb3JkLnB0cil7dGhyb3dJbnRlcm5hbEVycm9yKCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlIik7fXZhciBoYXNTbWFydFB0clR5cGU9ISFyZWNvcmQuc21hcnRQdHJUeXBlO3ZhciBoYXNTbWFydFB0cj0hIXJlY29yZC5zbWFydFB0cjtpZihoYXNTbWFydFB0clR5cGUhPT1oYXNTbWFydFB0cil7dGhyb3dJbnRlcm5hbEVycm9yKCJCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWQiKTt9cmVjb3JkLmNvdW50PXt2YWx1ZToxfTtyZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUseyQkOnt2YWx1ZTpyZWNvcmR9fSl9ZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlKHB0cil7dmFyIHJhd1BvaW50ZXI9dGhpcy5nZXRQb2ludGVlKHB0cik7aWYoIXJhd1BvaW50ZXIpe3RoaXMuZGVzdHJ1Y3RvcihwdHIpO3JldHVybiBudWxsfXZhciByZWdpc3RlcmVkSW5zdGFuY2U9Z2V0SW5oZXJpdGVkSW5zdGFuY2UodGhpcy5yZWdpc3RlcmVkQ2xhc3MscmF3UG9pbnRlcik7aWYodW5kZWZpbmVkIT09cmVnaXN0ZXJlZEluc3RhbmNlKXtpZigwPT09cmVnaXN0ZXJlZEluc3RhbmNlLiQkLmNvdW50LnZhbHVlKXtyZWdpc3RlcmVkSW5zdGFuY2UuJCQucHRyPXJhd1BvaW50ZXI7cmVnaXN0ZXJlZEluc3RhbmNlLiQkLnNtYXJ0UHRyPXB0cjtyZXR1cm4gcmVnaXN0ZXJlZEluc3RhbmNlWyJjbG9uZSJdKCl9ZWxzZSB7dmFyIHJ2PXJlZ2lzdGVyZWRJbnN0YW5jZVsiY2xvbmUiXSgpO3RoaXMuZGVzdHJ1Y3RvcihwdHIpO3JldHVybiBydn19ZnVuY3Rpb24gbWFrZURlZmF1bHRIYW5kbGUoKXtpZih0aGlzLmlzU21hcnRQb2ludGVyKXtyZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLHtwdHJUeXBlOnRoaXMucG9pbnRlZVR5cGUscHRyOnJhd1BvaW50ZXIsc21hcnRQdHJUeXBlOnRoaXMsc21hcnRQdHI6cHRyfSl9ZWxzZSB7cmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0aGlzLHB0cjpwdHJ9KX19dmFyIGFjdHVhbFR5cGU9dGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShyYXdQb2ludGVyKTt2YXIgcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQ9cmVnaXN0ZXJlZFBvaW50ZXJzW2FjdHVhbFR5cGVdO2lmKCFyZWdpc3RlcmVkUG9pbnRlclJlY29yZCl7cmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcyl9dmFyIHRvVHlwZTtpZih0aGlzLmlzQ29uc3Qpe3RvVHlwZT1yZWdpc3RlcmVkUG9pbnRlclJlY29yZC5jb25zdFBvaW50ZXJUeXBlO31lbHNlIHt0b1R5cGU9cmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQucG9pbnRlclR5cGU7fXZhciBkcD1kb3duY2FzdFBvaW50ZXIocmF3UG9pbnRlcix0aGlzLnJlZ2lzdGVyZWRDbGFzcyx0b1R5cGUucmVnaXN0ZXJlZENsYXNzKTtpZihkcD09PW51bGwpe3JldHVybiBtYWtlRGVmYXVsdEhhbmRsZS5jYWxsKHRoaXMpfWlmKHRoaXMuaXNTbWFydFBvaW50ZXIpe3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0b1R5cGUscHRyOmRwLHNtYXJ0UHRyVHlwZTp0aGlzLHNtYXJ0UHRyOnB0cn0pfWVsc2Uge3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0b1R5cGUscHRyOmRwfSl9fWZ1bmN0aW9uIGluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKXtSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGUuZ2V0UG9pbnRlZT1SZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlO1JlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZS5kZXN0cnVjdG9yPVJlZ2lzdGVyZWRQb2ludGVyX2Rlc3RydWN0b3I7UmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWyJhcmdQYWNrQWR2YW5jZSJdPTg7UmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWyJyZWFkVmFsdWVGcm9tUG9pbnRlciJdPXNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyO1JlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsiZGVsZXRlT2JqZWN0Il09UmVnaXN0ZXJlZFBvaW50ZXJfZGVsZXRlT2JqZWN0O1JlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsiZnJvbVdpcmVUeXBlIl09UmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlO31mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLHJlZ2lzdGVyZWRDbGFzcyxpc1JlZmVyZW5jZSxpc0NvbnN0LGlzU21hcnRQb2ludGVyLHBvaW50ZWVUeXBlLHNoYXJpbmdQb2xpY3kscmF3R2V0UG9pbnRlZSxyYXdDb25zdHJ1Y3RvcixyYXdTaGFyZSxyYXdEZXN0cnVjdG9yKXt0aGlzLm5hbWU9bmFtZTt0aGlzLnJlZ2lzdGVyZWRDbGFzcz1yZWdpc3RlcmVkQ2xhc3M7dGhpcy5pc1JlZmVyZW5jZT1pc1JlZmVyZW5jZTt0aGlzLmlzQ29uc3Q9aXNDb25zdDt0aGlzLmlzU21hcnRQb2ludGVyPWlzU21hcnRQb2ludGVyO3RoaXMucG9pbnRlZVR5cGU9cG9pbnRlZVR5cGU7dGhpcy5zaGFyaW5nUG9saWN5PXNoYXJpbmdQb2xpY3k7dGhpcy5yYXdHZXRQb2ludGVlPXJhd0dldFBvaW50ZWU7dGhpcy5yYXdDb25zdHJ1Y3Rvcj1yYXdDb25zdHJ1Y3Rvcjt0aGlzLnJhd1NoYXJlPXJhd1NoYXJlO3RoaXMucmF3RGVzdHJ1Y3Rvcj1yYXdEZXN0cnVjdG9yO2lmKCFpc1NtYXJ0UG9pbnRlciYmcmVnaXN0ZXJlZENsYXNzLmJhc2VDbGFzcz09PXVuZGVmaW5lZCl7aWYoaXNDb25zdCl7dGhpc1sidG9XaXJlVHlwZSJdPWNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlO3RoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uPW51bGw7fWVsc2Uge3RoaXNbInRvV2lyZVR5cGUiXT1ub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTt0aGlzLmRlc3RydWN0b3JGdW5jdGlvbj1udWxsO319ZWxzZSB7dGhpc1sidG9XaXJlVHlwZSJdPWdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZTt9fWZ1bmN0aW9uIHJlcGxhY2VQdWJsaWNTeW1ib2wobmFtZSx2YWx1ZSxudW1Bcmd1bWVudHMpe2lmKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobmFtZSkpe3Rocm93SW50ZXJuYWxFcnJvcigiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2wiKTt9aWYodW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGUmJnVuZGVmaW5lZCE9PW51bUFyZ3VtZW50cyl7TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXT12YWx1ZTt9ZWxzZSB7TW9kdWxlW25hbWVdPXZhbHVlO01vZHVsZVtuYW1lXS5hcmdDb3VudD1udW1Bcmd1bWVudHM7fX1mdW5jdGlvbiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzaWduYXR1cmUscmF3RnVuY3Rpb24pe3NpZ25hdHVyZT1yZWFkTGF0aW4xU3RyaW5nKHNpZ25hdHVyZSk7ZnVuY3Rpb24gbWFrZUR5bkNhbGxlcihkeW5DYWxsKXt2YXIgYXJncz1bXTtmb3IodmFyIGk9MTtpPHNpZ25hdHVyZS5sZW5ndGg7KytpKXthcmdzLnB1c2goImEiK2kpO312YXIgbmFtZT0iZHluQ2FsbF8iK3NpZ25hdHVyZSsiXyIrcmF3RnVuY3Rpb247dmFyIGJvZHk9InJldHVybiBmdW5jdGlvbiAiK25hbWUrIigiK2FyZ3Muam9pbigiLCAiKSsiKSB7XG4iO2JvZHkrPSIgICAgcmV0dXJuIGR5bkNhbGwocmF3RnVuY3Rpb24iKyhhcmdzLmxlbmd0aD8iLCAiOiIiKSthcmdzLmpvaW4oIiwgIikrIik7XG4iO2JvZHkrPSJ9O1xuIjtyZXR1cm4gKG5ldyBGdW5jdGlvbigiZHluQ2FsbCIsInJhd0Z1bmN0aW9uIixib2R5KSkoZHluQ2FsbCxyYXdGdW5jdGlvbil9dmFyIGZwO2lmKE1vZHVsZVsiRlVOQ1RJT05fVEFCTEVfIitzaWduYXR1cmVdIT09dW5kZWZpbmVkKXtmcD1Nb2R1bGVbIkZVTkNUSU9OX1RBQkxFXyIrc2lnbmF0dXJlXVtyYXdGdW5jdGlvbl07fWVsc2UgaWYodHlwZW9mIEZVTkNUSU9OX1RBQkxFIT09InVuZGVmaW5lZCIpe2ZwPUZVTkNUSU9OX1RBQkxFW3Jhd0Z1bmN0aW9uXTt9ZWxzZSB7dmFyIGRjPU1vZHVsZVsiYXNtIl1bImR5bkNhbGxfIitzaWduYXR1cmVdO2lmKGRjPT09dW5kZWZpbmVkKXtkYz1Nb2R1bGVbImFzbSJdWyJkeW5DYWxsXyIrc2lnbmF0dXJlLnJlcGxhY2UoL2YvZywiZCIpXTtpZihkYz09PXVuZGVmaW5lZCl7dGhyb3dCaW5kaW5nRXJyb3IoIk5vIGR5bkNhbGwgaW52b2tlciBmb3Igc2lnbmF0dXJlOiAiK3NpZ25hdHVyZSk7fX1mcD1tYWtlRHluQ2FsbGVyKGRjKTt9aWYodHlwZW9mIGZwIT09ImZ1bmN0aW9uIil7dGhyb3dCaW5kaW5nRXJyb3IoInVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAiK3NpZ25hdHVyZSsiOiAiK3Jhd0Z1bmN0aW9uKTt9cmV0dXJuIGZwfXZhciBVbmJvdW5kVHlwZUVycm9yPXVuZGVmaW5lZDtmdW5jdGlvbiBnZXRUeXBlTmFtZSh0eXBlKXt2YXIgcHRyPV9fX2dldFR5cGVOYW1lKHR5cGUpO3ZhciBydj1yZWFkTGF0aW4xU3RyaW5nKHB0cik7X2ZyZWUocHRyKTtyZXR1cm4gcnZ9ZnVuY3Rpb24gdGhyb3dVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UsdHlwZXMpe3ZhciB1bmJvdW5kVHlwZXM9W107dmFyIHNlZW49e307ZnVuY3Rpb24gdmlzaXQodHlwZSl7aWYoc2Vlblt0eXBlXSl7cmV0dXJufWlmKHJlZ2lzdGVyZWRUeXBlc1t0eXBlXSl7cmV0dXJufWlmKHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0pe3R5cGVEZXBlbmRlbmNpZXNbdHlwZV0uZm9yRWFjaCh2aXNpdCk7cmV0dXJufXVuYm91bmRUeXBlcy5wdXNoKHR5cGUpO3NlZW5bdHlwZV09dHJ1ZTt9dHlwZXMuZm9yRWFjaCh2aXNpdCk7dGhyb3cgbmV3IFVuYm91bmRUeXBlRXJyb3IobWVzc2FnZSsiOiAiK3VuYm91bmRUeXBlcy5tYXAoZ2V0VHlwZU5hbWUpLmpvaW4oWyIsICJdKSl9ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MocmF3VHlwZSxyYXdQb2ludGVyVHlwZSxyYXdDb25zdFBvaW50ZXJUeXBlLGJhc2VDbGFzc1Jhd1R5cGUsZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSxnZXRBY3R1YWxUeXBlLHVwY2FzdFNpZ25hdHVyZSx1cGNhc3QsZG93bmNhc3RTaWduYXR1cmUsZG93bmNhc3QsbmFtZSxkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3Ipe25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtnZXRBY3R1YWxUeXBlPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGdldEFjdHVhbFR5cGVTaWduYXR1cmUsZ2V0QWN0dWFsVHlwZSk7aWYodXBjYXN0KXt1cGNhc3Q9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24odXBjYXN0U2lnbmF0dXJlLHVwY2FzdCk7fWlmKGRvd25jYXN0KXtkb3duY2FzdD1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkb3duY2FzdFNpZ25hdHVyZSxkb3duY2FzdCk7fXJhd0Rlc3RydWN0b3I9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKTt2YXIgbGVnYWxGdW5jdGlvbk5hbWU9bWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO2V4cG9zZVB1YmxpY1N5bWJvbChsZWdhbEZ1bmN0aW9uTmFtZSwoZnVuY3Rpb24oKXt0aHJvd1VuYm91bmRUeXBlRXJyb3IoIkNhbm5vdCBjb25zdHJ1Y3QgIituYW1lKyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLFtiYXNlQ2xhc3NSYXdUeXBlXSk7fSkpO3doZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtyYXdUeXBlLHJhd1BvaW50ZXJUeXBlLHJhd0NvbnN0UG9pbnRlclR5cGVdLGJhc2VDbGFzc1Jhd1R5cGU/W2Jhc2VDbGFzc1Jhd1R5cGVdOltdLChmdW5jdGlvbihiYXNlKXtiYXNlPWJhc2VbMF07dmFyIGJhc2VDbGFzczt2YXIgYmFzZVByb3RvdHlwZTtpZihiYXNlQ2xhc3NSYXdUeXBlKXtiYXNlQ2xhc3M9YmFzZS5yZWdpc3RlcmVkQ2xhc3M7YmFzZVByb3RvdHlwZT1iYXNlQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7fWVsc2Uge2Jhc2VQcm90b3R5cGU9Q2xhc3NIYW5kbGUucHJvdG90eXBlO312YXIgY29uc3RydWN0b3I9Y3JlYXRlTmFtZWRGdW5jdGlvbihsZWdhbEZ1bmN0aW9uTmFtZSwoZnVuY3Rpb24oKXtpZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykhPT1pbnN0YW5jZVByb3RvdHlwZSl7dGhyb3cgbmV3IEJpbmRpbmdFcnJvcigiVXNlICduZXcnIHRvIGNvbnN0cnVjdCAiK25hbWUpfWlmKHVuZGVmaW5lZD09PXJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KXt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG5hbWUrIiBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvciIpfXZhciBib2R5PXJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ3VtZW50cy5sZW5ndGhdO2lmKHVuZGVmaW5lZD09PWJvZHkpe3Rocm93IG5ldyBCaW5kaW5nRXJyb3IoIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mICIrbmFtZSsiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoIithcmd1bWVudHMubGVuZ3RoKyIpIC0gZXhwZWN0ZWQgKCIrT2JqZWN0LmtleXMocmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpLnRvU3RyaW5nKCkrIikgcGFyYW1ldGVycyBpbnN0ZWFkISIpfXJldHVybiBib2R5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pKTt2YXIgaW5zdGFuY2VQcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShiYXNlUHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6Y29uc3RydWN0b3J9fSk7Y29uc3RydWN0b3IucHJvdG90eXBlPWluc3RhbmNlUHJvdG90eXBlO3ZhciByZWdpc3RlcmVkQ2xhc3M9bmV3IFJlZ2lzdGVyZWRDbGFzcyhuYW1lLGNvbnN0cnVjdG9yLGluc3RhbmNlUHJvdG90eXBlLHJhd0Rlc3RydWN0b3IsYmFzZUNsYXNzLGdldEFjdHVhbFR5cGUsdXBjYXN0LGRvd25jYXN0KTt2YXIgcmVmZXJlbmNlQ29udmVydGVyPW5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLHJlZ2lzdGVyZWRDbGFzcyx0cnVlLGZhbHNlLGZhbHNlKTt2YXIgcG9pbnRlckNvbnZlcnRlcj1uZXcgUmVnaXN0ZXJlZFBvaW50ZXIobmFtZSsiKiIscmVnaXN0ZXJlZENsYXNzLGZhbHNlLGZhbHNlLGZhbHNlKTt2YXIgY29uc3RQb2ludGVyQ29udmVydGVyPW5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lKyIgY29uc3QqIixyZWdpc3RlcmVkQ2xhc3MsZmFsc2UsdHJ1ZSxmYWxzZSk7cmVnaXN0ZXJlZFBvaW50ZXJzW3Jhd1R5cGVdPXtwb2ludGVyVHlwZTpwb2ludGVyQ29udmVydGVyLGNvbnN0UG9pbnRlclR5cGU6Y29uc3RQb2ludGVyQ29udmVydGVyfTtyZXBsYWNlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLGNvbnN0cnVjdG9yKTtyZXR1cm4gW3JlZmVyZW5jZUNvbnZlcnRlcixwb2ludGVyQ29udmVydGVyLGNvbnN0UG9pbnRlckNvbnZlcnRlcl19KSk7fWZ1bmN0aW9uIGhlYXAzMlZlY3RvclRvQXJyYXkoY291bnQsZmlyc3RFbGVtZW50KXt2YXIgYXJyYXk9W107Zm9yKHZhciBpPTA7aTxjb3VudDtpKyspe2FycmF5LnB1c2goSEVBUDMyWyhmaXJzdEVsZW1lbnQ+PjIpK2ldKTt9cmV0dXJuIGFycmF5fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yKHJhd0NsYXNzVHlwZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsaW52b2tlclNpZ25hdHVyZSxpbnZva2VyLHJhd0NvbnN0cnVjdG9yKXt2YXIgcmF3QXJnVHlwZXM9aGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIpO2ludm9rZXI9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSxpbnZva2VyKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxbcmF3Q2xhc3NUeXBlXSwoZnVuY3Rpb24oY2xhc3NUeXBlKXtjbGFzc1R5cGU9Y2xhc3NUeXBlWzBdO3ZhciBodW1hbk5hbWU9ImNvbnN0cnVjdG9yICIrY2xhc3NUeXBlLm5hbWU7aWYodW5kZWZpbmVkPT09Y2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KXtjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHk9W107fWlmKHVuZGVmaW5lZCE9PWNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudC0xXSl7dGhyb3cgbmV3IEJpbmRpbmdFcnJvcigiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbnN0cnVjdG9ycyB3aXRoIGlkZW50aWNhbCBudW1iZXIgb2YgcGFyYW1ldGVycyAoIisoYXJnQ291bnQtMSkrIikgZm9yIGNsYXNzICciK2NsYXNzVHlwZS5uYW1lKyInISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyEiKX1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQtMV09ZnVuY3Rpb24gdW5ib3VuZFR5cGVIYW5kbGVyKCl7dGhyb3dVbmJvdW5kVHlwZUVycm9yKCJDYW5ub3QgY29uc3RydWN0ICIrY2xhc3NUeXBlLm5hbWUrIiBkdWUgdG8gdW5ib3VuZCB0eXBlcyIscmF3QXJnVHlwZXMpO307d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10scmF3QXJnVHlwZXMsKGZ1bmN0aW9uKGFyZ1R5cGVzKXtjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQtMV09ZnVuY3Rpb24gY29uc3RydWN0b3JfYm9keSgpe2lmKGFyZ3VtZW50cy5sZW5ndGghPT1hcmdDb3VudC0xKXt0aHJvd0JpbmRpbmdFcnJvcihodW1hbk5hbWUrIiBjYWxsZWQgd2l0aCAiK2FyZ3VtZW50cy5sZW5ndGgrIiBhcmd1bWVudHMsIGV4cGVjdGVkICIrKGFyZ0NvdW50LTEpKTt9dmFyIGRlc3RydWN0b3JzPVtdO3ZhciBhcmdzPW5ldyBBcnJheShhcmdDb3VudCk7YXJnc1swXT1yYXdDb25zdHJ1Y3Rvcjtmb3IodmFyIGk9MTtpPGFyZ0NvdW50OysraSl7YXJnc1tpXT1hcmdUeXBlc1tpXVsidG9XaXJlVHlwZSJdKGRlc3RydWN0b3JzLGFyZ3VtZW50c1tpLTFdKTt9dmFyIHB0cj1pbnZva2VyLmFwcGx5KG51bGwsYXJncyk7cnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO3JldHVybiBhcmdUeXBlc1swXVsiZnJvbVdpcmVUeXBlIl0ocHRyKX07cmV0dXJuIFtdfSkpO3JldHVybiBbXX0pKTt9ZnVuY3Rpb24gbmV3Xyhjb25zdHJ1Y3Rvcixhcmd1bWVudExpc3Qpe2lmKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpe3Rocm93IG5ldyBUeXBlRXJyb3IoIm5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAiK3R5cGVvZiBjb25zdHJ1Y3RvcisiIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uIil9dmFyIGR1bW15PWNyZWF0ZU5hbWVkRnVuY3Rpb24oY29uc3RydWN0b3IubmFtZXx8InVua25vd25GdW5jdGlvbk5hbWUiLChmdW5jdGlvbigpe30pKTtkdW1teS5wcm90b3R5cGU9Y29uc3RydWN0b3IucHJvdG90eXBlO3ZhciBvYmo9bmV3IGR1bW15O3ZhciByPWNvbnN0cnVjdG9yLmFwcGx5KG9iaixhcmd1bWVudExpc3QpO3JldHVybiByIGluc3RhbmNlb2YgT2JqZWN0P3I6b2JqfWZ1bmN0aW9uIGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSxhcmdUeXBlcyxjbGFzc1R5cGUsY3BwSW52b2tlckZ1bmMsY3BwVGFyZ2V0RnVuYyl7dmFyIGFyZ0NvdW50PWFyZ1R5cGVzLmxlbmd0aDtpZihhcmdDb3VudDwyKXt0aHJvd0JpbmRpbmdFcnJvcigiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhIik7fXZhciBpc0NsYXNzTWV0aG9kRnVuYz1hcmdUeXBlc1sxXSE9PW51bGwmJmNsYXNzVHlwZSE9PW51bGw7dmFyIG5lZWRzRGVzdHJ1Y3RvclN0YWNrPWZhbHNlO2Zvcih2YXIgaT0xO2k8YXJnVHlwZXMubGVuZ3RoOysraSl7aWYoYXJnVHlwZXNbaV0hPT1udWxsJiZhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb249PT11bmRlZmluZWQpe25lZWRzRGVzdHJ1Y3RvclN0YWNrPXRydWU7YnJlYWt9fXZhciByZXR1cm5zPWFyZ1R5cGVzWzBdLm5hbWUhPT0idm9pZCI7dmFyIGFyZ3NMaXN0PSIiO3ZhciBhcmdzTGlzdFdpcmVkPSIiO2Zvcih2YXIgaT0wO2k8YXJnQ291bnQtMjsrK2kpe2FyZ3NMaXN0Kz0oaSE9PTA/IiwgIjoiIikrImFyZyIraTthcmdzTGlzdFdpcmVkKz0oaSE9PTA/IiwgIjoiIikrImFyZyIraSsiV2lyZWQiO312YXIgaW52b2tlckZuQm9keT0icmV0dXJuIGZ1bmN0aW9uICIrbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKGh1bWFuTmFtZSkrIigiK2FyZ3NMaXN0KyIpIHtcbiIrImlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAiKyhhcmdDb3VudC0yKSsiKSB7XG4iKyJ0aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gIitodW1hbk5hbWUrIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCAiKyhhcmdDb3VudC0yKSsiIGFyZ3MhJyk7XG4iKyJ9XG4iO2lmKG5lZWRzRGVzdHJ1Y3RvclN0YWNrKXtpbnZva2VyRm5Cb2R5Kz0idmFyIGRlc3RydWN0b3JzID0gW107XG4iO312YXIgZHRvclN0YWNrPW5lZWRzRGVzdHJ1Y3RvclN0YWNrPyJkZXN0cnVjdG9ycyI6Im51bGwiO3ZhciBhcmdzMT1bInRocm93QmluZGluZ0Vycm9yIiwiaW52b2tlciIsImZuIiwicnVuRGVzdHJ1Y3RvcnMiLCJyZXRUeXBlIiwiY2xhc3NQYXJhbSJdO3ZhciBhcmdzMj1bdGhyb3dCaW5kaW5nRXJyb3IsY3BwSW52b2tlckZ1bmMsY3BwVGFyZ2V0RnVuYyxydW5EZXN0cnVjdG9ycyxhcmdUeXBlc1swXSxhcmdUeXBlc1sxXV07aWYoaXNDbGFzc01ldGhvZEZ1bmMpe2ludm9rZXJGbkJvZHkrPSJ2YXIgdGhpc1dpcmVkID0gY2xhc3NQYXJhbS50b1dpcmVUeXBlKCIrZHRvclN0YWNrKyIsIHRoaXMpO1xuIjt9Zm9yKHZhciBpPTA7aTxhcmdDb3VudC0yOysraSl7aW52b2tlckZuQm9keSs9InZhciBhcmciK2krIldpcmVkID0gYXJnVHlwZSIraSsiLnRvV2lyZVR5cGUoIitkdG9yU3RhY2srIiwgYXJnIitpKyIpOyAvLyAiK2FyZ1R5cGVzW2krMl0ubmFtZSsiXG4iO2FyZ3MxLnB1c2goImFyZ1R5cGUiK2kpO2FyZ3MyLnB1c2goYXJnVHlwZXNbaSsyXSk7fWlmKGlzQ2xhc3NNZXRob2RGdW5jKXthcmdzTGlzdFdpcmVkPSJ0aGlzV2lyZWQiKyhhcmdzTGlzdFdpcmVkLmxlbmd0aD4wPyIsICI6IiIpK2FyZ3NMaXN0V2lyZWQ7fWludm9rZXJGbkJvZHkrPShyZXR1cm5zPyJ2YXIgcnYgPSAiOiIiKSsiaW52b2tlcihmbiIrKGFyZ3NMaXN0V2lyZWQubGVuZ3RoPjA/IiwgIjoiIikrYXJnc0xpc3RXaXJlZCsiKTtcbiI7aWYobmVlZHNEZXN0cnVjdG9yU3RhY2spe2ludm9rZXJGbkJvZHkrPSJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4iO31lbHNlIHtmb3IodmFyIGk9aXNDbGFzc01ldGhvZEZ1bmM/MToyO2k8YXJnVHlwZXMubGVuZ3RoOysraSl7dmFyIHBhcmFtTmFtZT1pPT09MT8idGhpc1dpcmVkIjoiYXJnIisoaS0yKSsiV2lyZWQiO2lmKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbiE9PW51bGwpe2ludm9rZXJGbkJvZHkrPXBhcmFtTmFtZSsiX2R0b3IoIitwYXJhbU5hbWUrIik7IC8vICIrYXJnVHlwZXNbaV0ubmFtZSsiXG4iO2FyZ3MxLnB1c2gocGFyYW1OYW1lKyJfZHRvciIpO2FyZ3MyLnB1c2goYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uKTt9fX1pZihyZXR1cm5zKXtpbnZva2VyRm5Cb2R5Kz0idmFyIHJldCA9IHJldFR5cGUuZnJvbVdpcmVUeXBlKHJ2KTtcbiIrInJldHVybiByZXQ7XG4iO31pbnZva2VyRm5Cb2R5Kz0ifVxuIjthcmdzMS5wdXNoKGludm9rZXJGbkJvZHkpO3ZhciBpbnZva2VyRnVuY3Rpb249bmV3XyhGdW5jdGlvbixhcmdzMSkuYXBwbHkobnVsbCxhcmdzMik7cmV0dXJuIGludm9rZXJGdW5jdGlvbn1mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbihyYXdDbGFzc1R5cGUsbWV0aG9kTmFtZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsaW52b2tlclNpZ25hdHVyZSxyYXdJbnZva2VyLGNvbnRleHQsaXNQdXJlVmlydHVhbCl7dmFyIHJhd0FyZ1R5cGVzPWhlYXAzMlZlY3RvclRvQXJyYXkoYXJnQ291bnQscmF3QXJnVHlwZXNBZGRyKTttZXRob2ROYW1lPXJlYWRMYXRpbjFTdHJpbmcobWV0aG9kTmFtZSk7cmF3SW52b2tlcj1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLHJhd0ludm9rZXIpO3doZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLFtyYXdDbGFzc1R5cGVdLChmdW5jdGlvbihjbGFzc1R5cGUpe2NsYXNzVHlwZT1jbGFzc1R5cGVbMF07dmFyIGh1bWFuTmFtZT1jbGFzc1R5cGUubmFtZSsiLiIrbWV0aG9kTmFtZTtpZihpc1B1cmVWaXJ0dWFsKXtjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLnB1c2gobWV0aG9kTmFtZSk7fWZ1bmN0aW9uIHVuYm91bmRUeXBlc0hhbmRsZXIoKXt0aHJvd1VuYm91bmRUeXBlRXJyb3IoIkNhbm5vdCBjYWxsICIraHVtYW5OYW1lKyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLHJhd0FyZ1R5cGVzKTt9dmFyIHByb3RvPWNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7dmFyIG1ldGhvZD1wcm90b1ttZXRob2ROYW1lXTtpZih1bmRlZmluZWQ9PT1tZXRob2R8fHVuZGVmaW5lZD09PW1ldGhvZC5vdmVybG9hZFRhYmxlJiZtZXRob2QuY2xhc3NOYW1lIT09Y2xhc3NUeXBlLm5hbWUmJm1ldGhvZC5hcmdDb3VudD09PWFyZ0NvdW50LTIpe3VuYm91bmRUeXBlc0hhbmRsZXIuYXJnQ291bnQ9YXJnQ291bnQtMjt1bmJvdW5kVHlwZXNIYW5kbGVyLmNsYXNzTmFtZT1jbGFzc1R5cGUubmFtZTtwcm90b1ttZXRob2ROYW1lXT11bmJvdW5kVHlwZXNIYW5kbGVyO31lbHNlIHtlbnN1cmVPdmVybG9hZFRhYmxlKHByb3RvLG1ldGhvZE5hbWUsaHVtYW5OYW1lKTtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50LTJdPXVuYm91bmRUeXBlc0hhbmRsZXI7fXdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLHJhd0FyZ1R5cGVzLChmdW5jdGlvbihhcmdUeXBlcyl7dmFyIG1lbWJlckZ1bmN0aW9uPWNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSxhcmdUeXBlcyxjbGFzc1R5cGUscmF3SW52b2tlcixjb250ZXh0KTtpZih1bmRlZmluZWQ9PT1wcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlKXttZW1iZXJGdW5jdGlvbi5hcmdDb3VudD1hcmdDb3VudC0yO3Byb3RvW21ldGhvZE5hbWVdPW1lbWJlckZ1bmN0aW9uO31lbHNlIHtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50LTJdPW1lbWJlckZ1bmN0aW9uO31yZXR1cm4gW119KSk7cmV0dXJuIFtdfSkpO312YXIgZW12YWxfZnJlZV9saXN0PVtdO3ZhciBlbXZhbF9oYW5kbGVfYXJyYXk9W3t9LHt2YWx1ZTp1bmRlZmluZWR9LHt2YWx1ZTpudWxsfSx7dmFsdWU6dHJ1ZX0se3ZhbHVlOmZhbHNlfV07ZnVuY3Rpb24gX19lbXZhbF9kZWNyZWYoaGFuZGxlKXtpZihoYW5kbGU+NCYmMD09PS0tZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0ucmVmY291bnQpe2VtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdPXVuZGVmaW5lZDtlbXZhbF9mcmVlX2xpc3QucHVzaChoYW5kbGUpO319ZnVuY3Rpb24gY291bnRfZW12YWxfaGFuZGxlcygpe3ZhciBjb3VudD0wO2Zvcih2YXIgaT01O2k8ZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsrK2kpe2lmKGVtdmFsX2hhbmRsZV9hcnJheVtpXSE9PXVuZGVmaW5lZCl7Kytjb3VudDt9fXJldHVybiBjb3VudH1mdW5jdGlvbiBnZXRfZmlyc3RfZW12YWwoKXtmb3IodmFyIGk9NTtpPGVtdmFsX2hhbmRsZV9hcnJheS5sZW5ndGg7KytpKXtpZihlbXZhbF9oYW5kbGVfYXJyYXlbaV0hPT11bmRlZmluZWQpe3JldHVybiBlbXZhbF9oYW5kbGVfYXJyYXlbaV19fXJldHVybiBudWxsfWZ1bmN0aW9uIGluaXRfZW12YWwoKXtNb2R1bGVbImNvdW50X2VtdmFsX2hhbmRsZXMiXT1jb3VudF9lbXZhbF9oYW5kbGVzO01vZHVsZVsiZ2V0X2ZpcnN0X2VtdmFsIl09Z2V0X2ZpcnN0X2VtdmFsO31mdW5jdGlvbiBfX2VtdmFsX3JlZ2lzdGVyKHZhbHVlKXtzd2l0Y2godmFsdWUpe2Nhc2UgdW5kZWZpbmVkOntyZXR1cm4gMX1jYXNlIG51bGw6e3JldHVybiAyfWNhc2UgdHJ1ZTp7cmV0dXJuIDN9Y2FzZSBmYWxzZTp7cmV0dXJuIDR9ZGVmYXVsdDp7dmFyIGhhbmRsZT1lbXZhbF9mcmVlX2xpc3QubGVuZ3RoP2VtdmFsX2ZyZWVfbGlzdC5wb3AoKTplbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoO2VtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdPXtyZWZjb3VudDoxLHZhbHVlOnZhbHVlfTtyZXR1cm4gaGFuZGxlfX19ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwocmF3VHlwZSxuYW1lKXtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjooZnVuY3Rpb24oaGFuZGxlKXt2YXIgcnY9ZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0udmFsdWU7X19lbXZhbF9kZWNyZWYoaGFuZGxlKTtyZXR1cm4gcnZ9KSwidG9XaXJlVHlwZSI6KGZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtyZXR1cm4gX19lbXZhbF9yZWdpc3Rlcih2YWx1ZSl9KSwiYXJnUGFja0FkdmFuY2UiOjgsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO31mdW5jdGlvbiBfZW1iaW5kX3JlcHIodil7aWYodj09PW51bGwpe3JldHVybiAibnVsbCJ9dmFyIHQ9dHlwZW9mIHY7aWYodD09PSJvYmplY3QifHx0PT09ImFycmF5Inx8dD09PSJmdW5jdGlvbiIpe3JldHVybiB2LnRvU3RyaW5nKCl9ZWxzZSB7cmV0dXJuICIiK3Z9fWZ1bmN0aW9uIGZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaGlmdCl7c3dpdGNoKHNoaWZ0KXtjYXNlIDI6cmV0dXJuKGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQRjMyW3BvaW50ZXI+PjJdKX0pO2Nhc2UgMzpyZXR1cm4oZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfSk7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGZsb2F0IHR5cGU6ICIrbmFtZSl9fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0KHJhd1R5cGUsbmFtZSxzaXplKXt2YXIgc2hpZnQ9Z2V0U2hpZnRGcm9tU2l6ZShzaXplKTtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjooZnVuY3Rpb24odmFsdWUpe3JldHVybiB2YWx1ZX0pLCJ0b1dpcmVUeXBlIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PSJudW1iZXIiJiZ0eXBlb2YgdmFsdWUhPT0iYm9vbGVhbiIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICInK19lbWJpbmRfcmVwcih2YWx1ZSkrJyIgdG8gJyt0aGlzLm5hbWUpfXJldHVybiB2YWx1ZX0pLCJhcmdQYWNrQWR2YW5jZSI6OCwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaGlmdCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9ZnVuY3Rpb24gaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2hpZnQsc2lnbmVkKXtzd2l0Y2goc2hpZnQpe2Nhc2UgMDpyZXR1cm4gc2lnbmVkP2Z1bmN0aW9uIHJlYWRTOEZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQOFtwb2ludGVyXX06ZnVuY3Rpb24gcmVhZFU4RnJvbVBvaW50ZXIocG9pbnRlcil7cmV0dXJuIEhFQVBVOFtwb2ludGVyXX07Y2FzZSAxOnJldHVybiBzaWduZWQ/ZnVuY3Rpb24gcmVhZFMxNkZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQMTZbcG9pbnRlcj4+MV19OmZ1bmN0aW9uIHJlYWRVMTZGcm9tUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gSEVBUFUxNltwb2ludGVyPj4xXX07Y2FzZSAyOnJldHVybiBzaWduZWQ/ZnVuY3Rpb24gcmVhZFMzMkZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQMzJbcG9pbnRlcj4+Ml19OmZ1bmN0aW9uIHJlYWRVMzJGcm9tUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gSEVBUFUzMltwb2ludGVyPj4yXX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGludGVnZXIgdHlwZTogIituYW1lKX19ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcihwcmltaXRpdmVUeXBlLG5hbWUsc2l6ZSxtaW5SYW5nZSxtYXhSYW5nZSl7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO2lmKG1heFJhbmdlPT09LTEpe21heFJhbmdlPTQyOTQ5NjcyOTU7fXZhciBzaGlmdD1nZXRTaGlmdEZyb21TaXplKHNpemUpO3ZhciBmcm9tV2lyZVR5cGU9KGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdmFsdWV9KTtpZihtaW5SYW5nZT09PTApe3ZhciBiaXRzaGlmdD0zMi04KnNpemU7ZnJvbVdpcmVUeXBlPShmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIHZhbHVlPDxiaXRzaGlmdD4+PmJpdHNoaWZ0fSk7fXZhciBpc1Vuc2lnbmVkVHlwZT1uYW1lLmluZGV4T2YoInVuc2lnbmVkIikhPS0xO3JlZ2lzdGVyVHlwZShwcmltaXRpdmVUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZnJvbVdpcmVUeXBlLCJ0b1dpcmVUeXBlIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PSJudW1iZXIiJiZ0eXBlb2YgdmFsdWUhPT0iYm9vbGVhbiIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICInK19lbWJpbmRfcmVwcih2YWx1ZSkrJyIgdG8gJyt0aGlzLm5hbWUpfWlmKHZhbHVlPG1pblJhbmdlfHx2YWx1ZT5tYXhSYW5nZSl7dGhyb3cgbmV3IFR5cGVFcnJvcignUGFzc2luZyBhIG51bWJlciAiJytfZW1iaW5kX3JlcHIodmFsdWUpKyciIGZyb20gSlMgc2lkZSB0byBDL0MrKyBzaWRlIHRvIGFuIGFyZ3VtZW50IG9mIHR5cGUgIicrbmFtZSsnIiwgd2hpY2ggaXMgb3V0c2lkZSB0aGUgdmFsaWQgcmFuZ2UgWycrbWluUmFuZ2UrIiwgIittYXhSYW5nZSsiXSEiKX1yZXR1cm4gaXNVbnNpZ25lZFR5cGU/dmFsdWU+Pj4wOnZhbHVlfDB9KSwiYXJnUGFja0FkdmFuY2UiOjgsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaGlmdCxtaW5SYW5nZSE9PTApLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3KHJhd1R5cGUsZGF0YVR5cGVJbmRleCxuYW1lKXt2YXIgdHlwZU1hcHBpbmc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XTt2YXIgVEE9dHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07ZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpe2hhbmRsZT1oYW5kbGU+PjI7dmFyIGhlYXA9SEVBUFUzMjt2YXIgc2l6ZT1oZWFwW2hhbmRsZV07dmFyIGRhdGE9aGVhcFtoYW5kbGUrMV07cmV0dXJuIG5ldyBUQShoZWFwWyJidWZmZXIiXSxkYXRhLHNpemUpfW5hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmRlY29kZU1lbW9yeVZpZXcsImFyZ1BhY2tBZHZhbmNlIjo4LCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZGVjb2RlTWVtb3J5Vmlld30se2lnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6dHJ1ZX0pO31mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nKHJhd1R5cGUsbmFtZSl7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6KGZ1bmN0aW9uKHZhbHVlKXt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBhPW5ldyBBcnJheShsZW5ndGgpO2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7YVtpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEhFQVBVOFt2YWx1ZSs0K2ldKTt9X2ZyZWUodmFsdWUpO3JldHVybiBhLmpvaW4oIiIpfSksInRvV2lyZVR5cGUiOihmdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dmFsdWU9bmV3IFVpbnQ4QXJyYXkodmFsdWUpO31mdW5jdGlvbiBnZXRUQUVsZW1lbnQodGEsaW5kZXgpe3JldHVybiB0YVtpbmRleF19ZnVuY3Rpb24gZ2V0U3RyaW5nRWxlbWVudChzdHJpbmcsaW5kZXgpe3JldHVybiBzdHJpbmcuY2hhckNvZGVBdChpbmRleCl9dmFyIGdldEVsZW1lbnQ7aWYodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtnZXRFbGVtZW50PWdldFRBRWxlbWVudDt9ZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KXtnZXRFbGVtZW50PWdldFRBRWxlbWVudDt9ZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSl7Z2V0RWxlbWVudD1nZXRUQUVsZW1lbnQ7fWVsc2UgaWYodHlwZW9mIHZhbHVlPT09InN0cmluZyIpe2dldEVsZW1lbnQ9Z2V0U3RyaW5nRWxlbWVudDt9ZWxzZSB7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt9dmFyIGxlbmd0aD12YWx1ZS5sZW5ndGg7dmFyIHB0cj1fbWFsbG9jKDQrbGVuZ3RoKTtIRUFQVTMyW3B0cj4+Ml09bGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7dmFyIGNoYXJDb2RlPWdldEVsZW1lbnQodmFsdWUsaSk7aWYoY2hhckNvZGU+MjU1KXtfZnJlZShwdHIpO3Rocm93QmluZGluZ0Vycm9yKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKTt9SEVBUFU4W3B0cis0K2ldPWNoYXJDb2RlO31pZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUscHRyKTt9cmV0dXJuIHB0cn0pLCJhcmdQYWNrQWR2YW5jZSI6OCwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjooZnVuY3Rpb24ocHRyKXtfZnJlZShwdHIpO30pfSk7fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nKHJhd1R5cGUsY2hhclNpemUsbmFtZSl7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBnZXRIZWFwLHNoaWZ0O2lmKGNoYXJTaXplPT09Mil7Z2V0SGVhcD0oZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUxNn0pO3NoaWZ0PTE7fWVsc2UgaWYoY2hhclNpemU9PT00KXtnZXRIZWFwPShmdW5jdGlvbigpe3JldHVybiBIRUFQVTMyfSk7c2hpZnQ9Mjt9cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjooZnVuY3Rpb24odmFsdWUpe3ZhciBIRUFQPWdldEhlYXAoKTt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBhPW5ldyBBcnJheShsZW5ndGgpO3ZhciBzdGFydD12YWx1ZSs0Pj5zaGlmdDtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2FbaV09U3RyaW5nLmZyb21DaGFyQ29kZShIRUFQW3N0YXJ0K2ldKTt9X2ZyZWUodmFsdWUpO3JldHVybiBhLmpvaW4oIiIpfSksInRvV2lyZVR5cGUiOihmdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7dmFyIEhFQVA9Z2V0SGVhcCgpO3ZhciBsZW5ndGg9dmFsdWUubGVuZ3RoO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCpjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aDt2YXIgc3RhcnQ9cHRyKzQ+PnNoaWZ0O2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7SEVBUFtzdGFydCtpXT12YWx1ZS5jaGFyQ29kZUF0KGkpO31pZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUscHRyKTt9cmV0dXJuIHB0cn0pLCJhcmdQYWNrQWR2YW5jZSI6OCwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjooZnVuY3Rpb24ocHRyKXtfZnJlZShwdHIpO30pfSk7fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdChyYXdUeXBlLG5hbWUsY29uc3RydWN0b3JTaWduYXR1cmUscmF3Q29uc3RydWN0b3IsZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKXtzdHJ1Y3RSZWdpc3RyYXRpb25zW3Jhd1R5cGVdPXtuYW1lOnJlYWRMYXRpbjFTdHJpbmcobmFtZSkscmF3Q29uc3RydWN0b3I6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oY29uc3RydWN0b3JTaWduYXR1cmUscmF3Q29uc3RydWN0b3IpLHJhd0Rlc3RydWN0b3I6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKSxmaWVsZHM6W119O31mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQoc3RydWN0VHlwZSxmaWVsZE5hbWUsZ2V0dGVyUmV0dXJuVHlwZSxnZXR0ZXJTaWduYXR1cmUsZ2V0dGVyLGdldHRlckNvbnRleHQsc2V0dGVyQXJndW1lbnRUeXBlLHNldHRlclNpZ25hdHVyZSxzZXR0ZXIsc2V0dGVyQ29udGV4dCl7c3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXS5maWVsZHMucHVzaCh7ZmllbGROYW1lOnJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKSxnZXR0ZXJSZXR1cm5UeXBlOmdldHRlclJldHVyblR5cGUsZ2V0dGVyOmVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGdldHRlclNpZ25hdHVyZSxnZXR0ZXIpLGdldHRlckNvbnRleHQ6Z2V0dGVyQ29udGV4dCxzZXR0ZXJBcmd1bWVudFR5cGU6c2V0dGVyQXJndW1lbnRUeXBlLHNldHRlcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzZXR0ZXJTaWduYXR1cmUsc2V0dGVyKSxzZXR0ZXJDb250ZXh0OnNldHRlckNvbnRleHR9KTt9ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfdm9pZChyYXdUeXBlLG5hbWUpe25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7aXNWb2lkOnRydWUsbmFtZTpuYW1lLCJhcmdQYWNrQWR2YW5jZSI6MCwiZnJvbVdpcmVUeXBlIjooZnVuY3Rpb24oKXtyZXR1cm4gdW5kZWZpbmVkfSksInRvV2lyZVR5cGUiOihmdW5jdGlvbihkZXN0cnVjdG9ycyxvKXtyZXR1cm4gdW5kZWZpbmVkfSl9KTt9ZnVuY3Rpb24gX2Fib3J0KCl7TW9kdWxlWyJhYm9ydCJdKCk7fXZhciBfZW52aXJvbj1TVEFUSUNUT1A7U1RBVElDVE9QKz0xNjtmdW5jdGlvbiBfX19idWlsZEVudmlyb25tZW50KGVudil7dmFyIE1BWF9FTlZfVkFMVUVTPTY0O3ZhciBUT1RBTF9FTlZfU0laRT0xMDI0O3ZhciBwb29sUHRyO3ZhciBlbnZQdHI7aWYoIV9fX2J1aWxkRW52aXJvbm1lbnQuY2FsbGVkKXtfX19idWlsZEVudmlyb25tZW50LmNhbGxlZD10cnVlO0VOVlsiVVNFUiJdPUVOVlsiTE9HTkFNRSJdPSJ3ZWJfdXNlciI7RU5WWyJQQVRIIl09Ii8iO0VOVlsiUFdEIl09Ii8iO0VOVlsiSE9NRSJdPSIvaG9tZS93ZWJfdXNlciI7RU5WWyJMQU5HIl09IkMuVVRGLTgiO0VOVlsiXyJdPU1vZHVsZVsidGhpc1Byb2dyYW0iXTtwb29sUHRyPXN0YXRpY0FsbG9jKFRPVEFMX0VOVl9TSVpFKTtlbnZQdHI9c3RhdGljQWxsb2MoTUFYX0VOVl9WQUxVRVMqNCk7SEVBUDMyW2VudlB0cj4+Ml09cG9vbFB0cjtIRUFQMzJbX2Vudmlyb24+PjJdPWVudlB0cjt9ZWxzZSB7ZW52UHRyPUhFQVAzMltfZW52aXJvbj4+Ml07cG9vbFB0cj1IRUFQMzJbZW52UHRyPj4yXTt9dmFyIHN0cmluZ3M9W107dmFyIHRvdGFsU2l6ZT0wO2Zvcih2YXIga2V5IGluIGVudil7aWYodHlwZW9mIGVudltrZXldPT09InN0cmluZyIpe3ZhciBsaW5lPWtleSsiPSIrZW52W2tleV07c3RyaW5ncy5wdXNoKGxpbmUpO3RvdGFsU2l6ZSs9bGluZS5sZW5ndGg7fX1pZih0b3RhbFNpemU+VE9UQUxfRU5WX1NJWkUpe3Rocm93IG5ldyBFcnJvcigiRW52aXJvbm1lbnQgc2l6ZSBleGNlZWRlZCBUT1RBTF9FTlZfU0laRSEiKX12YXIgcHRyU2l6ZT00O2Zvcih2YXIgaT0wO2k8c3RyaW5ncy5sZW5ndGg7aSsrKXt2YXIgbGluZT1zdHJpbmdzW2ldO3dyaXRlQXNjaWlUb01lbW9yeShsaW5lLHBvb2xQdHIpO0hFQVAzMltlbnZQdHIraSpwdHJTaXplPj4yXT1wb29sUHRyO3Bvb2xQdHIrPWxpbmUubGVuZ3RoKzE7fUhFQVAzMltlbnZQdHIrc3RyaW5ncy5sZW5ndGgqcHRyU2l6ZT4+Ml09MDt9dmFyIEVOVj17fTtmdW5jdGlvbiBfZ2V0ZW52KG5hbWUpe2lmKG5hbWU9PT0wKXJldHVybiAwO25hbWU9UG9pbnRlcl9zdHJpbmdpZnkobmFtZSk7aWYoIUVOVi5oYXNPd25Qcm9wZXJ0eShuYW1lKSlyZXR1cm4gMDtpZihfZ2V0ZW52LnJldClfZnJlZShfZ2V0ZW52LnJldCk7X2dldGVudi5yZXQ9YWxsb2NhdGVVVEY4KEVOVltuYW1lXSk7cmV0dXJuIF9nZXRlbnYucmV0fWZ1bmN0aW9uIF9nZXRncm5hbSgpe01vZHVsZVsicHJpbnRFcnIiXSgibWlzc2luZyBmdW5jdGlvbjogZ2V0Z3JuYW0iKTthYm9ydCgtMSk7fWZ1bmN0aW9uIF9nZXRwd25hbSgpe3Rocm93ICJnZXRwd25hbTogVE9ETyJ9ZnVuY3Rpb24gX2pzQ2xvc2UoKXtyZXR1cm4ganNBUEkuY2xvc2UuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9qc0NyZWF0ZShmaWxlbmFtZSl7cmV0dXJuIGpzQVBJLmNyZWF0ZS5jYWxsKG51bGwsVVRGMzJUb1N0cmluZyhmaWxlbmFtZSkpfWZ1bmN0aW9uIF9qc09wZW4oZmlsZW5hbWUpe3JldHVybiBqc0FQSS5vcGVuLmNhbGwobnVsbCxVVEYzMlRvU3RyaW5nKGZpbGVuYW1lKSl9ZnVuY3Rpb24gX2pzUmVhZCgpe3JldHVybiBqc0FQSS5yZWFkLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBfanNTZWVrKGZkLG9mZnNldCxtZXRob2Qpe3JldHVybiBqc0FQSS5zZWVrLmNhbGwobnVsbCxmZCxvZmZzZXQsVVRGOFRvU3RyaW5nKG1ldGhvZCkpfWZ1bmN0aW9uIF9qc1RlbGwoKXtyZXR1cm4ganNBUEkudGVsbC5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gX2pzV3JpdGUoKXtyZXR1cm4ganNBUEkud3JpdGUuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9sbHZtX2VoX3R5cGVpZF9mb3IodHlwZSl7cmV0dXJuIHR5cGV9dmFyIF9fX3RtX2N1cnJlbnQ9U1RBVElDVE9QO1NUQVRJQ1RPUCs9NDg7dmFyIF9fX3RtX3RpbWV6b25lPWFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZygiR01UIiksImk4IixBTExPQ19TVEFUSUMpO3ZhciBfdHpuYW1lPVNUQVRJQ1RPUDtTVEFUSUNUT1ArPTE2O3ZhciBfZGF5bGlnaHQ9U1RBVElDVE9QO1NUQVRJQ1RPUCs9MTY7dmFyIF90aW1lem9uZT1TVEFUSUNUT1A7U1RBVElDVE9QKz0xNjtmdW5jdGlvbiBfdHpzZXQoKXtpZihfdHpzZXQuY2FsbGVkKXJldHVybjtfdHpzZXQuY2FsbGVkPXRydWU7SEVBUDMyW190aW1lem9uZT4+Ml09KG5ldyBEYXRlKS5nZXRUaW1lem9uZU9mZnNldCgpKjYwO3ZhciB3aW50ZXI9bmV3IERhdGUoMmUzLDAsMSk7dmFyIHN1bW1lcj1uZXcgRGF0ZSgyZTMsNiwxKTtIRUFQMzJbX2RheWxpZ2h0Pj4yXT1OdW1iZXIod2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCkhPXN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpKTtmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKXt2YXIgbWF0Y2g9ZGF0ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXCgoW0EtWmEteiBdKylcKSQvKTtyZXR1cm4gbWF0Y2g/bWF0Y2hbMV06IkdNVCJ9dmFyIHdpbnRlck5hbWU9ZXh0cmFjdFpvbmUod2ludGVyKTt2YXIgc3VtbWVyTmFtZT1leHRyYWN0Wm9uZShzdW1tZXIpO3ZhciB3aW50ZXJOYW1lUHRyPWFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZyh3aW50ZXJOYW1lKSwiaTgiLEFMTE9DX05PUk1BTCk7dmFyIHN1bW1lck5hbWVQdHI9YWxsb2NhdGUoaW50QXJyYXlGcm9tU3RyaW5nKHN1bW1lck5hbWUpLCJpOCIsQUxMT0NfTk9STUFMKTtpZihzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTx3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKSl7SEVBUDMyW190em5hbWU+PjJdPXdpbnRlck5hbWVQdHI7SEVBUDMyW190em5hbWUrND4+Ml09c3VtbWVyTmFtZVB0cjt9ZWxzZSB7SEVBUDMyW190em5hbWU+PjJdPXN1bW1lck5hbWVQdHI7SEVBUDMyW190em5hbWUrND4+Ml09d2ludGVyTmFtZVB0cjt9fWZ1bmN0aW9uIF9sb2NhbHRpbWVfcih0aW1lLHRtUHRyKXtfdHpzZXQoKTt2YXIgZGF0ZT1uZXcgRGF0ZShIRUFQMzJbdGltZT4+Ml0qMWUzKTtIRUFQMzJbdG1QdHI+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0hFQVAzMlt0bVB0cis0Pj4yXT1kYXRlLmdldE1pbnV0ZXMoKTtIRUFQMzJbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRIb3VycygpO0hFQVAzMlt0bVB0cisxMj4+Ml09ZGF0ZS5nZXREYXRlKCk7SEVBUDMyW3RtUHRyKzE2Pj4yXT1kYXRlLmdldE1vbnRoKCk7SEVBUDMyW3RtUHRyKzIwPj4yXT1kYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtIRUFQMzJbdG1QdHIrMjQ+PjJdPWRhdGUuZ2V0RGF5KCk7dmFyIHN0YXJ0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7SEVBUDMyW3RtUHRyKzI4Pj4yXT15ZGF5O0hFQVAzMlt0bVB0ciszNj4+Ml09LShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjApO3ZhciBzdW1tZXJPZmZzZXQ9KG5ldyBEYXRlKDJlMyw2LDEpKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB3aW50ZXJPZmZzZXQ9c3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZHN0PShzdW1tZXJPZmZzZXQhPXdpbnRlck9mZnNldCYmZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbih3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KSl8MDtIRUFQMzJbdG1QdHIrMzI+PjJdPWRzdDt2YXIgem9uZVB0cj1IRUFQMzJbX3R6bmFtZSsoZHN0PzQ6MCk+PjJdO0hFQVAzMlt0bVB0cis0MD4+Ml09em9uZVB0cjtyZXR1cm4gdG1QdHJ9ZnVuY3Rpb24gX2xvY2FsdGltZSh0aW1lKXtyZXR1cm4gX2xvY2FsdGltZV9yKHRpbWUsX19fdG1fY3VycmVudCl9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LHNyYyxudW0pe0hFQVBVOC5zZXQoSEVBUFU4LnN1YmFycmF5KHNyYyxzcmMrbnVtKSxkZXN0KTtyZXR1cm4gZGVzdH1mdW5jdGlvbiBfbWt0aW1lKHRtUHRyKXtfdHpzZXQoKTt2YXIgZGF0ZT1uZXcgRGF0ZShIRUFQMzJbdG1QdHIrMjA+PjJdKzE5MDAsSEVBUDMyW3RtUHRyKzE2Pj4yXSxIRUFQMzJbdG1QdHIrMTI+PjJdLEhFQVAzMlt0bVB0cis4Pj4yXSxIRUFQMzJbdG1QdHIrND4+Ml0sSEVBUDMyW3RtUHRyPj4yXSwwKTt2YXIgZHN0PUhFQVAzMlt0bVB0ciszMj4+Ml07dmFyIGd1ZXNzZWRPZmZzZXQ9ZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgc3VtbWVyT2Zmc2V0PShuZXcgRGF0ZSgyZTMsNiwxKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgd2ludGVyT2Zmc2V0PXN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGRzdE9mZnNldD1NYXRoLm1pbih3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KTtpZihkc3Q8MCl7SEVBUDMyW3RtUHRyKzMyPj4yXT1OdW1iZXIoc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRzdE9mZnNldD09Z3Vlc3NlZE9mZnNldCk7fWVsc2UgaWYoZHN0PjAhPShkc3RPZmZzZXQ9PWd1ZXNzZWRPZmZzZXQpKXt2YXIgbm9uRHN0T2Zmc2V0PU1hdGgubWF4KHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO3ZhciB0cnVlT2Zmc2V0PWRzdD4wP2RzdE9mZnNldDpub25Ec3RPZmZzZXQ7ZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpKyh0cnVlT2Zmc2V0LWd1ZXNzZWRPZmZzZXQpKjZlNCk7fUhFQVAzMlt0bVB0cisyND4+Ml09ZGF0ZS5nZXREYXkoKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQuZ2V0VGltZSgpKS8oMWUzKjYwKjYwKjI0KXwwO0hFQVAzMlt0bVB0cisyOD4+Ml09eWRheTtyZXR1cm4gZGF0ZS5nZXRUaW1lKCkvMWUzfDB9dmFyIFBUSFJFQURfU1BFQ0lGSUM9e307ZnVuY3Rpb24gX3B0aHJlYWRfZ2V0c3BlY2lmaWMoa2V5KXtyZXR1cm4gUFRIUkVBRF9TUEVDSUZJQ1trZXldfHwwfXZhciBQVEhSRUFEX1NQRUNJRklDX05FWFRfS0VZPTE7ZnVuY3Rpb24gX3B0aHJlYWRfa2V5X2NyZWF0ZShrZXksZGVzdHJ1Y3Rvcil7aWYoa2V5PT0wKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUlOVkFMfUhFQVAzMltrZXk+PjJdPVBUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVk7UFRIUkVBRF9TUEVDSUZJQ1tQVEhSRUFEX1NQRUNJRklDX05FWFRfS0VZXT0wO1BUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVkrKztyZXR1cm4gMH1mdW5jdGlvbiBfcHRocmVhZF9vbmNlKHB0cixmdW5jKXtpZighX3B0aHJlYWRfb25jZS5zZWVuKV9wdGhyZWFkX29uY2Uuc2Vlbj17fTtpZihwdHIgaW4gX3B0aHJlYWRfb25jZS5zZWVuKXJldHVybjtNb2R1bGVbImR5bkNhbGxfdiJdKGZ1bmMpO19wdGhyZWFkX29uY2Uuc2VlbltwdHJdPTE7fWZ1bmN0aW9uIF9wdGhyZWFkX3NldHNwZWNpZmljKGtleSx2YWx1ZSl7aWYoIShrZXkgaW4gUFRIUkVBRF9TUEVDSUZJQykpe3JldHVybiBFUlJOT19DT0RFUy5FSU5WQUx9UFRIUkVBRF9TUEVDSUZJQ1trZXldPXZhbHVlO3JldHVybiAwfWZ1bmN0aW9uIF90aW1lKHB0cil7dmFyIHJldD1EYXRlLm5vdygpLzFlM3wwO2lmKHB0cil7SEVBUDMyW3B0cj4+Ml09cmV0O31yZXR1cm4gcmV0fUZTLnN0YXRpY0luaXQoKTtfX0FUSU5JVF9fLnVuc2hpZnQoKGZ1bmN0aW9uKCl7aWYoIU1vZHVsZVsibm9GU0luaXQiXSYmIUZTLmluaXQuaW5pdGlhbGl6ZWQpRlMuaW5pdCgpO30pKTtfX0FUTUFJTl9fLnB1c2goKGZ1bmN0aW9uKCl7RlMuaWdub3JlUGVybWlzc2lvbnM9ZmFsc2U7fSkpO19fQVRFWElUX18ucHVzaCgoZnVuY3Rpb24oKXtGUy5xdWl0KCk7fSkpO19fQVRJTklUX18udW5zaGlmdCgoZnVuY3Rpb24oKXtUVFkuaW5pdCgpO30pKTtfX0FURVhJVF9fLnB1c2goKGZ1bmN0aW9uKCl7VFRZLnNodXRkb3duKCk7fSkpOw0KSW50ZXJuYWxFcnJvcj1Nb2R1bGVbIkludGVybmFsRXJyb3IiXT1leHRlbmRFcnJvcihFcnJvciwiSW50ZXJuYWxFcnJvciIpO2VtYmluZF9pbml0X2NoYXJDb2RlcygpO0JpbmRpbmdFcnJvcj1Nb2R1bGVbIkJpbmRpbmdFcnJvciJdPWV4dGVuZEVycm9yKEVycm9yLCJCaW5kaW5nRXJyb3IiKTtpbml0X0NsYXNzSGFuZGxlKCk7aW5pdF9SZWdpc3RlcmVkUG9pbnRlcigpO2luaXRfZW1iaW5kKCk7VW5ib3VuZFR5cGVFcnJvcj1Nb2R1bGVbIlVuYm91bmRUeXBlRXJyb3IiXT1leHRlbmRFcnJvcihFcnJvciwiVW5ib3VuZFR5cGVFcnJvciIpO2luaXRfZW12YWwoKTtfX19idWlsZEVudmlyb25tZW50KEVOVik7RFlOQU1JQ1RPUF9QVFI9c3RhdGljQWxsb2MoNCk7U1RBQ0tfQkFTRT1TVEFDS1RPUD1hbGlnbk1lbW9yeShTVEFUSUNUT1ApO1NUQUNLX01BWD1TVEFDS19CQVNFK1RPVEFMX1NUQUNLO0RZTkFNSUNfQkFTRT1hbGlnbk1lbW9yeShTVEFDS19NQVgpO0hFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml09RFlOQU1JQ19CQVNFO3N0YXRpY1NlYWxlZD10cnVlO2Z1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LGRvbnRBZGROdWxsLGxlbmd0aCl7dmFyIGxlbj1sZW5ndGg+MD9sZW5ndGg6bGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7dmFyIHU4YXJyYXk9bmV3IEFycmF5KGxlbik7dmFyIG51bUJ5dGVzV3JpdHRlbj1zdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LHU4YXJyYXksMCx1OGFycmF5Lmxlbmd0aCk7aWYoZG9udEFkZE51bGwpdThhcnJheS5sZW5ndGg9bnVtQnl0ZXNXcml0dGVuO3JldHVybiB1OGFycmF5fU1vZHVsZVsid2FzbVRhYmxlU2l6ZSJdPTMxNjtNb2R1bGVbIndhc21NYXhUYWJsZVNpemUiXT0zMTY7ZnVuY3Rpb24gaW52b2tlX2koaW5kZXgpe3RyeXtyZXR1cm4gTW9kdWxlWyJkeW5DYWxsX2kiXShpbmRleCl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LGExKXt0cnl7cmV0dXJuIE1vZHVsZVsiZHluQ2FsbF9paSJdKGluZGV4LGExKX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfaWlpKGluZGV4LGExLGEyKXt0cnl7cmV0dXJuIE1vZHVsZVsiZHluQ2FsbF9paWkiXShpbmRleCxhMSxhMil9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX2lpaWkoaW5kZXgsYTEsYTIsYTMpe3RyeXtyZXR1cm4gTW9kdWxlWyJkeW5DYWxsX2lpaWkiXShpbmRleCxhMSxhMixhMyl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX2lpaWlpKGluZGV4LGExLGEyLGEzLGE0KXt0cnl7cmV0dXJuIE1vZHVsZVsiZHluQ2FsbF9paWlpaSJdKGluZGV4LGExLGEyLGEzLGE0KX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfaWlpaWlpaShpbmRleCxhMSxhMixhMyxhNCxhNSxhNil7dHJ5e3JldHVybiBNb2R1bGVbImR5bkNhbGxfaWlpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2KX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfaWlpaWlpaWlpaShpbmRleCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSl7dHJ5e3JldHVybiBNb2R1bGVbImR5bkNhbGxfaWlpaWlpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfaWlpaWlpamlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KXt0cnl7cmV0dXJuIE1vZHVsZVsiZHluQ2FsbF9paWlpaWlqaWkiXShpbmRleCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX2lqaihpbmRleCxhMSxhMixhMyxhNCl7dHJ5e3JldHVybiBNb2R1bGVbImR5bkNhbGxfaWpqIl0oaW5kZXgsYTEsYTIsYTMsYTQpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09Im51bWJlciImJmUhPT0ibG9uZ2ptcCIpdGhyb3cgZTtNb2R1bGVbInNldFRocmV3Il0oMSwwKTt9fWZ1bmN0aW9uIGludm9rZV9qaShpbmRleCxhMSl7dHJ5e3JldHVybiBNb2R1bGVbImR5bkNhbGxfamkiXShpbmRleCxhMSl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3YoaW5kZXgpe3RyeXtNb2R1bGVbImR5bkNhbGxfdiJdKGluZGV4KTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpKGluZGV4LGExKXt0cnl7TW9kdWxlWyJkeW5DYWxsX3ZpIl0oaW5kZXgsYTEpO31jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfdmlpKGluZGV4LGExLGEyKXt0cnl7TW9kdWxlWyJkeW5DYWxsX3ZpaSJdKGluZGV4LGExLGEyKTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsYTEsYTIsYTMpe3RyeXtNb2R1bGVbImR5bkNhbGxfdmlpaSJdKGluZGV4LGExLGEyLGEzKTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpaWlpKGluZGV4LGExLGEyLGEzLGE0KXt0cnl7TW9kdWxlWyJkeW5DYWxsX3ZpaWlpIl0oaW5kZXgsYTEsYTIsYTMsYTQpO31jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfdmlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1KXt0cnl7TW9kdWxlWyJkeW5DYWxsX3ZpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1KTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYpe3RyeXtNb2R1bGVbImR5bkNhbGxfdmlpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2KTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpe3RyeXtNb2R1bGVbImR5bkNhbGxfdmlpaWlpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KTt9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT0ibnVtYmVyIiYmZSE9PSJsb25nam1wIil0aHJvdyBlO01vZHVsZVsic2V0VGhyZXciXSgxLDApO319ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5LGExMCl7dHJ5e01vZHVsZVsiZHluQ2FsbF92aWlpaWlpaWlpaSJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5LGExMCk7fWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09Im51bWJlciImJmUhPT0ibG9uZ2ptcCIpdGhyb3cgZTtNb2R1bGVbInNldFRocmV3Il0oMSwwKTt9fWZ1bmN0aW9uIGludm9rZV92aWooaW5kZXgsYTEsYTIsYTMpe3RyeXtNb2R1bGVbImR5bkNhbGxfdmlqIl0oaW5kZXgsYTEsYTIsYTMpO31jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1mdW5jdGlvbiBpbnZva2VfdmlqaShpbmRleCxhMSxhMixhMyxhNCl7dHJ5e01vZHVsZVsiZHluQ2FsbF92aWppIl0oaW5kZXgsYTEsYTIsYTMsYTQpO31jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlWyJzZXRUaHJldyJdKDEsMCk7fX1Nb2R1bGUuYXNtR2xvYmFsQXJnPXt9O01vZHVsZS5hc21MaWJyYXJ5QXJnPXsiYWJvcnQiOmFib3J0LCJlbmxhcmdlTWVtb3J5IjplbmxhcmdlTWVtb3J5LCJnZXRUb3RhbE1lbW9yeSI6Z2V0VG90YWxNZW1vcnksImFib3J0T25DYW5ub3RHcm93TWVtb3J5IjphYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSwiaW52b2tlX2kiOmludm9rZV9pLCJpbnZva2VfaWkiOmludm9rZV9paSwiaW52b2tlX2lpaSI6aW52b2tlX2lpaSwiaW52b2tlX2lpaWkiOmludm9rZV9paWlpLCJpbnZva2VfaWlpaWkiOmludm9rZV9paWlpaSwiaW52b2tlX2lpaWlpaWkiOmludm9rZV9paWlpaWlpLCJpbnZva2VfaWlpaWlpaWlpaSI6aW52b2tlX2lpaWlpaWlpaWksImludm9rZV9paWlpaWlqaWkiOmludm9rZV9paWlpaWlqaWksImludm9rZV9pamoiOmludm9rZV9pamosImludm9rZV9qaSI6aW52b2tlX2ppLCJpbnZva2VfdiI6aW52b2tlX3YsImludm9rZV92aSI6aW52b2tlX3ZpLCJpbnZva2VfdmlpIjppbnZva2VfdmlpLCJpbnZva2VfdmlpaSI6aW52b2tlX3ZpaWksImludm9rZV92aWlpaSI6aW52b2tlX3ZpaWlpLCJpbnZva2VfdmlpaWlpIjppbnZva2VfdmlpaWlpLCJpbnZva2VfdmlpaWlpaSI6aW52b2tlX3ZpaWlpaWksImludm9rZV92aWlpaWlpaWlpIjppbnZva2VfdmlpaWlpaWlpaSwiaW52b2tlX3ZpaWlpaWlpaWlpIjppbnZva2VfdmlpaWlpaWlpaWksImludm9rZV92aWoiOmludm9rZV92aWosImludm9rZV92aWppIjppbnZva2VfdmlqaSwiX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbiI6X19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbiwiX19fY3hhX2JlZ2luX2NhdGNoIjpfX19jeGFfYmVnaW5fY2F0Y2gsIl9fX2N4YV9lbmRfY2F0Y2giOl9fX2N4YV9lbmRfY2F0Y2gsIl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIiOl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIsIl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMiOl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMsIl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzQiOl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzQsIl9fX2N4YV9mcmVlX2V4Y2VwdGlvbiI6X19fY3hhX2ZyZWVfZXhjZXB0aW9uLCJfX19jeGFfdGhyb3ciOl9fX2N4YV90aHJvdywiX19fbG9jayI6X19fbG9jaywiX19fbWFwX2ZpbGUiOl9fX21hcF9maWxlLCJfX19yZXN1bWVFeGNlcHRpb24iOl9fX3Jlc3VtZUV4Y2VwdGlvbiwiX19fc2V0RXJyTm8iOl9fX3NldEVyck5vLCJfX19zeXNjYWxsMTQwIjpfX19zeXNjYWxsMTQwLCJfX19zeXNjYWxsMTQ1IjpfX19zeXNjYWxsMTQ1LCJfX19zeXNjYWxsMTQ2IjpfX19zeXNjYWxsMTQ2LCJfX19zeXNjYWxsMTgzIjpfX19zeXNjYWxsMTgzLCJfX19zeXNjYWxsMTk4IjpfX19zeXNjYWxsMTk4LCJfX19zeXNjYWxsMjAiOl9fX3N5c2NhbGwyMCwiX19fc3lzY2FsbDYiOl9fX3N5c2NhbGw2LCJfX19zeXNjYWxsNjAiOl9fX3N5c2NhbGw2MCwiX19fc3lzY2FsbDgzIjpfX19zeXNjYWxsODMsIl9fX3N5c2NhbGw5MSI6X19fc3lzY2FsbDkxLCJfX191bmxvY2siOl9fX3VubG9jaywiX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0IjpfX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3QsIl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wiOl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsIl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzIjpfX2VtYmluZF9yZWdpc3Rlcl9jbGFzcywiX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IiOl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yLCJfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbiI6X19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24sIl9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsIjpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCwiX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQiOl9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0LCJfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyIjpfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLCJfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyI6X19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsIl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmciOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcsIl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nIjpfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZywiX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0IjpfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3QsIl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZCI6X19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0X2ZpZWxkLCJfX2VtYmluZF9yZWdpc3Rlcl92b2lkIjpfX2VtYmluZF9yZWdpc3Rlcl92b2lkLCJfYWJvcnQiOl9hYm9ydCwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyI6X2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZywiX2dldGVudiI6X2dldGVudiwiX2dldGdybmFtIjpfZ2V0Z3JuYW0sIl9nZXRwd25hbSI6X2dldHB3bmFtLCJfanNDbG9zZSI6X2pzQ2xvc2UsIl9qc0NyZWF0ZSI6X2pzQ3JlYXRlLCJfanNPcGVuIjpfanNPcGVuLCJfanNSZWFkIjpfanNSZWFkLCJfanNTZWVrIjpfanNTZWVrLCJfanNUZWxsIjpfanNUZWxsLCJfanNXcml0ZSI6X2pzV3JpdGUsIl9sbHZtX2VoX3R5cGVpZF9mb3IiOl9sbHZtX2VoX3R5cGVpZF9mb3IsIl9sb2NhbHRpbWUiOl9sb2NhbHRpbWUsIl9ta3RpbWUiOl9ta3RpbWUsIl9wdGhyZWFkX2dldHNwZWNpZmljIjpfcHRocmVhZF9nZXRzcGVjaWZpYywiX3B0aHJlYWRfa2V5X2NyZWF0ZSI6X3B0aHJlYWRfa2V5X2NyZWF0ZSwiX3B0aHJlYWRfb25jZSI6X3B0aHJlYWRfb25jZSwiX3B0aHJlYWRfc2V0c3BlY2lmaWMiOl9wdGhyZWFkX3NldHNwZWNpZmljLCJfdGltZSI6X3RpbWUsIkRZTkFNSUNUT1BfUFRSIjpEWU5BTUlDVE9QX1BUUiwiU1RBQ0tUT1AiOlNUQUNLVE9QfTt2YXIgYXNtPU1vZHVsZVsiYXNtIl0oTW9kdWxlLmFzbUdsb2JhbEFyZyxNb2R1bGUuYXNtTGlicmFyeUFyZyxidWZmZXIpO01vZHVsZVsiYXNtIl09YXNtO3ZhciBfX0dMT0JBTF9fc3ViX0lfYmluZF9jcHA9TW9kdWxlWyJfX0dMT0JBTF9fc3ViX0lfYmluZF9jcHAiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fR0xPQkFMX19zdWJfSV9icmlkZ2VfY3BwPU1vZHVsZVsiX19HTE9CQUxfX3N1Yl9JX2JyaWRnZV9jcHAiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiX19HTE9CQUxfX3N1Yl9JX2JyaWRnZV9jcHAiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX19HTE9CQUxfX3N1Yl9JX2NyY19jcHA9TW9kdWxlWyJfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfX0dMT0JBTF9fc3ViX0lfZ2xvYmFsX2NwcD1Nb2R1bGVbIl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bIl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fX2N4YV9jYW5fY2F0Y2g9TW9kdWxlWyJfX19jeGFfY2FuX2NhdGNoIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bIl9fX2N4YV9jYW5fY2F0Y2giXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1Nb2R1bGVbIl9fX2N4YV9pc19wb2ludGVyX3R5cGUiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiX19fY3hhX2lzX3BvaW50ZXJfdHlwZSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbIl9fX2Vycm5vX2xvY2F0aW9uIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bIl9fX2Vycm5vX2xvY2F0aW9uIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fX2dldFR5cGVOYW1lPU1vZHVsZVsiX19fZ2V0VHlwZU5hbWUiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiX19fZ2V0VHlwZU5hbWUiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnk9TW9kdWxlWyJfZW1zY3JpcHRlbl9yZXBsYWNlX21lbW9yeSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJfZW1zY3JpcHRlbl9yZXBsYWNlX21lbW9yeSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfZnJlZT1Nb2R1bGVbIl9mcmVlIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bIl9mcmVlIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9tYWxsb2M9TW9kdWxlWyJfbWFsbG9jIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bIl9tYWxsb2MiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgc2V0VGVtcFJldDA9TW9kdWxlWyJzZXRUZW1wUmV0MCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJzZXRUZW1wUmV0MCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBzZXRUaHJldz1Nb2R1bGVbInNldFRocmV3Il09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bInNldFRocmV3Il0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIHN0YWNrQWxsb2M9TW9kdWxlWyJzdGFja0FsbG9jIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bInN0YWNrQWxsb2MiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9kaWk9TW9kdWxlWyJkeW5DYWxsX2RpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX2RpaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2k9TW9kdWxlWyJkeW5DYWxsX2kiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF9pIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWk9TW9kdWxlWyJkeW5DYWxsX2lpIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfaWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paWk9TW9kdWxlWyJkeW5DYWxsX2lpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX2lpaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpaWk9TW9kdWxlWyJkeW5DYWxsX2lpaWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF9paWlpIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWlpaWk9TW9kdWxlWyJkeW5DYWxsX2lpaWlpIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfaWlpaWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paWlpaWk9TW9kdWxlWyJkeW5DYWxsX2lpaWlpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX2lpaWlpaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpaWlpaWk9TW9kdWxlWyJkeW5DYWxsX2lpaWlpaWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF9paWlpaWlpIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWlpaWlpaWlpaT1Nb2R1bGVbImR5bkNhbGxfaWlpaWlpaWlpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX2lpaWlpaWlpaWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paWlpaWlqaWk9TW9kdWxlWyJkeW5DYWxsX2lpaWlpaWppaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX2lpaWlpaWppaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lqaj1Nb2R1bGVbImR5bkNhbGxfaWpqIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfaWpqIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfamk9TW9kdWxlWyJkeW5DYWxsX2ppIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfamkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92PU1vZHVsZVsiZHluQ2FsbF92Il09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfdiJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpPU1vZHVsZVsiZHluQ2FsbF92aSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX3ZpIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpPU1vZHVsZVsiZHluQ2FsbF92aWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF92aWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWlkPU1vZHVsZVsiZHluQ2FsbF92aWlkIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfdmlpZCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpaWk9TW9kdWxlWyJkeW5DYWxsX3ZpaWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF92aWlpIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpaWk9TW9kdWxlWyJkeW5DYWxsX3ZpaWlpIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfdmlpaWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWlpaWk9TW9kdWxlWyJkeW5DYWxsX3ZpaWlpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX3ZpaWlpaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpaWlpaWk9TW9kdWxlWyJkeW5DYWxsX3ZpaWlpaWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF92aWlpaWlpIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpaWlpaWlpaT1Nb2R1bGVbImR5bkNhbGxfdmlpaWlpaWlpaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX3ZpaWlpaWlpaWkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWlpaWlpaWlpaT1Nb2R1bGVbImR5bkNhbGxfdmlpaWlpaWlpaWkiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlWyJhc20iXVsiZHluQ2FsbF92aWlpaWlpaWlpaSJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3Zpaj1Nb2R1bGVbImR5bkNhbGxfdmlqIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVsiYXNtIl1bImR5bkNhbGxfdmlqIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlqaT1Nb2R1bGVbImR5bkNhbGxfdmlqaSJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbImFzbSJdWyJkeW5DYWxsX3ZpamkiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTtNb2R1bGVbImFzbSJdPWFzbTtmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPSJFeGl0U3RhdHVzIjt0aGlzLm1lc3NhZ2U9IlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoIitzdGF0dXMrIikiO3RoaXMuc3RhdHVzPXN0YXR1czt9RXhpdFN0YXR1cy5wcm90b3R5cGU9bmV3IEVycm9yO0V4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yPUV4aXRTdGF0dXM7dmFyIGluaXRpYWxTdGFja1RvcDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIU1vZHVsZVsiY2FsbGVkUnVuIl0pcnVuKCk7aWYoIU1vZHVsZVsiY2FsbGVkUnVuIl0pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcjt9O2Z1bmN0aW9uIHJ1bihhcmdzKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXJldHVybjtpZihNb2R1bGVbImNhbGxlZFJ1biJdKXJldHVybjtmdW5jdGlvbiBkb1J1bigpe2lmKE1vZHVsZVsiY2FsbGVkUnVuIl0pcmV0dXJuO01vZHVsZVsiY2FsbGVkUnVuIl09dHJ1ZTtpZihBQk9SVClyZXR1cm47ZW5zdXJlSW5pdFJ1bnRpbWUoKTtwcmVNYWluKCk7aWYoTW9kdWxlWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKU1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSgpO3Bvc3RSdW4oKTt9aWYoTW9kdWxlWyJzZXRTdGF0dXMiXSl7TW9kdWxlWyJzZXRTdGF0dXMiXSgiUnVubmluZy4uLiIpO3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtNb2R1bGVbInNldFN0YXR1cyJdKCIiKTt9KSwxKTtkb1J1bigpO30pLDEpO31lbHNlIHtkb1J1bigpO319TW9kdWxlWyJydW4iXT1ydW47ZnVuY3Rpb24gZXhpdChzdGF0dXMsaW1wbGljaXQpe2lmKGltcGxpY2l0JiZNb2R1bGVbIm5vRXhpdFJ1bnRpbWUiXSYmc3RhdHVzPT09MCl7cmV0dXJufWlmKE1vZHVsZVsibm9FeGl0UnVudGltZSJdKTtlbHNlIHtBQk9SVD10cnVlO1NUQUNLVE9QPWluaXRpYWxTdGFja1RvcDtleGl0UnVudGltZSgpO2lmKE1vZHVsZVsib25FeGl0Il0pTW9kdWxlWyJvbkV4aXQiXShzdGF0dXMpO31pZihFTlZJUk9OTUVOVF9JU19OT0RFKXtwcm9jZXNzWyJleGl0Il0oc3RhdHVzKTt9TW9kdWxlWyJxdWl0Il0oc3RhdHVzLG5ldyBFeGl0U3RhdHVzKHN0YXR1cykpO31Nb2R1bGVbImV4aXQiXT1leGl0O2Z1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVsib25BYm9ydCJdKXtNb2R1bGVbIm9uQWJvcnQiXSh3aGF0KTt9aWYod2hhdCE9PXVuZGVmaW5lZCl7TW9kdWxlLnByaW50KHdoYXQpO01vZHVsZS5wcmludEVycih3aGF0KTt3aGF0PUpTT04uc3RyaW5naWZ5KHdoYXQpO31lbHNlIHt3aGF0PSIiO31BQk9SVD10cnVlO3Rocm93ICJhYm9ydCgiK3doYXQrIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uIn1Nb2R1bGVbImFib3J0Il09YWJvcnQ7aWYoTW9kdWxlWyJwcmVJbml0Il0pe2lmKHR5cGVvZiBNb2R1bGVbInByZUluaXQiXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZUluaXQiXT1bTW9kdWxlWyJwcmVJbml0Il1dO3doaWxlKE1vZHVsZVsicHJlSW5pdCJdLmxlbmd0aD4wKXtNb2R1bGVbInByZUluaXQiXS5wb3AoKSgpO319TW9kdWxlWyJub0V4aXRSdW50aW1lIl09dHJ1ZTtydW4oKTsNCg0KICByZXR1cm4gdW5wYWNrOw0KfTsNCi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KDQoNCg0KLyoqDQogKiBSZXR1cm5zIGEgUHJvbWlzZSBjb250YWluaW5nIHRoZSByYXIgZXh0cmFjdG9yIGZvciB0aGUgZ2l2ZW4gZmlsZW5hbWUuDQogKiBAcHJpdmF0ZQ0KICovDQpmdW5jdGlvbiBnZXRFeHRyYWN0b3IodXJsKSB7DQogIHJldHVybiBmZXRjaChuZXcgUmVxdWVzdCh1cmwpKQ0KICAgIC50aGVuKHJlc3BvbnNlID0+IHsNCiAgICAgIGlmIChyZXNwb25zZS5vaykgDQogICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpOw0KICAgICAgZWxzZSB7DQogICAgICAgIHRocm93IG5ldyBFcnJvcignNDA0IEVycm9yOiBGaWxlIG5vdCBmb3VuZC4nKTsNCiAgICAgIH0NCiAgICB9KQ0KICAgIC50aGVuKGJ1ZmZlciA9PiB1bnBhY2tCcmlkZ2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoYnVmZmVyKSk7DQp9DQoNCi8qKg0KICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXR0ZWQgY29udGVudHMgb2YgdGhlIGdpdmVuIGZpbGUuDQogKiBAcHJpdmF0ZQ0KICovDQpmdW5jdGlvbiBleHRyYWN0KHsgcmVzb3VyY2VJZCwgdXJsIH0pIHsNCiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgew0KDQogICAgaWYgKCF1bnBhY2tCcmlkZ2UpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnBhY2tCcmlkZ2Ugbm90IGRldGVjdGVkJyk7IH0NCiAgICBpZiAoIXVucGFjaykgeyB0aHJvdyBuZXcgRXJyb3IoJ3VucGFjayBub3QgZGV0ZWN0ZWQnKTsgfQ0KDQogICAgZ2V0RXh0cmFjdG9yKHVybCkudGhlbihleHRyYWN0b3IgPT4gew0KICAgICAgLy8gcmV0dXJuIGV4dHJhY3Rvci5leHRyYWN0QWxsKCk7DQogICAgICByZXNvbHZlKGV4dHJhY3Rvci5leHRyYWN0QWxsKCkpOw0KICAgIH0sIGVyciA9PiB7DQogICAgICByZWplY3QoZXJyKTsNCiAgICB9KTsNCiAgfSkNCn0NCg0KZnVuY3Rpb24gcmV0dXJuRGF0YShldmVudCwgZGF0YSkgew0KDQogIGNvbnN0IFtzdGF0ZSwgbGlzdF0gPSBkYXRhOw0KICBpZiAoc3RhdGUuc3RhdGUgPT0gJ0ZBSUwnKSB7DQogICAgY29uc3QgcmVzdWx0ID0gew0KICAgICAgdHlwZTogJ0VSUk9SJywNCiAgICAgIHJlYXNvbjogc3RhdGUucmVhc29uLA0KICAgICAgbXNnOiBzdGF0ZS5tc2csDQogICAgICByZXNvdXJjZUlkOiBldmVudC5kYXRhLnJlc291cmNlSWQsDQogICAgICB1cmw6IGV2ZW50LmRhdGEudXJsDQogICAgfTsNCiAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3VsdCk7DQogICAgcmV0dXJuOw0KICB9DQogIGNvbnN0IHJlc3VsdCA9IHsNCiAgICAgIHR5cGU6ICdGSU5JU0hFRCcsDQogICAgICByZXNvdXJjZUlkOiBldmVudC5kYXRhLnJlc291cmNlSWQsDQogICAgICBlbnRyaWVzOiB7fQ0KICB9Ow0KDQogIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTsNCiAgaWYgKGxpc3QgJiYgbGlzdC5maWxlcykgew0KICAgIGZvcihjb25zdCBmaWxlIG9mIGxpc3QuZmlsZXMpIHsNCiAgICAgIHJlc3VsdC5lbnRyaWVzW2ZpbGUuZmlsZUhlYWRlci5uYW1lXSA9IGZpbGUuZXh0cmFjdFsxXTsNCiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChmaWxlLmV4dHJhY3RbMV0uYnVmZmVyKTsNCiAgICB9DQogIH0NCiAgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQsIHRyYW5zZmVyYWJsZXMpOw0KfQ0KDQovKioNCiAqIExpc3RlbiBmb3IgbWVzc2FnZXMgc2VudCB0byB0aGUgd29ya2VyLg0KICogQHByaXZhdGUNCiAqLw0Kb25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHsNCiAgaWYoZXZlbnQuZGF0YS50eXBlID09ICdpbml0Jykgew0KICAgIHVucGFjayA9IGluaXR1bnBhY2soZXZlbnQuZGF0YS53YXNtVXJsKTsNCiAgICB1bnBhY2sub25SdW50aW1lSW5pdGlhbGl6ZWQgPSAoKSA9PiBwb3N0TWVzc2FnZSh7IHR5cGU6ICdXQVNNX0xPQURFRCcgfSk7DQogIH0NCiAgZWxzZSBpZihldmVudC5kYXRhLnR5cGUgPT0gJ2ZldGNoJykgew0KICAJZXh0cmFjdChldmVudC5kYXRhKS50aGVuKHVucGFja2VkID0+IHsNCiAgICAgIHJldHVybkRhdGEoZXZlbnQsIHVucGFja2VkKTsNCiAgICB9LCBlcnIgPT4gew0KICAgICAgY29uc3QgcmVzdWx0ID0gew0KICAgICAgICAgIHR5cGU6ICdFUlJPUicsDQogICAgICAgICAgcmVzb3VyY2VJZDogZXZlbnQuZGF0YS5yZXNvdXJjZUlkLA0KICAgICAgICAgIHVybDogZXZlbnQuZGF0YS51cmwNCiAgICAgIH07DQogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3VsdCk7DQogICAgfSk7DQogIH0NCiAgZWxzZSBpZihldmVudC5kYXRhLnR5cGUgPT0gJ3VucGFjaycpIHsNCiAgICBjb25zdCB7IGJ1ZmZlciB9ID0gZXZlbnQuZGF0YTsNCiAgICANCiAgICBpZiAoIXVucGFja0JyaWRnZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VucGFja0JyaWRnZSBub3QgZGV0ZWN0ZWQnKTsgfQ0KICAgIGlmICghdW5wYWNrKSB7IHRocm93IG5ldyBFcnJvcigndW5wYWNrIG5vdCBkZXRlY3RlZCcpOyB9DQoNCiAgICBjb25zdCBleHRyYWN0b3IgPSB1bnBhY2tCcmlkZ2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoYnVmZmVyKTsNCiAgICBjb25zdCB1bnBhY2tlZCA9IGV4dHJhY3Rvci5leHRyYWN0QWxsKCk7DQogICAgcmV0dXJuRGF0YShldmVudCwgdW5wYWNrZWQpOw0KICB9DQp9Ow0KDQovKioNCiAqIFdoZW4gdGhlIFdBU00gcnVudGltZSBoYXMgYmVlbiBpbml0aWFsaXplZCBvbiB0aGUgdW5wYWNrLmpzIG1vZHVsZSwgc2VuZCBhIG1lc3NhZ2UgaW5kaWNhdGluZw0KICogdGhhdCB0aGUgbGlicmFyeSBpcyByZWFkeS4NCiAqLwoK', 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVzb3VyY2VMb2FkZXJXb3JrZXIuanMiLCJzb3VyY2VzIjpbInNyYy9TY2VuZVRyZWUvUmVzb3VyY2VMb2FkZXIvUmVzb3VyY2VMb2FkZXJXb3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYyAqL1xyXG4vKiogU3luY2hyb25vdXNseSBpbml0aWFsaXplIHRoZSBmb2xsb3dpbmcgc2NyaXB0cyBpbiBvcmRlci4gXHJcbiAqIEBwcml2YXRlXHJcbiovXHJcbk1vZHVsZSA9IHtcclxuICBFTlZJUk9OTUVOVDogJ1dPUktFUidcclxufTtcclxuXHJcbmNvbnN0IFdvcmtlclNjb3BlID0ge31cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS11bnBhY2tCcmlkZ2UuanMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiFmdW5jdGlvbih0LGUpe1xyXG4gIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBoYXMgYmVlbiBfY2FyZWZ1bGx5XyBtb2RpZmllZCBieSBoYW5kLlxyXG4gIC8vIFRoZXJlIHdlcmUgdmFyaW91cyBjYXNlcyBmb3IgaW4gd2hhdCBjb250ZXh0IHRoZSBjb2RlIG1pZ2h0IFxyXG4gIC8vIGJlIHJ1biwgYW5kIEkgcmVtb3ZlZCBhbGwgYnV0IHRoZSB3ZWJ3b3JrZXIgY2FzZS4gXHJcbiAgLy8gVGhlcmUgd2FzIGNvZGUgdG8gaGFuZGxlIGxvYWRpbmcgaW4gYSBub2RlSlMgY29udGV4dCwgdGhhdCB0cmllZCB0byBpbXBvcnQoXCJmc1wiKVxyXG4gIC8vIFdlYlBhY2sga2VwdHMgdHJpcHBpbmcgdXAgb24gdGhhdCBjb2RlIGluIGl0cyBzdGF0aWMgYW5hbHlzaXMgb2YgdGhlIGNvZGUsIHNvXHJcbiAgLy8gSSBjYXJlZnVsbHkgcmVtb3ZlZCBpdC5cclxuICB0LnVucGFja0JyaWRnZSA9IGUodC5mcylcclxufShXb3JrZXJTY29wZSxmdW5jdGlvbih0KXtcclxuICByZXR1cm4gZnVuY3Rpb24odCl7XHJcbiAgICB2YXIgZT17fTtmdW5jdGlvbiByKG4pe2lmKGVbbl0pcmV0dXJuIGVbbl0uZXhwb3J0czt2YXIgaT1lW25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09dCxyLmM9ZSxyLmQ9ZnVuY3Rpb24odCxlLG4pe3Iubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PXIodCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBpIGluIHQpci5kKG4saSxmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiByLmQoZSxcImFcIixlKSxlfSxyLm89ZnVuY3Rpb24odCxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LHIucD1cIlwiLHIoci5zPTIpfShbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigxKSxpPXswOlwiRVJBUl9TVUNDRVNTXCIsMTA6XCJFUkFSX0VORF9BUkNISVZFXCIsMTE6XCJFUkFSX05PX01FTU9SWVwiLDEyOlwiRVJBUl9CQURfREFUQVwiLDEzOlwiRVJBUl9CQURfQVJDSElWRVwiLDE0OlwiRVJBUl9VTktOT1dOX0ZPUk1BVFwiLDE1OlwiRVJBUl9FT1BFTlwiLDE2OlwiRVJBUl9FQ1JFQVRFXCIsMTc6XCJFUkFSX0VDTE9TRVwiLDE4OlwiRVJBUl9FUkVBRFwiLDE5OlwiRVJBUl9FV1JJVEVcIiwyMDpcIkVSQVJfU01BTExfQlVGXCIsMjE6XCJFUkFSX1VOS05PV05cIiwyMjpcIkVSQVJfTUlTU0lOR19QQVNTV09SRFwiLDIzOlwiRVJBUl9FUkVGRVJFTkNFXCIsMjQ6XCJFUkFSX0JBRF9QQVNTV09SRFwifSxvPXswOlwiU3VjY2Vzc1wiLDExOlwiTm90IGVub3VnaCBtZW1vcnlcIiwxMjpcIkFyY2hpdmUgaGVhZGVyIG9yIGRhdGEgYXJlIGRhbWFnZWRcIiwxMzpcIkZpbGUgaXMgbm90IFJBUiBhcmNoaXZlXCIsMTQ6XCJVbmtub3duIGFyY2hpdmUgZm9ybWF0XCIsMTU6XCJGaWxlIG9wZW4gZXJyb3JcIiwxNjpcIkZpbGUgY3JlYXRlIGVycm9yXCIsMTc6XCJGaWxlIGNsb3NlIGVycm9yXCIsMTg6XCJGaWxlIHJlYWQgZXJyb3JcIiwxOTpcIkZpbGUgd3JpdGUgZXJyb3JcIiwyMDpcIkJ1ZmZlciBmb3IgYXJjaGl2ZSBjb21tZW50IGlzIHRvbyBzbWFsbCwgY29tbWVudCB0cnVuY2F0ZWRcIiwyMTpcIlVua25vd24gZXJyb3JcIiwyMjpcIlBhc3N3b3JkIGZvciBlbmNyeXB0ZWQgZmlsZSBvciBoZWFkZXIgaXMgbm90IHNwZWNpZmllZFwiLDIzOlwiQ2Fubm90IG9wZW4gZmlsZSBzb3VyY2UgZm9yIHJlZmVyZW5jZSByZWNvcmRcIiwyNDpcIldyb25nIHBhc3N3b3JkIGlzIHNwZWNpZmllZFwifTtjbGFzcyBze2NvbnN0cnVjdG9yKHQ9XCJcIil7dGhpcy5fcGFzc3dvcmQ9dCx0aGlzLl9hcmNoaXZlPW51bGx9Z2V0RmlsZUxpc3QoKXtsZXQgdCxbZSxyXT10aGlzLm9wZW5BcmMoITApO2lmKFwiU1VDQ0VTU1wiIT09ZS5zdGF0ZSl0PVtlLG51bGxdO2Vsc2V7bGV0IGUsbixpPVtdO2Zvcig7W2Usbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUoKCk9PiEwKSxcIlNVQ0NFU1NcIj09PWUuc3RhdGU7KWkucHVzaChuLmZpbGVIZWFkZXIpO3Q9XCJFUkFSX0VORF9BUkNISVZFXCIhPT1lLnJlYXNvbj9bZSxudWxsXTpbe3N0YXRlOlwiU1VDQ0VTU1wifSx7YXJjSGVhZGVyOnIsZmlsZUhlYWRlcnM6aX1dfXJldHVybiB0aGlzLmNsb3NlQXJjKCksdH1leHRyYWN0QWxsKCl7bGV0IHQsW2Uscl09dGhpcy5vcGVuQXJjKCExKTtpZihcIlNVQ0NFU1NcIiE9PWUuc3RhdGUpdD1bZSxudWxsXTtlbHNle2xldCBlLG4saT1bXTtmb3IoO1tlLG5dPXRoaXMucHJvY2Vzc05leHRGaWxlKCgpPT4hMSksXCJTVUNDRVNTXCI9PT1lLnN0YXRlOylpLnB1c2gobik7dD1cIkVSQVJfRU5EX0FSQ0hJVkVcIiE9PWUucmVhc29uP1tlLG51bGxdOlt7c3RhdGU6XCJTVUNDRVNTXCJ9LHthcmNIZWFkZXI6cixmaWxlczppfV19cmV0dXJuIHRoaXMuY2xvc2VBcmMoKSx0fWV4dHJhY3RGaWxlcyh0LGUpe2xldCByLFtuLGldPXRoaXMub3BlbkFyYyghMSxlKSxvPXt9O2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKW9bdFtlXV09ZTtpZihcIlNVQ0NFU1NcIiE9PW4uc3RhdGUpcj1bbixudWxsXTtlbHNle2xldCBlLG4scz1BcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKSx1PTA7Zm9yKDs7KXtsZXQgcj0hMSxpPW51bGw7aWYoW2Usbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUodD0+dCBpbiBvPyhpPW9bdF0sITEpOihyPSEwLCEwKSksXCJTVUNDRVNTXCIhPT1lLnN0YXRlKWJyZWFrO2lmKCFyJiYoc1tpXT1uLCsrdT09PXQubGVuZ3RoKSl7ZS5yZWFzb249XCJFUkFSX0VORF9BUkNISVZFXCI7YnJlYWt9fXI9XCJFUkFSX0VORF9BUkNISVZFXCIhPT1lLnJlYXNvbj9bZSxudWxsXTpbe3N0YXRlOlwiU1VDQ0VTU1wifSx7YXJjSGVhZGVyOmksZmlsZXM6c31dfXJldHVybiB0aGlzLmNsb3NlQXJjKCkscn1maWxlQ3JlYXRlZCh0KXt9Y2xvc2UodCl7dGhpcy5fbGFzdEZpbGVDb250ZW50PXRoaXMuY2xvc2VGaWxlKHQpfW9wZW5BcmModCxlKXtuLkV4dC5jdXJyZW50PXRoaXMsdGhpcy5fYXJjaGl2ZT1uZXcgdW5wYWNrLlJhckFyY2hpdmU7bGV0IHIsaT10aGlzLl9hcmNoaXZlLm9wZW4odGhpcy5fZmlsZVBhdGgsZXx8dGhpcy5fcGFzc3dvcmQsdCk7cmV0dXJuIHI9MCE9PWkuc3RhdGUuZXJyQ29kZT9bdGhpcy5nZXRGYWlsSW5mbyhpLnN0YXRlLmVyckNvZGUsaS5zdGF0ZS5lcnJUeXBlKSxudWxsXTpbe3N0YXRlOlwiU1VDQ0VTU1wifSx7Y29tbWVudDppLmNvbW1lbnQsZmxhZ3M6e3ZvbHVtZTowIT0oMSZpLmZsYWdzKSxsb2NrOjAhPSg0JmkuZmxhZ3MpLHNvbGlkOjAhPSg4JmkuZmxhZ3MpLGF1dGhJbmZvOjAhPSgzMiZpLmZsYWdzKSxyZWNvdmVyeVJlY29yZDowIT0oNjQmaS5mbGFncyksaGVhZGVyRW5jcnlwdGVkOjAhPSgxMjgmaS5mbGFncyl9fV0sbi5FeHQuY3VycmVudD1udWxsLHJ9cHJvY2Vzc05leHRGaWxlKHQpe2xldCBlO24uRXh0LmN1cnJlbnQ9dGhpcztsZXQgcj10aGlzLl9hcmNoaXZlLmdldEZpbGVIZWFkZXIoKSxpPVt7c3RhdGU6XCJTVUNDRVNTXCJ9LG51bGxdO2lmKDA9PT1yLnN0YXRlLmVyckNvZGUpe2xldCBlPXQoci5uYW1lKTt0aGlzLl9sYXN0RmlsZUNvbnRlbnQ9bnVsbDtsZXQgbj10aGlzLl9hcmNoaXZlLnJlYWRGaWxlKGUpOzA9PT1uLmVyckNvZGV8fGV8fChpWzBdPXRoaXMuZ2V0RmFpbEluZm8obi5lcnJDb2RlLG4uZXJyVHlwZSksMjI9PT1uLmVyckNvZGU/bj10aGlzLl9hcmNoaXZlLnJlYWRGaWxlKCEwKTpuLmVyckNvZGU9MCksMD09PW4uZXJyQ29kZT9pWzFdPXRoaXMuX2xhc3RGaWxlQ29udGVudDooci5zdGF0ZS5lcnJDb2RlPW4uZXJyQ29kZSxyLnN0YXRlLmVyclR5cGU9bi5lcnJUeXBlKSx0aGlzLl9sYXN0RmlsZUNvbnRlbnQ9bnVsbH1yZXR1cm4gZT0wIT09ci5zdGF0ZS5lcnJDb2RlP1t0aGlzLmdldEZhaWxJbmZvKHIuc3RhdGUuZXJyQ29kZSxyLnN0YXRlLmVyclR5cGUpLG51bGxdOlt7c3RhdGU6XCJTVUNDRVNTXCJ9LHtmaWxlSGVhZGVyOntuYW1lOnIubmFtZSxmbGFnczp7ZW5jcnlwdGVkOjAhPSg0JnIuZmxhZ3MpLHNvbGlkOjAhPSgxNiZyLmZsYWdzKSxkaXJlY3Rvcnk6MCE9KDMyJnIuZmxhZ3MpfSxwYWNrU2l6ZTpyLnBhY2tTaXplLHVucFNpemU6ci51bnBTaXplLGNyYzpyLmNyYyx0aW1lOmZ1bmN0aW9uKHQpe2NvbnN0IGU9WzUsNiw1LDUsNCw3XTtsZXQgcj1bXTtmb3IobGV0IG4gb2YgZSlyLnB1c2godCYoMTw8biktMSksdD4+PW47bGV0IG49dD0+dDwxMD9cIjBcIit0OlwiXCIrdDtyZXR1cm5gJHsxOTgwKyhyPXIucmV2ZXJzZSgpKVswXX0tJHtuKHJbMV0pfS0ke24oclsyXSl9YCtgVCR7bihyWzNdKX06JHtuKHJbNF0pfToke24oMipyWzVdKX0uMDAwYH0oci50aW1lKSx1bnBWZXI6YCR7TWF0aC5mbG9vcihyLnVucFZlci8xMCl9LiR7ci51bnBWZXIlMTB9YCxtZXRob2Q6ZnVuY3Rpb24odCl7cmV0dXJuezQ4OlwiU3RvcmluZ1wiLDQ5OlwiRmFzdGVzdFwiLDUwOlwiRmFzdFwiLDUxOlwiTm9ybWFsXCIsNTI6XCJHb29kXCIsNTM6XCJCZXN0XCJ9W3RdfHxcIlVua25vd25cIn0oci5tZXRob2QpfSxleHRyYWN0Oml9XSxuLkV4dC5jdXJyZW50PW51bGwsZX1jbG9zZUFyYygpe24uRXh0LmN1cnJlbnQ9dGhpcyx0aGlzLl9hcmNoaXZlLmRlbGV0ZSgpLG4uRXh0LmN1cnJlbnQ9bnVsbCx0aGlzLl9hcmNoaXZlPW51bGx9Z2V0RmFpbEluZm8odCxlKXtyZXR1cm57c3RhdGU6XCJGQUlMXCIscmVhc29uOmlbdF0sbXNnOm9bdF19fX1zLl9jdXJyZW50PW51bGwsZS5FeHRyYWN0b3I9c30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXh0PXtjdXJyZW50Om51bGx9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZnVuY3Rpb24odCl7Zm9yKHZhciByIGluIHQpZS5oYXNPd25Qcm9wZXJ0eShyKXx8KGVbcl09dFtyXSl9KHIoMykpO3ZhciBuPXIoMSk7ZS5FeHQ9bi5FeHR9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNCksaT1yKDYpO2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGE9ZnVuY3Rpb24odCxlPVwiXCIpe3JldHVybiBuZXcgbi5EYXRhRXh0cmFjdG9yKHQsZSl9LGUuY3JlYXRlRXh0cmFjdG9yRnJvbUZpbGU9ZnVuY3Rpb24odCxlPVwiXCIscj1cIlwiKXtyZXR1cm4gbmV3IGkuRmlsZUV4dHJhY3Rvcih0LGUscil9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDUpLGk9cigwKTtlLkRhdGFFeHRyYWN0b3I9Y2xhc3MgZXh0ZW5kcyBpLkV4dHJhY3Rvcntjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKGUpLHRoaXMuZGF0YUZpbGVzPXt9LHRoaXMuZGF0YUZpbGVNYXA9e30sdGhpcy5jdXJyZW50RmQ9MTtsZXQgcj17ZmlsZTpuZXcgbi5EYXRhRmlsZShuZXcgVWludDhBcnJheSh0KSksZmQ6dGhpcy5jdXJyZW50RmQrK307dGhpcy5fZmlsZVBhdGg9XCJfZGVmYXVsdFVucmFySlNfLnJhclwiLHRoaXMuZGF0YUZpbGVzW3RoaXMuX2ZpbGVQYXRoXT1yLHRoaXMuZGF0YUZpbGVNYXBbci5mZF09dGhpcy5fZmlsZVBhdGh9b3Blbih0KXtsZXQgZT10aGlzLmRhdGFGaWxlc1t0XTtyZXR1cm4gZT9lLmZkOjB9Y3JlYXRlKHQpe2xldCBlPXRoaXMuY3VycmVudEZkKys7cmV0dXJuIHRoaXMuZGF0YUZpbGVzW3RdPXtmaWxlOm5ldyBuLkRhdGFGaWxlLGZkOnRoaXMuY3VycmVudEZkKyt9LHRoaXMuZGF0YUZpbGVNYXBbZV09dCxlfWNsb3NlRmlsZSh0KXtsZXQgZT10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTtpZighZSlyZXR1cm4gbnVsbDtsZXQgcj1lLmZpbGUucmVhZEFsbCgpO3JldHVybiAxIT09dD8oZGVsZXRlIHRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dLGRlbGV0ZSB0aGlzLmRhdGFGaWxlTWFwW3RdKTplLmZpbGUuc2VlaygwLFwiU0VUXCIpLHJ9cmVhZCh0LGUscil7bGV0IG49dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07aWYoIW4pcmV0dXJuLTE7bGV0IGk9bi5maWxlLnJlYWQocik7cmV0dXJuIG51bGw9PT1pPy0xOih1bnBhY2suSEVBUFU4LnNldChpLGUpLGkuYnl0ZUxlbmd0aCl9d3JpdGUodCxlLHIpe2xldCBuPXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dO3JldHVybiEhbiYmKG4uZmlsZS53cml0ZSh1bnBhY2suSEVBUFU4LnNsaWNlKGUsZStyKSksITApfXRlbGwodCl7bGV0IGU9dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07cmV0dXJuIGU/ZS5maWxlLnRlbGwoKTotMX1zZWVrKHQsZSxyKXtsZXQgbj10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTtyZXR1cm4hIW4mJm4uZmlsZS5zZWVrKGUscil9fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2UuRGF0YUZpbGU9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5idWZmZXJzPVtdLHRoaXMucG9zPTAsdGhpcy5zaXplPTAsdCYmKHRoaXMuYnVmZmVycy5wdXNoKHQpLHRoaXMuc2l6ZT10LmJ5dGVMZW5ndGgsdGhpcy5wb3M9MCl9cmVhZCh0KXtpZih0aGlzLmZsYXR0ZW4oKSx0K3RoaXMucG9zPnRoaXMuc2l6ZSlyZXR1cm4gbnVsbDtsZXQgZT10aGlzLnBvcztyZXR1cm4gdGhpcy5wb3MrPXQsdGhpcy5idWZmZXJzWzBdLnNsaWNlKGUsdGhpcy5wb3MpfXJlYWRBbGwoKXtyZXR1cm4gdGhpcy5mbGF0dGVuKCksdGhpcy5idWZmZXJzWzBdfXdyaXRlKHQpe3JldHVybiB0aGlzLmJ1ZmZlcnMucHVzaCh0KSx0aGlzLnNpemUrPXQuYnl0ZUxlbmd0aCx0aGlzLnBvcys9dC5ieXRlTGVuZ3RoLCEwfXRlbGwoKXtyZXR1cm4gdGhpcy5wb3N9c2Vlayh0LGUpe2xldCByPXRoaXMucG9zO3JldHVyblwiU0VUXCI9PT1lP3I9dDpcIkNVUlwiPT09ZT9yKz10OnI9dGhpcy5zaXplLXQsIShyPDB8fHI+dGhpcy5zaXplfHwodGhpcy5wb3M9ciwwKSl9ZmxhdHRlbigpe2lmKHRoaXMuYnVmZmVycy5sZW5ndGg8PTEpcmV0dXJuO2xldCB0PW5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSksZT0wO2ZvcihsZXQgciBvZiB0aGlzLmJ1ZmZlcnMpdC5zZXQocixlKSxlKz1yLmJ5dGVMZW5ndGg7dGhpcy5idWZmZXJzPVt0XX19fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigxMiksaT1yKDEzKSxvPXIoMCk7ZS5GaWxlRXh0cmFjdG9yPWNsYXNzIGV4dGVuZHMgby5FeHRyYWN0b3J7Y29uc3RydWN0b3IodCxlLHIpe3N1cGVyKHIpLHRoaXMuX2ZpbGVQYXRoPXQsdGhpcy5maWxlTWFwPXt9LHRoaXMuX3RhcmdldD1lfW9wZW4odCl7bGV0IGU9bi5vcGVuU3luYyh0LFwiclwiKTtyZXR1cm4gdGhpcy5maWxlTWFwW2VdPXtzaXplOm4uZnN0YXRTeW5jKGUpLnNpemUscG9zOjAsbmFtZTp0fSxlfWNyZWF0ZSh0KXtsZXQgZT1pLmpvaW4odGhpcy5fdGFyZ2V0LHQpO2kucGFyc2UoZSkuZGlyLnNwbGl0KFwiL1wiKS5yZWR1Y2UoKHQsZSk9Pih0Kz1lK1wiL1wiLG4uZXhpc3RzU3luYyh0KXx8bi5ta2RpclN5bmModCksdCksXCJcIik7bGV0IHI9bi5vcGVuU3luYyhlLFwid1wiKTtyZXR1cm4gdGhpcy5maWxlTWFwW3JdPXtzaXplOjAscG9zOjAsbmFtZTp0fSxyfWNsb3NlRmlsZSh0KXtyZXR1cm4gZGVsZXRlIHRoaXMuZmlsZU1hcFt0XSxuLmNsb3NlU3luYyh0KSxudWxsfXJlYWQoZSxyLGkpe2xldCBvPXRoaXMuZmlsZU1hcFtlXSxzPW5ldyB0KGkpLHU9bi5yZWFkU3luYyhlLHMsMCxpLG8ucG9zKTtyZXR1cm4gdW5wYWNrLkhFQVBVOC5zZXQocyxyKSxvLnBvcys9dSx1fXdyaXRlKGUscixpKXtsZXQgbz10aGlzLmZpbGVNYXBbZV0scz1uLndyaXRlU3luYyhlLG5ldyB0KHVucGFjay5IRUFQVTguc3ViYXJyYXkocixyK2kpKSwwLGkpO3JldHVybiBvLnBvcys9cyxvLnNpemUrPXMscz09PWl9dGVsbCh0KXtyZXR1cm4gdGhpcy5maWxlTWFwW3RdLnBvc31zZWVrKHQsZSxyKXtsZXQgbj10aGlzLmZpbGVNYXBbdF0saT1uLnBvcztyZXR1cm5cIlNFVFwiPT09cj9pPTA6XCJFTkRcIj09PXImJihpPW4uc2l6ZSksISgoaSs9ZSk8MHx8aT5uLnNpemV8fChuLnBvcz1pLDApKX19fSkuY2FsbCh0aGlzLHIoNykuQnVmZmVyKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXtcclxuLyohXHJcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cclxuICogQGxpY2Vuc2UgIE1JVFxyXG4gKi9cclxudmFyIG49cig5KSxpPXIoMTApLG89cigxMSk7ZnVuY3Rpb24gcygpe3JldHVybiBhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIHUodCxlKXtpZihzKCk8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiBhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHQ9bmV3IFVpbnQ4QXJyYXkoZSkpLl9fcHJvdG9fXz1hLnByb3RvdHlwZToobnVsbD09PXQmJih0PW5ldyBhKGUpKSx0Lmxlbmd0aD1lKSx0fWZ1bmN0aW9uIGEodCxlLHIpe2lmKCEoYS5UWVBFRF9BUlJBWV9TVVBQT1JUfHx0aGlzIGluc3RhbmNlb2YgYSkpcmV0dXJuIG5ldyBhKHQsZSxyKTtpZihcIm51bWJlclwiPT10eXBlb2YgdCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7cmV0dXJuIGwodGhpcyx0KX1yZXR1cm4gZih0aGlzLHQsZSxyKX1mdW5jdGlvbiBmKHQsZSxyLG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2Z1bmN0aW9uKHQsZSxyLG4pe2lmKGUuYnl0ZUxlbmd0aCxyPDB8fGUuYnl0ZUxlbmd0aDxyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihlLmJ5dGVMZW5ndGg8cisobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpO2U9dm9pZCAwPT09ciYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUscik6bmV3IFVpbnQ4QXJyYXkoZSxyLG4pO2EuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1lKS5fX3Byb3RvX189YS5wcm90b3R5cGU6dD1jKHQsZSk7cmV0dXJuIHR9KHQsZSxyLG4pOlwic3RyaW5nXCI9PXR5cGVvZiBlP2Z1bmN0aW9uKHQsZSxyKXtcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9PXJ8fChyPVwidXRmOFwiKTtpZighYS5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHxnKGUsciksaT0odD11KHQsbikpLndyaXRlKGUscik7aSE9PW4mJih0PXQuc2xpY2UoMCxpKSk7cmV0dXJuIHR9KHQsZSxyKTpmdW5jdGlvbih0LGUpe2lmKGEuaXNCdWZmZXIoZSkpe3ZhciByPTB8cChlLmxlbmd0aCk7cmV0dXJuIDA9PT0odD11KHQscikpLmxlbmd0aD90OihlLmNvcHkodCwwLDAsciksdCl9aWYoZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcImxlbmd0aFwiaW4gZSlyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgZS5sZW5ndGh8fGZ1bmN0aW9uKHQpe3JldHVybiB0IT10fShlLmxlbmd0aCk/dSh0LDApOmModCxlKTtpZihcIkJ1ZmZlclwiPT09ZS50eXBlJiZvKGUuZGF0YSkpcmV0dXJuIGModCxlLmRhdGEpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuXCIpfSh0LGUpfWZ1bmN0aW9uIGgodCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKX1mdW5jdGlvbiBsKHQsZSl7aWYoaChlKSx0PXUodCxlPDA/MDowfHAoZSkpLCFhLlRZUEVEX0FSUkFZX1NVUFBPUlQpZm9yKHZhciByPTA7cjxlOysrcil0W3JdPTA7cmV0dXJuIHR9ZnVuY3Rpb24gYyh0LGUpe3ZhciByPWUubGVuZ3RoPDA/MDowfHAoZS5sZW5ndGgpO3Q9dSh0LHIpO2Zvcih2YXIgbj0wO248cjtuKz0xKXRbbl09MjU1JmVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gcCh0KXtpZih0Pj1zKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIrcygpLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHx0fWZ1bmN0aW9uIGcodCxlKXtpZihhLmlzQnVmZmVyKHQpKXJldHVybiB0Lmxlbmd0aDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyYmKEFycmF5QnVmZmVyLmlzVmlldyh0KXx8dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gdC5ieXRlTGVuZ3RoO1wic3RyaW5nXCIhPXR5cGVvZiB0JiYodD1cIlwiK3QpO3ZhciByPXQubGVuZ3RoO2lmKDA9PT1yKXJldHVybiAwO2Zvcih2YXIgbj0hMTs7KXN3aXRjaChlKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiByO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2Ugdm9pZCAwOnJldHVybiBrKHQpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipyO2Nhc2VcImhleFwiOnJldHVybiByPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gaih0KS5sZW5ndGg7ZGVmYXVsdDppZihuKXJldHVybiBrKHQpLmxlbmd0aDtlPShcIlwiK2UpLnRvTG93ZXJDYXNlKCksbj0hMH19ZnVuY3Rpb24gZCh0LGUscil7dmFyIG49dFtlXTt0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIHkodCxlLHIsbixpKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHI/KG49cixyPTApOnI+MjE0NzQ4MzY0Nz9yPTIxNDc0ODM2NDc6cjwtMjE0NzQ4MzY0OCYmKHI9LTIxNDc0ODM2NDgpLHI9K3IsaXNOYU4ocikmJihyPWk/MDp0Lmxlbmd0aC0xKSxyPDAmJihyPXQubGVuZ3RoK3IpLHI+PXQubGVuZ3RoKXtpZihpKXJldHVybi0xO3I9dC5sZW5ndGgtMX1lbHNlIGlmKHI8MCl7aWYoIWkpcmV0dXJuLTE7cj0wfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1hLmZyb20oZSxuKSksYS5pc0J1ZmZlcihlKSlyZXR1cm4gMD09PWUubGVuZ3RoPy0xOncodCxlLHIsbixpKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gZSY9MjU1LGEuVFlQRURfQVJSQVlfU1VQUE9SVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9pP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0LGUscik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbCh0LGUscik6dyh0LFtlXSxyLG4saSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiB3KHQsZSxyLG4saSl7dmFyIG8scz0xLHU9dC5sZW5ndGgsYT1lLmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoXCJ1Y3MyXCI9PT0obj1TdHJpbmcobikudG9Mb3dlckNhc2UoKSl8fFwidWNzLTJcIj09PW58fFwidXRmMTZsZVwiPT09bnx8XCJ1dGYtMTZsZVwiPT09bikpe2lmKHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDIpcmV0dXJuLTE7cz0yLHUvPTIsYS89MixyLz0yfWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4gMT09PXM/dFtlXTp0LnJlYWRVSW50MTZCRShlKnMpfWlmKGkpe3ZhciBoPS0xO2ZvcihvPXI7bzx1O28rKylpZihmKHQsbyk9PT1mKGUsLTE9PT1oPzA6by1oKSl7aWYoLTE9PT1oJiYoaD1vKSxvLWgrMT09PWEpcmV0dXJuIGgqc31lbHNlLTEhPT1oJiYoby09by1oKSxoPS0xfWVsc2UgZm9yKHIrYT51JiYocj11LWEpLG89cjtvPj0wO28tLSl7Zm9yKHZhciBsPSEwLGM9MDtjPGE7YysrKWlmKGYodCxvK2MpIT09ZihlLGMpKXtsPSExO2JyZWFrfWlmKGwpcmV0dXJuIG99cmV0dXJuLTF9ZnVuY3Rpb24gRSh0LGUscixuKXtyPU51bWJlcihyKXx8MDt2YXIgaT10Lmxlbmd0aC1yO24/KG49TnVtYmVyKG4pKT5pJiYobj1pKTpuPWk7dmFyIG89ZS5sZW5ndGg7aWYobyUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7bj5vLzImJihuPW8vMik7Zm9yKHZhciBzPTA7czxuOysrcyl7dmFyIHU9cGFyc2VJbnQoZS5zdWJzdHIoMipzLDIpLDE2KTtpZihpc05hTih1KSlyZXR1cm4gczt0W3Irc109dX1yZXR1cm4gc31mdW5jdGlvbiB2KHQsZSxyLG4pe3JldHVybiB6KGsoZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gQSh0LGUscixuKXtyZXR1cm4geihmdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7KytyKWUucHVzaCgyNTUmdC5jaGFyQ29kZUF0KHIpKTtyZXR1cm4gZX0oZSksdCxyLG4pfWZ1bmN0aW9uIF8odCxlLHIsbil7cmV0dXJuIEEodCxlLHIsbil9ZnVuY3Rpb24gYih0LGUscixuKXtyZXR1cm4geihqKGUpLHQscixuKX1mdW5jdGlvbiBtKHQsZSxyLG4pe3JldHVybiB6KGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG4saSxvPVtdLHM9MDtzPHQubGVuZ3RoJiYhKChlLT0yKTwwKTsrK3Mpcj10LmNoYXJDb2RlQXQocyksbj1yPj44LGk9ciUyNTYsby5wdXNoKGkpLG8ucHVzaChuKTtyZXR1cm4gb30oZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gUih0LGUscil7cmV0dXJuIDA9PT1lJiZyPT09dC5sZW5ndGg/bi5mcm9tQnl0ZUFycmF5KHQpOm4uZnJvbUJ5dGVBcnJheSh0LnNsaWNlKGUscikpfWZ1bmN0aW9uIFModCxlLHIpe3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBuPVtdLGk9ZTtpPHI7KXt2YXIgbyxzLHUsYSxmPXRbaV0saD1udWxsLGw9Zj4yMzk/NDpmPjIyMz8zOmY+MTkxPzI6MTtpZihpK2w8PXIpc3dpdGNoKGwpe2Nhc2UgMTpmPDEyOCYmKGg9Zik7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYobz10W2krMV0pKSYmKGE9KDMxJmYpPDw2fDYzJm8pPjEyNyYmKGg9YSk7YnJlYWs7Y2FzZSAzOm89dFtpKzFdLHM9dFtpKzJdLDEyOD09KDE5MiZvKSYmMTI4PT0oMTkyJnMpJiYoYT0oMTUmZik8PDEyfCg2MyZvKTw8Nnw2MyZzKT4yMDQ3JiYoYTw1NTI5Nnx8YT41NzM0MykmJihoPWEpO2JyZWFrO2Nhc2UgNDpvPXRbaSsxXSxzPXRbaSsyXSx1PXRbaSszXSwxMjg9PSgxOTImbykmJjEyOD09KDE5MiZzKSYmMTI4PT0oMTkyJnUpJiYoYT0oMTUmZik8PDE4fCg2MyZvKTw8MTJ8KDYzJnMpPDw2fDYzJnUpPjY1NTM1JiZhPDExMTQxMTImJihoPWEpfW51bGw9PT1oPyhoPTY1NTMzLGw9MSk6aD42NTUzNSYmKGgtPTY1NTM2LG4ucHVzaChoPj4+MTAmMTAyM3w1NTI5NiksaD01NjMyMHwxMDIzJmgpLG4ucHVzaChoKSxpKz1sfXJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPD1UKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KTt2YXIgcj1cIlwiLG49MDtmb3IoO248ZTspcis9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsdC5zbGljZShuLG4rPVQpKTtyZXR1cm4gcn0obil9ZS5CdWZmZXI9YSxlLlNsb3dCdWZmZXI9ZnVuY3Rpb24odCl7K3QhPXQmJih0PTApO3JldHVybiBhLmFsbG9jKCt0KX0sZS5JTlNQRUNUX01BWF9CWVRFUz01MCxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09dC5UWVBFRF9BUlJBWV9TVVBQT1JUP3QuVFlQRURfQVJSQVlfU1VQUE9SVDpmdW5jdGlvbigpe3RyeXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gdC5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PXQuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuc3ViYXJyYXkmJjA9PT10LnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaCh0KXtyZXR1cm4hMX19KCksZS5rTWF4TGVuZ3RoPXMoKSxhLnBvb2xTaXplPTgxOTIsYS5fYXVnbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX189YS5wcm90b3R5cGUsdH0sYS5mcm9tPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZihudWxsLHQsZSxyKX0sYS5UWVBFRF9BUlJBWV9TVVBQT1JUJiYoYS5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLGEuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJmFbU3ltYm9sLnNwZWNpZXNdPT09YSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLGEuYWxsb2M9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gaChlKSxlPD0wP3UodCxlKTp2b2lkIDAhPT1yP1wic3RyaW5nXCI9PXR5cGVvZiBuP3UodCxlKS5maWxsKHIsbik6dSh0LGUpLmZpbGwocik6dSh0LGUpfShudWxsLHQsZSxyKX0sYS5hbGxvY1Vuc2FmZT1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSxhLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSxhLmlzQnVmZmVyPWZ1bmN0aW9uKHQpe3JldHVybiEobnVsbD09dHx8IXQuX2lzQnVmZmVyKX0sYS5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7aWYoIWEuaXNCdWZmZXIodCl8fCFhLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO2lmKHQ9PT1lKXJldHVybiAwO2Zvcih2YXIgcj10Lmxlbmd0aCxuPWUubGVuZ3RoLGk9MCxvPU1hdGgubWluKHIsbik7aTxvOysraSlpZih0W2ldIT09ZVtpXSl7cj10W2ldLG49ZVtpXTticmVha31yZXR1cm4gcjxuPy0xOm48cj8xOjB9LGEuaXNFbmNvZGluZz1mdW5jdGlvbih0KXtzd2l0Y2goU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19LGEuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoIW8odCkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PXQubGVuZ3RoKXJldHVybiBhLmFsbG9jKDApO3ZhciByO2lmKHZvaWQgMD09PWUpZm9yKGU9MCxyPTA7cjx0Lmxlbmd0aDsrK3IpZSs9dFtyXS5sZW5ndGg7dmFyIG49YS5hbGxvY1Vuc2FmZShlKSxpPTA7Zm9yKHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIHM9dFtyXTtpZighYS5pc0J1ZmZlcihzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtzLmNvcHkobixpKSxpKz1zLmxlbmd0aH1yZXR1cm4gbn0sYS5ieXRlTGVuZ3RoPWcsYS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLGEucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz0yKWQodGhpcyxlLGUrMSk7cmV0dXJuIHRoaXN9LGEucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlNCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz00KWQodGhpcyxlLGUrMyksZCh0aGlzLGUrMSxlKzIpO3JldHVybiB0aGlzfSxhLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTghPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9OClkKHRoaXMsZSxlKzcpLGQodGhpcyxlKzEsZSs2KSxkKHRoaXMsZSsyLGUrNSksZCh0aGlzLGUrMyxlKzQpO3JldHVybiB0aGlzfSxhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT10P1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/Uyh0aGlzLDAsdCk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPSExO2lmKCh2b2lkIDA9PT1lfHxlPDApJiYoZT0wKSxlPnRoaXMubGVuZ3RoKXJldHVyblwiXCI7aWYoKHZvaWQgMD09PXJ8fHI+dGhpcy5sZW5ndGgpJiYocj10aGlzLmxlbmd0aCkscjw9MClyZXR1cm5cIlwiO2lmKChyPj4+PTApPD0oZT4+Pj0wKSlyZXR1cm5cIlwiO2Zvcih0fHwodD1cInV0ZjhcIik7Oylzd2l0Y2godCl7Y2FzZVwiaGV4XCI6cmV0dXJuIFUodGhpcyxlLHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBTKHRoaXMsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBQKHRoaXMsZSxyKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gQyh0aGlzLGUscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIFIodGhpcyxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBCKHRoaXMsZSxyKTtkZWZhdWx0OmlmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3Q9KHQrXCJcIikudG9Mb3dlckNhc2UoKSxuPSEwfX0uYXBwbHkodGhpcyxhcmd1bWVudHMpfSxhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7aWYoIWEuaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT10fHwwPT09YS5jb21wYXJlKHRoaXMsdCl9LGEucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXt2YXIgdD1cIlwiLHI9ZS5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gdGhpcy5sZW5ndGg+MCYmKHQ9dGhpcy50b1N0cmluZyhcImhleFwiLDAscikubWF0Y2goLy57Mn0vZykuam9pbihcIiBcIiksdGhpcy5sZW5ndGg+ciYmKHQrPVwiIC4uLiBcIikpLFwiPEJ1ZmZlciBcIit0K1wiPlwifSxhLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHQsZSxyLG4saSl7aWYoIWEuaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09ciYmKHI9dD90Lmxlbmd0aDowKSx2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1pJiYoaT10aGlzLmxlbmd0aCksZTwwfHxyPnQubGVuZ3RofHxuPDB8fGk+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYobj49aSYmZT49cilyZXR1cm4gMDtpZihuPj1pKXJldHVybi0xO2lmKGU+PXIpcmV0dXJuIDE7aWYoZT4+Pj0wLHI+Pj49MCxuPj4+PTAsaT4+Pj0wLHRoaXM9PT10KXJldHVybiAwO2Zvcih2YXIgbz1pLW4scz1yLWUsdT1NYXRoLm1pbihvLHMpLGY9dGhpcy5zbGljZShuLGkpLGg9dC5zbGljZShlLHIpLGw9MDtsPHU7KytsKWlmKGZbbF0hPT1oW2xdKXtvPWZbbF0scz1oW2xdO2JyZWFrfXJldHVybiBvPHM/LTE6czxvPzE6MH0sYS5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKHQsZSxyKX0sYS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbih0LGUscil7cmV0dXJuIHkodGhpcyx0LGUsciwhMCl9LGEucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4geSh0aGlzLHQsZSxyLCExKX0sYS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLHIsbil7aWYodm9pZCAwPT09ZSluPVwidXRmOFwiLHI9dGhpcy5sZW5ndGgsZT0wO2Vsc2UgaWYodm9pZCAwPT09ciYmXCJzdHJpbmdcIj09dHlwZW9mIGUpbj1lLHI9dGhpcy5sZW5ndGgsZT0wO2Vsc2V7aWYoIWlzRmluaXRlKGUpKXRocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO2V8PTAsaXNGaW5pdGUocik/KHJ8PTAsdm9pZCAwPT09biYmKG49XCJ1dGY4XCIpKToobj1yLHI9dm9pZCAwKX12YXIgaT10aGlzLmxlbmd0aC1lO2lmKCh2b2lkIDA9PT1yfHxyPmkpJiYocj1pKSx0Lmxlbmd0aD4wJiYocjwwfHxlPDApfHxlPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7bnx8KG49XCJ1dGY4XCIpO2Zvcih2YXIgbz0hMTs7KXN3aXRjaChuKXtjYXNlXCJoZXhcIjpyZXR1cm4gRSh0aGlzLHQsZSxyKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdih0aGlzLHQsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBBKHRoaXMsdCxlLHIpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBfKHRoaXMsdCxlLHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiKHRoaXMsdCxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBtKHRoaXMsdCxlLHIpO2RlZmF1bHQ6aWYobyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbik7bj0oXCJcIituKS50b0xvd2VyQ2FzZSgpLG89ITB9fSxhLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07dmFyIFQ9NDA5NjtmdW5jdGlvbiBQKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZ0W2ldKTtyZXR1cm4gbn1mdW5jdGlvbiBDKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBufWZ1bmN0aW9uIFUodCxlLHIpe3ZhciBuPXQubGVuZ3RoOyghZXx8ZTwwKSYmKGU9MCksKCFyfHxyPDB8fHI+bikmJihyPW4pO2Zvcih2YXIgaT1cIlwiLG89ZTtvPHI7KytvKWkrPU4odFtvXSk7cmV0dXJuIGl9ZnVuY3Rpb24gQih0LGUscil7Zm9yKHZhciBuPXQuc2xpY2UoZSxyKSxpPVwiXCIsbz0wO288bi5sZW5ndGg7bys9MilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG5bb10rMjU2Km5bbysxXSk7cmV0dXJuIGl9ZnVuY3Rpb24gRih0LGUscil7aWYodCUxIT0wfHx0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYodCtlPnIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWZ1bmN0aW9uIE0odCxlLHIsbixpLG8pe2lmKCFhLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGU+aXx8ZTxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB4KHQsZSxyLG4pe2U8MCYmKGU9NjU1MzUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsMik7aTxvOysraSl0W3IraV09KGUmMjU1PDw4KihuP2k6MS1pKSk+Pj44KihuP2k6MS1pKX1mdW5jdGlvbiBJKHQsZSxyLG4pe2U8MCYmKGU9NDI5NDk2NzI5NStlKzEpO2Zvcih2YXIgaT0wLG89TWF0aC5taW4odC5sZW5ndGgtciw0KTtpPG87KytpKXRbcitpXT1lPj4+OCoobj9pOjMtaSkmMjU1fWZ1bmN0aW9uIE8odCxlLHIsbixpLG8pe2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gWSh0LGUscixuLG8pe3JldHVybiBvfHxPKHQsMCxyLDQpLGkud3JpdGUodCxlLHIsbiwyMyw0KSxyKzR9ZnVuY3Rpb24gTCh0LGUscixuLG8pe3JldHVybiBvfHxPKHQsMCxyLDgpLGkud3JpdGUodCxlLHIsbiw1Miw4KSxyKzh9YS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXt2YXIgcixuPXRoaXMubGVuZ3RoO2lmKHQ9fn50LGU9dm9pZCAwPT09ZT9uOn5+ZSx0PDA/KHQrPW4pPDAmJih0PTApOnQ+biYmKHQ9biksZTwwPyhlKz1uKTwwJiYoZT0wKTplPm4mJihlPW4pLGU8dCYmKGU9dCksYS5UWVBFRF9BUlJBWV9TVVBQT1JUKShyPXRoaXMuc3ViYXJyYXkodCxlKSkuX19wcm90b19fPWEucHJvdG90eXBlO2Vsc2V7dmFyIGk9ZS10O3I9bmV3IGEoaSx2b2lkIDApO2Zvcih2YXIgbz0wO288aTsrK28pcltvXT10aGlzW28rdF19cmV0dXJuIHJ9LGEucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24odCxlLHIpe3R8PTAsZXw9MCxyfHxGKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdF0saT0xLG89MDsrK288ZSYmKGkqPTI1Nik7KW4rPXRoaXNbdCtvXSppO3JldHVybiBufSxhLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8Rih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3QrLS1lXSxpPTE7ZT4wJiYoaSo9MjU2KTspbis9dGhpc1t0Ky0tZV0qaTtyZXR1cm4gbn0sYS5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCwxLHRoaXMubGVuZ3RoKSx0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSxhLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDh8dGhpc1t0KzFdfSxhLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDQsdGhpcy5sZW5ndGgpLCh0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2KSsxNjc3NzIxNip0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxGKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0sYS5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8Rih0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3RdLGk9MSxvPTA7KytvPGUmJihpKj0yNTYpOyluKz10aGlzW3Qrb10qaTtyZXR1cm4gbj49KGkqPTEyOCkmJihuLT1NYXRoLnBvdygyLDgqZSkpLG59LGEucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbih0LGUscil7dHw9MCxlfD0wLHJ8fEYodCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49ZSxpPTEsbz10aGlzW3QrLS1uXTtuPjAmJihpKj0yNTYpOylvKz10aGlzW3QrLS1uXSppO3JldHVybiBvPj0oaSo9MTI4KSYmKG8tPU1hdGgucG93KDIsOCplKSksb30sYS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSxhLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fEYodCwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0sYS5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxGKHQsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LGEucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LGEucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LGEucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw0LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDIzLDQpfSxhLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxGKHQsNCx0aGlzLmxlbmd0aCksaS5yZWFkKHRoaXMsdCwhMSwyMyw0KX0sYS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fEYodCw4LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDUyLDgpfSxhLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Rih0LDgsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLHQsITEsNTIsOCl9LGEucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxyLG4peyh0PSt0LGV8PTAscnw9MCxuKXx8TSh0aGlzLHQsZSxyLE1hdGgucG93KDIsOCpyKS0xLDApO3ZhciBpPTEsbz0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrbzxyJiYoaSo9MjU2KTspdGhpc1tlK29dPXQvaSYyNTU7cmV0dXJuIGUrcn0sYS5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24odCxlLHIsbil7KHQ9K3QsZXw9MCxyfD0wLG4pfHxNKHRoaXMsdCxlLHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIGk9ci0xLG89MTtmb3IodGhpc1tlK2ldPTI1NSZ0Oy0taT49MCYmKG8qPTI1Nik7KXRoaXNbZStpXT10L28mMjU1O3JldHVybiBlK3J9LGEucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSwxLDI1NSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHRoaXNbZV09MjU1JnQsZSsxfSxhLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsMiw2NTUzNSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTp4KHRoaXMsdCxlLCEwKSxlKzJ9LGEucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSwyLDY1NTM1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOngodGhpcyx0LGUsITEpLGUrMn0sYS5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDQsNDI5NDk2NzI5NSwwKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZSszXT10Pj4+MjQsdGhpc1tlKzJdPXQ+Pj4xNix0aGlzW2UrMV09dD4+PjgsdGhpc1tlXT0yNTUmdCk6SSh0aGlzLHQsZSwhMCksZSs0fSxhLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLGEuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpJKHRoaXMsdCxlLCExKSxlKzR9LGEucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24odCxlLHIsbil7aWYodD0rdCxlfD0wLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtNKHRoaXMsdCxlLHIsaS0xLC1pKX12YXIgbz0wLHM9MSx1PTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihzKj0yNTYpOyl0PDAmJjA9PT11JiYwIT09dGhpc1tlK28tMV0mJih1PTEpLHRoaXNbZStvXT0odC9zPj4wKS11JjI1NTtyZXR1cm4gZStyfSxhLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQ9K3QsZXw9MCwhbil7dmFyIGk9TWF0aC5wb3coMiw4KnItMSk7TSh0aGlzLHQsZSxyLGktMSwtaSl9dmFyIG89ci0xLHM9MSx1PTA7Zm9yKHRoaXNbZStvXT0yNTUmdDstLW8+PTAmJihzKj0yNTYpOyl0PDAmJjA9PT11JiYwIT09dGhpc1tlK28rMV0mJih1PTEpLHRoaXNbZStvXT0odC9zPj4wKS11JjI1NTtyZXR1cm4gZStyfSxhLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8TSh0aGlzLHQsZSwxLDEyNywtMTI4KSxhLlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHQ8MCYmKHQ9MjU1K3QrMSksdGhpc1tlXT0yNTUmdCxlKzF9LGEucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTp4KHRoaXMsdCxlLCEwKSxlKzJ9LGEucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjgsdGhpc1tlKzFdPTI1NSZ0KTp4KHRoaXMsdCxlLCExKSxlKzJ9LGEucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxNKHRoaXMsdCxlLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksYS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPTI1NSZ0LHRoaXNbZSsxXT10Pj4+OCx0aGlzW2UrMl09dD4+PjE2LHRoaXNbZSszXT10Pj4+MjQpOkkodGhpcyx0LGUsITApLGUrNH0sYS5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fE0odGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx0PDAmJih0PTQyOTQ5NjcyOTUrdCsxKSxhLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjI0LHRoaXNbZSsxXT10Pj4+MTYsdGhpc1tlKzJdPXQ+Pj44LHRoaXNbZSszXT0yNTUmdCk6SSh0aGlzLHQsZSwhMSksZSs0fSxhLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBZKHRoaXMsdCxlLCEwLHIpfSxhLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBZKHRoaXMsdCxlLCExLHIpfSxhLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTCh0aGlzLHQsZSwhMCxyKX0sYS5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIEwodGhpcyx0LGUsITEscil9LGEucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24odCxlLHIsbil7aWYocnx8KHI9MCksbnx8MD09PW58fChuPXRoaXMubGVuZ3RoKSxlPj10Lmxlbmd0aCYmKGU9dC5sZW5ndGgpLGV8fChlPTApLG4+MCYmbjxyJiYobj1yKSxuPT09cilyZXR1cm4gMDtpZigwPT09dC5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKHI8MHx8cj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO24+dGhpcy5sZW5ndGgmJihuPXRoaXMubGVuZ3RoKSx0Lmxlbmd0aC1lPG4tciYmKG49dC5sZW5ndGgtZStyKTt2YXIgaSxvPW4tcjtpZih0aGlzPT09dCYmcjxlJiZlPG4pZm9yKGk9by0xO2k+PTA7LS1pKXRbaStlXT10aGlzW2krcl07ZWxzZSBpZihvPDFlM3x8IWEuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IoaT0wO2k8bzsrK2kpdFtpK2VdPXRoaXNbaStyXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHQsdGhpcy5zdWJhcnJheShyLHIrbyksZSk7cmV0dXJuIG99LGEucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLHIsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlPyhuPWUsZT0wLHI9dGhpcy5sZW5ndGgpOlwic3RyaW5nXCI9PXR5cGVvZiByJiYobj1yLHI9dGhpcy5sZW5ndGgpLDE9PT10Lmxlbmd0aCl7dmFyIGk9dC5jaGFyQ29kZUF0KDApO2k8MjU2JiYodD1pKX1pZih2b2lkIDAhPT1uJiZcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmIWEuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbil9ZWxzZVwibnVtYmVyXCI9PXR5cGVvZiB0JiYodCY9MjU1KTtpZihlPDB8fHRoaXMubGVuZ3RoPGV8fHRoaXMubGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYocjw9ZSlyZXR1cm4gdGhpczt2YXIgbztpZihlPj4+PTAscj12b2lkIDA9PT1yP3RoaXMubGVuZ3RoOnI+Pj4wLHR8fCh0PTApLFwibnVtYmVyXCI9PXR5cGVvZiB0KWZvcihvPWU7bzxyOysrbyl0aGlzW29dPXQ7ZWxzZXt2YXIgcz1hLmlzQnVmZmVyKHQpP3Q6ayhuZXcgYSh0LG4pLnRvU3RyaW5nKCkpLHU9cy5sZW5ndGg7Zm9yKG89MDtvPHItZTsrK28pdGhpc1tvK2VdPXNbbyV1XX1yZXR1cm4gdGhpc307dmFyIEQ9L1teK1xcLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIE4odCl7cmV0dXJuIHQ8MTY/XCIwXCIrdC50b1N0cmluZygxNik6dC50b1N0cmluZygxNil9ZnVuY3Rpb24gayh0LGUpe3ZhciByO2U9ZXx8MS8wO2Zvcih2YXIgbj10Lmxlbmd0aCxpPW51bGwsbz1bXSxzPTA7czxuOysrcyl7aWYoKHI9dC5jaGFyQ29kZUF0KHMpKT41NTI5NSYmcjw1NzM0NCl7aWYoIWkpe2lmKHI+NTYzMTkpeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pZihzKzE9PT1uKXsoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aT1yO2NvbnRpbnVlfWlmKHI8NTYzMjApeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KSxpPXI7Y29udGludWV9cj02NTUzNisoaS01NTI5Njw8MTB8ci01NjMyMCl9ZWxzZSBpJiYoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7aWYoaT1udWxsLHI8MTI4KXtpZigoZS09MSk8MClicmVhaztvLnB1c2gocil9ZWxzZSBpZihyPDIwNDgpe2lmKChlLT0yKTwwKWJyZWFrO28ucHVzaChyPj42fDE5Miw2MyZyfDEyOCl9ZWxzZSBpZihyPDY1NTM2KXtpZigoZS09Myk8MClicmVhaztvLnB1c2gocj4+MTJ8MjI0LHI+PjYmNjN8MTI4LDYzJnJ8MTI4KX1lbHNle2lmKCEocjwxMTE0MTEyKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7aWYoKGUtPTQpPDApYnJlYWs7by5wdXNoKHI+PjE4fDI0MCxyPj4xMiY2M3wxMjgscj4+NiY2M3wxMjgsNjMmcnwxMjgpfX1yZXR1cm4gb31mdW5jdGlvbiBqKHQpe3JldHVybiBuLnRvQnl0ZUFycmF5KGZ1bmN0aW9uKHQpe2lmKCh0PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSh0KS5yZXBsYWNlKEQsXCJcIikpLmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDt0Lmxlbmd0aCU0IT0wOyl0Kz1cIj1cIjtyZXR1cm4gdH0odCkpfWZ1bmN0aW9uIHoodCxlLHIsbil7Zm9yKHZhciBpPTA7aTxuJiYhKGkrcj49ZS5sZW5ndGh8fGk+PXQubGVuZ3RoKTsrK2kpZVtpK3JdPXRbaV07cmV0dXJuIGl9fSkuY2FsbCh0aGlzLHIoOCkpfSxmdW5jdGlvbih0LGUpe3ZhciByO3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7cj1yfHxGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl8fCgwLGV2YWwpKFwidGhpc1wiKX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfXQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPWYodCkscj1lWzBdLG49ZVsxXTtyZXR1cm4gMyoocituKS80LW59LGUudG9CeXRlQXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9Zih0KSxuPXJbMF0scz1yWzFdLHU9bmV3IG8oZnVuY3Rpb24odCxlLHIpe3JldHVybiAzKihlK3IpLzQtcn0oMCxuLHMpKSxhPTAsaD1zPjA/bi00Om4sbD0wO2w8aDtsKz00KWU9aVt0LmNoYXJDb2RlQXQobCldPDwxOHxpW3QuY2hhckNvZGVBdChsKzEpXTw8MTJ8aVt0LmNoYXJDb2RlQXQobCsyKV08PDZ8aVt0LmNoYXJDb2RlQXQobCszKV0sdVthKytdPWU+PjE2JjI1NSx1W2ErK109ZT4+OCYyNTUsdVthKytdPTI1NSZlOzI9PT1zJiYoZT1pW3QuY2hhckNvZGVBdChsKV08PDJ8aVt0LmNoYXJDb2RlQXQobCsxKV0+PjQsdVthKytdPTI1NSZlKTsxPT09cyYmKGU9aVt0LmNoYXJDb2RlQXQobCldPDwxMHxpW3QuY2hhckNvZGVBdChsKzEpXTw8NHxpW3QuY2hhckNvZGVBdChsKzIpXT4+Mix1W2ErK109ZT4+OCYyNTUsdVthKytdPTI1NSZlKTtyZXR1cm4gdX0sZS5mcm9tQnl0ZUFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPXQubGVuZ3RoLGk9ciUzLG89W10scz0wLHU9ci1pO3M8dTtzKz0xNjM4MylvLnB1c2gobCh0LHMscysxNjM4Mz51P3U6cysxNjM4MykpOzE9PT1pPyhlPXRbci0xXSxvLnB1c2gobltlPj4yXStuW2U8PDQmNjNdK1wiPT1cIikpOjI9PT1pJiYoZT0odFtyLTJdPDw4KSt0W3ItMV0sby5wdXNoKG5bZT4+MTBdK25bZT4+NCY2M10rbltlPDwyJjYzXStcIj1cIikpO3JldHVybiBvLmpvaW4oXCJcIil9O2Zvcih2YXIgbj1bXSxpPVtdLG89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxzPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLHU9MCxhPXMubGVuZ3RoO3U8YTsrK3Upblt1XT1zW3VdLGlbcy5jaGFyQ29kZUF0KHUpXT11O2Z1bmN0aW9uIGYodCl7dmFyIGU9dC5sZW5ndGg7aWYoZSU0PjApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTt2YXIgcj10LmluZGV4T2YoXCI9XCIpO3JldHVybi0xPT09ciYmKHI9ZSksW3Iscj09PWU/MDo0LXIlNF19ZnVuY3Rpb24gaCh0KXtyZXR1cm4gblt0Pj4xOCY2M10rblt0Pj4xMiY2M10rblt0Pj42JjYzXStuWzYzJnRdfWZ1bmN0aW9uIGwodCxlLHIpe2Zvcih2YXIgbixpPVtdLG89ZTtvPHI7bys9MyluPSh0W29dPDwxNiYxNjcxMTY4MCkrKHRbbysxXTw8OCY2NTI4MCkrKDI1NSZ0W28rMl0pLGkucHVzaChoKG4pKTtyZXR1cm4gaS5qb2luKFwiXCIpfWlbXCItXCIuY2hhckNvZGVBdCgwKV09NjIsaVtcIl9cIi5jaGFyQ29kZUF0KDApXT02M30sZnVuY3Rpb24odCxlKXtlLnJlYWQ9ZnVuY3Rpb24odCxlLHIsbixpKXt2YXIgbyxzLHU9OCppLW4tMSxhPSgxPDx1KS0xLGY9YT4+MSxoPS03LGw9cj9pLTE6MCxjPXI/LTE6MSxwPXRbZStsXTtmb3IobCs9YyxvPXAmKDE8PC1oKS0xLHA+Pj0taCxoKz11O2g+MDtvPTI1NipvK3RbZStsXSxsKz1jLGgtPTgpO2ZvcihzPW8mKDE8PC1oKS0xLG8+Pj0taCxoKz1uO2g+MDtzPTI1NipzK3RbZStsXSxsKz1jLGgtPTgpO2lmKDA9PT1vKW89MS1mO2Vsc2V7aWYobz09PWEpcmV0dXJuIHM/TmFOOjEvMCoocD8tMToxKTtzKz1NYXRoLnBvdygyLG4pLG8tPWZ9cmV0dXJuKHA/LTE6MSkqcypNYXRoLnBvdygyLG8tbil9LGUud3JpdGU9ZnVuY3Rpb24odCxlLHIsbixpLG8pe3ZhciBzLHUsYSxmPTgqby1pLTEsaD0oMTw8ZiktMSxsPWg+PjEsYz0yMz09PWk/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLHA9bj8wOm8tMSxnPW4/MTotMSxkPWU8MHx8MD09PWUmJjEvZTwwPzE6MDtmb3IoZT1NYXRoLmFicyhlKSxpc05hTihlKXx8ZT09PTEvMD8odT1pc05hTihlKT8xOjAscz1oKToocz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKSxlKihhPU1hdGgucG93KDIsLXMpKTwxJiYocy0tLGEqPTIpLChlKz1zK2w+PTE/Yy9hOmMqTWF0aC5wb3coMiwxLWwpKSphPj0yJiYocysrLGEvPTIpLHMrbD49aD8odT0wLHM9aCk6cytsPj0xPyh1PShlKmEtMSkqTWF0aC5wb3coMixpKSxzKz1sKToodT1lKk1hdGgucG93KDIsbC0xKSpNYXRoLnBvdygyLGkpLHM9MCkpO2k+PTg7dFtyK3BdPTI1NSZ1LHArPWcsdS89MjU2LGktPTgpO2ZvcihzPXM8PGl8dSxmKz1pO2Y+MDt0W3IrcF09MjU1JnMscCs9ZyxzLz0yNTYsZi09OCk7dFtyK3AtZ118PTEyOCpkfX0sZnVuY3Rpb24odCxlKXt2YXIgcj17fS50b1N0cmluZzt0LmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT1yLmNhbGwodCl9fSxmdW5jdGlvbihlLHIpe2UuZXhwb3J0cz10fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCxlKXtmb3IodmFyIHI9MCxuPXQubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBpPXRbbl07XCIuXCI9PT1pP3Quc3BsaWNlKG4sMSk6XCIuLlwiPT09aT8odC5zcGxpY2UobiwxKSxyKyspOnImJih0LnNwbGljZShuLDEpLHItLSl9aWYoZSlmb3IoO3ItLTtyKXQudW5zaGlmdChcIi4uXCIpO3JldHVybiB0fXZhciBuPS9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvLGk9ZnVuY3Rpb24odCl7cmV0dXJuIG4uZXhlYyh0KS5zbGljZSgxKX07ZnVuY3Rpb24gbyh0LGUpe2lmKHQuZmlsdGVyKXJldHVybiB0LmZpbHRlcihlKTtmb3IodmFyIHI9W10sbj0wO248dC5sZW5ndGg7bisrKWUodFtuXSxuLHQpJiZyLnB1c2godFtuXSk7cmV0dXJuIHJ9ZS5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVwiXCIsbj0hMSxpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIW47aS0tKXt2YXIgcz1pPj0wP2FyZ3VtZW50c1tpXTp0LmN3ZCgpO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5nc1wiKTtzJiYoZT1zK1wiL1wiK2Usbj1cIi9cIj09PXMuY2hhckF0KDApKX1yZXR1cm4gZT1yKG8oZS5zcGxpdChcIi9cIiksZnVuY3Rpb24odCl7cmV0dXJuISF0fSksIW4pLmpvaW4oXCIvXCIpLChuP1wiL1wiOlwiXCIpK2V8fFwiLlwifSxlLm5vcm1hbGl6ZT1mdW5jdGlvbih0KXt2YXIgbj1lLmlzQWJzb2x1dGUodCksaT1cIi9cIj09PXModCwtMSk7cmV0dXJuKHQ9cihvKHQuc3BsaXQoXCIvXCIpLGZ1bmN0aW9uKHQpe3JldHVybiEhdH0pLCFuKS5qb2luKFwiL1wiKSl8fG58fCh0PVwiLlwiKSx0JiZpJiYodCs9XCIvXCIpLChuP1wiL1wiOlwiXCIpK3R9LGUuaXNBYnNvbHV0ZT1mdW5jdGlvbih0KXtyZXR1cm5cIi9cIj09PXQuY2hhckF0KDApfSxlLmpvaW49ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGUubm9ybWFsaXplKG8odCxmdW5jdGlvbih0LGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1wiKTtyZXR1cm4gdH0pLmpvaW4oXCIvXCIpKX0sZS5yZWxhdGl2ZT1mdW5jdGlvbih0LHIpe2Z1bmN0aW9uIG4odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aCYmXCJcIj09PXRbZV07ZSsrKTtmb3IodmFyIHI9dC5sZW5ndGgtMTtyPj0wJiZcIlwiPT09dFtyXTtyLS0pO3JldHVybiBlPnI/W106dC5zbGljZShlLHItZSsxKX10PWUucmVzb2x2ZSh0KS5zdWJzdHIoMSkscj1lLnJlc29sdmUocikuc3Vic3RyKDEpO2Zvcih2YXIgaT1uKHQuc3BsaXQoXCIvXCIpKSxvPW4oci5zcGxpdChcIi9cIikpLHM9TWF0aC5taW4oaS5sZW5ndGgsby5sZW5ndGgpLHU9cyxhPTA7YTxzO2ErKylpZihpW2FdIT09b1thXSl7dT1hO2JyZWFrfXZhciBmPVtdO2ZvcihhPXU7YTxpLmxlbmd0aDthKyspZi5wdXNoKFwiLi5cIik7cmV0dXJuKGY9Zi5jb25jYXQoby5zbGljZSh1KSkpLmpvaW4oXCIvXCIpfSxlLnNlcD1cIi9cIixlLmRlbGltaXRlcj1cIjpcIixlLmRpcm5hbWU9ZnVuY3Rpb24odCl7dmFyIGU9aSh0KSxyPWVbMF0sbj1lWzFdO3JldHVybiByfHxuPyhuJiYobj1uLnN1YnN0cigwLG4ubGVuZ3RoLTEpKSxyK24pOlwiLlwifSxlLmJhc2VuYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIHI9aSh0KVsyXTtyZXR1cm4gZSYmci5zdWJzdHIoLTEqZS5sZW5ndGgpPT09ZSYmKHI9ci5zdWJzdHIoMCxyLmxlbmd0aC1lLmxlbmd0aCkpLHJ9LGUuZXh0bmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gaSh0KVszXX07dmFyIHM9XCJiXCI9PT1cImFiXCIuc3Vic3RyKC0xKT9mdW5jdGlvbih0LGUscil7cmV0dXJuIHQuc3Vic3RyKGUscil9OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZTwwJiYoZT10Lmxlbmd0aCtlKSx0LnN1YnN0cihlLHIpfX0pLmNhbGwodGhpcyxyKDE0KSl9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpPXQuZXhwb3J0cz17fTtmdW5jdGlvbiBvKCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBzKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIHUodCl7aWYocj09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQodCwwKTtpZigocj09PW98fCFyKSYmc2V0VGltZW91dClyZXR1cm4gcj1zZXRUaW1lb3V0LHNldFRpbWVvdXQodCwwKTt0cnl7cmV0dXJuIHIodCwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLHQsMCl9Y2F0Y2goZSl7cmV0dXJuIHIuY2FsbCh0aGlzLHQsMCl9fX0hZnVuY3Rpb24oKXt0cnl7cj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6b31jYXRjaCh0KXtyPW99dHJ5e249XCJmdW5jdGlvblwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpzfWNhdGNoKHQpe249c319KCk7dmFyIGEsZj1bXSxoPSExLGw9LTE7ZnVuY3Rpb24gYygpe2gmJmEmJihoPSExLGEubGVuZ3RoP2Y9YS5jb25jYXQoZik6bD0tMSxmLmxlbmd0aCYmcCgpKX1mdW5jdGlvbiBwKCl7aWYoIWgpe3ZhciB0PXUoYyk7aD0hMDtmb3IodmFyIGU9Zi5sZW5ndGg7ZTspe2ZvcihhPWYsZj1bXTsrK2w8ZTspYSYmYVtsXS5ydW4oKTtsPS0xLGU9Zi5sZW5ndGh9YT1udWxsLGg9ITEsZnVuY3Rpb24odCl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHQpO2lmKChuPT09c3x8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh0KTt0cnl7bih0KX1jYXRjaChlKXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiBuLmNhbGwodGhpcyx0KX19fSh0KX19ZnVuY3Rpb24gZyh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lfWZ1bmN0aW9uIGQoKXt9aS5uZXh0VGljaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO2YucHVzaChuZXcgZyh0LGUpKSwxIT09Zi5sZW5ndGh8fGh8fHUocCl9LGcucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGkudGl0bGU9XCJicm93c2VyXCIsaS5icm93c2VyPSEwLGkuZW52PXt9LGkuYXJndj1bXSxpLnZlcnNpb249XCJcIixpLnZlcnNpb25zPXt9LGkub249ZCxpLmFkZExpc3RlbmVyPWQsaS5vbmNlPWQsaS5vZmY9ZCxpLnJlbW92ZUxpc3RlbmVyPWQsaS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZCxpLmVtaXQ9ZCxpLnByZXBlbmRMaXN0ZW5lcj1kLGkucHJlcGVuZE9uY2VMaXN0ZW5lcj1kLGkubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfSxpLmJpbmRpbmc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9LGkuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9LGkuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfSxpLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fV0pfSk7XHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuY29uc3QgdW5wYWNrQnJpZGdlID0gV29ya2VyU2NvcGUudW5wYWNrQnJpZGdlO1xyXG5cclxubGV0IHVucGFjaztcclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXVucGFjay0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbnZhciBpbml0dW5wYWNrID0gZnVuY3Rpb24od2FzbUJpbmFyeUZpbGUpIHtcclxuICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaGFzIGJlZW4gX2NhcmVmdWxseV8gbW9kaWZpZWQgYnkgaGFuZC5cclxuICAvLyBEdWUgdG8gV2ViUGFjayBlbWJlZGRpbmcgdGhpcyBzY3JpcHQgaW50byB0aGUgWmVhIGVuZ2luZVxyXG4gIC8vIGJ1aWxkLCBjZXJ0YWluIGZlYXR1cmVzIGJyb2tlLlxyXG4gIC8vIFRoZXJlIHdhcyBjb2RlIHRvIGhhbmRsZSBsb2FkaW5nIGluIGEgbm9kZUpTIGNvbnRleHQsIHRoYXQgdHJpZWQgdG8gaW1wb3J0KFwiZnNcIilcclxuICAvLyBXZWJQYWNrIGtlcHRzIHRyaXBwaW5nIHVwIG9uIHRoYXQgY29kZSBpbiBpdHMgc3RhdGljIGFuYWx5c2lzIG9mIHRoZSBjb2RlLCBzb1xyXG4gIC8vIEkgY2FyZWZ1bGx5IHJlbW92ZWQgaXQuXHJcbiAgLy8gVGhlIGdsb2JhbCBzY29wZSBvZiB0aGUgc2NyaXB0IHNlZW1zIHRvIGJlIGRpZmZlcmVudCwgc28gdW5wYWNrQnJpZGdlIHdhcyBub3QgYXZhaWxhYmxlLlxyXG4gIC8vIFRoZSB1bnBhY2tCcmlkZ2UgY29kZSBhc3NpZ25zIHVucGFja0JyaWRnZSB0byB0aGUgcGFzc2VkIGluIHNjb3BlLCB3aGljaCBpcyAndGhpcycsIGJ1dCB0aGF0XHJcbiAgLy8gc2NvcGUgaXNuJ3QgYXZhaWxhYmxlIGluc2lkZSB0aGlzICd1bnBhY2snIGZ1bmN0aW9uLlxyXG4gIGNvbnN0IHVucGFjayA9IHt9O1xyXG5cclxuICAvLyBOb3RlOiB0aGUgZm9sbG93aW5nIGlzIHRoZSBVUkwgb2YgdGhlIHVucGFjay53YXNtIGZpbGUgaW4gb3VyIFplYUVuZ2luZSBwcm9qZWN0IG9uIG91clxyXG4gIC8vIHNlcnZlci4gSWRlYWxseSB3ZSBjb3VsZCB1c2UgYSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIFplYUVuZ2luZSBmaWxlLCBidXRcclxuICAvLyB0aGF0IGlzbid0IHBvc3NpYmxlIHlldC4gKFRPRE86IEFzayBNYXVybyBhYm91dCB0aGlzKVxyXG4gIGNyZWRlbnRpYWxzID0gXCJvbWl0XCJcclxuICAvLyB2YXIgd2FzbUJpbmFyeUZpbGU9XCJ1bnBhY2sud2FzbVwiO1xyXG5cclxudmFyIE1vZHVsZT10eXBlb2YgdW5wYWNrIT09XCJ1bmRlZmluZWRcIj91bnBhY2s6e307dmFyIEV4dD11bnBhY2tCcmlkZ2UuRXh0O3ZhciBqc0FQST17b3BlbjooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQub3Blbi5hcHBseShFeHQuY3VycmVudCxhcmd1bWVudHMpfSksY2xvc2U6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LmNsb3NlLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KSxyZWFkOihmdW5jdGlvbigpe3JldHVybiBFeHQuY3VycmVudC5yZWFkLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KSx3cml0ZTooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQud3JpdGUuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLHRlbGw6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LnRlbGwuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLHNlZWs6KGZ1bmN0aW9uKCl7cmV0dXJuIEV4dC5jdXJyZW50LnNlZWsuYXBwbHkoRXh0LmN1cnJlbnQsYXJndW1lbnRzKX0pLGNyZWF0ZTooZnVuY3Rpb24oKXtyZXR1cm4gRXh0LmN1cnJlbnQuY3JlYXRlLmFwcGx5KEV4dC5jdXJyZW50LGFyZ3VtZW50cyl9KX07dmFyIG1vZHVsZU92ZXJyaWRlcz17fTt2YXIga2V5O2ZvcihrZXkgaW4gTW9kdWxlKXtpZihNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSl7bW9kdWxlT3ZlcnJpZGVzW2tleV09TW9kdWxlW2tleV19fU1vZHVsZVtcImFyZ3VtZW50c1wiXT1bXTtNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXT1cIi4vdGhpcy5wcm9ncmFtXCI7TW9kdWxlW1wicXVpdFwiXT0oZnVuY3Rpb24oc3RhdHVzLHRvVGhyb3cpe3Rocm93IHRvVGhyb3d9KTtNb2R1bGVbXCJwcmVSdW5cIl09W107TW9kdWxlW1wicG9zdFJ1blwiXT1bXTt2YXIgRU5WSVJPTk1FTlRfSVNfV0VCPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVI9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX05PREU9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX1NIRUxMPWZhbHNlO2lmKE1vZHVsZVtcIkVOVklST05NRU5UXCJdKXtpZihNb2R1bGVbXCJFTlZJUk9OTUVOVFwiXT09PVwiV0VCXCIpe0VOVklST05NRU5UX0lTX1dFQj10cnVlfWVsc2UgaWYoTW9kdWxlW1wiRU5WSVJPTk1FTlRcIl09PT1cIldPUktFUlwiKXtFTlZJUk9OTUVOVF9JU19XT1JLRVI9dHJ1ZX1lbHNlIGlmKE1vZHVsZVtcIkVOVklST05NRU5UXCJdPT09XCJOT0RFXCIpe0VOVklST05NRU5UX0lTX05PREU9dHJ1ZX1lbHNlIGlmKE1vZHVsZVtcIkVOVklST05NRU5UXCJdPT09XCJTSEVMTFwiKXtFTlZJUk9OTUVOVF9JU19TSEVMTD10cnVlfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiTW9kdWxlWydFTlZJUk9OTUVOVCddIHZhbHVlIGlzIG5vdCB2YWxpZC4gbXVzdCBiZSBvbmUgb2Y6IFdFQnxXT1JLRVJ8Tk9ERXxTSEVMTC5cIil9fWVsc2V7RU5WSVJPTk1FTlRfSVNfV0VCPXR5cGVvZiB3aW5kb3c9PT1cIm9iamVjdFwiO0VOVklST05NRU5UX0lTX1dPUktFUj10eXBlb2YgaW1wb3J0U2NyaXB0cz09PVwiZnVuY3Rpb25cIjtFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT09XCJvYmplY3RcIiYmdHlwZW9mIHJlcXVpcmU9PT1cImZ1bmN0aW9uXCImJiFFTlZJUk9OTUVOVF9JU19XRUImJiFFTlZJUk9OTUVOVF9JU19XT1JLRVI7RU5WSVJPTk1FTlRfSVNfU0hFTEw9IUVOVklST05NRU5UX0lTX1dFQiYmIUVOVklST05NRU5UX0lTX05PREUmJiFFTlZJUk9OTUVOVF9JU19XT1JLRVJ9XHJcbmlmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKXtNb2R1bGVbXCJyZWFkXCJdPWZ1bmN0aW9uIHNoZWxsX3JlYWQodXJsKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9O2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7TW9kdWxlW1wicmVhZEJpbmFyeVwiXT1mdW5jdGlvbiByZWFkQmluYXJ5KHVybCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfX1Nb2R1bGVbXCJyZWFkQXN5bmNcIl09ZnVuY3Rpb24gcmVhZEFzeW5jKHVybCxvbmxvYWQsb25lcnJvcil7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsdHJ1ZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLm9ubG9hZD1mdW5jdGlvbiB4aHJfb25sb2FkKCl7aWYoeGhyLnN0YXR1cz09MjAwfHx4aHIuc3RhdHVzPT0wJiZ4aHIucmVzcG9uc2Upe29ubG9hZCh4aHIucmVzcG9uc2UpO3JldHVybn1vbmVycm9yKCl9O3hoci5vbmVycm9yPW9uZXJyb3I7eGhyLnNlbmQobnVsbCl9O01vZHVsZVtcInNldFdpbmRvd1RpdGxlXCJdPShmdW5jdGlvbih0aXRsZSl7ZG9jdW1lbnQudGl0bGU9dGl0bGV9KX1Nb2R1bGVbXCJwcmludFwiXT10eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCI/Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTp0eXBlb2YgcHJpbnQhPT1cInVuZGVmaW5lZFwiP3ByaW50Om51bGw7TW9kdWxlW1wicHJpbnRFcnJcIl09dHlwZW9mIHByaW50RXJyIT09XCJ1bmRlZmluZWRcIj9wcmludEVycjp0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJmNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpfHxNb2R1bGVbXCJwcmludFwiXTtNb2R1bGUucHJpbnQ9TW9kdWxlW1wicHJpbnRcIl07TW9kdWxlLnByaW50RXJyPU1vZHVsZVtcInByaW50RXJyXCJdO2ZvcihrZXkgaW4gbW9kdWxlT3ZlcnJpZGVzKXtpZihtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSl7TW9kdWxlW2tleV09bW9kdWxlT3ZlcnJpZGVzW2tleV19fW1vZHVsZU92ZXJyaWRlcz11bmRlZmluZWQ7dmFyIFNUQUNLX0FMSUdOPTE2O2Z1bmN0aW9uIHN0YXRpY0FsbG9jKHNpemUpe2Fzc2VydCghc3RhdGljU2VhbGVkKTt2YXIgcmV0PVNUQVRJQ1RPUDtTVEFUSUNUT1A9U1RBVElDVE9QK3NpemUrMTUmLTE2O3JldHVybiByZXR9ZnVuY3Rpb24gZHluYW1pY0FsbG9jKHNpemUpe2Fzc2VydChEWU5BTUlDVE9QX1BUUik7dmFyIHJldD1IRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdO3ZhciBlbmQ9cmV0K3NpemUrMTUmLTE2O0hFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml09ZW5kO2lmKGVuZD49VE9UQUxfTUVNT1JZKXt2YXIgc3VjY2Vzcz1lbmxhcmdlTWVtb3J5KCk7aWYoIXN1Y2Nlc3Mpe0hFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml09cmV0O3JldHVybiAwfX1yZXR1cm4gcmV0fWZ1bmN0aW9uIGFsaWduTWVtb3J5KHNpemUsZmFjdG9yKXtpZighZmFjdG9yKWZhY3Rvcj1TVEFDS19BTElHTjt2YXIgcmV0PXNpemU9TWF0aC5jZWlsKHNpemUvZmFjdG9yKSpmYWN0b3I7cmV0dXJuIHJldH1mdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKXtzd2l0Y2godHlwZSl7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnJldHVybiAxO2Nhc2VcImkxNlwiOnJldHVybiAyO2Nhc2VcImkzMlwiOnJldHVybiA0O2Nhc2VcImk2NFwiOnJldHVybiA4O2Nhc2VcImZsb2F0XCI6cmV0dXJuIDQ7Y2FzZVwiZG91YmxlXCI6cmV0dXJuIDg7ZGVmYXVsdDp7aWYodHlwZVt0eXBlLmxlbmd0aC0xXT09PVwiKlwiKXtyZXR1cm4gNH1lbHNlIGlmKHR5cGVbMF09PT1cImlcIil7dmFyIGJpdHM9cGFyc2VJbnQodHlwZS5zdWJzdHIoMSkpO2Fzc2VydChiaXRzJTg9PT0wKTtyZXR1cm4gYml0cy84fWVsc2V7cmV0dXJuIDB9fX19dmFyIGZ1bmN0aW9uUG9pbnRlcnM9bmV3IEFycmF5KDApO3ZhciBHTE9CQUxfQkFTRT0xMDI0O3ZhciBBQk9SVD0wO3ZhciBFWElUU1RBVFVTPTA7ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbix0ZXh0KXtpZighY29uZGl0aW9uKXthYm9ydChcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK3RleHQpfX1mdW5jdGlvbiBzZXRWYWx1ZShwdHIsdmFsdWUsdHlwZSxub1NhZmUpe3R5cGU9dHlwZXx8XCJpOFwiO2lmKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoLTEpPT09XCIqXCIpdHlwZT1cImkzMlwiO3N3aXRjaCh0eXBlKXtjYXNlXCJpMVwiOkhFQVA4W3B0cj4+MF09dmFsdWU7YnJlYWs7Y2FzZVwiaThcIjpIRUFQOFtwdHI+PjBdPXZhbHVlO2JyZWFrO2Nhc2VcImkxNlwiOkhFQVAxNltwdHI+PjFdPXZhbHVlO2JyZWFrO2Nhc2VcImkzMlwiOkhFQVAzMltwdHI+PjJdPXZhbHVlO2JyZWFrO2Nhc2VcImk2NFwiOnRlbXBJNjQ9W3ZhbHVlPj4+MCwodGVtcERvdWJsZT12YWx1ZSwrTWF0aF9hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPyhNYXRoX21pbigrTWF0aF9mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpLDQyOTQ5NjcyOTUpfDApPj4+MDp+fitNYXRoX2NlaWwoKHRlbXBEb3VibGUtICsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW3B0cj4+Ml09dGVtcEk2NFswXSxIRUFQMzJbcHRyKzQ+PjJdPXRlbXBJNjRbMV07YnJlYWs7Y2FzZVwiZmxvYXRcIjpIRUFQRjMyW3B0cj4+Ml09dmFsdWU7YnJlYWs7Y2FzZVwiZG91YmxlXCI6SEVBUEY2NFtwdHI+PjNdPXZhbHVlO2JyZWFrO2RlZmF1bHQ6YWJvcnQoXCJpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiBcIit0eXBlKX19dmFyIEFMTE9DX05PUk1BTD0wO3ZhciBBTExPQ19TVEFUSUM9Mjt2YXIgQUxMT0NfTk9ORT00O2Z1bmN0aW9uIGFsbG9jYXRlKHNsYWIsdHlwZXMsYWxsb2NhdG9yLHB0cil7dmFyIHplcm9pbml0LHNpemU7aWYodHlwZW9mIHNsYWI9PT1cIm51bWJlclwiKXt6ZXJvaW5pdD10cnVlO3NpemU9c2xhYn1lbHNle3plcm9pbml0PWZhbHNlO3NpemU9c2xhYi5sZW5ndGh9dmFyIHNpbmdsZVR5cGU9dHlwZW9mIHR5cGVzPT09XCJzdHJpbmdcIj90eXBlczpudWxsO3ZhciByZXQ7aWYoYWxsb2NhdG9yPT1BTExPQ19OT05FKXtyZXQ9cHRyfWVsc2V7cmV0PVt0eXBlb2YgX21hbGxvYz09PVwiZnVuY3Rpb25cIj9fbWFsbG9jOnN0YXRpY0FsbG9jLHN0YWNrQWxsb2Msc3RhdGljQWxsb2MsZHluYW1pY0FsbG9jXVthbGxvY2F0b3I9PT11bmRlZmluZWQ/QUxMT0NfU1RBVElDOmFsbG9jYXRvcl0oTWF0aC5tYXgoc2l6ZSxzaW5nbGVUeXBlPzE6dHlwZXMubGVuZ3RoKSl9aWYoemVyb2luaXQpe3ZhciBzdG9wO3B0cj1yZXQ7YXNzZXJ0KChyZXQmMyk9PTApO3N0b3A9cmV0KyhzaXplJn4zKTtmb3IoO3B0cjxzdG9wO3B0cis9NCl7SEVBUDMyW3B0cj4+Ml09MH1zdG9wPXJldCtzaXplO3doaWxlKHB0cjxzdG9wKXtIRUFQOFtwdHIrKz4+MF09MH1yZXR1cm4gcmV0fWlmKHNpbmdsZVR5cGU9PT1cImk4XCIpe2lmKHNsYWIuc3ViYXJyYXl8fHNsYWIuc2xpY2Upe0hFQVBVOC5zZXQoc2xhYixyZXQpfWVsc2V7SEVBUFU4LnNldChuZXcgVWludDhBcnJheShzbGFiKSxyZXQpfXJldHVybiByZXR9dmFyIGk9MCx0eXBlLHR5cGVTaXplLHByZXZpb3VzVHlwZTt3aGlsZShpPHNpemUpe3ZhciBjdXJyPXNsYWJbaV07dHlwZT1zaW5nbGVUeXBlfHx0eXBlc1tpXTtpZih0eXBlPT09MCl7aSsrO2NvbnRpbnVlfWlmKHR5cGU9PVwiaTY0XCIpdHlwZT1cImkzMlwiO3NldFZhbHVlKHJldCtpLGN1cnIsdHlwZSk7aWYocHJldmlvdXNUeXBlIT09dHlwZSl7dHlwZVNpemU9Z2V0TmF0aXZlVHlwZVNpemUodHlwZSk7cHJldmlvdXNUeXBlPXR5cGV9aSs9dHlwZVNpemV9cmV0dXJuIHJldH1mdW5jdGlvbiBQb2ludGVyX3N0cmluZ2lmeShwdHIsbGVuZ3RoKXtpZihsZW5ndGg9PT0wfHwhcHRyKXJldHVyblwiXCI7dmFyIGhhc1V0Zj0wO3ZhciB0O3ZhciBpPTA7d2hpbGUoMSl7dD1IRUFQVThbcHRyK2k+PjBdO2hhc1V0Znw9dDtpZih0PT0wJiYhbGVuZ3RoKWJyZWFrO2krKztpZihsZW5ndGgmJmk9PWxlbmd0aClicmVha31pZighbGVuZ3RoKWxlbmd0aD1pO3ZhciByZXQ9XCJcIjtpZihoYXNVdGY8MTI4KXt2YXIgTUFYX0NIVU5LPTEwMjQ7dmFyIGN1cnI7d2hpbGUobGVuZ3RoPjApe2N1cnI9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsSEVBUFU4LnN1YmFycmF5KHB0cixwdHIrTWF0aC5taW4obGVuZ3RoLE1BWF9DSFVOSykpKTtyZXQ9cmV0P3JldCtjdXJyOmN1cnI7cHRyKz1NQVhfQ0hVTks7bGVuZ3RoLT1NQVhfQ0hVTkt9cmV0dXJuIHJldH1yZXR1cm4gVVRGOFRvU3RyaW5nKHB0cil9dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9PVwidW5kZWZpbmVkXCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp1bmRlZmluZWQ7ZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSxpZHgpe3ZhciBlbmRQdHI9aWR4O3doaWxlKHU4QXJyYXlbZW5kUHRyXSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZ1OEFycmF5LnN1YmFycmF5JiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZSh1OEFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX1lbHNle3ZhciB1MCx1MSx1Mix1Myx1NCx1NTt2YXIgc3RyPVwiXCI7d2hpbGUoMSl7dTA9dThBcnJheVtpZHgrK107aWYoIXUwKXJldHVybiBzdHI7aWYoISh1MCYxMjgpKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO2NvbnRpbnVlfXUxPXU4QXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX11Mj11OEFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UzPXU4QXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDgpPT0yNDApe3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fHUzfWVsc2V7dTQ9dThBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI1Mik9PTI0OCl7dTA9KHUwJjMpPDwyNHx1MTw8MTh8dTI8PDEyfHUzPDw2fHU0fWVsc2V7dTU9dThBcnJheVtpZHgrK10mNjM7dTA9KHUwJjEpPDwzMHx1MTw8MjR8dTI8PDE4fHUzPDwxMnx1NDw8Nnx1NX19fWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApfWVsc2V7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyl9fX19ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cil7cmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIpfWZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0cixvdXRVOEFycmF5LG91dElkeCxtYXhCeXRlc1RvV3JpdGUpe2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXU9NjU1MzYrKCh1JjEwMjMpPDwxMCl8c3RyLmNoYXJDb2RlQXQoKytpKSYxMDIzO2lmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109dX1lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MTkyfHU+PjY7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZSBpZih1PD02NTUzNSl7aWYob3V0SWR4KzI+PWVuZElkeClicmVhaztvdXRVOEFycmF5W291dElkeCsrXT0yMjR8dT4+MTI7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjYmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZSBpZih1PD0yMDk3MTUxKXtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTI0MHx1Pj4xODtvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTImNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjYmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZSBpZih1PD02NzEwODg2Myl7aWYob3V0SWR4KzQ+PWVuZElkeClicmVhaztvdXRVOEFycmF5W291dElkeCsrXT0yNDh8dT4+MjQ7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjE4JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+NiY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dSY2M31lbHNle2lmKG91dElkeCs1Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MjUyfHU+PjMwO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4yNCY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTgmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjEyJjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj42JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzfX1vdXRVOEFycmF5W291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fWZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl7cmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl9ZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cil7dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl1PTY1NTM2KygodSYxMDIzKTw8MTApfHN0ci5jaGFyQ29kZUF0KCsraSkmMTAyMztpZih1PD0xMjcpeysrbGVufWVsc2UgaWYodTw9MjA0Nyl7bGVuKz0yfWVsc2UgaWYodTw9NjU1MzUpe2xlbis9M31lbHNlIGlmKHU8PTIwOTcxNTEpe2xlbis9NH1lbHNlIGlmKHU8PTY3MTA4ODYzKXtsZW4rPTV9ZWxzZXtsZW4rPTZ9fXJldHVybiBsZW59dmFyIFVURjE2RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPT1cInVuZGVmaW5lZFwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnVuZGVmaW5lZDtmdW5jdGlvbiBVVEYzMlRvU3RyaW5nKHB0cil7dmFyIGk9MDt2YXIgc3RyPVwiXCI7d2hpbGUoMSl7dmFyIHV0ZjMyPUhFQVAzMltwdHIraSo0Pj4yXTtpZih1dGYzMj09MClyZXR1cm4gc3RyOysraTtpZih1dGYzMj49NjU1MzYpe3ZhciBjaD11dGYzMi02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfWVsc2V7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKX19fWZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpe3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1fbWFsbG9jKHNpemUpO2lmKHJldClzdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUDgscmV0LHNpemUpO3JldHVybiByZXR9ZnVuY3Rpb24gZGVtYW5nbGUoZnVuYyl7cmV0dXJuIGZ1bmN9ZnVuY3Rpb24gZGVtYW5nbGVBbGwodGV4dCl7dmFyIHJlZ2V4PS9fX1pbXFx3XFxkX10rL2c7cmV0dXJuIHRleHQucmVwbGFjZShyZWdleCwoZnVuY3Rpb24oeCl7dmFyIHk9ZGVtYW5nbGUoeCk7cmV0dXJuIHg9PT15P3g6eCtcIiBbXCIreStcIl1cIn0pKX1mdW5jdGlvbiBqc1N0YWNrVHJhY2UoKXt2YXIgZXJyPW5ldyBFcnJvcjtpZighZXJyLnN0YWNrKXt0cnl7dGhyb3cgbmV3IEVycm9yKDApfWNhdGNoKGUpe2Vycj1lfWlmKCFlcnIuc3RhY2spe3JldHVyblwiKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSlcIn19cmV0dXJuIGVyci5zdGFjay50b1N0cmluZygpfWZ1bmN0aW9uIHN0YWNrVHJhY2UoKXt2YXIganM9anNTdGFja1RyYWNlKCk7aWYoTW9kdWxlW1wiZXh0cmFTdGFja1RyYWNlXCJdKWpzKz1cIlxcblwiK01vZHVsZVtcImV4dHJhU3RhY2tUcmFjZVwiXSgpO3JldHVybiBkZW1hbmdsZUFsbChqcyl9dmFyIFdBU01fUEFHRV9TSVpFPTY1NTM2O3ZhciBBU01KU19QQUdFX1NJWkU9MTY3NzcyMTY7dmFyIE1JTl9UT1RBTF9NRU1PUlk9MTY3NzcyMTY7ZnVuY3Rpb24gYWxpZ25VcCh4LG11bHRpcGxlKXtpZih4JW11bHRpcGxlPjApe3grPW11bHRpcGxlLXglbXVsdGlwbGV9cmV0dXJuIHh9dmFyIGJ1ZmZlcixIRUFQOCxIRUFQVTgsSEVBUDE2LEhFQVBVMTYsSEVBUDMyLEhFQVBVMzIsSEVBUEYzMixIRUFQRjY0O2Z1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlcihidWYpe01vZHVsZVtcImJ1ZmZlclwiXT1idWZmZXI9YnVmfWZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCl7TW9kdWxlW1wiSEVBUDhcIl09SEVBUDg9bmV3IEludDhBcnJheShidWZmZXIpO01vZHVsZVtcIkhFQVAxNlwiXT1IRUFQMTY9bmV3IEludDE2QXJyYXkoYnVmZmVyKTtNb2R1bGVbXCJIRUFQMzJcIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7TW9kdWxlW1wiSEVBUFU4XCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShidWZmZXIpO01vZHVsZVtcIkhFQVBVMTZcIl09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYnVmZmVyKTtNb2R1bGVbXCJIRUFQVTMyXCJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7TW9kdWxlW1wiSEVBUEYzMlwiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtNb2R1bGVbXCJIRUFQRjY0XCJdPUhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShidWZmZXIpfXZhciBTVEFUSUNfQkFTRSxTVEFUSUNUT1Asc3RhdGljU2VhbGVkO3ZhciBTVEFDS19CQVNFLFNUQUNLVE9QLFNUQUNLX01BWDt2YXIgRFlOQU1JQ19CQVNFLERZTkFNSUNUT1BfUFRSO1NUQVRJQ19CQVNFPVNUQVRJQ1RPUD1TVEFDS19CQVNFPVNUQUNLVE9QPVNUQUNLX01BWD1EWU5BTUlDX0JBU0U9RFlOQU1JQ1RPUF9QVFI9MDtzdGF0aWNTZWFsZWQ9ZmFsc2U7ZnVuY3Rpb24gYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkoKXthYm9ydChcIkNhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlIFwiK1RPVEFMX01FTU9SWStcIiwgKDIpIGNvbXBpbGUgd2l0aCAgLXMgQUxMT1dfTUVNT1JZX0dST1dUSD0xICB3aGljaCBhbGxvd3MgaW5jcmVhc2luZyB0aGUgc2l6ZSBhdCBydW50aW1lLCBvciAoMykgaWYgeW91IHdhbnQgbWFsbG9jIHRvIHJldHVybiBOVUxMICgwKSBpbnN0ZWFkIG9mIHRoaXMgYWJvcnQsIGNvbXBpbGUgd2l0aCAgLXMgQUJPUlRJTkdfTUFMTE9DPTAgXCIpfWlmKCFNb2R1bGVbXCJyZWFsbG9jQnVmZmVyXCJdKU1vZHVsZVtcInJlYWxsb2NCdWZmZXJcIl09KGZ1bmN0aW9uKHNpemUpe3ZhciByZXQ7dHJ5e2lmKEFycmF5QnVmZmVyLnRyYW5zZmVyKXtyZXQ9QXJyYXlCdWZmZXIudHJhbnNmZXIoYnVmZmVyLHNpemUpfWVsc2V7dmFyIG9sZEhFQVA4PUhFQVA4O3JldD1uZXcgQXJyYXlCdWZmZXIoc2l6ZSk7dmFyIHRlbXA9bmV3IEludDhBcnJheShyZXQpO3RlbXAuc2V0KG9sZEhFQVA4KX19Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfXZhciBzdWNjZXNzPV9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5KHJldCk7aWYoIXN1Y2Nlc3MpcmV0dXJuIGZhbHNlO3JldHVybiByZXR9KTtmdW5jdGlvbiBlbmxhcmdlTWVtb3J5KCl7dmFyIFBBR0VfTVVMVElQTEU9TW9kdWxlW1widXNpbmdXYXNtXCJdP1dBU01fUEFHRV9TSVpFOkFTTUpTX1BBR0VfU0laRTt2YXIgTElNSVQ9MjE0NzQ4MzY0OC1QQUdFX01VTFRJUExFO2lmKEhFQVAzMltEWU5BTUlDVE9QX1BUUj4+Ml0+TElNSVQpe3JldHVybiBmYWxzZX12YXIgT0xEX1RPVEFMX01FTU9SWT1UT1RBTF9NRU1PUlk7VE9UQUxfTUVNT1JZPU1hdGgubWF4KFRPVEFMX01FTU9SWSxNSU5fVE9UQUxfTUVNT1JZKTt3aGlsZShUT1RBTF9NRU1PUlk8SEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXSl7aWYoVE9UQUxfTUVNT1JZPD01MzY4NzA5MTIpe1RPVEFMX01FTU9SWT1hbGlnblVwKDIqVE9UQUxfTUVNT1JZLFBBR0VfTVVMVElQTEUpfWVsc2V7VE9UQUxfTUVNT1JZPU1hdGgubWluKGFsaWduVXAoKDMqVE9UQUxfTUVNT1JZKzIxNDc0ODM2NDgpLzQsUEFHRV9NVUxUSVBMRSksTElNSVQpfX12YXIgcmVwbGFjZW1lbnQ9TW9kdWxlW1wicmVhbGxvY0J1ZmZlclwiXShUT1RBTF9NRU1PUlkpO2lmKCFyZXBsYWNlbWVudHx8cmVwbGFjZW1lbnQuYnl0ZUxlbmd0aCE9VE9UQUxfTUVNT1JZKXtUT1RBTF9NRU1PUlk9T0xEX1RPVEFMX01FTU9SWTtyZXR1cm4gZmFsc2V9dXBkYXRlR2xvYmFsQnVmZmVyKHJlcGxhY2VtZW50KTt1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpO3JldHVybiB0cnVlfXZhciBieXRlTGVuZ3RoO3RyeXtieXRlTGVuZ3RoPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUJ1ZmZlci5wcm90b3R5cGUsXCJieXRlTGVuZ3RoXCIpLmdldCk7Ynl0ZUxlbmd0aChuZXcgQXJyYXlCdWZmZXIoNCkpfWNhdGNoKGUpe2J5dGVMZW5ndGg9KGZ1bmN0aW9uKGJ1ZmZlcil7cmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RofSl9dmFyIFRPVEFMX1NUQUNLPU1vZHVsZVtcIlRPVEFMX1NUQUNLXCJdfHw1MjQyODgwO3ZhciBUT1RBTF9NRU1PUlk9TW9kdWxlW1wiVE9UQUxfTUVNT1JZXCJdfHwxNjc3NzIxNjtpZihUT1RBTF9NRU1PUlk8VE9UQUxfU1RBQ0spTW9kdWxlLnByaW50RXJyKFwiVE9UQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzIFwiK1RPVEFMX01FTU9SWStcIiEgKFRPVEFMX1NUQUNLPVwiK1RPVEFMX1NUQUNLK1wiKVwiKTtpZihNb2R1bGVbXCJidWZmZXJcIl0pe2J1ZmZlcj1Nb2R1bGVbXCJidWZmZXJcIl19ZWxzZXtpZih0eXBlb2YgV2ViQXNzZW1ibHk9PT1cIm9iamVjdFwiJiZ0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5PT09XCJmdW5jdGlvblwiKXtNb2R1bGVbXCJ3YXNtTWVtb3J5XCJdPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1wiaW5pdGlhbFwiOlRPVEFMX01FTU9SWS9XQVNNX1BBR0VfU0laRX0pO2J1ZmZlcj1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdLmJ1ZmZlcn1lbHNle2J1ZmZlcj1uZXcgQXJyYXlCdWZmZXIoVE9UQUxfTUVNT1JZKX1Nb2R1bGVbXCJidWZmZXJcIl09YnVmZmVyfXVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7ZnVuY3Rpb24gZ2V0VG90YWxNZW1vcnkoKXtyZXR1cm4gVE9UQUxfTUVNT1JZfUhFQVAzMlswXT0xNjY4NTA5MDI5O0hFQVAxNlsxXT0yNTQ1OTtpZihIRUFQVThbMl0hPT0xMTV8fEhFQVBVOFszXSE9PTk5KXRocm93XCJSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hXCI7ZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKXt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe3ZhciBjYWxsYmFjaz1jYWxsYmFja3Muc2hpZnQoKTtpZih0eXBlb2YgY2FsbGJhY2s9PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2soKTtjb250aW51ZX12YXIgZnVuYz1jYWxsYmFjay5mdW5jO2lmKHR5cGVvZiBmdW5jPT09XCJudW1iZXJcIil7aWYoY2FsbGJhY2suYXJnPT09dW5kZWZpbmVkKXtNb2R1bGVbXCJkeW5DYWxsX3ZcIl0oZnVuYyl9ZWxzZXtNb2R1bGVbXCJkeW5DYWxsX3ZpXCJdKGZ1bmMsY2FsbGJhY2suYXJnKX19ZWxzZXtmdW5jKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrLmFyZyl9fX12YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FUTUFJTl9fPVtdO3ZhciBfX0FURVhJVF9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO3ZhciBydW50aW1lSW5pdGlhbGl6ZWQ9ZmFsc2U7dmFyIHJ1bnRpbWVFeGl0ZWQ9ZmFsc2U7ZnVuY3Rpb24gcHJlUnVuKCl7aWYoTW9kdWxlW1wicHJlUnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicHJlUnVuXCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlUnVuXCJdPVtNb2R1bGVbXCJwcmVSdW5cIl1dO3doaWxlKE1vZHVsZVtcInByZVJ1blwiXS5sZW5ndGgpe2FkZE9uUHJlUnVuKE1vZHVsZVtcInByZVJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKX1mdW5jdGlvbiBlbnN1cmVJbml0UnVudGltZSgpe2lmKHJ1bnRpbWVJbml0aWFsaXplZClyZXR1cm47cnVudGltZUluaXRpYWxpemVkPXRydWU7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyl9ZnVuY3Rpb24gcHJlTWFpbigpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pfWZ1bmN0aW9uIGV4aXRSdW50aW1lKCl7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVEVYSVRfXyk7cnVudGltZUV4aXRlZD10cnVlfWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbXCJwb3N0UnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInBvc3RSdW5cIl09W01vZHVsZVtcInBvc3RSdW5cIl1dO3doaWxlKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyl9ZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2Ipe19fQVRQT1NUUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixidWZmZXIsZG9udEFkZE51bGwpe2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0hFQVA4W2J1ZmZlcisrPj4wXT1zdHIuY2hhckNvZGVBdChpKX1pZighZG9udEFkZE51bGwpSEVBUDhbYnVmZmVyPj4wXT0wfXZhciBNYXRoX2Ficz1NYXRoLmFiczt2YXIgTWF0aF9jb3M9TWF0aC5jb3M7dmFyIE1hdGhfc2luPU1hdGguc2luO3ZhciBNYXRoX3Rhbj1NYXRoLnRhbjt2YXIgTWF0aF9hY29zPU1hdGguYWNvczt2YXIgTWF0aF9hc2luPU1hdGguYXNpbjt2YXIgTWF0aF9hdGFuPU1hdGguYXRhbjt2YXIgTWF0aF9hdGFuMj1NYXRoLmF0YW4yO3ZhciBNYXRoX2V4cD1NYXRoLmV4cDt2YXIgTWF0aF9sb2c9TWF0aC5sb2c7dmFyIE1hdGhfc3FydD1NYXRoLnNxcnQ7dmFyIE1hdGhfY2VpbD1NYXRoLmNlaWw7dmFyIE1hdGhfZmxvb3I9TWF0aC5mbG9vcjt2YXIgTWF0aF9wb3c9TWF0aC5wb3c7dmFyIE1hdGhfaW11bD1NYXRoLmltdWw7dmFyIE1hdGhfZnJvdW5kPU1hdGguZnJvdW5kO3ZhciBNYXRoX3JvdW5kPU1hdGgucm91bmQ7dmFyIE1hdGhfbWluPU1hdGgubWluO3ZhciBNYXRoX21heD1NYXRoLm1heDt2YXIgTWF0aF9jbHozMj1NYXRoLmNsejMyO3ZhciBNYXRoX3RydW5jPU1hdGgudHJ1bmM7dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKXtyZXR1cm4gaWR9ZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihydW5EZXBlbmRlbmN5V2F0Y2hlciE9PW51bGwpe2NsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO3J1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGx9aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX1Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl09e307TW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdPXt9O3ZhciBkYXRhVVJJUHJlZml4PVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9maWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpOmZpbGVuYW1lLmluZGV4T2YoZGF0YVVSSVByZWZpeCk9PT0wfWZ1bmN0aW9uIGludGVncmF0ZVdhc21KUygpe3ZhciB3YXNtVGV4dEZpbGU9XCJ1bnBhY2sud2FzdFwiOzt2YXIgYXNtanNDb2RlRmlsZT1cInVucGFjay50ZW1wLmFzbS5qc1wiO2lmKHR5cGVvZiBNb2R1bGVbXCJsb2NhdGVGaWxlXCJdPT09XCJmdW5jdGlvblwiKXtpZighaXNEYXRhVVJJKHdhc21UZXh0RmlsZSkpe3dhc21UZXh0RmlsZT1Nb2R1bGVbXCJsb2NhdGVGaWxlXCJdKHdhc21UZXh0RmlsZSl9aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPU1vZHVsZVtcImxvY2F0ZUZpbGVcIl0od2FzbUJpbmFyeUZpbGUpfWlmKCFpc0RhdGFVUkkoYXNtanNDb2RlRmlsZSkpe2FzbWpzQ29kZUZpbGU9TW9kdWxlW1wibG9jYXRlRmlsZVwiXShhc21qc0NvZGVGaWxlKX19dmFyIHdhc21QYWdlU2l6ZT02NCoxMDI0O3ZhciBpbmZvPXtcImdsb2JhbFwiOm51bGwsXCJlbnZcIjpudWxsLFwiYXNtMndhc21cIjp7XCJmNjQtcmVtXCI6KGZ1bmN0aW9uKHgseSl7cmV0dXJuIHgleX0pLFwiZGVidWdnZXJcIjooZnVuY3Rpb24oKXtkZWJ1Z2dlcn0pfSxcInBhcmVudFwiOk1vZHVsZX07dmFyIGV4cG9ydHM9bnVsbDtmdW5jdGlvbiBtZXJnZU1lbW9yeShuZXdCdWZmZXIpe3ZhciBvbGRCdWZmZXI9TW9kdWxlW1wiYnVmZmVyXCJdO2lmKG5ld0J1ZmZlci5ieXRlTGVuZ3RoPG9sZEJ1ZmZlci5ieXRlTGVuZ3RoKXtNb2R1bGVbXCJwcmludEVyclwiXShcInRoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmVcIil9dmFyIG9sZFZpZXc9bmV3IEludDhBcnJheShvbGRCdWZmZXIpO3ZhciBuZXdWaWV3PW5ldyBJbnQ4QXJyYXkobmV3QnVmZmVyKTtuZXdWaWV3LnNldChvbGRWaWV3KTt1cGRhdGVHbG9iYWxCdWZmZXIobmV3QnVmZmVyKTt1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpfWZ1bmN0aW9uIGZpeEltcG9ydHMoaW1wb3J0cyl7cmV0dXJuIGltcG9ydHN9ZnVuY3Rpb24gZ2V0QmluYXJ5KCl7dHJ5e2lmKE1vZHVsZVtcIndhc21CaW5hcnlcIl0pe3JldHVybiBuZXcgVWludDhBcnJheShNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKX1pZihNb2R1bGVbXCJyZWFkQmluYXJ5XCJdKXtyZXR1cm4gTW9kdWxlW1wicmVhZEJpbmFyeVwiXSh3YXNtQmluYXJ5RmlsZSl9ZWxzZXt0aHJvd1wib24gdGhlIHdlYiwgd2UgbmVlZCB0aGUgd2FzbSBiaW5hcnkgdG8gYmUgcHJlbG9hZGVkIGFuZCBzZXQgb24gTW9kdWxlWyd3YXNtQmluYXJ5J10uIGVtY2MucHkgd2lsbCBkbyB0aGF0IGZvciB5b3Ugd2hlbiBnZW5lcmF0aW5nIEhUTUwgKGJ1dCBub3QgSlMpXCJ9fWNhdGNoKGVycil7YWJvcnQoZXJyKX19ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpe2lmKCFNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdJiYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpJiZ0eXBlb2YgZmV0Y2g9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSx7Y3JlZGVudGlhbHN9KS50aGVuKChmdW5jdGlvbihyZXNwb25zZSl7aWYoIXJlc3BvbnNlW1wib2tcIl0pe3Rocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit3YXNtQmluYXJ5RmlsZStcIidcIn1yZXR1cm4gcmVzcG9uc2VbXCJhcnJheUJ1ZmZlclwiXSgpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBnZXRCaW5hcnkoKX0pKX1yZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtyZXNvbHZlKGdldEJpbmFyeSgpKX0pKX1mdW5jdGlvbiBkb05hdGl2ZVdhc20oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcil7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT09XCJvYmplY3RcIil7TW9kdWxlW1wicHJpbnRFcnJcIl0oXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3JldHVybiBmYWxzZX1pZighKE1vZHVsZVtcIndhc21NZW1vcnlcIl1pbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpe01vZHVsZVtcInByaW50RXJyXCJdKFwibm8gbmF0aXZlIHdhc20gTWVtb3J5IGluIHVzZVwiKTtyZXR1cm4gZmFsc2V9ZW52W1wibWVtb3J5XCJdPU1vZHVsZVtcIndhc21NZW1vcnlcIl07aW5mb1tcImdsb2JhbFwiXT17XCJOYU5cIjpOYU4sXCJJbmZpbml0eVwiOkluZmluaXR5fTtpbmZvW1wiZ2xvYmFsLk1hdGhcIl09TWF0aDtpbmZvW1wiZW52XCJdPWVudjtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXtleHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7aWYoZXhwb3J0cy5tZW1vcnkpbWVyZ2VNZW1vcnkoZXhwb3J0cy5tZW1vcnkpO01vZHVsZVtcImFzbVwiXT1leHBvcnRzO01vZHVsZVtcInVzaW5nV2FzbVwiXT10cnVlO3JlbW92ZVJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpfWFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2lmKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSl7dHJ5e3JldHVybiBNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpfWNhdGNoKGUpe01vZHVsZVtcInByaW50RXJyXCJdKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSk7cmV0dXJuIGZhbHNlfX1mdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKG91dHB1dCl7cmVjZWl2ZUluc3RhbmNlKG91dHB1dFtcImluc3RhbmNlXCJdLG91dHB1dFtcIm1vZHVsZVwiXSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcil7Z2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oKGZ1bmN0aW9uKGJpbmFyeSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbmZvKX0pKS50aGVuKHJlY2VpdmVyKS5jYXRjaCgoZnVuY3Rpb24ocmVhc29uKXtNb2R1bGVbXCJwcmludEVyclwiXShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3JlYXNvbik7YWJvcnQocmVhc29uKX0pKX1pZighTW9kdWxlW1wid2FzbUJpbmFyeVwiXSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT09XCJmdW5jdGlvblwiJiYhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSYmdHlwZW9mIGZldGNoPT09XCJmdW5jdGlvblwiKXtXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaCh3YXNtQmluYXJ5RmlsZSx7Y3JlZGVudGlhbHN9KSxpbmZvKS50aGVuKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpLmNhdGNoKChmdW5jdGlvbihyZWFzb24pe01vZHVsZVtcInByaW50RXJyXCJdKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3JlYXNvbik7TW9kdWxlW1wicHJpbnRFcnJcIl0oXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpfSkpfWVsc2V7aW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKX1yZXR1cm57fX1Nb2R1bGVbXCJhc21QcmVsb2FkXCJdPU1vZHVsZVtcImFzbVwiXTt2YXIgYXNtanNSZWFsbG9jQnVmZmVyPU1vZHVsZVtcInJlYWxsb2NCdWZmZXJcIl07dmFyIHdhc21SZWFsbG9jQnVmZmVyPShmdW5jdGlvbihzaXplKXt2YXIgUEFHRV9NVUxUSVBMRT1Nb2R1bGVbXCJ1c2luZ1dhc21cIl0/V0FTTV9QQUdFX1NJWkU6QVNNSlNfUEFHRV9TSVpFO3NpemU9YWxpZ25VcChzaXplLFBBR0VfTVVMVElQTEUpO3ZhciBvbGQ9TW9kdWxlW1wiYnVmZmVyXCJdO3ZhciBvbGRTaXplPW9sZC5ieXRlTGVuZ3RoO2lmKE1vZHVsZVtcInVzaW5nV2FzbVwiXSl7dHJ5e3ZhciByZXN1bHQ9TW9kdWxlW1wid2FzbU1lbW9yeVwiXS5ncm93KChzaXplLW9sZFNpemUpL3dhc21QYWdlU2l6ZSk7aWYocmVzdWx0IT09KC0xfDApKXtyZXR1cm4gTW9kdWxlW1wiYnVmZmVyXCJdPU1vZHVsZVtcIndhc21NZW1vcnlcIl0uYnVmZmVyfWVsc2V7cmV0dXJuIG51bGx9fWNhdGNoKGUpe3JldHVybiBudWxsfX19KTtNb2R1bGVbXCJyZWFsbG9jQnVmZmVyXCJdPShmdW5jdGlvbihzaXplKXtpZihmaW5hbE1ldGhvZD09PVwiYXNtanNcIil7cmV0dXJuIGFzbWpzUmVhbGxvY0J1ZmZlcihzaXplKX1lbHNle3JldHVybiB3YXNtUmVhbGxvY0J1ZmZlcihzaXplKX19KTt2YXIgZmluYWxNZXRob2Q9XCJcIjtNb2R1bGVbXCJhc21cIl09KGZ1bmN0aW9uKGdsb2JhbCxlbnYscHJvdmlkZWRCdWZmZXIpe2Vudj1maXhJbXBvcnRzKGVudik7aWYoIWVudltcInRhYmxlXCJdKXt2YXIgVEFCTEVfU0laRT1Nb2R1bGVbXCJ3YXNtVGFibGVTaXplXCJdO2lmKFRBQkxFX1NJWkU9PT11bmRlZmluZWQpVEFCTEVfU0laRT0xMDI0O3ZhciBNQVhfVEFCTEVfU0laRT1Nb2R1bGVbXCJ3YXNtTWF4VGFibGVTaXplXCJdO2lmKHR5cGVvZiBXZWJBc3NlbWJseT09PVwib2JqZWN0XCImJnR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZT09PVwiZnVuY3Rpb25cIil7aWYoTUFYX1RBQkxFX1NJWkUhPT11bmRlZmluZWQpe2VudltcInRhYmxlXCJdPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7XCJpbml0aWFsXCI6VEFCTEVfU0laRSxcIm1heGltdW1cIjpNQVhfVEFCTEVfU0laRSxcImVsZW1lbnRcIjpcImFueWZ1bmNcIn0pfWVsc2V7ZW52W1widGFibGVcIl09bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtcImluaXRpYWxcIjpUQUJMRV9TSVpFLGVsZW1lbnQ6XCJhbnlmdW5jXCJ9KX19ZWxzZXtlbnZbXCJ0YWJsZVwiXT1uZXcgQXJyYXkoVEFCTEVfU0laRSl9TW9kdWxlW1wid2FzbVRhYmxlXCJdPWVudltcInRhYmxlXCJdfWlmKCFlbnZbXCJtZW1vcnlCYXNlXCJdKXtlbnZbXCJtZW1vcnlCYXNlXCJdPU1vZHVsZVtcIlNUQVRJQ19CQVNFXCJdfWlmKCFlbnZbXCJ0YWJsZUJhc2VcIl0pe2VudltcInRhYmxlQmFzZVwiXT0wfXZhciBleHBvcnRzO2V4cG9ydHM9ZG9OYXRpdmVXYXNtKGdsb2JhbCxlbnYscHJvdmlkZWRCdWZmZXIpO2lmKCFleHBvcnRzKWFib3J0KFwibm8gYmluYXJ5ZW4gbWV0aG9kIHN1Y2NlZWRlZC4gY29uc2lkZXIgZW5hYmxpbmcgbW9yZSBvcHRpb25zLCBsaWtlIGludGVycHJldGluZywgaWYgeW91IHdhbnQgdGhhdDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi93aWtpL1dlYkFzc2VtYmx5I2JpbmFyeWVuLW1ldGhvZHNcIik7cmV0dXJuIGV4cG9ydHN9KX1pbnRlZ3JhdGVXYXNtSlMoKTtTVEFUSUNfQkFTRT1HTE9CQUxfQkFTRTtTVEFUSUNUT1A9U1RBVElDX0JBU0UrNjY5NjA7X19BVElOSVRfXy5wdXNoKHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwKCl9KX0se2Z1bmM6KGZ1bmN0aW9uKCl7X19HTE9CQUxfX3N1Yl9JX2NyY19jcHAoKX0pfSx7ZnVuYzooZnVuY3Rpb24oKXtfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCgpfSl9LHtmdW5jOihmdW5jdGlvbigpe19fR0xPQkFMX19zdWJfSV9iaW5kX2NwcCgpfSl9KTt2YXIgU1RBVElDX0JVTVA9NjY5NjA7TW9kdWxlW1wiU1RBVElDX0JBU0VcIl09U1RBVElDX0JBU0U7TW9kdWxlW1wiU1RBVElDX0JVTVBcIl09U1RBVElDX0JVTVA7U1RBVElDVE9QKz0xNjtmdW5jdGlvbiBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uKHNpemUpe3JldHVybiBfbWFsbG9jKHNpemUpfWZ1bmN0aW9uIF9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252KCl7cmV0dXJuISFfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udi51bmNhdWdodF9leGNlcHRpb259dmFyIEVYQ0VQVElPTlM9e2xhc3Q6MCxjYXVnaHQ6W10saW5mb3M6e30sZGVBZGp1c3Q6KGZ1bmN0aW9uKGFkanVzdGVkKXtpZighYWRqdXN0ZWR8fEVYQ0VQVElPTlMuaW5mb3NbYWRqdXN0ZWRdKXJldHVybiBhZGp1c3RlZDtmb3IodmFyIGtleSBpbiBFWENFUFRJT05TLmluZm9zKXt2YXIgcHRyPStrZXk7dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1twdHJdO2lmKGluZm8uYWRqdXN0ZWQ9PT1hZGp1c3RlZCl7cmV0dXJuIHB0cn19cmV0dXJuIGFkanVzdGVkfSksYWRkUmVmOihmdW5jdGlvbihwdHIpe2lmKCFwdHIpcmV0dXJuO3ZhciBpbmZvPUVYQ0VQVElPTlMuaW5mb3NbcHRyXTtpbmZvLnJlZmNvdW50Kyt9KSxkZWNSZWY6KGZ1bmN0aW9uKHB0cil7aWYoIXB0cilyZXR1cm47dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1twdHJdO2Fzc2VydChpbmZvLnJlZmNvdW50PjApO2luZm8ucmVmY291bnQtLTtpZihpbmZvLnJlZmNvdW50PT09MCYmIWluZm8ucmV0aHJvd24pe2lmKGluZm8uZGVzdHJ1Y3Rvcil7TW9kdWxlW1wiZHluQ2FsbF92aVwiXShpbmZvLmRlc3RydWN0b3IscHRyKX1kZWxldGUgRVhDRVBUSU9OUy5pbmZvc1twdHJdO19fX2N4YV9mcmVlX2V4Y2VwdGlvbihwdHIpfX0pLGNsZWFyUmVmOihmdW5jdGlvbihwdHIpe2lmKCFwdHIpcmV0dXJuO3ZhciBpbmZvPUVYQ0VQVElPTlMuaW5mb3NbcHRyXTtpbmZvLnJlZmNvdW50PTB9KX07ZnVuY3Rpb24gX19fY3hhX2JlZ2luX2NhdGNoKHB0cil7dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1twdHJdO2lmKGluZm8mJiFpbmZvLmNhdWdodCl7aW5mby5jYXVnaHQ9dHJ1ZTtfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udi51bmNhdWdodF9leGNlcHRpb24tLX1pZihpbmZvKWluZm8ucmV0aHJvd249ZmFsc2U7RVhDRVBUSU9OUy5jYXVnaHQucHVzaChwdHIpO0VYQ0VQVElPTlMuYWRkUmVmKEVYQ0VQVElPTlMuZGVBZGp1c3QocHRyKSk7cmV0dXJuIHB0cn1mdW5jdGlvbiBfX19jeGFfZnJlZV9leGNlcHRpb24ocHRyKXt0cnl7cmV0dXJuIF9mcmVlKHB0cil9Y2F0Y2goZSl7fX1mdW5jdGlvbiBfX19jeGFfZW5kX2NhdGNoKCl7TW9kdWxlW1wic2V0VGhyZXdcIl0oMCk7dmFyIHB0cj1FWENFUFRJT05TLmNhdWdodC5wb3AoKTtpZihwdHIpe0VYQ0VQVElPTlMuZGVjUmVmKEVYQ0VQVElPTlMuZGVBZGp1c3QocHRyKSk7RVhDRVBUSU9OUy5sYXN0PTB9fWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzQoKXtyZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9fX3Jlc3VtZUV4Y2VwdGlvbihwdHIpe2lmKCFFWENFUFRJT05TLmxhc3Qpe0VYQ0VQVElPTlMubGFzdD1wdHJ9dGhyb3cgcHRyfWZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoKCl7dmFyIHRocm93bj1FWENFUFRJT05TLmxhc3Q7aWYoIXRocm93bil7cmV0dXJuKHNldFRlbXBSZXQwKDApLDApfDB9dmFyIGluZm89RVhDRVBUSU9OUy5pbmZvc1t0aHJvd25dO3ZhciB0aHJvd250eXBlPWluZm8udHlwZTtpZighdGhyb3dudHlwZSl7cmV0dXJuKHNldFRlbXBSZXQwKDApLHRocm93bil8MH12YXIgdHlwZUFycmF5PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7dmFyIHBvaW50ZXI9TW9kdWxlW1wiX19fY3hhX2lzX3BvaW50ZXJfdHlwZVwiXSh0aHJvd250eXBlKTtpZighX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyKV9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlcj1fbWFsbG9jKDQpO0hFQVAzMltfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaC5idWZmZXI+PjJdPXRocm93bjt0aHJvd249X19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyO2Zvcih2YXIgaT0wO2k8dHlwZUFycmF5Lmxlbmd0aDtpKyspe2lmKHR5cGVBcnJheVtpXSYmTW9kdWxlW1wiX19fY3hhX2Nhbl9jYXRjaFwiXSh0eXBlQXJyYXlbaV0sdGhyb3dudHlwZSx0aHJvd24pKXt0aHJvd249SEVBUDMyW3Rocm93bj4+Ml07aW5mby5hZGp1c3RlZD10aHJvd247cmV0dXJuKHNldFRlbXBSZXQwKHR5cGVBcnJheVtpXSksdGhyb3duKXwwfX10aHJvd249SEVBUDMyW3Rocm93bj4+Ml07cmV0dXJuKHNldFRlbXBSZXQwKHRocm93bnR5cGUpLHRocm93bil8MH1mdW5jdGlvbiBfX19jeGFfdGhyb3cocHRyLHR5cGUsZGVzdHJ1Y3Rvcil7RVhDRVBUSU9OUy5pbmZvc1twdHJdPXtwdHI6cHRyLGFkanVzdGVkOnB0cix0eXBlOnR5cGUsZGVzdHJ1Y3RvcjpkZXN0cnVjdG9yLHJlZmNvdW50OjAsY2F1Z2h0OmZhbHNlLHJldGhyb3duOmZhbHNlfTtFWENFUFRJT05TLmxhc3Q9cHRyO2lmKCEoXCJ1bmNhdWdodF9leGNlcHRpb25cImluIF9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252KSl7X19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9uPTF9ZWxzZXtfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udi51bmNhdWdodF9leGNlcHRpb24rK310aHJvdyBwdHJ9ZnVuY3Rpb24gX19fbG9jaygpe312YXIgRVJSTk9fQ09ERVM9e0VQRVJNOjEsRU5PRU5UOjIsRVNSQ0g6MyxFSU5UUjo0LEVJTzo1LEVOWElPOjYsRTJCSUc6NyxFTk9FWEVDOjgsRUJBREY6OSxFQ0hJTEQ6MTAsRUFHQUlOOjExLEVXT1VMREJMT0NLOjExLEVOT01FTToxMixFQUNDRVM6MTMsRUZBVUxUOjE0LEVOT1RCTEs6MTUsRUJVU1k6MTYsRUVYSVNUOjE3LEVYREVWOjE4LEVOT0RFVjoxOSxFTk9URElSOjIwLEVJU0RJUjoyMSxFSU5WQUw6MjIsRU5GSUxFOjIzLEVNRklMRToyNCxFTk9UVFk6MjUsRVRYVEJTWToyNixFRkJJRzoyNyxFTk9TUEM6MjgsRVNQSVBFOjI5LEVST0ZTOjMwLEVNTElOSzozMSxFUElQRTozMixFRE9NOjMzLEVSQU5HRTozNCxFTk9NU0c6NDIsRUlEUk06NDMsRUNIUk5HOjQ0LEVMMk5TWU5DOjQ1LEVMM0hMVDo0NixFTDNSU1Q6NDcsRUxOUk5HOjQ4LEVVTkFUQ0g6NDksRU5PQ1NJOjUwLEVMMkhMVDo1MSxFREVBRExLOjM1LEVOT0xDSzozNyxFQkFERTo1MixFQkFEUjo1MyxFWEZVTEw6NTQsRU5PQU5POjU1LEVCQURSUUM6NTYsRUJBRFNMVDo1NyxFREVBRExPQ0s6MzUsRUJGT05UOjU5LEVOT1NUUjo2MCxFTk9EQVRBOjYxLEVUSU1FOjYyLEVOT1NSOjYzLEVOT05FVDo2NCxFTk9QS0c6NjUsRVJFTU9URTo2NixFTk9MSU5LOjY3LEVBRFY6NjgsRVNSTU5UOjY5LEVDT01NOjcwLEVQUk9UTzo3MSxFTVVMVElIT1A6NzIsRURPVERPVDo3MyxFQkFETVNHOjc0LEVOT1RVTklROjc2LEVCQURGRDo3NyxFUkVNQ0hHOjc4LEVMSUJBQ0M6NzksRUxJQkJBRDo4MCxFTElCU0NOOjgxLEVMSUJNQVg6ODIsRUxJQkVYRUM6ODMsRU5PU1lTOjM4LEVOT1RFTVBUWTozOSxFTkFNRVRPT0xPTkc6MzYsRUxPT1A6NDAsRU9QTk9UU1VQUDo5NSxFUEZOT1NVUFBPUlQ6OTYsRUNPTk5SRVNFVDoxMDQsRU5PQlVGUzoxMDUsRUFGTk9TVVBQT1JUOjk3LEVQUk9UT1RZUEU6OTEsRU5PVFNPQ0s6ODgsRU5PUFJPVE9PUFQ6OTIsRVNIVVRET1dOOjEwOCxFQ09OTlJFRlVTRUQ6MTExLEVBRERSSU5VU0U6OTgsRUNPTk5BQk9SVEVEOjEwMyxFTkVUVU5SRUFDSDoxMDEsRU5FVERPV046MTAwLEVUSU1FRE9VVDoxMTAsRUhPU1RET1dOOjExMixFSE9TVFVOUkVBQ0g6MTEzLEVJTlBST0dSRVNTOjExNSxFQUxSRUFEWToxMTQsRURFU1RBRERSUkVROjg5LEVNU0dTSVpFOjkwLEVQUk9UT05PU1VQUE9SVDo5MyxFU09DS1ROT1NVUFBPUlQ6OTQsRUFERFJOT1RBVkFJTDo5OSxFTkVUUkVTRVQ6MTAyLEVJU0NPTk46MTA2LEVOT1RDT05OOjEwNyxFVE9PTUFOWVJFRlM6MTA5LEVVU0VSUzo4NyxFRFFVT1Q6MTIyLEVTVEFMRToxMTYsRU5PVFNVUDo5NSxFTk9NRURJVU06MTIzLEVJTFNFUTo4NCxFT1ZFUkZMT1c6NzUsRUNBTkNFTEVEOjEyNSxFTk9UUkVDT1ZFUkFCTEU6MTMxLEVPV05FUkRFQUQ6MTMwLEVTVFJQSVBFOjg2fTtmdW5jdGlvbiBfX19zZXRFcnJObyh2YWx1ZSl7aWYoTW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl0pSEVBUDMyW01vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdKCk+PjJdPXZhbHVlO3JldHVybiB2YWx1ZX1mdW5jdGlvbiBfX19tYXBfZmlsZShwYXRobmFtZSxzaXplKXtfX19zZXRFcnJObyhFUlJOT19DT0RFUy5FUEVSTSk7cmV0dXJuLTF9dmFyIEVSUk5PX01FU1NBR0VTPXswOlwiU3VjY2Vzc1wiLDE6XCJOb3Qgc3VwZXItdXNlclwiLDI6XCJObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIsMzpcIk5vIHN1Y2ggcHJvY2Vzc1wiLDQ6XCJJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbFwiLDU6XCJJL08gZXJyb3JcIiw2OlwiTm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzc1wiLDc6XCJBcmcgbGlzdCB0b28gbG9uZ1wiLDg6XCJFeGVjIGZvcm1hdCBlcnJvclwiLDk6XCJCYWQgZmlsZSBudW1iZXJcIiwxMDpcIk5vIGNoaWxkcmVuXCIsMTE6XCJObyBtb3JlIHByb2Nlc3Nlc1wiLDEyOlwiTm90IGVub3VnaCBjb3JlXCIsMTM6XCJQZXJtaXNzaW9uIGRlbmllZFwiLDE0OlwiQmFkIGFkZHJlc3NcIiwxNTpcIkJsb2NrIGRldmljZSByZXF1aXJlZFwiLDE2OlwiTW91bnQgZGV2aWNlIGJ1c3lcIiwxNzpcIkZpbGUgZXhpc3RzXCIsMTg6XCJDcm9zcy1kZXZpY2UgbGlua1wiLDE5OlwiTm8gc3VjaCBkZXZpY2VcIiwyMDpcIk5vdCBhIGRpcmVjdG9yeVwiLDIxOlwiSXMgYSBkaXJlY3RvcnlcIiwyMjpcIkludmFsaWQgYXJndW1lbnRcIiwyMzpcIlRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtXCIsMjQ6XCJUb28gbWFueSBvcGVuIGZpbGVzXCIsMjU6XCJOb3QgYSB0eXBld3JpdGVyXCIsMjY6XCJUZXh0IGZpbGUgYnVzeVwiLDI3OlwiRmlsZSB0b28gbGFyZ2VcIiwyODpcIk5vIHNwYWNlIGxlZnQgb24gZGV2aWNlXCIsMjk6XCJJbGxlZ2FsIHNlZWtcIiwzMDpcIlJlYWQgb25seSBmaWxlIHN5c3RlbVwiLDMxOlwiVG9vIG1hbnkgbGlua3NcIiwzMjpcIkJyb2tlbiBwaXBlXCIsMzM6XCJNYXRoIGFyZyBvdXQgb2YgZG9tYWluIG9mIGZ1bmNcIiwzNDpcIk1hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlXCIsMzU6XCJGaWxlIGxvY2tpbmcgZGVhZGxvY2sgZXJyb3JcIiwzNjpcIkZpbGUgb3IgcGF0aCBuYW1lIHRvbyBsb25nXCIsMzc6XCJObyByZWNvcmQgbG9ja3MgYXZhaWxhYmxlXCIsMzg6XCJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWRcIiwzOTpcIkRpcmVjdG9yeSBub3QgZW1wdHlcIiw0MDpcIlRvbyBtYW55IHN5bWJvbGljIGxpbmtzXCIsNDI6XCJObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZVwiLDQzOlwiSWRlbnRpZmllciByZW1vdmVkXCIsNDQ6XCJDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2VcIiw0NTpcIkxldmVsIDIgbm90IHN5bmNocm9uaXplZFwiLDQ2OlwiTGV2ZWwgMyBoYWx0ZWRcIiw0NzpcIkxldmVsIDMgcmVzZXRcIiw0ODpcIkxpbmsgbnVtYmVyIG91dCBvZiByYW5nZVwiLDQ5OlwiUHJvdG9jb2wgZHJpdmVyIG5vdCBhdHRhY2hlZFwiLDUwOlwiTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGVcIiw1MTpcIkxldmVsIDIgaGFsdGVkXCIsNTI6XCJJbnZhbGlkIGV4Y2hhbmdlXCIsNTM6XCJJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvclwiLDU0OlwiRXhjaGFuZ2UgZnVsbFwiLDU1OlwiTm8gYW5vZGVcIiw1NjpcIkludmFsaWQgcmVxdWVzdCBjb2RlXCIsNTc6XCJJbnZhbGlkIHNsb3RcIiw1OTpcIkJhZCBmb250IGZpbGUgZm10XCIsNjA6XCJEZXZpY2Ugbm90IGEgc3RyZWFtXCIsNjE6XCJObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pXCIsNjI6XCJUaW1lciBleHBpcmVkXCIsNjM6XCJPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXNcIiw2NDpcIk1hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrXCIsNjU6XCJQYWNrYWdlIG5vdCBpbnN0YWxsZWRcIiw2NjpcIlRoZSBvYmplY3QgaXMgcmVtb3RlXCIsNjc6XCJUaGUgbGluayBoYXMgYmVlbiBzZXZlcmVkXCIsNjg6XCJBZHZlcnRpc2UgZXJyb3JcIiw2OTpcIlNybW91bnQgZXJyb3JcIiw3MDpcIkNvbW11bmljYXRpb24gZXJyb3Igb24gc2VuZFwiLDcxOlwiUHJvdG9jb2wgZXJyb3JcIiw3MjpcIk11bHRpaG9wIGF0dGVtcHRlZFwiLDczOlwiQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpXCIsNzQ6XCJUcnlpbmcgdG8gcmVhZCB1bnJlYWRhYmxlIG1lc3NhZ2VcIiw3NTpcIlZhbHVlIHRvbyBsYXJnZSBmb3IgZGVmaW5lZCBkYXRhIHR5cGVcIiw3NjpcIkdpdmVuIGxvZy4gbmFtZSBub3QgdW5pcXVlXCIsNzc6XCJmLmQuIGludmFsaWQgZm9yIHRoaXMgb3BlcmF0aW9uXCIsNzg6XCJSZW1vdGUgYWRkcmVzcyBjaGFuZ2VkXCIsNzk6XCJDYW4gICBhY2Nlc3MgYSBuZWVkZWQgc2hhcmVkIGxpYlwiLDgwOlwiQWNjZXNzaW5nIGEgY29ycnVwdGVkIHNoYXJlZCBsaWJcIiw4MTpcIi5saWIgc2VjdGlvbiBpbiBhLm91dCBjb3JydXB0ZWRcIiw4MjpcIkF0dGVtcHRpbmcgdG8gbGluayBpbiB0b28gbWFueSBsaWJzXCIsODM6XCJBdHRlbXB0aW5nIHRvIGV4ZWMgYSBzaGFyZWQgbGlicmFyeVwiLDg0OlwiSWxsZWdhbCBieXRlIHNlcXVlbmNlXCIsODY6XCJTdHJlYW1zIHBpcGUgZXJyb3JcIiw4NzpcIlRvbyBtYW55IHVzZXJzXCIsODg6XCJTb2NrZXQgb3BlcmF0aW9uIG9uIG5vbi1zb2NrZXRcIiw4OTpcIkRlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWRcIiw5MDpcIk1lc3NhZ2UgdG9vIGxvbmdcIiw5MTpcIlByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldFwiLDkyOlwiUHJvdG9jb2wgbm90IGF2YWlsYWJsZVwiLDkzOlwiVW5rbm93biBwcm90b2NvbFwiLDk0OlwiU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZFwiLDk1OlwiTm90IHN1cHBvcnRlZFwiLDk2OlwiUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWRcIiw5NzpcIkFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wgZmFtaWx5XCIsOTg6XCJBZGRyZXNzIGFscmVhZHkgaW4gdXNlXCIsOTk6XCJBZGRyZXNzIG5vdCBhdmFpbGFibGVcIiwxMDA6XCJOZXR3b3JrIGludGVyZmFjZSBpcyBub3QgY29uZmlndXJlZFwiLDEwMTpcIk5ldHdvcmsgaXMgdW5yZWFjaGFibGVcIiwxMDI6XCJDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmtcIiwxMDM6XCJDb25uZWN0aW9uIGFib3J0ZWRcIiwxMDQ6XCJDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXJcIiwxMDU6XCJObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlXCIsMTA2OlwiU29ja2V0IGlzIGFscmVhZHkgY29ubmVjdGVkXCIsMTA3OlwiU29ja2V0IGlzIG5vdCBjb25uZWN0ZWRcIiwxMDg6XCJDYW4ndCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93blwiLDEwOTpcIlRvbyBtYW55IHJlZmVyZW5jZXNcIiwxMTA6XCJDb25uZWN0aW9uIHRpbWVkIG91dFwiLDExMTpcIkNvbm5lY3Rpb24gcmVmdXNlZFwiLDExMjpcIkhvc3QgaXMgZG93blwiLDExMzpcIkhvc3QgaXMgdW5yZWFjaGFibGVcIiwxMTQ6XCJTb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWRcIiwxMTU6XCJDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiwxMTY6XCJTdGFsZSBmaWxlIGhhbmRsZVwiLDEyMjpcIlF1b3RhIGV4Y2VlZGVkXCIsMTIzOlwiTm8gbWVkaXVtIChpbiB0YXBlIGRyaXZlKVwiLDEyNTpcIk9wZXJhdGlvbiBjYW5jZWxlZFwiLDEzMDpcIlByZXZpb3VzIG93bmVyIGRpZWRcIiwxMzE6XCJTdGF0ZSBub3QgcmVjb3ZlcmFibGVcIn07dmFyIFBBVEg9e3NwbGl0UGF0aDooZnVuY3Rpb24oZmlsZW5hbWUpe3ZhciBzcGxpdFBhdGhSZT0vXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztyZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSl9KSxub3JtYWxpemVBcnJheTooZnVuY3Rpb24ocGFydHMsYWxsb3dBYm92ZVJvb3Qpe3ZhciB1cD0wO2Zvcih2YXIgaT1wYXJ0cy5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIGxhc3Q9cGFydHNbaV07aWYobGFzdD09PVwiLlwiKXtwYXJ0cy5zcGxpY2UoaSwxKX1lbHNlIGlmKGxhc3Q9PT1cIi4uXCIpe3BhcnRzLnNwbGljZShpLDEpO3VwKyt9ZWxzZSBpZih1cCl7cGFydHMuc3BsaWNlKGksMSk7dXAtLX19aWYoYWxsb3dBYm92ZVJvb3Qpe2Zvcig7dXA7dXAtLSl7cGFydHMudW5zaGlmdChcIi4uXCIpfX1yZXR1cm4gcGFydHN9KSxub3JtYWxpemU6KGZ1bmN0aW9uKHBhdGgpe3ZhciBpc0Fic29sdXRlPXBhdGguY2hhckF0KDApPT09XCIvXCIsdHJhaWxpbmdTbGFzaD1wYXRoLnN1YnN0cigtMSk9PT1cIi9cIjtwYXRoPVBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKChmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSksIWlzQWJzb2x1dGUpLmpvaW4oXCIvXCIpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD1cIi5cIn1pZihwYXRoJiZ0cmFpbGluZ1NsYXNoKXtwYXRoKz1cIi9cIn1yZXR1cm4oaXNBYnNvbHV0ZT9cIi9cIjpcIlwiKStwYXRofSksZGlybmFtZTooZnVuY3Rpb24ocGF0aCl7dmFyIHJlc3VsdD1QQVRILnNwbGl0UGF0aChwYXRoKSxyb290PXJlc3VsdFswXSxkaXI9cmVzdWx0WzFdO2lmKCFyb290JiYhZGlyKXtyZXR1cm5cIi5cIn1pZihkaXIpe2Rpcj1kaXIuc3Vic3RyKDAsZGlyLmxlbmd0aC0xKX1yZXR1cm4gcm9vdCtkaXJ9KSxiYXNlbmFtZTooZnVuY3Rpb24ocGF0aCl7aWYocGF0aD09PVwiL1wiKXJldHVyblwiL1wiO3ZhciBsYXN0U2xhc2g9cGF0aC5sYXN0SW5kZXhPZihcIi9cIik7aWYobGFzdFNsYXNoPT09LTEpcmV0dXJuIHBhdGg7cmV0dXJuIHBhdGguc3Vic3RyKGxhc3RTbGFzaCsxKX0pLGV4dG5hbWU6KGZ1bmN0aW9uKHBhdGgpe3JldHVybiBQQVRILnNwbGl0UGF0aChwYXRoKVszXX0pLGpvaW46KGZ1bmN0aW9uKCl7dmFyIHBhdGhzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtyZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbihcIi9cIikpfSksam9pbjI6KGZ1bmN0aW9uKGwscil7cmV0dXJuIFBBVEgubm9ybWFsaXplKGwrXCIvXCIrcil9KSxyZXNvbHZlOihmdW5jdGlvbigpe3ZhciByZXNvbHZlZFBhdGg9XCJcIixyZXNvbHZlZEFic29sdXRlPWZhbHNlO2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFyZXNvbHZlZEFic29sdXRlO2ktLSl7dmFyIHBhdGg9aT49MD9hcmd1bWVudHNbaV06RlMuY3dkKCk7aWYodHlwZW9mIHBhdGghPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcIil9ZWxzZSBpZighcGF0aCl7cmV0dXJuXCJcIn1yZXNvbHZlZFBhdGg9cGF0aCtcIi9cIityZXNvbHZlZFBhdGg7cmVzb2x2ZWRBYnNvbHV0ZT1wYXRoLmNoYXJBdCgwKT09PVwiL1wifXJlc29sdmVkUGF0aD1QQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKChmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSksIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oXCIvXCIpO3JldHVybihyZXNvbHZlZEFic29sdXRlP1wiL1wiOlwiXCIpK3Jlc29sdmVkUGF0aHx8XCIuXCJ9KSxyZWxhdGl2ZTooZnVuY3Rpb24oZnJvbSx0byl7ZnJvbT1QQVRILnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO3RvPVBBVEgucmVzb2x2ZSh0bykuc3Vic3RyKDEpO2Z1bmN0aW9uIHRyaW0oYXJyKXt2YXIgc3RhcnQ9MDtmb3IoO3N0YXJ0PGFyci5sZW5ndGg7c3RhcnQrKyl7aWYoYXJyW3N0YXJ0XSE9PVwiXCIpYnJlYWt9dmFyIGVuZD1hcnIubGVuZ3RoLTE7Zm9yKDtlbmQ+PTA7ZW5kLS0pe2lmKGFycltlbmRdIT09XCJcIilicmVha31pZihzdGFydD5lbmQpcmV0dXJuW107cmV0dXJuIGFyci5zbGljZShzdGFydCxlbmQtc3RhcnQrMSl9dmFyIGZyb21QYXJ0cz10cmltKGZyb20uc3BsaXQoXCIvXCIpKTt2YXIgdG9QYXJ0cz10cmltKHRvLnNwbGl0KFwiL1wiKSk7dmFyIGxlbmd0aD1NYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLHRvUGFydHMubGVuZ3RoKTt2YXIgc2FtZVBhcnRzTGVuZ3RoPWxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe2lmKGZyb21QYXJ0c1tpXSE9PXRvUGFydHNbaV0pe3NhbWVQYXJ0c0xlbmd0aD1pO2JyZWFrfX12YXIgb3V0cHV0UGFydHM9W107Zm9yKHZhciBpPXNhbWVQYXJ0c0xlbmd0aDtpPGZyb21QYXJ0cy5sZW5ndGg7aSsrKXtvdXRwdXRQYXJ0cy5wdXNoKFwiLi5cIil9b3V0cHV0UGFydHM9b3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7cmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oXCIvXCIpfSl9O3ZhciBUVFk9e3R0eXM6W10saW5pdDooZnVuY3Rpb24oKXt9KSxzaHV0ZG93bjooZnVuY3Rpb24oKXt9KSxyZWdpc3RlcjooZnVuY3Rpb24oZGV2LG9wcyl7VFRZLnR0eXNbZGV2XT17aW5wdXQ6W10sb3V0cHV0OltdLG9wczpvcHN9O0ZTLnJlZ2lzdGVyRGV2aWNlKGRldixUVFkuc3RyZWFtX29wcyl9KSxzdHJlYW1fb3BzOntvcGVuOihmdW5jdGlvbihzdHJlYW0pe3ZhciB0dHk9VFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07aWYoIXR0eSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKX1zdHJlYW0udHR5PXR0eTtzdHJlYW0uc2Vla2FibGU9ZmFsc2V9KSxjbG9zZTooZnVuY3Rpb24oc3RyZWFtKXtzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KX0pLGZsdXNoOihmdW5jdGlvbihzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpfSkscmVhZDooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7aWYoIXN0cmVhbS50dHl8fCFzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5YSU8pfXZhciBieXRlc1JlYWQ9MDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciByZXN1bHQ7dHJ5e3Jlc3VsdD1zdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfWlmKHJlc3VsdD09PXVuZGVmaW5lZCYmYnl0ZXNSZWFkPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUFHQUlOKX1pZihyZXN1bHQ9PT1udWxsfHxyZXN1bHQ9PT11bmRlZmluZWQpYnJlYWs7Ynl0ZXNSZWFkKys7YnVmZmVyW29mZnNldCtpXT1yZXN1bHR9aWYoYnl0ZXNSZWFkKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKX1yZXR1cm4gYnl0ZXNSZWFkfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe2lmKCFzdHJlYW0udHR5fHwhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOWElPKX1mb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3RyeXtzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LGJ1ZmZlcltvZmZzZXQraV0pfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9fWlmKGxlbmd0aCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGl9KX0sZGVmYXVsdF90dHlfb3BzOntnZXRfY2hhcjooZnVuY3Rpb24odHR5KXtpZighdHR5LmlucHV0Lmxlbmd0aCl7dmFyIHJlc3VsdD1udWxsO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBCVUZTSVpFPTI1Njt2YXIgYnVmPW5ldyBCdWZmZXIoQlVGU0laRSk7dmFyIGJ5dGVzUmVhZD0wO3ZhciBpc1Bvc2l4UGxhdGZvcm09cHJvY2Vzcy5wbGF0Zm9ybSE9XCJ3aW4zMlwiO3ZhciBmZD1wcm9jZXNzLnN0ZGluLmZkO2lmKGlzUG9zaXhQbGF0Zm9ybSl7dmFyIHVzaW5nRGV2aWNlPWZhbHNlO3RyeXtmZD1mcy5vcGVuU3luYyhcIi9kZXYvc3RkaW5cIixcInJcIik7dXNpbmdEZXZpY2U9dHJ1ZX1jYXRjaChlKXt9fXRyeXtieXRlc1JlYWQ9ZnMucmVhZFN5bmMoZmQsYnVmLDAsQlVGU0laRSxudWxsKX1jYXRjaChlKXtpZihlLnRvU3RyaW5nKCkuaW5kZXhPZihcIkVPRlwiKSE9LTEpYnl0ZXNSZWFkPTA7ZWxzZSB0aHJvdyBlfWlmKHVzaW5nRGV2aWNlKXtmcy5jbG9zZVN5bmMoZmQpfWlmKGJ5dGVzUmVhZD4wKXtyZXN1bHQ9YnVmLnNsaWNlKDAsYnl0ZXNSZWFkKS50b1N0cmluZyhcInV0Zi04XCIpfWVsc2V7cmVzdWx0PW51bGx9fWVsc2UgaWYodHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHdpbmRvdy5wcm9tcHQ9PVwiZnVuY3Rpb25cIil7cmVzdWx0PXdpbmRvdy5wcm9tcHQoXCJJbnB1dDogXCIpO2lmKHJlc3VsdCE9PW51bGwpe3Jlc3VsdCs9XCJcXG5cIn19ZWxzZSBpZih0eXBlb2YgcmVhZGxpbmU9PVwiZnVuY3Rpb25cIil7cmVzdWx0PXJlYWRsaW5lKCk7aWYocmVzdWx0IT09bnVsbCl7cmVzdWx0Kz1cIlxcblwifX1pZighcmVzdWx0KXtyZXR1cm4gbnVsbH10dHkuaW5wdXQ9aW50QXJyYXlGcm9tU3RyaW5nKHJlc3VsdCx0cnVlKX1yZXR1cm4gdHR5LmlucHV0LnNoaWZ0KCl9KSxwdXRfY2hhcjooZnVuY3Rpb24odHR5LHZhbCl7aWYodmFsPT09bnVsbHx8dmFsPT09MTApe01vZHVsZVtcInByaW50XCJdKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119ZWxzZXtpZih2YWwhPTApdHR5Lm91dHB1dC5wdXNoKHZhbCl9fSksZmx1c2g6KGZ1bmN0aW9uKHR0eSl7aWYodHR5Lm91dHB1dCYmdHR5Lm91dHB1dC5sZW5ndGg+MCl7TW9kdWxlW1wicHJpbnRcIl0oVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXX19KX0sZGVmYXVsdF90dHkxX29wczp7cHV0X2NoYXI6KGZ1bmN0aW9uKHR0eSx2YWwpe2lmKHZhbD09PW51bGx8fHZhbD09PTEwKXtNb2R1bGVbXCJwcmludEVyclwiXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LDApKTt0dHkub3V0cHV0PVtdfWVsc2V7aWYodmFsIT0wKXR0eS5vdXRwdXQucHVzaCh2YWwpfX0pLGZsdXNoOihmdW5jdGlvbih0dHkpe2lmKHR0eS5vdXRwdXQmJnR0eS5vdXRwdXQubGVuZ3RoPjApe01vZHVsZVtcInByaW50RXJyXCJdKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119fSl9fTt2YXIgTUVNRlM9e29wc190YWJsZTpudWxsLG1vdW50OihmdW5jdGlvbihtb3VudCl7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCxcIi9cIiwxNjM4NHw1MTEsMCl9KSxjcmVhdGVOb2RlOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7aWYoRlMuaXNCbGtkZXYobW9kZSl8fEZTLmlzRklGTyhtb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfWlmKCFNRU1GUy5vcHNfdGFibGUpe01FTUZTLm9wc190YWJsZT17ZGlyOntub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyLGxvb2t1cDpNRU1GUy5ub2RlX29wcy5sb29rdXAsbWtub2Q6TUVNRlMubm9kZV9vcHMubWtub2QscmVuYW1lOk1FTUZTLm5vZGVfb3BzLnJlbmFtZSx1bmxpbms6TUVNRlMubm9kZV9vcHMudW5saW5rLHJtZGlyOk1FTUZTLm5vZGVfb3BzLnJtZGlyLHJlYWRkaXI6TUVNRlMubm9kZV9vcHMucmVhZGRpcixzeW1saW5rOk1FTUZTLm5vZGVfb3BzLnN5bWxpbmt9LHN0cmVhbTp7bGxzZWVrOk1FTUZTLnN0cmVhbV9vcHMubGxzZWVrfX0sZmlsZTp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cn0sc3RyZWFtOntsbHNlZWs6TUVNRlMuc3RyZWFtX29wcy5sbHNlZWsscmVhZDpNRU1GUy5zdHJlYW1fb3BzLnJlYWQsd3JpdGU6TUVNRlMuc3RyZWFtX29wcy53cml0ZSxhbGxvY2F0ZTpNRU1GUy5zdHJlYW1fb3BzLmFsbG9jYXRlLG1tYXA6TUVNRlMuc3RyZWFtX29wcy5tbWFwLG1zeW5jOk1FTUZTLnN0cmVhbV9vcHMubXN5bmN9fSxsaW5rOntub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyLHJlYWRsaW5rOk1FTUZTLm5vZGVfb3BzLnJlYWRsaW5rfSxzdHJlYW06e319LGNocmRldjp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cn0sc3RyZWFtOkZTLmNocmRldl9zdHJlYW1fb3BzfX19dmFyIG5vZGU9RlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlLGRldik7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuZGlyLm5vZGU7bm9kZS5zdHJlYW1fb3BzPU1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO25vZGUuY29udGVudHM9e319ZWxzZSBpZihGUy5pc0ZpbGUobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07bm9kZS51c2VkQnl0ZXM9MDtub2RlLmNvbnRlbnRzPW51bGx9ZWxzZSBpZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUubGluay5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUubGluay5zdHJlYW19ZWxzZSBpZihGUy5pc0NocmRldihub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmNocmRldi5zdHJlYW19bm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKTtpZihwYXJlbnQpe3BhcmVudC5jb250ZW50c1tuYW1lXT1ub2RlfXJldHVybiBub2RlfSksZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheTooZnVuY3Rpb24obm9kZSl7aWYobm9kZS5jb250ZW50cyYmbm9kZS5jb250ZW50cy5zdWJhcnJheSl7dmFyIGFycj1bXTtmb3IodmFyIGk9MDtpPG5vZGUudXNlZEJ5dGVzOysraSlhcnIucHVzaChub2RlLmNvbnRlbnRzW2ldKTtyZXR1cm4gYXJyfXJldHVybiBub2RlLmNvbnRlbnRzfSksZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6KGZ1bmN0aW9uKG5vZGUpe2lmKCFub2RlLmNvbnRlbnRzKXJldHVybiBuZXcgVWludDhBcnJheTtpZihub2RlLmNvbnRlbnRzLnN1YmFycmF5KXJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsbm9kZS51c2VkQnl0ZXMpO3JldHVybiBuZXcgVWludDhBcnJheShub2RlLmNvbnRlbnRzKX0pLGV4cGFuZEZpbGVTdG9yYWdlOihmdW5jdGlvbihub2RlLG5ld0NhcGFjaXR5KXtpZihub2RlLmNvbnRlbnRzJiZub2RlLmNvbnRlbnRzLnN1YmFycmF5JiZuZXdDYXBhY2l0eT5ub2RlLmNvbnRlbnRzLmxlbmd0aCl7bm9kZS5jb250ZW50cz1NRU1GUy5nZXRGaWxlRGF0YUFzUmVndWxhckFycmF5KG5vZGUpO25vZGUudXNlZEJ5dGVzPW5vZGUuY29udGVudHMubGVuZ3RofWlmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgcHJldkNhcGFjaXR5PW5vZGUuY29udGVudHM/bm9kZS5jb250ZW50cy5sZW5ndGg6MDtpZihwcmV2Q2FwYWNpdHk+PW5ld0NhcGFjaXR5KXJldHVybjt2YXIgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYPTEwMjQqMTAyNDtuZXdDYXBhY2l0eT1NYXRoLm1heChuZXdDYXBhY2l0eSxwcmV2Q2FwYWNpdHkqKHByZXZDYXBhY2l0eTxDQVBBQ0lUWV9ET1VCTElOR19NQVg/MjoxLjEyNSl8MCk7aWYocHJldkNhcGFjaXR5IT0wKW5ld0NhcGFjaXR5PU1hdGgubWF4KG5ld0NhcGFjaXR5LDI1Nik7dmFyIG9sZENvbnRlbnRzPW5vZGUuY29udGVudHM7bm9kZS5jb250ZW50cz1uZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7aWYobm9kZS51c2VkQnl0ZXM+MClub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLG5vZGUudXNlZEJ5dGVzKSwwKTtyZXR1cm59aWYoIW5vZGUuY29udGVudHMmJm5ld0NhcGFjaXR5PjApbm9kZS5jb250ZW50cz1bXTt3aGlsZShub2RlLmNvbnRlbnRzLmxlbmd0aDxuZXdDYXBhY2l0eSlub2RlLmNvbnRlbnRzLnB1c2goMCl9KSxyZXNpemVGaWxlU3RvcmFnZTooZnVuY3Rpb24obm9kZSxuZXdTaXplKXtpZihub2RlLnVzZWRCeXRlcz09bmV3U2l6ZSlyZXR1cm47aWYobmV3U2l6ZT09MCl7bm9kZS5jb250ZW50cz1udWxsO25vZGUudXNlZEJ5dGVzPTA7cmV0dXJufWlmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgb2xkQ29udGVudHM9bm9kZS5jb250ZW50cztub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKSk7aWYob2xkQ29udGVudHMpe25vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsTWF0aC5taW4obmV3U2l6ZSxub2RlLnVzZWRCeXRlcykpKX1ub2RlLnVzZWRCeXRlcz1uZXdTaXplO3JldHVybn1pZighbm9kZS5jb250ZW50cylub2RlLmNvbnRlbnRzPVtdO2lmKG5vZGUuY29udGVudHMubGVuZ3RoPm5ld1NpemUpbm9kZS5jb250ZW50cy5sZW5ndGg9bmV3U2l6ZTtlbHNlIHdoaWxlKG5vZGUuY29udGVudHMubGVuZ3RoPG5ld1NpemUpbm9kZS5jb250ZW50cy5wdXNoKDApO25vZGUudXNlZEJ5dGVzPW5ld1NpemV9KSxub2RlX29wczp7Z2V0YXR0cjooZnVuY3Rpb24obm9kZSl7dmFyIGF0dHI9e307YXR0ci5kZXY9RlMuaXNDaHJkZXYobm9kZS5tb2RlKT9ub2RlLmlkOjE7YXR0ci5pbm89bm9kZS5pZDthdHRyLm1vZGU9bm9kZS5tb2RlO2F0dHIubmxpbms9MTthdHRyLnVpZD0wO2F0dHIuZ2lkPTA7YXR0ci5yZGV2PW5vZGUucmRldjtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXthdHRyLnNpemU9NDA5Nn1lbHNlIGlmKEZTLmlzRmlsZShub2RlLm1vZGUpKXthdHRyLnNpemU9bm9kZS51c2VkQnl0ZXN9ZWxzZSBpZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7YXR0ci5zaXplPW5vZGUubGluay5sZW5ndGh9ZWxzZXthdHRyLnNpemU9MH1hdHRyLmF0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLm10aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmN0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmJsa3NpemU9NDA5NjthdHRyLmJsb2Nrcz1NYXRoLmNlaWwoYXR0ci5zaXplL2F0dHIuYmxrc2l6ZSk7cmV0dXJuIGF0dHJ9KSxzZXRhdHRyOihmdW5jdGlvbihub2RlLGF0dHIpe2lmKGF0dHIubW9kZSE9PXVuZGVmaW5lZCl7bm9kZS5tb2RlPWF0dHIubW9kZX1pZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7bm9kZS50aW1lc3RhbXA9YXR0ci50aW1lc3RhbXB9aWYoYXR0ci5zaXplIT09dW5kZWZpbmVkKXtNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLGF0dHIuc2l6ZSl9fSksbG9va3VwOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1tFUlJOT19DT0RFUy5FTk9FTlRdfSksbWtub2Q6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2KXtyZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlLGRldil9KSxyZW5hbWU6KGZ1bmN0aW9uKG9sZF9ub2RlLG5ld19kaXIsbmV3X25hbWUpe2lmKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKXt2YXIgbmV3X25vZGU7dHJ5e25ld19ub2RlPUZTLmxvb2t1cE5vZGUobmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7fWlmKG5ld19ub2RlKXtmb3IodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSl9fX1kZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdO29sZF9ub2RlLm5hbWU9bmV3X25hbWU7bmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV09b2xkX25vZGU7b2xkX25vZGUucGFyZW50PW5ld19kaXJ9KSx1bmxpbms6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXtkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdfSkscm1kaXI6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTtmb3IodmFyIGkgaW4gbm9kZS5jb250ZW50cyl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVEVNUFRZKX1kZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdfSkscmVhZGRpcjooZnVuY3Rpb24obm9kZSl7dmFyIGVudHJpZXM9W1wiLlwiLFwiLi5cIl07Zm9yKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cyl7aWYoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSl7Y29udGludWV9ZW50cmllcy5wdXNoKGtleSl9cmV0dXJuIGVudHJpZXN9KSxzeW1saW5rOihmdW5jdGlvbihwYXJlbnQsbmV3bmFtZSxvbGRwYXRoKXt2YXIgbm9kZT1NRU1GUy5jcmVhdGVOb2RlKHBhcmVudCxuZXduYW1lLDUxMXw0MDk2MCwwKTtub2RlLmxpbms9b2xkcGF0aDtyZXR1cm4gbm9kZX0pLHJlYWRsaW5rOihmdW5jdGlvbihub2RlKXtpZighRlMuaXNMaW5rKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9cmV0dXJuIG5vZGUubGlua30pfSxzdHJlYW1fb3BzOntyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe3ZhciBjb250ZW50cz1zdHJlYW0ubm9kZS5jb250ZW50cztpZihwb3NpdGlvbj49c3RyZWFtLm5vZGUudXNlZEJ5dGVzKXJldHVybiAwO3ZhciBzaXplPU1hdGgubWluKHN0cmVhbS5ub2RlLnVzZWRCeXRlcy1wb3NpdGlvbixsZW5ndGgpO2Fzc2VydChzaXplPj0wKTtpZihzaXplPjgmJmNvbnRlbnRzLnN1YmFycmF5KXtidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLHBvc2l0aW9uK3NpemUpLG9mZnNldCl9ZWxzZXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKWJ1ZmZlcltvZmZzZXQraV09Y29udGVudHNbcG9zaXRpb24raV19cmV0dXJuIHNpemV9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uLGNhbk93bil7aWYoIWxlbmd0aClyZXR1cm4gMDt2YXIgbm9kZT1zdHJlYW0ubm9kZTtub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpO2lmKGJ1ZmZlci5zdWJhcnJheSYmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KSl7aWYoY2FuT3duKXtub2RlLmNvbnRlbnRzPWJ1ZmZlci5zdWJhcnJheShvZmZzZXQsb2Zmc2V0K2xlbmd0aCk7bm9kZS51c2VkQnl0ZXM9bGVuZ3RoO3JldHVybiBsZW5ndGh9ZWxzZSBpZihub2RlLnVzZWRCeXRlcz09PTAmJnBvc2l0aW9uPT09MCl7bm9kZS5jb250ZW50cz1uZXcgVWludDhBcnJheShidWZmZXIuc3ViYXJyYXkob2Zmc2V0LG9mZnNldCtsZW5ndGgpKTtub2RlLnVzZWRCeXRlcz1sZW5ndGg7cmV0dXJuIGxlbmd0aH1lbHNlIGlmKHBvc2l0aW9uK2xlbmd0aDw9bm9kZS51c2VkQnl0ZXMpe25vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsb2Zmc2V0K2xlbmd0aCkscG9zaXRpb24pO3JldHVybiBsZW5ndGh9fU1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKG5vZGUscG9zaXRpb24rbGVuZ3RoKTtpZihub2RlLmNvbnRlbnRzLnN1YmFycmF5JiZidWZmZXIuc3ViYXJyYXkpbm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbik7ZWxzZXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe25vZGUuY29udGVudHNbcG9zaXRpb24raV09YnVmZmVyW29mZnNldCtpXX19bm9kZS51c2VkQnl0ZXM9TWF0aC5tYXgobm9kZS51c2VkQnl0ZXMscG9zaXRpb24rbGVuZ3RoKTtyZXR1cm4gbGVuZ3RofSksbGxzZWVrOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7dmFyIHBvc2l0aW9uPW9mZnNldDtpZih3aGVuY2U9PT0xKXtwb3NpdGlvbis9c3RyZWFtLnBvc2l0aW9ufWVsc2UgaWYod2hlbmNlPT09Mil7aWYoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXtwb3NpdGlvbis9c3RyZWFtLm5vZGUudXNlZEJ5dGVzfX1pZihwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfXJldHVybiBwb3NpdGlvbn0pLGFsbG9jYXRlOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsb2Zmc2V0K2xlbmd0aCk7c3RyZWFtLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxvZmZzZXQrbGVuZ3RoKX0pLG1tYXA6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfXZhciBwdHI7dmFyIGFsbG9jYXRlZDt2YXIgY29udGVudHM9c3RyZWFtLm5vZGUuY29udGVudHM7aWYoIShmbGFncyYyKSYmKGNvbnRlbnRzLmJ1ZmZlcj09PWJ1ZmZlcnx8Y29udGVudHMuYnVmZmVyPT09YnVmZmVyLmJ1ZmZlcikpe2FsbG9jYXRlZD1mYWxzZTtwdHI9Y29udGVudHMuYnl0ZU9mZnNldH1lbHNle2lmKHBvc2l0aW9uPjB8fHBvc2l0aW9uK2xlbmd0aDxzdHJlYW0ubm9kZS51c2VkQnl0ZXMpe2lmKGNvbnRlbnRzLnN1YmFycmF5KXtjb250ZW50cz1jb250ZW50cy5zdWJhcnJheShwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpfWVsc2V7Y29udGVudHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMscG9zaXRpb24scG9zaXRpb24rbGVuZ3RoKX19YWxsb2NhdGVkPXRydWU7cHRyPV9tYWxsb2MobGVuZ3RoKTtpZighcHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9NRU0pfWJ1ZmZlci5zZXQoY29udGVudHMscHRyKX1yZXR1cm57cHRyOnB0cixhbGxvY2F0ZWQ6YWxsb2NhdGVkfX0pLG1zeW5jOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgsbW1hcEZsYWdzKXtpZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfWlmKG1tYXBGbGFncyYyKXtyZXR1cm4gMH12YXIgYnl0ZXNXcml0dGVuPU1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLGJ1ZmZlciwwLGxlbmd0aCxvZmZzZXQsZmFsc2UpO3JldHVybiAwfSl9fTt2YXIgSURCRlM9e2Riczp7fSxpbmRleGVkREI6KGZ1bmN0aW9uKCl7aWYodHlwZW9mIGluZGV4ZWREQiE9PVwidW5kZWZpbmVkXCIpcmV0dXJuIGluZGV4ZWREQjt2YXIgcmV0PW51bGw7aWYodHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCIpcmV0PXdpbmRvdy5pbmRleGVkREJ8fHdpbmRvdy5tb3pJbmRleGVkREJ8fHdpbmRvdy53ZWJraXRJbmRleGVkREJ8fHdpbmRvdy5tc0luZGV4ZWREQjthc3NlcnQocmV0LFwiSURCRlMgdXNlZCwgYnV0IGluZGV4ZWREQiBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiByZXR9KSxEQl9WRVJTSU9OOjIxLERCX1NUT1JFX05BTUU6XCJGSUxFX0RBVEFcIixtb3VudDooZnVuY3Rpb24obW91bnQpe3JldHVybiBNRU1GUy5tb3VudC5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxzeW5jZnM6KGZ1bmN0aW9uKG1vdW50LHBvcHVsYXRlLGNhbGxiYWNrKXtJREJGUy5nZXRMb2NhbFNldChtb3VudCwoZnVuY3Rpb24oZXJyLGxvY2FsKXtpZihlcnIpcmV0dXJuIGNhbGxiYWNrKGVycik7SURCRlMuZ2V0UmVtb3RlU2V0KG1vdW50LChmdW5jdGlvbihlcnIscmVtb3RlKXtpZihlcnIpcmV0dXJuIGNhbGxiYWNrKGVycik7dmFyIHNyYz1wb3B1bGF0ZT9yZW1vdGU6bG9jYWw7dmFyIGRzdD1wb3B1bGF0ZT9sb2NhbDpyZW1vdGU7SURCRlMucmVjb25jaWxlKHNyYyxkc3QsY2FsbGJhY2spfSkpfSkpfSksZ2V0REI6KGZ1bmN0aW9uKG5hbWUsY2FsbGJhY2spe3ZhciBkYj1JREJGUy5kYnNbbmFtZV07aWYoZGIpe3JldHVybiBjYWxsYmFjayhudWxsLGRiKX12YXIgcmVxO3RyeXtyZXE9SURCRlMuaW5kZXhlZERCKCkub3BlbihuYW1lLElEQkZTLkRCX1ZFUlNJT04pfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1pZighcmVxKXtyZXR1cm4gY2FsbGJhY2soXCJVbmFibGUgdG8gY29ubmVjdCB0byBJbmRleGVkREJcIil9cmVxLm9udXBncmFkZW5lZWRlZD0oZnVuY3Rpb24oZSl7dmFyIGRiPWUudGFyZ2V0LnJlc3VsdDt2YXIgdHJhbnNhY3Rpb249ZS50YXJnZXQudHJhbnNhY3Rpb247dmFyIGZpbGVTdG9yZTtpZihkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKElEQkZTLkRCX1NUT1JFX05BTUUpKXtmaWxlU3RvcmU9dHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSl9ZWxzZXtmaWxlU3RvcmU9ZGIuY3JlYXRlT2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSl9aWYoIWZpbGVTdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKFwidGltZXN0YW1wXCIpKXtmaWxlU3RvcmUuY3JlYXRlSW5kZXgoXCJ0aW1lc3RhbXBcIixcInRpbWVzdGFtcFwiLHt1bmlxdWU6ZmFsc2V9KX19KTtyZXEub25zdWNjZXNzPShmdW5jdGlvbigpe2RiPXJlcS5yZXN1bHQ7SURCRlMuZGJzW25hbWVdPWRiO2NhbGxiYWNrKG51bGwsZGIpfSk7cmVxLm9uZXJyb3I9KGZ1bmN0aW9uKGUpe2NhbGxiYWNrKHRoaXMuZXJyb3IpO2UucHJldmVudERlZmF1bHQoKX0pfSksZ2V0TG9jYWxTZXQ6KGZ1bmN0aW9uKG1vdW50LGNhbGxiYWNrKXt2YXIgZW50cmllcz17fTtmdW5jdGlvbiBpc1JlYWxEaXIocCl7cmV0dXJuIHAhPT1cIi5cIiYmcCE9PVwiLi5cIn1mdW5jdGlvbiB0b0Fic29sdXRlKHJvb3Qpe3JldHVybihmdW5jdGlvbihwKXtyZXR1cm4gUEFUSC5qb2luMihyb290LHApfSl9dmFyIGNoZWNrPUZTLnJlYWRkaXIobW91bnQubW91bnRwb2ludCkuZmlsdGVyKGlzUmVhbERpcikubWFwKHRvQWJzb2x1dGUobW91bnQubW91bnRwb2ludCkpO3doaWxlKGNoZWNrLmxlbmd0aCl7dmFyIHBhdGg9Y2hlY2sucG9wKCk7dmFyIHN0YXQ7dHJ5e3N0YXQ9RlMuc3RhdChwYXRoKX1jYXRjaChlKXtyZXR1cm4gY2FsbGJhY2soZSl9aWYoRlMuaXNEaXIoc3RhdC5tb2RlKSl7Y2hlY2sucHVzaC5hcHBseShjaGVjayxGUy5yZWFkZGlyKHBhdGgpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKHBhdGgpKSl9ZW50cmllc1twYXRoXT17dGltZXN0YW1wOnN0YXQubXRpbWV9fXJldHVybiBjYWxsYmFjayhudWxsLHt0eXBlOlwibG9jYWxcIixlbnRyaWVzOmVudHJpZXN9KX0pLGdldFJlbW90ZVNldDooZnVuY3Rpb24obW91bnQsY2FsbGJhY2spe3ZhciBlbnRyaWVzPXt9O0lEQkZTLmdldERCKG1vdW50Lm1vdW50cG9pbnQsKGZ1bmN0aW9uKGVycixkYil7aWYoZXJyKXJldHVybiBjYWxsYmFjayhlcnIpO3RyeXt2YXIgdHJhbnNhY3Rpb249ZGIudHJhbnNhY3Rpb24oW0lEQkZTLkRCX1NUT1JFX05BTUVdLFwicmVhZG9ubHlcIik7dHJhbnNhY3Rpb24ub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpfSk7dmFyIHN0b3JlPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpO3ZhciBpbmRleD1zdG9yZS5pbmRleChcInRpbWVzdGFtcFwiKTtpbmRleC5vcGVuS2V5Q3Vyc29yKCkub25zdWNjZXNzPShmdW5jdGlvbihldmVudCl7dmFyIGN1cnNvcj1ldmVudC50YXJnZXQucmVzdWx0O2lmKCFjdXJzb3Ipe3JldHVybiBjYWxsYmFjayhudWxsLHt0eXBlOlwicmVtb3RlXCIsZGI6ZGIsZW50cmllczplbnRyaWVzfSl9ZW50cmllc1tjdXJzb3IucHJpbWFyeUtleV09e3RpbWVzdGFtcDpjdXJzb3Iua2V5fTtjdXJzb3IuY29udGludWUoKX0pfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX19KSl9KSxsb2FkTG9jYWxFbnRyeTooZnVuY3Rpb24ocGF0aCxjYWxsYmFjayl7dmFyIHN0YXQsbm9kZTt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgpO25vZGU9bG9va3VwLm5vZGU7c3RhdD1GUy5zdGF0KHBhdGgpfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1pZihGUy5pc0RpcihzdGF0Lm1vZGUpKXtyZXR1cm4gY2FsbGJhY2sobnVsbCx7dGltZXN0YW1wOnN0YXQubXRpbWUsbW9kZTpzdGF0Lm1vZGV9KX1lbHNlIGlmKEZTLmlzRmlsZShzdGF0Lm1vZGUpKXtub2RlLmNvbnRlbnRzPU1FTUZTLmdldEZpbGVEYXRhQXNUeXBlZEFycmF5KG5vZGUpO3JldHVybiBjYWxsYmFjayhudWxsLHt0aW1lc3RhbXA6c3RhdC5tdGltZSxtb2RlOnN0YXQubW9kZSxjb250ZW50czpub2RlLmNvbnRlbnRzfSl9ZWxzZXtyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwibm9kZSB0eXBlIG5vdCBzdXBwb3J0ZWRcIikpfX0pLHN0b3JlTG9jYWxFbnRyeTooZnVuY3Rpb24ocGF0aCxlbnRyeSxjYWxsYmFjayl7dHJ5e2lmKEZTLmlzRGlyKGVudHJ5Lm1vZGUpKXtGUy5ta2RpcihwYXRoLGVudHJ5Lm1vZGUpfWVsc2UgaWYoRlMuaXNGaWxlKGVudHJ5Lm1vZGUpKXtGUy53cml0ZUZpbGUocGF0aCxlbnRyeS5jb250ZW50cyx7Y2FuT3duOnRydWV9KX1lbHNle3JldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZFwiKSl9RlMuY2htb2QocGF0aCxlbnRyeS5tb2RlKTtGUy51dGltZShwYXRoLGVudHJ5LnRpbWVzdGFtcCxlbnRyeS50aW1lc3RhbXApfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1jYWxsYmFjayhudWxsKX0pLHJlbW92ZUxvY2FsRW50cnk6KGZ1bmN0aW9uKHBhdGgsY2FsbGJhY2spe3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCk7dmFyIHN0YXQ9RlMuc3RhdChwYXRoKTtpZihGUy5pc0RpcihzdGF0Lm1vZGUpKXtGUy5ybWRpcihwYXRoKX1lbHNlIGlmKEZTLmlzRmlsZShzdGF0Lm1vZGUpKXtGUy51bmxpbmsocGF0aCl9fWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX1jYWxsYmFjayhudWxsKX0pLGxvYWRSZW1vdGVFbnRyeTooZnVuY3Rpb24oc3RvcmUscGF0aCxjYWxsYmFjayl7dmFyIHJlcT1zdG9yZS5nZXQocGF0aCk7cmVxLm9uc3VjY2Vzcz0oZnVuY3Rpb24oZXZlbnQpe2NhbGxiYWNrKG51bGwsZXZlbnQudGFyZ2V0LnJlc3VsdCl9KTtyZXEub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpfSl9KSxzdG9yZVJlbW90ZUVudHJ5OihmdW5jdGlvbihzdG9yZSxwYXRoLGVudHJ5LGNhbGxiYWNrKXt2YXIgcmVxPXN0b3JlLnB1dChlbnRyeSxwYXRoKTtyZXEub25zdWNjZXNzPShmdW5jdGlvbigpe2NhbGxiYWNrKG51bGwpfSk7cmVxLm9uZXJyb3I9KGZ1bmN0aW9uKGUpe2NhbGxiYWNrKHRoaXMuZXJyb3IpO2UucHJldmVudERlZmF1bHQoKX0pfSkscmVtb3ZlUmVtb3RlRW50cnk6KGZ1bmN0aW9uKHN0b3JlLHBhdGgsY2FsbGJhY2spe3ZhciByZXE9c3RvcmUuZGVsZXRlKHBhdGgpO3JlcS5vbnN1Y2Nlc3M9KGZ1bmN0aW9uKCl7Y2FsbGJhY2sobnVsbCl9KTtyZXEub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpfSl9KSxyZWNvbmNpbGU6KGZ1bmN0aW9uKHNyYyxkc3QsY2FsbGJhY2spe3ZhciB0b3RhbD0wO3ZhciBjcmVhdGU9W107T2JqZWN0LmtleXMoc3JjLmVudHJpZXMpLmZvckVhY2goKGZ1bmN0aW9uKGtleSl7dmFyIGU9c3JjLmVudHJpZXNba2V5XTt2YXIgZTI9ZHN0LmVudHJpZXNba2V5XTtpZighZTJ8fGUudGltZXN0YW1wPmUyLnRpbWVzdGFtcCl7Y3JlYXRlLnB1c2goa2V5KTt0b3RhbCsrfX0pKTt2YXIgcmVtb3ZlPVtdO09iamVjdC5rZXlzKGRzdC5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpe3ZhciBlPWRzdC5lbnRyaWVzW2tleV07dmFyIGUyPXNyYy5lbnRyaWVzW2tleV07aWYoIWUyKXtyZW1vdmUucHVzaChrZXkpO3RvdGFsKyt9fSkpO2lmKCF0b3RhbCl7cmV0dXJuIGNhbGxiYWNrKG51bGwpfXZhciBjb21wbGV0ZWQ9MDt2YXIgZGI9c3JjLnR5cGU9PT1cInJlbW90ZVwiP3NyYy5kYjpkc3QuZGI7dmFyIHRyYW5zYWN0aW9uPWRiLnRyYW5zYWN0aW9uKFtJREJGUy5EQl9TVE9SRV9OQU1FXSxcInJlYWR3cml0ZVwiKTt2YXIgc3RvcmU9dHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSk7ZnVuY3Rpb24gZG9uZShlcnIpe2lmKGVycil7aWYoIWRvbmUuZXJyb3JlZCl7ZG9uZS5lcnJvcmVkPXRydWU7cmV0dXJuIGNhbGxiYWNrKGVycil9cmV0dXJufWlmKCsrY29tcGxldGVkPj10b3RhbCl7cmV0dXJuIGNhbGxiYWNrKG51bGwpfX10cmFuc2FjdGlvbi5vbmVycm9yPShmdW5jdGlvbihlKXtkb25lKHRoaXMuZXJyb3IpO2UucHJldmVudERlZmF1bHQoKX0pO2NyZWF0ZS5zb3J0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocGF0aCl7aWYoZHN0LnR5cGU9PT1cImxvY2FsXCIpe0lEQkZTLmxvYWRSZW1vdGVFbnRyeShzdG9yZSxwYXRoLChmdW5jdGlvbihlcnIsZW50cnkpe2lmKGVycilyZXR1cm4gZG9uZShlcnIpO0lEQkZTLnN0b3JlTG9jYWxFbnRyeShwYXRoLGVudHJ5LGRvbmUpfSkpfWVsc2V7SURCRlMubG9hZExvY2FsRW50cnkocGF0aCwoZnVuY3Rpb24oZXJyLGVudHJ5KXtpZihlcnIpcmV0dXJuIGRvbmUoZXJyKTtJREJGUy5zdG9yZVJlbW90ZUVudHJ5KHN0b3JlLHBhdGgsZW50cnksZG9uZSl9KSl9fSkpO3JlbW92ZS5zb3J0KCkucmV2ZXJzZSgpLmZvckVhY2goKGZ1bmN0aW9uKHBhdGgpe2lmKGRzdC50eXBlPT09XCJsb2NhbFwiKXtJREJGUy5yZW1vdmVMb2NhbEVudHJ5KHBhdGgsZG9uZSl9ZWxzZXtJREJGUy5yZW1vdmVSZW1vdGVFbnRyeShzdG9yZSxwYXRoLGRvbmUpfX0pKX0pfTt2YXIgTk9ERUZTPXtpc1dpbmRvd3M6ZmFsc2Usc3RhdGljSW5pdDooZnVuY3Rpb24oKXtOT0RFRlMuaXNXaW5kb3dzPSEhcHJvY2Vzcy5wbGF0Zm9ybS5tYXRjaCgvXndpbi8pO3ZhciBmbGFncz1wcm9jZXNzW1wiYmluZGluZ1wiXShcImNvbnN0YW50c1wiKTtpZihmbGFnc1tcImZzXCJdKXtmbGFncz1mbGFnc1tcImZzXCJdfU5PREVGUy5mbGFnc0Zvck5vZGVNYXA9e1wiMTAyNFwiOmZsYWdzW1wiT19BUFBFTkRcIl0sXCI2NFwiOmZsYWdzW1wiT19DUkVBVFwiXSxcIjEyOFwiOmZsYWdzW1wiT19FWENMXCJdLFwiMFwiOmZsYWdzW1wiT19SRE9OTFlcIl0sXCIyXCI6ZmxhZ3NbXCJPX1JEV1JcIl0sXCI0MDk2XCI6ZmxhZ3NbXCJPX1NZTkNcIl0sXCI1MTJcIjpmbGFnc1tcIk9fVFJVTkNcIl0sXCIxXCI6ZmxhZ3NbXCJPX1dST05MWVwiXX19KSxidWZmZXJGcm9tOihmdW5jdGlvbihhcnJheUJ1ZmZlcil7cmV0dXJuIEJ1ZmZlci5hbGxvYz9CdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik6bmV3IEJ1ZmZlcihhcnJheUJ1ZmZlcil9KSxtb3VudDooZnVuY3Rpb24obW91bnQpe2Fzc2VydChFTlZJUk9OTUVOVF9JU19OT0RFKTtyZXR1cm4gTk9ERUZTLmNyZWF0ZU5vZGUobnVsbCxcIi9cIixOT0RFRlMuZ2V0TW9kZShtb3VudC5vcHRzLnJvb3QpLDApfSksY3JlYXRlTm9kZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxkZXYpe2lmKCFGUy5pc0Rpcihtb2RlKSYmIUZTLmlzRmlsZShtb2RlKSYmIUZTLmlzTGluayhtb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX12YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUpO25vZGUubm9kZV9vcHM9Tk9ERUZTLm5vZGVfb3BzO25vZGUuc3RyZWFtX29wcz1OT0RFRlMuc3RyZWFtX29wcztyZXR1cm4gbm9kZX0pLGdldE1vZGU6KGZ1bmN0aW9uKHBhdGgpe3ZhciBzdGF0O3RyeXtzdGF0PWZzLmxzdGF0U3luYyhwYXRoKTtpZihOT0RFRlMuaXNXaW5kb3dzKXtzdGF0Lm1vZGU9c3RhdC5tb2RlfChzdGF0Lm1vZGUmMjkyKT4+Mn19Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfXJldHVybiBzdGF0Lm1vZGV9KSxyZWFsUGF0aDooZnVuY3Rpb24obm9kZSl7dmFyIHBhcnRzPVtdO3doaWxlKG5vZGUucGFyZW50IT09bm9kZSl7cGFydHMucHVzaChub2RlLm5hbWUpO25vZGU9bm9kZS5wYXJlbnR9cGFydHMucHVzaChub2RlLm1vdW50Lm9wdHMucm9vdCk7cGFydHMucmV2ZXJzZSgpO3JldHVybiBQQVRILmpvaW4uYXBwbHkobnVsbCxwYXJ0cyl9KSxmbGFnc0Zvck5vZGU6KGZ1bmN0aW9uKGZsYWdzKXtmbGFncyY9fjIwOTcxNTI7ZmxhZ3MmPX4yMDQ4O2ZsYWdzJj1+MzI3Njg7ZmxhZ3MmPX41MjQyODg7dmFyIG5ld0ZsYWdzPTA7Zm9yKHZhciBrIGluIE5PREVGUy5mbGFnc0Zvck5vZGVNYXApe2lmKGZsYWdzJmspe25ld0ZsYWdzfD1OT0RFRlMuZmxhZ3NGb3JOb2RlTWFwW2tdO2ZsYWdzXj1rfX1pZighZmxhZ3Mpe3JldHVybiBuZXdGbGFnc31lbHNle3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9fSksbm9kZV9vcHM6e2dldGF0dHI6KGZ1bmN0aW9uKG5vZGUpe3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt2YXIgc3RhdDt0cnl7c3RhdD1mcy5sc3RhdFN5bmMocGF0aCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfWlmKE5PREVGUy5pc1dpbmRvd3MmJiFzdGF0LmJsa3NpemUpe3N0YXQuYmxrc2l6ZT00MDk2fWlmKE5PREVGUy5pc1dpbmRvd3MmJiFzdGF0LmJsb2Nrcyl7c3RhdC5ibG9ja3M9KHN0YXQuc2l6ZStzdGF0LmJsa3NpemUtMSkvc3RhdC5ibGtzaXplfDB9cmV0dXJue2RldjpzdGF0LmRldixpbm86c3RhdC5pbm8sbW9kZTpzdGF0Lm1vZGUsbmxpbms6c3RhdC5ubGluayx1aWQ6c3RhdC51aWQsZ2lkOnN0YXQuZ2lkLHJkZXY6c3RhdC5yZGV2LHNpemU6c3RhdC5zaXplLGF0aW1lOnN0YXQuYXRpbWUsbXRpbWU6c3RhdC5tdGltZSxjdGltZTpzdGF0LmN0aW1lLGJsa3NpemU6c3RhdC5ibGtzaXplLGJsb2NrczpzdGF0LmJsb2Nrc319KSxzZXRhdHRyOihmdW5jdGlvbihub2RlLGF0dHIpe3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7aWYoYXR0ci5tb2RlIT09dW5kZWZpbmVkKXtmcy5jaG1vZFN5bmMocGF0aCxhdHRyLm1vZGUpO25vZGUubW9kZT1hdHRyLm1vZGV9aWYoYXR0ci50aW1lc3RhbXAhPT11bmRlZmluZWQpe3ZhciBkYXRlPW5ldyBEYXRlKGF0dHIudGltZXN0YW1wKTtmcy51dGltZXNTeW5jKHBhdGgsZGF0ZSxkYXRlKX1pZihhdHRyLnNpemUhPT11bmRlZmluZWQpe2ZzLnRydW5jYXRlU3luYyhwYXRoLGF0dHIuc2l6ZSl9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxsb29rdXA6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgcGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPU5PREVGUy5nZXRNb2RlKHBhdGgpO3JldHVybiBOT0RFRlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlKX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7dmFyIG5vZGU9Tk9ERUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpO3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7ZnMubWtkaXJTeW5jKHBhdGgsbm9kZS5tb2RlKX1lbHNle2ZzLndyaXRlRmlsZVN5bmMocGF0aCxcIlwiLHttb2RlOm5vZGUubW9kZX0pfX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9cmV0dXJuIG5vZGV9KSxyZW5hbWU6KGZ1bmN0aW9uKG9sZE5vZGUsbmV3RGlyLG5ld05hbWUpe3ZhciBvbGRQYXRoPU5PREVGUy5yZWFsUGF0aChvbGROb2RlKTt2YXIgbmV3UGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChuZXdEaXIpLG5ld05hbWUpO3RyeXtmcy5yZW5hbWVTeW5jKG9sZFBhdGgsbmV3UGF0aCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHVubGluazooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3ZhciBwYXRoPVBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKHBhcmVudCksbmFtZSk7dHJ5e2ZzLnVubGlua1N5bmMocGF0aCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHJtZGlyOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIHBhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSxuYW1lKTt0cnl7ZnMucm1kaXJTeW5jKHBhdGgpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxyZWFkZGlyOihmdW5jdGlvbihub2RlKXt2YXIgcGF0aD1OT0RFRlMucmVhbFBhdGgobm9kZSk7dHJ5e3JldHVybiBmcy5yZWFkZGlyU3luYyhwYXRoKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSksc3ltbGluazooZnVuY3Rpb24ocGFyZW50LG5ld05hbWUsb2xkUGF0aCl7dmFyIG5ld1BhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSxuZXdOYW1lKTt0cnl7ZnMuc3ltbGlua1N5bmMob2xkUGF0aCxuZXdQYXRoKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSkscmVhZGxpbms6KGZ1bmN0aW9uKG5vZGUpe3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7cGF0aD1mcy5yZWFkbGlua1N5bmMocGF0aCk7cGF0aD1OT0RFSlNfUEFUSC5yZWxhdGl2ZShOT0RFSlNfUEFUSC5yZXNvbHZlKG5vZGUubW91bnQub3B0cy5yb290KSxwYXRoKTtyZXR1cm4gcGF0aH1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSl9LHN0cmVhbV9vcHM6e29wZW46KGZ1bmN0aW9uKHN0cmVhbSl7dmFyIHBhdGg9Tk9ERUZTLnJlYWxQYXRoKHN0cmVhbS5ub2RlKTt0cnl7aWYoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXtzdHJlYW0ubmZkPWZzLm9wZW5TeW5jKHBhdGgsTk9ERUZTLmZsYWdzRm9yTm9kZShzdHJlYW0uZmxhZ3MpKX19Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe3RyeXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkmJnN0cmVhbS5uZmQpe2ZzLmNsb3NlU3luYyhzdHJlYW0ubmZkKX19Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7aWYobGVuZ3RoPT09MClyZXR1cm4gMDt0cnl7cmV0dXJuIGZzLnJlYWRTeW5jKHN0cmVhbS5uZmQsTk9ERUZTLmJ1ZmZlckZyb20oYnVmZmVyLmJ1ZmZlciksb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dHJ5e3JldHVybiBmcy53cml0ZVN5bmMoc3RyZWFtLm5mZCxOT0RFRlMuYnVmZmVyRnJvbShidWZmZXIuYnVmZmVyKSxvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxsbHNlZWs6KGZ1bmN0aW9uKHN0cmVhbSxvZmZzZXQsd2hlbmNlKXt2YXIgcG9zaXRpb249b2Zmc2V0O2lmKHdoZW5jZT09PTEpe3Bvc2l0aW9uKz1zdHJlYW0ucG9zaXRpb259ZWxzZSBpZih3aGVuY2U9PT0yKXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3RyeXt2YXIgc3RhdD1mcy5mc3RhdFN5bmMoc3RyZWFtLm5mZCk7cG9zaXRpb24rPXN0YXQuc2l6ZX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19fWlmKHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9cmV0dXJuIHBvc2l0aW9ufSl9fTt2YXIgV09SS0VSRlM9e0RJUl9NT0RFOjE2ODk1LEZJTEVfTU9ERTozMzI3OSxyZWFkZXI6bnVsbCxtb3VudDooZnVuY3Rpb24obW91bnQpe2Fzc2VydChFTlZJUk9OTUVOVF9JU19XT1JLRVIpO2lmKCFXT1JLRVJGUy5yZWFkZXIpV09SS0VSRlMucmVhZGVyPW5ldyBGaWxlUmVhZGVyU3luYzt2YXIgcm9vdD1XT1JLRVJGUy5jcmVhdGVOb2RlKG51bGwsXCIvXCIsV09SS0VSRlMuRElSX01PREUsMCk7dmFyIGNyZWF0ZWRQYXJlbnRzPXt9O2Z1bmN0aW9uIGVuc3VyZVBhcmVudChwYXRoKXt2YXIgcGFydHM9cGF0aC5zcGxpdChcIi9cIik7dmFyIHBhcmVudD1yb290O2Zvcih2YXIgaT0wO2k8cGFydHMubGVuZ3RoLTE7aSsrKXt2YXIgY3Vycj1wYXJ0cy5zbGljZSgwLGkrMSkuam9pbihcIi9cIik7aWYoIWNyZWF0ZWRQYXJlbnRzW2N1cnJdKXtjcmVhdGVkUGFyZW50c1tjdXJyXT1XT1JLRVJGUy5jcmVhdGVOb2RlKHBhcmVudCxwYXJ0c1tpXSxXT1JLRVJGUy5ESVJfTU9ERSwwKX1wYXJlbnQ9Y3JlYXRlZFBhcmVudHNbY3Vycl19cmV0dXJuIHBhcmVudH1mdW5jdGlvbiBiYXNlKHBhdGgpe3ZhciBwYXJ0cz1wYXRoLnNwbGl0KFwiL1wiKTtyZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoLTFdfUFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobW91bnQub3B0c1tcImZpbGVzXCJdfHxbXSwoZnVuY3Rpb24oZmlsZSl7V09SS0VSRlMuY3JlYXRlTm9kZShlbnN1cmVQYXJlbnQoZmlsZS5uYW1lKSxiYXNlKGZpbGUubmFtZSksV09SS0VSRlMuRklMRV9NT0RFLDAsZmlsZSxmaWxlLmxhc3RNb2RpZmllZERhdGUpfSkpOyhtb3VudC5vcHRzW1wiYmxvYnNcIl18fFtdKS5mb3JFYWNoKChmdW5jdGlvbihvYmope1dPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KG9ialtcIm5hbWVcIl0pLGJhc2Uob2JqW1wibmFtZVwiXSksV09SS0VSRlMuRklMRV9NT0RFLDAsb2JqW1wiZGF0YVwiXSl9KSk7KG1vdW50Lm9wdHNbXCJwYWNrYWdlc1wiXXx8W10pLmZvckVhY2goKGZ1bmN0aW9uKHBhY2spe3BhY2tbXCJtZXRhZGF0YVwiXS5maWxlcy5mb3JFYWNoKChmdW5jdGlvbihmaWxlKXt2YXIgbmFtZT1maWxlLmZpbGVuYW1lLnN1YnN0cigxKTtXT1JLRVJGUy5jcmVhdGVOb2RlKGVuc3VyZVBhcmVudChuYW1lKSxiYXNlKG5hbWUpLFdPUktFUkZTLkZJTEVfTU9ERSwwLHBhY2tbXCJibG9iXCJdLnNsaWNlKGZpbGUuc3RhcnQsZmlsZS5lbmQpKX0pKX0pKTtyZXR1cm4gcm9vdH0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2LGNvbnRlbnRzLG10aW1lKXt2YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUpO25vZGUubW9kZT1tb2RlO25vZGUubm9kZV9vcHM9V09SS0VSRlMubm9kZV9vcHM7bm9kZS5zdHJlYW1fb3BzPVdPUktFUkZTLnN0cmVhbV9vcHM7bm9kZS50aW1lc3RhbXA9KG10aW1lfHxuZXcgRGF0ZSkuZ2V0VGltZSgpO2Fzc2VydChXT1JLRVJGUy5GSUxFX01PREUhPT1XT1JLRVJGUy5ESVJfTU9ERSk7aWYobW9kZT09PVdPUktFUkZTLkZJTEVfTU9ERSl7bm9kZS5zaXplPWNvbnRlbnRzLnNpemU7bm9kZS5jb250ZW50cz1jb250ZW50c31lbHNle25vZGUuc2l6ZT00MDk2O25vZGUuY29udGVudHM9e319aWYocGFyZW50KXtwYXJlbnQuY29udGVudHNbbmFtZV09bm9kZX1yZXR1cm4gbm9kZX0pLG5vZGVfb3BzOntnZXRhdHRyOihmdW5jdGlvbihub2RlKXtyZXR1cm57ZGV2OjEsaW5vOnVuZGVmaW5lZCxtb2RlOm5vZGUubW9kZSxubGluazoxLHVpZDowLGdpZDowLHJkZXY6dW5kZWZpbmVkLHNpemU6bm9kZS5zaXplLGF0aW1lOm5ldyBEYXRlKG5vZGUudGltZXN0YW1wKSxtdGltZTpuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksY3RpbWU6bmV3IERhdGUobm9kZS50aW1lc3RhbXApLGJsa3NpemU6NDA5NixibG9ja3M6TWF0aC5jZWlsKG5vZGUuc2l6ZS80MDk2KX19KSxzZXRhdHRyOihmdW5jdGlvbihub2RlLGF0dHIpe2lmKGF0dHIubW9kZSE9PXVuZGVmaW5lZCl7bm9kZS5tb2RlPWF0dHIubW9kZX1pZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7bm9kZS50aW1lc3RhbXA9YXR0ci50aW1lc3RhbXB9fSksbG9va3VwOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfSkscmVuYW1lOihmdW5jdGlvbihvbGROb2RlLG5ld0RpcixuZXdOYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KSx1bmxpbms6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KSxybWRpcjooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pLHJlYWRkaXI6KGZ1bmN0aW9uKG5vZGUpe3ZhciBlbnRyaWVzPVtcIi5cIixcIi4uXCJdO2Zvcih2YXIga2V5IGluIG5vZGUuY29udGVudHMpe2lmKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpe2NvbnRpbnVlfWVudHJpZXMucHVzaChrZXkpfXJldHVybiBlbnRyaWVzfSksc3ltbGluazooZnVuY3Rpb24ocGFyZW50LG5ld05hbWUsb2xkUGF0aCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfSkscmVhZGxpbms6KGZ1bmN0aW9uKG5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pfSxzdHJlYW1fb3BzOntyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKHBvc2l0aW9uPj1zdHJlYW0ubm9kZS5zaXplKXJldHVybiAwO3ZhciBjaHVuaz1zdHJlYW0ubm9kZS5jb250ZW50cy5zbGljZShwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpO3ZhciBhYj1XT1JLRVJGUy5yZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspO2J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYWIpLG9mZnNldCk7cmV0dXJuIGNodW5rLnNpemV9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfSksbGxzZWVrOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7dmFyIHBvc2l0aW9uPW9mZnNldDtpZih3aGVuY2U9PT0xKXtwb3NpdGlvbis9c3RyZWFtLnBvc2l0aW9ufWVsc2UgaWYod2hlbmNlPT09Mil7aWYoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXtwb3NpdGlvbis9c3RyZWFtLm5vZGUuc2l6ZX19aWYocG9zaXRpb248MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1yZXR1cm4gcG9zaXRpb259KX19O1NUQVRJQ1RPUCs9MTY7U1RBVElDVE9QKz0xNjtTVEFUSUNUT1ArPTE2O3ZhciBGUz17cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOnt9LHN0cmVhbXM6W10sbmV4dElub2RlOjEsbmFtZVRhYmxlOm51bGwsY3VycmVudFBhdGg6XCIvXCIsaW5pdGlhbGl6ZWQ6ZmFsc2UsaWdub3JlUGVybWlzc2lvbnM6dHJ1ZSx0cmFja2luZ0RlbGVnYXRlOnt9LHRyYWNraW5nOntvcGVuRmxhZ3M6e1JFQUQ6MSxXUklURToyfX0sRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGhhbmRsZUZTRXJyb3I6KGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKXRocm93IGUrXCIgOiBcIitzdGFja1RyYWNlKCk7cmV0dXJuIF9fX3NldEVyck5vKGUuZXJybm8pfSksbG9va3VwUGF0aDooZnVuY3Rpb24ocGF0aCxvcHRzKXtwYXRoPVBBVEgucmVzb2x2ZShGUy5jd2QoKSxwYXRoKTtvcHRzPW9wdHN8fHt9O2lmKCFwYXRoKXJldHVybntwYXRoOlwiXCIsbm9kZTpudWxsfTt2YXIgZGVmYXVsdHM9e2ZvbGxvd19tb3VudDp0cnVlLHJlY3Vyc2VfY291bnQ6MH07Zm9yKHZhciBrZXkgaW4gZGVmYXVsdHMpe2lmKG9wdHNba2V5XT09PXVuZGVmaW5lZCl7b3B0c1trZXldPWRlZmF1bHRzW2tleV19fWlmKG9wdHMucmVjdXJzZV9jb3VudD44KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTE9PUCl9dmFyIHBhcnRzPVBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKChmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSksZmFsc2UpO3ZhciBjdXJyZW50PUZTLnJvb3Q7dmFyIGN1cnJlbnRfcGF0aD1cIi9cIjtmb3IodmFyIGk9MDtpPHBhcnRzLmxlbmd0aDtpKyspe3ZhciBpc2xhc3Q9aT09PXBhcnRzLmxlbmd0aC0xO2lmKGlzbGFzdCYmb3B0cy5wYXJlbnQpe2JyZWFrfWN1cnJlbnQ9RlMubG9va3VwTm9kZShjdXJyZW50LHBhcnRzW2ldKTtjdXJyZW50X3BhdGg9UEFUSC5qb2luMihjdXJyZW50X3BhdGgscGFydHNbaV0pO2lmKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSl7aWYoIWlzbGFzdHx8aXNsYXN0JiZvcHRzLmZvbGxvd19tb3VudCl7Y3VycmVudD1jdXJyZW50Lm1vdW50ZWQucm9vdH19aWYoIWlzbGFzdHx8b3B0cy5mb2xsb3cpe3ZhciBjb3VudD0wO3doaWxlKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKXt2YXIgbGluaz1GUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO2N1cnJlbnRfcGF0aD1QQVRILnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksbGluayk7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCx7cmVjdXJzZV9jb3VudDpvcHRzLnJlY3Vyc2VfY291bnR9KTtjdXJyZW50PWxvb2t1cC5ub2RlO2lmKGNvdW50Kys+NDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVMT09QKX19fX1yZXR1cm57cGF0aDpjdXJyZW50X3BhdGgsbm9kZTpjdXJyZW50fX0pLGdldFBhdGg6KGZ1bmN0aW9uKG5vZGUpe3ZhciBwYXRoO3doaWxlKHRydWUpe2lmKEZTLmlzUm9vdChub2RlKSl7dmFyIG1vdW50PW5vZGUubW91bnQubW91bnRwb2ludDtpZighcGF0aClyZXR1cm4gbW91bnQ7cmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aC0xXSE9PVwiL1wiP21vdW50K1wiL1wiK3BhdGg6bW91bnQrcGF0aH1wYXRoPXBhdGg/bm9kZS5uYW1lK1wiL1wiK3BhdGg6bm9kZS5uYW1lO25vZGU9bm9kZS5wYXJlbnR9fSksaGFzaE5hbWU6KGZ1bmN0aW9uKHBhcmVudGlkLG5hbWUpe3ZhciBoYXNoPTA7Zm9yKHZhciBpPTA7aTxuYW1lLmxlbmd0aDtpKyspe2hhc2g9KGhhc2g8PDUpLWhhc2grbmFtZS5jaGFyQ29kZUF0KGkpfDB9cmV0dXJuKHBhcmVudGlkK2hhc2g+Pj4wKSVGUy5uYW1lVGFibGUubGVuZ3RofSksaGFzaEFkZE5vZGU6KGZ1bmN0aW9uKG5vZGUpe3ZhciBoYXNoPUZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLG5vZGUubmFtZSk7bm9kZS5uYW1lX25leHQ9RlMubmFtZVRhYmxlW2hhc2hdO0ZTLm5hbWVUYWJsZVtoYXNoXT1ub2RlfSksaGFzaFJlbW92ZU5vZGU6KGZ1bmN0aW9uKG5vZGUpe3ZhciBoYXNoPUZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLG5vZGUubmFtZSk7aWYoRlMubmFtZVRhYmxlW2hhc2hdPT09bm9kZSl7RlMubmFtZVRhYmxlW2hhc2hdPW5vZGUubmFtZV9uZXh0fWVsc2V7dmFyIGN1cnJlbnQ9RlMubmFtZVRhYmxlW2hhc2hdO3doaWxlKGN1cnJlbnQpe2lmKGN1cnJlbnQubmFtZV9uZXh0PT09bm9kZSl7Y3VycmVudC5uYW1lX25leHQ9bm9kZS5uYW1lX25leHQ7YnJlYWt9Y3VycmVudD1jdXJyZW50Lm5hbWVfbmV4dH19fSksbG9va3VwTm9kZTooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3ZhciBlcnI9RlMubWF5TG9va3VwKHBhcmVudCk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIscGFyZW50KX12YXIgaGFzaD1GUy5oYXNoTmFtZShwYXJlbnQuaWQsbmFtZSk7Zm9yKHZhciBub2RlPUZTLm5hbWVUYWJsZVtoYXNoXTtub2RlO25vZGU9bm9kZS5uYW1lX25leHQpe3ZhciBub2RlTmFtZT1ub2RlLm5hbWU7aWYobm9kZS5wYXJlbnQuaWQ9PT1wYXJlbnQuaWQmJm5vZGVOYW1lPT09bmFtZSl7cmV0dXJuIG5vZGV9fXJldHVybiBGUy5sb29rdXAocGFyZW50LG5hbWUpfSksY3JlYXRlTm9kZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxyZGV2KXtpZighRlMuRlNOb2RlKXtGUy5GU05vZGU9KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUscmRldil7aWYoIXBhcmVudCl7cGFyZW50PXRoaXN9dGhpcy5wYXJlbnQ9cGFyZW50O3RoaXMubW91bnQ9cGFyZW50Lm1vdW50O3RoaXMubW91bnRlZD1udWxsO3RoaXMuaWQ9RlMubmV4dElub2RlKys7dGhpcy5uYW1lPW5hbWU7dGhpcy5tb2RlPW1vZGU7dGhpcy5ub2RlX29wcz17fTt0aGlzLnN0cmVhbV9vcHM9e307dGhpcy5yZGV2PXJkZXZ9KTtGUy5GU05vZGUucHJvdG90eXBlPXt9O3ZhciByZWFkTW9kZT0yOTJ8NzM7dmFyIHdyaXRlTW9kZT0xNDY7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNOb2RlLnByb3RvdHlwZSx7cmVhZDp7Z2V0OihmdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGUmcmVhZE1vZGUpPT09cmVhZE1vZGV9KSxzZXQ6KGZ1bmN0aW9uKHZhbCl7dmFsP3RoaXMubW9kZXw9cmVhZE1vZGU6dGhpcy5tb2RlJj1+cmVhZE1vZGV9KX0sd3JpdGU6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5tb2RlJndyaXRlTW9kZSk9PT13cml0ZU1vZGV9KSxzZXQ6KGZ1bmN0aW9uKHZhbCl7dmFsP3RoaXMubW9kZXw9d3JpdGVNb2RlOnRoaXMubW9kZSY9fndyaXRlTW9kZX0pfSxpc0ZvbGRlcjp7Z2V0OihmdW5jdGlvbigpe3JldHVybiBGUy5pc0Rpcih0aGlzLm1vZGUpfSl9LGlzRGV2aWNlOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSl9KX19KX12YXIgbm9kZT1uZXcgRlMuRlNOb2RlKHBhcmVudCxuYW1lLG1vZGUscmRldik7RlMuaGFzaEFkZE5vZGUobm9kZSk7cmV0dXJuIG5vZGV9KSxkZXN0cm95Tm9kZTooZnVuY3Rpb24obm9kZSl7RlMuaGFzaFJlbW92ZU5vZGUobm9kZSl9KSxpc1Jvb3Q6KGZ1bmN0aW9uKG5vZGUpe3JldHVybiBub2RlPT09bm9kZS5wYXJlbnR9KSxpc01vdW50cG9pbnQ6KGZ1bmN0aW9uKG5vZGUpe3JldHVybiEhbm9kZS5tb3VudGVkfSksaXNGaWxlOihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0zMjc2OH0pLGlzRGlyOihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0xNjM4NH0pLGlzTGluazooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5NjB9KSxpc0NocmRldjooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09ODE5Mn0pLGlzQmxrZGV2OihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0yNDU3Nn0pLGlzRklGTzooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5Nn0pLGlzU29ja2V0OihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY0OTE1Mik9PT00OTE1Mn0pLGZsYWdNb2Rlczp7XCJyXCI6MCxcInJzXCI6MTA1MjY3MixcInIrXCI6MixcIndcIjo1NzcsXCJ3eFwiOjcwNSxcInh3XCI6NzA1LFwidytcIjo1NzgsXCJ3eCtcIjo3MDYsXCJ4dytcIjo3MDYsXCJhXCI6MTA4OSxcImF4XCI6MTIxNyxcInhhXCI6MTIxNyxcImErXCI6MTA5MCxcImF4K1wiOjEyMTgsXCJ4YStcIjoxMjE4fSxtb2RlU3RyaW5nVG9GbGFnczooZnVuY3Rpb24oc3RyKXt2YXIgZmxhZ3M9RlMuZmxhZ01vZGVzW3N0cl07aWYodHlwZW9mIGZsYWdzPT09XCJ1bmRlZmluZWRcIil7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmaWxlIG9wZW4gbW9kZTogXCIrc3RyKX1yZXR1cm4gZmxhZ3N9KSxmbGFnc1RvUGVybWlzc2lvblN0cmluZzooZnVuY3Rpb24oZmxhZyl7dmFyIHBlcm1zPVtcInJcIixcIndcIixcInJ3XCJdW2ZsYWcmM107aWYoZmxhZyY1MTIpe3Blcm1zKz1cIndcIn1yZXR1cm4gcGVybXN9KSxub2RlUGVybWlzc2lvbnM6KGZ1bmN0aW9uKG5vZGUscGVybXMpe2lmKEZTLmlnbm9yZVBlcm1pc3Npb25zKXtyZXR1cm4gMH1pZihwZXJtcy5pbmRleE9mKFwiclwiKSE9PS0xJiYhKG5vZGUubW9kZSYyOTIpKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUFDQ0VTfWVsc2UgaWYocGVybXMuaW5kZXhPZihcIndcIikhPT0tMSYmIShub2RlLm1vZGUmMTQ2KSl7cmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFU31lbHNlIGlmKHBlcm1zLmluZGV4T2YoXCJ4XCIpIT09LTEmJiEobm9kZS5tb2RlJjczKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFU31yZXR1cm4gMH0pLG1heUxvb2t1cDooZnVuY3Rpb24oZGlyKXt2YXIgZXJyPUZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsXCJ4XCIpO2lmKGVycilyZXR1cm4gZXJyO2lmKCFkaXIubm9kZV9vcHMubG9va3VwKXJldHVybiBFUlJOT19DT0RFUy5FQUNDRVM7cmV0dXJuIDB9KSxtYXlDcmVhdGU6KGZ1bmN0aW9uKGRpcixuYW1lKXt0cnl7dmFyIG5vZGU9RlMubG9va3VwTm9kZShkaXIsbmFtZSk7cmV0dXJuIEVSUk5PX0NPREVTLkVFWElTVH1jYXRjaChlKXt9cmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsXCJ3eFwiKX0pLG1heURlbGV0ZTooZnVuY3Rpb24oZGlyLG5hbWUsaXNkaXIpe3ZhciBub2RlO3RyeXtub2RlPUZTLmxvb2t1cE5vZGUoZGlyLG5hbWUpfWNhdGNoKGUpe3JldHVybiBlLmVycm5vfXZhciBlcnI9RlMubm9kZVBlcm1pc3Npb25zKGRpcixcInd4XCIpO2lmKGVycil7cmV0dXJuIGVycn1pZihpc2Rpcil7aWYoIUZTLmlzRGlyKG5vZGUubW9kZSkpe3JldHVybiBFUlJOT19DT0RFUy5FTk9URElSfWlmKEZTLmlzUm9vdChub2RlKXx8RlMuZ2V0UGF0aChub2RlKT09PUZTLmN3ZCgpKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUJVU1l9fWVsc2V7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVJU0RJUn19cmV0dXJuIDB9KSxtYXlPcGVuOihmdW5jdGlvbihub2RlLGZsYWdzKXtpZighbm9kZSl7cmV0dXJuIEVSUk5PX0NPREVTLkVOT0VOVH1pZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVMT09QfWVsc2UgaWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7aWYoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpIT09XCJyXCJ8fGZsYWdzJjUxMil7cmV0dXJuIEVSUk5PX0NPREVTLkVJU0RJUn19cmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSl9KSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6KGZ1bmN0aW9uKGZkX3N0YXJ0LGZkX2VuZCl7ZmRfc3RhcnQ9ZmRfc3RhcnR8fDA7ZmRfZW5kPWZkX2VuZHx8RlMuTUFYX09QRU5fRkRTO2Zvcih2YXIgZmQ9ZmRfc3RhcnQ7ZmQ8PWZkX2VuZDtmZCsrKXtpZighRlMuc3RyZWFtc1tmZF0pe3JldHVybiBmZH19dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU1GSUxFKX0pLGdldFN0cmVhbTooZnVuY3Rpb24oZmQpe3JldHVybiBGUy5zdHJlYW1zW2ZkXX0pLGNyZWF0ZVN0cmVhbTooZnVuY3Rpb24oc3RyZWFtLGZkX3N0YXJ0LGZkX2VuZCl7aWYoIUZTLkZTU3RyZWFtKXtGUy5GU1N0cmVhbT0oZnVuY3Rpb24oKXt9KTtGUy5GU1N0cmVhbS5wcm90b3R5cGU9e307T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNTdHJlYW0ucHJvdG90eXBlLHtvYmplY3Q6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlfSksc2V0OihmdW5jdGlvbih2YWwpe3RoaXMubm9kZT12YWx9KX0saXNSZWFkOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0xfSl9LGlzV3JpdGU6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5mbGFncyYyMDk3MTU1KSE9PTB9KX0saXNBcHBlbmQ6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFncyYxMDI0fSl9fSl9dmFyIG5ld1N0cmVhbT1uZXcgRlMuRlNTdHJlYW07Zm9yKHZhciBwIGluIHN0cmVhbSl7bmV3U3RyZWFtW3BdPXN0cmVhbVtwXX1zdHJlYW09bmV3U3RyZWFtO3ZhciBmZD1GUy5uZXh0ZmQoZmRfc3RhcnQsZmRfZW5kKTtzdHJlYW0uZmQ9ZmQ7RlMuc3RyZWFtc1tmZF09c3RyZWFtO3JldHVybiBzdHJlYW19KSxjbG9zZVN0cmVhbTooZnVuY3Rpb24oZmQpe0ZTLnN0cmVhbXNbZmRdPW51bGx9KSxjaHJkZXZfc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgZGV2aWNlPUZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtzdHJlYW0uc3RyZWFtX29wcz1kZXZpY2Uuc3RyZWFtX29wcztpZihzdHJlYW0uc3RyZWFtX29wcy5vcGVuKXtzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSl9fSksbGxzZWVrOihmdW5jdGlvbigpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSl9KX0sbWFqb3I6KGZ1bmN0aW9uKGRldil7cmV0dXJuIGRldj4+OH0pLG1pbm9yOihmdW5jdGlvbihkZXYpe3JldHVybiBkZXYmMjU1fSksbWFrZWRldjooZnVuY3Rpb24obWEsbWkpe3JldHVybiBtYTw8OHxtaX0pLHJlZ2lzdGVyRGV2aWNlOihmdW5jdGlvbihkZXYsb3BzKXtGUy5kZXZpY2VzW2Rldl09e3N0cmVhbV9vcHM6b3BzfX0pLGdldERldmljZTooZnVuY3Rpb24oZGV2KXtyZXR1cm4gRlMuZGV2aWNlc1tkZXZdfSksZ2V0TW91bnRzOihmdW5jdGlvbihtb3VudCl7dmFyIG1vdW50cz1bXTt2YXIgY2hlY2s9W21vdW50XTt3aGlsZShjaGVjay5sZW5ndGgpe3ZhciBtPWNoZWNrLnBvcCgpO21vdW50cy5wdXNoKG0pO2NoZWNrLnB1c2guYXBwbHkoY2hlY2ssbS5tb3VudHMpfXJldHVybiBtb3VudHN9KSxzeW5jZnM6KGZ1bmN0aW9uKHBvcHVsYXRlLGNhbGxiYWNrKXtpZih0eXBlb2YgcG9wdWxhdGU9PT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrPXBvcHVsYXRlO3BvcHVsYXRlPWZhbHNlfUZTLnN5bmNGU1JlcXVlc3RzKys7aWYoRlMuc3luY0ZTUmVxdWVzdHM+MSl7Y29uc29sZS5sb2coXCJ3YXJuaW5nOiBcIitGUy5zeW5jRlNSZXF1ZXN0cytcIiBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrXCIpfXZhciBtb3VudHM9RlMuZ2V0TW91bnRzKEZTLnJvb3QubW91bnQpO3ZhciBjb21wbGV0ZWQ9MDtmdW5jdGlvbiBkb0NhbGxiYWNrKGVycil7YXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzPjApO0ZTLnN5bmNGU1JlcXVlc3RzLS07cmV0dXJuIGNhbGxiYWNrKGVycil9ZnVuY3Rpb24gZG9uZShlcnIpe2lmKGVycil7aWYoIWRvbmUuZXJyb3JlZCl7ZG9uZS5lcnJvcmVkPXRydWU7cmV0dXJuIGRvQ2FsbGJhY2soZXJyKX1yZXR1cm59aWYoKytjb21wbGV0ZWQ+PW1vdW50cy5sZW5ndGgpe2RvQ2FsbGJhY2sobnVsbCl9fW1vdW50cy5mb3JFYWNoKChmdW5jdGlvbihtb3VudCl7aWYoIW1vdW50LnR5cGUuc3luY2ZzKXtyZXR1cm4gZG9uZShudWxsKX1tb3VudC50eXBlLnN5bmNmcyhtb3VudCxwb3B1bGF0ZSxkb25lKX0pKX0pLG1vdW50OihmdW5jdGlvbih0eXBlLG9wdHMsbW91bnRwb2ludCl7dmFyIHJvb3Q9bW91bnRwb2ludD09PVwiL1wiO3ZhciBwc2V1ZG89IW1vdW50cG9pbnQ7dmFyIG5vZGU7aWYocm9vdCYmRlMucm9vdCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfWVsc2UgaWYoIXJvb3QmJiFwc2V1ZG8pe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChtb3VudHBvaW50LHtmb2xsb3dfbW91bnQ6ZmFsc2V9KTttb3VudHBvaW50PWxvb2t1cC5wYXRoO25vZGU9bG9va3VwLm5vZGU7aWYoRlMuaXNNb3VudHBvaW50KG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSl9aWYoIUZTLmlzRGlyKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpfX12YXIgbW91bnQ9e3R5cGU6dHlwZSxvcHRzOm9wdHMsbW91bnRwb2ludDptb3VudHBvaW50LG1vdW50czpbXX07dmFyIG1vdW50Um9vdD10eXBlLm1vdW50KG1vdW50KTttb3VudFJvb3QubW91bnQ9bW91bnQ7bW91bnQucm9vdD1tb3VudFJvb3Q7aWYocm9vdCl7RlMucm9vdD1tb3VudFJvb3R9ZWxzZSBpZihub2RlKXtub2RlLm1vdW50ZWQ9bW91bnQ7aWYobm9kZS5tb3VudCl7bm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCl9fXJldHVybiBtb3VudFJvb3R9KSx1bm1vdW50OihmdW5jdGlvbihtb3VudHBvaW50KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgobW91bnRwb2ludCx7Zm9sbG93X21vdW50OmZhbHNlfSk7aWYoIUZTLmlzTW91bnRwb2ludChsb29rdXAubm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIG5vZGU9bG9va3VwLm5vZGU7dmFyIG1vdW50PW5vZGUubW91bnRlZDt2YXIgbW91bnRzPUZTLmdldE1vdW50cyhtb3VudCk7T2JqZWN0LmtleXMoRlMubmFtZVRhYmxlKS5mb3JFYWNoKChmdW5jdGlvbihoYXNoKXt2YXIgY3VycmVudD1GUy5uYW1lVGFibGVbaGFzaF07d2hpbGUoY3VycmVudCl7dmFyIG5leHQ9Y3VycmVudC5uYW1lX25leHQ7aWYobW91bnRzLmluZGV4T2YoY3VycmVudC5tb3VudCkhPT0tMSl7RlMuZGVzdHJveU5vZGUoY3VycmVudCl9Y3VycmVudD1uZXh0fX0pKTtub2RlLm1vdW50ZWQ9bnVsbDt2YXIgaWR4PW5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO2Fzc2VydChpZHghPT0tMSk7bm9kZS5tb3VudC5tb3VudHMuc3BsaWNlKGlkeCwxKX0pLGxvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3JldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCxuYW1lKX0pLG1rbm9kOihmdW5jdGlvbihwYXRoLG1vZGUsZGV2KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OnRydWV9KTt2YXIgcGFyZW50PWxvb2t1cC5ub2RlO3ZhciBuYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7aWYoIW5hbWV8fG5hbWU9PT1cIi5cInx8bmFtZT09PVwiLi5cIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX12YXIgZXJyPUZTLm1heUNyZWF0ZShwYXJlbnQsbmFtZSk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfWlmKCFwYXJlbnQubm9kZV9vcHMubWtub2Qpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1yZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCxuYW1lLG1vZGUsZGV2KX0pLGNyZWF0ZTooZnVuY3Rpb24ocGF0aCxtb2RlKXttb2RlPW1vZGUhPT11bmRlZmluZWQ/bW9kZTo0Mzg7bW9kZSY9NDA5NTttb2RlfD0zMjc2ODtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLDApfSksbWtkaXI6KGZ1bmN0aW9uKHBhdGgsbW9kZSl7bW9kZT1tb2RlIT09dW5kZWZpbmVkP21vZGU6NTExO21vZGUmPTUxMXw1MTI7bW9kZXw9MTYzODQ7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSwwKX0pLG1rZGlyVHJlZTooZnVuY3Rpb24ocGF0aCxtb2RlKXt2YXIgZGlycz1wYXRoLnNwbGl0KFwiL1wiKTt2YXIgZD1cIlwiO2Zvcih2YXIgaT0wO2k8ZGlycy5sZW5ndGg7KytpKXtpZighZGlyc1tpXSljb250aW51ZTtkKz1cIi9cIitkaXJzW2ldO3RyeXtGUy5ta2RpcihkLG1vZGUpfWNhdGNoKGUpe2lmKGUuZXJybm8hPUVSUk5PX0NPREVTLkVFWElTVCl0aHJvdyBlfX19KSxta2RldjooZnVuY3Rpb24ocGF0aCxtb2RlLGRldil7aWYodHlwZW9mIGRldj09PVwidW5kZWZpbmVkXCIpe2Rldj1tb2RlO21vZGU9NDM4fW1vZGV8PTgxOTI7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSxkZXYpfSksc3ltbGluazooZnVuY3Rpb24ob2xkcGF0aCxuZXdwYXRoKXtpZighUEFUSC5yZXNvbHZlKG9sZHBhdGgpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpfXZhciBsb29rdXA9RlMubG9va3VwUGF0aChuZXdwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7aWYoIXBhcmVudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX12YXIgbmV3bmFtZT1QQVRILmJhc2VuYW1lKG5ld3BhdGgpO3ZhciBlcnI9RlMubWF5Q3JlYXRlKHBhcmVudCxuZXduYW1lKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9aWYoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9cmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCxuZXduYW1lLG9sZHBhdGgpfSkscmVuYW1lOihmdW5jdGlvbihvbGRfcGF0aCxuZXdfcGF0aCl7dmFyIG9sZF9kaXJuYW1lPVBBVEguZGlybmFtZShvbGRfcGF0aCk7dmFyIG5ld19kaXJuYW1lPVBBVEguZGlybmFtZShuZXdfcGF0aCk7dmFyIG9sZF9uYW1lPVBBVEguYmFzZW5hbWUob2xkX3BhdGgpO3ZhciBuZXdfbmFtZT1QQVRILmJhc2VuYW1lKG5ld19wYXRoKTt2YXIgbG9va3VwLG9sZF9kaXIsbmV3X2Rpcjt0cnl7bG9va3VwPUZTLmxvb2t1cFBhdGgob2xkX3BhdGgse3BhcmVudDp0cnVlfSk7b2xkX2Rpcj1sb29rdXAubm9kZTtsb29rdXA9RlMubG9va3VwUGF0aChuZXdfcGF0aCx7cGFyZW50OnRydWV9KTtuZXdfZGlyPWxvb2t1cC5ub2RlfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX1pZighb2xkX2Rpcnx8IW5ld19kaXIpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKTtpZihvbGRfZGlyLm1vdW50IT09bmV3X2Rpci5tb3VudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVhERVYpfXZhciBvbGRfbm9kZT1GUy5sb29rdXBOb2RlKG9sZF9kaXIsb2xkX25hbWUpO3ZhciByZWxhdGl2ZT1QQVRILnJlbGF0aXZlKG9sZF9wYXRoLG5ld19kaXJuYW1lKTtpZihyZWxhdGl2ZS5jaGFyQXQoMCkhPT1cIi5cIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1yZWxhdGl2ZT1QQVRILnJlbGF0aXZlKG5ld19wYXRoLG9sZF9kaXJuYW1lKTtpZihyZWxhdGl2ZS5jaGFyQXQoMCkhPT1cIi5cIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVEVNUFRZKX12YXIgbmV3X25vZGU7dHJ5e25ld19ub2RlPUZTLmxvb2t1cE5vZGUobmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7fWlmKG9sZF9ub2RlPT09bmV3X25vZGUpe3JldHVybn12YXIgaXNkaXI9RlMuaXNEaXIob2xkX25vZGUubW9kZSk7dmFyIGVycj1GUy5tYXlEZWxldGUob2xkX2RpcixvbGRfbmFtZSxpc2Rpcik7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfWVycj1uZXdfbm9kZT9GUy5tYXlEZWxldGUobmV3X2RpcixuZXdfbmFtZSxpc2Rpcik6RlMubWF5Q3JlYXRlKG5ld19kaXIsbmV3X25hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX1pZighb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1pZihGUy5pc01vdW50cG9pbnQob2xkX25vZGUpfHxuZXdfbm9kZSYmRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfWlmKG5ld19kaXIhPT1vbGRfZGlyKXtlcnI9RlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsXCJ3XCIpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX19dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbXCJ3aWxsTW92ZVBhdGhcIl0pe0ZTLnRyYWNraW5nRGVsZWdhdGVbXCJ3aWxsTW92ZVBhdGhcIl0ob2xkX3BhdGgsbmV3X3BhdGgpfX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxNb3ZlUGF0aCddKCdcIitvbGRfcGF0aCtcIicsICdcIituZXdfcGF0aCtcIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlKX1GUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7dHJ5e29sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLG5ld19kaXIsbmV3X25hbWUpfWNhdGNoKGUpe3Rocm93IGV9ZmluYWxseXtGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSl9dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbk1vdmVQYXRoXCJdKUZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbk1vdmVQYXRoXCJdKG9sZF9wYXRoLG5ld19wYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uTW92ZVBhdGgnXSgnXCIrb2xkX3BhdGgrXCInLCAnXCIrbmV3X3BhdGgrXCInKSB0aHJldyBhbiBleGNlcHRpb246IFwiK2UubWVzc2FnZSl9fSkscm1kaXI6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTt2YXIgZXJyPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSx0cnVlKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9aWYoIXBhcmVudC5ub2RlX29wcy5ybWRpcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfWlmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfXRyeXtpZihGUy50cmFja2luZ0RlbGVnYXRlW1wid2lsbERlbGV0ZVBhdGhcIl0pe0ZTLnRyYWNraW5nRGVsZWdhdGVbXCJ3aWxsRGVsZXRlUGF0aFwiXShwYXRoKX19Y2F0Y2goZSl7Y29uc29sZS5sb2coXCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKCdcIitwYXRoK1wiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiBcIitlLm1lc3NhZ2UpfXBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsbmFtZSk7RlMuZGVzdHJveU5vZGUobm9kZSk7dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbkRlbGV0ZVBhdGhcIl0pRlMudHJhY2tpbmdEZWxlZ2F0ZVtcIm9uRGVsZXRlUGF0aFwiXShwYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uRGVsZXRlUGF0aCddKCdcIitwYXRoK1wiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiBcIitlLm1lc3NhZ2UpfX0pLHJlYWRkaXI6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO3ZhciBub2RlPWxvb2t1cC5ub2RlO2lmKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpfXJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSl9KSx1bmxpbms6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTt2YXIgZXJyPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSxmYWxzZSk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfWlmKCFwYXJlbnQubm9kZV9vcHMudW5saW5rKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9aWYoRlMuaXNNb3VudHBvaW50KG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSl9dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbXCJ3aWxsRGVsZXRlUGF0aFwiXSl7RlMudHJhY2tpbmdEZWxlZ2F0ZVtcIndpbGxEZWxldGVQYXRoXCJdKHBhdGgpfX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxEZWxldGVQYXRoJ10oJ1wiK3BhdGgrXCInKSB0aHJldyBhbiBleGNlcHRpb246IFwiK2UubWVzc2FnZSl9cGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsbmFtZSk7RlMuZGVzdHJveU5vZGUobm9kZSk7dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbkRlbGV0ZVBhdGhcIl0pRlMudHJhY2tpbmdEZWxlZ2F0ZVtcIm9uRGVsZXRlUGF0aFwiXShwYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uRGVsZXRlUGF0aCddKCdcIitwYXRoK1wiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiBcIitlLm1lc3NhZ2UpfX0pLHJlYWRsaW5rOihmdW5jdGlvbihwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCk7dmFyIGxpbms9bG9va3VwLm5vZGU7aWYoIWxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9aWYoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9cmV0dXJuIFBBVEgucmVzb2x2ZShGUy5nZXRQYXRoKGxpbmsucGFyZW50KSxsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspKX0pLHN0YXQ6KGZ1bmN0aW9uKHBhdGgsZG9udEZvbGxvdyl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO3ZhciBub2RlPWxvb2t1cC5ub2RlO2lmKCFub2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpfWlmKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1yZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpfSksbHN0YXQ6KGZ1bmN0aW9uKHBhdGgpe3JldHVybiBGUy5zdGF0KHBhdGgsdHJ1ZSl9KSxjaG1vZDooZnVuY3Rpb24ocGF0aCxtb2RlLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09XCJzdHJpbmdcIil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO25vZGU9bG9va3VwLm5vZGV9ZWxzZXtub2RlPXBhdGh9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfW5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHttb2RlOm1vZGUmNDA5NXxub2RlLm1vZGUmfjQwOTUsdGltZXN0YW1wOkRhdGUubm93KCl9KX0pLGxjaG1vZDooZnVuY3Rpb24ocGF0aCxtb2RlKXtGUy5jaG1vZChwYXRoLG1vZGUsdHJ1ZSl9KSxmY2htb2Q6KGZ1bmN0aW9uKGZkLG1vZGUpe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtKGZkKTtpZighc3RyZWFtKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9RlMuY2htb2Qoc3RyZWFtLm5vZGUsbW9kZSl9KSxjaG93bjooZnVuY3Rpb24ocGF0aCx1aWQsZ2lkLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09XCJzdHJpbmdcIil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO25vZGU9bG9va3VwLm5vZGV9ZWxzZXtub2RlPXBhdGh9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfW5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHt0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSksbGNob3duOihmdW5jdGlvbihwYXRoLHVpZCxnaWQpe0ZTLmNob3duKHBhdGgsdWlkLGdpZCx0cnVlKX0pLGZjaG93bjooZnVuY3Rpb24oZmQsdWlkLGdpZCl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1GUy5jaG93bihzdHJlYW0ubm9kZSx1aWQsZ2lkKX0pLHRydW5jYXRlOihmdW5jdGlvbihwYXRoLGxlbil7aWYobGVuPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PT1cInN0cmluZ1wiKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTtub2RlPWxvb2t1cC5ub2RlfWVsc2V7bm9kZT1wYXRofWlmKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX1pZihGUy5pc0Rpcihub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpfWlmKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX12YXIgZXJyPUZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLFwid1wiKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3NpemU6bGVuLHRpbWVzdGFtcDpEYXRlLm5vdygpfSl9KSxmdHJ1bmNhdGU6KGZ1bmN0aW9uKGZkLGxlbil7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1pZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1GUy50cnVuY2F0ZShzdHJlYW0ubm9kZSxsZW4pfSksdXRpbWU6KGZ1bmN0aW9uKHBhdGgsYXRpbWUsbXRpbWUpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO3ZhciBub2RlPWxvb2t1cC5ub2RlO25vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHt0aW1lc3RhbXA6TWF0aC5tYXgoYXRpbWUsbXRpbWUpfSl9KSxvcGVuOihmdW5jdGlvbihwYXRoLGZsYWdzLG1vZGUsZmRfc3RhcnQsZmRfZW5kKXtpZihwYXRoPT09XCJcIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX1mbGFncz10eXBlb2YgZmxhZ3M9PT1cInN0cmluZ1wiP0ZTLm1vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKTpmbGFnczttb2RlPXR5cGVvZiBtb2RlPT09XCJ1bmRlZmluZWRcIj80Mzg6bW9kZTtpZihmbGFncyY2NCl7bW9kZT1tb2RlJjQwOTV8MzI3Njh9ZWxzZXttb2RlPTB9dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PT1cIm9iamVjdFwiKXtub2RlPXBhdGh9ZWxzZXtwYXRoPVBBVEgubm9ybWFsaXplKHBhdGgpO3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiEoZmxhZ3MmMTMxMDcyKX0pO25vZGU9bG9va3VwLm5vZGV9Y2F0Y2goZSl7fX12YXIgY3JlYXRlZD1mYWxzZTtpZihmbGFncyY2NCl7aWYobm9kZSl7aWYoZmxhZ3MmMTI4KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FRVhJU1QpfX1lbHNle25vZGU9RlMubWtub2QocGF0aCxtb2RlLDApO2NyZWF0ZWQ9dHJ1ZX19aWYoIW5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9aWYoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSl7ZmxhZ3MmPX41MTJ9aWYoZmxhZ3MmNjU1MzYmJiFGUy5pc0Rpcihub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URElSKX1pZighY3JlYXRlZCl7dmFyIGVycj1GUy5tYXlPcGVuKG5vZGUsZmxhZ3MpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX19aWYoZmxhZ3MmNTEyKXtGUy50cnVuY2F0ZShub2RlLDApfWZsYWdzJj1+KDEyOHw1MTIpO3ZhciBzdHJlYW09RlMuY3JlYXRlU3RyZWFtKHtub2RlOm5vZGUscGF0aDpGUy5nZXRQYXRoKG5vZGUpLGZsYWdzOmZsYWdzLHNlZWthYmxlOnRydWUscG9zaXRpb246MCxzdHJlYW1fb3BzOm5vZGUuc3RyZWFtX29wcyx1bmdvdHRlbjpbXSxlcnJvcjpmYWxzZX0sZmRfc3RhcnQsZmRfZW5kKTtpZihzdHJlYW0uc3RyZWFtX29wcy5vcGVuKXtzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSl9aWYoTW9kdWxlW1wibG9nUmVhZEZpbGVzXCJdJiYhKGZsYWdzJjEpKXtpZighRlMucmVhZEZpbGVzKUZTLnJlYWRGaWxlcz17fTtpZighKHBhdGggaW4gRlMucmVhZEZpbGVzKSl7RlMucmVhZEZpbGVzW3BhdGhdPTE7TW9kdWxlW1wicHJpbnRFcnJcIl0oXCJyZWFkIGZpbGU6IFwiK3BhdGgpfX10cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZVtcIm9uT3BlbkZpbGVcIl0pe3ZhciB0cmFja2luZ0ZsYWdzPTA7aWYoKGZsYWdzJjIwOTcxNTUpIT09MSl7dHJhY2tpbmdGbGFnc3w9RlMudHJhY2tpbmcub3BlbkZsYWdzLlJFQUR9aWYoKGZsYWdzJjIwOTcxNTUpIT09MCl7dHJhY2tpbmdGbGFnc3w9RlMudHJhY2tpbmcub3BlbkZsYWdzLldSSVRFfUZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbk9wZW5GaWxlXCJdKHBhdGgsdHJhY2tpbmdGbGFncyl9fWNhdGNoKGUpe2NvbnNvbGUubG9nKFwiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25PcGVuRmlsZSddKCdcIitwYXRoK1wiJywgZmxhZ3MpIHRocmV3IGFuIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlKX1yZXR1cm4gc3RyZWFtfSksY2xvc2U6KGZ1bmN0aW9uKHN0cmVhbSl7aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKHN0cmVhbS5nZXRkZW50cylzdHJlYW0uZ2V0ZGVudHM9bnVsbDt0cnl7aWYoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Upe3N0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSl9fWNhdGNoKGUpe3Rocm93IGV9ZmluYWxseXtGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpfXN0cmVhbS5mZD1udWxsfSksaXNDbG9zZWQ6KGZ1bmN0aW9uKHN0cmVhbSl7cmV0dXJuIHN0cmVhbS5mZD09PW51bGx9KSxsbHNlZWs6KGZ1bmN0aW9uKHN0cmVhbSxvZmZzZXQsd2hlbmNlKXtpZihGUy5pc0Nsb3NlZChzdHJlYW0pKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoIXN0cmVhbS5zZWVrYWJsZXx8IXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX1zdHJlYW0ucG9zaXRpb249c3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSxvZmZzZXQsd2hlbmNlKTtzdHJlYW0udW5nb3R0ZW49W107cmV0dXJuIHN0cmVhbS5wb3NpdGlvbn0pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7aWYobGVuZ3RoPDB8fHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0xKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUil9aWYoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9dmFyIHNlZWtpbmc9dHlwZW9mIHBvc2l0aW9uIT09XCJ1bmRlZmluZWRcIjtpZighc2Vla2luZyl7cG9zaXRpb249c3RyZWFtLnBvc2l0aW9ufWVsc2UgaWYoIXN0cmVhbS5zZWVrYWJsZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX12YXIgYnl0ZXNSZWFkPXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKTtpZighc2Vla2luZylzdHJlYW0ucG9zaXRpb24rPWJ5dGVzUmVhZDtyZXR1cm4gYnl0ZXNSZWFkfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixjYW5Pd24pe2lmKGxlbmd0aDwwfHxwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfWlmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX1pZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1pZihzdHJlYW0uZmxhZ3MmMTAyNCl7RlMubGxzZWVrKHN0cmVhbSwwLDIpfXZhciBzZWVraW5nPXR5cGVvZiBwb3NpdGlvbiE9PVwidW5kZWZpbmVkXCI7aWYoIXNlZWtpbmcpe3Bvc2l0aW9uPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKCFzdHJlYW0uc2Vla2FibGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSl9dmFyIGJ5dGVzV3JpdHRlbj1zdHJlYW0uc3RyZWFtX29wcy53cml0ZShzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKTtpZighc2Vla2luZylzdHJlYW0ucG9zaXRpb24rPWJ5dGVzV3JpdHRlbjt0cnl7aWYoc3RyZWFtLnBhdGgmJkZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbldyaXRlVG9GaWxlXCJdKUZTLnRyYWNraW5nRGVsZWdhdGVbXCJvbldyaXRlVG9GaWxlXCJdKHN0cmVhbS5wYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZyhcIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uV3JpdGVUb0ZpbGUnXSgnXCIrcGF0aCtcIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlKX1yZXR1cm4gYnl0ZXNXcml0dGVufSksYWxsb2NhdGU6KGZ1bmN0aW9uKHN0cmVhbSxvZmZzZXQsbGVuZ3RoKXtpZihGUy5pc0Nsb3NlZChzdHJlYW0pKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9aWYob2Zmc2V0PDB8fGxlbmd0aDw9MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX1pZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfWlmKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkmJiFGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKX1pZighc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVPUE5PVFNVUFApfXN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSxvZmZzZXQsbGVuZ3RoKX0pLG1tYXA6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUFDQ0VTKX1pZighc3RyZWFtLnN0cmVhbV9vcHMubW1hcCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKX1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl9KSxtc3luYzooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl7aWYoIXN0cmVhbXx8IXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKXtyZXR1cm4gMH1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl9KSxtdW5tYXA6KGZ1bmN0aW9uKHN0cmVhbSl7cmV0dXJuIDB9KSxpb2N0bDooZnVuY3Rpb24oc3RyZWFtLGNtZCxhcmcpe2lmKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVFRZKX1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLGNtZCxhcmcpfSkscmVhZEZpbGU6KGZ1bmN0aW9uKHBhdGgsb3B0cyl7b3B0cz1vcHRzfHx7fTtvcHRzLmZsYWdzPW9wdHMuZmxhZ3N8fFwiclwiO29wdHMuZW5jb2Rpbmc9b3B0cy5lbmNvZGluZ3x8XCJiaW5hcnlcIjtpZihvcHRzLmVuY29kaW5nIT09XCJ1dGY4XCImJm9wdHMuZW5jb2RpbmchPT1cImJpbmFyeVwiKXt0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSBcIicrb3B0cy5lbmNvZGluZysnXCInKX12YXIgcmV0O3ZhciBzdHJlYW09RlMub3BlbihwYXRoLG9wdHMuZmxhZ3MpO3ZhciBzdGF0PUZTLnN0YXQocGF0aCk7dmFyIGxlbmd0aD1zdGF0LnNpemU7dmFyIGJ1Zj1uZXcgVWludDhBcnJheShsZW5ndGgpO0ZTLnJlYWQoc3RyZWFtLGJ1ZiwwLGxlbmd0aCwwKTtpZihvcHRzLmVuY29kaW5nPT09XCJ1dGY4XCIpe3JldD1VVEY4QXJyYXlUb1N0cmluZyhidWYsMCl9ZWxzZSBpZihvcHRzLmVuY29kaW5nPT09XCJiaW5hcnlcIil7cmV0PWJ1Zn1GUy5jbG9zZShzdHJlYW0pO3JldHVybiByZXR9KSx3cml0ZUZpbGU6KGZ1bmN0aW9uKHBhdGgsZGF0YSxvcHRzKXtvcHRzPW9wdHN8fHt9O29wdHMuZmxhZ3M9b3B0cy5mbGFnc3x8XCJ3XCI7dmFyIHN0cmVhbT1GUy5vcGVuKHBhdGgsb3B0cy5mbGFncyxvcHRzLm1vZGUpO2lmKHR5cGVvZiBkYXRhPT09XCJzdHJpbmdcIil7dmFyIGJ1Zj1uZXcgVWludDhBcnJheShsZW5ndGhCeXRlc1VURjgoZGF0YSkrMSk7dmFyIGFjdHVhbE51bUJ5dGVzPXN0cmluZ1RvVVRGOEFycmF5KGRhdGEsYnVmLDAsYnVmLmxlbmd0aCk7RlMud3JpdGUoc3RyZWFtLGJ1ZiwwLGFjdHVhbE51bUJ5dGVzLHVuZGVmaW5lZCxvcHRzLmNhbk93bil9ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpe0ZTLndyaXRlKHN0cmVhbSxkYXRhLDAsZGF0YS5ieXRlTGVuZ3RoLHVuZGVmaW5lZCxvcHRzLmNhbk93bil9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGVcIil9RlMuY2xvc2Uoc3RyZWFtKX0pLGN3ZDooZnVuY3Rpb24oKXtyZXR1cm4gRlMuY3VycmVudFBhdGh9KSxjaGRpcjooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7aWYobG9va3VwLm5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpfWlmKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9dmFyIGVycj1GUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsXCJ4XCIpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX1GUy5jdXJyZW50UGF0aD1sb29rdXAucGF0aH0pLGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczooZnVuY3Rpb24oKXtGUy5ta2RpcihcIi90bXBcIik7RlMubWtkaXIoXCIvaG9tZVwiKTtGUy5ta2RpcihcIi9ob21lL3dlYl91c2VyXCIpfSksY3JlYXRlRGVmYXVsdERldmljZXM6KGZ1bmN0aW9uKCl7RlMubWtkaXIoXCIvZGV2XCIpO0ZTLnJlZ2lzdGVyRGV2aWNlKEZTLm1ha2VkZXYoMSwzKSx7cmVhZDooZnVuY3Rpb24oKXtyZXR1cm4gMH0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtyZXR1cm4gbGVuZ3RofSl9KTtGUy5ta2RldihcIi9kZXYvbnVsbFwiLEZTLm1ha2VkZXYoMSwzKSk7VFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwwKSxUVFkuZGVmYXVsdF90dHlfb3BzKTtUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LDApLFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtGUy5ta2RldihcIi9kZXYvdHR5XCIsRlMubWFrZWRldig1LDApKTtGUy5ta2RldihcIi9kZXYvdHR5MVwiLEZTLm1ha2VkZXYoNiwwKSk7dmFyIHJhbmRvbV9kZXZpY2U7aWYodHlwZW9mIGNyeXB0byE9PVwidW5kZWZpbmVkXCIpe3ZhciByYW5kb21CdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMSk7cmFuZG9tX2RldmljZT0oZnVuY3Rpb24oKXtjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7cmV0dXJuIHJhbmRvbUJ1ZmZlclswXX0pfWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7cmFuZG9tX2RldmljZT0oZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWlyZShcImNyeXB0b1wiKVtcInJhbmRvbUJ5dGVzXCJdKDEpWzBdfSl9ZWxzZXtyYW5kb21fZGV2aWNlPShmdW5jdGlvbigpe3JldHVybiBNYXRoLnJhbmRvbSgpKjI1NnwwfSl9RlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLFwicmFuZG9tXCIscmFuZG9tX2RldmljZSk7RlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLFwidXJhbmRvbVwiLHJhbmRvbV9kZXZpY2UpO0ZTLm1rZGlyKFwiL2Rldi9zaG1cIik7RlMubWtkaXIoXCIvZGV2L3NobS90bXBcIil9KSxjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXM6KGZ1bmN0aW9uKCl7RlMubWtkaXIoXCIvcHJvY1wiKTtGUy5ta2RpcihcIi9wcm9jL3NlbGZcIik7RlMubWtkaXIoXCIvcHJvYy9zZWxmL2ZkXCIpO0ZTLm1vdW50KHttb3VudDooZnVuY3Rpb24oKXt2YXIgbm9kZT1GUy5jcmVhdGVOb2RlKFwiL3Byb2Mvc2VsZlwiLFwiZmRcIiwxNjM4NHw1MTEsNzMpO25vZGUubm9kZV9vcHM9e2xvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3ZhciBmZD0rbmFtZTt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShmZCk7aWYoIXN0cmVhbSl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERik7dmFyIHJldD17cGFyZW50Om51bGwsbW91bnQ6e21vdW50cG9pbnQ6XCJmYWtlXCJ9LG5vZGVfb3BzOntyZWFkbGluazooZnVuY3Rpb24oKXtyZXR1cm4gc3RyZWFtLnBhdGh9KX19O3JldC5wYXJlbnQ9cmV0O3JldHVybiByZXR9KX07cmV0dXJuIG5vZGV9KX0se30sXCIvcHJvYy9zZWxmL2ZkXCIpfSksY3JlYXRlU3RhbmRhcmRTdHJlYW1zOihmdW5jdGlvbigpe2lmKE1vZHVsZVtcInN0ZGluXCJdKXtGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsXCJzdGRpblwiLE1vZHVsZVtcInN0ZGluXCJdKX1lbHNle0ZTLnN5bWxpbmsoXCIvZGV2L3R0eVwiLFwiL2Rldi9zdGRpblwiKX1pZihNb2R1bGVbXCJzdGRvdXRcIl0pe0ZTLmNyZWF0ZURldmljZShcIi9kZXZcIixcInN0ZG91dFwiLG51bGwsTW9kdWxlW1wic3Rkb3V0XCJdKX1lbHNle0ZTLnN5bWxpbmsoXCIvZGV2L3R0eVwiLFwiL2Rldi9zdGRvdXRcIil9aWYoTW9kdWxlW1wic3RkZXJyXCJdKXtGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsXCJzdGRlcnJcIixudWxsLE1vZHVsZVtcInN0ZGVyclwiXSl9ZWxzZXtGUy5zeW1saW5rKFwiL2Rldi90dHkxXCIsXCIvZGV2L3N0ZGVyclwiKX12YXIgc3RkaW49RlMub3BlbihcIi9kZXYvc3RkaW5cIixcInJcIik7YXNzZXJ0KHN0ZGluLmZkPT09MCxcImludmFsaWQgaGFuZGxlIGZvciBzdGRpbiAoXCIrc3RkaW4uZmQrXCIpXCIpO3ZhciBzdGRvdXQ9RlMub3BlbihcIi9kZXYvc3Rkb3V0XCIsXCJ3XCIpO2Fzc2VydChzdGRvdXQuZmQ9PT0xLFwiaW52YWxpZCBoYW5kbGUgZm9yIHN0ZG91dCAoXCIrc3Rkb3V0LmZkK1wiKVwiKTt2YXIgc3RkZXJyPUZTLm9wZW4oXCIvZGV2L3N0ZGVyclwiLFwid1wiKTthc3NlcnQoc3RkZXJyLmZkPT09MixcImludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKFwiK3N0ZGVyci5mZCtcIilcIil9KSxlbnN1cmVFcnJub0Vycm9yOihmdW5jdGlvbigpe2lmKEZTLkVycm5vRXJyb3IpcmV0dXJuO0ZTLkVycm5vRXJyb3I9ZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubyxub2RlKXt0aGlzLm5vZGU9bm9kZTt0aGlzLnNldEVycm5vPShmdW5jdGlvbihlcnJubyl7dGhpcy5lcnJubz1lcnJubztmb3IodmFyIGtleSBpbiBFUlJOT19DT0RFUyl7aWYoRVJSTk9fQ09ERVNba2V5XT09PWVycm5vKXt0aGlzLmNvZGU9a2V5O2JyZWFrfX19KTt0aGlzLnNldEVycm5vKGVycm5vKTt0aGlzLm1lc3NhZ2U9RVJSTk9fTUVTU0FHRVNbZXJybm9dO2lmKHRoaXMuc3RhY2spT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzdGFja1wiLHt2YWx1ZToobmV3IEVycm9yKS5zdGFjayx3cml0YWJsZTp0cnVlfSl9O0ZTLkVycm5vRXJyb3IucHJvdG90eXBlPW5ldyBFcnJvcjtGUy5FcnJub0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1GUy5FcnJub0Vycm9yO1tFUlJOT19DT0RFUy5FTk9FTlRdLmZvckVhY2goKGZ1bmN0aW9uKGNvZGUpe0ZTLmdlbmVyaWNFcnJvcnNbY29kZV09bmV3IEZTLkVycm5vRXJyb3IoY29kZSk7RlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjaz1cIjxnZW5lcmljIGVycm9yLCBubyBzdGFjaz5cIn0pKX0pLHN0YXRpY0luaXQ6KGZ1bmN0aW9uKCl7RlMuZW5zdXJlRXJybm9FcnJvcigpO0ZTLm5hbWVUYWJsZT1uZXcgQXJyYXkoNDA5Nik7RlMubW91bnQoTUVNRlMse30sXCIvXCIpO0ZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO0ZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7RlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7RlMuZmlsZXN5c3RlbXM9e1wiTUVNRlNcIjpNRU1GUyxcIklEQkZTXCI6SURCRlMsXCJOT0RFRlNcIjpOT0RFRlMsXCJXT1JLRVJGU1wiOldPUktFUkZTfX0pLGluaXQ6KGZ1bmN0aW9uKGlucHV0LG91dHB1dCxlcnJvcil7YXNzZXJ0KCFGUy5pbml0LmluaXRpYWxpemVkLFwiRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKVwiKTtGUy5pbml0LmluaXRpYWxpemVkPXRydWU7RlMuZW5zdXJlRXJybm9FcnJvcigpO01vZHVsZVtcInN0ZGluXCJdPWlucHV0fHxNb2R1bGVbXCJzdGRpblwiXTtNb2R1bGVbXCJzdGRvdXRcIl09b3V0cHV0fHxNb2R1bGVbXCJzdGRvdXRcIl07TW9kdWxlW1wic3RkZXJyXCJdPWVycm9yfHxNb2R1bGVbXCJzdGRlcnJcIl07RlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl9KSxxdWl0OihmdW5jdGlvbigpe0ZTLmluaXQuaW5pdGlhbGl6ZWQ9ZmFsc2U7dmFyIGZmbHVzaD1Nb2R1bGVbXCJfZmZsdXNoXCJdO2lmKGZmbHVzaClmZmx1c2goMCk7Zm9yKHZhciBpPTA7aTxGUy5zdHJlYW1zLmxlbmd0aDtpKyspe3ZhciBzdHJlYW09RlMuc3RyZWFtc1tpXTtpZighc3RyZWFtKXtjb250aW51ZX1GUy5jbG9zZShzdHJlYW0pfX0pLGdldE1vZGU6KGZ1bmN0aW9uKGNhblJlYWQsY2FuV3JpdGUpe3ZhciBtb2RlPTA7aWYoY2FuUmVhZCltb2RlfD0yOTJ8NzM7aWYoY2FuV3JpdGUpbW9kZXw9MTQ2O3JldHVybiBtb2RlfSksam9pblBhdGg6KGZ1bmN0aW9uKHBhcnRzLGZvcmNlUmVsYXRpdmUpe3ZhciBwYXRoPVBBVEguam9pbi5hcHBseShudWxsLHBhcnRzKTtpZihmb3JjZVJlbGF0aXZlJiZwYXRoWzBdPT1cIi9cIilwYXRoPXBhdGguc3Vic3RyKDEpO3JldHVybiBwYXRofSksYWJzb2x1dGVQYXRoOihmdW5jdGlvbihyZWxhdGl2ZSxiYXNlKXtyZXR1cm4gUEFUSC5yZXNvbHZlKGJhc2UscmVsYXRpdmUpfSksc3RhbmRhcmRpemVQYXRoOihmdW5jdGlvbihwYXRoKXtyZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aCl9KSxmaW5kT2JqZWN0OihmdW5jdGlvbihwYXRoLGRvbnRSZXNvbHZlTGFzdExpbmspe3ZhciByZXQ9RlMuYW5hbHl6ZVBhdGgocGF0aCxkb250UmVzb2x2ZUxhc3RMaW5rKTtpZihyZXQuZXhpc3RzKXtyZXR1cm4gcmV0Lm9iamVjdH1lbHNle19fX3NldEVyck5vKHJldC5lcnJvcik7cmV0dXJuIG51bGx9fSksYW5hbHl6ZVBhdGg6KGZ1bmN0aW9uKHBhdGgsZG9udFJlc29sdmVMYXN0TGluayl7dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRSZXNvbHZlTGFzdExpbmt9KTtwYXRoPWxvb2t1cC5wYXRofWNhdGNoKGUpe312YXIgcmV0PXtpc1Jvb3Q6ZmFsc2UsZXhpc3RzOmZhbHNlLGVycm9yOjAsbmFtZTpudWxsLHBhdGg6bnVsbCxvYmplY3Q6bnVsbCxwYXJlbnRFeGlzdHM6ZmFsc2UscGFyZW50UGF0aDpudWxsLHBhcmVudE9iamVjdDpudWxsfTt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDp0cnVlfSk7cmV0LnBhcmVudEV4aXN0cz10cnVlO3JldC5wYXJlbnRQYXRoPWxvb2t1cC5wYXRoO3JldC5wYXJlbnRPYmplY3Q9bG9va3VwLm5vZGU7cmV0Lm5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTtsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRSZXNvbHZlTGFzdExpbmt9KTtyZXQuZXhpc3RzPXRydWU7cmV0LnBhdGg9bG9va3VwLnBhdGg7cmV0Lm9iamVjdD1sb29rdXAubm9kZTtyZXQubmFtZT1sb29rdXAubm9kZS5uYW1lO3JldC5pc1Jvb3Q9bG9va3VwLnBhdGg9PT1cIi9cIn1jYXRjaChlKXtyZXQuZXJyb3I9ZS5lcnJub31yZXR1cm4gcmV0fSksY3JlYXRlRm9sZGVyOihmdW5jdGlvbihwYXJlbnQsbmFtZSxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7dmFyIG1vZGU9RlMuZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTtyZXR1cm4gRlMubWtkaXIocGF0aCxtb2RlKX0pLGNyZWF0ZVBhdGg6KGZ1bmN0aW9uKHBhcmVudCxwYXRoLGNhblJlYWQsY2FuV3JpdGUpe3BhcmVudD10eXBlb2YgcGFyZW50PT09XCJzdHJpbmdcIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpO3ZhciBwYXJ0cz1wYXRoLnNwbGl0KFwiL1wiKS5yZXZlcnNlKCk7d2hpbGUocGFydHMubGVuZ3RoKXt2YXIgcGFydD1wYXJ0cy5wb3AoKTtpZighcGFydCljb250aW51ZTt2YXIgY3VycmVudD1QQVRILmpvaW4yKHBhcmVudCxwYXJ0KTt0cnl7RlMubWtkaXIoY3VycmVudCl9Y2F0Y2goZSl7fXBhcmVudD1jdXJyZW50fXJldHVybiBjdXJyZW50fSksY3JlYXRlRmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUscHJvcGVydGllcyxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7dmFyIG1vZGU9RlMuZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTtyZXR1cm4gRlMuY3JlYXRlKHBhdGgsbW9kZSl9KSxjcmVhdGVEYXRhRmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsZGF0YSxjYW5SZWFkLGNhbldyaXRlLGNhbk93bil7dmFyIHBhdGg9bmFtZT9QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk6cGFyZW50O3ZhciBtb2RlPUZTLmdldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7dmFyIG5vZGU9RlMuY3JlYXRlKHBhdGgsbW9kZSk7aWYoZGF0YSl7aWYodHlwZW9mIGRhdGE9PT1cInN0cmluZ1wiKXt2YXIgYXJyPW5ldyBBcnJheShkYXRhLmxlbmd0aCk7Zm9yKHZhciBpPTAsbGVuPWRhdGEubGVuZ3RoO2k8bGVuOysraSlhcnJbaV09ZGF0YS5jaGFyQ29kZUF0KGkpO2RhdGE9YXJyfUZTLmNobW9kKG5vZGUsbW9kZXwxNDYpO3ZhciBzdHJlYW09RlMub3Blbihub2RlLFwid1wiKTtGUy53cml0ZShzdHJlYW0sZGF0YSwwLGRhdGEubGVuZ3RoLDAsY2FuT3duKTtGUy5jbG9zZShzdHJlYW0pO0ZTLmNobW9kKG5vZGUsbW9kZSl9cmV0dXJuIG5vZGV9KSxjcmVhdGVEZXZpY2U6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLGlucHV0LG91dHB1dCl7dmFyIHBhdGg9UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT09XCJzdHJpbmdcIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPUZTLmdldE1vZGUoISFpbnB1dCwhIW91dHB1dCk7aWYoIUZTLmNyZWF0ZURldmljZS5tYWpvcilGUy5jcmVhdGVEZXZpY2UubWFqb3I9NjQ7dmFyIGRldj1GUy5tYWtlZGV2KEZTLmNyZWF0ZURldmljZS5tYWpvcisrLDApO0ZTLnJlZ2lzdGVyRGV2aWNlKGRldix7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXtzdHJlYW0uc2Vla2FibGU9ZmFsc2V9KSxjbG9zZTooZnVuY3Rpb24oc3RyZWFtKXtpZihvdXRwdXQmJm91dHB1dC5idWZmZXImJm91dHB1dC5idWZmZXIubGVuZ3RoKXtvdXRwdXQoMTApfX0pLHJlYWQ6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe3ZhciBieXRlc1JlYWQ9MDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciByZXN1bHQ7dHJ5e3Jlc3VsdD1pbnB1dCgpfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9aWYocmVzdWx0PT09dW5kZWZpbmVkJiZieXRlc1JlYWQ9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQUdBSU4pfWlmKHJlc3VsdD09PW51bGx8fHJlc3VsdD09PXVuZGVmaW5lZClicmVhaztieXRlc1JlYWQrKztidWZmZXJbb2Zmc2V0K2ldPXJlc3VsdH1pZihieXRlc1JlYWQpe3N0cmVhbS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpfXJldHVybiBieXRlc1JlYWR9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt0cnl7b3V0cHV0KGJ1ZmZlcltvZmZzZXQraV0pfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9fWlmKGxlbmd0aCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGl9KX0pO3JldHVybiBGUy5ta2RldihwYXRoLG1vZGUsZGV2KX0pLGNyZWF0ZUxpbms6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLHRhcmdldCxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7cmV0dXJuIEZTLnN5bWxpbmsodGFyZ2V0LHBhdGgpfSksZm9yY2VMb2FkRmlsZTooZnVuY3Rpb24ob2JqKXtpZihvYmouaXNEZXZpY2V8fG9iai5pc0ZvbGRlcnx8b2JqLmxpbmt8fG9iai5jb250ZW50cylyZXR1cm4gdHJ1ZTt2YXIgc3VjY2Vzcz10cnVlO2lmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCE9PVwidW5kZWZpbmVkXCIpe3Rocm93IG5ldyBFcnJvcihcIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLlwiKX1lbHNlIGlmKE1vZHVsZVtcInJlYWRcIl0pe3RyeXtvYmouY29udGVudHM9aW50QXJyYXlGcm9tU3RyaW5nKE1vZHVsZVtcInJlYWRcIl0ob2JqLnVybCksdHJ1ZSk7b2JqLnVzZWRCeXRlcz1vYmouY29udGVudHMubGVuZ3RofWNhdGNoKGUpe3N1Y2Nlc3M9ZmFsc2V9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGxvYWQgd2l0aG91dCByZWFkKCkgb3IgWE1MSHR0cFJlcXVlc3QuXCIpfWlmKCFzdWNjZXNzKV9fX3NldEVyck5vKEVSUk5PX0NPREVTLkVJTyk7cmV0dXJuIHN1Y2Nlc3N9KSxjcmVhdGVMYXp5RmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsdXJsLGNhblJlYWQsY2FuV3JpdGUpe2Z1bmN0aW9uIExhenlVaW50OEFycmF5KCl7dGhpcy5sZW5ndGhLbm93bj1mYWxzZTt0aGlzLmNodW5rcz1bXX1MYXp5VWludDhBcnJheS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uIExhenlVaW50OEFycmF5X2dldChpZHgpe2lmKGlkeD50aGlzLmxlbmd0aC0xfHxpZHg8MCl7cmV0dXJuIHVuZGVmaW5lZH12YXIgY2h1bmtPZmZzZXQ9aWR4JXRoaXMuY2h1bmtTaXplO3ZhciBjaHVua051bT1pZHgvdGhpcy5jaHVua1NpemV8MDtyZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XX07TGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldERhdGFHZXR0ZXI9ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlcihnZXR0ZXIpe3RoaXMuZ2V0dGVyPWdldHRlcn07TGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmNhY2hlTGVuZ3RoPWZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJIRUFEXCIsdXJsLGZhbHNlKTt4aHIuc2VuZChudWxsKTtpZighKHhoci5zdGF0dXM+PTIwMCYmeGhyLnN0YXR1czwzMDB8fHhoci5zdGF0dXM9PT0zMDQpKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGxvYWQgXCIrdXJsK1wiLiBTdGF0dXM6IFwiK3hoci5zdGF0dXMpO3ZhciBkYXRhbGVuZ3RoPU51bWJlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LWxlbmd0aFwiKSk7dmFyIGhlYWRlcjt2YXIgaGFzQnl0ZVNlcnZpbmc9KGhlYWRlcj14aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpKSYmaGVhZGVyPT09XCJieXRlc1wiO3ZhciB1c2VzR3ppcD0oaGVhZGVyPXhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikpJiZoZWFkZXI9PT1cImd6aXBcIjt2YXIgY2h1bmtTaXplPTEwMjQqMTAyNDtpZighaGFzQnl0ZVNlcnZpbmcpY2h1bmtTaXplPWRhdGFsZW5ndGg7dmFyIGRvWEhSPShmdW5jdGlvbihmcm9tLHRvKXtpZihmcm9tPnRvKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiK2Zyb20rXCIsIFwiK3RvK1wiKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhXCIpO2lmKHRvPmRhdGFsZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IFwiK2RhdGFsZW5ndGgrXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiKTt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7aWYoZGF0YWxlbmd0aCE9PWNodW5rU2l6ZSl4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsXCJieXRlcz1cIitmcm9tK1wiLVwiK3RvKTtpZih0eXBlb2YgVWludDhBcnJheSE9XCJ1bmRlZmluZWRcIil4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjtpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7eGhyLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpfXhoci5zZW5kKG51bGwpO2lmKCEoeGhyLnN0YXR1cz49MjAwJiZ4aHIuc3RhdHVzPDMwMHx8eGhyLnN0YXR1cz09PTMwNCkpdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIit1cmwrXCIuIFN0YXR1czogXCIreGhyLnN0YXR1cyk7aWYoeGhyLnJlc3BvbnNlIT09dW5kZWZpbmVkKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlfHxbXSl9ZWxzZXtyZXR1cm4gaW50QXJyYXlGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHR8fFwiXCIsdHJ1ZSl9fSk7dmFyIGxhenlBcnJheT10aGlzO2xhenlBcnJheS5zZXREYXRhR2V0dGVyKChmdW5jdGlvbihjaHVua051bSl7dmFyIHN0YXJ0PWNodW5rTnVtKmNodW5rU2l6ZTt2YXIgZW5kPShjaHVua051bSsxKSpjaHVua1NpemUtMTtlbmQ9TWF0aC5taW4oZW5kLGRhdGFsZW5ndGgtMSk7aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT09XCJ1bmRlZmluZWRcIil7bGF6eUFycmF5LmNodW5rc1tjaHVua051bV09ZG9YSFIoc3RhcnQsZW5kKX1pZih0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV09PT1cInVuZGVmaW5lZFwiKXRocm93IG5ldyBFcnJvcihcImRvWEhSIGZhaWxlZCFcIik7cmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dfSkpO2lmKHVzZXNHemlwfHwhZGF0YWxlbmd0aCl7Y2h1bmtTaXplPWRhdGFsZW5ndGg9MTtkYXRhbGVuZ3RoPXRoaXMuZ2V0dGVyKDApLmxlbmd0aDtjaHVua1NpemU9ZGF0YWxlbmd0aDtjb25zb2xlLmxvZyhcIkxhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZFwiKX10aGlzLl9sZW5ndGg9ZGF0YWxlbmd0aDt0aGlzLl9jaHVua1NpemU9Y2h1bmtTaXplO3RoaXMubGVuZ3RoS25vd249dHJ1ZX07aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT09XCJ1bmRlZmluZWRcIil7aWYoIUVOVklST05NRU5UX0lTX1dPUktFUil0aHJvd1wiQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jY1wiO3ZhciBsYXp5QXJyYXk9bmV3IExhenlVaW50OEFycmF5O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSx7bGVuZ3RoOntnZXQ6KGZ1bmN0aW9uKCl7aWYoIXRoaXMubGVuZ3RoS25vd24pe3RoaXMuY2FjaGVMZW5ndGgoKX1yZXR1cm4gdGhpcy5fbGVuZ3RofSl9LGNodW5rU2l6ZTp7Z2V0OihmdW5jdGlvbigpe2lmKCF0aGlzLmxlbmd0aEtub3duKXt0aGlzLmNhY2hlTGVuZ3RoKCl9cmV0dXJuIHRoaXMuX2NodW5rU2l6ZX0pfX0pO3ZhciBwcm9wZXJ0aWVzPXtpc0RldmljZTpmYWxzZSxjb250ZW50czpsYXp5QXJyYXl9fWVsc2V7dmFyIHByb3BlcnRpZXM9e2lzRGV2aWNlOmZhbHNlLHVybDp1cmx9fXZhciBub2RlPUZTLmNyZWF0ZUZpbGUocGFyZW50LG5hbWUscHJvcGVydGllcyxjYW5SZWFkLGNhbldyaXRlKTtpZihwcm9wZXJ0aWVzLmNvbnRlbnRzKXtub2RlLmNvbnRlbnRzPXByb3BlcnRpZXMuY29udGVudHN9ZWxzZSBpZihwcm9wZXJ0aWVzLnVybCl7bm9kZS5jb250ZW50cz1udWxsO25vZGUudXJsPXByb3BlcnRpZXMudXJsfU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUse3VzZWRCeXRlczp7Z2V0OihmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aH0pfX0pO3ZhciBzdHJlYW1fb3BzPXt9O3ZhciBrZXlzPU9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7a2V5cy5mb3JFYWNoKChmdW5jdGlvbihrZXkpe3ZhciBmbj1ub2RlLnN0cmVhbV9vcHNba2V5XTtzdHJlYW1fb3BzW2tleV09ZnVuY3Rpb24gZm9yY2VMb2FkTGF6eUZpbGUoKXtpZighRlMuZm9yY2VMb2FkRmlsZShub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX1yZXR1cm4gZm4uYXBwbHkobnVsbCxhcmd1bWVudHMpfX0pKTtzdHJlYW1fb3BzLnJlYWQ9ZnVuY3Rpb24gc3RyZWFtX29wc19yZWFkKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7aWYoIUZTLmZvcmNlTG9hZEZpbGUobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKHBvc2l0aW9uPj1jb250ZW50cy5sZW5ndGgpcmV0dXJuIDA7dmFyIHNpemU9TWF0aC5taW4oY29udGVudHMubGVuZ3RoLXBvc2l0aW9uLGxlbmd0aCk7YXNzZXJ0KHNpemU+PTApO2lmKGNvbnRlbnRzLnNsaWNlKXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzW3Bvc2l0aW9uK2ldfX1lbHNle2Zvcih2YXIgaT0wO2k8c2l6ZTtpKyspe2J1ZmZlcltvZmZzZXQraV09Y29udGVudHMuZ2V0KHBvc2l0aW9uK2kpfX1yZXR1cm4gc2l6ZX07bm9kZS5zdHJlYW1fb3BzPXN0cmVhbV9vcHM7cmV0dXJuIG5vZGV9KSxjcmVhdGVQcmVsb2FkZWRGaWxlOihmdW5jdGlvbihwYXJlbnQsbmFtZSx1cmwsY2FuUmVhZCxjYW5Xcml0ZSxvbmxvYWQsb25lcnJvcixkb250Q3JlYXRlRmlsZSxjYW5Pd24scHJlRmluaXNoKXtCcm93c2VyLmluaXQoKTt2YXIgZnVsbG5hbWU9bmFtZT9QQVRILnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsbmFtZSkpOnBhcmVudDt2YXIgZGVwPWdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koXCJjcCBcIitmdWxsbmFtZSk7ZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KXtmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KXtpZihwcmVGaW5pc2gpcHJlRmluaXNoKCk7aWYoIWRvbnRDcmVhdGVGaWxlKXtGUy5jcmVhdGVEYXRhRmlsZShwYXJlbnQsbmFtZSxieXRlQXJyYXksY2FuUmVhZCxjYW5Xcml0ZSxjYW5Pd24pfWlmKG9ubG9hZClvbmxvYWQoKTtyZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCl9dmFyIGhhbmRsZWQ9ZmFsc2U7TW9kdWxlW1wicHJlbG9hZFBsdWdpbnNcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocGx1Z2luKXtpZihoYW5kbGVkKXJldHVybjtpZihwbHVnaW5bXCJjYW5IYW5kbGVcIl0oZnVsbG5hbWUpKXtwbHVnaW5bXCJoYW5kbGVcIl0oYnl0ZUFycmF5LGZ1bGxuYW1lLGZpbmlzaCwoZnVuY3Rpb24oKXtpZihvbmVycm9yKW9uZXJyb3IoKTtyZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCl9KSk7aGFuZGxlZD10cnVlfX0pKTtpZighaGFuZGxlZClmaW5pc2goYnl0ZUFycmF5KX1hZGRSdW5EZXBlbmRlbmN5KGRlcCk7aWYodHlwZW9mIHVybD09XCJzdHJpbmdcIil7QnJvd3Nlci5hc3luY0xvYWQodXJsLChmdW5jdGlvbihieXRlQXJyYXkpe3Byb2Nlc3NEYXRhKGJ5dGVBcnJheSl9KSxvbmVycm9yKX1lbHNle3Byb2Nlc3NEYXRhKHVybCl9fSksaW5kZXhlZERCOihmdW5jdGlvbigpe3JldHVybiB3aW5kb3cuaW5kZXhlZERCfHx3aW5kb3cubW96SW5kZXhlZERCfHx3aW5kb3cud2Via2l0SW5kZXhlZERCfHx3aW5kb3cubXNJbmRleGVkREJ9KSxEQl9OQU1FOihmdW5jdGlvbigpe3JldHVyblwiRU1fRlNfXCIrd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfSksREJfVkVSU0lPTjoyMCxEQl9TVE9SRV9OQU1FOlwiRklMRV9EQVRBXCIsc2F2ZUZpbGVzVG9EQjooZnVuY3Rpb24ocGF0aHMsb25sb2FkLG9uZXJyb3Ipe29ubG9hZD1vbmxvYWR8fChmdW5jdGlvbigpe30pO29uZXJyb3I9b25lcnJvcnx8KGZ1bmN0aW9uKCl7fSk7dmFyIGluZGV4ZWREQj1GUy5pbmRleGVkREIoKTt0cnl7dmFyIG9wZW5SZXF1ZXN0PWluZGV4ZWREQi5vcGVuKEZTLkRCX05BTUUoKSxGUy5EQl9WRVJTSU9OKX1jYXRjaChlKXtyZXR1cm4gb25lcnJvcihlKX1vcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24gb3BlblJlcXVlc3Rfb251cGdyYWRlbmVlZGVkKCl7Y29uc29sZS5sb2coXCJjcmVhdGluZyBkYlwiKTt2YXIgZGI9b3BlblJlcXVlc3QucmVzdWx0O2RiLmNyZWF0ZU9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpfTtvcGVuUmVxdWVzdC5vbnN1Y2Nlc3M9ZnVuY3Rpb24gb3BlblJlcXVlc3Rfb25zdWNjZXNzKCl7dmFyIGRiPW9wZW5SZXF1ZXN0LnJlc3VsdDt2YXIgdHJhbnNhY3Rpb249ZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLFwicmVhZHdyaXRlXCIpO3ZhciBmaWxlcz10cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTt2YXIgb2s9MCxmYWlsPTAsdG90YWw9cGF0aHMubGVuZ3RoO2Z1bmN0aW9uIGZpbmlzaCgpe2lmKGZhaWw9PTApb25sb2FkKCk7ZWxzZSBvbmVycm9yKCl9cGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24ocGF0aCl7dmFyIHB1dFJlcXVlc3Q9ZmlsZXMucHV0KEZTLmFuYWx5emVQYXRoKHBhdGgpLm9iamVjdC5jb250ZW50cyxwYXRoKTtwdXRSZXF1ZXN0Lm9uc3VjY2Vzcz1mdW5jdGlvbiBwdXRSZXF1ZXN0X29uc3VjY2Vzcygpe29rKys7aWYob2srZmFpbD09dG90YWwpZmluaXNoKCl9O3B1dFJlcXVlc3Qub25lcnJvcj1mdW5jdGlvbiBwdXRSZXF1ZXN0X29uZXJyb3IoKXtmYWlsKys7aWYob2srZmFpbD09dG90YWwpZmluaXNoKCl9fSkpO3RyYW5zYWN0aW9uLm9uZXJyb3I9b25lcnJvcn07b3BlblJlcXVlc3Qub25lcnJvcj1vbmVycm9yfSksbG9hZEZpbGVzRnJvbURCOihmdW5jdGlvbihwYXRocyxvbmxvYWQsb25lcnJvcil7b25sb2FkPW9ubG9hZHx8KGZ1bmN0aW9uKCl7fSk7b25lcnJvcj1vbmVycm9yfHwoZnVuY3Rpb24oKXt9KTt2YXIgaW5kZXhlZERCPUZTLmluZGV4ZWREQigpO3RyeXt2YXIgb3BlblJlcXVlc3Q9aW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLEZTLkRCX1ZFUlNJT04pfWNhdGNoKGUpe3JldHVybiBvbmVycm9yKGUpfW9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZD1vbmVycm9yO29wZW5SZXF1ZXN0Lm9uc3VjY2Vzcz1mdW5jdGlvbiBvcGVuUmVxdWVzdF9vbnN1Y2Nlc3MoKXt2YXIgZGI9b3BlblJlcXVlc3QucmVzdWx0O3RyeXt2YXIgdHJhbnNhY3Rpb249ZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLFwicmVhZG9ubHlcIil9Y2F0Y2goZSl7b25lcnJvcihlKTtyZXR1cm59dmFyIGZpbGVzPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO3ZhciBvaz0wLGZhaWw9MCx0b3RhbD1wYXRocy5sZW5ndGg7ZnVuY3Rpb24gZmluaXNoKCl7aWYoZmFpbD09MClvbmxvYWQoKTtlbHNlIG9uZXJyb3IoKX1wYXRocy5mb3JFYWNoKChmdW5jdGlvbihwYXRoKXt2YXIgZ2V0UmVxdWVzdD1maWxlcy5nZXQocGF0aCk7Z2V0UmVxdWVzdC5vbnN1Y2Nlc3M9ZnVuY3Rpb24gZ2V0UmVxdWVzdF9vbnN1Y2Nlc3MoKXtpZihGUy5hbmFseXplUGF0aChwYXRoKS5leGlzdHMpe0ZTLnVubGluayhwYXRoKX1GUy5jcmVhdGVEYXRhRmlsZShQQVRILmRpcm5hbWUocGF0aCksUEFUSC5iYXNlbmFtZShwYXRoKSxnZXRSZXF1ZXN0LnJlc3VsdCx0cnVlLHRydWUsdHJ1ZSk7b2srKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX07Z2V0UmVxdWVzdC5vbmVycm9yPWZ1bmN0aW9uIGdldFJlcXVlc3Rfb25lcnJvcigpe2ZhaWwrKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX19KSk7dHJhbnNhY3Rpb24ub25lcnJvcj1vbmVycm9yfTtvcGVuUmVxdWVzdC5vbmVycm9yPW9uZXJyb3J9KX07dmFyIFNZU0NBTExTPXtERUZBVUxUX1BPTExNQVNLOjUsbWFwcGluZ3M6e30sdW1hc2s6NTExLGNhbGN1bGF0ZUF0OihmdW5jdGlvbihkaXJmZCxwYXRoKXtpZihwYXRoWzBdIT09XCIvXCIpe3ZhciBkaXI7aWYoZGlyZmQ9PT0tMTAwKXtkaXI9RlMuY3dkKCl9ZWxzZXt2YXIgZGlyc3RyZWFtPUZTLmdldFN0cmVhbShkaXJmZCk7aWYoIWRpcnN0cmVhbSl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERik7ZGlyPWRpcnN0cmVhbS5wYXRofXBhdGg9UEFUSC5qb2luMihkaXIscGF0aCl9cmV0dXJuIHBhdGh9KSxkb1N0YXQ6KGZ1bmN0aW9uKGZ1bmMscGF0aCxidWYpe3RyeXt2YXIgc3RhdD1mdW5jKHBhdGgpfWNhdGNoKGUpe2lmKGUmJmUubm9kZSYmUEFUSC5ub3JtYWxpemUocGF0aCkhPT1QQVRILm5vcm1hbGl6ZShGUy5nZXRQYXRoKGUubm9kZSkpKXtyZXR1cm4tRVJSTk9fQ09ERVMuRU5PVERJUn10aHJvdyBlfUhFQVAzMltidWY+PjJdPXN0YXQuZGV2O0hFQVAzMltidWYrND4+Ml09MDtIRUFQMzJbYnVmKzg+PjJdPXN0YXQuaW5vO0hFQVAzMltidWYrMTI+PjJdPXN0YXQubW9kZTtIRUFQMzJbYnVmKzE2Pj4yXT1zdGF0Lm5saW5rO0hFQVAzMltidWYrMjA+PjJdPXN0YXQudWlkO0hFQVAzMltidWYrMjQ+PjJdPXN0YXQuZ2lkO0hFQVAzMltidWYrMjg+PjJdPXN0YXQucmRldjtIRUFQMzJbYnVmKzMyPj4yXT0wO0hFQVAzMltidWYrMzY+PjJdPXN0YXQuc2l6ZTtIRUFQMzJbYnVmKzQwPj4yXT00MDk2O0hFQVAzMltidWYrNDQ+PjJdPXN0YXQuYmxvY2tzO0hFQVAzMltidWYrNDg+PjJdPXN0YXQuYXRpbWUuZ2V0VGltZSgpLzFlM3wwO0hFQVAzMltidWYrNTI+PjJdPTA7SEVBUDMyW2J1Zis1Nj4+Ml09c3RhdC5tdGltZS5nZXRUaW1lKCkvMWUzfDA7SEVBUDMyW2J1Zis2MD4+Ml09MDtIRUFQMzJbYnVmKzY0Pj4yXT1zdGF0LmN0aW1lLmdldFRpbWUoKS8xZTN8MDtIRUFQMzJbYnVmKzY4Pj4yXT0wO0hFQVAzMltidWYrNzI+PjJdPXN0YXQuaW5vO3JldHVybiAwfSksZG9Nc3luYzooZnVuY3Rpb24oYWRkcixzdHJlYW0sbGVuLGZsYWdzKXt2YXIgYnVmZmVyPW5ldyBVaW50OEFycmF5KEhFQVBVOC5zdWJhcnJheShhZGRyLGFkZHIrbGVuKSk7RlMubXN5bmMoc3RyZWFtLGJ1ZmZlciwwLGxlbixmbGFncyl9KSxkb01rZGlyOihmdW5jdGlvbihwYXRoLG1vZGUpe3BhdGg9UEFUSC5ub3JtYWxpemUocGF0aCk7aWYocGF0aFtwYXRoLmxlbmd0aC0xXT09PVwiL1wiKXBhdGg9cGF0aC5zdWJzdHIoMCxwYXRoLmxlbmd0aC0xKTtGUy5ta2RpcihwYXRoLG1vZGUsMCk7cmV0dXJuIDB9KSxkb01rbm9kOihmdW5jdGlvbihwYXRoLG1vZGUsZGV2KXtzd2l0Y2gobW9kZSY2MTQ0MCl7Y2FzZSAzMjc2ODpjYXNlIDgxOTI6Y2FzZSAyNDU3NjpjYXNlIDQwOTY6Y2FzZSA0OTE1MjpicmVhaztkZWZhdWx0OnJldHVybi1FUlJOT19DT0RFUy5FSU5WQUx9RlMubWtub2QocGF0aCxtb2RlLGRldik7cmV0dXJuIDB9KSxkb1JlYWRsaW5rOihmdW5jdGlvbihwYXRoLGJ1ZixidWZzaXplKXtpZihidWZzaXplPD0wKXJldHVybi1FUlJOT19DT0RFUy5FSU5WQUw7dmFyIHJldD1GUy5yZWFkbGluayhwYXRoKTt2YXIgbGVuPU1hdGgubWluKGJ1ZnNpemUsbGVuZ3RoQnl0ZXNVVEY4KHJldCkpO3ZhciBlbmRDaGFyPUhFQVA4W2J1ZitsZW5dO3N0cmluZ1RvVVRGOChyZXQsYnVmLGJ1ZnNpemUrMSk7SEVBUDhbYnVmK2xlbl09ZW5kQ2hhcjtyZXR1cm4gbGVufSksZG9BY2Nlc3M6KGZ1bmN0aW9uKHBhdGgsYW1vZGUpe2lmKGFtb2RlJn43KXtyZXR1cm4tRVJSTk9fQ09ERVMuRUlOVkFMfXZhciBub2RlO3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO25vZGU9bG9va3VwLm5vZGU7dmFyIHBlcm1zPVwiXCI7aWYoYW1vZGUmNClwZXJtcys9XCJyXCI7aWYoYW1vZGUmMilwZXJtcys9XCJ3XCI7aWYoYW1vZGUmMSlwZXJtcys9XCJ4XCI7aWYocGVybXMmJkZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLHBlcm1zKSl7cmV0dXJuLUVSUk5PX0NPREVTLkVBQ0NFU31yZXR1cm4gMH0pLGRvRHVwOihmdW5jdGlvbihwYXRoLGZsYWdzLHN1Z2dlc3RGRCl7dmFyIHN1Z2dlc3Q9RlMuZ2V0U3RyZWFtKHN1Z2dlc3RGRCk7aWYoc3VnZ2VzdClGUy5jbG9zZShzdWdnZXN0KTtyZXR1cm4gRlMub3BlbihwYXRoLGZsYWdzLDAsc3VnZ2VzdEZELHN1Z2dlc3RGRCkuZmR9KSxkb1JlYWR2OihmdW5jdGlvbihzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpe3ZhciByZXQ9MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUDMyW2lvditpKjg+PjJdO3ZhciBsZW49SEVBUDMyW2lvdisoaSo4KzQpPj4yXTt2YXIgY3Vycj1GUy5yZWFkKHN0cmVhbSxIRUFQOCxwdHIsbGVuLG9mZnNldCk7aWYoY3VycjwwKXJldHVybi0xO3JldCs9Y3VycjtpZihjdXJyPGxlbilicmVha31yZXR1cm4gcmV0fSksZG9Xcml0ZXY6KGZ1bmN0aW9uKHN0cmVhbSxpb3YsaW92Y250LG9mZnNldCl7dmFyIHJldD0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1IRUFQMzJbaW92K2kqOD4+Ml07dmFyIGxlbj1IRUFQMzJbaW92KyhpKjgrNCk+PjJdO3ZhciBjdXJyPUZTLndyaXRlKHN0cmVhbSxIRUFQOCxwdHIsbGVuLG9mZnNldCk7aWYoY3VycjwwKXJldHVybi0xO3JldCs9Y3Vycn1yZXR1cm4gcmV0fSksdmFyYXJnczowLGdldDooZnVuY3Rpb24odmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncys9NDt2YXIgcmV0PUhFQVAzMltTWVNDQUxMUy52YXJhcmdzLTQ+PjJdO3JldHVybiByZXR9KSxnZXRTdHI6KGZ1bmN0aW9uKCl7dmFyIHJldD1Qb2ludGVyX3N0cmluZ2lmeShTWVNDQUxMUy5nZXQoKSk7cmV0dXJuIHJldH0pLGdldFN0cmVhbUZyb21GRDooZnVuY3Rpb24oKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShTWVNDQUxMUy5nZXQoKSk7aWYoIXN0cmVhbSl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERik7cmV0dXJuIHN0cmVhbX0pLGdldFNvY2tldEZyb21GRDooZnVuY3Rpb24oKXt2YXIgc29ja2V0PVNPQ0tGUy5nZXRTb2NrZXQoU1lTQ0FMTFMuZ2V0KCkpO2lmKCFzb2NrZXQpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO3JldHVybiBzb2NrZXR9KSxnZXRTb2NrZXRBZGRyZXNzOihmdW5jdGlvbihhbGxvd051bGwpe3ZhciBhZGRycD1TWVNDQUxMUy5nZXQoKSxhZGRybGVuPVNZU0NBTExTLmdldCgpO2lmKGFsbG93TnVsbCYmYWRkcnA9PT0wKXJldHVybiBudWxsO3ZhciBpbmZvPV9fcmVhZF9zb2NrYWRkcihhZGRycCxhZGRybGVuKTtpZihpbmZvLmVycm5vKXRocm93IG5ldyBGUy5FcnJub0Vycm9yKGluZm8uZXJybm8pO2luZm8uYWRkcj1ETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKXx8aW5mby5hZGRyO3JldHVybiBpbmZvfSksZ2V0NjQ6KGZ1bmN0aW9uKCl7dmFyIGxvdz1TWVNDQUxMUy5nZXQoKSxoaWdoPVNZU0NBTExTLmdldCgpO2lmKGxvdz49MClhc3NlcnQoaGlnaD09PTApO2Vsc2UgYXNzZXJ0KGhpZ2g9PT0tMSk7cmV0dXJuIGxvd30pLGdldFplcm86KGZ1bmN0aW9uKCl7YXNzZXJ0KFNZU0NBTExTLmdldCgpPT09MCl9KX07ZnVuY3Rpb24gX19fc3lzY2FsbDE0MCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksb2Zmc2V0X2hpZ2g9U1lTQ0FMTFMuZ2V0KCksb2Zmc2V0X2xvdz1TWVNDQUxMUy5nZXQoKSxyZXN1bHQ9U1lTQ0FMTFMuZ2V0KCksd2hlbmNlPVNZU0NBTExTLmdldCgpO3ZhciBvZmZzZXQ9b2Zmc2V0X2xvdztGUy5sbHNlZWsoc3RyZWFtLG9mZnNldCx3aGVuY2UpO0hFQVAzMltyZXN1bHQ+PjJdPXN0cmVhbS5wb3NpdGlvbjtpZihzdHJlYW0uZ2V0ZGVudHMmJm9mZnNldD09PTAmJndoZW5jZT09PTApc3RyZWFtLmdldGRlbnRzPW51bGw7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09XCJ1bmRlZmluZWRcInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDUod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLGlvdj1TWVNDQUxMUy5nZXQoKSxpb3ZjbnQ9U1lTQ0FMTFMuZ2V0KCk7cmV0dXJuIFNZU0NBTExTLmRvUmVhZHYoc3RyZWFtLGlvdixpb3ZjbnQpfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PVwidW5kZWZpbmVkXCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybi1lLmVycm5vfX1mdW5jdGlvbiBfX19zeXNjYWxsMTQ2KHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKSxpb3Y9U1lTQ0FMTFMuZ2V0KCksaW92Y250PVNZU0NBTExTLmdldCgpO3JldHVybiBTWVNDQUxMUy5kb1dyaXRldihzdHJlYW0saW92LGlvdmNudCl9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09XCJ1bmRlZmluZWRcInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGwxODMod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgYnVmPVNZU0NBTExTLmdldCgpLHNpemU9U1lTQ0FMTFMuZ2V0KCk7aWYoc2l6ZT09PTApcmV0dXJuLUVSUk5PX0NPREVTLkVJTlZBTDt2YXIgY3dkPUZTLmN3ZCgpO3ZhciBjd2RMZW5ndGhJbkJ5dGVzPWxlbmd0aEJ5dGVzVVRGOChjd2QpO2lmKHNpemU8Y3dkTGVuZ3RoSW5CeXRlcysxKXJldHVybi1FUlJOT19DT0RFUy5FUkFOR0U7c3RyaW5nVG9VVEY4KGN3ZCxidWYsc2l6ZSk7cmV0dXJuIGJ1Zn1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT1cInVuZGVmaW5lZFwifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4tZS5lcnJub319ZnVuY3Rpb24gX19fc3lzY2FsbDE5OCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBwYXRoPVNZU0NBTExTLmdldFN0cigpLG93bmVyPVNZU0NBTExTLmdldCgpLGdyb3VwPVNZU0NBTExTLmdldCgpO0ZTLmNob3duKHBhdGgsb3duZXIsZ3JvdXApO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PVwidW5kZWZpbmVkXCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybi1lLmVycm5vfX12YXIgUFJPQ0lORk89e3BwaWQ6MSxwaWQ6NDIsc2lkOjQyLHBnaWQ6NDJ9O2Z1bmN0aW9uIF9fX3N5c2NhbGwyMCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3JldHVybiBQUk9DSU5GTy5waWR9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09XCJ1bmRlZmluZWRcInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw2KHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKTtGUy5jbG9zZShzdHJlYW0pO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09PVwidW5kZWZpbmVkXCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybi1lLmVycm5vfX1mdW5jdGlvbiBfX19zeXNjYWxsNjAod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgbWFzaz1TWVNDQUxMUy5nZXQoKTt2YXIgb2xkPVNZU0NBTExTLnVtYXNrO1NZU0NBTExTLnVtYXNrPW1hc2s7cmV0dXJuIG9sZH1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT1cInVuZGVmaW5lZFwifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4tZS5lcnJub319ZnVuY3Rpb24gX19fc3lzY2FsbDgzKHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHRhcmdldD1TWVNDQUxMUy5nZXRTdHIoKSxsaW5rcGF0aD1TWVNDQUxMUy5nZXRTdHIoKTtGUy5zeW1saW5rKHRhcmdldCxsaW5rcGF0aCk7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09XCJ1bmRlZmluZWRcInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw5MSh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBhZGRyPVNZU0NBTExTLmdldCgpLGxlbj1TWVNDQUxMUy5nZXQoKTt2YXIgaW5mbz1TWVNDQUxMUy5tYXBwaW5nc1thZGRyXTtpZighaW5mbylyZXR1cm4gMDtpZihsZW49PT1pbmZvLmxlbil7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oaW5mby5mZCk7U1lTQ0FMTFMuZG9Nc3luYyhhZGRyLHN0cmVhbSxsZW4saW5mby5mbGFncyk7RlMubXVubWFwKHN0cmVhbSk7U1lTQ0FMTFMubWFwcGluZ3NbYWRkcl09bnVsbDtpZihpbmZvLmFsbG9jYXRlZCl7X2ZyZWUoaW5mby5tYWxsb2MpfX1yZXR1cm4gMH1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT1cInVuZGVmaW5lZFwifHwhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSlhYm9ydChlKTtyZXR1cm4tZS5lcnJub319ZnVuY3Rpb24gX19fdW5sb2NrKCl7fXZhciBzdHJ1Y3RSZWdpc3RyYXRpb25zPXt9O2Z1bmN0aW9uIHJ1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKXt3aGlsZShkZXN0cnVjdG9ycy5sZW5ndGgpe3ZhciBwdHI9ZGVzdHJ1Y3RvcnMucG9wKCk7dmFyIGRlbD1kZXN0cnVjdG9ycy5wb3AoKTtkZWwocHRyKX19ZnVuY3Rpb24gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUFUzMltwb2ludGVyPj4yXSl9dmFyIGF3YWl0aW5nRGVwZW5kZW5jaWVzPXt9O3ZhciByZWdpc3RlcmVkVHlwZXM9e307dmFyIHR5cGVEZXBlbmRlbmNpZXM9e307dmFyIGNoYXJfMD00ODt2YXIgY2hhcl85PTU3O2Z1bmN0aW9uIG1ha2VMZWdhbEZ1bmN0aW9uTmFtZShuYW1lKXtpZih1bmRlZmluZWQ9PT1uYW1lKXtyZXR1cm5cIl91bmtub3duXCJ9bmFtZT1uYW1lLnJlcGxhY2UoL1teYS16QS1aMC05X10vZyxcIiRcIik7dmFyIGY9bmFtZS5jaGFyQ29kZUF0KDApO2lmKGY+PWNoYXJfMCYmZjw9Y2hhcl85KXtyZXR1cm5cIl9cIituYW1lfWVsc2V7cmV0dXJuIG5hbWV9fWZ1bmN0aW9uIGNyZWF0ZU5hbWVkRnVuY3Rpb24obmFtZSxib2R5KXtuYW1lPW1ha2VMZWdhbEZ1bmN0aW9uTmFtZShuYW1lKTtyZXR1cm4obmV3IEZ1bmN0aW9uKFwiYm9keVwiLFwicmV0dXJuIGZ1bmN0aW9uIFwiK25hbWUrXCIoKSB7XFxuXCIrJyAgICBcInVzZSBzdHJpY3RcIjsnK1wiICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXCIrXCJ9O1xcblwiKSkoYm9keSl9ZnVuY3Rpb24gZXh0ZW5kRXJyb3IoYmFzZUVycm9yVHlwZSxlcnJvck5hbWUpe3ZhciBlcnJvckNsYXNzPWNyZWF0ZU5hbWVkRnVuY3Rpb24oZXJyb3JOYW1lLChmdW5jdGlvbihtZXNzYWdlKXt0aGlzLm5hbWU9ZXJyb3JOYW1lO3RoaXMubWVzc2FnZT1tZXNzYWdlO3ZhciBzdGFjaz0obmV3IEVycm9yKG1lc3NhZ2UpKS5zdGFjaztpZihzdGFjayE9PXVuZGVmaW5lZCl7dGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrXCJcXG5cIitzdGFjay5yZXBsYWNlKC9eRXJyb3IoOlteXFxuXSopP1xcbi8sXCJcIil9fSkpO2Vycm9yQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYmFzZUVycm9yVHlwZS5wcm90b3R5cGUpO2Vycm9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPWVycm9yQ2xhc3M7ZXJyb3JDbGFzcy5wcm90b3R5cGUudG9TdHJpbmc9KGZ1bmN0aW9uKCl7aWYodGhpcy5tZXNzYWdlPT09dW5kZWZpbmVkKXtyZXR1cm4gdGhpcy5uYW1lfWVsc2V7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfX0pO3JldHVybiBlcnJvckNsYXNzfXZhciBJbnRlcm5hbEVycm9yPXVuZGVmaW5lZDtmdW5jdGlvbiB0aHJvd0ludGVybmFsRXJyb3IobWVzc2FnZSl7dGhyb3cgbmV3IEludGVybmFsRXJyb3IobWVzc2FnZSl9ZnVuY3Rpb24gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQobXlUeXBlcyxkZXBlbmRlbnRUeXBlcyxnZXRUeXBlQ29udmVydGVycyl7bXlUeXBlcy5mb3JFYWNoKChmdW5jdGlvbih0eXBlKXt0eXBlRGVwZW5kZW5jaWVzW3R5cGVdPWRlcGVuZGVudFR5cGVzfSkpO2Z1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpe3ZhciBteVR5cGVDb252ZXJ0ZXJzPWdldFR5cGVDb252ZXJ0ZXJzKHR5cGVDb252ZXJ0ZXJzKTtpZihteVR5cGVDb252ZXJ0ZXJzLmxlbmd0aCE9PW15VHlwZXMubGVuZ3RoKXt0aHJvd0ludGVybmFsRXJyb3IoXCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50XCIpfWZvcih2YXIgaT0wO2k8bXlUeXBlcy5sZW5ndGg7KytpKXtyZWdpc3RlclR5cGUobXlUeXBlc1tpXSxteVR5cGVDb252ZXJ0ZXJzW2ldKX19dmFyIHR5cGVDb252ZXJ0ZXJzPW5ldyBBcnJheShkZXBlbmRlbnRUeXBlcy5sZW5ndGgpO3ZhciB1bnJlZ2lzdGVyZWRUeXBlcz1bXTt2YXIgcmVnaXN0ZXJlZD0wO2RlcGVuZGVudFR5cGVzLmZvckVhY2goKGZ1bmN0aW9uKGR0LGkpe2lmKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShkdCkpe3R5cGVDb252ZXJ0ZXJzW2ldPXJlZ2lzdGVyZWRUeXBlc1tkdF19ZWxzZXt1bnJlZ2lzdGVyZWRUeXBlcy5wdXNoKGR0KTtpZighYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkoZHQpKXthd2FpdGluZ0RlcGVuZGVuY2llc1tkdF09W119YXdhaXRpbmdEZXBlbmRlbmNpZXNbZHRdLnB1c2goKGZ1bmN0aW9uKCl7dHlwZUNvbnZlcnRlcnNbaV09cmVnaXN0ZXJlZFR5cGVzW2R0XTsrK3JlZ2lzdGVyZWQ7aWYocmVnaXN0ZXJlZD09PXVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCl7b25Db21wbGV0ZSh0eXBlQ29udmVydGVycyl9fSkpfX0pKTtpZigwPT09dW5yZWdpc3RlcmVkVHlwZXMubGVuZ3RoKXtvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKX19ZnVuY3Rpb24gX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0KHN0cnVjdFR5cGUpe3ZhciByZWc9c3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXTtkZWxldGUgc3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXTt2YXIgcmF3Q29uc3RydWN0b3I9cmVnLnJhd0NvbnN0cnVjdG9yO3ZhciByYXdEZXN0cnVjdG9yPXJlZy5yYXdEZXN0cnVjdG9yO3ZhciBmaWVsZFJlY29yZHM9cmVnLmZpZWxkczt2YXIgZmllbGRUeXBlcz1maWVsZFJlY29yZHMubWFwKChmdW5jdGlvbihmaWVsZCl7cmV0dXJuIGZpZWxkLmdldHRlclJldHVyblR5cGV9KSkuY29uY2F0KGZpZWxkUmVjb3Jkcy5tYXAoKGZ1bmN0aW9uKGZpZWxkKXtyZXR1cm4gZmllbGQuc2V0dGVyQXJndW1lbnRUeXBlfSkpKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbc3RydWN0VHlwZV0sZmllbGRUeXBlcywoZnVuY3Rpb24oZmllbGRUeXBlcyl7dmFyIGZpZWxkcz17fTtmaWVsZFJlY29yZHMuZm9yRWFjaCgoZnVuY3Rpb24oZmllbGQsaSl7dmFyIGZpZWxkTmFtZT1maWVsZC5maWVsZE5hbWU7dmFyIGdldHRlclJldHVyblR5cGU9ZmllbGRUeXBlc1tpXTt2YXIgZ2V0dGVyPWZpZWxkLmdldHRlcjt2YXIgZ2V0dGVyQ29udGV4dD1maWVsZC5nZXR0ZXJDb250ZXh0O3ZhciBzZXR0ZXJBcmd1bWVudFR5cGU9ZmllbGRUeXBlc1tpK2ZpZWxkUmVjb3Jkcy5sZW5ndGhdO3ZhciBzZXR0ZXI9ZmllbGQuc2V0dGVyO3ZhciBzZXR0ZXJDb250ZXh0PWZpZWxkLnNldHRlckNvbnRleHQ7ZmllbGRzW2ZpZWxkTmFtZV09e3JlYWQ6KGZ1bmN0aW9uKHB0cil7cmV0dXJuIGdldHRlclJldHVyblR5cGVbXCJmcm9tV2lyZVR5cGVcIl0oZ2V0dGVyKGdldHRlckNvbnRleHQscHRyKSl9KSx3cml0ZTooZnVuY3Rpb24ocHRyLG8pe3ZhciBkZXN0cnVjdG9ycz1bXTtzZXR0ZXIoc2V0dGVyQ29udGV4dCxwdHIsc2V0dGVyQXJndW1lbnRUeXBlW1widG9XaXJlVHlwZVwiXShkZXN0cnVjdG9ycyxvKSk7cnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpfSl9fSkpO3JldHVyblt7bmFtZTpyZWcubmFtZSxcImZyb21XaXJlVHlwZVwiOihmdW5jdGlvbihwdHIpe3ZhciBydj17fTtmb3IodmFyIGkgaW4gZmllbGRzKXtydltpXT1maWVsZHNbaV0ucmVhZChwdHIpfXJhd0Rlc3RydWN0b3IocHRyKTtyZXR1cm4gcnZ9KSxcInRvV2lyZVR5cGVcIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7Zm9yKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzKXtpZighKGZpZWxkTmFtZSBpbiBvKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgZmllbGRcIil9fXZhciBwdHI9cmF3Q29uc3RydWN0b3IoKTtmb3IoZmllbGROYW1lIGluIGZpZWxkcyl7ZmllbGRzW2ZpZWxkTmFtZV0ud3JpdGUocHRyLG9bZmllbGROYW1lXSl9aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKHJhd0Rlc3RydWN0b3IscHRyKX1yZXR1cm4gcHRyfSksXCJhcmdQYWNrQWR2YW5jZVwiOjgsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjpyYXdEZXN0cnVjdG9yfV19KSl9ZnVuY3Rpb24gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKXtzd2l0Y2goc2l6ZSl7Y2FzZSAxOnJldHVybiAwO2Nhc2UgMjpyZXR1cm4gMTtjYXNlIDQ6cmV0dXJuIDI7Y2FzZSA4OnJldHVybiAzO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gdHlwZSBzaXplOiBcIitzaXplKX19ZnVuY3Rpb24gZW1iaW5kX2luaXRfY2hhckNvZGVzKCl7dmFyIGNvZGVzPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgaT0wO2k8MjU2OysraSl7Y29kZXNbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKX1lbWJpbmRfY2hhckNvZGVzPWNvZGVzfXZhciBlbWJpbmRfY2hhckNvZGVzPXVuZGVmaW5lZDtmdW5jdGlvbiByZWFkTGF0aW4xU3RyaW5nKHB0cil7dmFyIHJldD1cIlwiO3ZhciBjPXB0cjt3aGlsZShIRUFQVThbY10pe3JldCs9ZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV19cmV0dXJuIHJldH12YXIgQmluZGluZ0Vycm9yPXVuZGVmaW5lZDtmdW5jdGlvbiB0aHJvd0JpbmRpbmdFcnJvcihtZXNzYWdlKXt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG1lc3NhZ2UpfWZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zKXtvcHRpb25zPW9wdGlvbnN8fHt9O2lmKCEoXCJhcmdQYWNrQWR2YW5jZVwiaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2VcIil9dmFyIG5hbWU9cmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7aWYoIXJhd1R5cGUpe3Rocm93QmluZGluZ0Vycm9yKCd0eXBlIFwiJytuYW1lKydcIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyJyl9aWYocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXtpZihvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpe3JldHVybn1lbHNle3Rocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJ1wiK25hbWUrXCInIHR3aWNlXCIpfX1yZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV09cmVnaXN0ZXJlZEluc3RhbmNlO2RlbGV0ZSB0eXBlRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2lmKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXt2YXIgY2FsbGJhY2tzPWF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2RlbGV0ZSBhd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtjYWxsYmFja3MuZm9yRWFjaCgoZnVuY3Rpb24oY2Ipe2NiKCl9KSl9fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wocmF3VHlwZSxuYW1lLHNpemUsdHJ1ZVZhbHVlLGZhbHNlVmFsdWUpe3ZhciBzaGlmdD1nZXRTaGlmdEZyb21TaXplKHNpemUpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6KGZ1bmN0aW9uKHd0KXtyZXR1cm4hIXd0fSksXCJ0b1dpcmVUeXBlXCI6KGZ1bmN0aW9uKGRlc3RydWN0b3JzLG8pe3JldHVybiBvP3RydWVWYWx1ZTpmYWxzZVZhbHVlfSksXCJhcmdQYWNrQWR2YW5jZVwiOjgsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOihmdW5jdGlvbihwb2ludGVyKXt2YXIgaGVhcDtpZihzaXplPT09MSl7aGVhcD1IRUFQOH1lbHNlIGlmKHNpemU9PT0yKXtoZWFwPUhFQVAxNn1lbHNlIGlmKHNpemU9PT00KXtoZWFwPUhFQVAzMn1lbHNle3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGJvb2xlYW4gdHlwZSBzaXplOiBcIituYW1lKX1yZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShoZWFwW3BvaW50ZXI+PnNoaWZ0XSl9KSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfWZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzQWxpYXNPZihvdGhlcil7aWYoISh0aGlzIGluc3RhbmNlb2YgQ2xhc3NIYW5kbGUpKXtyZXR1cm4gZmFsc2V9aWYoIShvdGhlciBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSl7cmV0dXJuIGZhbHNlfXZhciBsZWZ0Q2xhc3M9dGhpcy4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczt2YXIgbGVmdD10aGlzLiQkLnB0cjt2YXIgcmlnaHRDbGFzcz1vdGhlci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczt2YXIgcmlnaHQ9b3RoZXIuJCQucHRyO3doaWxlKGxlZnRDbGFzcy5iYXNlQ2xhc3Mpe2xlZnQ9bGVmdENsYXNzLnVwY2FzdChsZWZ0KTtsZWZ0Q2xhc3M9bGVmdENsYXNzLmJhc2VDbGFzc313aGlsZShyaWdodENsYXNzLmJhc2VDbGFzcyl7cmlnaHQ9cmlnaHRDbGFzcy51cGNhc3QocmlnaHQpO3JpZ2h0Q2xhc3M9cmlnaHRDbGFzcy5iYXNlQ2xhc3N9cmV0dXJuIGxlZnRDbGFzcz09PXJpZ2h0Q2xhc3MmJmxlZnQ9PT1yaWdodH1mdW5jdGlvbiBzaGFsbG93Q29weUludGVybmFsUG9pbnRlcihvKXtyZXR1cm57Y291bnQ6by5jb3VudCxkZWxldGVTY2hlZHVsZWQ6by5kZWxldGVTY2hlZHVsZWQscHJlc2VydmVQb2ludGVyT25EZWxldGU6by5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSxwdHI6by5wdHIscHRyVHlwZTpvLnB0clR5cGUsc21hcnRQdHI6by5zbWFydFB0cixzbWFydFB0clR5cGU6by5zbWFydFB0clR5cGV9fWZ1bmN0aW9uIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZChvYmope2Z1bmN0aW9uIGdldEluc3RhbmNlVHlwZU5hbWUoaGFuZGxlKXtyZXR1cm4gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLm5hbWV9dGhyb3dCaW5kaW5nRXJyb3IoZ2V0SW5zdGFuY2VUeXBlTmFtZShvYmopK1wiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZFwiKX1mdW5jdGlvbiBDbGFzc0hhbmRsZV9jbG9uZSgpe2lmKCF0aGlzLiQkLnB0cil7dGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpfWlmKHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpe3RoaXMuJCQuY291bnQudmFsdWUrPTE7cmV0dXJuIHRoaXN9ZWxzZXt2YXIgY2xvbmU9T2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykseyQkOnt2YWx1ZTpzaGFsbG93Q29weUludGVybmFsUG9pbnRlcih0aGlzLiQkKX19KTtjbG9uZS4kJC5jb3VudC52YWx1ZSs9MTtjbG9uZS4kJC5kZWxldGVTY2hlZHVsZWQ9ZmFsc2U7cmV0dXJuIGNsb25lfX1mdW5jdGlvbiBydW5EZXN0cnVjdG9yKGhhbmRsZSl7dmFyICQkPWhhbmRsZS4kJDtpZigkJC5zbWFydFB0cil7JCQuc21hcnRQdHJUeXBlLnJhd0Rlc3RydWN0b3IoJCQuc21hcnRQdHIpfWVsc2V7JCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MucmF3RGVzdHJ1Y3RvcigkJC5wdHIpfX1mdW5jdGlvbiBDbGFzc0hhbmRsZV9kZWxldGUoKXtpZighdGhpcy4kJC5wdHIpe3Rocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKX1pZih0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCYmIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpe3Rocm93QmluZGluZ0Vycm9yKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKX10aGlzLiQkLmNvdW50LnZhbHVlLT0xO3ZhciB0b0RlbGV0ZT0wPT09dGhpcy4kJC5jb3VudC52YWx1ZTtpZih0b0RlbGV0ZSl7cnVuRGVzdHJ1Y3Rvcih0aGlzKX1pZighdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSl7dGhpcy4kJC5zbWFydFB0cj11bmRlZmluZWQ7dGhpcy4kJC5wdHI9dW5kZWZpbmVkfX1mdW5jdGlvbiBDbGFzc0hhbmRsZV9pc0RlbGV0ZWQoKXtyZXR1cm4hdGhpcy4kJC5wdHJ9dmFyIGRlbGF5RnVuY3Rpb249dW5kZWZpbmVkO3ZhciBkZWxldGlvblF1ZXVlPVtdO2Z1bmN0aW9uIGZsdXNoUGVuZGluZ0RlbGV0ZXMoKXt3aGlsZShkZWxldGlvblF1ZXVlLmxlbmd0aCl7dmFyIG9iaj1kZWxldGlvblF1ZXVlLnBvcCgpO29iai4kJC5kZWxldGVTY2hlZHVsZWQ9ZmFsc2U7b2JqW1wiZGVsZXRlXCJdKCl9fWZ1bmN0aW9uIENsYXNzSGFuZGxlX2RlbGV0ZUxhdGVyKCl7aWYoIXRoaXMuJCQucHRyKXt0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyl9aWYodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKXt0aHJvd0JpbmRpbmdFcnJvcihcIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cIil9ZGVsZXRpb25RdWV1ZS5wdXNoKHRoaXMpO2lmKGRlbGV0aW9uUXVldWUubGVuZ3RoPT09MSYmZGVsYXlGdW5jdGlvbil7ZGVsYXlGdW5jdGlvbihmbHVzaFBlbmRpbmdEZWxldGVzKX10aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZD10cnVlO3JldHVybiB0aGlzfWZ1bmN0aW9uIGluaXRfQ2xhc3NIYW5kbGUoKXtDbGFzc0hhbmRsZS5wcm90b3R5cGVbXCJpc0FsaWFzT2ZcIl09Q2xhc3NIYW5kbGVfaXNBbGlhc09mO0NsYXNzSGFuZGxlLnByb3RvdHlwZVtcImNsb25lXCJdPUNsYXNzSGFuZGxlX2Nsb25lO0NsYXNzSGFuZGxlLnByb3RvdHlwZVtcImRlbGV0ZVwiXT1DbGFzc0hhbmRsZV9kZWxldGU7Q2xhc3NIYW5kbGUucHJvdG90eXBlW1wiaXNEZWxldGVkXCJdPUNsYXNzSGFuZGxlX2lzRGVsZXRlZDtDbGFzc0hhbmRsZS5wcm90b3R5cGVbXCJkZWxldGVMYXRlclwiXT1DbGFzc0hhbmRsZV9kZWxldGVMYXRlcn1mdW5jdGlvbiBDbGFzc0hhbmRsZSgpe312YXIgcmVnaXN0ZXJlZFBvaW50ZXJzPXt9O2Z1bmN0aW9uIGVuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpe2lmKHVuZGVmaW5lZD09PXByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpe3ZhciBwcmV2RnVuYz1wcm90b1ttZXRob2ROYW1lXTtwcm90b1ttZXRob2ROYW1lXT0oZnVuY3Rpb24oKXtpZighcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHMubGVuZ3RoKSl7dGhyb3dCaW5kaW5nRXJyb3IoXCJGdW5jdGlvbiAnXCIraHVtYW5OYW1lK1wiJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKFwiK2FyZ3VtZW50cy5sZW5ndGgrXCIpIC0gZXhwZWN0cyBvbmUgb2YgKFwiK3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUrXCIpIVwiKX1yZXR1cm4gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlPVtdO3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbcHJldkZ1bmMuYXJnQ291bnRdPXByZXZGdW5jfX1mdW5jdGlvbiBleHBvc2VQdWJsaWNTeW1ib2wobmFtZSx2YWx1ZSxudW1Bcmd1bWVudHMpe2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7aWYodW5kZWZpbmVkPT09bnVtQXJndW1lbnRzfHx1bmRlZmluZWQhPT1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSYmdW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJ1wiK25hbWUrXCInIHR3aWNlXCIpfWVuc3VyZU92ZXJsb2FkVGFibGUoTW9kdWxlLG5hbWUsbmFtZSk7aWYoTW9kdWxlLmhhc093blByb3BlcnR5KG51bUFyZ3VtZW50cykpe3Rocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIrbnVtQXJndW1lbnRzK1wiKSFcIil9TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXT12YWx1ZX1lbHNle01vZHVsZVtuYW1lXT12YWx1ZTtpZih1bmRlZmluZWQhPT1udW1Bcmd1bWVudHMpe01vZHVsZVtuYW1lXS5udW1Bcmd1bWVudHM9bnVtQXJndW1lbnRzfX19ZnVuY3Rpb24gUmVnaXN0ZXJlZENsYXNzKG5hbWUsY29uc3RydWN0b3IsaW5zdGFuY2VQcm90b3R5cGUscmF3RGVzdHJ1Y3RvcixiYXNlQ2xhc3MsZ2V0QWN0dWFsVHlwZSx1cGNhc3QsZG93bmNhc3Qpe3RoaXMubmFtZT1uYW1lO3RoaXMuY29uc3RydWN0b3I9Y29uc3RydWN0b3I7dGhpcy5pbnN0YW5jZVByb3RvdHlwZT1pbnN0YW5jZVByb3RvdHlwZTt0aGlzLnJhd0Rlc3RydWN0b3I9cmF3RGVzdHJ1Y3Rvcjt0aGlzLmJhc2VDbGFzcz1iYXNlQ2xhc3M7dGhpcy5nZXRBY3R1YWxUeXBlPWdldEFjdHVhbFR5cGU7dGhpcy51cGNhc3Q9dXBjYXN0O3RoaXMuZG93bmNhc3Q9ZG93bmNhc3Q7dGhpcy5wdXJlVmlydHVhbEZ1bmN0aW9ucz1bXX1mdW5jdGlvbiB1cGNhc3RQb2ludGVyKHB0cixwdHJDbGFzcyxkZXNpcmVkQ2xhc3Mpe3doaWxlKHB0ckNsYXNzIT09ZGVzaXJlZENsYXNzKXtpZighcHRyQ2xhc3MudXBjYXN0KXt0aHJvd0JpbmRpbmdFcnJvcihcIkV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgXCIrZGVzaXJlZENsYXNzLm5hbWUrXCIsIGdvdCBhbiBpbnN0YW5jZSBvZiBcIitwdHJDbGFzcy5uYW1lKX1wdHI9cHRyQ2xhc3MudXBjYXN0KHB0cik7cHRyQ2xhc3M9cHRyQ2xhc3MuYmFzZUNsYXNzfXJldHVybiBwdHJ9ZnVuY3Rpb24gY29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsaGFuZGxlKXtpZihoYW5kbGU9PT1udWxsKXtpZih0aGlzLmlzUmVmZXJlbmNlKXt0aHJvd0JpbmRpbmdFcnJvcihcIm51bGwgaXMgbm90IGEgdmFsaWQgXCIrdGhpcy5uYW1lKX1yZXR1cm4gMH1pZighaGFuZGxlLiQkKXt0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgXCInK19lbWJpbmRfcmVwcihoYW5kbGUpKydcIiBhcyBhICcrdGhpcy5uYW1lKX1pZighaGFuZGxlLiQkLnB0cil7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSBcIit0aGlzLm5hbWUpfXZhciBoYW5kbGVDbGFzcz1oYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7dmFyIHB0cj11cGNhc3RQb2ludGVyKGhhbmRsZS4kJC5wdHIsaGFuZGxlQ2xhc3MsdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO3JldHVybiBwdHJ9ZnVuY3Rpb24gZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLGhhbmRsZSl7dmFyIHB0cjtpZihoYW5kbGU9PT1udWxsKXtpZih0aGlzLmlzUmVmZXJlbmNlKXt0aHJvd0JpbmRpbmdFcnJvcihcIm51bGwgaXMgbm90IGEgdmFsaWQgXCIrdGhpcy5uYW1lKX1pZih0aGlzLmlzU21hcnRQb2ludGVyKXtwdHI9dGhpcy5yYXdDb25zdHJ1Y3RvcigpO2lmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IscHRyKX1yZXR1cm4gcHRyfWVsc2V7cmV0dXJuIDB9fWlmKCFoYW5kbGUuJCQpe3Rocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyBcIicrX2VtYmluZF9yZXByKGhhbmRsZSkrJ1wiIGFzIGEgJyt0aGlzLm5hbWUpfWlmKCFoYW5kbGUuJCQucHRyKXt0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlIFwiK3RoaXMubmFtZSl9aWYoIXRoaXMuaXNDb25zdCYmaGFuZGxlLiQkLnB0clR5cGUuaXNDb25zdCl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIFwiKyhoYW5kbGUuJCQuc21hcnRQdHJUeXBlP2hhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZTpoYW5kbGUuJCQucHRyVHlwZS5uYW1lKStcIiB0byBwYXJhbWV0ZXIgdHlwZSBcIit0aGlzLm5hbWUpfXZhciBoYW5kbGVDbGFzcz1oYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7cHRyPXVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0cixoYW5kbGVDbGFzcyx0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7aWYodGhpcy5pc1NtYXJ0UG9pbnRlcil7aWYodW5kZWZpbmVkPT09aGFuZGxlLiQkLnNtYXJ0UHRyKXt0aHJvd0JpbmRpbmdFcnJvcihcIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsXCIpfXN3aXRjaCh0aGlzLnNoYXJpbmdQb2xpY3kpe2Nhc2UgMDppZihoYW5kbGUuJCQuc21hcnRQdHJUeXBlPT09dGhpcyl7cHRyPWhhbmRsZS4kJC5zbWFydFB0cn1lbHNle3Rocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSBcIisoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZT9oYW5kbGUuJCQuc21hcnRQdHJUeXBlLm5hbWU6aGFuZGxlLiQkLnB0clR5cGUubmFtZSkrXCIgdG8gcGFyYW1ldGVyIHR5cGUgXCIrdGhpcy5uYW1lKX1icmVhaztjYXNlIDE6cHRyPWhhbmRsZS4kJC5zbWFydFB0cjticmVhaztjYXNlIDI6aWYoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZT09PXRoaXMpe3B0cj1oYW5kbGUuJCQuc21hcnRQdHJ9ZWxzZXt2YXIgY2xvbmVkSGFuZGxlPWhhbmRsZVtcImNsb25lXCJdKCk7cHRyPXRoaXMucmF3U2hhcmUocHRyLF9fZW12YWxfcmVnaXN0ZXIoKGZ1bmN0aW9uKCl7Y2xvbmVkSGFuZGxlW1wiZGVsZXRlXCJdKCl9KSkpO2lmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IscHRyKX19YnJlYWs7ZGVmYXVsdDp0aHJvd0JpbmRpbmdFcnJvcihcIlVuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeVwiKX19cmV0dXJuIHB0cn1mdW5jdGlvbiBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycyxoYW5kbGUpe2lmKGhhbmRsZT09PW51bGwpe2lmKHRoaXMuaXNSZWZlcmVuY2Upe3Rocm93QmluZGluZ0Vycm9yKFwibnVsbCBpcyBub3QgYSB2YWxpZCBcIit0aGlzLm5hbWUpfXJldHVybiAwfWlmKCFoYW5kbGUuJCQpe3Rocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyBcIicrX2VtYmluZF9yZXByKGhhbmRsZSkrJ1wiIGFzIGEgJyt0aGlzLm5hbWUpfWlmKCFoYW5kbGUuJCQucHRyKXt0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlIFwiK3RoaXMubmFtZSl9aWYoaGFuZGxlLiQkLnB0clR5cGUuaXNDb25zdCl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlIFwiK2hhbmRsZS4kJC5wdHJUeXBlLm5hbWUrXCIgdG8gcGFyYW1ldGVyIHR5cGUgXCIrdGhpcy5uYW1lKX12YXIgaGFuZGxlQ2xhc3M9aGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3ZhciBwdHI9dXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLGhhbmRsZUNsYXNzLHRoaXMucmVnaXN0ZXJlZENsYXNzKTtyZXR1cm4gcHRyfWZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyX2dldFBvaW50ZWUocHRyKXtpZih0aGlzLnJhd0dldFBvaW50ZWUpe3B0cj10aGlzLnJhd0dldFBvaW50ZWUocHRyKX1yZXR1cm4gcHRyfWZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyX2Rlc3RydWN0b3IocHRyKXtpZih0aGlzLnJhd0Rlc3RydWN0b3Ipe3RoaXMucmF3RGVzdHJ1Y3RvcihwdHIpfX1mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3QoaGFuZGxlKXtpZihoYW5kbGUhPT1udWxsKXtoYW5kbGVbXCJkZWxldGVcIl0oKX19ZnVuY3Rpb24gZG93bmNhc3RQb2ludGVyKHB0cixwdHJDbGFzcyxkZXNpcmVkQ2xhc3Mpe2lmKHB0ckNsYXNzPT09ZGVzaXJlZENsYXNzKXtyZXR1cm4gcHRyfWlmKHVuZGVmaW5lZD09PWRlc2lyZWRDbGFzcy5iYXNlQ2xhc3Mpe3JldHVybiBudWxsfXZhciBydj1kb3duY2FzdFBvaW50ZXIocHRyLHB0ckNsYXNzLGRlc2lyZWRDbGFzcy5iYXNlQ2xhc3MpO2lmKHJ2PT09bnVsbCl7cmV0dXJuIG51bGx9cmV0dXJuIGRlc2lyZWRDbGFzcy5kb3duY2FzdChydil9ZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCgpe3JldHVybiBPYmplY3Qua2V5cyhyZWdpc3RlcmVkSW5zdGFuY2VzKS5sZW5ndGh9ZnVuY3Rpb24gZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcygpe3ZhciBydj1bXTtmb3IodmFyIGsgaW4gcmVnaXN0ZXJlZEluc3RhbmNlcyl7aWYocmVnaXN0ZXJlZEluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrKSl7cnYucHVzaChyZWdpc3RlcmVkSW5zdGFuY2VzW2tdKX19cmV0dXJuIHJ2fWZ1bmN0aW9uIHNldERlbGF5RnVuY3Rpb24oZm4pe2RlbGF5RnVuY3Rpb249Zm47aWYoZGVsZXRpb25RdWV1ZS5sZW5ndGgmJmRlbGF5RnVuY3Rpb24pe2RlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyl9fWZ1bmN0aW9uIGluaXRfZW1iaW5kKCl7TW9kdWxlW1wiZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudFwiXT1nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50O01vZHVsZVtcImdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXNcIl09Z2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcztNb2R1bGVbXCJmbHVzaFBlbmRpbmdEZWxldGVzXCJdPWZsdXNoUGVuZGluZ0RlbGV0ZXM7TW9kdWxlW1wic2V0RGVsYXlGdW5jdGlvblwiXT1zZXREZWxheUZ1bmN0aW9ufXZhciByZWdpc3RlcmVkSW5zdGFuY2VzPXt9O2Z1bmN0aW9uIGdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLHB0cil7aWYocHRyPT09dW5kZWZpbmVkKXt0aHJvd0JpbmRpbmdFcnJvcihcInB0ciBzaG91bGQgbm90IGJlIHVuZGVmaW5lZFwiKX13aGlsZShjbGFzc18uYmFzZUNsYXNzKXtwdHI9Y2xhc3NfLnVwY2FzdChwdHIpO2NsYXNzXz1jbGFzc18uYmFzZUNsYXNzfXJldHVybiBwdHJ9ZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2UoY2xhc3NfLHB0cil7cHRyPWdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLHB0cik7cmV0dXJuIHJlZ2lzdGVyZWRJbnN0YW5jZXNbcHRyXX1mdW5jdGlvbiBtYWtlQ2xhc3NIYW5kbGUocHJvdG90eXBlLHJlY29yZCl7aWYoIXJlY29yZC5wdHJUeXBlfHwhcmVjb3JkLnB0cil7dGhyb3dJbnRlcm5hbEVycm9yKFwibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZVwiKX12YXIgaGFzU21hcnRQdHJUeXBlPSEhcmVjb3JkLnNtYXJ0UHRyVHlwZTt2YXIgaGFzU21hcnRQdHI9ISFyZWNvcmQuc21hcnRQdHI7aWYoaGFzU21hcnRQdHJUeXBlIT09aGFzU21hcnRQdHIpe3Rocm93SW50ZXJuYWxFcnJvcihcIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZFwiKX1yZWNvcmQuY291bnQ9e3ZhbHVlOjF9O3JldHVybiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSx7JCQ6e3ZhbHVlOnJlY29yZH19KX1mdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGUocHRyKXt2YXIgcmF3UG9pbnRlcj10aGlzLmdldFBvaW50ZWUocHRyKTtpZighcmF3UG9pbnRlcil7dGhpcy5kZXN0cnVjdG9yKHB0cik7cmV0dXJuIG51bGx9dmFyIHJlZ2lzdGVyZWRJbnN0YW5jZT1nZXRJbmhlcml0ZWRJbnN0YW5jZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcyxyYXdQb2ludGVyKTtpZih1bmRlZmluZWQhPT1yZWdpc3RlcmVkSW5zdGFuY2Upe2lmKDA9PT1yZWdpc3RlcmVkSW5zdGFuY2UuJCQuY291bnQudmFsdWUpe3JlZ2lzdGVyZWRJbnN0YW5jZS4kJC5wdHI9cmF3UG9pbnRlcjtyZWdpc3RlcmVkSW5zdGFuY2UuJCQuc21hcnRQdHI9cHRyO3JldHVybiByZWdpc3RlcmVkSW5zdGFuY2VbXCJjbG9uZVwiXSgpfWVsc2V7dmFyIHJ2PXJlZ2lzdGVyZWRJbnN0YW5jZVtcImNsb25lXCJdKCk7dGhpcy5kZXN0cnVjdG9yKHB0cik7cmV0dXJuIHJ2fX1mdW5jdGlvbiBtYWtlRGVmYXVsdEhhbmRsZSgpe2lmKHRoaXMuaXNTbWFydFBvaW50ZXIpe3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dGhpcy5wb2ludGVlVHlwZSxwdHI6cmF3UG9pbnRlcixzbWFydFB0clR5cGU6dGhpcyxzbWFydFB0cjpwdHJ9KX1lbHNle3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dGhpcyxwdHI6cHRyfSl9fXZhciBhY3R1YWxUeXBlPXRoaXMucmVnaXN0ZXJlZENsYXNzLmdldEFjdHVhbFR5cGUocmF3UG9pbnRlcik7dmFyIHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkPXJlZ2lzdGVyZWRQb2ludGVyc1thY3R1YWxUeXBlXTtpZighcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQpe3JldHVybiBtYWtlRGVmYXVsdEhhbmRsZS5jYWxsKHRoaXMpfXZhciB0b1R5cGU7aWYodGhpcy5pc0NvbnN0KXt0b1R5cGU9cmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQuY29uc3RQb2ludGVyVHlwZX1lbHNle3RvVHlwZT1yZWdpc3RlcmVkUG9pbnRlclJlY29yZC5wb2ludGVyVHlwZX12YXIgZHA9ZG93bmNhc3RQb2ludGVyKHJhd1BvaW50ZXIsdGhpcy5yZWdpc3RlcmVkQ2xhc3MsdG9UeXBlLnJlZ2lzdGVyZWRDbGFzcyk7aWYoZHA9PT1udWxsKXtyZXR1cm4gbWFrZURlZmF1bHRIYW5kbGUuY2FsbCh0aGlzKX1pZih0aGlzLmlzU21hcnRQb2ludGVyKXtyZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dG9UeXBlLHB0cjpkcCxzbWFydFB0clR5cGU6dGhpcyxzbWFydFB0cjpwdHJ9KX1lbHNle3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0b1R5cGUscHRyOmRwfSl9fWZ1bmN0aW9uIGluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKXtSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGUuZ2V0UG9pbnRlZT1SZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlO1JlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZS5kZXN0cnVjdG9yPVJlZ2lzdGVyZWRQb2ludGVyX2Rlc3RydWN0b3I7UmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlW1wiYXJnUGFja0FkdmFuY2VcIl09ODtSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiXT1zaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcjtSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbXCJkZWxldGVPYmplY3RcIl09UmVnaXN0ZXJlZFBvaW50ZXJfZGVsZXRlT2JqZWN0O1JlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVtcImZyb21XaXJlVHlwZVwiXT1SZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGV9ZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXIobmFtZSxyZWdpc3RlcmVkQ2xhc3MsaXNSZWZlcmVuY2UsaXNDb25zdCxpc1NtYXJ0UG9pbnRlcixwb2ludGVlVHlwZSxzaGFyaW5nUG9saWN5LHJhd0dldFBvaW50ZWUscmF3Q29uc3RydWN0b3IscmF3U2hhcmUscmF3RGVzdHJ1Y3Rvcil7dGhpcy5uYW1lPW5hbWU7dGhpcy5yZWdpc3RlcmVkQ2xhc3M9cmVnaXN0ZXJlZENsYXNzO3RoaXMuaXNSZWZlcmVuY2U9aXNSZWZlcmVuY2U7dGhpcy5pc0NvbnN0PWlzQ29uc3Q7dGhpcy5pc1NtYXJ0UG9pbnRlcj1pc1NtYXJ0UG9pbnRlcjt0aGlzLnBvaW50ZWVUeXBlPXBvaW50ZWVUeXBlO3RoaXMuc2hhcmluZ1BvbGljeT1zaGFyaW5nUG9saWN5O3RoaXMucmF3R2V0UG9pbnRlZT1yYXdHZXRQb2ludGVlO3RoaXMucmF3Q29uc3RydWN0b3I9cmF3Q29uc3RydWN0b3I7dGhpcy5yYXdTaGFyZT1yYXdTaGFyZTt0aGlzLnJhd0Rlc3RydWN0b3I9cmF3RGVzdHJ1Y3RvcjtpZighaXNTbWFydFBvaW50ZXImJnJlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3M9PT11bmRlZmluZWQpe2lmKGlzQ29uc3Qpe3RoaXNbXCJ0b1dpcmVUeXBlXCJdPWNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlO3RoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uPW51bGx9ZWxzZXt0aGlzW1widG9XaXJlVHlwZVwiXT1ub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTt0aGlzLmRlc3RydWN0b3JGdW5jdGlvbj1udWxsfX1lbHNle3RoaXNbXCJ0b1dpcmVUeXBlXCJdPWdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZX19ZnVuY3Rpb24gcmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLHZhbHVlLG51bUFyZ3VtZW50cyl7aWYoIU1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7dGhyb3dJbnRlcm5hbEVycm9yKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIil9aWYodW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGUmJnVuZGVmaW5lZCE9PW51bUFyZ3VtZW50cyl7TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXT12YWx1ZX1lbHNle01vZHVsZVtuYW1lXT12YWx1ZTtNb2R1bGVbbmFtZV0uYXJnQ291bnQ9bnVtQXJndW1lbnRzfX1mdW5jdGlvbiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzaWduYXR1cmUscmF3RnVuY3Rpb24pe3NpZ25hdHVyZT1yZWFkTGF0aW4xU3RyaW5nKHNpZ25hdHVyZSk7ZnVuY3Rpb24gbWFrZUR5bkNhbGxlcihkeW5DYWxsKXt2YXIgYXJncz1bXTtmb3IodmFyIGk9MTtpPHNpZ25hdHVyZS5sZW5ndGg7KytpKXthcmdzLnB1c2goXCJhXCIraSl9dmFyIG5hbWU9XCJkeW5DYWxsX1wiK3NpZ25hdHVyZStcIl9cIityYXdGdW5jdGlvbjt2YXIgYm9keT1cInJldHVybiBmdW5jdGlvbiBcIituYW1lK1wiKFwiK2FyZ3Muam9pbihcIiwgXCIpK1wiKSB7XFxuXCI7Ym9keSs9XCIgICAgcmV0dXJuIGR5bkNhbGwocmF3RnVuY3Rpb25cIisoYXJncy5sZW5ndGg/XCIsIFwiOlwiXCIpK2FyZ3Muam9pbihcIiwgXCIpK1wiKTtcXG5cIjtib2R5Kz1cIn07XFxuXCI7cmV0dXJuKG5ldyBGdW5jdGlvbihcImR5bkNhbGxcIixcInJhd0Z1bmN0aW9uXCIsYm9keSkpKGR5bkNhbGwscmF3RnVuY3Rpb24pfXZhciBmcDtpZihNb2R1bGVbXCJGVU5DVElPTl9UQUJMRV9cIitzaWduYXR1cmVdIT09dW5kZWZpbmVkKXtmcD1Nb2R1bGVbXCJGVU5DVElPTl9UQUJMRV9cIitzaWduYXR1cmVdW3Jhd0Z1bmN0aW9uXX1lbHNlIGlmKHR5cGVvZiBGVU5DVElPTl9UQUJMRSE9PVwidW5kZWZpbmVkXCIpe2ZwPUZVTkNUSU9OX1RBQkxFW3Jhd0Z1bmN0aW9uXX1lbHNle3ZhciBkYz1Nb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX1wiK3NpZ25hdHVyZV07aWYoZGM9PT11bmRlZmluZWQpe2RjPU1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfXCIrc2lnbmF0dXJlLnJlcGxhY2UoL2YvZyxcImRcIildO2lmKGRjPT09dW5kZWZpbmVkKXt0aHJvd0JpbmRpbmdFcnJvcihcIk5vIGR5bkNhbGwgaW52b2tlciBmb3Igc2lnbmF0dXJlOiBcIitzaWduYXR1cmUpfX1mcD1tYWtlRHluQ2FsbGVyKGRjKX1pZih0eXBlb2YgZnAhPT1cImZ1bmN0aW9uXCIpe3Rocm93QmluZGluZ0Vycm9yKFwidW5rbm93biBmdW5jdGlvbiBwb2ludGVyIHdpdGggc2lnbmF0dXJlIFwiK3NpZ25hdHVyZStcIjogXCIrcmF3RnVuY3Rpb24pfXJldHVybiBmcH12YXIgVW5ib3VuZFR5cGVFcnJvcj11bmRlZmluZWQ7ZnVuY3Rpb24gZ2V0VHlwZU5hbWUodHlwZSl7dmFyIHB0cj1fX19nZXRUeXBlTmFtZSh0eXBlKTt2YXIgcnY9cmVhZExhdGluMVN0cmluZyhwdHIpO19mcmVlKHB0cik7cmV0dXJuIHJ2fWZ1bmN0aW9uIHRocm93VW5ib3VuZFR5cGVFcnJvcihtZXNzYWdlLHR5cGVzKXt2YXIgdW5ib3VuZFR5cGVzPVtdO3ZhciBzZWVuPXt9O2Z1bmN0aW9uIHZpc2l0KHR5cGUpe2lmKHNlZW5bdHlwZV0pe3JldHVybn1pZihyZWdpc3RlcmVkVHlwZXNbdHlwZV0pe3JldHVybn1pZih0eXBlRGVwZW5kZW5jaWVzW3R5cGVdKXt0eXBlRGVwZW5kZW5jaWVzW3R5cGVdLmZvckVhY2godmlzaXQpO3JldHVybn11bmJvdW5kVHlwZXMucHVzaCh0eXBlKTtzZWVuW3R5cGVdPXRydWV9dHlwZXMuZm9yRWFjaCh2aXNpdCk7dGhyb3cgbmV3IFVuYm91bmRUeXBlRXJyb3IobWVzc2FnZStcIjogXCIrdW5ib3VuZFR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbihbXCIsIFwiXSkpfWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzKHJhd1R5cGUscmF3UG9pbnRlclR5cGUscmF3Q29uc3RQb2ludGVyVHlwZSxiYXNlQ2xhc3NSYXdUeXBlLGdldEFjdHVhbFR5cGVTaWduYXR1cmUsZ2V0QWN0dWFsVHlwZSx1cGNhc3RTaWduYXR1cmUsdXBjYXN0LGRvd25jYXN0U2lnbmF0dXJlLGRvd25jYXN0LG5hbWUsZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKXtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7Z2V0QWN0dWFsVHlwZT1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXRBY3R1YWxUeXBlU2lnbmF0dXJlLGdldEFjdHVhbFR5cGUpO2lmKHVwY2FzdCl7dXBjYXN0PWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHVwY2FzdFNpZ25hdHVyZSx1cGNhc3QpfWlmKGRvd25jYXN0KXtkb3duY2FzdD1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkb3duY2FzdFNpZ25hdHVyZSxkb3duY2FzdCl9cmF3RGVzdHJ1Y3Rvcj1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3IpO3ZhciBsZWdhbEZ1bmN0aW9uTmFtZT1tYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSk7ZXhwb3NlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLChmdW5jdGlvbigpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgXCIrbmFtZStcIiBkdWUgdG8gdW5ib3VuZCB0eXBlc1wiLFtiYXNlQ2xhc3NSYXdUeXBlXSl9KSk7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW3Jhd1R5cGUscmF3UG9pbnRlclR5cGUscmF3Q29uc3RQb2ludGVyVHlwZV0sYmFzZUNsYXNzUmF3VHlwZT9bYmFzZUNsYXNzUmF3VHlwZV06W10sKGZ1bmN0aW9uKGJhc2Upe2Jhc2U9YmFzZVswXTt2YXIgYmFzZUNsYXNzO3ZhciBiYXNlUHJvdG90eXBlO2lmKGJhc2VDbGFzc1Jhd1R5cGUpe2Jhc2VDbGFzcz1iYXNlLnJlZ2lzdGVyZWRDbGFzcztiYXNlUHJvdG90eXBlPWJhc2VDbGFzcy5pbnN0YW5jZVByb3RvdHlwZX1lbHNle2Jhc2VQcm90b3R5cGU9Q2xhc3NIYW5kbGUucHJvdG90eXBlfXZhciBjb25zdHJ1Y3Rvcj1jcmVhdGVOYW1lZEZ1bmN0aW9uKGxlZ2FsRnVuY3Rpb25OYW1lLChmdW5jdGlvbigpe2lmKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSE9PWluc3RhbmNlUHJvdG90eXBlKXt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKFwiVXNlICduZXcnIHRvIGNvbnN0cnVjdCBcIituYW1lKX1pZih1bmRlZmluZWQ9PT1yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSl7dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihuYW1lK1wiIGhhcyBubyBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yXCIpfXZhciBib2R5PXJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ3VtZW50cy5sZW5ndGhdO2lmKHVuZGVmaW5lZD09PWJvZHkpe3Rocm93IG5ldyBCaW5kaW5nRXJyb3IoXCJUcmllZCB0byBpbnZva2UgY3RvciBvZiBcIituYW1lK1wiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoXCIrYXJndW1lbnRzLmxlbmd0aCtcIikgLSBleHBlY3RlZCAoXCIrT2JqZWN0LmtleXMocmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpLnRvU3RyaW5nKCkrXCIpIHBhcmFtZXRlcnMgaW5zdGVhZCFcIil9cmV0dXJuIGJvZHkuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkpO3ZhciBpbnN0YW5jZVByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGJhc2VQcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpjb25zdHJ1Y3Rvcn19KTtjb25zdHJ1Y3Rvci5wcm90b3R5cGU9aW5zdGFuY2VQcm90b3R5cGU7dmFyIHJlZ2lzdGVyZWRDbGFzcz1uZXcgUmVnaXN0ZXJlZENsYXNzKG5hbWUsY29uc3RydWN0b3IsaW5zdGFuY2VQcm90b3R5cGUscmF3RGVzdHJ1Y3RvcixiYXNlQ2xhc3MsZ2V0QWN0dWFsVHlwZSx1cGNhc3QsZG93bmNhc3QpO3ZhciByZWZlcmVuY2VDb252ZXJ0ZXI9bmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUscmVnaXN0ZXJlZENsYXNzLHRydWUsZmFsc2UsZmFsc2UpO3ZhciBwb2ludGVyQ29udmVydGVyPW5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lK1wiKlwiLHJlZ2lzdGVyZWRDbGFzcyxmYWxzZSxmYWxzZSxmYWxzZSk7dmFyIGNvbnN0UG9pbnRlckNvbnZlcnRlcj1uZXcgUmVnaXN0ZXJlZFBvaW50ZXIobmFtZStcIiBjb25zdCpcIixyZWdpc3RlcmVkQ2xhc3MsZmFsc2UsdHJ1ZSxmYWxzZSk7cmVnaXN0ZXJlZFBvaW50ZXJzW3Jhd1R5cGVdPXtwb2ludGVyVHlwZTpwb2ludGVyQ29udmVydGVyLGNvbnN0UG9pbnRlclR5cGU6Y29uc3RQb2ludGVyQ29udmVydGVyfTtyZXBsYWNlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLGNvbnN0cnVjdG9yKTtyZXR1cm5bcmVmZXJlbmNlQ29udmVydGVyLHBvaW50ZXJDb252ZXJ0ZXIsY29uc3RQb2ludGVyQ29udmVydGVyXX0pKX1mdW5jdGlvbiBoZWFwMzJWZWN0b3JUb0FycmF5KGNvdW50LGZpcnN0RWxlbWVudCl7dmFyIGFycmF5PVtdO2Zvcih2YXIgaT0wO2k8Y291bnQ7aSsrKXthcnJheS5wdXNoKEhFQVAzMlsoZmlyc3RFbGVtZW50Pj4yKStpXSl9cmV0dXJuIGFycmF5fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yKHJhd0NsYXNzVHlwZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsaW52b2tlclNpZ25hdHVyZSxpbnZva2VyLHJhd0NvbnN0cnVjdG9yKXt2YXIgcmF3QXJnVHlwZXM9aGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIpO2ludm9rZXI9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSxpbnZva2VyKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxbcmF3Q2xhc3NUeXBlXSwoZnVuY3Rpb24oY2xhc3NUeXBlKXtjbGFzc1R5cGU9Y2xhc3NUeXBlWzBdO3ZhciBodW1hbk5hbWU9XCJjb25zdHJ1Y3RvciBcIitjbGFzc1R5cGUubmFtZTtpZih1bmRlZmluZWQ9PT1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpe2NsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keT1bXX1pZih1bmRlZmluZWQhPT1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQtMV0pe3Rocm93IG5ldyBCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzIChcIisoYXJnQ291bnQtMSkrXCIpIGZvciBjbGFzcyAnXCIrY2xhc3NUeXBlLm5hbWUrXCInISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFcIil9Y2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50LTFdPWZ1bmN0aW9uIHVuYm91bmRUeXBlSGFuZGxlcigpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgXCIrY2xhc3NUeXBlLm5hbWUrXCIgZHVlIHRvIHVuYm91bmQgdHlwZXNcIixyYXdBcmdUeXBlcyl9O3doZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLHJhd0FyZ1R5cGVzLChmdW5jdGlvbihhcmdUeXBlcyl7Y2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50LTFdPWZ1bmN0aW9uIGNvbnN0cnVjdG9yX2JvZHkoKXtpZihhcmd1bWVudHMubGVuZ3RoIT09YXJnQ291bnQtMSl7dGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lK1wiIGNhbGxlZCB3aXRoIFwiK2FyZ3VtZW50cy5sZW5ndGgrXCIgYXJndW1lbnRzLCBleHBlY3RlZCBcIisoYXJnQ291bnQtMSkpfXZhciBkZXN0cnVjdG9ycz1bXTt2YXIgYXJncz1uZXcgQXJyYXkoYXJnQ291bnQpO2FyZ3NbMF09cmF3Q29uc3RydWN0b3I7Zm9yKHZhciBpPTE7aTxhcmdDb3VudDsrK2kpe2FyZ3NbaV09YXJnVHlwZXNbaV1bXCJ0b1dpcmVUeXBlXCJdKGRlc3RydWN0b3JzLGFyZ3VtZW50c1tpLTFdKX12YXIgcHRyPWludm9rZXIuYXBwbHkobnVsbCxhcmdzKTtydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7cmV0dXJuIGFyZ1R5cGVzWzBdW1wiZnJvbVdpcmVUeXBlXCJdKHB0cil9O3JldHVybltdfSkpO3JldHVybltdfSkpfWZ1bmN0aW9uIG5ld18oY29uc3RydWN0b3IsYXJndW1lbnRMaXN0KXtpZighKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwibmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlIFwiK3R5cGVvZiBjb25zdHJ1Y3RvcitcIiB3aGljaCBpcyBub3QgYSBmdW5jdGlvblwiKX12YXIgZHVtbXk9Y3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvci5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIiwoZnVuY3Rpb24oKXt9KSk7ZHVtbXkucHJvdG90eXBlPWNvbnN0cnVjdG9yLnByb3RvdHlwZTt2YXIgb2JqPW5ldyBkdW1teTt2YXIgcj1jb25zdHJ1Y3Rvci5hcHBseShvYmosYXJndW1lbnRMaXN0KTtyZXR1cm4gciBpbnN0YW5jZW9mIE9iamVjdD9yOm9ian1mdW5jdGlvbiBjcmFmdEludm9rZXJGdW5jdGlvbihodW1hbk5hbWUsYXJnVHlwZXMsY2xhc3NUeXBlLGNwcEludm9rZXJGdW5jLGNwcFRhcmdldEZ1bmMpe3ZhciBhcmdDb3VudD1hcmdUeXBlcy5sZW5ndGg7aWYoYXJnQ291bnQ8Mil7dGhyb3dCaW5kaW5nRXJyb3IoXCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyFcIil9dmFyIGlzQ2xhc3NNZXRob2RGdW5jPWFyZ1R5cGVzWzFdIT09bnVsbCYmY2xhc3NUeXBlIT09bnVsbDt2YXIgbmVlZHNEZXN0cnVjdG9yU3RhY2s9ZmFsc2U7Zm9yKHZhciBpPTE7aTxhcmdUeXBlcy5sZW5ndGg7KytpKXtpZihhcmdUeXBlc1tpXSE9PW51bGwmJmFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbj09PXVuZGVmaW5lZCl7bmVlZHNEZXN0cnVjdG9yU3RhY2s9dHJ1ZTticmVha319dmFyIHJldHVybnM9YXJnVHlwZXNbMF0ubmFtZSE9PVwidm9pZFwiO3ZhciBhcmdzTGlzdD1cIlwiO3ZhciBhcmdzTGlzdFdpcmVkPVwiXCI7Zm9yKHZhciBpPTA7aTxhcmdDb3VudC0yOysraSl7YXJnc0xpc3QrPShpIT09MD9cIiwgXCI6XCJcIikrXCJhcmdcIitpO2FyZ3NMaXN0V2lyZWQrPShpIT09MD9cIiwgXCI6XCJcIikrXCJhcmdcIitpK1wiV2lyZWRcIn12YXIgaW52b2tlckZuQm9keT1cInJldHVybiBmdW5jdGlvbiBcIittYWtlTGVnYWxGdW5jdGlvbk5hbWUoaHVtYW5OYW1lKStcIihcIithcmdzTGlzdCtcIikge1xcblwiK1wiaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IFwiKyhhcmdDb3VudC0yKStcIikge1xcblwiK1widGhyb3dCaW5kaW5nRXJyb3IoJ2Z1bmN0aW9uIFwiK2h1bWFuTmFtZStcIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCBcIisoYXJnQ291bnQtMikrXCIgYXJncyEnKTtcXG5cIitcIn1cXG5cIjtpZihuZWVkc0Rlc3RydWN0b3JTdGFjayl7aW52b2tlckZuQm9keSs9XCJ2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcXG5cIn12YXIgZHRvclN0YWNrPW5lZWRzRGVzdHJ1Y3RvclN0YWNrP1wiZGVzdHJ1Y3RvcnNcIjpcIm51bGxcIjt2YXIgYXJnczE9W1widGhyb3dCaW5kaW5nRXJyb3JcIixcImludm9rZXJcIixcImZuXCIsXCJydW5EZXN0cnVjdG9yc1wiLFwicmV0VHlwZVwiLFwiY2xhc3NQYXJhbVwiXTt2YXIgYXJnczI9W3Rocm93QmluZGluZ0Vycm9yLGNwcEludm9rZXJGdW5jLGNwcFRhcmdldEZ1bmMscnVuRGVzdHJ1Y3RvcnMsYXJnVHlwZXNbMF0sYXJnVHlwZXNbMV1dO2lmKGlzQ2xhc3NNZXRob2RGdW5jKXtpbnZva2VyRm5Cb2R5Kz1cInZhciB0aGlzV2lyZWQgPSBjbGFzc1BhcmFtLnRvV2lyZVR5cGUoXCIrZHRvclN0YWNrK1wiLCB0aGlzKTtcXG5cIn1mb3IodmFyIGk9MDtpPGFyZ0NvdW50LTI7KytpKXtpbnZva2VyRm5Cb2R5Kz1cInZhciBhcmdcIitpK1wiV2lyZWQgPSBhcmdUeXBlXCIraStcIi50b1dpcmVUeXBlKFwiK2R0b3JTdGFjaytcIiwgYXJnXCIraStcIik7IC8vIFwiK2FyZ1R5cGVzW2krMl0ubmFtZStcIlxcblwiO2FyZ3MxLnB1c2goXCJhcmdUeXBlXCIraSk7YXJnczIucHVzaChhcmdUeXBlc1tpKzJdKX1pZihpc0NsYXNzTWV0aG9kRnVuYyl7YXJnc0xpc3RXaXJlZD1cInRoaXNXaXJlZFwiKyhhcmdzTGlzdFdpcmVkLmxlbmd0aD4wP1wiLCBcIjpcIlwiKSthcmdzTGlzdFdpcmVkfWludm9rZXJGbkJvZHkrPShyZXR1cm5zP1widmFyIHJ2ID0gXCI6XCJcIikrXCJpbnZva2VyKGZuXCIrKGFyZ3NMaXN0V2lyZWQubGVuZ3RoPjA/XCIsIFwiOlwiXCIpK2FyZ3NMaXN0V2lyZWQrXCIpO1xcblwiO2lmKG5lZWRzRGVzdHJ1Y3RvclN0YWNrKXtpbnZva2VyRm5Cb2R5Kz1cInJ1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKTtcXG5cIn1lbHNle2Zvcih2YXIgaT1pc0NsYXNzTWV0aG9kRnVuYz8xOjI7aTxhcmdUeXBlcy5sZW5ndGg7KytpKXt2YXIgcGFyYW1OYW1lPWk9PT0xP1widGhpc1dpcmVkXCI6XCJhcmdcIisoaS0yKStcIldpcmVkXCI7aWYoYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uIT09bnVsbCl7aW52b2tlckZuQm9keSs9cGFyYW1OYW1lK1wiX2R0b3IoXCIrcGFyYW1OYW1lK1wiKTsgLy8gXCIrYXJnVHlwZXNbaV0ubmFtZStcIlxcblwiO2FyZ3MxLnB1c2gocGFyYW1OYW1lK1wiX2R0b3JcIik7YXJnczIucHVzaChhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24pfX19aWYocmV0dXJucyl7aW52b2tlckZuQm9keSs9XCJ2YXIgcmV0ID0gcmV0VHlwZS5mcm9tV2lyZVR5cGUocnYpO1xcblwiK1wicmV0dXJuIHJldDtcXG5cIn1lbHNle31pbnZva2VyRm5Cb2R5Kz1cIn1cXG5cIjthcmdzMS5wdXNoKGludm9rZXJGbkJvZHkpO3ZhciBpbnZva2VyRnVuY3Rpb249bmV3XyhGdW5jdGlvbixhcmdzMSkuYXBwbHkobnVsbCxhcmdzMik7cmV0dXJuIGludm9rZXJGdW5jdGlvbn1mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbihyYXdDbGFzc1R5cGUsbWV0aG9kTmFtZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsaW52b2tlclNpZ25hdHVyZSxyYXdJbnZva2VyLGNvbnRleHQsaXNQdXJlVmlydHVhbCl7dmFyIHJhd0FyZ1R5cGVzPWhlYXAzMlZlY3RvclRvQXJyYXkoYXJnQ291bnQscmF3QXJnVHlwZXNBZGRyKTttZXRob2ROYW1lPXJlYWRMYXRpbjFTdHJpbmcobWV0aG9kTmFtZSk7cmF3SW52b2tlcj1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLHJhd0ludm9rZXIpO3doZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLFtyYXdDbGFzc1R5cGVdLChmdW5jdGlvbihjbGFzc1R5cGUpe2NsYXNzVHlwZT1jbGFzc1R5cGVbMF07dmFyIGh1bWFuTmFtZT1jbGFzc1R5cGUubmFtZStcIi5cIittZXRob2ROYW1lO2lmKGlzUHVyZVZpcnR1YWwpe2NsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MucHVyZVZpcnR1YWxGdW5jdGlvbnMucHVzaChtZXRob2ROYW1lKX1mdW5jdGlvbiB1bmJvdW5kVHlwZXNIYW5kbGVyKCl7dGhyb3dVbmJvdW5kVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgXCIraHVtYW5OYW1lK1wiIGR1ZSB0byB1bmJvdW5kIHR5cGVzXCIscmF3QXJnVHlwZXMpfXZhciBwcm90bz1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlO3ZhciBtZXRob2Q9cHJvdG9bbWV0aG9kTmFtZV07aWYodW5kZWZpbmVkPT09bWV0aG9kfHx1bmRlZmluZWQ9PT1tZXRob2Qub3ZlcmxvYWRUYWJsZSYmbWV0aG9kLmNsYXNzTmFtZSE9PWNsYXNzVHlwZS5uYW1lJiZtZXRob2QuYXJnQ291bnQ9PT1hcmdDb3VudC0yKXt1bmJvdW5kVHlwZXNIYW5kbGVyLmFyZ0NvdW50PWFyZ0NvdW50LTI7dW5ib3VuZFR5cGVzSGFuZGxlci5jbGFzc05hbWU9Y2xhc3NUeXBlLm5hbWU7cHJvdG9bbWV0aG9kTmFtZV09dW5ib3VuZFR5cGVzSGFuZGxlcn1lbHNle2Vuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpO3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQtMl09dW5ib3VuZFR5cGVzSGFuZGxlcn13aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxyYXdBcmdUeXBlcywoZnVuY3Rpb24oYXJnVHlwZXMpe3ZhciBtZW1iZXJGdW5jdGlvbj1jcmFmdEludm9rZXJGdW5jdGlvbihodW1hbk5hbWUsYXJnVHlwZXMsY2xhc3NUeXBlLHJhd0ludm9rZXIsY29udGV4dCk7aWYodW5kZWZpbmVkPT09cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSl7bWVtYmVyRnVuY3Rpb24uYXJnQ291bnQ9YXJnQ291bnQtMjtwcm90b1ttZXRob2ROYW1lXT1tZW1iZXJGdW5jdGlvbn1lbHNle3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQtMl09bWVtYmVyRnVuY3Rpb259cmV0dXJuW119KSk7cmV0dXJuW119KSl9dmFyIGVtdmFsX2ZyZWVfbGlzdD1bXTt2YXIgZW12YWxfaGFuZGxlX2FycmF5PVt7fSx7dmFsdWU6dW5kZWZpbmVkfSx7dmFsdWU6bnVsbH0se3ZhbHVlOnRydWV9LHt2YWx1ZTpmYWxzZX1dO2Z1bmN0aW9uIF9fZW12YWxfZGVjcmVmKGhhbmRsZSl7aWYoaGFuZGxlPjQmJjA9PT0tLWVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdLnJlZmNvdW50KXtlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXT11bmRlZmluZWQ7ZW12YWxfZnJlZV9saXN0LnB1c2goaGFuZGxlKX19ZnVuY3Rpb24gY291bnRfZW12YWxfaGFuZGxlcygpe3ZhciBjb3VudD0wO2Zvcih2YXIgaT01O2k8ZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsrK2kpe2lmKGVtdmFsX2hhbmRsZV9hcnJheVtpXSE9PXVuZGVmaW5lZCl7Kytjb3VudH19cmV0dXJuIGNvdW50fWZ1bmN0aW9uIGdldF9maXJzdF9lbXZhbCgpe2Zvcih2YXIgaT01O2k8ZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsrK2kpe2lmKGVtdmFsX2hhbmRsZV9hcnJheVtpXSE9PXVuZGVmaW5lZCl7cmV0dXJuIGVtdmFsX2hhbmRsZV9hcnJheVtpXX19cmV0dXJuIG51bGx9ZnVuY3Rpb24gaW5pdF9lbXZhbCgpe01vZHVsZVtcImNvdW50X2VtdmFsX2hhbmRsZXNcIl09Y291bnRfZW12YWxfaGFuZGxlcztNb2R1bGVbXCJnZXRfZmlyc3RfZW12YWxcIl09Z2V0X2ZpcnN0X2VtdmFsfWZ1bmN0aW9uIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpe3N3aXRjaCh2YWx1ZSl7Y2FzZSB1bmRlZmluZWQ6e3JldHVybiAxfTtjYXNlIG51bGw6e3JldHVybiAyfTtjYXNlIHRydWU6e3JldHVybiAzfTtjYXNlIGZhbHNlOntyZXR1cm4gNH07ZGVmYXVsdDp7dmFyIGhhbmRsZT1lbXZhbF9mcmVlX2xpc3QubGVuZ3RoP2VtdmFsX2ZyZWVfbGlzdC5wb3AoKTplbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoO2VtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdPXtyZWZjb3VudDoxLHZhbHVlOnZhbHVlfTtyZXR1cm4gaGFuZGxlfX19ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwocmF3VHlwZSxuYW1lKXtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOihmdW5jdGlvbihoYW5kbGUpe3ZhciBydj1lbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS52YWx1ZTtfX2VtdmFsX2RlY3JlZihoYW5kbGUpO3JldHVybiBydn0pLFwidG9XaXJlVHlwZVwiOihmdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7cmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpfSksXCJhcmdQYWNrQWR2YW5jZVwiOjgsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9ZnVuY3Rpb24gX2VtYmluZF9yZXByKHYpe2lmKHY9PT1udWxsKXtyZXR1cm5cIm51bGxcIn12YXIgdD10eXBlb2YgdjtpZih0PT09XCJvYmplY3RcInx8dD09PVwiYXJyYXlcInx8dD09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHYudG9TdHJpbmcoKX1lbHNle3JldHVyblwiXCIrdn19ZnVuY3Rpb24gZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLHNoaWZ0KXtzd2l0Y2goc2hpZnQpe2Nhc2UgMjpyZXR1cm4oZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUEYzMltwb2ludGVyPj4yXSl9KTtjYXNlIDM6cmV0dXJuKGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfSk7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBmbG9hdCB0eXBlOiBcIituYW1lKX19ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQocmF3VHlwZSxuYW1lLHNpemUpe3ZhciBzaGlmdD1nZXRTaGlmdEZyb21TaXplKHNpemUpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6KGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdmFsdWV9KSxcInRvV2lyZVR5cGVcIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwibnVtYmVyXCImJnR5cGVvZiB2YWx1ZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBcIicrX2VtYmluZF9yZXByKHZhbHVlKSsnXCIgdG8gJyt0aGlzLm5hbWUpfXJldHVybiB2YWx1ZX0pLFwiYXJnUGFja0FkdmFuY2VcIjo4LFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjpmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2hpZnQpLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9ZnVuY3Rpb24gaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2hpZnQsc2lnbmVkKXtzd2l0Y2goc2hpZnQpe2Nhc2UgMDpyZXR1cm4gc2lnbmVkP2Z1bmN0aW9uIHJlYWRTOEZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQOFtwb2ludGVyXX06ZnVuY3Rpb24gcmVhZFU4RnJvbVBvaW50ZXIocG9pbnRlcil7cmV0dXJuIEhFQVBVOFtwb2ludGVyXX07Y2FzZSAxOnJldHVybiBzaWduZWQ/ZnVuY3Rpb24gcmVhZFMxNkZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQMTZbcG9pbnRlcj4+MV19OmZ1bmN0aW9uIHJlYWRVMTZGcm9tUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gSEVBUFUxNltwb2ludGVyPj4xXX07Y2FzZSAyOnJldHVybiBzaWduZWQ/ZnVuY3Rpb24gcmVhZFMzMkZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiBIRUFQMzJbcG9pbnRlcj4+Ml19OmZ1bmN0aW9uIHJlYWRVMzJGcm9tUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gSEVBUFUzMltwb2ludGVyPj4yXX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBpbnRlZ2VyIHR5cGU6IFwiK25hbWUpfX1mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyKHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKXtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7aWYobWF4UmFuZ2U9PT0tMSl7bWF4UmFuZ2U9NDI5NDk2NzI5NX12YXIgc2hpZnQ9Z2V0U2hpZnRGcm9tU2l6ZShzaXplKTt2YXIgZnJvbVdpcmVUeXBlPShmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIHZhbHVlfSk7aWYobWluUmFuZ2U9PT0wKXt2YXIgYml0c2hpZnQ9MzItOCpzaXplO2Zyb21XaXJlVHlwZT0oZnVuY3Rpb24odmFsdWUpe3JldHVybiB2YWx1ZTw8Yml0c2hpZnQ+Pj5iaXRzaGlmdH0pfXZhciBpc1Vuc2lnbmVkVHlwZT1uYW1lLmluZGV4T2YoXCJ1bnNpZ25lZFwiKSE9LTE7cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOmZyb21XaXJlVHlwZSxcInRvV2lyZVR5cGVcIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZSE9PVwibnVtYmVyXCImJnR5cGVvZiB2YWx1ZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBcIicrX2VtYmluZF9yZXByKHZhbHVlKSsnXCIgdG8gJyt0aGlzLm5hbWUpfWlmKHZhbHVlPG1pblJhbmdlfHx2YWx1ZT5tYXhSYW5nZSl7dGhyb3cgbmV3IFR5cGVFcnJvcignUGFzc2luZyBhIG51bWJlciBcIicrX2VtYmluZF9yZXByKHZhbHVlKSsnXCIgZnJvbSBKUyBzaWRlIHRvIEMvQysrIHNpZGUgdG8gYW4gYXJndW1lbnQgb2YgdHlwZSBcIicrbmFtZSsnXCIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFsnK21pblJhbmdlK1wiLCBcIittYXhSYW5nZStcIl0hXCIpfXJldHVybiBpc1Vuc2lnbmVkVHlwZT92YWx1ZT4+PjA6dmFsdWV8MH0pLFwiYXJnUGFja0FkdmFuY2VcIjo4LFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaGlmdCxtaW5SYW5nZSE9PTApLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9ZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcocmF3VHlwZSxkYXRhVHlwZUluZGV4LG5hbWUpe3ZhciB0eXBlTWFwcGluZz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldO3ZhciBUQT10eXBlTWFwcGluZ1tkYXRhVHlwZUluZGV4XTtmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSl7aGFuZGxlPWhhbmRsZT4+Mjt2YXIgaGVhcD1IRUFQVTMyO3ZhciBzaXplPWhlYXBbaGFuZGxlXTt2YXIgZGF0YT1oZWFwW2hhbmRsZSsxXTtyZXR1cm4gbmV3IFRBKGhlYXBbXCJidWZmZXJcIl0sZGF0YSxzaXplKX1uYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOmRlY29kZU1lbW9yeVZpZXcsXCJhcmdQYWNrQWR2YW5jZVwiOjgsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOmRlY29kZU1lbW9yeVZpZXd9LHtpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOnRydWV9KX1mdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nKHJhd1R5cGUsbmFtZSl7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsXCJmcm9tV2lyZVR5cGVcIjooZnVuY3Rpb24odmFsdWUpe3ZhciBsZW5ndGg9SEVBUFUzMlt2YWx1ZT4+Ml07dmFyIGE9bmV3IEFycmF5KGxlbmd0aCk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXthW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoSEVBUFU4W3ZhbHVlKzQraV0pfV9mcmVlKHZhbHVlKTtyZXR1cm4gYS5qb2luKFwiXCIpfSksXCJ0b1dpcmVUeXBlXCI6KGZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YWx1ZT1uZXcgVWludDhBcnJheSh2YWx1ZSl9ZnVuY3Rpb24gZ2V0VEFFbGVtZW50KHRhLGluZGV4KXtyZXR1cm4gdGFbaW5kZXhdfWZ1bmN0aW9uIGdldFN0cmluZ0VsZW1lbnQoc3RyaW5nLGluZGV4KXtyZXR1cm4gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpfXZhciBnZXRFbGVtZW50O2lmKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSl7Z2V0RWxlbWVudD1nZXRUQUVsZW1lbnR9ZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KXtnZXRFbGVtZW50PWdldFRBRWxlbWVudH1lbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KXtnZXRFbGVtZW50PWdldFRBRWxlbWVudH1lbHNlIGlmKHR5cGVvZiB2YWx1ZT09PVwic3RyaW5nXCIpe2dldEVsZW1lbnQ9Z2V0U3RyaW5nRWxlbWVudH1lbHNle3Rocm93QmluZGluZ0Vycm9yKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKX12YXIgbGVuZ3RoPXZhbHVlLmxlbmd0aDt2YXIgcHRyPV9tYWxsb2MoNCtsZW5ndGgpO0hFQVBVMzJbcHRyPj4yXT1sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXt2YXIgY2hhckNvZGU9Z2V0RWxlbWVudCh2YWx1ZSxpKTtpZihjaGFyQ29kZT4yNTUpe19mcmVlKHB0cik7dGhyb3dCaW5kaW5nRXJyb3IoXCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHNcIil9SEVBUFU4W3B0cis0K2ldPWNoYXJDb2RlfWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSxwdHIpfXJldHVybiBwdHJ9KSxcImFyZ1BhY2tBZHZhbmNlXCI6OCxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOihmdW5jdGlvbihwdHIpe19mcmVlKHB0cil9KX0pfWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nKHJhd1R5cGUsY2hhclNpemUsbmFtZSl7bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBnZXRIZWFwLHNoaWZ0O2lmKGNoYXJTaXplPT09Mil7Z2V0SGVhcD0oZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUxNn0pO3NoaWZ0PTF9ZWxzZSBpZihjaGFyU2l6ZT09PTQpe2dldEhlYXA9KGZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJ9KTtzaGlmdD0yfXJlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsXCJmcm9tV2lyZVR5cGVcIjooZnVuY3Rpb24odmFsdWUpe3ZhciBIRUFQPWdldEhlYXAoKTt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBhPW5ldyBBcnJheShsZW5ndGgpO3ZhciBzdGFydD12YWx1ZSs0Pj5zaGlmdDtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2FbaV09U3RyaW5nLmZyb21DaGFyQ29kZShIRUFQW3N0YXJ0K2ldKX1fZnJlZSh2YWx1ZSk7cmV0dXJuIGEuam9pbihcIlwiKX0pLFwidG9XaXJlVHlwZVwiOihmdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7dmFyIEhFQVA9Z2V0SGVhcCgpO3ZhciBsZW5ndGg9dmFsdWUubGVuZ3RoO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCpjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aDt2YXIgc3RhcnQ9cHRyKzQ+PnNoaWZ0O2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7SEVBUFtzdGFydCtpXT12YWx1ZS5jaGFyQ29kZUF0KGkpfWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSxwdHIpfXJldHVybiBwdHJ9KSxcImFyZ1BhY2tBZHZhbmNlXCI6OCxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOihmdW5jdGlvbihwdHIpe19mcmVlKHB0cil9KX0pfWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdChyYXdUeXBlLG5hbWUsY29uc3RydWN0b3JTaWduYXR1cmUscmF3Q29uc3RydWN0b3IsZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKXtzdHJ1Y3RSZWdpc3RyYXRpb25zW3Jhd1R5cGVdPXtuYW1lOnJlYWRMYXRpbjFTdHJpbmcobmFtZSkscmF3Q29uc3RydWN0b3I6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oY29uc3RydWN0b3JTaWduYXR1cmUscmF3Q29uc3RydWN0b3IpLHJhd0Rlc3RydWN0b3I6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKSxmaWVsZHM6W119fWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZChzdHJ1Y3RUeXBlLGZpZWxkTmFtZSxnZXR0ZXJSZXR1cm5UeXBlLGdldHRlclNpZ25hdHVyZSxnZXR0ZXIsZ2V0dGVyQ29udGV4dCxzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyU2lnbmF0dXJlLHNldHRlcixzZXR0ZXJDb250ZXh0KXtzdHJ1Y3RSZWdpc3RyYXRpb25zW3N0cnVjdFR5cGVdLmZpZWxkcy5wdXNoKHtmaWVsZE5hbWU6cmVhZExhdGluMVN0cmluZyhmaWVsZE5hbWUpLGdldHRlclJldHVyblR5cGU6Z2V0dGVyUmV0dXJuVHlwZSxnZXR0ZXI6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0dGVyU2lnbmF0dXJlLGdldHRlciksZ2V0dGVyQ29udGV4dDpnZXR0ZXJDb250ZXh0LHNldHRlckFyZ3VtZW50VHlwZTpzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyOmVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSxzZXR0ZXIpLHNldHRlckNvbnRleHQ6c2V0dGVyQ29udGV4dH0pfWZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQocmF3VHlwZSxuYW1lKXtuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse2lzVm9pZDp0cnVlLG5hbWU6bmFtZSxcImFyZ1BhY2tBZHZhbmNlXCI6MCxcImZyb21XaXJlVHlwZVwiOihmdW5jdGlvbigpe3JldHVybiB1bmRlZmluZWR9KSxcInRvV2lyZVR5cGVcIjooZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7cmV0dXJuIHVuZGVmaW5lZH0pfSl9ZnVuY3Rpb24gX2Fib3J0KCl7TW9kdWxlW1wiYWJvcnRcIl0oKX12YXIgX2Vudmlyb249U1RBVElDVE9QO1NUQVRJQ1RPUCs9MTY7ZnVuY3Rpb24gX19fYnVpbGRFbnZpcm9ubWVudChlbnYpe3ZhciBNQVhfRU5WX1ZBTFVFUz02NDt2YXIgVE9UQUxfRU5WX1NJWkU9MTAyNDt2YXIgcG9vbFB0cjt2YXIgZW52UHRyO2lmKCFfX19idWlsZEVudmlyb25tZW50LmNhbGxlZCl7X19fYnVpbGRFbnZpcm9ubWVudC5jYWxsZWQ9dHJ1ZTtFTlZbXCJVU0VSXCJdPUVOVltcIkxPR05BTUVcIl09XCJ3ZWJfdXNlclwiO0VOVltcIlBBVEhcIl09XCIvXCI7RU5WW1wiUFdEXCJdPVwiL1wiO0VOVltcIkhPTUVcIl09XCIvaG9tZS93ZWJfdXNlclwiO0VOVltcIkxBTkdcIl09XCJDLlVURi04XCI7RU5WW1wiX1wiXT1Nb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXTtwb29sUHRyPXN0YXRpY0FsbG9jKFRPVEFMX0VOVl9TSVpFKTtlbnZQdHI9c3RhdGljQWxsb2MoTUFYX0VOVl9WQUxVRVMqNCk7SEVBUDMyW2VudlB0cj4+Ml09cG9vbFB0cjtIRUFQMzJbX2Vudmlyb24+PjJdPWVudlB0cn1lbHNle2VudlB0cj1IRUFQMzJbX2Vudmlyb24+PjJdO3Bvb2xQdHI9SEVBUDMyW2VudlB0cj4+Ml19dmFyIHN0cmluZ3M9W107dmFyIHRvdGFsU2l6ZT0wO2Zvcih2YXIga2V5IGluIGVudil7aWYodHlwZW9mIGVudltrZXldPT09XCJzdHJpbmdcIil7dmFyIGxpbmU9a2V5K1wiPVwiK2VudltrZXldO3N0cmluZ3MucHVzaChsaW5lKTt0b3RhbFNpemUrPWxpbmUubGVuZ3RofX1pZih0b3RhbFNpemU+VE9UQUxfRU5WX1NJWkUpe3Rocm93IG5ldyBFcnJvcihcIkVudmlyb25tZW50IHNpemUgZXhjZWVkZWQgVE9UQUxfRU5WX1NJWkUhXCIpfXZhciBwdHJTaXplPTQ7Zm9yKHZhciBpPTA7aTxzdHJpbmdzLmxlbmd0aDtpKyspe3ZhciBsaW5lPXN0cmluZ3NbaV07d3JpdGVBc2NpaVRvTWVtb3J5KGxpbmUscG9vbFB0cik7SEVBUDMyW2VudlB0citpKnB0clNpemU+PjJdPXBvb2xQdHI7cG9vbFB0cis9bGluZS5sZW5ndGgrMX1IRUFQMzJbZW52UHRyK3N0cmluZ3MubGVuZ3RoKnB0clNpemU+PjJdPTB9dmFyIEVOVj17fTtmdW5jdGlvbiBfZ2V0ZW52KG5hbWUpe2lmKG5hbWU9PT0wKXJldHVybiAwO25hbWU9UG9pbnRlcl9zdHJpbmdpZnkobmFtZSk7aWYoIUVOVi5oYXNPd25Qcm9wZXJ0eShuYW1lKSlyZXR1cm4gMDtpZihfZ2V0ZW52LnJldClfZnJlZShfZ2V0ZW52LnJldCk7X2dldGVudi5yZXQ9YWxsb2NhdGVVVEY4KEVOVltuYW1lXSk7cmV0dXJuIF9nZXRlbnYucmV0fWZ1bmN0aW9uIF9nZXRncm5hbSgpe01vZHVsZVtcInByaW50RXJyXCJdKFwibWlzc2luZyBmdW5jdGlvbjogZ2V0Z3JuYW1cIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9nZXRwd25hbSgpe3Rocm93XCJnZXRwd25hbTogVE9ET1wifWZ1bmN0aW9uIF9qc0Nsb3NlKCl7cmV0dXJuIGpzQVBJLmNsb3NlLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBfanNDcmVhdGUoZmlsZW5hbWUpe3JldHVybiBqc0FQSS5jcmVhdGUuY2FsbChudWxsLFVURjMyVG9TdHJpbmcoZmlsZW5hbWUpKX1mdW5jdGlvbiBfanNPcGVuKGZpbGVuYW1lKXtyZXR1cm4ganNBUEkub3Blbi5jYWxsKG51bGwsVVRGMzJUb1N0cmluZyhmaWxlbmFtZSkpfWZ1bmN0aW9uIF9qc1JlYWQoKXtyZXR1cm4ganNBUEkucmVhZC5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gX2pzU2VlayhmZCxvZmZzZXQsbWV0aG9kKXtyZXR1cm4ganNBUEkuc2Vlay5jYWxsKG51bGwsZmQsb2Zmc2V0LFVURjhUb1N0cmluZyhtZXRob2QpKX1mdW5jdGlvbiBfanNUZWxsKCl7cmV0dXJuIGpzQVBJLnRlbGwuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIF9qc1dyaXRlKCl7cmV0dXJuIGpzQVBJLndyaXRlLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBfbGx2bV9laF90eXBlaWRfZm9yKHR5cGUpe3JldHVybiB0eXBlfXZhciBfX190bV9jdXJyZW50PVNUQVRJQ1RPUDtTVEFUSUNUT1ArPTQ4O3ZhciBfX190bV90aW1lem9uZT1hbGxvY2F0ZShpbnRBcnJheUZyb21TdHJpbmcoXCJHTVRcIiksXCJpOFwiLEFMTE9DX1NUQVRJQyk7dmFyIF90em5hbWU9U1RBVElDVE9QO1NUQVRJQ1RPUCs9MTY7dmFyIF9kYXlsaWdodD1TVEFUSUNUT1A7U1RBVElDVE9QKz0xNjt2YXIgX3RpbWV6b25lPVNUQVRJQ1RPUDtTVEFUSUNUT1ArPTE2O2Z1bmN0aW9uIF90enNldCgpe2lmKF90enNldC5jYWxsZWQpcmV0dXJuO190enNldC5jYWxsZWQ9dHJ1ZTtIRUFQMzJbX3RpbWV6b25lPj4yXT0obmV3IERhdGUpLmdldFRpbWV6b25lT2Zmc2V0KCkqNjA7dmFyIHdpbnRlcj1uZXcgRGF0ZSgyZTMsMCwxKTt2YXIgc3VtbWVyPW5ldyBEYXRlKDJlMyw2LDEpO0hFQVAzMltfZGF5bGlnaHQ+PjJdPU51bWJlcih3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKSE9c3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCkpO2Z1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpe3ZhciBtYXRjaD1kYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7cmV0dXJuIG1hdGNoP21hdGNoWzFdOlwiR01UXCJ9dmFyIHdpbnRlck5hbWU9ZXh0cmFjdFpvbmUod2ludGVyKTt2YXIgc3VtbWVyTmFtZT1leHRyYWN0Wm9uZShzdW1tZXIpO3ZhciB3aW50ZXJOYW1lUHRyPWFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZyh3aW50ZXJOYW1lKSxcImk4XCIsQUxMT0NfTk9STUFMKTt2YXIgc3VtbWVyTmFtZVB0cj1hbGxvY2F0ZShpbnRBcnJheUZyb21TdHJpbmcoc3VtbWVyTmFtZSksXCJpOFwiLEFMTE9DX05PUk1BTCk7aWYoc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk8d2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCkpe0hFQVAzMltfdHpuYW1lPj4yXT13aW50ZXJOYW1lUHRyO0hFQVAzMltfdHpuYW1lKzQ+PjJdPXN1bW1lck5hbWVQdHJ9ZWxzZXtIRUFQMzJbX3R6bmFtZT4+Ml09c3VtbWVyTmFtZVB0cjtIRUFQMzJbX3R6bmFtZSs0Pj4yXT13aW50ZXJOYW1lUHRyfX1mdW5jdGlvbiBfbG9jYWx0aW1lX3IodGltZSx0bVB0cil7X3R6c2V0KCk7dmFyIGRhdGU9bmV3IERhdGUoSEVBUDMyW3RpbWU+PjJdKjFlMyk7SEVBUDMyW3RtUHRyPj4yXT1kYXRlLmdldFNlY29uZHMoKTtIRUFQMzJbdG1QdHIrND4+Ml09ZGF0ZS5nZXRNaW51dGVzKCk7SEVBUDMyW3RtUHRyKzg+PjJdPWRhdGUuZ2V0SG91cnMoKTtIRUFQMzJbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0RGF0ZSgpO0hFQVAzMlt0bVB0cisxNj4+Ml09ZGF0ZS5nZXRNb250aCgpO0hFQVAzMlt0bVB0cisyMD4+Ml09ZGF0ZS5nZXRGdWxsWWVhcigpLTE5MDA7SEVBUDMyW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQuZ2V0VGltZSgpKS8oMWUzKjYwKjYwKjI0KXwwO0hFQVAzMlt0bVB0cisyOD4+Ml09eWRheTtIRUFQMzJbdG1QdHIrMzY+PjJdPS0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKjYwKTt2YXIgc3VtbWVyT2Zmc2V0PShuZXcgRGF0ZSgyZTMsNiwxKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgd2ludGVyT2Zmc2V0PXN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGRzdD0oc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCkpfDA7SEVBUDMyW3RtUHRyKzMyPj4yXT1kc3Q7dmFyIHpvbmVQdHI9SEVBUDMyW190em5hbWUrKGRzdD80OjApPj4yXTtIRUFQMzJbdG1QdHIrNDA+PjJdPXpvbmVQdHI7cmV0dXJuIHRtUHRyfWZ1bmN0aW9uIF9sb2NhbHRpbWUodGltZSl7cmV0dXJuIF9sb2NhbHRpbWVfcih0aW1lLF9fX3RtX2N1cnJlbnQpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCxzcmMsbnVtKXtIRUFQVTguc2V0KEhFQVBVOC5zdWJhcnJheShzcmMsc3JjK251bSksZGVzdCk7cmV0dXJuIGRlc3R9ZnVuY3Rpb24gX21rdGltZSh0bVB0cil7X3R6c2V0KCk7dmFyIGRhdGU9bmV3IERhdGUoSEVBUDMyW3RtUHRyKzIwPj4yXSsxOTAwLEhFQVAzMlt0bVB0cisxNj4+Ml0sSEVBUDMyW3RtUHRyKzEyPj4yXSxIRUFQMzJbdG1QdHIrOD4+Ml0sSEVBUDMyW3RtUHRyKzQ+PjJdLEhFQVAzMlt0bVB0cj4+Ml0sMCk7dmFyIGRzdD1IRUFQMzJbdG1QdHIrMzI+PjJdO3ZhciBndWVzc2VkT2Zmc2V0PWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3RhcnQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDAsMSk7dmFyIHN1bW1lck9mZnNldD0obmV3IERhdGUoMmUzLDYsMSkpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHdpbnRlck9mZnNldD1zdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBkc3RPZmZzZXQ9TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7aWYoZHN0PDApe0hFQVAzMlt0bVB0ciszMj4+Ml09TnVtYmVyKHN1bW1lck9mZnNldCE9d2ludGVyT2Zmc2V0JiZkc3RPZmZzZXQ9PWd1ZXNzZWRPZmZzZXQpfWVsc2UgaWYoZHN0PjAhPShkc3RPZmZzZXQ9PWd1ZXNzZWRPZmZzZXQpKXt2YXIgbm9uRHN0T2Zmc2V0PU1hdGgubWF4KHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO3ZhciB0cnVlT2Zmc2V0PWRzdD4wP2RzdE9mZnNldDpub25Ec3RPZmZzZXQ7ZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpKyh0cnVlT2Zmc2V0LWd1ZXNzZWRPZmZzZXQpKjZlNCl9SEVBUDMyW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7SEVBUDMyW3RtUHRyKzI4Pj4yXT15ZGF5O3JldHVybiBkYXRlLmdldFRpbWUoKS8xZTN8MH12YXIgUFRIUkVBRF9TUEVDSUZJQz17fTtmdW5jdGlvbiBfcHRocmVhZF9nZXRzcGVjaWZpYyhrZXkpe3JldHVybiBQVEhSRUFEX1NQRUNJRklDW2tleV18fDB9dmFyIFBUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVk9MTtmdW5jdGlvbiBfcHRocmVhZF9rZXlfY3JlYXRlKGtleSxkZXN0cnVjdG9yKXtpZihrZXk9PTApe3JldHVybiBFUlJOT19DT0RFUy5FSU5WQUx9SEVBUDMyW2tleT4+Ml09UFRIUkVBRF9TUEVDSUZJQ19ORVhUX0tFWTtQVEhSRUFEX1NQRUNJRklDW1BUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVldPTA7UFRIUkVBRF9TUEVDSUZJQ19ORVhUX0tFWSsrO3JldHVybiAwfWZ1bmN0aW9uIF9wdGhyZWFkX29uY2UocHRyLGZ1bmMpe2lmKCFfcHRocmVhZF9vbmNlLnNlZW4pX3B0aHJlYWRfb25jZS5zZWVuPXt9O2lmKHB0ciBpbiBfcHRocmVhZF9vbmNlLnNlZW4pcmV0dXJuO01vZHVsZVtcImR5bkNhbGxfdlwiXShmdW5jKTtfcHRocmVhZF9vbmNlLnNlZW5bcHRyXT0xfWZ1bmN0aW9uIF9wdGhyZWFkX3NldHNwZWNpZmljKGtleSx2YWx1ZSl7aWYoIShrZXkgaW4gUFRIUkVBRF9TUEVDSUZJQykpe3JldHVybiBFUlJOT19DT0RFUy5FSU5WQUx9UFRIUkVBRF9TUEVDSUZJQ1trZXldPXZhbHVlO3JldHVybiAwfWZ1bmN0aW9uIF90aW1lKHB0cil7dmFyIHJldD1EYXRlLm5vdygpLzFlM3wwO2lmKHB0cil7SEVBUDMyW3B0cj4+Ml09cmV0fXJldHVybiByZXR9RlMuc3RhdGljSW5pdCgpO19fQVRJTklUX18udW5zaGlmdCgoZnVuY3Rpb24oKXtpZighTW9kdWxlW1wibm9GU0luaXRcIl0mJiFGUy5pbml0LmluaXRpYWxpemVkKUZTLmluaXQoKX0pKTtfX0FUTUFJTl9fLnB1c2goKGZ1bmN0aW9uKCl7RlMuaWdub3JlUGVybWlzc2lvbnM9ZmFsc2V9KSk7X19BVEVYSVRfXy5wdXNoKChmdW5jdGlvbigpe0ZTLnF1aXQoKX0pKTtfX0FUSU5JVF9fLnVuc2hpZnQoKGZ1bmN0aW9uKCl7VFRZLmluaXQoKX0pKTtfX0FURVhJVF9fLnB1c2goKGZ1bmN0aW9uKCl7VFRZLnNodXRkb3duKCl9KSk7XHJcbkludGVybmFsRXJyb3I9TW9kdWxlW1wiSW50ZXJuYWxFcnJvclwiXT1leHRlbmRFcnJvcihFcnJvcixcIkludGVybmFsRXJyb3JcIik7ZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7QmluZGluZ0Vycm9yPU1vZHVsZVtcIkJpbmRpbmdFcnJvclwiXT1leHRlbmRFcnJvcihFcnJvcixcIkJpbmRpbmdFcnJvclwiKTtpbml0X0NsYXNzSGFuZGxlKCk7aW5pdF9SZWdpc3RlcmVkUG9pbnRlcigpO2luaXRfZW1iaW5kKCk7VW5ib3VuZFR5cGVFcnJvcj1Nb2R1bGVbXCJVbmJvdW5kVHlwZUVycm9yXCJdPWV4dGVuZEVycm9yKEVycm9yLFwiVW5ib3VuZFR5cGVFcnJvclwiKTtpbml0X2VtdmFsKCk7X19fYnVpbGRFbnZpcm9ubWVudChFTlYpO0RZTkFNSUNUT1BfUFRSPXN0YXRpY0FsbG9jKDQpO1NUQUNLX0JBU0U9U1RBQ0tUT1A9YWxpZ25NZW1vcnkoU1RBVElDVE9QKTtTVEFDS19NQVg9U1RBQ0tfQkFTRStUT1RBTF9TVEFDSztEWU5BTUlDX0JBU0U9YWxpZ25NZW1vcnkoU1RBQ0tfTUFYKTtIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdPURZTkFNSUNfQkFTRTtzdGF0aWNTZWFsZWQ9dHJ1ZTtmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSxkb250QWRkTnVsbCxsZW5ndGgpe3ZhciBsZW49bGVuZ3RoPjA/bGVuZ3RoOmxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO3ZhciB1OGFycmF5PW5ldyBBcnJheShsZW4pO3ZhciBudW1CeXRlc1dyaXR0ZW49c3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSx1OGFycmF5LDAsdThhcnJheS5sZW5ndGgpO2lmKGRvbnRBZGROdWxsKXU4YXJyYXkubGVuZ3RoPW51bUJ5dGVzV3JpdHRlbjtyZXR1cm4gdThhcnJheX1Nb2R1bGVbXCJ3YXNtVGFibGVTaXplXCJdPTMxNjtNb2R1bGVbXCJ3YXNtTWF4VGFibGVTaXplXCJdPTMxNjtmdW5jdGlvbiBpbnZva2VfaShpbmRleCl7dHJ5e3JldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lcIl0oaW5kZXgpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LGExKXt0cnl7cmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlcIl0oaW5kZXgsYTEpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX2lpaShpbmRleCxhMSxhMil7dHJ5e3JldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lpaVwiXShpbmRleCxhMSxhMil9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1mdW5jdGlvbiBpbnZva2VfaWlpaShpbmRleCxhMSxhMixhMyl7dHJ5e3JldHVybiBNb2R1bGVbXCJkeW5DYWxsX2lpaWlcIl0oaW5kZXgsYTEsYTIsYTMpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX2lpaWlpKGluZGV4LGExLGEyLGEzLGE0KXt0cnl7cmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX2lpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYpe3RyeXtyZXR1cm4gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWlpXCJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2KX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCImJmUhPT1cImxvbmdqbXBcIil0aHJvdyBlO01vZHVsZVtcInNldFRocmV3XCJdKDEsMCl9fWZ1bmN0aW9uIGludm9rZV9paWlpaWlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KXt0cnl7cmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpaWlpaVwiXShpbmRleCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1mdW5jdGlvbiBpbnZva2VfaWlpaWlpamlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KXt0cnl7cmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpamlpXCJdKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCImJmUhPT1cImxvbmdqbXBcIil0aHJvdyBlO01vZHVsZVtcInNldFRocmV3XCJdKDEsMCl9fWZ1bmN0aW9uIGludm9rZV9pamooaW5kZXgsYTEsYTIsYTMsYTQpe3RyeXtyZXR1cm4gTW9kdWxlW1wiZHluQ2FsbF9pampcIl0oaW5kZXgsYTEsYTIsYTMsYTQpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX2ppKGluZGV4LGExKXt0cnl7cmV0dXJuIE1vZHVsZVtcImR5bkNhbGxfamlcIl0oaW5kZXgsYTEpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3YoaW5kZXgpe3RyeXtNb2R1bGVbXCJkeW5DYWxsX3ZcIl0oaW5kZXgpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpKGluZGV4LGExKXt0cnl7TW9kdWxlW1wiZHluQ2FsbF92aVwiXShpbmRleCxhMSl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1mdW5jdGlvbiBpbnZva2VfdmlpKGluZGV4LGExLGEyKXt0cnl7TW9kdWxlW1wiZHluQ2FsbF92aWlcIl0oaW5kZXgsYTEsYTIpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsYTEsYTIsYTMpe3RyeXtNb2R1bGVbXCJkeW5DYWxsX3ZpaWlcIl0oaW5kZXgsYTEsYTIsYTMpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWlpKGluZGV4LGExLGEyLGEzLGE0KXt0cnl7TW9kdWxlW1wiZHluQ2FsbF92aWlpaVwiXShpbmRleCxhMSxhMixhMyxhNCl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1mdW5jdGlvbiBpbnZva2VfdmlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1KXt0cnl7TW9kdWxlW1wiZHluQ2FsbF92aWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQsYTUpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYpe3RyeXtNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpe3RyeXtNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIiYmZSE9PVwibG9uZ2ptcFwiKXRocm93IGU7TW9kdWxlW1wic2V0VGhyZXdcIl0oMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWlpKGluZGV4LGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5LGExMCl7dHJ5e01vZHVsZVtcImR5bkNhbGxfdmlpaWlpaWlpaWlcIl0oaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTksYTEwKX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCImJmUhPT1cImxvbmdqbXBcIil0aHJvdyBlO01vZHVsZVtcInNldFRocmV3XCJdKDEsMCl9fWZ1bmN0aW9uIGludm9rZV92aWooaW5kZXgsYTEsYTIsYTMpe3RyeXtNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXShpbmRleCxhMSxhMixhMyl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1mdW5jdGlvbiBpbnZva2VfdmlqaShpbmRleCxhMSxhMixhMyxhNCl7dHJ5e01vZHVsZVtcImR5bkNhbGxfdmlqaVwiXShpbmRleCxhMSxhMixhMyxhNCl9Y2F0Y2goZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiJiZlIT09XCJsb25nam1wXCIpdGhyb3cgZTtNb2R1bGVbXCJzZXRUaHJld1wiXSgxLDApfX1Nb2R1bGUuYXNtR2xvYmFsQXJnPXt9O01vZHVsZS5hc21MaWJyYXJ5QXJnPXtcImFib3J0XCI6YWJvcnQsXCJlbmxhcmdlTWVtb3J5XCI6ZW5sYXJnZU1lbW9yeSxcImdldFRvdGFsTWVtb3J5XCI6Z2V0VG90YWxNZW1vcnksXCJhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeVwiOmFib3J0T25DYW5ub3RHcm93TWVtb3J5LFwiaW52b2tlX2lcIjppbnZva2VfaSxcImludm9rZV9paVwiOmludm9rZV9paSxcImludm9rZV9paWlcIjppbnZva2VfaWlpLFwiaW52b2tlX2lpaWlcIjppbnZva2VfaWlpaSxcImludm9rZV9paWlpaVwiOmludm9rZV9paWlpaSxcImludm9rZV9paWlpaWlpXCI6aW52b2tlX2lpaWlpaWksXCJpbnZva2VfaWlpaWlpaWlpaVwiOmludm9rZV9paWlpaWlpaWlpLFwiaW52b2tlX2lpaWlpaWppaVwiOmludm9rZV9paWlpaWlqaWksXCJpbnZva2VfaWpqXCI6aW52b2tlX2lqaixcImludm9rZV9qaVwiOmludm9rZV9qaSxcImludm9rZV92XCI6aW52b2tlX3YsXCJpbnZva2VfdmlcIjppbnZva2VfdmksXCJpbnZva2VfdmlpXCI6aW52b2tlX3ZpaSxcImludm9rZV92aWlpXCI6aW52b2tlX3ZpaWksXCJpbnZva2VfdmlpaWlcIjppbnZva2VfdmlpaWksXCJpbnZva2VfdmlpaWlpXCI6aW52b2tlX3ZpaWlpaSxcImludm9rZV92aWlpaWlpXCI6aW52b2tlX3ZpaWlpaWksXCJpbnZva2VfdmlpaWlpaWlpaVwiOmludm9rZV92aWlpaWlpaWlpLFwiaW52b2tlX3ZpaWlpaWlpaWlpXCI6aW52b2tlX3ZpaWlpaWlpaWlpLFwiaW52b2tlX3ZpalwiOmludm9rZV92aWosXCJpbnZva2VfdmlqaVwiOmludm9rZV92aWppLFwiX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvblwiOl9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24sXCJfX19jeGFfYmVnaW5fY2F0Y2hcIjpfX19jeGFfYmVnaW5fY2F0Y2gsXCJfX19jeGFfZW5kX2NhdGNoXCI6X19fY3hhX2VuZF9jYXRjaCxcIl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzJcIjpfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8yLFwiX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfM1wiOl9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzMsXCJfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF80XCI6X19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNCxcIl9fX2N4YV9mcmVlX2V4Y2VwdGlvblwiOl9fX2N4YV9mcmVlX2V4Y2VwdGlvbixcIl9fX2N4YV90aHJvd1wiOl9fX2N4YV90aHJvdyxcIl9fX2xvY2tcIjpfX19sb2NrLFwiX19fbWFwX2ZpbGVcIjpfX19tYXBfZmlsZSxcIl9fX3Jlc3VtZUV4Y2VwdGlvblwiOl9fX3Jlc3VtZUV4Y2VwdGlvbixcIl9fX3NldEVyck5vXCI6X19fc2V0RXJyTm8sXCJfX19zeXNjYWxsMTQwXCI6X19fc3lzY2FsbDE0MCxcIl9fX3N5c2NhbGwxNDVcIjpfX19zeXNjYWxsMTQ1LFwiX19fc3lzY2FsbDE0NlwiOl9fX3N5c2NhbGwxNDYsXCJfX19zeXNjYWxsMTgzXCI6X19fc3lzY2FsbDE4MyxcIl9fX3N5c2NhbGwxOThcIjpfX19zeXNjYWxsMTk4LFwiX19fc3lzY2FsbDIwXCI6X19fc3lzY2FsbDIwLFwiX19fc3lzY2FsbDZcIjpfX19zeXNjYWxsNixcIl9fX3N5c2NhbGw2MFwiOl9fX3N5c2NhbGw2MCxcIl9fX3N5c2NhbGw4M1wiOl9fX3N5c2NhbGw4MyxcIl9fX3N5c2NhbGw5MVwiOl9fX3N5c2NhbGw5MSxcIl9fX3VubG9ja1wiOl9fX3VubG9jayxcIl9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdFwiOl9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdCxcIl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2xcIjpfX2VtYmluZF9yZWdpc3Rlcl9ib29sLFwiX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NcIjpfX2VtYmluZF9yZWdpc3Rlcl9jbGFzcyxcIl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yXCI6X19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IsXCJfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvblwiOl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uLFwiX19lbWJpbmRfcmVnaXN0ZXJfZW12YWxcIjpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxcIl9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0XCI6X19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsXCJfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyXCI6X19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcixcIl9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3XCI6X19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsXCJfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nXCI6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxcIl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nXCI6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsXCJfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RcIjpfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3QsXCJfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGRcIjpfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQsXCJfX2VtYmluZF9yZWdpc3Rlcl92b2lkXCI6X19lbWJpbmRfcmVnaXN0ZXJfdm9pZCxcIl9hYm9ydFwiOl9hYm9ydCxcIl9lbXNjcmlwdGVuX21lbWNweV9iaWdcIjpfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFwiX2dldGVudlwiOl9nZXRlbnYsXCJfZ2V0Z3JuYW1cIjpfZ2V0Z3JuYW0sXCJfZ2V0cHduYW1cIjpfZ2V0cHduYW0sXCJfanNDbG9zZVwiOl9qc0Nsb3NlLFwiX2pzQ3JlYXRlXCI6X2pzQ3JlYXRlLFwiX2pzT3BlblwiOl9qc09wZW4sXCJfanNSZWFkXCI6X2pzUmVhZCxcIl9qc1NlZWtcIjpfanNTZWVrLFwiX2pzVGVsbFwiOl9qc1RlbGwsXCJfanNXcml0ZVwiOl9qc1dyaXRlLFwiX2xsdm1fZWhfdHlwZWlkX2ZvclwiOl9sbHZtX2VoX3R5cGVpZF9mb3IsXCJfbG9jYWx0aW1lXCI6X2xvY2FsdGltZSxcIl9ta3RpbWVcIjpfbWt0aW1lLFwiX3B0aHJlYWRfZ2V0c3BlY2lmaWNcIjpfcHRocmVhZF9nZXRzcGVjaWZpYyxcIl9wdGhyZWFkX2tleV9jcmVhdGVcIjpfcHRocmVhZF9rZXlfY3JlYXRlLFwiX3B0aHJlYWRfb25jZVwiOl9wdGhyZWFkX29uY2UsXCJfcHRocmVhZF9zZXRzcGVjaWZpY1wiOl9wdGhyZWFkX3NldHNwZWNpZmljLFwiX3RpbWVcIjpfdGltZSxcIkRZTkFNSUNUT1BfUFRSXCI6RFlOQU1JQ1RPUF9QVFIsXCJTVEFDS1RPUFwiOlNUQUNLVE9QfTt2YXIgYXNtPU1vZHVsZVtcImFzbVwiXShNb2R1bGUuYXNtR2xvYmFsQXJnLE1vZHVsZS5hc21MaWJyYXJ5QXJnLGJ1ZmZlcik7TW9kdWxlW1wiYXNtXCJdPWFzbTt2YXIgX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwPU1vZHVsZVtcIl9fR0xPQkFMX19zdWJfSV9iaW5kX2NwcFwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcD1Nb2R1bGVbXCJfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcFwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX19HTE9CQUxfX3N1Yl9JX2JyaWRnZV9jcHBcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fR0xPQkFMX19zdWJfSV9jcmNfY3BwPU1vZHVsZVtcIl9fR0xPQkFMX19zdWJfSV9jcmNfY3BwXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcFwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX19HTE9CQUxfX3N1Yl9JX2dsb2JhbF9jcHA9TW9kdWxlW1wiX19HTE9CQUxfX3N1Yl9JX2dsb2JhbF9jcHBcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfX19jeGFfY2FuX2NhdGNoPU1vZHVsZVtcIl9fX2N4YV9jYW5fY2F0Y2hcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9fX2N4YV9jYW5fY2F0Y2hcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGU9TW9kdWxlW1wiX19fY3hhX2lzX3BvaW50ZXJfdHlwZVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX19fY3hhX2lzX3BvaW50ZXJfdHlwZVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfX19nZXRUeXBlTmFtZT1Nb2R1bGVbXCJfX19nZXRUeXBlTmFtZVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiX19fZ2V0VHlwZU5hbWVcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5PU1vZHVsZVtcIl9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5XCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfZW1zY3JpcHRlbl9yZXBsYWNlX21lbW9yeVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9mcmVlXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfbWFsbG9jPU1vZHVsZVtcIl9tYWxsb2NcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9tYWxsb2NcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIHNldFRlbXBSZXQwPU1vZHVsZVtcInNldFRlbXBSZXQwXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJzZXRUZW1wUmV0MFwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgc2V0VGhyZXc9TW9kdWxlW1wic2V0VGhyZXdcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInNldFRocmV3XCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBzdGFja0FsbG9jPU1vZHVsZVtcInN0YWNrQWxsb2NcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcInN0YWNrQWxsb2NcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfZGlpPU1vZHVsZVtcImR5bkNhbGxfZGlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2RpaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9pPU1vZHVsZVtcImR5bkNhbGxfaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF9pXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpPU1vZHVsZVtcImR5bkNhbGxfaWlcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWlpPU1vZHVsZVtcImR5bkNhbGxfaWlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paWlpPU1vZHVsZVtcImR5bkNhbGxfaWlpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF9paWlpXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpaWlpPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWlpaWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWlpaWlpPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpaWlpaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paWlpaWlpPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF9paWlpaWlpXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpaWlpaWlpaWk9TW9kdWxlW1wiZHluQ2FsbF9paWlpaWlpaWlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpaWlpaWlpaWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfaWlpaWlpamlpPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlpamlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX2lpaWlpaWppaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9pamo9TW9kdWxlW1wiZHluQ2FsbF9pampcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfaWpqXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2ppPU1vZHVsZVtcImR5bkNhbGxfamlcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfamlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdj1Nb2R1bGVbXCJkeW5DYWxsX3ZcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfdlwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aT1Nb2R1bGVbXCJkeW5DYWxsX3ZpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX3ZpXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpaT1Nb2R1bGVbXCJkeW5DYWxsX3ZpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF92aWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpZD1Nb2R1bGVbXCJkeW5DYWxsX3ZpaWRcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfdmlpZFwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWlpPU1vZHVsZVtcImR5bkNhbGxfdmlpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF92aWlpXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpaWlpPU1vZHVsZVtcImR5bkNhbGxfdmlpaWlcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfdmlpaWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpaWlpPU1vZHVsZVtcImR5bkNhbGxfdmlpaWlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX3ZpaWlpaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWlpaWlpPU1vZHVsZVtcImR5bkNhbGxfdmlpaWlpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF92aWlpaWlpXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3ZpaWlpaWlpaWk9TW9kdWxlW1wiZHluQ2FsbF92aWlpaWlpaWlpXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX3ZpaWlpaWlpaWlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpaWlpaWlpaWk9TW9kdWxlW1wiZHluQ2FsbF92aWlpaWlpaWlpaVwiXT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlW1wiYXNtXCJdW1wiZHluQ2FsbF92aWlpaWlpaWlpaVwiXS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF92aWo9TW9kdWxlW1wiZHluQ2FsbF92aWpcIl09KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcImR5bkNhbGxfdmlqXCJdLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX3Zpamk9TW9kdWxlW1wiZHluQ2FsbF92aWppXCJdPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGVbXCJhc21cIl1bXCJkeW5DYWxsX3ZpamlcIl0uYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7TW9kdWxlW1wiYXNtXCJdPWFzbTtmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiO3RoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrc3RhdHVzK1wiKVwiO3RoaXMuc3RhdHVzPXN0YXR1c31FeGl0U3RhdHVzLnByb3RvdHlwZT1uZXcgRXJyb3I7RXhpdFN0YXR1cy5wcm90b3R5cGUuY29uc3RydWN0b3I9RXhpdFN0YXR1czt2YXIgaW5pdGlhbFN0YWNrVG9wO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighTW9kdWxlW1wiY2FsbGVkUnVuXCJdKXJ1bigpO2lmKCFNb2R1bGVbXCJjYWxsZWRSdW5cIl0pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcn07ZnVuY3Rpb24gcnVuKGFyZ3Mpe2FyZ3M9YXJnc3x8TW9kdWxlW1wiYXJndW1lbnRzXCJdO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApcmV0dXJuO2lmKE1vZHVsZVtcImNhbGxlZFJ1blwiXSlyZXR1cm47ZnVuY3Rpb24gZG9SdW4oKXtpZihNb2R1bGVbXCJjYWxsZWRSdW5cIl0pcmV0dXJuO01vZHVsZVtcImNhbGxlZFJ1blwiXT10cnVlO2lmKEFCT1JUKXJldHVybjtlbnN1cmVJbml0UnVudGltZSgpO3ByZU1haW4oKTtpZihNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSlNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSgpO3Bvc3RSdW4oKX1pZihNb2R1bGVbXCJzZXRTdGF0dXNcIl0pe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlJ1bm5pbmcuLi5cIik7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKX0pLDEpO2RvUnVuKCl9KSwxKX1lbHNle2RvUnVuKCl9fU1vZHVsZVtcInJ1blwiXT1ydW47ZnVuY3Rpb24gZXhpdChzdGF0dXMsaW1wbGljaXQpe2lmKGltcGxpY2l0JiZNb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdJiZzdGF0dXM9PT0wKXtyZXR1cm59aWYoTW9kdWxlW1wibm9FeGl0UnVudGltZVwiXSl7fWVsc2V7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPXN0YXR1cztTVEFDS1RPUD1pbml0aWFsU3RhY2tUb3A7ZXhpdFJ1bnRpbWUoKTtpZihNb2R1bGVbXCJvbkV4aXRcIl0pTW9kdWxlW1wib25FeGl0XCJdKHN0YXR1cyl9aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7cHJvY2Vzc1tcImV4aXRcIl0oc3RhdHVzKX1Nb2R1bGVbXCJxdWl0XCJdKHN0YXR1cyxuZXcgRXhpdFN0YXR1cyhzdGF0dXMpKX1Nb2R1bGVbXCJleGl0XCJdPWV4aXQ7ZnVuY3Rpb24gYWJvcnQod2hhdCl7aWYoTW9kdWxlW1wib25BYm9ydFwiXSl7TW9kdWxlW1wib25BYm9ydFwiXSh3aGF0KX1pZih3aGF0IT09dW5kZWZpbmVkKXtNb2R1bGUucHJpbnQod2hhdCk7TW9kdWxlLnByaW50RXJyKHdoYXQpO3doYXQ9SlNPTi5zdHJpbmdpZnkod2hhdCl9ZWxzZXt3aGF0PVwiXCJ9QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7dGhyb3dcImFib3J0KFwiK3doYXQrXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwifU1vZHVsZVtcImFib3J0XCJdPWFib3J0O2lmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX1Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdPXRydWU7cnVuKClcclxuXHJcbiAgcmV0dXJuIHVucGFjaztcclxufTtcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSBjb250YWluaW5nIHRoZSByYXIgZXh0cmFjdG9yIGZvciB0aGUgZ2l2ZW4gZmlsZW5hbWUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFeHRyYWN0b3IodXJsKSB7XHJcbiAgcmV0dXJuIGZldGNoKG5ldyBSZXF1ZXN0KHVybCkpXHJcbiAgICAudGhlbihyZXNwb25zZSA9PiB7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykgXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignNDA0IEVycm9yOiBGaWxlIG5vdCBmb3VuZC4nKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIC50aGVuKGJ1ZmZlciA9PiB1bnBhY2tCcmlkZ2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoYnVmZmVyKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZvcm1hdHRlZCBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gZmlsZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3QoeyByZXNvdXJjZUlkLCB1cmwgfSkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHJcbiAgICBpZiAoIXVucGFja0JyaWRnZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VucGFja0JyaWRnZSBub3QgZGV0ZWN0ZWQnKTsgfVxyXG4gICAgaWYgKCF1bnBhY2spIHsgdGhyb3cgbmV3IEVycm9yKCd1bnBhY2sgbm90IGRldGVjdGVkJyk7IH1cclxuXHJcbiAgICBnZXRFeHRyYWN0b3IodXJsKS50aGVuKGV4dHJhY3RvciA9PiB7XHJcbiAgICAgIC8vIHJldHVybiBleHRyYWN0b3IuZXh0cmFjdEFsbCgpO1xyXG4gICAgICByZXNvbHZlKGV4dHJhY3Rvci5leHRyYWN0QWxsKCkpO1xyXG4gICAgfSwgZXJyID0+IHtcclxuICAgICAgcmVqZWN0KGVycilcclxuICAgIH0pO1xyXG4gIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldHVybkRhdGEoZXZlbnQsIGRhdGEpIHtcclxuXHJcbiAgY29uc3QgW3N0YXRlLCBsaXN0XSA9IGRhdGE7XHJcbiAgaWYgKHN0YXRlLnN0YXRlID09ICdGQUlMJykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICB0eXBlOiAnRVJST1InLFxyXG4gICAgICByZWFzb246IHN0YXRlLnJlYXNvbixcclxuICAgICAgbXNnOiBzdGF0ZS5tc2csXHJcbiAgICAgIHJlc291cmNlSWQ6IGV2ZW50LmRhdGEucmVzb3VyY2VJZCxcclxuICAgICAgdXJsOiBldmVudC5kYXRhLnVybFxyXG4gICAgfTtcclxuICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzdWx0KTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICB0eXBlOiAnRklOSVNIRUQnLFxyXG4gICAgICByZXNvdXJjZUlkOiBldmVudC5kYXRhLnJlc291cmNlSWQsXHJcbiAgICAgIGVudHJpZXM6IHt9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdXHJcbiAgaWYgKGxpc3QgJiYgbGlzdC5maWxlcykge1xyXG4gICAgZm9yKGNvbnN0IGZpbGUgb2YgbGlzdC5maWxlcykge1xyXG4gICAgICByZXN1bHQuZW50cmllc1tmaWxlLmZpbGVIZWFkZXIubmFtZV0gPSBmaWxlLmV4dHJhY3RbMV07XHJcbiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChmaWxlLmV4dHJhY3RbMV0uYnVmZmVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQsIHRyYW5zZmVyYWJsZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIGZvciBtZXNzYWdlcyBzZW50IHRvIHRoZSB3b3JrZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gIGlmKGV2ZW50LmRhdGEudHlwZSA9PSAnaW5pdCcpIHtcclxuICAgIHVucGFjayA9IGluaXR1bnBhY2soZXZlbnQuZGF0YS53YXNtVXJsKTtcclxuICAgIHVucGFjay5vblJ1bnRpbWVJbml0aWFsaXplZCA9ICgpID0+IHBvc3RNZXNzYWdlKHsgdHlwZTogJ1dBU01fTE9BREVEJyB9KTtcclxuICB9XHJcbiAgZWxzZSBpZihldmVudC5kYXRhLnR5cGUgPT0gJ2ZldGNoJykge1xyXG4gIFx0ZXh0cmFjdChldmVudC5kYXRhKS50aGVuKHVucGFja2VkID0+IHtcclxuICAgICAgcmV0dXJuRGF0YShldmVudCwgdW5wYWNrZWQpXHJcbiAgICB9LCBlcnIgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgICB0eXBlOiAnRVJST1InLFxyXG4gICAgICAgICAgcmVzb3VyY2VJZDogZXZlbnQuZGF0YS5yZXNvdXJjZUlkLFxyXG4gICAgICAgICAgdXJsOiBldmVudC5kYXRhLnVybFxyXG4gICAgICB9O1xyXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3VsdCk7XHJcbiAgICB9KVxyXG4gIH1cclxuICBlbHNlIGlmKGV2ZW50LmRhdGEudHlwZSA9PSAndW5wYWNrJykge1xyXG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGV2ZW50LmRhdGE7XHJcbiAgICBcclxuICAgIGlmICghdW5wYWNrQnJpZGdlKSB7IHRocm93IG5ldyBFcnJvcigndW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCcpOyB9XHJcbiAgICBpZiAoIXVucGFjaykgeyB0aHJvdyBuZXcgRXJyb3IoJ3VucGFjayBub3QgZGV0ZWN0ZWQnKTsgfVxyXG5cclxuICAgIGNvbnN0IGV4dHJhY3RvciA9IHVucGFja0JyaWRnZS5jcmVhdGVFeHRyYWN0b3JGcm9tRGF0YShidWZmZXIpXHJcbiAgICBjb25zdCB1bnBhY2tlZCA9IGV4dHJhY3Rvci5leHRyYWN0QWxsKClcclxuICAgIHJldHVybkRhdGEoZXZlbnQsIHVucGFja2VkKVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBXQVNNIHJ1bnRpbWUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHVucGFjay5qcyBtb2R1bGUsIHNlbmQgYSBtZXNzYWdlIGluZGljYXRpbmdcclxuICogdGhhdCB0aGUgbGlicmFyeSBpcyByZWFkeS5cclxuICovXHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sR0FBRztBQUNULEVBQUUsV0FBVyxFQUFFLFFBQVE7QUFDdkIsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSxNQUFNLFdBQVcsR0FBRyxHQUFFO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUMxQixDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3pCLEVBQUUsT0FBTyxTQUFTLENBQUMsQ0FBQztBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsT0FBTyxNQUFNLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsb0NBQW9DLENBQUMsRUFBRSxDQUFDLHlCQUF5QixDQUFDLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyw0REFBNEQsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyx3REFBd0QsQ0FBQyxFQUFFLENBQUMsOENBQThDLENBQUMsRUFBRSxDQUFDLDZCQUE2QixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFjLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN2aVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLHVDQUF1QyxDQUFDLENBQUMsT0FBTSxXQUFXLEVBQUUsT0FBTyxXQUFXLEVBQUUsQ0FBQyxZQUFZLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLDRDQUE0QyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFFLE9BQU8sV0FBVyxFQUFFLENBQUMsQ0FBQyxNQUFNLFlBQVksV0FBVyxFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUMsT0FBTSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLG9GQUFvRixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLHNDQUFzQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyx5REFBeUQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsV0FBVyxFQUFFLE9BQU8sV0FBVyxFQUFFLFVBQVUsRUFBRSxPQUFPLFdBQVcsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUUsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsT0FBTyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLE9BQU8sTUFBTSxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLDJCQUEyQixDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsT0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsNkNBQTZDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsNkNBQTZDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5RUFBeUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLG9CQUFvQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLHVDQUF1QyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLDZDQUE2QyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLDJCQUEyQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUksUUFBUSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxLQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFjLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxPQUFPLFVBQVUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU0sZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQywrREFBK0QsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU8sVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxPQUFPLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxPQUFPLFlBQVksQ0FBQyxZQUFZLENBQUMsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWSxDQUFDLE9BQU8sWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLE9BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ24xeUI7QUFDQTtBQUNBLE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUM7QUFDOUM7QUFDQSxJQUFJLE1BQU0sQ0FBQztBQUNYO0FBQ0E7QUFDQSxJQUFJLFVBQVUsR0FBRyxTQUFTLGNBQWMsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsV0FBVyxHQUFHLE9BQU07QUFDdEI7QUFDQTtBQUNBLElBQUksTUFBTSxDQUFDLE9BQU8sTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxJQUFJLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxJQUFJLG1CQUFtQixDQUFDLEtBQUssQ0FBZ0MsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBMkIsS0FBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0ZBQWtGLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMscUJBQXFCLENBQUMsT0FBTyxhQUFhLEdBQUcsVUFBVSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sT0FBTyxHQUFHLFFBQVEsRUFBRSxPQUFPLE9BQU8sR0FBRyxVQUFVLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLHFCQUFxQixDQUF1RixDQUFDO0FBQ2xxRCxHQUFHLGtCQUFrQixFQUFFLHFCQUFxQixDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsU0FBUyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLFVBQVUsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFLLENBQUMsRUFBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sUUFBUSxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxPQUFPLEdBQUcsV0FBVyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxlQUFlLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsU0FBUyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxTQUFTLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxTQUFTLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsU0FBUyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQWtCLFNBQVMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLFFBQVEsS0FBSyxDQUFDLDZCQUE2QixDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTSxDQUFDLElBQUksVUFBVSxDQUFDLE9BQU8sS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFHLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBQyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUksQ0FBQyxDQUFDLEVBQUUsU0FBUSxDQUFDLE9BQU8sR0FBRyxDQUFDLFNBQVMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFNLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE9BQU8sV0FBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxLQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRSxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxLQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFDLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFTLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxLQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsT0FBTyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxTQUFTLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBQyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBQyxDQUFDLEtBQUksQ0FBQyxHQUFHLEVBQUUsRUFBQyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxZQUFZLENBQUMsT0FBTyxXQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFDLENBQUMsS0FBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxTQUFTLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxZQUFZLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU0sNEJBQTRCLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsU0FBUyxVQUFVLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLElBQUksZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFNBQVMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUcsQ0FBQyxTQUFTLHVCQUF1QixFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU0sRUFBQyxDQUFDLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQVMsdUJBQXVCLEVBQUUsQ0FBQyxLQUFLLENBQUMsaUhBQWlILENBQUMsWUFBWSxDQUFDLG9NQUFvTSxFQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksRUFBQyxDQUFDLEtBQUksQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsYUFBYSxFQUFFLENBQUMsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxZQUFZLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUMsQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssRUFBQyxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxLQUFLLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxTQUFTLE1BQU0sQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLHNEQUFzRCxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBQyxDQUFDLEtBQUksQ0FBQyxHQUFHLE9BQU8sV0FBVyxHQUFHLFFBQVEsRUFBRSxPQUFPLFdBQVcsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLFlBQVksRUFBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFNLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxTQUFTLGNBQWMsRUFBRSxDQUFDLE9BQU8sWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFLLHlEQUF5RCxDQUFDLFNBQVMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLE9BQU8sUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxFQUFFLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLENBQXlCLFNBQVMsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFH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QyxTQUFTLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxlQUFlLEVBQUUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUUsSUFBSSxhQUFhLENBQUMsb0JBQW9CLENBQUMsR0FBRyxPQUFPLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxZQUFZLEVBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxjQUFjLEVBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxhQUFhLEVBQUMsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxT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QUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBRyxVQUFVLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsR0FBRyxPQUFPLFdBQVcsR0FBRyxRQUFRLEVBQUUsT0FBTyxXQUFXLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsY0FBYyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxVQUFVLEVBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEdBQWtCLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyw0S0FBNEssQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLEVBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLDBCQUEwQixHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLHVCQUF1QixHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLDBCQUEwQixHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLHdCQUF3QixHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBNkYsSUFBSSxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxPQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFnRCxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLFNBQVMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLGdCQUFnQixFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsNEJBQTRCLEVBQUUsQ0FBQyxPQUFPLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyw0QkFBNEIsRUFBRSxDQUFDLE9BQU8sMEJBQTBCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLDRCQUE0QixFQUFFLENBQUMsT0FBTywwQkFBMEIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxTQUFTLDBCQUEwQixFQUFFLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsTUFBTSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsU0FBUyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUErSixNQUFNLEdBQUcsQ0FBQyxTQUFTLE9BQU8sRUFBRSxFQUFFLElBQUksV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENB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QyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBRyxDQUFDLE9BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFNLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLE9BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE9BQU8sSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFNLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU0sRUFBRSxDQUFDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFNBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksRUFBRSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sU0FBUyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFFLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLG1CQUFtQixDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBQyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLENBQUMsS0FBSyxHQUFHLE9BQU8sTUFBTSxFQUFFLFdBQVcsRUFBRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxPQUFPLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFFLENBQUMsS0FBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUUsQ0FBQyxLQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLHlCQUF5QixFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxTQUFTLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxFQUFFLFdBQVcsQ0FBQyxPQUFPLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxZQUFZLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLFNBQVMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxVQUFVLENBQUMsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBUyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFNLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVEsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFDLENBQUMsS0FBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsU0FBUSxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFTLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUUsUUFBUSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVSxDQUFDLEtBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFDLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxPQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxHQUFHLE9BQU8sU0FBUyxHQUFHLFdBQVcsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBQyxDQUFDLEdBQUUsQ0FBQyxHQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sUUFBUSxDQUFDLGdDQUFnQyxDQUFDLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFDLENBQUMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEdBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxTQUFTLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFNBQVMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsU0FBUyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsR0FBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUUsQ0FBQyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLFNBQVMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsS0FBSSxDQUFDLE9BQU8sUUFBUSxDQUFDLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLFNBQVMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFDLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsU0FBUyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsR0FBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsU0FBUyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEdBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLFNBQVMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsR0FBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLEdBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUUsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFDLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxXQUFXLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsU0FBUyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsS0FBSSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBQyxDQUFDLE9BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLFNBQVEsQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxjQUFjLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLENBQUMsRUFBRSxDQUFDLFNBQVMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxHQUFFLENBQUMsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFRLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUMsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxTQUFRLENBQUMsS0FBSyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLENBQUMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxPQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUksQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVMsQ0FBQyxLQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLE9BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsU0FBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxVQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyx1QkFBdUIsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUcsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLE9BQU8sV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFNBQVMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLE9BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLFNBQVMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBSyxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyx5RUFBeUUsRUFBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFDLENBQUMsR0FBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxVQUFVLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHVDQUF1QyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHFDQUFxQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMseUNBQXlDLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1Q0FBdUMsQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUNBQXVDLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxLQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFLLENBQUMsS0FBSSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsTUFBSyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMscUNBQXFDLENBQUMsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLE1BQU0sQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFNBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUSxDQUFDLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxRQUFRLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVEsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBQyxDQUFDLE9BQU8sWUFBWSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFDLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUMsQ0FBQyxLQUFJLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxHQUFHLE9BQU8sTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsS0FBSyxHQUFHLG1CQUFtQixDQUFDLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsS0FBSSxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFDLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxlQUFlLEVBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUUsVUFBVSxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBQyxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUMsS0FBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUMsQ0FBQyxLQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLDRCQUE0QixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUcsSUFBSSxXQUFXLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyw0QkFBMkIsQ0FBQyxHQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLHdCQUF3QixFQUFFLENBQUMsRUFBRSxDQUFDLG9CQUFvQixFQUFFLENBQUMsRUFBRSxDQUFDLHdCQUF3QixFQUFFLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFNBQVMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyw4S0FBOEssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMscUJBQXFCLEdBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFNBQVMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLFNBQVMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsUUFBTyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxPQUFPLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxTQUFTLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksRUFBRSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sU0FBUyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFFLENBQUMsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxTQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sY0FBYyxHQUFHLFdBQVcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsa01BQWtNLENBQUMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQUssQ0FBQyxDQUFDLEtBQUksQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsU0FBUyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUUsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsU0FBUyw0QkFBNEIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU0sQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsMEJBQTBCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsR0FBRyxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLFVBQVUsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE9BQU8sVUFBVSxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxvQ0FBb0MsRUFBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUksQ0FBQyxPQUFPLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLFNBQVMsUUFBUSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUMsQ0FBQyxHQUFHLE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2RUFBNkUsRUFBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSSxDQUFDLENBQUMsR0FBRyxPQUFPLGNBQWMsR0FBRyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsTUFBSyxxSEFBcUgsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUUsQ0FBQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFDLENBQUMsS0FBSSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsU0FBUSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBRyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxpQkFBaUIsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLGVBQWUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLFNBQVMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFnRCxTQUFTLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLG1CQUFtQixDQUFJLEVBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUksRUFBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBQyxDQUFDLGdCQUFnQixDQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLFNBQVMsU0FBUyxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFDLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxPQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxTQUFTLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMsU0FBUywyQkFBMkIsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxTQUFTLHFCQUFxQixFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssT0FBTyxHQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsU0FBUyxvQkFBb0IsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFNBQVMsa0JBQWtCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRSxFQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsUUFBTyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxRQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxTQUFTLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsU0FBUyxxQkFBcUIsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsVUFBVSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssT0FBTyxHQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLElBQUksQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxTQUFTLG9CQUFvQixFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFNBQVMsa0JBQWtCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRSxFQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsUUFBTyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxRQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFFLENBQUMsS0FBSSxDQUFDLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsTUFBTSxRQUFRLE9BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxTQUFTLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxTQUFTLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLFVBQVUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLFNBQVMsU0FBUyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sRUFBRSxHQUFHLFdBQVcsRUFBRSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksZ0JBQWdCLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsWUFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsV0FBVyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sRUFBRSxHQUFHLFdBQVcsRUFBRSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxZQUFZLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLFlBQVksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsWUFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLFNBQVMsRUFBRSxFQUFFLElBQUksbUJBQW1CLENBQUMsRUFBRSxDQUFDLFNBQVMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFD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TSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsU0FBUyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLFNBQVMsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLElBQUksU0FBUyxJQUFJLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxn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QUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixFQUFFLFNBQVMsT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFNLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTSxDQUFDLEtBQUksQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLDZCQUE2QixDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEVBQUMsQ0FBQyxTQUFTLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLFlBQVksV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxHQUFHLEVBQUUsS0FBSyxZQUFZLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVMsQ0FBQyxNQUFNLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLFVBQVMsQ0FBQyxPQUFPLFNBQVMsR0FBRyxVQUFVLEVBQUUsSUFBSSxHQUFHLEtBQUssQ0FBQyxTQUFTLDBCQUEwQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxTQUFTLDJCQUEyQixDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLDJCQUEyQixFQUFDLENBQUMsU0FBUyxpQkFBaUIsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLDJCQUEyQixDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsS0FBSSxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQyxTQUFTLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUMsQ0FBQyxLQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLFNBQVMsa0JBQWtCLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLHVDQUF1QyxFQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLHVCQUF1QixDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQVMsQ0FBQyxDQUFDLFNBQVMscUJBQXFCLEVBQUUsQ0FBQyxPQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksYUFBYSxDQUFDLEVBQUUsQ0FBQyxTQUFTLG1CQUFtQixFQUFFLENBQUMsTUFBTSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUUsQ0FBQyxDQUFDLFNBQVMsdUJBQXVCLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLHVDQUF1QyxFQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsRUFBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLGdCQUFnQixFQUFFLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLHdCQUF1QixDQUFDLFNBQVMsV0FBVyxFQUFFLEVBQUUsSUFBSSxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsU0FBUyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxnREFBZ0QsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFRLENBQUMsQ0FBQyxTQUFTLGtCQUFrQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsWUFBWSxFQUFFLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxFQUFFLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsK0JBQStCLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsc0ZBQXNGLENBQUMsWUFBWSxDQUFDLElBQUksRUFBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBSyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsU0FBUyxHQUFHLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsYUFBWSxDQUFDLENBQUMsQ0FBQyxTQUFTLGVBQWUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUUsQ0FBQyxTQUFTLGFBQWEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsaUJBQWlCLENBQUMsK0JBQStCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFTLENBQUMsT0FBTyxHQUFHLENBQUMsU0FBUyxtQ0FBbUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLGtEQUFrRCxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsU0FBUyx3QkFBd0IsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLGtEQUFrRCxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxrQ0FBa0MsRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxpREFBaUQsRUFBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVEsQ0FBQyxLQUFJLENBQUMsaUJBQWlCLENBQUMsa0NBQWtDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUSxDQUFDLEtBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLE1BQU0sUUFBUSxpQkFBaUIsQ0FBQyw2QkFBNkIsRUFBQyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsU0FBUyxzQ0FBc0MsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFD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QUksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxNQUFLLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxhQUFZLENBQUMsQ0FBQyxTQUFTLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLGdDQUFnQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsT0FBTSxDQUFDLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUMsV0FBVyxFQUFDLENBQUMsS0FBSyxHQUFHLE9BQU8sY0FBYyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFDLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxvQ0FBb0MsQ0FBQyxTQUFTLEVBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFDLENBQUMsR0FBRyxPQUFPLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQywwQ0FBMEMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksZ0JBQWdCLENBQUMsU0FBUyxDQUFDLFNBQVMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsU0FBUyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLElBQUksZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsc0JBQXNCLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFDLHNCQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUMsQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsRUFBRSxVQUFVLENBQUMscUJBQXFCLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsZ0JBQWdCLENBQUMsRUFBQyxDQUFDLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsRUFBRSxFQUFFLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxrQkFBaUIsQ0FBQyxLQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxVQUFTLENBQUMsSUFBSSxXQUFXLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLEVBQUUsVUFBVSxDQUFDLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsSUFBSSxlQUFlLENBQUMsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLHFCQUFxQixDQUFDLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxTQUFTLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLFNBQVMsbUNBQW1DLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsNkJBQTZCLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsU0FBUyxTQUFTLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLEdBQUUsQ0FBQyxHQUFHLFNBQVMsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsNkVBQTZFLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLHFHQUFxRyxDQUFDLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxrQkFBa0IsRUFBRSxDQUFDLHFCQUFxQixDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsV0FBVyxFQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLFNBQVMsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxnQkFBZ0IsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTSxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU0sRUFBRSxDQUFDLEdBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLFdBQVcsWUFBWSxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsb0NBQW9DLENBQUMsT0FBTyxXQUFXLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLHFCQUFxQixFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsZ0ZBQWdGLEVBQUMsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFPLENBQUMsSUFBSSxhQUFhLENBQUMsa0JBQWtCLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsMkJBQTJCLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQyxTQUFTLENBQUMsNERBQTRELEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxDQUFDLGFBQWEsRUFBRSwwQkFBeUIsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLGFBQWEsRUFBRSx3Q0FBd0MsQ0FBQyxTQUFTLENBQUMsYUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFhLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsQ0FBQyxhQUFhLEVBQUUsaUNBQWdDLENBQUMsS0FBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLEVBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxhQUFhLEVBQUUsdUNBQXVDLENBQUMsZ0JBQWUsQ0FBTyxhQUFhLEVBQUUsS0FBSyxDQUFDLEtBQUss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RUFBRSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDLFNBQVMsbUJBQW1CLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxNQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxTQUFTLGVBQWUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLE9BQU8sa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLFVBQVUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLGdCQUFlLENBQUMsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUssRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUUsS0FBSyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBRSxLQUFLLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFFLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FB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RUFBRSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxTQUFTLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsc0JBQXNCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLDRCQUE0QixDQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsU0FBUyw0QkFBNEIsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFNBQVMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxZQUFZLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUMsQ0FBQyxTQUFTLFlBQVksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEdBQUcsS0FBSyxZQUFZLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxhQUFZLENBQUMsS0FBSyxHQUFHLEtBQUssWUFBWSxpQkFBaUIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxhQUFZLENBQUMsS0FBSyxHQUFHLEtBQUssWUFBWSxTQUFTLENBQUMsQ0FBQyxVQUFVLENBQUMsYUFBWSxDQUFDLEtBQUssR0FBRyxPQUFPLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQyxVQUFVLENBQUMsaUJBQWdCLENBQUMsS0FBSSxDQUFDLGlCQUFpQixDQUFDLHVDQUF1QyxFQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENB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QUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxTQUFTLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLEVBQUUsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU0sQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLFNBQVMsU0FBUyxFQUFFLENBQUMsTUFBSyxnQkFBZ0IsQ0FBQyxTQUFTLFFBQVEsRUFBRSxDQUFDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsT0FBTyxFQUFFLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxPQUFPLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQVMsT0FBTyxFQUFFLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxRQUFRLEVBQUUsQ0FBQyxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLENBQUMsU0FBUyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWEsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYSxDQUFDLENBQUMsU0FBUyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sS0FBSyxDQUFDLFNBQVMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxTQUFTLHNCQUFzQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsU0FBUyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxTQUFTLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUkseUJBQXlCLENBQUMsQ0FBQyxDQUFDLFNBQVMs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QyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFFBQVEsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQyxDQUFDLE1B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Q0FBQyxDQUFDLElBQUksMEJBQTBCLENBQUMsTUFBTSxDQUFDLDRCQUE0QixDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLDRCQUE0QixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksa0JBQWtCLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsVUFBVSxDQUFDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsK0JBQStCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFTLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBZ0MsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQU8sU0FBUyxLQUFLLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxpQkFBaUIsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLEVBQUUsQ0FBQyxPQUFPLEdBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxLQUFJLENBQUMsS0FBSyxHQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLFFBQVEsRUFBRSxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFFLEtBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFtQixRQUFRLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEVBQUMsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLEdBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFjLE1BQUssUUFBUSxDQUFDLElBQUksQ0FBQyw4Q0FBOEMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxNQUFNLENBQUMsU0FBUyxD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', false);
/* eslint-enable */

/* eslint-disable require-jsdoc */
// For synchronous loading, uncomment these lines.
// import {
//     ResourceLoaderWorker_onmessage
// } from './ResourceLoaderWorker.js';

/**
 * Class for delegating resource loading, enabling an abstraction of a cloud file system to be implemented.
 *
 * **Events**
 * * **loaded:** emitted when a file has finished loading
 * * **progressIncremented:** emitted when a loading of processing task has been incremented
 * * **allResourcesLoaded:** emitted when all outstanding resources are loaded. This event can be used to signal the completion of load.
 */
class ResourceLoader extends EventEmitter {
  /**
   * Create a resource loader.
   */
  constructor() {
    super();
    this.__adapter = undefined;
    this.__totalWork = 0;
    this.__doneWork = 0;
    this.__callbacks = {};

    this.__workers = [];
    this.__nextWorker = 0;

    let baseUrl;
    if (globalThis.navigator) {
      const scripts = document.getElementsByTagName('script');
      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];
        if (script.src.includes('zea-engine')) {
          const parts = script.src.split('/');
          parts.pop();
          parts.pop();
          baseUrl = parts.join('/');
          break
        }
      }
      if (!baseUrl) {
        baseUrl = 'https://unpkg.com/@zeainc/zea-engine@0.1.3';
      }
      this.wasmUrl = baseUrl + '/public-resources/unpack.wasm';
    }

    if (!baseUrl) {
      baseUrl = 'https://unpkg.com/@zeainc/zea-engine@0.1.3';
    }
    this.wasmUrl = baseUrl + '/public-resources/unpack.wasm';

    // Common resources are used by systems such at the renderer and VR controllers.
    // Any asset that will probably be used my multiple different independent objects
    // should be loaded here. (For now, it is being used to load VR Controller assets.)
    this.__commonResources = {};
  }

  /**
   * The setAdapter method.
   * @param {object} adapter - The adapter object.
   */
  setAdapter(adapter) {
    this.__adapter = adapter;
  }

  /**
   * The getAdapter method.
   * @return {object} - The adapter object.
   */
  getAdapter() {
    return this.__adapter
  }

  // /////////////////////////////////////////////////
  // Workers

  /**
   * The __getWorker method.
   * @return {any} - The return value.
   * @private
   */
  __getWorker() {
    const __constructWorker = () => {
      return new Promise((resolve) => {
        const worker = new WorkerFactory();
        // const worker = new Worker(this.__resourceLoaderFile.url);

        worker.postMessage({
          type: 'init',
          wasmUrl: this.wasmUrl,
        });
        worker.onmessage = (event) => {
          if (event.data.type === 'WASM_LOADED') {
            resolve(worker);
          } else if (event.data.type === 'FINISHED') {
            const data = event.data;

            // const text = [
            //   '==================== ResourceLoaderWorker.js ====================',
            //   `Filename: ${data.resourceId}`,
            //   '------------------------------------------------------',
            // ];
            // for(const file in data.entries) {
            //   text.push(`${file}:${data.entries[file].byteLength}`);
            // }
            // console.log(text.join('\n'))

            this.addWorkDone(event.data.resourceId, 1); // loading done...
            this.__onFinishedReceiveFileData(event.data);
          } else if (event.data.type === 'ERROR') {
            const data = event.data;
            console.error('Unable to load Resource:', data.resourceId, ' With url:', data.url);
          }
        };
      })
    };

    this.__nextWorker = (this.__nextWorker + 1) % 3;
    if (this.__workers[this.__nextWorker] == undefined) this.__workers[this.__nextWorker] = __constructWorker();
    return this.__workers[this.__nextWorker]
  }

  /**
   * The __terminateWorkers value.
   * @private
   */
  __terminateWorkers() {
    for (const worker of this.__workers) worker.terminate();
    this.__workers = [];
  }

  // /////////////////////////////////////////////////
  // URLS

  /**
   * Given some value, which could be an IR or a path, return the unique identifier.
   * @param {string} value - The file value.
   * @return {string} - The resolved fileId if an adapter is installed, else the original value.
   */
  resolveFileId(value) {
    if (this.__adapter) return this.__adapter.resolveFileId(value)
    return value
  }

  /**
   * The resolveFilename method.
   * @deprecated
   * @param {string} value - The file value.
   * @return {string} - The resolved URL if an adapter is installed, else the original value.
   */
  resolveFilename(value) {
    if (this.__adapter) return this.__adapter.resolveFilename(value)
    const filename = value.split(value.lastIndexOf('/'))[1];
    return filename
  }

  /**
   * The resolveURL method.
   * @deprecated
   * @param {string} value - The file value.
   * @return {string} - The resolved URL if an adapter is installed, else the original value.
   */
  resolveURL(value) {
    if (this.__adapter) return this.__adapter.resolveURL(value)
    return value
  }

  /**
   * The loadURL method.
   * @param {string} resourceId - The resourceId value.
   * @param {string} url - The url value.
   * @param {function} callback - The callback value.
   * @param {boolean} addLoadWork - The addLoadWork value.
   * @return {any} - The return value.
   * @deprecated
   * @private
   */
  loadURL(resourceId, url, callback, addLoadWork = true) {
    console.warn('Please call loadUrl instead,');
    return this.loadUrl(resourceId, url, callback, addLoadWork)
  }

  /**
   * The loadUrl method.
   * @param {string} resourceId - The resourceId value.
   * @param {string} url - The url value.
   * @param {function} callback - The callback value.
   * @param {boolean} addLoadWork - The addLoadWork value.
   */
  loadUrl(resourceId, url, callback, addLoadWork = true) {
    if (addLoadWork) {
      this.addWork(resourceId, 3); // Add work in 2 chunks. Loading, unpacking, parsing.
    }

    if (!(resourceId in this.__callbacks)) this.__callbacks[resourceId] = [];
    this.__callbacks[resourceId].push(callback);

    function checkStatus(response) {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} - ${response.statusText}`)
      }
      return response
    }
    fetch(url)
      .then((response) => checkStatus(response) && response.arrayBuffer())
      .then((buffer) => {
        this.__getWorker().then((worker) => {
          worker.postMessage({
            type: 'unpack',
            resourceId,
            buffer,
          });
        });
      });
  }

  /**
   * The __onFinishedReceiveFileData method.
   * @param {object} fileData - The fileData value.
   * @private
   */
  __onFinishedReceiveFileData(fileData) {
    const resourceId = fileData.resourceId;
    this.addWorkDone(resourceId, 1); // unpacking done...
    const callbacks = this.__callbacks[resourceId];
    if (callbacks) {
      for (const callback of callbacks) {
        callback(fileData.entries);
      }
      delete this.__callbacks[resourceId];
    }
    this.emit('loaded', { resourceId });
    this.addWorkDone(resourceId, 1); // parsing done...
  }

  /**
   * Loads and return a file resource using the specified path.
   *
   * @param {string} resourceId - The resourceId value.
   * @return {VLAAsset} - The return value.
   */
  loadCommonAssetResource(resourceId) {
    if (resourceId in this.__commonResources) {
      return this.__commonResources[resourceId]
    }
    const asset = new VLAAsset();
    asset.getParameter('DataFilePath').setValue(resourceId);
    this.__commonResources[resourceId] = asset;
    return asset
  }

  // /////////////////////////////////////////////////
  // Work

  /**
   * Add work to the total work pile.. We never know how big the pile will get.
   *
   * @param {string} resourceId - The resourceId value.
   * @param {number} amount - The amount value.
   */
  addWork(resourceId, amount) {
    this.__totalWork += amount;
    const percent = (this.__doneWork / this.__totalWork) * 100;
    this.emit('progressIncremented', { percent });
  }

  /**
   * Add work to the 'done' pile. The done pile should eventually match the total pile.
   *
   * @param {string} resourceId - The resourceId value.
   * @param {number} amount - The amount value.
   */
  addWorkDone(resourceId, amount) {
    this.__doneWork += amount;

    const percent = (this.__doneWork / this.__totalWork) * 100;
    this.emit('progressIncremented', { percent });
    if (this.__doneWork > this.__totalWork) {
      throw new Error('Mismatch between work loaded and work done.')
    }
    if (this.__doneWork == this.__totalWork) {
      this.emit('allResourcesLoaded', {});
    }
  }
}

const resourceLoader = new ResourceLoader();

/**
 * Class designed to store version data. Widely used in the zea engine for backwards compatibility.
 */
class Version {
  /**
   * Creates a version.
   * The version string should have the following structure: <br>
   * major, minor and patch separated by a dot(`.`) and parts separated by a dash(`-`).
   *
   * @param {str} versionStr - The version string value.
   */
  constructor(versionStr) {
    if (versionStr) {
      const parts = versionStr.split('-');
      const numbers = parts[0].split('.');
      this.major = parseInt(numbers[0]);
      this.minor = parseInt(numbers[1]);
      this.patch = parseInt(numbers[2]);
      if (parts.length == 2) this.branch = parts[1];
    } else {
      this.major = 0;
      this.minor = 0;
      this.patch = 0;
    }
  }

  /**
   * Compare a version object against a version numbers array.
   *
   * @param {array} numbers - An array containing 3 version numbers. [Major, Minor, Patch]
   * @return {number} - return positive: v1 > v2, zero:v1 == v2, negative: v1 < v2
   */
  compare(numbers) {
    // https://stackoverflow.com/questions/6832596/how-to-compare-software-version-number-using-js-only-number
    // 2nd answer.
    const v1 = [this.major, this.minor, this.patch];
    for (let i = 0; i < 3; i++) {
      if (v1[i] !== numbers[i]) return v1[i] - numbers[i]
    }
    return 0
  }

  /**
   * Compare a version object against a version numbers array.
   *
   * @param {array} numbers - The numbers value.
   * @return {boolean} - The return value.
   */
  equals(numbers) {
    return !(this.patch == numbers[2] && this.minor == numbers[1] && this.major == numbers[0])
  }

  /**
   * Compare a version object against a version numbers array.
   *
   * @param {array} numbers - The numbers value.
   * @return {boolean} - The return value.
   */
  lessThan(numbers) {
    return !(this.major >= numbers[0] || this.minor >= numbers[1] || this.patch >= numbers[2])
    // if (this.major >= numbers[0]) return false
    // if (this.minor >= numbers[1]) return false
    // if (this.patch >= numbers[2]) return false
    // return true
    // return (
    //   this.major < numbers[0] ||
    //   this.minor < numbers[1] ||
    //   this.patch < numbers[2]
    // )
  }

  /**
   * Compare a version object against a version numbers array.
   *
   * @param {array} numbers - The numbers value.
   * @return {boolean} - The return value.
   */
  greaterThan(numbers) {
    return this.major > numbers[0] || this.minor > numbers[1] || this.patch > numbers[2]
  }

  /**
   * Compare a version object against a version numbers array.
   *
   * @param {array} numbers - The numbers value.
   * @return {boolean} - The return value.
   */
  greaterOrEqualThan(numbers) {
    if (this.major < numbers[0]) return false
    if (this.major > numbers[0]) return true

    if (this.minor < numbers[1]) return false
    if (this.minor > numbers[1]) return true

    if (this.patch < numbers[2]) return false
    return true
    // return (
    //   this.major >= numbers[0] &&
    //   this.minor >= numbers[1] &&
    //   this.patch >= numbers[2]
    // )
  }
}

/* eslint-disable camelcase */

/**
 * Writes `TypedArray` types in binary using a specific encoding.
 */
class BinWriter {
  /**
   * Create a bin writer.
   * @param {number} dataSize - The dataSize value.
   */
  constructor(dataSize = 0) {
    this.__data = new ArrayBuffer(dataSize);
    this.__byteOffset = 0;
    this.__reserved = dataSize;
    this.__dataView = new DataView(this.__data);
  }

  /**
   * Returns the byte offset position.
   *
   * @return {number} - The return value.
   */
  pos() {
    return this.__byteOffset
  }

  /**
   * Sets byte offset value.
   *
   * @param {number} byteOffset - The byteOffset value.
   */
  seek(byteOffset) {
    this.__byteOffset = byteOffset;
  }

  /**
   * The seekEnd method.
   */
  seekEnd() {
    this.__byteOffset = this.__reserved;
  }

  /**
   * Returns written buffer data to current point.
   *
   * @return {ArrayBuffer} - Returns an array buffer.
   */
  getBuffer() {
    if (this.__data.byteLength == this.__byteOffset) {
      return this.__data
    } else {
      const unit8Array = new Uint8Array(this.__data);
      return unit8Array.slice(0, this.__byteOffset).buffer
    }
  }

  /**
   * The __grow method.
   * @private
   */
  __grow() {
    const newSize = (this.__reserved > 0 ? this.__reserved : 1) * 2;
    const data = new ArrayBuffer(newSize);
    const unit8Array = new Uint8Array(data);
    const old_unit8Array = new Uint8Array(this.__data);
    unit8Array.set(old_unit8Array);
    this.__data = data;
    this.__dataView = new DataView(this.__data);
    this.__reserved = newSize;
  }

  /**
   * The __reserve method.
   * @param {number} offset - The offset value.
   * @private
   */
  __reserve(offset) {
    if (this.__byteOffset + offset > this.__reserved) {
      this.__grow();
    }
  }

  /**
   * The __offset method.
   * @param {number} byteCount - The byteCount value.
   * @private
   */
  __offset(byteCount) {
    this.__byteOffset += byteCount;
    if (this.__byteOffset > this.__reserved) {
      this.__grow();
    }
  }

  /**
   * Writes an unsigned Int8 value in current byte offset.
   *
   * @param {number} value - The value param.
   */
  writeUInt8(value) {
    this.__reserve(1);
    this.__dataView.setUint8(this.__byteOffset, value);
    this.__offset(1);
  }

  /**
   * Writes an unsigned Int16 value in current byte offset.
   * @param {number} value - The value param.
   */
  writeUInt16(value) {
    this.__reserve(2);
    this.__dataView.setUint16(this.__byteOffset, value, true);
    this.__offset(2);
  }

  /**
   * Writes an unsigned Int32 value in current byte offset.
   * @param {number} value - The value param.
   */
  writeUInt32(value) {
    this.__reserve(4);
    this.__dataView.setUint32(this.__byteOffset, value, true);
    this.__offset(4);
  }

  /**
   * Writes a signed Int32 value in current byte offset.
   * @param {number} value - The value param.
   */
  writeSInt32(value) {
    this.__reserve(4);
    this.__dataView.setInt32(this.__byteOffset, value, true);
    this.__offset(4);
  }

  /**
   * Writes a Float16 value in current byte offset.
   *
   * @param {number} value - The value param.
   */
  writeFloat16(value) {
    const uint16 = MathFunctions.encode16BitFloat(value);
    this.writeUInt16(uint16);
  }

  /**
   * Writes a Float32 value in current byte offset.
   *
   * @param {number} value - The value param.
   */
  writeFloat32(value) {
    this.__reserve(4);
    this.__dataView.setFloat32(this.__byteOffset, value, true);
    this.__offset(4);
  }

  /**
   * Writes an unsigned Int8 array value from current byte offset.
   *
   * @param {Uint8Array} value - The value param.
   * @param {boolean} writeSize - The writeSize value.
   */
  writeUInt8Array(value, writeSize = true) {
    const count = value.size ? value.size : value.length;
    this.__reserve(count + (writeSize ? 4 : 0));
    if (writeSize) this.writeUInt32(count);
    for (let i = 0; i < count; i++) {
      this.writeUInt8(value[i]);
    }
  }

  /**
   * Writes an unsigned Int16 array value from current byte offset.
   *
   * @param {array} value - The value param.
   * @param {boolean} writeSize - The writeSize value.
   */
  writeUInt16Array(value, writeSize = true) {
    const count = value.size ? value.size : value.length;
    this.__reserve(count * 2 + (writeSize ? 4 : 0));
    if (writeSize) this.writeUInt32(count);
    for (let i = 0; i < count; i++) {
      this.writeUInt16(value[i]);
    }
  }

  /**
   * Writes an unsigned Int32 array value from current byte offset.
   *
   * @param {Uint32Array} value - The value param.
   * @param {boolean} writeSize - The writeSize value.
   */
  writeUInt32Array(value, writeSize = true) {
    const count = value.size ? value.size : value.length;
    this.__reserve(count * 4 + (writeSize ? 4 : 0));
    if (writeSize) this.writeUInt32(count);
    for (let i = 0; i < count; i++) {
      this.writeUInt32(value[i]);
    }
  }

  /**
   * Writes a Float32 array value from current byte offset.
   *
   * @param {Float32Array} value - The value param.
   * @param {boolean} writeSize - The writeSize value.
   */
  writeFloat32Array(value, writeSize = true) {
    const count = value.size ? value.size : value.length;
    this.__reserve(count * 4 + (writeSize ? 4 : 0));
    if (writeSize) this.writeUInt32(count);
    for (let i = 0; i < count; i++) {
      this.writeFloat32(value[i]);
    }
  }

  /**
   * Writes string value in current position, first writing an unsigned Int32 describing its length, then adding the string in Float32 values.
   *
   * @param {string} str - The str value.
   * @param {boolean} writeSize - The writeSize value.
   */
  writeStr(str, writeSize = true) {
    const count = str.length;
    this.__reserve(count * 4 + (writeSize ? 4 : 0));
    if (writeSize) this.writeUInt32(count);
    for (let i = 0; i < count; i++) {
      this.writeFloat32(str.charCodeAt(i));
    }
  }

  /**
   * Writes a `Vec2` in the buffer using signed Int32 values(In `x,y` order).
   * @param {Vec2} value - The Vec2 to write.
   */
  writeSInt32Vec2(value) {
    this.writeSInt32(value.x);
    this.writeSInt32(value.y);
  }

  /**
   * Writes a `Vec2` in the buffer using unsigned Int32 values(In `x,y` order).
   *
   * @param {Vec2} value - The Vec2 to write.
   */
  writeUInt32Vec2(value) {
    this.writeUInt32(value.x);
    this.writeUInt32(value.y);
  }

  /**
   * Writes a `Vec2` in the buffer using Float16 values(In `x,y` order).
   * @param {Vec2} value - The Vec2 to write.
   */
  writeFloat16Vec2(value) {
    this.writeFloat16(value.x);
    this.writeFloat16(value.y);
  }

  /**
   * Writes a `Vec2` in the buffer using Float32 values(In `x,y` order).
   *
   * @param {Vec2} value - The Vec2 to write.
   */
  writeFloat32Vec2(value) {
    this.writeFloat32(value.x);
    this.writeFloat32(value.y);
  }

  /**
   * Writes a `Vec3` in the buffer using Float16 values(In `x,y,z` order).
   *
   * @param {Vec3} value - The Vec3 to write.
   */
  writeFloat16Vec3(value) {
    this.writeFloat16(value.x);
    this.writeFloat16(value.y);
    this.writeFloat16(value.z);
  }

  /**
   * Writes a `Vec3` in the buffer using Float32 values(In `x,y,z` order).
   * @param {Vec3} value - The Vec3 to write.
   */
  writeFloat32Vec3(value) {
    this.writeFloat32(value.x);
    this.writeFloat32(value.y);
    this.writeFloat32(value.z);
  }

  /**
   * Writes a `Quat` in the buffer using Float16 values(In `x,y,z,w` order).
   *
   * @param {Quat} value - The Quat to write.
   */
  writeFloat16Quat(value) {
    this.writeFloat16(value.x);
    this.writeFloat16(value.y);
    this.writeFloat16(value.z);
    this.writeFloat16(value.w);
  }

  /**
   * Writes a `Quat` in the buffer using Float32 values(In `x,y,z,w` order).
   *
   * @param {Quat} value - The Quat to write.
   */
  writeFloat32Quat(value) {
    this.writeFloat32(value.x);
    this.writeFloat32(value.y);
    this.writeFloat32(value.z);
    this.writeFloat32(value.w);
  }

  /**
   * Writes a RGB `Color` in the buffer using Float32 values(In `r,g,b` order).
   *
   * @param {Color} value - The Color to write.
   */
  writeRGBFloat32Color(value) {
    this.writeFloat32(value.r);
    this.writeFloat32(value.g);
    this.writeFloat32(value.b);
  }

  /**
   * Writes a RGBA `Color` in the buffer using Float32 values(In `r,g,b,a` order).
   *
   * @param {Color} value - The Color to write.
   */
  writeRGBAFloat32Color(value) {
    this.writeFloat32(value.r);
    this.writeFloat32(value.g);
    this.writeFloat32(value.b);
    this.writeFloat32(value.a);
  }

  /**
   * Writes a RGB `Color` in the buffer using unsigned Int8 values(In `r,g,b` order).
   *
   * @param {Color} value - The Color to write.
   */
  writeRGBUInt8Color(value) {
    this.writeUInt8(value.r);
    this.writeUInt8(value.g);
    this.writeUInt8(value.b);
  }

  /**
   * Writes a RGBA `Color` in the buffer using unsigned Int8 values(In `r,g,b,a` order).
   *
   * @param {Color} value - The Color to write.
   */
  writeRGBAUInt8Color(value) {
    this.writeUInt8(value.r);
    this.writeUInt8(value.g);
    this.writeUInt8(value.b);
    this.writeUInt8(value.a);
  }

  /**
   * Writes a `Box2` in the buffer using Floar32 values(In `p0,p1` order).
   *
   * @param {Box2} value - The Box2 to write.
   */
  writeBox2(value) {
    this.writeFloat32Vec2(value.p0);
    this.writeFloat32Vec2(value.p1);
  }

  /**
   * Writes a `Box3` in the buffer using Floar32 values(In `p0,p1` order).
   *
   * @param {Box3} value - The Box3 to write.
   */
  writeBox3(value) {
    this.writeFloat32Vec3(value.p0);
    this.writeFloat32Vec3(value.p1);
  }

  /**
   * The writePadd method.
   * @param {number} size - The size value.
   */
  writePadd(size) {
    const bytes = size - this.__byteOffset;
    this.__reserve(bytes);
    this.__offset(bytes);
  }

  /**
   * The writeAlignment method.
   * @param {number} numBytes - The numBytes value.
   */
  writeAlignment(numBytes) {
    const bytes = this.__byteOffset % numBytes;
    if (bytes != 0) {
      this.__reserve(numBytes - bytes);
      this.__offset(numBytes - bytes);
    }
  }
}

const OperatorOutputMode = {
  OP_WRITE: 0,
  OP_READ_WRITE: 1,
};

/**
 * Represents a reactive type of attribute that can be owned by a `ParameterOwner` class.
 *
 * **Events**
 * * **nameChanged:** Triggered when the name of the parameter changes.
 * * **valueChanged:** Triggered when the value of the parameter changes.
 */
class Parameter extends EventEmitter {
  /**
   * When initializing a new parameter, the passed in value could be anything.
   * If it is a new type of value, just ensure you register it in the `Registry`.
   *
   * How to use it:
   *
   * ```javascript
   *  // Creating a parameter object
   *  const param = new Parameter('Title', 'Awesome Parameter Value', 'String')
   *
   *   // Capturing events
   *  param.on('valueChanged', (...params) => console.log('Value changed!'))
   *
   *  // Changing parameter's value will cause `valueChanged` event to trigger.
   *  param.setValue('A New Awesome Parameter Value')
   *  // As result the console log code will execute: Value Changed!
   * ```
   *
   * @param {string} name - The name of the parameter.
   * @param {object|string|number|any} value - The value of the parameter.
   * @param {string} dataType - The data type of the parameter.
   */
  constructor(name, value, dataType) {
    super(name);

    this.__name = name;
    this.__value = value;
    this.__dataType = dataType ? dataType : undefined;
    this.__boundOps = [];
    this.__dirtyOpIndex = 0;
    this.__cleaning = false;

    this.getName = this.getName.bind(this);
    this.setName = this.setName.bind(this);
    this.getValue = this.getValue.bind(this);
    this.setValue = this.setValue.bind(this);
  }

  /**
   * Copies and returns the exact clone of current parameter
   *
   * @return {Parameter} - Clone of current parameter
   */
  clone() {
    const clonedParameter = new Parameter(this.__name, this.__value, this.__dataType);
    return clonedParameter
  }

  /**
   * Returns specified name of the parameter.
   *
   * @return {string} - Returns the name.
   */
  getName() {
    return this.__name
  }

  /**
   * Sets the name of the current parameter.
   *
   * @param {string} name - The base parameter name.
   * @return {Parameter} - The instance itself.
   */
  setName(name) {
    if (name === this.__name) {
      return this
    }

    const prevName = this.__name;
    this.__name = name;
    this.emit('nameChanged', { newName: this.__name, prevName });
  }

  /**
   * Returns the owner item of the current parameter.
   *
   * @return {ParameterOwner} - The return value.
   */
  getOwner() {
    return this.ownerItem
  }

  /**
   * Sets the owner item of the current parameter.
   *
   * @param {ParameterOwner} ownerItem - The ownerItem value.
   */
  setOwner(ownerItem) {
    this.ownerItem = ownerItem;
  }

  /**
   * Returns the parameter's path as an array of strings.
   * Includes owner's path in case it is owned by a `ParameterOwner`.
   *
   * @return {array} - The return value.
   */
  getPath() {
    if (this.ownerItem && this.ownerItem.getName) {
      return [...this.ownerItem.getPath(), this.__name]
    } else {
      return [this.__name]
    }
  }

  /**
   * Returns parameter's data type.
   *
   * @return {string} - The return value.
   */
  getDataType() {
    return this.__dataType
  }

  // ////////////////////////////////////////////////
  // Operator bindings

  /**
   * Binds an OperatorOutput to this parameter.
   *
   * @param {OperatorOutput} operatorOutput - The output that we are unbinding from the Parameter
   * @param {number} index - The index(optional) that the output is being bound at.
   * @return {number} - The index of the bound output.
   */
  bindOperatorOutput(operatorOutput, index = -1) {
    if (index == -1) index = this.__boundOps.length;
    this.__boundOps.splice(index, 0, operatorOutput);
    // Update the remaining binding indices
    for (let i = index; i < this.__boundOps.length; i++) {
      this.__boundOps[i].setParamBindIndex(i);
    }
    // If we weren't already dirty, make sure to emit a 'valueChanged' anyway.
    if (!this.setDirty(index)) this.emit('valueChanged', { mode: 0 });
    return index
  }

  /**
   * The unbindOperator method.
   *
   * @param {OperatorOutput} operatorOutput - The output that we are unbinding from the Parameter
   * @return {boolean} - The return value.
   */
  unbindOperator(operatorOutput) {
    const index = operatorOutput.getParamBindIndex();
    this.__boundOps.splice(index, 1);
    // Update the remaining binding indices
    for (let i = index; i < this.__boundOps.length; i++) {
      this.__boundOps[i].setParamBindIndex(i);
    }
    this.setDirty(Math.max(0, index - 1));
    return index
  }

  /**
   * Dirties this Parameter so subsequent calls to `getValue` will cause an evaluation of its bound operators.
   *
   * @param {number} index - Index of the operator
   * @return {boolean} - `true` if the Parameter was made dirty, else `false` if it was already dirty.
   */
  setDirty(index) {
    // Determine the first operator in the stack that must evaluate to clean the parameter.
    if (index < this.__dirtyOpIndex) {
      // Walk back down the stack and dirty each of the other bound operators.
      // If we must dirty all operators in the stack from the last OP_WRITE to the end.
      for (this.__dirtyOpIndex--; this.__dirtyOpIndex > 0; this.__dirtyOpIndex--) {
        // Dirty all the other bound ops in the stack until we hit an OP_WRITE
        if (this.__dirtyOpIndex != index) {
          // This will cause the other outputs of the operator to become dirty.
          this.__boundOps[this.__dirtyOpIndex].getOperator().setDirty();
        }
        if (this.__boundOps[this.__dirtyOpIndex].getMode() == OperatorOutputMode.OP_WRITE) break
      }

      this.emit('valueChanged', { mode: 0 });
      return true
    }

    return false
  }

  /**
   * Returns true if this parameter is currently dirty and will evaluate its bound
   * operators if its value is requested by a call to getValue.
   *
   * @return {boolean} - Returns a boolean.
   */
  isDirty() {
    return this.__dirtyOpIndex < this.__boundOps.length
  }

  /**
   * Returns the index of the first 'dirty' binding in the stack. This will be the index of the
   * first operator that will evaluate when the parameter needs to be cleaned.
   *
   * @return {number} - The index of the dirty binding in the binding stack.
   */
  getDirtyBindingIndex() {
    return this.__dirtyOpIndex
  }

  /**
   * The setCleanFromOp method.
   * @param {any} value - The computed value to be stored in the Parameter.
   * @param {number} index - The index of the bound OperatorOutput.
   */
  setCleanFromOp(value, index) {
    if (index != this.__dirtyOpIndex) {
      if (index < this.__dirtyOpIndex) {
        // This can happen when an operator in the following case.

        // ParamA [OpC, OpB, OpA]
        // ParamB [OpC, OpA]
        // When OpB dirties ParamA, and is evaluated, ParamB is considered clean because OpA was never dirtied

        // We see this message when parameters are evaluated as soon as a change is detected instead of
        // in batches. Now that all rendering code is pulling data only during the render cycle, we ara
        // not seeing it anymore. However, maybe with a UI open, it will start emitting this warning.
        // Note: this would be caused, if a Parameter is already cleaned by an Operator, and yet the Operator
        // is re-evaluating. I am not sure how this can occur.
        // const op = operatorOutput.getOperator()
        // console.log(
        //   `Operator:: ${
        //     op.constructor.name
        //   } with name: ${op.getName()} is being cleaned immediately, instead of lazily.`
        // )
        console.log(`Parameter is cleaned when it was already clean to that point in the stack:`, this.getPath());
      } else if (this.__boundOps[index].getMode() != OperatorOutputMode.OP_WRITE) {
        // A parameter can become dirty (so __dirtyOpIndex == 0), and then another operator bound on top.
        // if the next op is a WRITE op, then we can fast forward the dirty index.
        const thisClassName = Registry.getBlueprintName(this);
        const opClassName = Registry.getBlueprintName(this.__boundOps[index].getOperator());
        throw new Error(
          `Parameter: ${thisClassName} with name: ${this.getName()} is not cleaning all outputs during evaluation of op: ${opClassName} with name: ${op.getName()}`
        )
      }
    }
    this.__value = value;

    // As each operator writes its value, the dirty value is incremented
    this.__dirtyOpIndex = index + 1;
  }

  /**
   * During operator evaluation, operators can use this method to retrieve the existing
   * value of one of their outputs.
   * @param {number} index - The index of the bound OperatorOutput to evaluate up to.
   * @return {object|string|number|any} - The return value.
   */
  getValueFromOp(index) {
    // Note: during evaluation of an Operator that writes to multiple outputs,
    // it can write to an output with an IO setting, which means it retrieves
    // the previous value while calculating the next.
    if (this.__dirtyOpIndex < index) {
      this._clean(index);
    }
    return this.__value
  }

  /**
   * Cleans the parameter up tp the index of the specified index of the bound OperatorOutput
   *
   * @param {number} index - The index of the bound OperatorOutput to evaluate up to.
   */
  _clean(index) {
    if (this.__cleaning) {
      throw new Error(`Cycle detected when cleaning: ${this.getPath()}. Operators need to be rebound to fix errors`)
    }
    this.__cleaning = true;

    while (this.__dirtyOpIndex < index) {
      const tmp = this.__dirtyOpIndex;
      const operatorOutput = this.__boundOps[this.__dirtyOpIndex];
      // The op can get the current value and modify it in place
      // and set the output to clean.
      operatorOutput.getOperator().evaluate();

      if (tmp == this.__dirtyOpIndex) {
        // During initial configuration of an operator, cleaning outputs might be disabled.
        const op = this.__boundOps[this.__dirtyOpIndex].getOperator();
        const opClassName = Registry.getBlueprintName(op);
        console.warn(
          `Operator: ${opClassName} with name: ${op.getName()} is not cleaning its outputs during evaluation`
        );
        this.__dirtyOpIndex++;
      }
    }

    this.__cleaning = false;
  }

  /**
   * Returns parameter's value.
   *
   * @param {number} mode - The mode value.
   * @return {object|string|number|any} - The return value.
   */
  getValue(mode) {
    if (mode != undefined) {
      console.warn("WARNING in Parameter.setValue: 'mode' is deprecated.");
    }
    if (this.__dirtyOpIndex < this.__boundOps.length) {
      this._clean(this.__boundOps.length);
    }
    return this.__value
  }

  /**
   * Sets value of the parameter.
   *
   * @param {object|string|number|any} value - The value param.
   * @param {number} mode - This is deprecated now.
   */
  setValue(value, mode) {
    if (value == undefined) {
      // eslint-disable-next-line no-throw-literal
      throw 'undefined was passed into the set value for param:' + this.getName()
    }
    if (mode != undefined) {
      console.warn("WARNING in Parameter.setValue: 'mode' is deprecated.");
    }

    if (this.__boundOps.length > 0) {
      for (let i = this.__boundOps.length - 1; i >= 0; i--) {
        const operatorOutput = this.__boundOps[i];
        value = operatorOutput.backPropagateValue(value);
        if (operatorOutput.getMode() == 0 /* OP_WRITE */) return
      }
    }

    if (!value.fromJSON) {
      // Note: equality tests on anything but simple values is going to be super expensive.
      if (this.__value == value) return
    }
    this.__value = value;

    // Note: only users call 'setValue'. Operators call 'setCleanFromOp'
    this.emit('valueChanged', {});
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The loadValue is used to change the value of a parameter, without triggering a
   * valueChanges, or setting the USER_EDITED state.
   *
   * @param {any} value - The context value.
   */
  loadValue(value) {
    this.__value = value;
  }

  /**
   * The toJSON method serializes this instance as a JSON.
   * It can be used for persistence, data transfer, etc.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    if (this.__value.toJSON) return { value: this.__value.toJSON(context) }
    else return { value: this.__value }
  }

  /**
   * The fromJSON method takes a JSON and deserializes into an instance of this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.value == undefined) {
      console.warn('Invalid Parameter JSON');
      return
    }

    if (j.value.type && this.__value == undefined) {
      this.__value = Registry.constructClass(j.value.type);
    }
    if (this.__value == undefined || !this.__value.fromJSON) {
      this.__value = j.value;
    } else {
      this.__value.fromJSON(j.value, context);
    }
    this.emit('valueChanged', { mode: 0 });
  }

  /**
   * The readBinary method.
   *
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    console.warn(`TODO: Parameter: ${this.constructor.name} with name: ${this.__name} does not implement readBinary`);
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {Parameter} - Returns a new cloned parameter.
   */
  clone() {
    const clonedValue = this.__value;
    if (clonedValue.clone) clonedValue = clonedValue.clone();
    const clonedParam = new Parameter(this.__name, clonedValue, this.__dataType);
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores numeric values.
 *
 * ```javascript
 * const numberParam = new NumberParameter('MyNumber', 15)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(numberParam)
 * ```
 *
 * @extends Parameter
 */
class NumberParameter extends Parameter {
  /**
   * Create a number parameter.
   * @param {string} name - The name of the number parameter.
   * @param {number} value - The value of the parameter.
   * @param {array} range - An array with two numbers. If defined, the parameter value will be clamped.
   * @param {number} step - The step value. If defined, the parameter value will be rounded to the nearest integer.
   */
  constructor(name, value = 0, range = undefined, step = undefined) {
    super(name, value, 'Number');
    // The value might not have a range.
    if (range && !Array.isArray(range)) console.error('Range value must be an array of 2 numbers.');
    this.__range = range;
    this.__step = step;
  }

  /**
   * Returns the range to which the parameter is restrained.
   *
   * @return {array} - The return value.
   */
  getRange() {
    return this.__range
  }

  /**
   * Sets the range to which the parameter is restrained.
   *
   * @param {array} range - The range value.
   */
  setRange(range) {
    // Should be an array [0, 20]
    this.__range = range;
  }

  /**
   * Returns the step number, which is the one used for rounding.
   *
   * @return {number} - The return value.
   */
  getStep() {
    return this.__step
  }

  /**
   * Returns step value.
   *
   * @param {number} step - The step value.
   */
  setStep(step) {
    this.__step = step;
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    if (this.__range) j.range = this.__range;
    if (this.__step) j.step = this.__step;
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);
    if (j.range) this.__range = j.range;
    if (j.step) this.__step = j.step;
  }

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value = reader.loadFloat32();
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new number parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {NumberParameter} - Returns a new number parameter.
   */
  clone() {
    const clonedParam = new NumberParameter(this.__name, this.__value);
    clonedParam.__range = this.__range;
    clonedParam.__step = this.__step;
    return clonedParam
  }
}

Registry.register('NumberParameter', NumberParameter);
Registry.register('Property_SInt32', NumberParameter);
Registry.register('Property_UInt32', NumberParameter);
Registry.register('Property_Float32', NumberParameter);

/**
 * Represents a specific type of parameter, that stores multiple choice(array) values.
 *
 * i.e.:
 * ```javascript
 * const multiChoiceParameter =  new MultiChoiceParameter('InitialXfoMode', GROUP_INITIAL_XFO_MODES.average, [
 *                                  'manual',
 *                                  'first',
 *                                  'average',
 *                                  'global',
 *                                ])
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(multiChoiceParameter)
 * ```
 * @extends NumberParameter
 */
class MultiChoiceParameter extends NumberParameter {
  /**
   * Create a multi choice parameter.
   * @param {string} name - The name of the multi choice parameter.
   * @param {number} index - The index value.
   * @param {array} choices - The choices value.
   */
  constructor(name, index, choices) {
    super(name, index, [0, choices.length], 1);
    this.choices = choices;
  }

  /**
   * Returns choices array.
   *
   * @return {array} - The return value.
   */
  getChoices() {
    return this.choices
  }

  /**
   * Sets parameter index value.
   *
   * @param {string|number} value - The value param.
   */
  setValue(value) {
    if (typeof value === 'string') {
      super.setValue(this.choices.indexOf(value));
    } else {
      super.setValue(value);
    }
  }
}

/**
 * Represents a specific type of parameter, that only stores `boolean` values.
 *
 * i.e.:
 * ```javascript
 * const booleanParam = new BooleanParameter('MyBoolean', true)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(booleanParam)
 * ```
 * @extends Parameter
 */
class BooleanParameter extends Parameter {
  /**
   * Creates a new parameter with `Boolean` data type.
   *
   * @param {string} name - The name of the boolean parameter.
   * @param {boolean} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value, 'Boolean');
  }

  /**
   * The clone method constructs a new boolean parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {BooleanParameter} - Returns a new cloned boolean parameter.
   */
  clone() {
    const clonedParam = new BooleanParameter(this.__name, this.__value);
    return clonedParam
  }
}

Registry.register('BooleanParameter', BooleanParameter);

/**
 * Represents a specific type of parameter, that only stores Vec2(two-dimensional coordinate) values.
 *
 * i.e.:
 * ```javascript
 * const vec2Param = new Vec2Parameter('MyVec2', new Vec2(1.2, 3.4))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(vec2Param)
 * ```
 *
 * **Events**
 * * **rangeChanged:** Triggered when rage array changes.
 *
 * @extends Parameter
 */
class Vec2Parameter extends Parameter {
  /**
   * Create a Vec2 parameter.
   *
   * @param {string} name - The name of the Vec2 parameter.
   * @param {Vec2} value - The value of the parameter.
   * @param {array} range - The range value is an array of two `Vec2` objects.
   */
  constructor(name, value, range = undefined) {
    super(name, value ? value : new Vec2(), 'Vec2');
    this.__range = range;
  }

  /**
   * Returns the range of values in which current parameter can be.
   *
   * @return {array} - The return value.
   */
  getRange() {
    // Range should be an array of 2 vec2s. [min(x,y), max(x,y)]
    return this.__range
  }

  /**
   * The __setRange method.
   * @param {array} range - The range value.
   * @private
   */
  __setRange(range) {
    // Should be an array [0, 20]
    this.__range = range;
    this.emit('rangeChanged', { range });
  }

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  /**
   * The clone method constructs a new Vec2 parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {Vec2Parameter} - Returns a new Vec2 parameter.
   */
  clone() {
    const clonedParam = new Vec2Parameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores Vec3(three-dimensional coordinate) values.
 *
 * i.e.:
 * ```javascript
 * const vec3Param = new Vec3Parameter('MyVec3', new Vec3(1.2, 3.4, 1))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(vec3Param)
 * ```
 * @extends Parameter
 */
class Vec3Parameter extends Parameter {
  /**
   * Create a Vec3 parameter.
   * @param {string} name - The name of the Vec3 parameter.
   * @param {Vec3} value - The value of the parameter.
   * @param {array} range - The range value is an array of two `Vec2` objects.
   */
  constructor(name, value, range = undefined) {
    super(name, value ? value : new Vec3$1(), 'Vec3');
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new Vec3 parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {Vec3Parameter} - Returns a new Vec3 parameter.
   */
  clone() {
    const clonedParam = new Vec3Parameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores Vec3(four-dimensional coordinate) values.
 *
 * i.e.:
 * ```javascript
 * const vec4Param = new Vec4Parameter('MyVec4', new Vec4(1.2, 3.4, 1, 4.2))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(vec4Param)
 * ```
 *
 * @extends Parameter
 */
class Vec4Parameter extends Parameter {
  /**
   * Create a Vec4 parameter.
   * @param {string} name - The name of the Vec4 parameter.
   * @param {Vec4} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value ? value : new Vec4$1(), 'Vec4');
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new Vec4 parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {Vec4Parameter} - Returns a new Vec4 parameter.
   */
  clone() {
    const clonedParam = new Vec4Parameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores `Color` values.
 *
 * i.e.:
 * ```javascript
 * const colorParam = new ColorParameter('MyColor', new Color(0, 254, 2))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(colorParam)
 * ```
 *
 * @extends Parameter
 */
class ColorParameter extends Parameter {
  /**
   * Create a color parameter.
   * @param {string} name - The name of the color parameter.
   * @param {Color} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value ? value : new Color(), 'Color');
  }

  /**
   * Extracts `Color` values from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    const value = reader.loadRGBAFloat32Color();
    // If the value is in linear space, then we should convert it to gamma space.
    // Note: !! this should always be done in preprocessing...
    value.applyGamma(2.2);

    this.__value = value;
  }

  /**
   * The clone method constructs a new color parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {ColorParameter} - Returns a new cloned color parameter.
   */
  clone() {
    const clonedParam = new ColorParameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

Registry.register('ColorParameter', ColorParameter);

/**
 * Represents a specific type of parameter, that only stores Mat3(3x3 matrix) values.
 *
 * i.e.:
 * ```javascript
 * const mat3Param = new Ma3Parameter('MyMat3', new Mat3(...args))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(mat3Param)
 * ```
 *
 * @extends Parameter
 */
class Mat3Parameter extends Parameter {
  /**
   * Create a Mat3 parameter.
   * @param {string} name - The name of the Mat3 parameter.
   * @param {Vec3} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value ? value : new Mat3$1(), 'Mat3');
  }

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  /**
   * The clone method constructs a new Mat3 parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {Mat3Parameter} - Returns a new cloned Mat3 parameter.
   */
  clone() {
    const clonedParam = new Mat3Parameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores Mat4(4x4 matrix) values.
 *
 * i.e.:
 * ```javascript
 * const mat4Param = new Ma3Parameter('MyMat4', new Mat4(...args))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(mat4Param)
 * ```
 *
 * @extends Parameter
 */
class Mat4Parameter extends Parameter {
  /**
   * Create a Mat4 parameter.
   *
   * @param {string} name - The name of the Mat4 parameter.
   * @param {Mat4} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value ? value : new Mat4(), 'Mat4');
  }

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  /**
   * The clone method constructs a new Mat4 parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {Mat4Parameter} - Returns a new cloned Mat4 parameter.
   */
  clone() {
    const clonedParam = new Mat4Parameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores `Xfo` transform values.
 *
 * ```javascript
 * const xfoParam = new XfoParameter('MyXfo', new Xfo(new Vec3(1.2, 3.4, 1)))
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(xfoParam)
 * ```
 *
 * @extends Parameter
 */
class XfoParameter extends Parameter {
  /**
   * Create a Xfo parameter.
   * @param {string} name - The name of the Xfo parameter.
   * @param {Xfo} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value ? value : new Xfo(), 'Xfo');
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Extracts a number value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value.readBinary(reader);
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new Xfo parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {XfoParameter} - Returns a new Xfo parameter.
   */
  clone() {
    const clonedParam = new XfoParameter(this.__name, this.__value.clone());
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores `BaseImage` values.
 *
 * i.e.:
 * ```javascript
 * // Since `Label` is a `BaseImage` implementation, it helps us with the example.
 * const label = new Label('My awesome label', 'LabelPack')
 * const imageParam = new ImageParameter('MyImage', label)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(imageParam)
 * ```
 *
 * @extends Parameter
 */
class ImageParameter extends Parameter {
  /**
   * Create an image parameter.
   *
   * @param {string} name - The name of the image parameter.
   * @param {BaseImage} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value, 'BaseImage');
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    if (this.__value) {
      j.imageType = Registry.getBlueprintName(this.__value);
    }
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  fromJSON(j, context) {
    if (j.imageType) {
      this.__value = Registry.constructClass(j.imageType);
    }
    return super.fromJSON(j, context)
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new image parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {ImageParameter} - Returns a new cloned image parameter.
   */
  clone() {
    const clonedParam = new ImageParameter(this.__name, this.__value);
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores Mat4(4x4 matrix) values.
 *
 * i.e.:
 * ```javascript
 * const stringParam = new StringParameter('MyString', 'A String value goes here')
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(stringParam)
 * ```
 *
 * @extends Parameter
 */
class StringParameter extends Parameter {
  /**
   * Create a string parameter.
   * @param {string} name - The name of the material color parameter.
   * @param {string} value - The value of the parameter.
   */
  constructor(name, value = '') {
    super(name, value, 'String');
    this.multiLine = false;
  }

  /**
   * Sets flag that indicates if the string contains new line feeds.
   *
   * @param {boolean} multiLine - The multiLine value.
   */
  setMultiLine(multiLine) {
    this.multiLine = multiLine;
  }

  /**
   * Returns multi-line flag value.
   *
   * @return {boolean} - The return value.
   */
  getMultiLine() {
    return this.multiLine
  }

  /**
   * Extracts the string value from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    this.__value = reader.loadStr();
  }

  /**
   * The clone method constructs a new string parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {StringParameter} - Returns a new string parameter.
   */
  clone() {
    const clonedParam = new StringParameter(this.__name, this.__value);
    return clonedParam
  }
}

Registry.register('StringParameter', StringParameter);
Registry.register('Property_String', StringParameter);

/**
 * Represents a specific type of parameter, that only stores `string` values.
 *
 * i.e.:
 * ```javascript
 * const codeStr = `const sayHello = () => console.log('Hello World')`
 * const codeParam = new CodeParameter('MyCode', codeStr)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(codeParam)
 * ```
 *
 * @extends StringParameter
 */
class CodeParameter extends StringParameter {
  /**
   * Creates a code parameter.
   * The default language is `js`.
   *
   * @param {string} name - The name of the code parameter.
   * @param {string} value - The value of the parameter.
   */
  constructor(name, value = '') {
    super(name, value, 'String');
    this.lang = 'js';
  }

  /**
   * Sets code language for parameter.
   *
   * @param {string} lang - The language value.
   */
  setLanguage(lang) {
    this.lang = lang;
  }

  /**
   * Returns code language of parameter.
   *
   * @return {string} - Returns the language.
   */
  getLanguage() {
    return this.lang
  }

  /**
   * The clone method constructs a new code parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {CodeParameter} - Returns a new cloned code parameter.
   */
  clone() {
    const clonedParam = new CodeParameter(this.__name, this.__value);
    return clonedParam
  }
}

Registry.register('CodeParameter', CodeParameter);

/**
 * Represents a specific type of parameter, that only stores any type of list values.
 *
 * i.e.:
 * ```javascript
 * const listParam = new ListParameter('MyList', GearParameter)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(listParam)
 * ```
 *
 * **Events**
 * * **valueChanged:** Triggered when setting a value changes in the array(insert, add, remove).
 * * **elementAdded:** Triggered when an element is added to the array(add, insert).
 * * **elementRemoved:** Triggered when an element is removed from the array
 *
 * @extends Parameter
 */
class ListParameter extends Parameter {
  /**
   * Create a list parameter.
   * @param {string} name - The name of the list parameter.
   * @param {string|Parameter} dataType - The dataType value.
   */
  constructor(name, dataType) {
    super(name, []);
    this.__dataType = dataType;
  }

  /**
   * The __filter method.
   * @param {string|Parameter} item - The item value.
   * @return {boolean} - The return value.
   *
   * @private
   */
  __filter(item) {
    return true
  }

  /**
   * Returns the count of items in the array.
   *
   * @return {number} - The return value.
   */
  getCount() {
    return this.__value.length
  }

  /**
   * Returns value from the array in the specified index.
   *
   * @param {number} index - The index value.
   * @return {Parameter|string} - The return value.
   */
  getElement(index) {
    return this.__value[index]
  }

  /**
   * Sets a value in the specified array's index.
   *
   * @param {number} index - The index value.
   * @param {string|Parameter} value - The value value.
   */
  setElement(index, value) {
    this.__value[index] = value;
    this.emit('valueChanged', {});
  }

  /**
   * Adds a new element at the end of the array pile.
   *
   * @param {string|Parameter} elem - The elem value.
   * @return {string|Parameter} - The return value.
   */
  addElement(elem) {
    if (elem == undefined) elem = new this.__dataType();
    else {
      if (!this.__filter(elem)) return
    }

    this.__value.push(elem);
    this.emit('elementAdded', { elem, index: this.__value.length - 1 });
    this.emit('valueChanged', {});
    return elem
  }

  /**
   * Removes an array element from the specified index
   *
   * @param {number} index - The index value.
   */
  removeElement(index) {
    const elem = this.__value[index];
    this.__value.splice(index, 1);
    this.emit('elementRemoved', { elem, index });
    this.emit('valueChanged', {});
  }

  /**
   * Inserts a new element in the specified index.
   *
   * @param {number} index - The index value.
   * @param {string|Parameter} elem - The elem value.
   */
  insertElement(index, elem) {
    if (!this.__filter(elem)) return
    this.__value.splice(index, 0, elem);
    // this.setValue(this.__value);
    this.emit('elementAdded', { elem, index });
    this.emit('valueChanged', {});
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const items = [];
    for (const p of this.__value) {
      if (typeof this.__dataType === 'string') items.push(p);
      else items.push(p.toJSON(context));
    }
    return {
      items,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.items == undefined) {
      console.warn('Invalid Parameter JSON');
      return
    }

    this.__value = [];
    for (let i = 0; i < j.items.length; i++) {
      let elem;
      if (typeof this.__dataType === 'string') {
        elem = j.items[i];
      } else {
        console.log(this.__dataType);
        elem = new this.__dataType();
        elem.fromJSON(j.items[i], context);
      }
      this.__value.push(elem);
      this.emit('elementAdded', { elem, index: this.__value.length - 1 });
    }
    this.emit('valueChanged', { mode: 0 });
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new list parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {ListParameter} - Returns a new list parameter.
   */
  clone() {
    const clonedValue = this.__value.slice(0);
    const clonedParam = new ListParameter(this.__name, this.__dataType);
    clonedParam.setValue(clonedValue);
    return clonedParam
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    for (let i = 0; i < this.__value.length; i++) {
      if (this.__value[i] instanceof Parameter) this.__value[i].destroy();
      this.removeElement(i);
    }
  }
}

/**
 * Represents a specific type of parameter, that stores multiple parameters in object format.
 *
 * i.e.:
 * ```javascript
 * const structParam = new StructParameter('MyStructParam')
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(structParam)
 * ```
 *
 * **Events**
 * * **valueChanged:** Triggered whenever parameter's value changes.
 *
 * @extends Parameter
 */
class StructParameter extends Parameter {
  /**
   * Create a struct parameter.
   * @param {string} name - The name of the struct parameter.
   */
  constructor(name) {
    super(name, {}, 'Struct');
    this.__members = [];
  }

  /**
   * The _addMember method.
   * @param {Parameter} parameter - The parameter value.
   * @return {Parameter} - The return value.
   * @private
   */
  _addMember(parameter) {
    this.__value[parameter.getName()] = parameter.getValue();
    parameter.on('valueChanged', () => {
      this.__value[parameter.getName()] = parameter.getValue();
    });
    this.__members.push(parameter);
    this.emit('valueChanged', {});
    return parameter
  }

  /**
   * The getParameter method.
   *
   * @private
   * @param {string} name - The parameter name.
   * @return {Parameter} - The return value.
   */
  getParameter(name) {
    for (const p of this.__members) {
      if (p.getName() == name) return p
    }
  }

  /**
   * Looks for a member parameter with the specified name and returns it.
   *
   * @param {string} name - The parameter name.
   * @return {Parameter} - The return value.
   */
  getMember(name) {
    return this.getParameter(name)
  }

  /**
   * Returns the name of all parameters in StructParameter.
   *
   * @return {array} - The return value.
   */
  getMemberNames() {
    const names = [];
    for (let i = 0; i < this.__members.length; i++) {
      const member = this.__members[i];
      if (member != null) names[i] = member.getName();
    }
    return names
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const members = [];
    for (const p of this.__members) members.push(p.toJSON(context));
    return {
      members,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.members == undefined) {
      console.warn('Invalid Parameter JSON');
      return
    }

    for (let i = 0; i < j.members.length; i++) {
      if (j.members[i]) {
        this.__members[i].fromJSON(j.members[i], context);
      }
    }
  }

  // ////////////////////////////////////////
  // Destroy

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    for (const p of this.__members) p.destroy();
  }
}

/* eslint-disable require-jsdoc */

/**
 * Represents a specific type of parameter, that only stores `TreeItem` values.
 *
 * i.e.:
 * ```javascript
 * const treeItem = new TreeItem('tree1')
 * const treeItemParam = new TreeItemParameter('MyTreeItem', treeItem)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(treeItemParam)
 * ```
 *
 * **Events**
 * * **treeItemGlobalXfoChanged:** Triggered when computed world Xfo of parameter's `TreeItem` changes.
 * * **valueChanged:** Triggered when parameter's value changes.
 *
 * @extends Parameter
 */
class TreeItemParameter extends Parameter {
  /**
   * Create a tree item parameter.
   * @param {string} name - The name of the tree item parameter.
   * @param {function} filterFn - The filterFn value.
   */
  constructor(name, filterFn = undefined) {
    super(name, undefined, 'TreeItem');
    this.__filterFn = filterFn;
    this.__emittreeItemGlobalXfoChanged = this.__emittreeItemGlobalXfoChanged.bind(this);
  }

  __emittreeItemGlobalXfoChanged(event) {
    this.emit('treeItemGlobalXfoChanged', event);
  }

  /**
   * Sets parameter value's owner `TreeItem`.
   *
   * @param {TreeItem} owner - The owner value.
   */
  setOwner(owner) {
    this.__owner = owner;
  }

  /**
   * Returns parameter value's owner `TreeItem`.
   *
   * @return {TreeItem} - The return value.
   */
  getOwner() {
    return this.__owner
  }

  /**
   * The setFilterFn method.
   * @param {function} flterFn - The flterFn value.
   */
  setFilterFn() {
    this.__filterFn = filterFn;
  }

  /**
   * The getFilterFn method.
   * @return {function} - The return value.
   */
  getFilterFn() {
    return this.__filterFn
  }

  /**
   * Sets parameter's `TreeItem` value.
   *
   * @param {TreeItem} treeItem - The treeItem value
   * @return {boolean} - The return value.
   */
  setValue(treeItem) {
    // 0 == normal set. 1 = changed via cleaner fn, 2=change by loading/cloning code.
    if (this.__filterFn && !this.__filterFn(treeItem)) return false
    if (this.__value !== treeItem) {
      if (this.__value) {
        this.__value.off('globalXfoChanged', this.__emittreeItemGlobalXfoChanged);
      }
      this.__value = treeItem;
      if (this.__value) {
        this.__value.on('globalXfoChanged', this.__emittreeItemGlobalXfoChanged);
      }

      this.emit('valueChanged', {});
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    return {
      value: context.makeRelative(this.__value.getPath()),
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.value == undefined) {
      console.warn('Invalid Parameter JSON');
      return
    }
    context.resolvePath(
      j.value,
      (treeItem) => {
        this.setValue(treeItem);
      },
      () => {
        console.warn('Unable to resolve tree item parameter value:' + pj.paramPath);
      }
    );
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new tree item parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {TreeItemParameter} - Returns a new tree item parameter.
   */
  clone() {
    const clonedParam = new TreeItemParameter(this.__name, this.__filterFn);
    return clonedParam
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    if (this.__value) {
      this.__value.off('globalXfoChanged', this.__emittreeItemGlobalXfoChanged);
    }
  }
}

/** Class representing an item set parameter.
 * @extends Parameter
 * @private
 */
class ItemSetParameter extends Parameter {
  /**
   * Create an item set parameter.
   * @param {string} name - The name of the item set parameter.
   * @param {any} filterFn - The filterFn value.
   */
  constructor(name, filterFn) {
    super(name, undefined, 'BaseItem');
    this.__items = new Set();
    this.__filterFn = filterFn; // Note: the filter Fn indicates that users will edit the set.
  }

  /**
   * The setFilterFn method.
   * @param {any} filterFn - The filterFn value.
   */
  setFilterFn(filterFn) {
    this.__filterFn = filterFn;
  }

  /**
   * The getFilterFn method.
   * @return {any} - The return value.
   */
  getFilterFn() {
    return this.__filterFn
  }

  /**
   * The getItem method.
   * @param {number} index - The index param.
   * @return {any} - The return value.
   */
  getItem(index) {
    return Array.from(this.__items)[index]
  }

  /**
   * The addItem method.
   * @param {any} item - The item value.
   * @param {boolean} emitValueChanged - The emit value.
   * @return {boolean} - The return value.
   */
  addItem(item, emitValueChanged = true) {
    if (this.__filterFn && !this.__filterFn(item)) {
      console.warn('ItemSet __filterFn rejecting item:', item.getPath());
      return false
    }
    this.__items.add(item);
    const index = Array.from(this.__items).indexOf(item);
    this.emit('itemAdded', { item, index });
    if (emitValueChanged) this.emit('valueChanged', {});
    return index
  }

  /**
   * Adds items to the parameter value
   *
   * @param {Set} items - list of items to add to the parameter
   * @param {boolean} [emitValueChanged=true]
   * @memberof ItemSetParameter
   */
  addItems(items, emitValueChanged = true) {
    items.forEach((item) => this.addItem(item, false));
    if (emitValueChanged) this.emit('valueChanged', {});
  }

  /**
   * The removeItem method.
   * @param {any} index - The index value.
   * @param {boolean} emitValueChanged - The emit param.
   * @return {any} - The return value.
   */
  removeItem(index, emitValueChanged = true) {
    const item = Array.from(this.__items)[index];
    this.__items.delete(item);
    this.emit('itemRemoved', { item, index });
    if (emitValueChanged) this.emit('valueChanged', {});
    return item
  }

  /**
   * The setItems method.
   * @param {any} items - The item param.
   * @param {boolean} emit - The emit param.
   */
  setItems(items, emit = true) {
    for (let i = this.__items.length - 1; i >= 0; i--) {
      const item = this.__items[i];
      if (!items.has(item)) {
        this.removeItem(item, false);
      }
    }
    for (const item of items) {
      if (!this.__items.has(item)) {
        this.addItem(item, false);
      }
    }
    if (emit) this.emit('valueChanged', {});
  }

  /**
   * The clearItems method.
   * @param {boolean} emit - The emit value.
   */
  clearItems(emitValueChanged = true) {
    this.__items.clear();
    if (emitValueChanged) this.emit('valueChanged', {});
  }

  /**
   * The getNumItems method.
   * @return {any} - The return value.
   */
  getNumItems() {
    return Array.from(this.__items).length
  }

  /**
   * The getValue method.
   * @return {any} - The return value.
   */
  getValue() {
    return this.__items
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @param {object} context - The context value.
   * @return {object} - The return value.
   */
  toJSON(context) {
    return {}
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {}

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a item set new parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {ItemSetParameter} - Returns a new item set parameter.
   */
  clone() {
    const clonedParam = new ItemSetParameter(this.__name, this.__filterFn);
    return clonedParam
  }
}

/** Class representing a proxy parameter. Proxies are used to connect
 * a parameter on one object with another. An existing parameter is
 * replaced with a proxy that binds to a parameter on another object.
 * @extends Parameter
 * @private
 */
class ProxyParameter extends Parameter {
  /**
   * Create a proxy parameter.
   * @param {string} name - The name of the proxy parameter.
   * @param {Parameter} sourceParameter - The source parameter to proxy.
   */
  constructor(name, sourceParameter) {
    super(name, undefined, sourceParameter.getDataType());
    this.setSourceParameter(sourceParameter);
  }

  /**
   * The setValue method.
   * @param {any} value - The value param.
   */
  setSourceParameter(sourceParameter) {
    this.sourceParameter = sourceParameter;
    this.sourceParameter.on('valueChanged', this.__proxyValueChanged.bind(this));
  }

  /**
   * @private
   * Handles propagating the valueChanged event from the source param
   * @param {any} value - The value param.
   */
  __proxyValueChanged(event) {
    this.emit('valueChanged', event);
  }

  /**
   * The getDataType method.
   * @return {any} - The return value.
   */
  getDataType() {
    return this.sourceParameter.getDataType()
  }

  /**
   * The setValue method.
   * @param {any} value - The value param.
   */
  setValue(value) {
    // this.sourceParameter.setValue(value)
  }

  /**
   * The getValue method.
   * @return {any} - The return value.
   */
  getValue() {
    return this.sourceParameter.getValue()
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    if (this.sourceParameter) j.sourceParameter = this.sourceParameter.getPath();
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);
    if (j.sourceParameter) {
      // Note: the tree should have fully loaded by the time we are loading operators
      // even new items and groups should have been created. Operators and state machines
      // are loaded last.
      context.resolvePath(
        j.sourceParameter,
        (param) => {
          this.setSourceParameter(param);
        },
        (reason) => {
          console.warn("Error loading Proxy Param: '" + this.getName() + "'. Unable to connect to:" + j.sourceParameter);
        }
      );
    }
    if (j.range) this.sourceParameter = j.range;
    if (j.step) this.__step = j.step;
  }

  // ////////////////////////////////////////
  // Clone

  /**
   * The clone method constructs a new number parameter, copies its values
   * from this parameter and returns it.
   *
   * @param {object} context - The context object.
   * @return {ProxyParameter} - Returns a new number parameter.
   */
  clone(context) {
    const clonedParam = new ProxyParameter(this.__name, this.__value);
    if (this.sourceParameter) {
      this.connectToClonedSourceParam(context);
    }
    return clonedParam
  }

  /**
   * During cloning, we need to reconnect references to other items in the tree
   * These other items may/may not be being cloned also, and so we need to request
   * the context that it resolve the item.
   * @param {CloneContext} context - The context object that can resolve references.
   */
  connectToClonedSourceParam(context) {
    context.resolveClonedItem(
      this.sourceParameter,
      (param) => {
        clonedParam.setSourceParameter(param);
      },
      (reason) => {
        console.warn("Error cloning Proxy Param: '" + this.getName() + "'. Unable to connect to:" + j.sourceParameter);
      }
    );
  }
}

Registry.register('ProxyParameter', ProxyParameter);

/** Class representing a geometry parameter.
 * @extends Parameter
 * @private
 */
class GeometryParameter extends Parameter {
  /**
   * Create a geometry parameter.
   * @param {string} name - The name of the color parameter.
   * @param {any} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, undefined, 'Geometry');
    this.setValue(value);

    this.__emitBoundingBoxDirtied = this.__emitBoundingBoxDirtied.bind(this);
  }

  // eslint-disable-next-line require-jsdoc
  __emitBoundingBoxDirtied(event) {
    this.emit('boundingBoxChanged', event);
  }

  /**
   * The setValue method.
   * @param {any} geom - The geom value.
   */
  setValue(geom) {
    // 0 == normal set. 1 = changed via cleaner fn, 2 = change by loading/cloning code.
    if (this.__value !== geom) {
      if (this.__value) {
        this.__value.off('boundingBoxChanged', this.__emitBoundingBoxDirtied);
      }
      this.__value = geom;
      if (this.__value) {
        this.__value.on('boundingBoxChanged', this.__emitBoundingBoxDirtied);
      }

      this.emit('valueChanged', {});
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    return super.toJSON(context)
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  fromJSON(j, context) {
    return super.fromJSON(j, context)
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new geometry parameter, copies its values
   * from this parameter and returns it.
   * @return {GeometryParameter} - Returns a new geometry parameter.
   */
  clone() {
    const clonedParam = new GeometryParameter(this.__name, this.__value);
    return clonedParam
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    // Note: some parameters hold refs to geoms/materials,
    // which need to be explicitly cleaned up.
    // e.g. freeing GPU Memory.

    if (this.__value) {
      this.__value.off('boundingBoxChanged', this.__emitBoundingBoxDirtied);
    }
  }
}

/**
 * Represents a specific type of parameter, that only stores file data values.
 *
 * **Events**
 * * **valueChanged:** Triggered when setting file's URL.
 * * **fileUpdated:** Triggered when parameter's value is updated.
 *
 * @extends Parameter
 */
class FilePathParameter extends Parameter {
  /**
   * Create a file path parameter.
   *
   * @param {string} name - The name of the file path parameter.
   * @param {string} exts - The exts value.
   */
  constructor(name) {
    super(name, '', 'FilePath');
  }

  /**
   * Returns complete file path.
   *
   * @return {string} - The return value.
   */
  getFilepath() {
    if (this.__value) {
      return resourceLoader.getFilepath(this.__value)
    }

    return ''
  }

  /**
   * Resolves resourceId using the specified path and sets its value to the parameter.
   *
   * @param {string} filePath - The filePath value.
   */
  setFilepath(filePath) {
    this.setValue(resourceLoader.resolveFileId(filePath));
  }

  /**
   * Returns parameter's file name
   *
   * @return {string} - The return value.
   */
  getFilename() {
    return resourceLoader.resolveFilename(this.__value)
  }

  /**
   * Returns parameter's file extension
   *
   * @return {string} - The return value.
   */
  getExt() {
    const filename = this.getFilename();
    const suffixSt = filename.lastIndexOf('.');
    if (suffixSt != -1) return filename.substring(suffixSt).toLowerCase()
  }

  /**
   * Returns parameter's file name without extension
   *
   * @return {string} - The return value.
   */
  getStem() {
    const filename = this.getFilename();
    if (filename) {
      const parts = filename.split('.');
      if (parts.length == 2) return parts[0]
      else return filename
    }
  }

  /**
   * Returns file object, which contains the url, resourceId and the name.
   *
   * @return {object} - The return value.
   */
  getFileDesc() {
    return this.getFile()
  }

  /**
   * Returns file object, which contains the url, resourceId and the name.
   *
   * @return {object} - The return value.
   */
  getFile() {
    return { id: this.__value, url: this.getUrl(), name: this.getFilename() }
  }

  /**
   * Sets file data.
   *
   * @param {string} url - the url value of the
   * @param {string} name - (optional) the name of the file that the Url points to.
   */
  setUrl(url, name) {
    this.setValue(resourceLoader.resolveFileId(url));
  }

  /**
   * Returns the file url string.
   *
   * @return {string} - The return value.
   */
  getUrl() {
    return resourceLoader.resolveURL(this.__value)
  }

  /**
   * Sets file parameter value
   *
   * @param {string} value - The value param.
   */
  setValue(value) {
    if (value == undefined) {
      throw new Error('Invalid value for setValue.')
    }
    // Note: equality tests only work on simple types.
    // Important here because file changes cause reloads..
    if (value == this.__value) {
      return
    }

    this.__value = value;

    this.emit('valueChanged', {});
  }
  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = {};
    if (this.__file) {
      j.value = this.__value;
    }
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.value) {
      this.__value = j.value;
    }
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new file path parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {FilePathParameter} - Returns a new cloned file path parameter.
   */
  clone() {
    const clonedParam = new FilePathParameter(this.__name);
    clonedParam.__file = this.__file;
    return clonedParam
  }
}

/**
 * Represents a specific type of parameter, that only stores `Material` values.
 *
 * i.e.:
 * ```javascript
 * const material = new Material('itemMaterial', 'SimpleSurfaceShader')
 * material.getParameter('BaseColor').setValue(new Color(89 / 255, 182 / 255, 92 / 255))
 *
 * const materialParam = new MaterialParameter('MyMaterial', material)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(materialParam)
 * ```
 * **Events**
 * * **valueParameterValueChanged:** Triggered when parameter's value changes.
 * * **valueChanged:** Triggered when parameter's value changes, except on cleaning processes.
 *
 * @extends Parameter
 */
class MaterialParameter extends Parameter {
  /**
   * Create a material parameter.
   * @param {string} name - The name of the material parameter.
   * @param {Material} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value, 'Material');
    this.__valueParameterValueChanged = this.__valueParameterValueChanged.bind(this);
  }

  // eslint-disable-next-line require-jsdoc
  __valueParameterValueChanged(event) {
    this.emit('valueParameterValueChanged', event);
  }

  /**
   * Sets `Material` value of the parameter.
   *
   * @param {Material} material - The material param.
   */
  setValue(material) {
    // 0 == normal set. 1 = changed via cleaner fn, 2 = change by loading/cloning code.
    if (this.__value !== material) {
      if (this.__value) {
        this.__value.off('parameterValueChanged', this.__valueParameterValueChanged);
      }
      this.__value = material;
      if (this.__value) {
        this.__value.on('parameterValueChanged', this.__valueParameterValueChanged);
      }

      // During the cleaning process, we don't want notifications.
      this.emit('valueChanged', {});
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    return this.__value ? { value: this.__value.getPath() } : undefined
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.value == undefined) {
      console.warn('Invalid Parameter JSON');
      return
    }

    if (j.value instanceof array || j.value instanceof string) {
      if (context && context.assetItem) {
        const materialLibrary = context.assetItem.getMaterialLibrary();
        const material = materialLibrary.getMaterial(j.value instanceof array ? j.value[1] : j.value);
        if (material) {
          this.loadValue(material);
        }
      }
    }
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new material parameter, copies its values
   * from this parameter and returns it.
   *
   * @return {MaterialParameter} - Returns a new material parameter.
   */
  clone() {
    const clonedParam = new MaterialParameter(this.__name, this.__value);
    return clonedParam
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    // Note: Some parameters hold refs to geoms/materials,
    // which need to be explicitly cleaned up.
    // E.g. freeing GPU Memory.

    if (this.__value) {
      this.__value.off('parameterValueChanged', this.__valueParameterValueChanged);
    }
  }
}

/**
 * Represents a 2D image item, containing width and height.
 *
 * **Parameters**
 * * **AlphaFromLuminance(`BooleanParameter`):** Sets alpha chanel to the luminance of the image and all color channels to `0`.
 * * **Invert(`BooleanParameter`):** Horizontally flips the image(Basically inverting X pixels).
 * * **FlipY(`BooleanParameter`):** Vertically flips the image, meaning that it would be upside down if enabled.
 *
 * **Events**
 * * **updated:** Triggered when the value of any of the parameters listed above changes.
 *
 * @extends BaseItem
 */
class BaseImage extends BaseItem {
  /**
   * Creates an instance of BaseImage.
   * @param {string} name - name of the item
   */
  constructor(name) {
    super(name);
    this.width = 0;
    this.height = 0;
    this.format = 'RGB';
    this.type = 'UNSIGNED_BYTE';

    this.addParameter(new BooleanParameter('AlphaFromLuminance', false));
    this.addParameter(new BooleanParameter('Invert', false));
    this.addParameter(new BooleanParameter('FlipY', false));

    this.on('parameterValueChanged', (event) => {
      this.emit('updated');
    });

    // Note: Many parts of the code assume a 'loaded' signal.
    // We should probably deprecate and use only 'updated'.
    // Instead we should start using a loaded Promise.
    this.loaded = false;
  }

  /**
   * Returns true if loaded.
   * @private
   * @return {boolean} - Returns a boolean.
   */
  isLoaded() {
    return true
  }

  /**
   * Returns mapping object state of the item.
   * @return {object|undefined} - The return value.
   */
  getMapping() {
    return this.__mapping
  }

  /**
   * Sets mapping structure object in the state of the item.
   * @param {object} mapping - The mapping value.
   */
  setMapping(mapping) {
    this.__mapping = mapping;
  }

  /**
   * Base images are static content, so the value for this method is always going to be `false`
   *
   * @return {boolean} - Returns a boolean.
   */
  isStream() {
    return false
  }

  /**
   * The isStreamAtlas method.
   * @private
   * @return {boolean} - Returns a boolean.
   */
  isStreamAtlas() {
    return this.__streamAtlas
  }

  /**
   * Returns all parameters and class state values.
   *
   * @return {object} - The return value.
   */
  getParams() {
    return {
      type: this.type,
      format: this.format,
      width: this.width,
      height: this.height,
      flipY: this.getParameter('FlipY').getValue(),
      invert: this.getParameter('Invert').getValue(),
      alphaFromLuminance: this.getParameter('AlphaFromLuminance').getValue(),
    }
  }
}

/**
 * Represents a specific type of parameter, that stores `number` and `BaseImage` texture values.
 *
 * i.e.:
 * ```javascript
 * const image = new LDRImage();
 * image.getParameter('FilePath').setUrl("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
 *
 * const numberParam = new MaterialFloatParam('MyMaterialFloat', 15.5)
 * numberParam.setImage(image)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(numberParam)
 * ```
 *
 * * **Events**
 * * **valueChanged:** Triggered every time the Image value changes
 * * **textureDisconnected:** Triggered when Image value is cleaned/removed.
 * * **textureConnected:** Triggered when the Image value is set.
 *
 * @extends NumberParameter
 */
class MaterialFloatParam extends NumberParameter {
  /**
   * Create a material float parameter.
   * @param {string} name - The name of the material color parameter.
   * @param {number} value - The value of the parameter.
   * @param {array} range - An array with two numbers. If defined, the parameter value will be clamped.
   */
  constructor(name, value, range) {
    super(name, value, range);
  }

  /**
   * Returns `BaseImage` texture of the Material.
   *
   * @return {BaseImage} - The return value.
   */
  getImage() {
    return this.__image
  }

  /**
   * Sets `BaseImage` texture value in parameter.
   *
   * @param {BaseImage} value - The value value.
   */
  setImage(value) {
    const disconnectImage = () => {
      // image.off('loaded', imageUpdated);
      // image.off('updated', imageUpdated);
      this.emit('textureDisconnected', {});
    };
    if (value) {
      if (this.__image != undefined && this.__image !== value) {
        disconnectImage();
      }
      this.__image = value;
      // image.on('loaded', imageUpdated);
      // image.on('updated', imageUpdated);
      this.emit('textureConnected', {});
      this.emit('valueChanged', { mode: 0 });
    } else {
      if (this.__image != undefined) {
        disconnectImage();
        this.__image = undefined;
        this.emit('textureDisconnected', {});
      }
    }
  }

  /**
   * Sets `number` or the `BaseImage` texture value in parameter.
   *
   * @param {number} value - The value param.
   */
  setValue(value) {
    if (value instanceof BaseImage) {
      this.setImage(value);
    } else {
      if (this.__image != undefined) {
        this.setImage(undefined);
      }
      super.setValue(value);
    }
  }

  /**
   * Extracts `number` and `Image` values from a buffer, updating current parameter state.
   *
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.readBinary(reader, context);

    const textureName = reader.loadStr();
    if (textureName != '') {
      console.log('Load Texture');
      this.setImage(context.materialLibrary.getImage(textureName));
    }
  }

  /**
   * The clone method constructs a new material float parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {MaterialFloatParam} - Returns a new cloned material float parameter.
   */
  clone() {
    const clonedParam = new MaterialFloatParam(this.__name, this.__value.clone());
    return clonedParam
  }
}

Registry.register('MaterialFloatParam', MaterialFloatParam);

/**
 * Represents a specific type of parameter, that stores `Color` and `BaseImage` texture values.
 *
 * i.e.:
 * ```javascript
 * const image = new LDRImage();
 * image.getParameter('FilePath').setUrl("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
 *
 * const matColorParam = new MaterialColorParam('MyMaterialColor', new Color(0, 254, 2))
 * matColorParam.setImage(image)
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(matColorParam)
 * ```
 *
 * **Events**
 * * **valueChanged:** Triggered every time the Image value changes
 * * **textureDisconnected:** Triggered when Image value is cleaned/removed.
 * * **textureConnected:** Triggered when the Image value is set.
 *
 * @extends ColorParameter
 */
class MaterialColorParam extends ColorParameter {
  /**
   * Create a material color parameter.
   * @param {string} name - The name of the material color parameter.
   * @param {Color} value - The value of the parameter.
   */
  constructor(name, value) {
    super(name, value);
    this.__imageUpdated = this.__imageUpdated.bind(this);
  }

  /**
   * Returns `BaseImage` texture of the Material.
   *
   * @return {BaseImage} - The return value.
   */
  getImage() {
    return this.__image
  }

  /**
   * The __imageUpdated method.
   * @private
   */
  __imageUpdated() {
    this.emit('valueChanged', {});
  }

  /**
   * Sets `BaseImage` texture value in parameter.
   *
   * @param {BaseImage} value - The value param.
   */
  setImage(value) {
    const disconnectImage = () => {
      this.__image.off('loaded', this.__imageUpdated);
      this.__image.off('updated', this.__imageUpdated);
      this.__image = null;
      this.emit('textureDisconnected', {});
    };
    if (value) {
      if (this.__image != undefined && this.__image !== value) {
        disconnectImage();
      }
      this.__image = value;
      this.__image.on('updated', this.__imageUpdated);
      this.emit('textureConnected', {});
      this.emit('valueChanged', { mode: 0 });
    } else {
      if (this.__image != undefined) {
        disconnectImage();
        this.__image = undefined;
        this.emit('textureDisconnected', {});
      }
    }
  }

  /**
   * Sets `Color` or the `BaseImage` texture value in parameter.
   *
   * @param {BaseImage|Color} value - The value param.
   */
  setValue(value) {
    // Note: instead of supporting images or colors, we should replace the ColorParameter with an ImageParameter when assigning textures
    // console.warn('@todo-review: Should we accept different type of values?')
    if (value instanceof BaseImage) {
      this.setImage(value);
    } else {
      if (this.__image != undefined) {
        this.setImage(undefined);
      }
      super.setValue(value);
    }
  }
  /**
   * Extracts `Color` and `Image` values from a buffer, updating current parameter state.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.readBinary(reader, context);

    const textureName = reader.loadStr();
    if (textureName != '') {
      this.setImage(context.materialLibrary.getImage(textureName));
    }
  }

  /**
   * The clone method constructs a new material color parameter,
   * copies its values from this parameter and returns it.
   *
   * @return {MaterialColorParam} - Returns a new cloned material color parameter.
   */
  clone() {
    const clonedParam = new MaterialColorParam(this.__name, this.__value.clone());
    return clonedParam
  }
}

Registry.register('MaterialColorParam', MaterialColorParam);

/* eslint-disable require-jsdoc */

function isTypedArray(obj) {
  return !!obj && obj.byteLength !== undefined
}

/**
 * Class representing an attribute.
 */
class Attribute {
  /**
   * Create an attribute.
   * @param {AttrValue|number} dataType - The dataType value.
   * @param {number|TypedArray} expectedSize - The expectedSize value.
   * @param {number} defaultValue - The defaultValue value.
   */
  constructor(dataType, expectedSize, defaultValue = undefined) {
    this.__dataType = dataType;
    this.normalized = false;
    if (dataType.numElements != undefined) {
      this.__dimension = this.__dataType.numElements();
    } else {
      switch (dataType) {
        case Float32:
        case UInt32:
        case SInt32:
          this.__dimension = 1;
          break
        default:
          throw new Error('Invalid data type for attribute:' + dataType)
      }
    }
    this.__defaultElementValue = defaultValue != undefined ? defaultValue : Number.MAX_VALUE;
    if (isTypedArray(expectedSize)) {
      this.__data = expectedSize;
    } else {
      this.__data = new Float32Array(expectedSize * this.__dimension);
      this.initRange(0);
    }
  }

  /**
   * Resizes current data array to to a new size.
   * In case the new size is bigger than current size, the new values are filled up with default ones.
   *
   * @param {number} size - The size value.
   */
  resize(size) {
    const prevLength = this.__data.length;
    const newLength = size * this.__dimension;

    if (newLength > prevLength) {
      const data = new Float32Array(newLength);
      data.set(this.__data);
      this.__data = data;
      this.initRange(prevLength);
    } else if (newLength < prevLength) {
      this.__data = this.__data.slice(0, newLength);
    }
  }

  /**
   * Fills up data values with default ones starting from the specified index.
   *
   * @param {number} start - The start value.
   */
  initRange(start) {
    // Initialize the values to invalid values.
    for (let i = start; i < this.__data.length; i++) {
      this.__data[i] = this.__defaultElementValue;
    }
  }

  /**
   * Returns the count of attribute values in the data.
   *
   * @return {number} - The return value.
   */
  getCount() {
    return this.__data.length / this.__dimension
  }

  /**
   * Returns the count of attribute values in the data.
   *
   * @return {number} - The return value.
   */
  get length() {
    return this.__data.length / this.__dimension
  }

  /**
   * Returns the type of attribute value.
   *
   * @return {AttrValue|number} - The return value.
   */
  get dataType() {
    return this.__dataType
  }

  /**
   * Returns current data array.
   *
   * @return {TypedArray} - The return value.
   */
  get data() {
    return this.__data
  }

  /**
   * Sets data value.
   *
   * @param {TypedArray} data - The data value.
   */
  set data(data) {
    this.__data = data;
  }

  /**
   * Returns the number of elements stored in each `AttrValue`.
   *
   * @return {number} - The return value.
   */
  get numElements() {
    return this.__dimension
  }

  /**
   * Returns data value of the specified index.
   *
   * @param {number} index - The index value.
   * @return {number} - The return value.
   */
  getFloat32Value(index) {
    return this.__data[index]
  }

  /**
   * Sets data value in the specified index.
   *
   * @param {number} index - The index value.
   * @param {number} value - The value param.
   */
  setFloat32Value(index, value) {
    this.__data[index] = value;
  }

  /**
   * Returns the `AttrValue` object placed in the specified index.
   *
   * @param {number} index - The index value.
   * @return {AttrValue} - The return value.
   */
  getValueRef(index) {
    const numElems = this.__dimension;
    if (index >= this.__data.length / numElems)
      throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.__data.length / 3)
    return this.__dataType.createFromBuffer(this.__data.buffer, index * numElems * 4)
  }

  /**
   * Sets `AttrValue` object in the specified index.
   *
   * @param {number} index - The index value.
   * @param {AttrValue} value - The value param.
   */
  setValue(index, value) {
    const numElems = this.__dimension;
    if (index >= this.__data.length / numElems)
      throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.__data.length / 3)
    this.__dataType.createFromBuffer(this.__data.buffer, index * numElems * 4).setFromOther(value);
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    return {
      data: Array.from(this.__data),
      dataType: Registry.getBlueprintName(this.__dataType),
      defaultValue: this.__defaultElementValue,
      length: this.__data.length / this.__dimension,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   */
  fromJSON(j) {
    this.__data = Float32Array.from(j.data);
  }

  /**
   * Returns the string representation of the object's state.
   *
   * @return {string} - The return value.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }
}

/* eslint-disable require-jsdoc */

// Defines used to explicity specify types for WebGL.
function isTypedArray$1(obj) {
  return !!obj && obj.byteLength !== undefined
}

/**
 * Represents a base class for 3D geometry items.
 *
 * **Events**
 * * **boundingBoxChanged:** Triggered when the bounding box changes.
 *
 * @extends ParameterOwner
 */
class BaseGeom extends ParameterOwner {
  /**
   * Create a base geom.
   */
  constructor() {
    super();
    this.__numVertices = 0;
    this.__boundingBox = new Box3$1();
    this.__boundingBoxDirty = true;
    this.__vertexAttributes = new Map();
    this.__metaData = new Map();
    this.addVertexAttribute('positions', Vec3$1, 0.0);
  }

  /**
   * Establishes a name for the geometry.
   *
   * @param {string} name - The debug name value.
   */
  setDebugName(name) {
    this.__name = name;
  }

  /**
   * Adds a new vertex attribute to the geometry.
   *
   * @param {string} name - The name of the vertex attribute.
   * @param {AttrValue|number} dataType - The dataType value.
   * @param {number} defaultScalarValue - The default scalar value.
   * @return {Attribute} - Returns an attribute.
   */
  addVertexAttribute(name, dataType, defaultScalarValue = undefined) {
    const positions = this.getVertexAttribute('positions');
    let attr;
    if (isTypedArray$1(defaultScalarValue)) {
      attr = new Attribute(dataType, defaultScalarValue);
    } else {
      attr = new Attribute(dataType, positions != undefined ? positions.length : 0, defaultScalarValue);
    }
    this.__vertexAttributes.set(name, attr);
    return attr
  }

  /**
   * Checks if the the geometry has an attribute with the specified name.
   *
   * @param {string} name - The name of the vertex attribute.
   * @return {boolean} - The return value.
   */
  hasVertexAttribute(name) {
    return this.__vertexAttributes.has(name)
  }

  /**
   * Returns vertex attribute with the specified name.
   *
   * @param {string} name - The name of the vertex attribute.
   * @return {Attribute} - The return value.
   */
  getVertexAttribute(name) {
    return this.__vertexAttributes.get(name)
  }

  /**
   * Returns all vertex attributes in an object with their names.
   *
   * @return {object} - The return value.
   */
  getVertexAttributes() {
    const vertexAttributes = {};
    for (const [key, attr] of this.__vertexAttributes.entries()) vertexAttributes[key] = attr;
    return vertexAttributes
  }

  /**
   * Returns 'positions' vertex attribute.
   * @deprecated
   */
  get vertices() {
    console.warn("deprecated use #getVertexAttribute('positions')");
    return this.__vertexAttributes.get('positions')
  }

  /**
   * Returns the number of vertex attributes.
   *
   * @return {number} - The return value.
   */
  numVertices() {
    return this.__numVertices
  }

  /**
   * Returns the number of vertex attributes.
   *
   * @return {number} - The return value.
   */
  getNumVertices() {
    return this.__numVertices
  }

  /**
   * Sets the number of vertices the geometry has.
   *
   * @param {number} count - The count value.
   */
  setNumVertices(count) {
    this.__numVertices = count;
    // Resizes each of the vertex attributes to match the new count.
    this.__vertexAttributes.forEach((attr) => attr.resize(this.__numVertices));
  }

  /**
   * Returns the position attribute value of the given vertex
   * @deprecated
   * @param {number} index - The index value.
   * @return {Vec3} - Returns a Vec3.
   */
  getVertex(index) {
    console.warn(`deprecated use #getVertexAttribute('positions').getValueRef()`);
    return Vec3$1.createFromBuffer(this.vertices.data.buffer, index * 3 * 4)
  }

  /**
   * Sets the position attribute value of the given vertex
   * @deprecated
   * @param {index} index - The index value.
   * @param {Vec3} value - The value value.
   * @return {Vec3} - Returns a Vec3.
   */
  setVertex(index, value) {
    console.warn(`deprecated use #getVertexAttribute('positions').getValueRef().setFromOther(value)`);
    return Vec3$1.createFromBuffer(this.vertices.data.buffer, index * 3 * 4).setFromOther(value)
  }

  /**
   * Applies an offset to each of the vertices in the geometry.
   * @deprecated
   * @param {Vec3} delta - The delta value.
   */
  moveVertices(delta) {
    console.warn(`deprecated use #getVertexAttribute('positions').getValueRef()`);
    const vertices = this.vertices;
    for (let i = 0; i < vertices.length; i++) vertices.getValueRef(i).addInPlace(delta);
    this.setBoundingBoxDirty();
  }

  /**
   * The transformVertices method.
   * @deprecated
   * @param {Xfo} xfo - The xfo tranform.
   */
  transformVertices(xfo) {
    console.warn(`deprecated, please transform the vertices manually`);
    const vertices = this.vertices;
    for (let i = 0; i < vertices.length; i++) {
      const v = vertices.getValueRef(i);
      const v2 = xfo.transformVec3(v);
      v.set(v2.x, v2.y, v2.z);
    }
    this.setBoundingBoxDirty();
  }

  // ////////////////////////////////////////
  // BoundingBox

  /**
   * Returns the bounding box for geometry.
   * @deprecated
   * @return {Vec3} - The return value.
   */
  get boundingBox() {
    console.warn(`deprecated, please use #getBoundingBox()`);
    if (this.__boundingBoxDirty) this.updateBoundingBox();
    return this.__boundingBox
  }

  /**
   * Returns the bounding box for geometry.
   * @return {Vec3} - The return value.
   */
  getBoundingBox() {
    if (this.__boundingBoxDirty) this.updateBoundingBox();
    return this.__boundingBox
  }

  /**
   * The setBoundingBoxDirty method.
   */
  setBoundingBoxDirty() {
    this.__boundingBoxDirty = true;
    this.emit('boundingBoxChanged', {});
  }

  /**
   * The updateBoundingBox method.
   */
  updateBoundingBox() {
    const positions = this.getVertexAttribute('positions');
    const bbox = new Box3$1();
    const numVerts = positions.length;
    for (let i = 0; i < numVerts; i++) bbox.addPoint(positions.getValueRef(i));
    this.__boundingBox = bbox;
    this.__boundingBoxDirty = false;
  }

  // ////////////////////////////////////////
  // Metadata

  /**
   * Returns metadata value of the specified name.
   *
   * @param {string} key - The key value.
   * @return {object} - The return value.
   */
  getMetadata(key) {
    return this.__metaData.get(key)
  }

  /**
   * Verifies if geometry's metadata contains a value with the specified key.
   *
   * @param {string} key - The key value.
   * @return {boolean} - The return value.
   */
  hasMetadata(key) {
    return this.__metaData.has(key)
  }

  /**
   * Sets metadata value to the geometry.
   *
   * @param {string} key - The key value.
   * @param {object} metaData - The metaData value.
   */
  setMetadata(key, metaData) {
    this.__metaData.set(key, metaData);
  }

  /**
   * Removes metadata value from the geometry with the specified key.
   *
   * @param {string} key - The key value.
   */
  deleteMetadata(key) {
    this.__metaData.delete(key);
  }

  // ////////////////////////////////////////
  // Memory

  /**
   * Returns vertex attributes buffers and its count.
   *
   * @param {object} opts - The opts value.
   * @return {object} - The return value.
   */
  genBuffers(opts) {
    const attrBuffers = {};
    for (const [attrName, attr] of this.__vertexAttributes) {
      attrBuffers[attrName] = {
        values: attr.data,
        count: attr.length,
        dataType: attr.dataType,
        normalized: attr.normalized,
      };
    }
    return {
      numVertices: this.numVertices(),
      attrBuffers,
    }
  }

  /**
   * The freeBuffers method.
   */
  freeBuffers() {
    // Before destroying all our data,
    // make sure the bbox is up to date.
    // if (this.__boundingBoxDirty)
    //     this.updateBoundingBox();
    // // TODO: push the data to a worker thread and terminate like in MeshProxy.
    // this.__vertexAttributes = new Map();
  }

  // ////////////////////////////////////////
  // Persistence
  /**
   * Sets state of current Geometry(Including Vertices and Bounding Box) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   */
  loadBaseGeomBinary(reader) {
    this.name = reader.loadStr();
    const flags = reader.loadUInt8();
    this.debugColor = reader.loadRGBFloat32Color();
    const numVerts = reader.loadUInt32();
    this.__boundingBox.set(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());

    this.setNumVertices(numVerts);
    const positionsAttr = this.getVertexAttribute('positions');

    let normalsAttr;
    let texCoordsAttr;
    if (flags & (1 << 1)) {
      normalsAttr = this.getVertexAttribute('normals');
      if (!normalsAttr) normalsAttr = this.addVertexAttribute('normals', Vec3$1, 0.0);
    }
    if (flags & (1 << 2)) {
      texCoordsAttr = this.getVertexAttribute('texCoords');
      if (!texCoordsAttr) texCoordsAttr = this.addVertexAttribute('texCoords', Vec2, 0.0);
    }

    const parse8BitPositionsArray = (range, offset, sclVec, positions_8bit) => {
      for (let i = range[0]; i < range[1]; i++) {
        const pos = new Vec3$1(
          positions_8bit[i * 3 + 0] / 255.0,
          positions_8bit[i * 3 + 1] / 255.0,
          positions_8bit[i * 3 + 2] / 255.0
        );
        pos.multiplyInPlace(sclVec);
        pos.addInPlace(offset);
        positionsAttr.setValue(i, pos);
      }
    };

    const parse8BitNormalsArray = (range, offset, sclVec, normals_8bit) => {
      if (sclVec.isNull()) sclVec.set(1, 1, 1);
      for (let i = range[0]; i < range[1]; i++) {
        const normal = new Vec3$1(
          normals_8bit[i * 3 + 0] / 255.0,
          normals_8bit[i * 3 + 1] / 255.0,
          normals_8bit[i * 3 + 2] / 255.0
        );
        normal.multiplyInPlace(sclVec);
        normal.addInPlace(offset);
        normal.normalizeInPlace();
        normalsAttr.setValue(i, normal);
      }
    };
    const parse8BitTextureCoordsArray = (range, offset, sclVec, texCoords_8bit) => {
      // if (sclVec.isNull())
      //     sclVec.set(1, 1, 1);
      for (let i = range[0]; i < range[1]; i++) {
        const textureCoord = new Vec2(texCoords_8bit[i * 2 + 0] / 255.0, texCoords_8bit[i * 2 + 1] / 255.0);
        textureCoord.multiplyInPlace(sclVec);
        textureCoord.addInPlace(offset);
        texCoordsAttr.setValue(i, textureCoord);
      }
    };

    const numClusters = reader.loadUInt32();
    if (numClusters == 1) {
      {
        const box3 = this.__boundingBox;
        const positions_8bit = reader.loadUInt8Array(numVerts * 3);
        parse8BitPositionsArray([0, numVerts], box3.p0, box3.diagonal(), positions_8bit);
      }

      if (normalsAttr) {
        const box3 = new Box3$1(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
        const normals_8bit = reader.loadUInt8Array(numVerts * 3);
        parse8BitNormalsArray([0, numVerts], box3.p0, box3.diagonal(), normals_8bit);

        normalsAttr.loadSplitValues(reader);
      }
      if (texCoordsAttr) {
        const box2 = new Box2(reader.loadFloat32Vec2(), reader.loadFloat32Vec2());
        const texCoords_8bit = reader.loadUInt8Array(numVerts * 2);
        parse8BitTextureCoordsArray([0, numVerts], box2.p0, box2.diagonal(), texCoords_8bit);

        texCoordsAttr.loadSplitValues(reader);
      }
    } else {
      const clusters = [];
      let offset = 0;
      for (let i = 0; i < numClusters; i++) {
        const count = reader.loadUInt32();
        const box3 = new Box3$1(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
        const clusterData = {
          range: [offset, offset + count],
          bbox: box3,
        };
        if (normalsAttr) {
          clusterData.normalsRange = new Box3$1(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
        }
        if (texCoordsAttr) {
          clusterData.texCoordsRange = new Box2(reader.loadFloat32Vec2(), reader.loadFloat32Vec2());
        }

        clusters.push(clusterData);
        offset += count;
      }
      const positions_8bit = reader.loadUInt8Array(numVerts * 3);
      let normals_8bit;
      let texCoords_8bit;
      if (normalsAttr) {
        normals_8bit = reader.loadUInt8Array(numVerts * 3);
      }
      if (texCoordsAttr) {
        texCoords_8bit = reader.loadUInt8Array(numVerts * 2);
      }

      for (let i = 0; i < numClusters; i++) {
        {
          const box3 = clusters[i].bbox;
          parse8BitPositionsArray(clusters[i].range, box3.p0, box3.diagonal(), positions_8bit);
        }

        if (normalsAttr) {
          const box3 = clusters[i].normalsRange;
          parse8BitNormalsArray(clusters[i].range, box3.p0, box3.diagonal(), normals_8bit);
        }
        if (texCoordsAttr) {
          const box2 = clusters[i].texCoordsRange;
          parse8BitTextureCoordsArray(clusters[i].range, box2.p0, box2.diagonal(), texCoords_8bit);
        }
      }
      if (normalsAttr) {
        normalsAttr.loadSplitValues(reader);
      }
      if (texCoordsAttr) {
        texCoordsAttr.loadSplitValues(reader);
      }
    }
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    let json = super.toJSON(context);
    if (!json) json = {};
    json.type = Registry.getBlueprintName(this);
    json.numVertices = this.__numVertices;

    const vertexAttributes = {};
    for (const [key, attr] of this.__vertexAttributes.entries()) {
      // if (!opts || !('attrList' in opts) || opts.attrList.indexOf(key) != -1)
      vertexAttributes[key] = attr.toJSON(context);
    }
    json.vertexAttributes = vertexAttributes;

    return json
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context) {
    super.fromJSON(json, context);
    this.setNumVertices(json.numVertices);
    for (const name in json.vertexAttributes) {
      let attr = this.__vertexAttributes.get(name);
      const attrJSON = json.vertexAttributes[name];
      if (!attr) {
        const dataType = Registry.getBlueprint(attrJSON.dataType);
        attr = new VertexAttribute(this, dataType, 0, attrJSON.defaultScalarValue);
        this.__vertexAttributes.set(name, attr);
      }
      attr.fromJSON(attrJSON);
    }
  }

  /**
   * Returns geometry data value in json format.
   *
   * @return {string} - The return value.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }
}

/* eslint-disable camelcase */

/**
 * Class representing vertex attributes.
 *
 * ```
 * const vertexAttribute = new VertexAttribute(this, Float32, 0)
 * ```
 *
 * @extends Attribute
 */
class VertexAttribute$1 extends Attribute {
  /**
   * Create vertex attributes
   * @param {Mesh} geom - The geom value.
   * @param {AttrValue|number} dataType - The dataType value.
   * @param {number|TypedArray} expectedSize - The expectedSize value.
   * @param {number} defaultScalarValue - The default scalar value.
   */
  constructor(geom, dataType, expectedSize, defaultScalarValue) {
    super(dataType, expectedSize, defaultScalarValue);
    this.__geom = geom; // TODO: WeakRef??

    this.__splits = {};
    this.__splitValues = [];
  }

  /**
   * The getFaceVertexValueRef method.
   * @param {number} face - The face value.
   * @param {number} facevertex - The face vertex value.
   * @return {AttrValue} - The return value.
   */
  getFaceVertexValueRef(face, facevertex) {
    const vertex = this.__geom.getFaceVertexIndex(face, facevertex);
    if (vertex in this.__splits && face in this.__splits[vertex]) {
      return this.__splitValues[this.__splits[vertex][face]]
    }
    return this.getValueRef(vertex)
  }

  /**
   * The setFaceVertexValue method.
   * @param {number} face - The face value.
   * @param {number} facevertex - The facevertex value.
   * @param {AttrValue} value - The value value.
   */
  setFaceVertexValue(face, facevertex, value) {
    const vertex = this.__geom.getFaceVertexIndex(face, facevertex);
    this.setFaceVertexValue_ByVertexIndex(face, vertex, value);
  }

  /**
   * The setFaceVertexValue_ByVertexIndex method.
   * @param {number} face - The face value.
   * @param {number} vertex - The vertex value.
   * @param {AttrValue} value - The value value.
   */
  setFaceVertexValue_ByVertexIndex(face, vertex, value) {
    const valueRef = this.getValueRef(vertex);
    if (!valueRef.isValid()) {
      // the value is uninitialized. Initialize it.
      valueRef.setFromOther(value);
    } else if (valueRef.approxEqual(value)) ; else {
      // The new value is different from the existing value

      if (vertex in this.__splits) {
        // Now check if any existing splits for this vertex match the value being set.
        // i.e. for faces around a vertex, there will often be a seam along 2 edges
        // where the values differ. On each side of the seam, all faces can use the same
        // value. We should see then only one split value for the vertex.
        const vertexSplitIds = this.__splits[vertex];
        for (const fid in vertexSplitIds) {
          const splitId = vertexSplitIds[fid];
          if (this.__splitValues[splitId].approxEqual(value)) {
            // re-use this split value
            vertexSplitIds[face] = splitId;
            return
          }
        }

        // If a split already exists for this face, re-use it.
        if (face in this.__splits[vertex]) {
          const valueRef = this.__splitValues[this.__splits[vertex][face]];
          valueRef.setFromOther(value);
          return
        }
      } else {
        this.__splits[vertex] = {};
      }
      this.__splits[vertex][face] = this.__splitValues.length;
      this.__splitValues.push(value);
    }
  }

  /**
   * The setSplitVertexValue method.
   * @param {number} vertex - The vertex value.
   * @param {number} face - The face value.
   * @param {AttrValue} value - The value value.
   */
  setSplitVertexValue(vertex, face, value) {
    if (!(vertex in this.__splits)) this.__splits[vertex] = {};
    if (face in this.__splits[vertex]) {
      const currValue = this.__splitValues[this.__splits[vertex][face]];
      if (currValue.approxEqual(value)) return
      console.warn('Face Vertex Already Split with different value');
    }
    this.__splits[vertex][face] = this.__splitValues.length;
    this.__splitValues.push(value);
  }

  /**
   * The setSplitVertexValues method.
   * @param {number} vertex - The vertex value.
   * @param {array} faceGroup - The faceGroup value.
   * @param {AttrValue} value - The value value.
   */
  setSplitVertexValues(vertex, faceGroup, value) {
    if (!(vertex in this.__splits)) this.__splits[vertex] = {};
    const splitIndex = this.__splitValues.length;
    this.__splitValues.push(value);
    for (const face of faceGroup) {
      // if (face in this.__splits[vertex]) {
      //     let currValue = this.__splitValues[this.__splits[vertex][face]];
      //     if (currValue.approxEqual(value))
      //         return;
      //     console.warn("Face Vertex Already Split with different value");
      // }
      this.__splits[vertex][face] = splitIndex;
    }
  }

  /**
   * The getSplits method.
   * @return {array} - The return value.
   */
  getSplits() {
    return this.__splits
  }

  /**
   * The getSplitCount method.
   * @return {number} - The return value.
   */
  getSplitCount() {
    let splitCount = 0;
    for (const vertex in this.__splits) splitCount += Object.keys(this.__splits[vertex]).length;
    return splitCount
  }

  /**
   * The generateSplitValues method.
   * @param {array} splitIndices - The splitIndices value.
   * @param {number} splitCount - The splitCount value.
   * @return {Float32Array} - The return value.
   */
  generateSplitValues(splitIndices, splitCount) {
    if (splitCount == 0) return this.__data

    const numUnSplitValues = this.length;
    const count = this.length + splitCount;
    const numElems = this.__dataType.numElements ? this.__dataType.numElements() : 1;
    const data = new Float32Array(count * numElems);
    for (let i = 0; i < this.__data.length; i++) data[i] = this.__data[i];

    // Now duplicate the split values to generate an attributes array
    // usig the shared splits accross all attributes.
    // eslint-disable-next-line guard-for-in
    for (const vertex in splitIndices) {
      const faces = splitIndices[vertex];
      // eslint-disable-next-line guard-for-in
      for (const face in faces) {
        const tgt = numUnSplitValues + faces[face];
        if (vertex in this.__splits && face in this.__splits[vertex]) {
          // this attribue has a split value in its array.
          // we must use that value...
          const src = this.__splits[vertex][face];
          if (this.__dataType == Float32) data[tgt * numElems] = this.__splitValues[src];
          else this.__dataType.createFromBuffer(data.buffer, tgt * numElems * 4).setFromOther(this.__splitValues[src]);
        } else {
          // Copy each scalar value to the new place in the array.
          const src = parseInt(vertex);
          for (let e = 0; e < numElems; e++) {
            if (src * numElems + e > this.__data.length) {
              console.log('Error remapping src:' + src * numElems + e);
            }
            if (tgt * numElems + e > data.length) {
              console.log('Error remapping tgt:' + tgt * numElems + e);
            }
            data[tgt * numElems + e] = this.__data[src * numElems + e];
          }
        }
      }
    }
    return data
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const json = super.toJSON(context);
    json.splits = this.__splits;
    json.splitValues = this.__splitValues;
    return json
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context) {
    super.fromJSON(json, context);
    this.__splits = json.splits;
    this.__splitValues = [];
    for (const valjson of json.splitValues) this.__splitValues.push(this.__dataType.createFromJSON(valjson));
  }

  /**
   * The loadSplitValues method.
   * @param {BinReader} reader - The reader value.
   */
  loadSplitValues(reader) {
    const splitIndices = reader.loadUInt32Array();
    if (splitIndices.length == 0) return
    let offset = 0;
    let numSplitValues = 0;
    while (true) {
      const vertexId = splitIndices[offset++];
      const numSplits = splitIndices[offset++];

      const splits = {};
      for (let i = 0; i < numSplits; i++) {
        const faceId = splitIndices[offset++];
        const splitId = splitIndices[offset++];
        splits[faceId] = splitId;
        if (splitId >= numSplitValues) numSplitValues = splitId + 1;
      }
      this.__splits[vertexId] = splits;
      if (offset >= splitIndices.length) break
    }
    const dim = this.__numFloat32Elements;
    const splitValues = reader.loadFloat32Array(numSplitValues * dim);
    this.__splitValues = [];
    for (let i = 0; i < numSplitValues; i++) {
      const val = this.__dataType.createFromFloat32Array(splitValues.slice(i * dim, i * dim + dim));
      this.__splitValues.push(val);
    }
  }
}

/* eslint-disable camelcase */

/**
 * Class representing a point primitive drawing type, every vertex specified is a point.
 *
 * ```
 * const points = new Points()
 * ```
 *
 * * **Events**
 * * **boundingBoxChanged:** Triggered when the bounding box changes.
 *
 * @extends BaseGeom
 */
class Points extends BaseGeom {
  /**
   * Create points.
   */
  constructor() {
    super();
  }

  /**
   * Loads and populates `Points` object from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   */
  loadBin(reader) {
    this.name = reader.loadStr();
    const numVerts = reader.loadUInt32();
    this.__boundingBox.set(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
    this.setNumVertices(numVerts);
    const positions = this.getVertexAttribute('positions');

    if (numVerts < 256) {
      const bboxMat = this.__boundingBox.toMat4();
      const posAttr_8bit = reader.loadUInt8Array(numVerts * 3);
      for (let i = 0; i < numVerts; i++) {
        const pos = new Vec3(
          posAttr_8bit[i * 3 + 0] / 255.0,
          posAttr_8bit[i * 3 + 1] / 255.0,
          posAttr_8bit[i * 3 + 2] / 255.0
        );
        positions.setValue(i, bboxMat.transformVec3(pos));
      }
    } else {
      const numClusters = reader.loadUInt32();
      const clusters = [];
      for (let i = 0; i < numClusters; i++) {
        const range = reader.loadUInt32Vec2();
        const p0 = reader.loadFloat32Vec3();
        const p1 = reader.loadFloat32Vec3();
        clusters.push({
          range: range,
          bbox: new Box3(p0, p1),
        });
      }
      const posAttr_8bit = reader.loadUInt8Array(numVerts * 3);

      for (let i = 0; i < numClusters; i++) {
        const bboxMat = clusters[i]['bbox'].toMat4();
        for (let j = clusters[i]['range'].x; j < clusters[i]['range'].y; j++) {
          const pos = new Vec3(
            posAttr_8bit[j * 3 + 0] / 255.0,
            posAttr_8bit[j * 3 + 1] / 255.0,
            posAttr_8bit[j * 3 + 2] / 255.0
          );
          positions.setValue(j, bboxMat.transformVec3(pos));
        }
      }
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Sets state of current geometry(Including line segments) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.loadBaseGeomBinary(reader);

    // this.computeVertexNormals();
    this.emit('geomDataChanged', {});
  }
}

Registry.register('Points', Points);

/**
 *
 * Class representing lines primitive drawing type, connecting vertices using the specified indices.
 * i.e. We have 4 points(vertices) but we don't know how they connect to each other,
 * and that's why we need indices(Numbers indicating which vertex connects to which).
 * In this case if we say that `indices` is `[0,1,2,3]`, it would connect the first vertex to the second,
 * and the third to the fourth.
 *
 * ```
 * const lines = new Lines()
 * ```
 *
 * **Events**
 * * **geomDataChanged:** Triggered when the data value of the geometry is set(This includes reading binary)
 *
 * @extends BaseGeom
 */
class Lines extends BaseGeom {
  /**
   * Create lines.
   */
  constructor() {
    super();
    this.__indices = new Uint32Array();
    this.lineThickness = 0.0;
  }

  /**
   * Returns the specified indices(Vertex connectors)
   *
   * @return {Uint32Array} - The indices index array.
   */
  getIndices() {
    return this.__indices
  }

  /**
   * Returns the number of line segments.
   *
   * @return {number} - Returns the number of segments.
   */
  getNumSegments() {
    return this.__indices.length / 2
  }

  /**
   * Sets the number of line segments in the geometry.<br>
   * **Important:** It resets indices values.
   *
   * @param {number} numOfSegments - The count value.
   */
  setNumSegments(numOfSegments) {
    if (numOfSegments > this.getNumSegments()) {
      const indices = new Uint32Array(numOfSegments * 2);
      indices.set(this.__indices);
      this.__indices = indices;
    } else {
      this.__indices = this.__indices.slice(0, numOfSegments * 2);
    }
  }

  /**
   * Sets segment values in the specified index.
   *
   * @param {number} index - The index value.
   * @param {number} p0 - The p0 value.
   * @param {number} p1 - The p1 value.
   */
  setSegmentVertexIndices(index, p0, p1) {
    if (index >= this.__indices.length / 2)
      throw new Error('Invalid line index:' + index + '. Num Segments:' + this.__indices.length / 2)
    this.__indices[index * 2 + 0] = p0;
    this.__indices[index * 2 + 1] = p1;
  }

  /**
   * Sets segment values in the specified index.
   *
   * @param {number} index - The index value.
   * @param {number} p0 - The p0 value.
   * @param {number} p1 - The p1 value.
   */
  setSegment(index, p0, p1) {
    console.warn(`deprecated use #setSegmentVertexIndices`);
    this.setSegmentVertexIndices(index, p0, p1);
  }

  /**
   * The getSegmentVertexIndex method.
   *
   * @param {number} line - The line value.
   * @param {number} lineVertex - The lineVertex value.
   * @return {number} - The return value.
   * @private
   */
  getSegmentVertexIndex(line, lineVertex) {
    const numSegments = this.getNumSegments();
    if (line < numSegments) return this.__indices[line * 2 + lineVertex]
  }

  // ////////////////////////////////////////
  // Memory

  /**
   * Returns vertex attributes buffers and its count.
   *
   * @return {object} - The return value.
   */
  genBuffers() {
    const buffers = super.genBuffers();

    let indices;
    if (buffers.numVertices < Math.pow(2, 8)) {
      indices = new Uint8Array(this.__indices.length);
      this.__indices.forEach((value, index) => {
        indices[index] = value;
      });
    } else if (buffers.numVertices < Math.pow(2, 16)) {
      indices = new Uint16Array(this.__indices.length);
      this.__indices.forEach((value, index) => {
        indices[index] = value;
      });
    } else {
      indices = this.__indices;
    }
    buffers.indices = indices;
    return buffers
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Sets state of current geometry(Including line segments) using a binary reader object.
   *
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.loadBaseGeomBinary(reader);

    this.setNumSegments(reader.loadUInt32());

    const bytes = reader.loadUInt8();
    if (bytes == 1) this.__indices = reader.loadUInt8Array();
    else if (bytes == 2) this.__indices = reader.loadUInt16Array();
    else if (bytes == 4) this.__indices = reader.loadUInt32Array();

    this.emit('geomDataChanged', {});
  }
  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    j.indices = Array.from(this.__indices);

    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);
    this.__indices = Uint32Array.from(j.indices);
  }
}

Registry.register('Lines', Lines);

/* eslint-disable prefer-rest-params */

/**
 * The Mesh class provides a flexible and fast polygon mesh representation. It supports polygons of arbitrary complexity,
 * from basic triangles and quads to pentagons more.
 * It supports storing per face attributes, and per edge attributes.
 * The Mesh class handles converting its internal representation of polygons into a simpler triangles representation for rendering.
 *
 * ```
 * const mesh = new Mesh()
 * ```
 *
 * **Events**
 * * **geomDataTopologyChanged:** Triggered when the topology of the mesh has been changed.
 * * **geomDataChanged:** Triggered when the vertices of the mesh have changed, but not necessarily the topology.
 *
 * @extends BaseGeom
 */
class Mesh extends BaseGeom {
  /**
   * Creates an instance of Mesh.
   */
  constructor() {
    super();
    this.init();
  }

  /**
   * The init method.
   * @private
   */
  init() {
    this.__faceCounts = [];
    this.__faceVertexIndices = new Uint32Array();

    this.__faceAttributes = new Map();
    this.__edgeAttributes = new Map();

    this.__logTopologyWarnings = false;

    this.edgeVerts = undefined;
    this.vertexEdges = undefined;
    this.numEdges = 0;
    this.edgeAngles = new Float32Array();
  }

  /**
   * The getFaceCounts method.
   * @return {array} - The return value.
   */
  getFaceCounts() {
    return this.__faceCounts
  }

  /**
   * The getNumFaces method.
   * @return {number} - The return value.
   */
  getNumFaces() {
    return this.__faceCounts.length == 0 ? 0 : this.__faceCounts.reduce((numFaces, fc) => (numFaces += fc))
  }

  /**
   * The clear method.
   */
  clear() {
    this.__faceVertexIndices = undefined;
    this.__faceCounts = [];
  }

  /**
   * Sets the number of faces on the mesh using an array specifying the counts per polygon size.
   * The first item in the array specifies the number of triangles, the second, the number of quads, the 3rd, the number o f5 sided polygons etc..
   * e.g. to specify 2 triangles, and 7 quads, we would pass [2, 7]
   * @param {array} faceCounts - The faceCounts value.
   */
  setFaceCounts(faceCounts) {
    let numFaces = 0;
    let numFacesVertices = 0;
    let numVertsPerFace = 3;
    for (const fc of faceCounts) {
      numFaces += fc;
      numFacesVertices += fc * numVertsPerFace;
      numVertsPerFace++;
    }

    const prevNumFaces = this.getNumFaces();
    if (prevNumFaces == 0) {
      this.__faceVertexIndices = new Uint32Array(numFacesVertices);
    } else {
      const faceVertexIndices = new Uint32Array(numFacesVertices);

      // Now we preserve the existing indices if they fit within the new faceVertexIndices array.
      let startSrc = 0;
      let startTgt = 0;
      numFacesVertices = 0;
      numVertsPerFace = 3;
      faceCounts.forEach((fc, index) => {
        const endSrc = startSrc + Math.min(fc, this.__faceCounts[index]) * numVertsPerFace;
        faceVertexIndices.set(this.__faceVertexIndices.slice(startSrc, endSrc), startTgt);
        startSrc += this.__faceCounts[index] * numVertsPerFace;
        startTgt += fc * numVertsPerFace;
        numVertsPerFace++;
      });
      this.__faceVertexIndices = faceVertexIndices;
    }
    this.__faceCounts = faceCounts;

    for (const attr of this.__faceAttributes) attr.resize(numFaces);
  }

  /**
   * Returns the number of vertices indexed by this face
   * @param {number} faceIndex - The faceIndex value.
   * @return {number} - The return value.
   */
  getFaceVertexCount(faceIndex) {
    let idx = 0;
    let count = 0;
    this.__faceCounts.some((fc, index) => {
      idx += fc;
      if (idx > faceIndex) {
        count = index + 3;
        return true
      }
    });
    return count
  }

  /**
   * Returns the offset of the face indices within the entire index array.
   * @param {number} faceIndex - The faceIndex value.
   * @return {number} - The return value.
   */
  getFaceVertexOffset(faceIndex) {
    let idx = 0;
    let offset = 0;
    this.__faceCounts.some((fc, index) => {
      if (idx + fc > faceIndex) {
        offset += (faceIndex - idx) * (index + 3);
        return true
      }
      idx += fc;
      offset += fc * (index + 3);
    });
    return offset
  }

  /**
   * The setFaceVertexIndices method.
   * @param {number} faceIndex - The faceIndex value.
   * @param {array} vertexIndices - The array of vertex indices for this face value.
   */
  setFaceVertexIndices(faceIndex, vertexIndices) {
    if (arguments.length != 2) {
      console.warn(`deprecated interface. Please pass vertexIndices as an array`);
      vertexIndices = Array.prototype.slice.call(arguments, 1);
    }
    const faceVertexCount = this.getFaceVertexCount(faceIndex);
    if (vertexIndices.length != faceVertexCount) {
      throw new Error(
        `Invalid indices for face:${faceIndex} vertexIndices:${vertexIndices}. Expected ${faceVertexCount} indices`
      )
    }
    const offset = this.getFaceVertexOffset(faceIndex);
    this.__faceVertexIndices.set(vertexIndices, offset);
  }

  /**
   * Adds a new face to the mesh
   * @param {array} vertexIndices - The vertex indices of the face.
   * @return {number} - The index of the face in the mesh.
   */
  addFace(vertexIndices) {
    const faceCounts = [...this.__faceCounts];
    if (faceCounts.length <= vertexIndices.length - 3) {
      for (let i = faceCounts.length; i < vertexIndices.length - 3; i++) faceCounts[i] = 0;
      faceCounts[vertexIndices.length - 3] = 1;
    } else {
      faceCounts[vertexIndices.length - 3]++;
    }
    this.setFaceCounts(faceCounts);

    // Calculate the offset in the faceVertexIndices of this new face.
    let faceIndex = 0;
    let offset = 0;
    this.__faceCounts.some((fc, index) => {
      if (index + 3 == vertexIndices.length) {
        faceIndex += fc - 1;
        offset += (fc - 1) * (index + 3);
        return true
      }
      faceIndex += fc;
      offset += fc * (index + 3);
    });
    this.__faceVertexIndices.set(vertexIndices, offset);
    return faceIndex
  }

  /**
   * Returns the vertex indices of the specified face.
   * @param {number} faceIndex - The index of the specified face
   * @return {array} - An array of indices into the vertex attributes
   */
  getFaceVertexIndices(faceIndex) {
    const vertexIndices = [];
    const offset = this.getFaceVertexOffset(faceIndex);
    const count = this.getFaceVertexCount(faceIndex);
    for (let i = 0; i < count; i++) {
      vertexIndices.push(this.__faceVertexIndices[offset + i]);
    }
    return vertexIndices
  }

  /**
   * Returns a single vertex index for a given face and facevertex.
   * @param {number} faceIndex - The faceIndex value.
   * @param {number} facevertex - The face vertex is the index within the face. So the first vertex index is 0.
   * @return {number} - The vertex index
   */
  getFaceVertexIndex(faceIndex, facevertex) {
    const offset = this.getFaceVertexOffset(faceIndex);
    return this.__faceVertexIndices[offset + facevertex]
  }

  // ///////////////////////////
  // Vertex Attributes

  /**
   * Adds a `VertexAttribute` to the geometry.
   *
   * @param {string} name - The name of the vertex attribute to add.
   * @param {AttrValue|number} dataType - The dataType value.
   * @param {number} defaultScalarValue - The default scalar value.
   * @return {VertexAttribute} - Returns a vertex attribute.
   */
  addVertexAttribute(name, dataType, defaultScalarValue = undefined) {
    const positions = this.getVertexAttribute('positions');
    const attr = new VertexAttribute$1(this, dataType, positions != undefined ? positions.length : 0, defaultScalarValue);
    this.__vertexAttributes.set(name, attr);
    return attr
  }

  // ///////////////////////////
  // Face Attributes

  /**
   * The addFaceAttribute method.
   * @param {string} name - The name of the face attribute to add.
   * @param {AttrValue|number} dataType - The data type.
   * @param {number|TypedArray} count - The count value.
   * @return {Attribute} - Returns a face attribute.
   */
  addFaceAttribute(name, dataType, count = undefined) {
    const attr = new Attribute(dataType, count != undefined ? count : this.getNumFaces());
    this.__faceAttributes.set(name, attr);
    return attr
  }

  /**
   * The hasFaceAttribute method.
   * @param {string} name - The name of the face attribute.
   * @return {boolean} - The return value.
   */
  hasFaceAttribute(name) {
    return this.__faceAttributes.has(name)
  }

  /**
   * The getFaceAttribute method.
   * @param {string} name - The name of the face attribute.
   * @return {boolean} - The return value.
   */
  getFaceAttribute(name) {
    return this.__faceAttributes.get(name)
  }

  // /////////////////////////
  // Edge Attributes

  /**
   * The addEdgeAttribute method.
   * @param {string} name - The name of the edge attribute t oadd.
   * @param {AttrValue|number} dataType - The data type.
   * @param {number} count - The default scalar value.
   * @return {Attribute} - Returns an edge attribute.
   */
  addEdgeAttribute(name, dataType, count = undefined) {
    const attr = new Attribute(dataType, count != undefined ? count : this.getNumEdges());
    this.__edgeAttributes.set(name, attr);
    return attr
  }

  /**
   * The hasEdgeAttribute method.
   * @param {string} name - The name of the edge attribute.
   * @return {boolean} - The return value.
   */
  hasEdgeAttribute(name) {
    return this.__edgeAttributes.has(name)
  }

  /**
   * The getEdgeAttribute method.
   * @param {string} name - The name of the edge attribute.
   * @return {Attribute} - The return value.
   */
  getEdgeAttribute(name) {
    return this.__edgeAttributes.get(name)
  }

  // ///////////////////////////

  /**
   * The genTopologyInfo method.
   */
  genTopologyInfo() {
    const connectedVertices = {}; // acceleration structure.
    this.vertexEdges = []; // 2d array of vertex to edges.
    // this.vertexFaces = []; // 2d array of vertex to faces.
    this.edgeFaces = []; // flat array of 2 face indices per edge
    this.edgeVerts = []; // flat array of 2 vert indices per edge
    this.faceEdges = []; // the edges bordering each face.
    this.numEdges = 0;

    const positions = this.getVertexAttribute('positions');
    const getEdgeIndex = (v0, v1) => {
      let tmp0 = v0;
      let tmp1 = v1;
      if (tmp1 < tmp0) {
        const tmp = tmp0;
        tmp0 = tmp1;
        tmp1 = tmp;
      }
      const key = tmp0 + '>' + tmp1;
      if (key in connectedVertices) {
        // console.log(key + ':' + connectedVertices[key] + " face:" + ( v0 < v1 ? 0 : 1) );
        return connectedVertices[key]
      }

      const p0 = positions.getValueRef(tmp0);
      const p1 = positions.getValueRef(tmp1);
      const edgeVec = p1.subtract(p0);

      const edgeIndex = this.edgeFaces.length / 2;
      const edgeData = {
        edgeIndex: edgeIndex,
        edgeVec: edgeVec,
      };
      connectedVertices[key] = edgeData;

      this.edgeFaces.push(-1);
      this.edgeFaces.push(-1);
      this.edgeVerts.push(tmp0);
      this.edgeVerts.push(tmp1);
      // console.log(key + ':' + connectedVertices[key] + " face:" + ( v0 < v1 ? 0 : 1));

      this.numEdges++;
      return edgeData
    };

    const addEdge = (v0, v1, faceIndex) => {
      // console.log('addEdge:' + v0 + " :" + v1 + " faceIndex:" + faceIndex );
      const edgeData = getEdgeIndex(v0, v1);
      const edgeIndex = edgeData.edgeIndex;
      if (v1 < v0) {
        const edgeFaceIndex = edgeIndex * 2 + 0;
        if (this.__logTopologyWarnings && this.edgeFaces[edgeFaceIndex] != -1)
          console.warn('Edge poly 0 already set. Mesh is non-manifold.');
        this.edgeFaces[edgeFaceIndex] = faceIndex;
      } else {
        const edgeFaceIndex = edgeIndex * 2 + 1;
        if (this.__logTopologyWarnings && this.edgeFaces[edgeFaceIndex] != -1)
          console.warn('Edge poly 1 already set. Mesh is non-manifold.');
        this.edgeFaces[edgeFaceIndex] = faceIndex;
      }

      if (!(faceIndex in this.faceEdges)) this.faceEdges[faceIndex] = [];
      this.faceEdges[faceIndex].push(edgeIndex);

      // Push the edge index onto both vertex edge lists.
      // We use Sets to avoid adding the same edge 2x to the same vertex.
      if (this.vertexEdges[v0] == undefined) {
        this.vertexEdges[v0] = new Set();
      }
      if (this.vertexEdges[v1] == undefined) {
        this.vertexEdges[v1] = new Set();
      }
      this.vertexEdges[v0].add(edgeIndex);
      this.vertexEdges[v1].add(edgeIndex);

      // if (this.vertexFaces[v0] == undefined) {
      //     this.vertexFaces[v0] = [];
      // }
      // this.vertexFaces[v0].push(faceIndex);
    };

    const numFaces = this.getNumFaces();
    for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
      const faceVerts = this.getFaceVertexIndices(faceIndex);
      for (let j = 0; j < faceVerts.length; j++) {
        const v0 = faceVerts[j];
        const v1 = faceVerts[(j + 1) % faceVerts.length];
        addEdge(v0, v1, faceIndex);
      }
    }
  }

  /**
   * Computes a normal value per face by averaging the triangle normals of the face.
   */
  computeFaceNormals() {
    const positions = this.getVertexAttribute('positions');
    const faceNormals = this.addFaceAttribute('normals', Vec3$1);
    const numFaces = this.getNumFaces();
    for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
      const faceVerts = this.getFaceVertexIndices(faceIndex);
      const p0 = positions.getValueRef(faceVerts[0]);
      const p1 = positions.getValueRef(faceVerts[1]);
      let prev = p1;
      const faceNormal = new Vec3$1();
      for (let j = 2; j < faceVerts.length; j++) {
        const pn = positions.getValueRef(faceVerts[j]);
        const v0 = prev.subtract(p0);
        const v1 = pn.subtract(p0);
        faceNormal.addInPlace(v0.cross(v1).normalize());
        prev = pn;
      }
      if (faceNormal.lengthSquared() < Number.EPSILON) ; else {
        faceNormals.setValue(faceIndex, faceNormal.normalize());
      }
    }
  }

  /**
   * Calculates the angles at each edge between the adjoining faces
   */
  calculateEdgeAngles() {
    if (this.vertexEdges == undefined) this.genTopologyInfo();

    if (!this.hasFaceAttribute('normals')) this.computeFaceNormals();

    const positions = this.getVertexAttribute('positions');
    const faceNormals = this.getFaceAttribute('normals');
    this.edgeVecs = [];
    this.edgeAngles = new Float32Array(this.numEdges);
    for (let i = 0; i < this.edgeFaces.length; i += 2) {
      const v0 = this.edgeVerts[i];
      const v1 = this.edgeVerts[i + 1];
      const e_vec = positions.getValueRef(v1).subtract(positions.getValueRef(v0));
      e_vec.normalizeInPlace();
      this.edgeVecs.push(e_vec);

      const p0 = this.edgeFaces[i];
      const p1 = this.edgeFaces[i + 1];
      if (p0 == -1 || p1 == -1) {
        // Flag the edge as a border edge....
        this.edgeAngles[i / 2] = Math.PI * 2.0;
        continue
      }

      const n0 = faceNormals.getValueRef(p0);
      const n1 = faceNormals.getValueRef(p1);
      this.edgeAngles[i / 2] = n0.angleTo(n1);
    }
  }

  /**
   * Compute vertex normals.
   * @param {number} hardAngle - The hardAngle value in radians.
   * @return {VertexAttribute} - The return value.
   */
  computeVertexNormals(hardAngle = 1.0 /* radians */) {
    // console.log("computeVertexNormals");

    this.calculateEdgeAngles();

    const faceNormals = this.getFaceAttribute('normals');
    const normalsAttr = this.addVertexAttribute('normals', Vec3$1);

    // these methods are faster versions than using the methods
    // provided on the attributes. We cache values and use hard coded constants.
    const faceNormalsBuffer = faceNormals.data.buffer;
    const getFaceNormal = (index) => {
      return Vec3$1.createFromBuffer(faceNormalsBuffer, index * 3 * 4) // 3 components at 4 bytes each.
    };
    const vertexNormalsArray = normalsAttr.data;
    const setVertexNormal = (index, value) => {
      vertexNormalsArray[index * 3 + 0] = value.x;
      vertexNormalsArray[index * 3 + 1] = value.y;
      vertexNormalsArray[index * 3 + 2] = value.z;
    };
    const getConnectedEdgeVecs = (faceIndex, vertexIndex) => {
      let e0;
      let e1;
      const faceEdges = this.faceEdges[faceIndex];
      for (const e of faceEdges) {
        if (this.edgeVerts[e * 2] == vertexIndex) {
          if (!e0) e0 = this.edgeVecs[e];
          else e1 = this.edgeVecs[e];
        } else if (this.edgeVerts[e * 2 + 1] == vertexIndex) {
          if (!e0) e0 = this.edgeVecs[e];
          else e1 = this.edgeVecs[e];
        }
      }
      return [e0, e1]
    };

    for (let i = 0; i < this.vertexEdges.length; i++) {
      // If this face indexing doesn't start at 0, then the vertexEdges don't either.
      if (this.vertexEdges[i] == undefined) continue

      const edges = this.vertexEdges[i];

      // Groups of faces having a smooth normal at the current vertex.
      const faceGroups = [];
      const addFaceToGroup = (face) => {
        let inGroup = false;
        for (const faceGroup of faceGroups) {
          inGroup = faceGroup.indexOf(face) != -1;
          if (inGroup) break
        }
        if (!inGroup) faceGroups.push([face]);
      };
      for (const e of edges) {
        const f0 = this.edgeFaces[e * 2];
        const f1 = this.edgeFaces[e * 2 + 1];
        if (f0 != -1 && f1 == -1 && this.edgeAngles[e] < hardAngle) {
          let f0groupIndex = -1;
          let f1groupIndex = -1;
          for (let groupIndex = 0; groupIndex < faceGroups.length; groupIndex++) {
            if (f0groupIndex == -1 && faceGroups[groupIndex].indexOf(f0) != -1) f0groupIndex = groupIndex;
            if (f1groupIndex == -1 && faceGroups[groupIndex].indexOf(f1) != -1) f1groupIndex = groupIndex;
          }
          if (f0groupIndex == -1 && f1groupIndex == -1) {
            faceGroups.push([f0, f1]);
          } else if (f0groupIndex != -1 && f1groupIndex != -1) {
            if (f0groupIndex != f1groupIndex) {
              // Merge the 2 groups that the smooth edge joins.
              faceGroups[f0groupIndex] = faceGroups[f0groupIndex].concat(faceGroups[f1groupIndex]);
              faceGroups.splice(f1groupIndex, 1);
            }
          } else {
            if (f0groupIndex == -1) {
              faceGroups[f1groupIndex].push(f0);
            }
            if (f1groupIndex == -1) {
              faceGroups[f0groupIndex].push(f1);
            }
          }
          continue
        }
        // This is a hard edge or a border edge... Add faces separately group.
        if (f0 != -1) addFaceToGroup(f0);
        if (f1 != -1) addFaceToGroup(f1);
      }

      // Sort the groups to have the biggest group first.
      faceGroups.sort((a, b) => (a.length < b.length ? 1 : a.length > b.length ? -1 : 0));

      let firstVirtex = true;
      for (const faceGroup of faceGroups) {
        const normal = new Vec3$1();
        for (const faceIndex of faceGroup) {
          const face_edges = getConnectedEdgeVecs(faceIndex, i);
          const weight = face_edges[0].angleTo(face_edges[1]);
          // if (i == 1)
          //     console.log("FaceNormal:" + faceIndex + ":" + getFaceNormal(faceIndex).toString());
          normal.addInPlace(getFaceNormal(faceIndex).scale(weight));
        }
        normal.normalizeInPlace();
        if (firstVirtex) {
          setVertexNormal(i, normal);
          firstVirtex = false;
        } else {
          normalsAttr.setSplitVertexValues(i, faceGroup, normal);
        }
      }
    }

    return normalsAttr
  }

  /**
   * The computeHardEdgesIndices method.
   * @param {number} hardAngle - The hardAngle value in radians.
   * @return {array} - The return value.
   */
  computeHardEdgesIndices(hardAngle = 1.0) {
    if (!this.edgeVerts) this.calculateEdgeAngles();

    const hardEdges = [];
    const addEdge = (index) => {
      hardEdges.push(this.edgeVerts[index]);
      hardEdges.push(this.edgeVerts[index + 1]);
    };
    for (let i = 0; i < this.edgeAngles.length; i++) {
      if (this.edgeAngles[i] > hardAngle) {
        addEdge(i * 2);
      }
    }
    return Uint32Array.from(hardEdges)
  }

  /**
   * The getWireframeIndices method.
   * @return {any} - The return value.
   * @private
   */
  getWireframeIndices() {
    console.warn('@todo-review - This returns nothing');
    return indices
  }

  // ////////////////////////////////////////
  // Rendering

  /**
   * The genBuffers method.
   * @param {object} opts - The opts value.
   * @return {object} - The return value.
   */
  genBuffers(opts) {
    // Compute the normals on demand.
    // if (!('normals' in this.__vertexAttributes)) {
    //     // this.__geom.computeVertexNormals();
    //     this.addVertexAttribute("normals", Vec3, 0.0);
    // }

    const splitIndices = {};
    let splitCount = 0;
    for (const [, attr] of this.__vertexAttributes) {
      const attrSplits = attr.getSplits();
      for (const polygon in attrSplits) {
        if (!(polygon in splitIndices)) splitIndices[polygon] = {};
        const vertices = attrSplits[polygon];
        for (const v in vertices) {
          const vertex = parseInt(v);
          if (!(vertex in splitIndices[polygon])) {
            splitIndices[polygon][vertex] = splitCount;
            splitCount++;
          }
        }
      }
    }

    const positions = this.getVertexAttribute('positions');
    const numUnSplitVertices = positions.length;
    const totalNumVertices = numUnSplitVertices + splitCount;

    let indices;
    if (!opts || opts.includeIndices != false) {
      indices = this.generateTriangulatedIndices(totalNumVertices, numUnSplitVertices, splitIndices);
    }

    // let maxIndex;
    // if (debugAttrValues)
    //     maxIndex = Math.max(...indices);
    const attrBuffers = {};
    for (const [attrName, attr] of this.__vertexAttributes) {
      let values;
      if (splitCount == 0) values = attr.data;
      else values = attr.generateSplitValues(splitIndices, splitCount);

      const dimension = attr.numElements;
      const count = values.length / dimension;

      // if (debugAttrValues) {
      //     if (count <= maxIndex)
      //         console.warn("Invalid indexing. Attr value is insufficient for indexing:" + attrName + ". Max Index:" + maxIndex + " Attr Size:" + count);
      // }

      attrBuffers[attrName] = {
        values: values,
        count: count,
        dimension: dimension,
        normalized: attrName == 'normals',
        dataType: attr.dataType,
      };
    }

    const result = {
      numVertices: this.numVertices(),
      numRenderVerts: totalNumVertices,
      indices,
      attrBuffers,
    };

    if (opts && opts.includeVertexNeighbors) {
      if (this.vertexEdges == undefined) this.genTopologyInfo();

      let count = 0;
      for (let i = 0; i < this.vertexEdges.length; i++) {
        // If this face indexing doesn't start at 0, then the vertexEdges don't either.
        if (this.vertexEdges[i]) count += this.vertexEdges[i].size;
      }
      // The array will be structured as a start+offset for each vertex, followed
      // by a 2d array of neighbor indices.
      const vertexNeighbors = new Uint32Array(this.vertexEdges.length * 2 + count);

      const sortFanEdges = (fanEdges) => {
        for (let i = 0; i < fanEdges.length; i++) {
          const feA = fanEdges[i];
          for (let j = 0; j < i; j++) {
            const feB = fanEdges[j];
            if (feA[0] != -1 && feA[0] == feB[1]) {
              //  move feA after feB;
              if (i != j + 1) {
                fanEdges.splice(i, 1);
                fanEdges.splice(j + 1, 0, feA);
              }
              break
            }
            if (feA[1] != -1 && feA[1] == feB[0]) {
              //  move feA before feB;
              fanEdges.splice(i, 1);
              fanEdges.splice(j, 0, feA);
              break
            }
          }
        }
      };

      const checkFanEdges = (fanEdges) => {
        // now check that the faces all build a fan. Maybe starting and ending with -1
        if (fanEdges[0][0] == -1 || fanEdges[fanEdges.length - 1][1] == -1) {
          if (fanEdges[0][0] != -1 || fanEdges[fanEdges.length - 1][1] != -1) {
            throw new Error('If fan starts with -1, it must also end with -1')
          }
        }
        for (let i = 0; i < fanEdges.length; i++) {
          const fe = fanEdges[i];
          if (fe[0] == -1 || fe[1] == -1) {
            if (i != 0 && i != fanEdges.length - 1) {
              throw new Error('-1 only allowed at the beginning and end of a fan.')
            }
          }
          if (fe[0] != -1) {
            let prev = i - 1;
            if (prev < 0) prev += fanEdges.length;
            if (fe[0] != fanEdges[prev][1]) {
              throw new Error('Faces are not sequential')
            }
          }
          if (fe[1] != -1) {
            const next = (i + 1) % fanEdges.length;
            if (fe[1] != fanEdges[next][0]) {
              throw new Error('Faces are not sequential')
            }
          }
        }
      };

      // Populate the start and offset values.
      let offset = this.vertexEdges.length * 2;
      for (let i = 0; i < this.vertexEdges.length; i++) {
        if (this.vertexEdges[i] == undefined) continue
        const edges = this.vertexEdges[i];

        // Build a sorted list of faces based on a fan around
        // the vertex.
        const fanEdges = [];
        for (const e of edges) {
          const v0 = this.edgeVerts[e * 2];
          const v1 = this.edgeVerts[e * 2 + 1];
          let f0 = this.edgeFaces[e * 2];
          let f1 = this.edgeFaces[e * 2 + 1];
          let neigVert;
          if (v0 == i) {
            neigVert = v1;
          } else if (v1 == i) {
            neigVert = v0;
            // swap the faces
            const tmp = f0;
            f0 = f1;
            f1 = tmp;
          } else {
            throw new Error('Invalid topology')
          }
          fanEdges.push([f0, f1, neigVert]);
        }
        sortFanEdges(fanEdges);
        checkFanEdges(fanEdges);
        const closed = fanEdges[0][0] != -1 || fanEdges[fanEdges.length - 1][1] != -1;
        let flags = 0;
        if (closed) flags += 1;
        vertexNeighbors[i * 2] = offset;
        vertexNeighbors[i * 2 + 1] = edges.size + (flags << 8);
        for (const fe of fanEdges) {
          vertexNeighbors[offset] = fe[2];
          offset++;
        }
      }

      result.vertexNeighbors = vertexNeighbors;
    }

    return result
  }

  /**
   * Compute the number of triangles. For higher degree polygons, they are divided into multiple triangles for rendering.
   * @return {number} - Returns the number of triangles.
   */
  computeNumTriangles() {
    let numVertsPerFace = 3;
    let trisCount = 0;
    for (const fc of this.__faceCounts) {
      trisCount += fc * (numVertsPerFace - 2);
      numVertsPerFace++;
    }
    return trisCount
  }

  /**
   * To prepare data for rendering, the indices for the polygons is used to compute a new index buffer based on
   * only triangles. This is used during rendering and the resulting indices uploaded ot the GPU  by GLMesh class.
   *
   * @param {number} totalNumVertices - The total number of vertices.
   * @param {number} numUnSplitVertices - The total number of unsplit vertices.
   * @param {array} splitIndices - The splitIndices value.
   * @return {TypedArray} - Retures a typed array containing the triangulated indices.
   */
  generateTriangulatedIndices(totalNumVertices, numUnSplitVertices, splitIndices) {
    const trisCount = this.computeNumTriangles();

    let trianglulatedIndices;
    if (totalNumVertices < Math.pow(2, 8)) trianglulatedIndices = new Uint8Array(trisCount * 3);
    else if (totalNumVertices < Math.pow(2, 16)) trianglulatedIndices = new Uint16Array(trisCount * 3);
    else trianglulatedIndices = new Uint32Array(trisCount * 3);

    let triangleVertex = 0;
    const addTriangleVertexIndex = function (vertex, faceIndex) {
      if (vertex in splitIndices && faceIndex in splitIndices[vertex])
        vertex = numUnSplitVertices + splitIndices[vertex][faceIndex];
      trianglulatedIndices[triangleVertex] = vertex;
      triangleVertex++;
    };
    const numFaces = this.getNumFaces();
    for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
      const faceVerts = this.getFaceVertexIndices(faceIndex);
      for (let j = 0; j < faceVerts.length; j++) {
        if (j >= 3) {
          // For each aditional triangle, we have to add 2 indices.
          addTriangleVertexIndex(faceVerts[0], faceIndex);
          addTriangleVertexIndex(faceVerts[j - 1], faceIndex);
        }
        addTriangleVertexIndex(faceVerts[j], faceIndex);
      }
    }
    return trianglulatedIndices
  }

  /**
   * The freeBuffers method.
   */
  freeBuffers() {
    super.freeBuffers();
    this.init();
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Restores mesh properties from a binary reader.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.loadBaseGeomBinary(reader);
    this.setFaceCounts(reader.loadUInt32Array());

    // Note: we can remove this. We can infer this from the above faceCounts array.
    const faceVertexCounts = reader.loadUInt8Array(this.getNumFaces());
    const offsetRange = reader.loadSInt32Vec2();
    const bytes = reader.loadUInt8();
    let faceVertexIndexDeltas;
    if (bytes == 1) faceVertexIndexDeltas = reader.loadUInt8Array();
    else if (bytes == 2) faceVertexIndexDeltas = reader.loadUInt16Array();
    else if (bytes == 4) faceVertexIndexDeltas = reader.loadUInt32Array();

    const numFaces = this.getNumFaces();
    let offset = 0;
    let prevCount = 0;
    let faceOffsets = [];
    for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
      const count = this.getFaceVertexCount(faceIndex);
      faceOffsets[faceIndex] = offset;
      for (let j = 0; j < count; j++) {
        const faceVertex = offset + j;
        const delta = faceVertexIndexDeltas[faceVertex] + offsetRange.x;
        if (faceIndex == 0) this.__faceVertexIndices[faceVertex] = delta;
        else {
          let prevFaceVertex = faceOffsets[faceIndex - 1];
          prevFaceVertex += j < prevCount ? j : prevCount - 1;
          this.__faceVertexIndices[faceVertex] = this.__faceVertexIndices[prevFaceVertex] + delta;
        }
      }
      offset += count;
      prevCount = count;
    }
    this.__numPopulatedFaceVertexIndices = offset;

    if (!this.hasVertexAttribute('normals')) {
      this.computeVertexNormals();
    }

    // this.computeVertexNormals();
    this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    j.faceCounts = Array.from(this.__faceCounts);
    j.faceVertexIndices = Array.from(this.__faceVertexIndices);

    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);
    if (j.faceCounts) this.__faceCounts = j.faceCounts;
    if (j.faceVertexIndices) this.__faceVertexIndices = Uint32Array.from(j.faceVertexIndices);
  }
}

Registry.register('Mesh', Mesh);

/** Class representing a base geometry proxy.
 * @extends EventEmitter
 * @private
 */
class BaseProxy extends EventEmitter {
  /**
   * Create a base proxy.
   * @param {any} data - The data value.
   */
  constructor(data) {
    super();
    this.name = data.name;
    this.__buffers = data.geomBuffers;
    if (this.__buffers.attrBuffers) {
      // eslint-disable-next-line guard-for-in
      for (const attrName in this.__buffers.attrBuffers) {
        const attrData = this.__buffers.attrBuffers[attrName];
        const dataType = Registry.getBlueprint(attrData.dataType);
        attrData.dataType = dataType;
      }
    }

    this.boundingBox = new Box3$1();
    this.boundingBox.p0.__data = data.bbox.p0.__data;
    this.boundingBox.p1.__data = data.bbox.p1.__data;

    this.__metaData = new Map();
  }

  /**
   * The genBuffers method.
   * @return {any} - The return value.
   */
  genBuffers() {
    return this.__buffers
  }

  /**
   * The freeBuffers method.
   */
  freeBuffers() {
    // Note: Explicitly transfer data to a web worker and then
    // terminate the worker. (hacky way to free TypedArray memory explicitly)
    const freeData = { attrBuffers: {} };
    const transferables = [];
    if (this.__buffers.indices) {
      transferables.push(this.__buffers.indices.buffer);
      freeData.indices = this.__buffers.indices;
      delete this.__buffers.indices;
    }
    if (this.__buffers.attrBuffers) {
      for (const attrName in this.__buffers.attrBuffers) {
        const attrData = this.__buffers.attrBuffers[attrName];
        freeData.attrBuffers[attrName] = this.__buffers.attrBuffers[attrName];
        transferables.push(attrData.values.buffer);
        delete this.__buffers.attrBuffers[attrName];
      }
      delete this.__buffers.attrBuffers;
    }
  }

  // ////////////////////////////////////////
  // Metadata

  /**
   * The getMetadata method.
   * @param {any} key - The key value.
   * @return {any} - The return value.
   */
  getMetadata(key) {
    return this.__metaData.get(key)
  }

  /**
   * The hasMetadata method.
   * @param {any} key - The key value.
   * @return {any} - The return value.
   */
  hasMetadata(key) {
    return this.__metaData.has(key)
  }

  /**
   * The setMetadata method.
   * @param {any} key - The key value.
   * @param {object} metaData - The metaData value.
   */
  setMetadata(key, metaData) {
    this.__metaData.set(key, metaData);
  }
}

/** Class representing a points proxy.
 * @extends BaseProxy
 * @private
 */
class PointsProxy extends BaseProxy {
  /**
   * Create a points proxy.
   * @param {any} data - The data value.
   */
  constructor(data) {
    super(data);
  }
}

/** Class representing a lines proxy.
 * @extends BaseProxy
 * @private
 */
class LinesProxy extends BaseProxy {
  /**
   * Create a lines proxy.
   * @param {any} data - The data value.
   */
  constructor(data) {
    super(data);
  }
}

/** Class representing a mesh proxy.
 * @extends BaseProxy
 * @private
 */
class MeshProxy extends BaseProxy {
  /**
   * Create a mesh proxy.
   * @param {any} data - The data value.
   */
  constructor(data) {
    super(data);
  }
}

/**
 * Represents an ordered grid of points along `X` and `Y` axes.
 *
 * ```
 * const pointGrid = new PointGrid(2.2, 1.5, 12, 12)
 * ```
 *
 * @extends Points
 */
class PointGrid extends Points {
  /**
   * Creates an instance of PointGrid.
   *
   * @param {number} [x=1.0] - The length of the point grid along the X axis.
   * @param {number} [y=1.0] - The length of the point grid along the Y axis.
   * @param {number} [xDivisions=1] - The number of divisions along the X axis.
   * @param {number} [yDivisions=1] - The number of divisions along the Y axis.
   * @param {boolean} [addTextureCoords=false] - The addTextureCoords value.
   */
  constructor(x = 1.0, y = 1.0, xDivisions = 1, yDivisions = 1, addTextureCoords = false) {
    super();

    if (isNaN(x) || isNaN(y) || isNaN(xDivisions) || isNaN(yDivisions)) throw new Error('Invalid geom args')

    this.__x = x;
    this.__y = y;
    this.__xDivisions = xDivisions;
    this.__yDivisions = yDivisions;
    if (addTextureCoords) this.addVertexAttribute('texCoords', Vec2);
    this.__rebuild();
  }

  /**
   * Getter for X.
   * Is deprecated. Please use "getX".
   *
   * @deprecated
   * @return {number} - Returns the length.
   */
  get x() {
    console.warn("getter is deprecated. Please use 'getX'");
    return this.getX()
  }

  /**
   * Setter for X.
   * Is deprecated. Please use "setX".
   *
   * @deprecated
   * @param {number} val - The length along the X axis.
   */
  set x(val) {
    console.warn("getter is deprecated. Please use 'setX'");
    this.setX(val);
  }

  /**
   * Getter for Y.
   * Is deprecated. Please use "getY".
   *
   * @deprecated
   * @return {number} - Returns the length.
   */
  get y() {
    console.warn("getter is deprecated. Please use 'getY'");
    return this.getY()
  }

  /**
   * Setter for Y.
   * Is deprecated. Please use "setY".
   *
   * @deprecated
   * @param {number} val - The length along the Y axis.
   */
  set y(val) {
    console.warn("getter is deprecated. Please use 'setY'");
    this.setY(val);
  }

  /**
   * Getter for the length of the point grid along the `X` axis.
   *
   * @return {number} - Returns the length.
   */
  getX() {
    return this.__x
  }

  /**
   * Setter for the length of the point grid along the `X` axis.
   *
   * @param {number} val - The length along the `X` axis.
   */
  setX(val) {
    this.__x = val;
    this.__resize();
  }

  /**
   * Getter for the length of the point grid along the `Y` axis.
   *
   * @return {number} - Returns the length.
   */
  getY() {
    return this.__y
  }

  /**
   * Setter for the length of the point grid along the `Y` axis.
   *
   * @param {number} val - The length along the Y axis.
   */
  setY(val) {
    this.__y = val;
    this.__resize();
  }

  /**
   * Setter for the size of the point grid.
   *
   * @param {number} x - The length along the `X` axis.
   * @param {number} y - The length along the `Y` axis.
   */
  setSize(x, y) {
    this.__x = x;
    this.__y = y;
    this.__resize();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.setNumVertices(this.__xDivisions * this.__yDivisions);

    const texCoords = this.getVertexAttribute('texCoords');
    if (texCoords) {
      for (let i = 0; i < this.__yDivisions; i++) {
        const y = i / (this.__yDivisions - 1);
        for (let j = 0; j < this.__xDivisions; j++) {
          const x = j / (this.__xDivisions - 1);
          texCoords.getValueRef(i * this.__xDivisions + j).set(x, y);
        }
      }
    }
    this.__resize(false);
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @param {number} emit - emit a 'geomDataChanged' event.
   * @private
   */
  __resize(emit = true) {
    const positions = this.getVertexAttribute('positions');
    for (let i = 0; i < this.__yDivisions; i++) {
      const y = (i / (this.__yDivisions - 1) - 0.5) * this.__y;
      for (let j = 0; j < this.__xDivisions; j++) {
        const x = (j / (this.__xDivisions - 1) - 0.5) * this.__x;
        positions.getValueRef(i * this.__xDivisions + j).set(x, y, 0.0);
      }
    }
    this.setBoundingBoxDirty();
    if (emit) this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['x'] = this.__x;
    json['y'] = this.__y;
    json['xDivisions'] = this.__xDivisions;
    json['yDivisions'] = this.__yDivisions;
    return json
  }
}

/**
 * A class for generating a rectangle shape.
 *
 * ```
 * const rect = new Rect(1.5, 2.0)
 * ```
 *
 * **Parameters**
 * * **x(`NumberParameter`):** Length of the rectangle along the `X` axis.
 * * **y(`NumberParameter`):** Length of the rectangle along the `Y` axis.
 *
 *
 * @extends Lines
 */
class Rect extends Lines {
  /**
   * Create a rect.
   * @param {number} x - The length of the rect along the `X` axis.
   * @param {number} y - The length of the rect along the `Y` axis.
   */
  constructor(x = 1.0, y = 1.0) {
    super();

    if (isNaN(x) || isNaN(y)) throw new Error('Invalid geom args')

    this.__x = this.addParameter(new NumberParameter('x', x));
    this.__x.on('valueChanged', this.__resize.bind(this));
    this.__y = this.addParameter(new NumberParameter('y', y));
    this.__y.on('valueChanged', this.__resize.bind(this));
    this.__rebuild();
  }

  /**
   * Getter for the length of the rect along the `X` axis.
   *
   * @return {number} - Returns the length.
   */
  get x() {
    return this.__x.getValue()
  }

  /**
   * Setter for the length of the rect along the `X` axis.
   *
   * @param {number} val - The length along the `X` axis.
   */
  set x(val) {
    this.__x.setValue(val);
  }

  /**
   * Getter for the length of the rect along the `Y` axis.
   *
   * @return {number} - Returns the length.
   */
  get y() {
    return this.__y.getValue()
  }

  /**
   * Setter for the length of the rect along the U axis.
   *
   * @param {number} val - The length along the `Y` axis.
   */
  set y(val) {
    this.__y.setValue(val);
  }

  /**
   * Setter for the size of the rect.
   *
   * @param {number} x - The length along the `X` axis.
   * @param {number} y - The length along the `Y` axis.
   */
  setSize(x, y) {
    this.__x.setValue(x, -1);
    this.__y.setValue(y, -1);
    this.__resize();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.setNumVertices(4);
    this.setNumSegments(4);
    this.setSegmentVertexIndices(0, 0, 1);
    this.setSegmentVertexIndices(1, 1, 2);
    this.setSegmentVertexIndices(2, 2, 3);
    this.setSegmentVertexIndices(3, 3, 0);
    this.__resize(false);
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @param {number} emit - emit a 'geomDataChanged' event.
   * @private
   */
  __resize(emit) {
    const x = this.__x.getValue();
    const y = this.__y.getValue();

    const positions = this.getVertexAttribute('positions');
    positions.getValueRef(0).set(-0.5 * x, -0.5 * y, 0.0);
    positions.getValueRef(1).set(0.5 * x, -0.5 * y, 0.0);
    positions.getValueRef(2).set(0.5 * x, 0.5 * y, 0.0);
    positions.getValueRef(3).set(-0.5 * x, 0.5 * y, 0.0);
    this.setBoundingBoxDirty();
    if (emit) this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['x'] = this.__x;
    json['y'] = this.__y;
    return json
  }
}

Registry.register('Rect', Rect);

/**
 * A class for generating a circle shape using line segments.
 *
 * ```
 * const circle = new Circle(2.2, 12)
 * ```
 *
 * **Parameters**
 * * **Radius(`NumberParameter`):** Radius of the circle.
 * * **Angle(`NumberParameter`):** Number of segments used to build the circle.
 * * **NumSegments(`NumberParameter`):** Segments angle in radiants.
 *
 * @extends Lines
 */
class Circle extends Lines {
  /**
   * Creates an instance of Circle.
   * @param {number} radius - The radius of the circle.
   * @param {number} numSegments - The number of segments.
   * @param {number} angle - Arc segments angle(radians)
   */
  constructor(radius = 1.0, numSegments = 32, angle = Math.PI * 2) {
    super();

    if (isNaN(radius) || isNaN(numSegments)) throw new Error('Invalid geom args')

    this.__radius = this.addParameter(new NumberParameter('Radius', radius));
    this.__angle = this.addParameter(new NumberParameter('Angle', angle));
    this.__numSegments = this.addParameter(
      new NumberParameter('NumSegments', numSegments >= 3 ? numSegments : 3, [3, 200], 1)
    );

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__radius.on('valueChanged', resize);
    this.__angle.on('valueChanged', rebuild);
    this.__numSegments.on('valueChanged', rebuild);
    this.__rebuild();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const segs = this.__numSegments.getValue();
    this.setNumVertices(segs);
    const arc = this.__angle.getValue() < Math.PI * 2;
    if (arc) this.setNumSegments(segs - 1);
    else this.setNumSegments(segs);
    for (let i = 0; i < (arc ? segs - 1 : segs); i++) this.setSegmentVertexIndices(i, i, (i + 1) % segs);
    this.__resize(false);
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @param {boolean} emit - The emit value.
   * @private
   */
  __resize(emit) {
    const radius = this.__radius.getValue();
    const segs = this.__numSegments.getValue();
    const step = this.__angle.getValue() / segs;
    const positions = this.getVertexAttribute('positions');
    for (let i = 0; i < segs; i++) {
      positions.getValueRef(i).set(Math.cos(step * i) * radius, Math.sin(step * i) * radius, 0.0);
    }
    this.setBoundingBoxDirty();
    if (emit) this.emit('geomDataChanged', {});
  }
}

Registry.register('Circle', Circle);

/**
 * A class for generating a cross shape, drawing a line on the `X,Y,Z` axes.
 * The axis line length is the `size` you specify, but the middle of the line is positioned in the coordinate `(0, 0, 0)` .
 * Meaning that half of the line goes negative and half goes positive.
 *
 * ```
 * const cross = new Cross(1.5)
 * ```
 *
 * **Parameters**
 * * **size(`NumberParameter`):** Specifies the size of the cross.
 *
 * @extends Lines
 */
class Cross extends Lines {
  /**
   * Create a cross.
   * @param {number} size - The size of the cross.
   */
  constructor(size = 1.0) {
    super();

    if (isNaN(size)) throw new Error('Invalid geom args')

    this.__sizeParam = this.addParameter(new NumberParameter('size', size));
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    this.__sizeParam.on('valueChanged', resize);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.setNumVertices(6);
    this.setNumSegments(3);
    this.setSegmentVertexIndices(0, 0, 1);
    this.setSegmentVertexIndices(1, 2, 3);
    this.setSegmentVertexIndices(2, 4, 5);
    this.__resize();
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const size = this.__sizeParam.getValue();
    const positions = this.getVertexAttribute('positions');
    positions.getValueRef(0).set(-0.5 * size, 0, 0);
    positions.getValueRef(1).set(0.5 * size, 0, 0);
    positions.getValueRef(2).set(0, 0.5 * size, 0);
    positions.getValueRef(3).set(0, -0.5 * size, 0);
    positions.getValueRef(4).set(0, 0, 0.5 * size);
    positions.getValueRef(5).set(0, 0, -0.5 * size);
    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }
}

Registry.register('Cross', Cross);

/**
 * A class for generating a lines cuboid shape(Without faces).
 *
 * **Parameters**
 * * **x(`NumberParameter`):** Length of the line cuboid along the `X` axis
 * * **y(`NumberParameter`):** Length of the line cuboid along the `Y` axis
 * * **z(`NumberParameter`):** Length of the line cuboid along the `Z` axis
 * * **BaseZAtZero(`NumberParameter`):** Property to start or not `Z` axis from position `0.
 *
 * @extends Lines
 */
class LinesCuboid extends Lines {
  /**
   * Create a lines cuboid.
   * @param {number} x - The length of the line cuboid along the X axis.
   * @param {number} y - The length of the line cuboid along the Y axis.
   * @param {number} z - The length of the line cuboid along the Z axis.
   * @param {boolean} baseZAtZero - The baseZAtZero value.
   */
  constructor(x = 1.0, y = 1.0, z = 1.0, baseZAtZero = false) {
    super();

    this.__x = this.addParameter(new NumberParameter('x', x));
    this.__y = this.addParameter(new NumberParameter('y', y));
    this.__z = this.addParameter(new NumberParameter('z', z));

    this.__baseZAtZero = this.addParameter(new NumberParameter('BaseZAtZero', baseZAtZero));
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__x.on('valueChanged', resize);
    this.__y.on('valueChanged', resize);
    this.__z.on('valueChanged', resize);
    this.__baseZAtZero.on('valueChanged', rebuild);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.setNumVertices(8);
    this.setNumSegments(12);
    this.setSegmentVertexIndices(0, 0, 1);
    this.setSegmentVertexIndices(1, 1, 2);
    this.setSegmentVertexIndices(2, 2, 3);
    this.setSegmentVertexIndices(3, 3, 0);

    this.setSegmentVertexIndices(4, 4, 5);
    this.setSegmentVertexIndices(5, 5, 6);
    this.setSegmentVertexIndices(6, 6, 7);
    this.setSegmentVertexIndices(7, 7, 4);

    this.setSegmentVertexIndices(8, 0, 4);
    this.setSegmentVertexIndices(9, 1, 5);
    this.setSegmentVertexIndices(10, 2, 6);
    this.setSegmentVertexIndices(11, 3, 7);
    this.__resize(false);
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const x = this.__x.getValue();
    const y = this.__y.getValue();
    const z = this.__z.getValue();
    const baseZAtZero = this.__baseZAtZero.getValue();

    const positions = this.getVertexAttribute('positions');
    let zoff = 0.5;
    if (baseZAtZero) zoff = 1.0;
    positions.getValueRef(0).set(0.5 * x, -0.5 * y, zoff * z);
    positions.getValueRef(1).set(0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(2).set(-0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(3).set(-0.5 * x, -0.5 * y, zoff * z);

    zoff = -0.5;
    if (baseZAtZero) zoff = 0.0;
    positions.getValueRef(4).set(0.5 * x, -0.5 * y, zoff * z);
    positions.getValueRef(5).set(0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(6).set(-0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(7).set(-0.5 * x, -0.5 * y, zoff * z);

    this.setBoundingBoxDirty();
    if (emit) this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['size'] = this.__size;
    return json
  }
}

Registry.register('LinesCuboid', LinesCuboid);

/**
 * Represents a network of lines that cross each other to form a series of squares or rectangles.
 *
 * ```
 * const grid = new Grid(5, 5, 50, 50, true)
 * ```
 *
 * **Parameters**
 * * **x(`NumberParameter`):** Length of the grid along the `X` axis.
 * * **y(`NumberParameter`):** Length of the grid along the `Y` axis.
 * * **xDivisions(`NumberParameter`):** Number of divisions along `X` axis
 * * **yDivisions(`NumberParameter`):** Number of divisions along `Y` axis
 * * **skipCenterLines(`BooleanParameter`):** Property that indicates whether to display the center grid lines or not
 *
 * @extends Lines
 */
class Grid extends Lines {
  /**
   * Create a grid.
   * @param {number} x - The length of the grid along the `X` axis.
   * @param {number} y - The length of the grid along the `Y` axis.
   * @param {number} xDivisions - The number of divisions along `X` axis.
   * @param {number} yDivisions - The number of divisions along `Y` axis.
   * @param {boolean} skipCenterLines - A boolean indicating whether to display the center grid lines or not.
   */
  constructor(x = 1.0, y = 1.0, xDivisions = 10, yDivisions = 10, skipCenterLines = false) {
    super();

    if (isNaN(x) || isNaN(y) || isNaN(xDivisions) || isNaN(yDivisions)) throw new Error('Invalid geom args')

    this.__xParam = this.addParameter(new NumberParameter('x', x));
    this.__yParam = this.addParameter(new NumberParameter('y', y));
    this.__xDivisionsParam = this.addParameter(new NumberParameter('xDivisions', xDivisions));
    this.__yDivisionsParam = this.addParameter(new NumberParameter('yDivisions', yDivisions));
    this.__skipCenterLinesParam = this.addParameter(new BooleanParameter('skipCenterLines', skipCenterLines));

    this.__rebuild();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const xDivisions = this.__xDivisionsParam.getValue();
    const yDivisions = this.__yDivisionsParam.getValue();

    const skipCenterLines = this.__skipCenterLinesParam.getValue() && xDivisions % 2 == 0 && yDivisions % 2 == 0;
    this.setNumVertices((xDivisions + yDivisions + 2 - (skipCenterLines ? 1 : 0)) * 2);
    this.setNumSegments(xDivisions + yDivisions + 2 - (skipCenterLines ? 1 : 0));
    let idx = 0;
    for (let i = 0; i <= xDivisions; i++) {
      if (skipCenterLines && i == xDivisions / 2) continue
      const v0 = idx * 2;
      const v1 = idx * 2 + 1;
      this.setSegmentVertexIndices(idx, v0, v1);
      idx++;
    }
    for (let i = 0; i <= yDivisions; i++) {
      if (skipCenterLines && i == xDivisions / 2) continue
      const v0 = idx * 2;
      const v1 = idx * 2 + 1;
      this.setSegmentVertexIndices(idx, v0, v1);
      idx++;
    }
    this.__resize();
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const positions = this.getVertexAttribute('positions');
    const xDivisions = this.__xDivisionsParam.getValue();
    const yDivisions = this.__yDivisionsParam.getValue();
    const xSize = this.__xParam.getValue();
    const ySize = this.__yParam.getValue();

    const skipCenterLines = this.__skipCenterLinesParam.getValue() && xDivisions % 2 == 0 && yDivisions % 2 == 0;
    let idx = 0;
    for (let i = 0; i <= xDivisions; i++) {
      if (skipCenterLines && i == xDivisions / 2) continue
      const v0 = idx * 2;
      const v1 = idx * 2 + 1;
      const x = (i / xDivisions - 0.5) * xSize;
      positions.getValueRef(v0).set(x, -0.5 * ySize, 0.0);
      positions.getValueRef(v1).set(x, 0.5 * ySize, 0.0);
      idx++;
    }
    for (let i = 0; i <= yDivisions; i++) {
      if (skipCenterLines && i == xDivisions / 2) continue
      const v0 = idx * 2;
      const v1 = idx * 2 + 1;
      const y = (i / yDivisions - 0.5) * ySize;
      positions.getValueRef(v0).set(-0.5 * xSize, y, 0.0);
      positions.getValueRef(v1).set(0.5 * xSize, y, 0.0);
      idx++;
    }

    this.setBoundingBoxDirty();
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['x'] = this.__x;
    json['z'] = this.__y;
    json['xDivisions'] = this.__xDivisions;
    json['yDivisions'] = this.__yDivisions;
    return json
  }
}

Registry.register('Grid', Grid);

/* eslint-disable no-unused-vars */

/**
 * Represents a cone geometry.
 *
 * ```
 * const cone = new Cone(1.2, 4.0)
 * ```
 *
 * **Parameters**
 * * **radius(`NumberParameter`):** Specifies the radius of the base of the cone.
 * * **height(`NumberParameter`):** Specifies the height of the cone.
 * * **detail(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
 * * **cap(`BooleanParameter`):** Specifies whether the base of the cone is capped or open.
 *
 * @extends Mesh
 */
class Cone extends Mesh {
  /**
   * Create a cone.
   * @param {number} radius - The radius of the base of the cone.
   * @param {number} height - The height of the cone.
   * @param {number} detail - The detail of the cone.
   * @param {boolean} cap -  A boolean indicating whether the base of the cone is capped or open.
   */
  constructor(radius = 0.5, height = 1.0, detail = 32, cap = true) {
    super();

    if (isNaN(radius) || isNaN(height) || isNaN(detail)) throw new Error('Invalid geom args')

    this.__radiusParam = this.addParameter(new NumberParameter('radius', radius));
    this.__heightParam = this.addParameter(new NumberParameter('height', height));
    this.__detailParam = this.addParameter(new NumberParameter('detail', detail >= 3 ? detail : 3, [3, 200], 1));
    this.__capParam = this.addParameter(new BooleanParameter('cap', cap));

    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__radiusParam.on('valueChanged', resize);
    this.__heightParam.on('valueChanged', resize);
    this.__detailParam.on('valueChanged', rebuild);
    this.__capParam.on('valueChanged', rebuild);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.clear();

    const nbSides = this.__detailParam.getValue();
    const radius = this.__radiusParam.getValue();
    const height = this.__heightParam.getValue();
    const cap = this.__capParam.getValue();
    let numVertices = nbSides + 1;
    if (cap) {
      numVertices += 1;
    }
    this.setNumVertices(numVertices);
    const tipPoint = nbSides;
    const basePoint = nbSides + 1;

    // ////////////////////////////
    // Set Vertex Positions
    const positions = this.getVertexAttribute('positions');

    positions.getValueRef(tipPoint).set(0.0, 0.0, height);
    for (let i = 0; i < nbSides; i++) {
      const theta = (i / nbSides) * 2.0 * Math.PI;
      positions.getValueRef(i).set(radius * Math.cos(theta), radius * Math.sin(theta), 0.0);
    }
    if (cap) {
      positions.getValueRef(basePoint).set(0.0, 0.0, 0.0);
    }

    // ////////////////////////////
    // Build the topology
    this.setFaceCounts([nbSides + (cap ? nbSides : 0)]);
    for (let i = 0; i < nbSides; i++) {
      const j = (i + 1) % nbSides;
      this.setFaceVertexIndices(i, [j, i, tipPoint]);
    }
    if (cap) {
      for (let i = 0; i < nbSides; i++) {
        const j = (i + 1) % nbSides;
        this.setFaceVertexIndices(nbSides + i, [i, j, basePoint]);
      }
    }

    // ////////////////////////////
    // setNormals
    const normals = this.getVertexAttribute('normals');

    let normalElevation;
    const divider = height;
    if (Math.abs(height) < 1.0e-12) normalElevation = height < 0 ? -1.0e-12 : 1.0e-12;
    normalElevation = radius / divider;

    let tri = 0;
    for (let i = 0; i < nbSides; i++) {
      const theta1 = ((i + 1) / nbSides) * 2.0 * Math.PI;
      const theta2 = (i / nbSides) * 2.0 * Math.PI;
      const theta = (theta1 + theta2) * 0.5;

      normals.setFaceVertexValue(tri, 0, new Vec3$1(Math.cos(theta1), normalElevation, Math.sin(theta1)).normalize());
      normals.setFaceVertexValue(tri, 1, new Vec3$1(Math.cos(theta2), normalElevation, Math.sin(theta2)).normalize());
      normals.setFaceVertexValue(tri, 2, new Vec3$1(Math.cos(theta), normalElevation, Math.sin(theta)).normalize());
      tri++;
    }
    if (cap) {
      const normal = new Vec3$1(0.0, -1.0, 0.0);
      for (let i = 0; i < nbSides; i++) {
        normals.setFaceVertexValue(tri, 0, normal);
        normals.setFaceVertexValue(tri, 1, normal);
        normals.setFaceVertexValue(tri, 2, normal);
        tri++;
      }
    }

    // ////////////////////////////
    // setUVs
    const texCoords = this.getVertexAttribute('texCoords');

    // Now set the attrbute values
    tri = 0;
    for (let i = 0; i < nbSides; i++) {
      texCoords.setFaceVertexValue(tri, 0, new Vec2((i + 1) / nbSides, 0.0));
      texCoords.setFaceVertexValue(tri, 1, new Vec2(i / nbSides, 0.0));
      texCoords.setFaceVertexValue(tri, 2, new Vec2((i + 0.5) / nbSides, 1.0));
    }
    if (cap) {
      for (let i = 0; i < nbSides; i++) {
        texCoords.setFaceVertexValue(tri, 0, new Vec2(i / nbSides, 0.0));
        texCoords.setFaceVertexValue(tri, 1, new Vec2((i + 1) / nbSides, 0.0));
        texCoords.setFaceVertexValue(tri, 2, new Vec2((i + 0.5) / nbSides, 1.0));
        tri++;
      }
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const nbSides = this.__detailParam.getValue();
    const radius = this.__radiusParam.getValue();
    const height = this.__heightParam.getValue();
    const cap = this.__capParam.getValue();

    const tipPoint = nbSides;
    const basePoint = nbSides + 1;

    const positions = this.getVertexAttribute('positions');
    positions.getValueRef(tipPoint).set(0.0, 0.0, height);
    for (let i = 0; i < nbSides; i++) {
      const theta = (i / nbSides) * 2.0 * Math.PI;
      positions.getValueRef(i).set(radius * Math.cos(theta), radius * Math.sin(theta), 0.0);
    }
    if (this.__cap) {
      positions.getValueRef(basePoint).set(0.0, 0.0, 0.0);
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }
}

Registry.register('Cone', Cone);

/**
 * A class for generating a cuboid geometry.
 *
 * **Parameters**
 * * **x(`NumberParameter`):** Length of the line cuboid along the `X` axis
 * * **y(`NumberParameter`):** Length of the line cuboid along the `Y` axis
 * * **z(`NumberParameter`):** Length of the line cuboid along the `Z` axis
 * * **BaseZAtZero(`NumberParameter`):** Property to start or not `Z` axis from position `0.
 *
 * @extends Mesh
 */
class Cuboid extends Mesh {
  /**
   * Create a cuboid.
   * @param {number} x - The length of the cuboid along the X axis.
   * @param {number} y - The length of the cuboid along the Y axis.
   * @param {number} z - The length of the cuboid along the Z axis.
   * @param {boolean} baseZAtZero - The baseZAtZero value.
   */
  constructor(x = 1.0, y = 1.0, z = 1.0, baseZAtZero = false) {
    super();

    if (isNaN(x) || isNaN(y) || isNaN(z)) throw new Error('Invalid geom args')

    this.__xParam = this.addParameter(new NumberParameter('x', x));
    this.__yParam = this.addParameter(new NumberParameter('y', y));
    this.__zParam = this.addParameter(new NumberParameter('z', z));
    this.__baseZAtZeroParam = this.addParameter(new BooleanParameter('baseZAtZero', baseZAtZero));

    this.setFaceCounts([0, 6]);
    this.setFaceVertexIndices(0, [0, 1, 2, 3]);
    this.setFaceVertexIndices(1, [7, 6, 5, 4]);

    this.setFaceVertexIndices(2, [1, 0, 4, 5]);
    this.setFaceVertexIndices(3, [3, 2, 6, 7]);

    this.setFaceVertexIndices(4, [0, 3, 7, 4]);
    this.setFaceVertexIndices(5, [2, 1, 5, 6]);
    this.setNumVertices(8);
    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    this.__xParam.on('valueChanged', resize);
    this.__yParam.on('valueChanged', resize);
    this.__zParam.on('valueChanged', resize);
    this.__baseZAtZeroParam.on('valueChanged', resize);
  }

  /**
   * Setter for the size of the cuboid.
   *
   * @param {number} x - The length of the edges along the X axis.
   * @param {number} y - The length of the edges along the Y axis.
   * @param {number} z - The length of the edges along the Z axis.
   */
  setSize(x, y, z) {
    this.__xParam.setValue(x);
    this.__yParam.setValue(y);
    this.__zParam.setValue(z);
  }

  /**
   * Setter for the base size of the cuboid.
   *
   * @param {number} x - The length of the edges along the X axis.
   * @param {number} y - The length of the edges along the Y axis.
   */
  setBaseSize(x, y) {
    this.__xParam.setValue(x);
    this.__yParam.setValue(y);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const normals = this.getVertexAttribute('normals');
    for (let i = 0; i < 6; i++) {
      let normal;
      switch (i) {
        case 0:
          normal = new Vec3$1(0, 0, 1);
          break
        case 1:
          normal = new Vec3$1(0, 0, -1);
          break
        case 2:
          normal = new Vec3$1(1, 0, 0);
          break
        case 3:
          normal = new Vec3$1(-1, 0, 0);
          break
        case 4:
          normal = new Vec3$1(0, 1, 0);
          break
        case 5:
          normal = new Vec3$1(0, -1, 0);
          break
      }
      normals.setFaceVertexValue(i, 0, normal);
      normals.setFaceVertexValue(i, 1, normal);
      normals.setFaceVertexValue(i, 2, normal);
      normals.setFaceVertexValue(i, 3, normal);
    }
    const texCoords = this.getVertexAttribute('texCoords');
    for (let i = 0; i < 6; i++) {
      texCoords.setFaceVertexValue(i, 0, new Vec2(0, 0));
      texCoords.setFaceVertexValue(i, 1, new Vec2(1, 0));
      texCoords.setFaceVertexValue(i, 2, new Vec2(1, 1));
      texCoords.setFaceVertexValue(i, 3, new Vec2(0, 1));
    }
    this.__resize();
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const x = this.__xParam.getValue();
    const y = this.__yParam.getValue();
    const z = this.__zParam.getValue();
    const baseZAtZero = this.__baseZAtZeroParam.getValue();
    let zoff = 0.5;
    const positions = this.getVertexAttribute('positions');
    if (baseZAtZero) zoff = 1.0;
    positions.getValueRef(0).set(0.5 * x, -0.5 * y, zoff * z);
    positions.getValueRef(1).set(0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(2).set(-0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(3).set(-0.5 * x, -0.5 * y, zoff * z);

    zoff = -0.5;
    if (baseZAtZero) zoff = 0.0;
    positions.getValueRef(4).set(0.5 * x, -0.5 * y, zoff * z);
    positions.getValueRef(5).set(0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(6).set(-0.5 * x, 0.5 * y, zoff * z);
    positions.getValueRef(7).set(-0.5 * x, -0.5 * y, zoff * z);

    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['x'] = this.__x;
    json['y'] = this.__y;
    json['z'] = this.__z;
    return json
  }
}

Registry.register('Cuboid', Cuboid);

/**
 * A class for generating a cylinder geometry. It is very much like a cuboid but with `N` number of sides.
 *
 * ```
 * const cylinder = new Cylinder(1.5, 2.0, 6)
 * ```
 *
 * **Parameters**
 * * **radius(`NumberParameter`):** Specifies the radius of the cylinder.
 * * **height(`NumberParameter`):** Specifies the height of the cone.
 * * **sides(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
 * * **loops(`NumberParameter`):** Specifies the number of subdivisions(stacks) on the `Z` axis.
 * * **caps(`BooleanParameter`):** Specifies whether the ends of the cylinder are capped or open.
 * * **baseZAtZero(`BooleanParameter`):** Property to start or not `Z` axis from position `0.
 *
 * @extends Mesh
 */
class Cylinder extends Mesh {
  /**
   * Create a cylinder.
   * @param {number} radius - The radius of the cylinder.
   * @param {number} height - The height of the cylinder.
   * @param {number} sides - The number of sides.
   * @param {number} loops - The number of loops.
   * @param {boolean} caps - A boolean indicating whether the ends of the cylinder are capped or open.
   * @param {boolean} baseZAtZero - The baseZAtZero value.
   */
  constructor(radius = 0.5, height = 1.0, sides = 32, loops = 2, caps = true, baseZAtZero = false) {
    super();

    if (isNaN(radius) || isNaN(height) || isNaN(sides) || isNaN(loops)) throw new Error('Invalid geom args')

    this.__radiusParam = this.addParameter(new NumberParameter('radius', radius));
    this.__heightParam = this.addParameter(new NumberParameter('height', height));
    this.__sidesParam = this.addParameter(new NumberParameter('sides', sides >= 3 ? sides : 3, [3, 200], 1));
    this.__loopsParam = this.addParameter(new NumberParameter('loops', loops >= 2 ? loops : 2, [1, 200], 1));
    this.__capsParam = this.addParameter(new BooleanParameter('caps', caps));
    this.__baseZAtZeroParam = this.addParameter(new BooleanParameter('baseZAtZero', baseZAtZero));

    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__radiusParam.on('valueChanged', resize);
    this.__heightParam.on('valueChanged', resize);
    this.__sidesParam.on('valueChanged', rebuild);
    this.__loopsParam.on('valueChanged', rebuild);
    this.__capsParam.on('valueChanged', rebuild);
    this.__baseZAtZeroParam.on('valueChanged', resize);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    this.clear();

    const nbSides = this.__sidesParam.getValue();
    const nbLoops = this.__loopsParam.getValue();
    const caps = this.__capsParam.getValue();

    let numVertices = nbSides * nbLoops;
    if (caps) {
      numVertices += 2;
    }
    this.setNumVertices(numVertices);
    if (caps) this.setFaceCounts([nbSides * 2, nbSides]);
    else this.setFaceCounts([0, nbSides]);

    // ////////////////////////////
    // Build the topology
    let faceIndex = 0;

    if (caps) {
      // Bottom caps topology
      for (let j = 0; j < nbSides; j++) {
        const v0 = numVertices - 1;
        const v1 = j;
        const v2 = (j + 1) % nbSides;
        this.setFaceVertexIndices(faceIndex++, [v0, v1, v2]);
      }
      // Top caps topology
      for (let j = 0; j < nbSides; j++) {
        const v0 = nbSides * (nbLoops - 1) + j;
        const v1 = numVertices - 2;
        const v2 = nbSides * (nbLoops - 1) + ((j + 1) % nbSides);
        this.setFaceVertexIndices(faceIndex++, [v0, v1, v2]);
      }
    }

    // build the topology for the body of the cylinder
    for (let i = 0; i < nbLoops - 1; i++) {
      for (let j = 0; j < nbSides; j++) {
        const v0 = nbSides * i + ((j + 1) % nbSides);
        const v1 = nbSides * i + j;
        const v2 = nbSides * (i + 1) + j;
        const v3 = nbSides * (i + 1) + ((j + 1) % nbSides);
        this.setFaceVertexIndices(faceIndex++, [v0, v1, v2, v3]);
      }
    }

    // ////////////////////////////
    // setNormals
    const normals = this.getVertexAttribute('normals');

    // Now set the attribute values
    faceIndex = 0;
    if (caps) {
      const normal = new Vec3$1(0.0, 0.0, -1.0);
      for (let i = 0; i < nbSides; i++) {
        normals.setFaceVertexValue(faceIndex, 0, normal);
        normals.setFaceVertexValue(faceIndex, 1, normal);
        normals.setFaceVertexValue(faceIndex, 2, normal);
        faceIndex++;
      }
      normal.set(0.0, 0.0, 1.0);
      for (let i = 0; i < nbSides; i++) {
        normals.setFaceVertexValue(faceIndex, 0, normal);
        normals.setFaceVertexValue(faceIndex, 1, normal);
        normals.setFaceVertexValue(faceIndex, 2, normal);
        faceIndex++;
      }
    }
    for (let i = 0; i < nbLoops - 1; i++) {
      for (let j = 0; j < nbSides; j++) {
        let phi = (j / nbSides) * 2.0 * Math.PI;
        const normal1 = new Vec3$1(Math.sin(phi), Math.cos(phi), 0.0);
        normals.setFaceVertexValue(faceIndex, 0, normal1);
        normals.setFaceVertexValue(faceIndex, 1, normal1);

        phi = ((j + 1) / nbSides) * 2.0 * Math.PI;
        const normal2 = new Vec3$1(Math.sin(phi), Math.cos(phi), 0.0);
        normals.setFaceVertexValue(faceIndex, 2, normal2);
        normals.setFaceVertexValue(faceIndex, 3, normal2);
        faceIndex++;
      }
    }

    // ////////////////////////////
    // setUVs
    const texCoords = this.getVertexAttribute('texCoords');

    // Now set the attrbute values
    faceIndex = 0;
    if (caps) {
      for (let i = 0; i < nbSides; i++) {
        texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbSides, 0.0));
        texCoords.setFaceVertexValue(faceIndex, 1, new Vec2((i + 1) / nbSides, 0.0));
        texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 0.5) / nbSides, 1.0));
        faceIndex++;
      }
      for (let i = 0; i < nbSides; i++) {
        texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbSides, 0.0));
        texCoords.setFaceVertexValue(faceIndex, 1, new Vec2((i + 1) / nbSides, 0.0));
        texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 0.5) / nbSides, 1.0));
        faceIndex++;
      }
    }

    for (let i = 0; i < nbSides; i++) {
      texCoords.setFaceVertexValue(faceIndex, 0, new Vec2((i + 1) / nbSides, 0.0));
      texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 1) / nbSides, 1.0));
      texCoords.setFaceVertexValue(faceIndex, 1, new Vec2(i / nbSides, 0.0));
      texCoords.setFaceVertexValue(faceIndex, 3, new Vec2(i / nbSides, 1.0));
      faceIndex++;
    }

    this.emit('geomDataTopologyChanged', {});
    this.__resize();
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const nbSides = this.__sidesParam.getValue();
    const nbLoops = this.__loopsParam.getValue();
    const radius = this.__radiusParam.getValue();
    const height = this.__heightParam.getValue();
    const caps = this.__capsParam.getValue();
    const baseZAtZero = this.__baseZAtZeroParam.getValue();

    let numVertices = nbSides * nbLoops;
    if (caps) {
      numVertices += 2;
    }
    let vertex = 0;
    let zoff = 0.5;
    if (baseZAtZero) zoff = 0.0;

    const positions = this.getVertexAttribute('positions');
    for (let i = 0; i < nbLoops; i++) {
      const z = (i / (nbLoops - 1)) * height - height * zoff;
      for (let j = 0; j < nbSides; j++) {
        const phi = (j / nbSides) * 2.0 * Math.PI;
        positions.getValueRef(vertex).set(Math.sin(phi) * radius, Math.cos(phi) * radius, z);
        vertex++;
      }
    }
    if (caps) {
      positions.getValueRef(numVertices - 1).set(0.0, 0.0, height * (baseZAtZero ? 0.0 : -0.5));
      positions.getValueRef(numVertices - 2).set(0.0, 0.0, height * (baseZAtZero ? 1.0 : 0.5));
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }
}

Registry.register('Cylinder', Cylinder);

/**
 * A class for generating a disc geometry.
 *
 * ```
 * const disc = new Disc(2.0, 22)
 * ```
 *
 * **Parameters**
 * * **radius(`NumberParameter`):** Specifies the radius of the disc.
 * * **sides(`NumberParameter`):** Specifies the resolution, or the disc subdivisions around `Z` axis.
 *
 * @extends Mesh
 */
class Disc extends Mesh {
  /**
   * Creates an instance of Disc.
   *
   * @param {number} [radius=0.5] - The radius of the disc.
   * @param {number} [sides=32] - The number of sides.
   */
  constructor(radius = 0.5, sides = 32) {
    super();

    if (isNaN(radius) || isNaN(sides)) throw new Error('Invalid geom args')

    this.__radiusParam = this.addParameter(new NumberParameter('radius', radius));
    this.__sidesParam = this.addParameter(new NumberParameter('sides', sides >= 3 ? sides : 3, [3, 200], 1));

    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();
  }

  /**
   * Returns the value of the `radius` parameter.
   *
   * @return {number} - Returns the radius.
   */
  get radius() {
    return this.__radius
  }

  /**
   * Sets the value of the `radius` parameter.
   *
   * @param {number} val - The radius value.
   */
  set radius(val) {
    this.__radius = val;
    this.__resize();
  }

  /**
   * Sets the value of the `sides` parameter.
   * @param {number} val - The number of sides.
   */
  set sides(val) {
    this.__sides = val >= 3 ? val : 3;
    this.__rebuild();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const nbSides = this.__sidesParam.getValue();

    this.setNumVertices(nbSides + 1);
    this.setFaceCounts([nbSides]);

    // ////////////////////////////
    // Set Vertex Positions
    const positions = this.getVertexAttribute('positions');
    positions.getValueRef(0).set(0.0, 0.0, 0.0);

    // ////////////////////////////
    // Build the topology
    for (let j = 0; j < nbSides; j++) {
      const v1 = (j % nbSides) + 1;
      const v2 = ((j + 1) % nbSides) + 1;
      this.setFaceVertexIndices(j, [0, v1, v2]);
    }

    // ////////////////////////////
    // setNormals
    const normals = this.getVertexAttribute('normals');
    // Now set the attrbute values
    const normal = new Vec3$1(0, 0, 1);
    normals.setValue(0, normal);
    for (let i = 0; i < nbSides; i++) {
      normals.setValue(i + 1, normal);
    }

    // ////////////////////////////
    // setUVs
    const texCoords = this.getVertexAttribute('texCoords');
    texCoords.getValueRef(0).set(0.5, 0.5);
    for (let i = 0; i < nbSides; i++) {
      const phi = (i / nbSides) * 2.0 * Math.PI;
      texCoords.getValueRef(i + 1).set(Math.sin(phi) * 0.5 + 0.5, Math.cos(phi) * 0.5 + 0.5);
    }

    this.setBoundingBoxDirty();
    this.__resize();
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const nbSides = this.__sidesParam.getValue();
    const radius = this.__radiusParam.getValue();
    const positions = this.getVertexAttribute('positions');
    for (let i = 0; i < nbSides; i++) {
      const phi = (i / nbSides) * 2.0 * Math.PI;
      positions.getValueRef(i + 1).set(Math.sin(phi) * radius, Math.cos(phi) * radius, 0.0);
    }
    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['radius'] = this.__radius;
    return json
  }
}

Registry.register('Disc', Disc);

/**
 * A class for generating a plane geometry.
 *
 * ```
 * const plane = new Plane(2.0, 1.5, 10, 10)
 * ```
 *
 * **Parameters**
 * * **SizeX(`NumberParameter`):** Length of the plane along `X` axis.
 * * **SizeY(`NumberParameter`):** Length of the plane along `Y` axis.
 * * **DetailX(`NumberParameter`):** Number of divisions along `X`axis.
 * * **DetailY(`NumberParameter`):** Number of divisions along `Y`axis.
 *
 * @extends Mesh
 */
class Plane$1 extends Mesh {
  /**
   * Create a plane.
   * @param {number} [SizeX=1.0] - The length of the plane along the X axis.
   * @param {number} [SizeY=1.0] - The length of the plane along the Y axis.
   * @param {number} [DetailX=1] - The number of divisions along the X axis.
   * @param {number} [DetailY=1] - The number of divisions along the Y axis.
   * @param {boolean} [addNormals=true] - The addNormals value.
   * @param {boolean} [addTextureCoords=true] - The addTextureCoords value.
   */
  constructor(SizeX = 1.0, SizeY = 1.0, DetailX = 1, DetailY = 1, addNormals = true, addTextureCoords = true) {
    super();

    if (isNaN(SizeX) || isNaN(SizeY) || isNaN(DetailX) || isNaN(DetailY)) throw new Error('Invalid geom args')

    this.__sizeXParam = this.addParameter(new NumberParameter('SizeX', SizeX));
    this.__sizeYParam = this.addParameter(new NumberParameter('SizeY', SizeY));
    this.__detailXParam = this.addParameter(new NumberParameter('DetailX', DetailX));
    this.__detailYParam = this.addParameter(new NumberParameter('DetailY', DetailY));
    if (addNormals) this.addVertexAttribute('normals', Vec3$1);
    if (addTextureCoords) this.addVertexAttribute('texCoords', Vec2);
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__sizeXParam.on('valueChanged', resize);
    this.__sizeYParam.on('valueChanged', resize);
    this.__detailXParam.on('valueChanged', rebuild);
    this.__detailYParam.on('valueChanged', rebuild);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const detailX = this.__detailXParam.getValue();
    const detailY = this.__detailYParam.getValue();
    this.setNumVertices((detailX + 1) * (detailY + 1));
    this.setFaceCounts([0, detailX * detailY]);

    let quadId = 0;
    for (let i = 0; i < detailY; i++) {
      for (let j = 0; j < detailX; j++) {
        const v0 = (detailX + 1) * (i + 1) + j;
        const v1 = (detailX + 1) * (i + 1) + (j + 1);
        const v2 = (detailX + 1) * i + (j + 1);
        const v3 = (detailX + 1) * i + j;
        this.setFaceVertexIndices(quadId, [v0, v1, v2, v3]);
        quadId = quadId + 1;
      }
    }

    let voff = 0;
    const normals = this.getVertexAttribute('normals');
    if (normals) {
      for (let i = 0; i <= detailY; i++) {
        for (let j = 0; j <= detailX; j++) {
          normals.getValueRef(voff).set(0, 0, 1);
          voff++;
        }
      }
    }

    voff = 0;
    const texCoords = this.getVertexAttribute('texCoords');
    if (texCoords) {
      for (let i = 0; i <= detailY; i++) {
        const y = i / detailY;
        for (let j = 0; j <= detailX; j++) {
          const x = j / detailX;
          texCoords.getValueRef(voff).set(x, y);
          voff++;
        }
      }
    }

    this.__resize(false);
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   *
   * @private
   * @param {boolean} [emit=true] - If `true` emits `geomDataChanged` event.
   */
  __resize(emit = true) {
    const sizeX = this.__sizeXParam.getValue();
    const sizeY = this.__sizeYParam.getValue();
    const detailX = this.__detailXParam.getValue();
    const detailY = this.__detailYParam.getValue();
    const positions = this.getVertexAttribute('positions');
    let voff = 0;
    for (let i = 0; i <= detailY; i++) {
      const y = (i / detailY - 0.5) * sizeY;
      for (let j = 0; j <= detailX; j++) {
        const x = (j / detailX - 0.5) * sizeX;
        positions.getValueRef(voff).set(x, y, 0.0);
        voff++;
      }
    }

    this.setBoundingBoxDirty();
    if (emit) this.emit('geomDataChanged', {});
  }
}

/**
 * A class for generating a sphere geometry.
 *
 * ```
 * const sphere = new Sphere(1.4, 13)
 * ```
 *
 * **Parameters**
 * * **radius(`NumberParameter`):** Radius of the sphere.
 * * **sides(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
 * * **loops(`NumberParameter`):** Specifies the number of subdivisions(stacks) along the `Z` axis.
 *
 * @extends Mesh
 */
class Sphere$1 extends Mesh {
  /**
   * Creates an instance of Sphere.
   * @param {number} [radius=1.0] - The radius of the sphere.
   * @param {number} [sides=12] - The number of sides.
   * @param {number} [loops=12] - The number of loops.
   */
  constructor(radius = 1.0, sides = 12, loops = 12) {
    super();

    if (isNaN(radius) || isNaN(sides) || isNaN(loops)) throw new Error('Invalid geom args')

    this.__radiusParam = this.addParameter(new NumberParameter('radius', radius));
    this.__sidesParam = this.addParameter(new NumberParameter('sides', sides >= 3 ? sides : 3, [3, 200], 1));
    this.__loopsParam = this.addParameter(new NumberParameter('loops', loops >= 3 ? loops : 3, [3, 200], 1));

    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();

    const resize = () => {
      this.__resize();
    };
    const rebuild = () => {
      this.__rebuild();
    };
    this.__radiusParam.on('valueChanged', resize);
    this.__sidesParam.on('valueChanged', rebuild);
    this.__loopsParam.on('valueChanged', rebuild);
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const radius = this.__radiusParam.getValue();
    const nbSides = this.__sidesParam.getValue();
    const nbLoops = this.__loopsParam.getValue();

    const numVertices = 2 + nbSides * nbLoops;
    const numTris = nbSides * 2;
    const numQuads = nbSides * nbLoops;
    this.setNumVertices(numVertices);
    this.setFaceCounts([numTris, numQuads]);

    // ////////////////////////////
    // Set Vertex Positions

    const positions = this.getVertexAttribute('positions');
    const normals = this.getVertexAttribute('normals');
    const normal = new Vec3$1(0.0, 0.0, 1.0);
    let vertex = 0;
    positions.getValueRef(vertex).set(0.0, 0.0, radius);
    normals.getValueRef(vertex).set(0.0, 0.0, 1.0);
    vertex++;

    for (let i = 0; i < nbLoops; i++) {
      const theta = ((i + 1) / (nbLoops + 1)) * Math.PI;
      for (let j = 0; j < nbSides; j++) {
        const phi = (j / nbSides) * 2.0 * Math.PI;
        normal.set(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));

        // Set positions and normals at the same time.
        positions.getValueRef(vertex).setFromOther(normal.scale(radius));
        normals.getValueRef(vertex).setFromOther(normal);
        vertex++;
      }
    }
    positions.getValueRef(vertex).set(0.0, 0.0, -radius);
    normals.getValueRef(vertex).set(0.0, 0.0, -1.0);
    vertex++;

    // ////////////////////////////
    // Build the topology
    const texCoords = this.getVertexAttribute('texCoords');

    // build the fan at the first pole.
    let faceIndex = 0;
    for (let j = 0; j < nbSides; j++) {
      const v0 = 0;
      const v1 = ((j + 1) % nbSides) + 1;
      const v2 = j + 1;
      this.setFaceVertexIndices(faceIndex, [v0, v1, v2]);

      const uv0 = new Vec2(0.5, 0.0);
      const uv1 = new Vec2(1.0 - (j + 1) / nbSides, 0.0);
      const uv2 = new Vec2(1.0 - j / nbSides, 1.0 / (nbLoops + 1));
      texCoords.setFaceVertexValue(faceIndex, 0, uv0);
      texCoords.setFaceVertexValue(faceIndex, 1, uv1);
      texCoords.setFaceVertexValue(faceIndex, 2, uv2);

      faceIndex++;
    }
    // Build the fan at the second pole.
    for (let j = 0; j < nbSides; j++) {
      const v0 = numVertices - 1;
      const v1 = nbSides * (nbLoops - 1) + j + 1;
      const v2 = nbSides * (nbLoops - 1) + ((j + 1) % nbSides) + 1;
      this.setFaceVertexIndices(faceIndex, [v0, v1, v2]);

      const uv0 = new Vec2(1.0 - j / nbSides, nbLoops / (nbLoops + 1));
      const uv1 = new Vec2(1.0 - (j + 1) / nbSides, nbLoops / (nbLoops + 1));
      const uv2 = new Vec2(0.5, 1.0);
      texCoords.setFaceVertexValue(faceIndex, 0, uv0);
      texCoords.setFaceVertexValue(faceIndex, 1, uv1);
      texCoords.setFaceVertexValue(faceIndex, 2, uv2);

      faceIndex++;
    }

    for (let i = 0; i < nbLoops - 1; i++) {
      for (let j = 0; j < nbSides; j++) {
        const v0 = nbSides * i + j + 1;
        const v1 = nbSides * i + ((j + 1) % nbSides) + 1;
        const v2 = nbSides * (i + 1) + ((j + 1) % nbSides) + 1;
        const v3 = nbSides * (i + 1) + j + 1;
        this.setFaceVertexIndices(faceIndex, [v0, v1, v2, v3]);

        texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbLoops, j / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 1, new Vec2(i / nbLoops, (j + 1) / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 1) / nbLoops, (j + 1) / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 3, new Vec2((i + 1) / nbLoops, j / nbLoops));
        faceIndex++;
      }
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const radius = this.__radiusParam.getValue();
    const nbSides = this.__sidesParam.getValue();
    const nbLoops = this.__loopsParam.getValue();

    // ////////////////////////////
    // Set Vertex Positions
    const positions = this.getVertexAttribute('positions');
    let vertex = 0;
    const normal = new Vec3$1(0.0, 0.0, 1.0);
    positions.getValueRef(vertex).set(0.0, 0.0, radius);
    vertex++;

    for (let i = 0; i < nbLoops; i++) {
      const theta = ((i + 1) / (nbLoops + 1)) * Math.PI;
      for (let j = 0; j < nbSides; j++) {
        const phi = (j / nbSides) * 2.0 * Math.PI;
        normal.set(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));

        // Set positions and normals at the same time.
        positions.getValueRef(vertex).setFromOther(normal.scale(radius));
        vertex++;
      }
    }
    positions.getValueRef(vertex).set(0.0, 0.0, -radius);
    vertex++;

    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }
}

Registry.register('Sphere', Sphere$1);

/**
 * A class for generating a torus geometry.
 *
 * ```
 * const torus = new Torus(0.4, 1.3)
 * ```
 *
 * @extends Mesh
 */
class Torus extends Mesh {
  /**
   * Creates an instance of Torus.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the torus.
   * @param {number} [outerRadius=1.0] - The outer radius of the torus.
   * @param {number} [detail=32] - The detail of the cone.
   */
  constructor(innerRadius = 0.5, outerRadius = 1.0, detail = 32) {
    super();

    if (isNaN(innerRadius) || isNaN(outerRadius) || isNaN(detail)) throw new Error('Invalid geom args')

    this.__innerRadius = innerRadius;
    this.__outerRadius = outerRadius;
    this.__detail = detail >= 3 ? detail : 3;

    this.addVertexAttribute('texCoords', Vec2);
    this.addVertexAttribute('normals', Vec3$1);
    this.__rebuild();
  }

  /**
   * Getter for the inner radius.
   *
   * @return {number} - Returns the radius.
   */
  get innerRadius() {
    return this.__innerRadius
  }

  /**
   * Setter for the inner radius.
   *
   * @param {number} val - The radius value.
   */
  set innerRadius(val) {
    this.__innerRadius = val;
    this.__resize();
  }

  /**
   * Getter for the outer radius.
   *
   * @return {number} - Returns the radius.
   */
  get outerRadius() {
    return this.__outerRadius
  }

  /**
   * Setter for the outer radius.
   *
   * @param {number} val - The radius value.
   */
  set outerRadius(val) {
    this.__outerRadius = val;
    this.__resize();
  }

  /**
   * Getter for the torus detail.
   *
   * @return {number} - Returns the detail.
   */
  get detail() {
    return this.__detail
  }

  /**
   * Setter for the torus detail.
   *
   * @param {number} val - The detail value.
   */
  set detail(val) {
    this.__detail = val >= 3 ? val : 3;
    this.__rebuild();
  }

  /**
   * The __rebuild method.
   * @private
   */
  __rebuild() {
    const nbSlices = this.__detail;
    const nbLoops = this.__detail * 2;
    const numVertices = nbSlices * nbLoops;

    this.setNumVertices(numVertices);
    this.setFaceCounts([0, nbSlices * nbLoops]);

    // ////////////////////////////
    // Set Vertex Positions

    const positions = this.getVertexAttribute('positions');
    const normals = this.getVertexAttribute('normals');
    let vertex = 0;
    for (let i = 0; i < nbLoops; i++) {
      const theta = (i / nbLoops) * 2.0 * Math.PI;
      const ctheta = Math.cos(theta);
      const stheta = Math.sin(theta);

      for (let j = 0; j < nbSlices; j++) {
        const phi = (j / nbSlices) * 2.0 * Math.PI;

        const sphi = Math.sin(phi);
        const cphi = Math.cos(phi);
        const d = this.__outerRadius + cphi * this.__innerRadius;

        // Set positions and normals at the same time.
        positions.getValueRef(vertex).set(ctheta * d, stheta * d, this.__innerRadius * sphi);
        normals.getValueRef(vertex).set(ctheta * cphi, stheta * cphi, sphi);
        vertex++;
      }
    }

    // ////////////////////////////
    // Build the topology and texCoords
    const texCoords = this.getVertexAttribute('texCoords');
    let faceIndex = 0;
    for (let i = 0; i < nbLoops; i++) {
      for (let j = 0; j < nbSlices; j++) {
        const ip = (i + 1) % nbLoops;
        const jp = (j + 1) % nbSlices;
        const v0 = nbSlices * i + j;
        const v1 = nbSlices * i + jp;
        const v2 = nbSlices * ip + jp;
        const v3 = nbSlices * ip + j;
        this.setFaceVertexIndices(faceIndex, [v0, v1, v2, v3]);

        texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbLoops, j / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 1, new Vec2(i / nbLoops, (j + 1) / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 1) / nbLoops, (j + 1) / nbLoops));
        texCoords.setFaceVertexValue(faceIndex, 3, new Vec2((i + 1) / nbLoops, j / nbLoops));
        faceIndex++;
      }
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataTopologyChanged', {});
  }

  /**
   * The __resize method.
   * @private
   */
  __resize() {
    const nbSlices = this.__detail;
    const nbLoops = this.__detail * 2;

    const positions = this.getVertexAttribute('positions');
    const vertex = 0;
    for (let i = 0; i < nbLoops; i++) {
      const theta = (i / nbLoops) * 2.0 * Math.PI;
      const ctheta = Math.cos(theta);
      const stheta = Math.sin(theta);

      for (let j = 0; j < nbSlices; j++) {
        const phi = (j / nbSlices) * 2.0 * Math.PI;

        const sphi = Math.sin(phi);
        const cphi = Math.cos(phi);
        const d = this.__outerRadius + cphi * this.__innerRadius;

        // Set positions and normals at the same time.
        positions.getValueRef(vertex).set(ctheta * d, stheta * d, this.__innerRadius * sphi);
        index++;
      }
    }

    this.setBoundingBoxDirty();
    this.emit('geomDataChanged', {});
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @return {object} - Returns the json object.
   */
  toJSON() {
    const json = super.toJSON();
    json['x'] = this.__x;
    json['y'] = this.__y;
    json['z'] = this.__z;
    return json
  }
}

// let ResourceLoaderWorker = require("worker-loader?inline!./ResourceLoaderWorker.js");

/**
 * Represents a BaseImage with the ability to load data.
 *
 * **Events**
 * * **loaded:** Triggered when the data is loaded.
 * * **updated:** Triggered when the data is updated.
 * @extends BaseImage
 */
class DataImage extends BaseImage {
  /**
   * Create a data image.
   * @param {string} name - The name value.
   */
  constructor(name) {
    super();

    if (name == undefined) name = this.constructor.name;
    this.__name = name;
    this.format = 'RGBA';
    this.type = 'UNSIGNED_BYTE';
    this.__loaded = false;

    // this.__data = new Uint8Array(4);
    this.width = 1;
    this.height = 1;
  }

  /**
   * Returns an indicator of current item's loaded state.
   * @return {boolean} - `true` if bytes data is fully loaded, `false` otherwise.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * Returns the item's name.
   *
   * @return {string} - The return value.
   */
  getName() {
    return this.__name
  }

  /**
   * Images are static content, so the value for this method is always going to be `false`
   *
   * @return {boolean} - The return value.
   */
  isStream() {
    return false
  }

  /**
   * Sets Image's data by recieving an bytes array.
   *
   * @param {number} width - The width value.
   * @param {number} height - The height value.
   * @param {Uint8Array} data - The data value.
   */
  setData(width, height, data) {
    this.width = width;
    this.height = height;
    this.__data = data;
    if (!this.__loaded) {
      this.__loaded = true;
      this.emit('loaded', {});
    } else this.emit('updated', {});
  }

  /**
   * Returns all parameters and class state values(Including data).
   *
   * @return {object} - The return value.
   */
  getParams() {
    const params = super.getParams();
    params['data'] = this.__data;
    return params
  }
}

Registry.register('DataImage2D', DataImage);
Registry.register('DataImage', DataImage);

var count;
// Stream object for reading off bytes from a byte array

function ByteStream(data){
	this.data = data;
	this.pos = 0;
}

// read the next byte off the stream
ByteStream.prototype.readByte = function(){
	return this.data[this.pos++];
};

// look at the next byte in the stream without updating the stream position
ByteStream.prototype.peekByte = function(){
	return this.data[this.pos];
};

// read an array of bytes
ByteStream.prototype.readBytes = function(n){
	var bytes = new Array(n);
	for(var i=0; i<n; i++){
		bytes[i] = this.readByte();
	}
	return bytes;
};

// peek at an array of bytes without updating the stream position
ByteStream.prototype.peekBytes = function(n){
	var bytes = new Array(n);
	for(var i=0; i<n; i++){
		bytes[i] = this.data[this.pos + i];
	}
	return bytes;
};

// read a string from a byte set
ByteStream.prototype.readString = function(len){
	var str = '';
	for(var i=0; i<len; i++){
		str += String.fromCharCode(this.readByte());
	}
	return str;
};

// read a single byte and return an array of bit booleans
ByteStream.prototype.readBitArray = function(){
	var arr = [];
	var bite = this.readByte();
	for (var i = 7; i >= 0; i--) {
		arr.push(!!(bite & (1 << i)));
	}
	return arr;
};

// read an unsigned int with endian option
ByteStream.prototype.readUnsigned = function(littleEndian){
	var a = this.readBytes(2);
	if(littleEndian){
		return (a[1] << 8) + a[0];	
	}else {
		return (a[0] << 8) + a[1];
	}	
};


function DataParser(data){
	this.stream = new ByteStream(data);
	// the final parsed object from the data
	this.output = {};
}

DataParser.prototype.parse = function(schema){
	// the top level schema is just the top level parts array
	this.parseParts(this.output, schema);	
	return this.output;
};

// parse a set of hierarchy parts providing the parent object, and the subschema
DataParser.prototype.parseParts = function(obj, schema){
	for(var i=0; i<schema.length; i++){
		var part = schema[i];
		this.parsePart(obj, part); 
	}
};

DataParser.prototype.parsePart = function(obj, part){
	var name = part.label;
	var value;

	// make sure the part meets any parse requirements
	if(part.requires && ! part.requires(this.stream, this.output, obj)){
		return;
	}
	
	if(part.loop){
		// create a parse loop over the parts
		var items = [];
		while(part.loop(this.stream)){
			var item = {};
			this.parseParts(item, part.parts);
			items.push(item);
		}
		obj[name] = items;
	}else if(part.parts){
		// process any child parts
		value = {};
		this.parseParts(value, part.parts);
		obj[name] = value;
	}else if(part.parser){
		// parse the value using a parser
		value = part.parser(this.stream, this.output, obj);
		if(!part.skip){
			obj[name] = value;
		}
	}else if(part.bits){
		// convert the next byte to a set of bit fields
		obj[name] = this.parseBits(part.bits);
	}
};

// combine bits to calculate value
function bitsToNum(bitArray){
	return bitArray.reduce(function(s, n) { return s * 2 + n; }, 0);
}

// parse a byte as a bit set (flags and values)
DataParser.prototype.parseBits = function(details){
	var out = {};
	var bits = this.stream.readBitArray();
	for(var key in details){
		var item = details[key];
		if(item.length){
			// convert the bit set to value
			out[key] = bitsToNum(bits.slice(item.index, item.index + item.length));
		}else {
			out[key] = bits[item.index];
		}
	}
	return out;
};


// a set of common parsers used with DataParser

var Parsers = {
	// read a byte
	readByte: function(){
		return function(stream){
			return stream.readByte();
		};
	},
	// read an array of bytes
	readBytes: function(length){
		return function(stream){
			return stream.readBytes(length);
		};
	},
	// read a string from bytes
	readString: function(length){
		return function(stream){
			return stream.readString(length);
		};
	},
	// read an unsigned int (with endian)
	readUnsigned: function(littleEndian){
		return function(stream){
			return stream.readUnsigned(littleEndian);
		};
	},
	// read an array of byte sets
	readArray: function(size, countFunc){
		return function(stream, obj, parent){
			var count = countFunc(stream, obj, parent);
			var arr = new Array(count);
			for(var i=0; i<count; i++){
				arr[i] = stream.readBytes(size);
			}
			return arr;
		};
	}
};


// object used to represent array buffer data for a gif file



// a set of 0x00 terminated subblocks
var subBlocks = {
	label: 'blocks',
	parser: function(stream){
		var out = [];
		var terminator = 0x00;		
		for(var size=stream.readByte(); size!==terminator; size=stream.readByte()){
			out = out.concat(stream.readBytes(size));
		}
		return out;
	}
};

// global control extension
var gce = {
	label: 'gce',
	requires: function(stream){
		// just peek at the top two bytes, and if true do this
		var codes = stream.peekBytes(2);
		return codes[0] === 0x21 && codes[1] === 0xF9;
	},
	parts: [
		{ label: 'codes', parser: Parsers.readBytes(2), skip: true },
		{ label: 'byteSize', parser: Parsers.readByte() },
		{ label: 'extras', bits: {
			future: { index: 0, length: 3 },
			disposal: { index: 3, length: 3 },
			userInput: { index: 6 },
			transparentColorGiven: { index: 7 }
		}},
		{ label: 'delay', parser: Parsers.readUnsigned(true) },
		{ label: 'transparentColorIndex', parser: Parsers.readByte() },
		{ label: 'terminator', parser: Parsers.readByte(), skip: true }
	]
};

// image pipeline block
var image = {
	label: 'image',
	requires: function(stream){
		// peek at the next byte
		var code = stream.peekByte();
		return code === 0x2C;
	},
	parts: [
		{ label: 'code', parser: Parsers.readByte(), skip: true },
		{
			label: 'descriptor', // image descriptor
			parts: [
				{ label: 'left', parser: Parsers.readUnsigned(true) },
				{ label: 'top', parser: Parsers.readUnsigned(true) },
				{ label: 'width', parser: Parsers.readUnsigned(true) },
				{ label: 'height', parser: Parsers.readUnsigned(true) },
				{ label: 'lct', bits: {
					exists: { index: 0 },
					interlaced: { index: 1 },
					sort: { index: 2 },
					future: { index: 3, length: 2 },
					size: { index: 5, length: 3 }
				}}
			]
		},{
			label: 'lct', // optional local color table
			requires: function(stream, obj, parent){
				return parent.descriptor.lct.exists;
			},
			parser: Parsers.readArray(3, function(stream, obj, parent){
				return Math.pow(2, parent.descriptor.lct.size + 1);
			})
		},{
			label: 'data', // the image data blocks
			parts: [
				{ label: 'minCodeSize', parser: Parsers.readByte() },
				subBlocks
			]
		}
	]
};

// plain text block
var text = {
	label: 'text',
	requires: function(stream){
		// just peek at the top two bytes, and if true do this
		var codes = stream.peekBytes(2);
		return codes[0] === 0x21 && codes[1] === 0x01;
	},
	parts: [
		{ label: 'codes', parser: Parsers.readBytes(2), skip: true },
		{ label: 'blockSize', parser: Parsers.readByte() },
		{ 
			label: 'preData', 
			parser: function(stream, obj, parent){
				return stream.readBytes(parent.text.blockSize);
			}
		},
		subBlocks
	]
};

// application block
var application = {
	label: 'application',
	requires: function(stream, obj, parent){
		// make sure this frame doesn't already have a gce, text, comment, or image
		// as that means this block should be attached to the next frame
		//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }

		// peek at the top two bytes
		var codes = stream.peekBytes(2);
		return codes[0] === 0x21 && codes[1] === 0xFF;
	},
	parts: [
		{ label: 'codes', parser: Parsers.readBytes(2), skip: true },
		{ label: 'blockSize', parser: Parsers.readByte() },
		{ 
			label: 'id', 
			parser: function(stream, obj, parent){
				return stream.readString(parent.blockSize);
			}
		},
		subBlocks
	]
};

// comment block
var comment = {
	label: 'comment',
	requires: function(stream, obj, parent){
		// make sure this frame doesn't already have a gce, text, comment, or image
		// as that means this block should be attached to the next frame
		//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }

		// peek at the top two bytes
		var codes = stream.peekBytes(2);
		return codes[0] === 0x21 && codes[1] === 0xFE;
	},
	parts: [
		{ label: 'codes', parser: Parsers.readBytes(2), skip: true },
		subBlocks
	]
};

// frames of ext and image data
var frames = {
	label: 'frames',
	parts: [
		gce,
		application,
		comment,
		image,
		text
	],
	loop: function(stream){
		var nextCode = stream.peekByte();
		// rather than check for a terminator, we should check for the existence
		// of an ext or image block to avoid infinite loops
		//var terminator = 0x3B;
		//return nextCode !== terminator;
		return nextCode === 0x21 || nextCode === 0x2C;
	}
};

// main GIF schema
var schemaGIF = [
	{
		label: 'header', // gif header
		parts: [
			{ label: 'signature', parser: Parsers.readString(3) },
			{ label: 'version', parser: Parsers.readString(3) }
		]
	},{
		label: 'lsd', // local screen descriptor
		parts: [
			{ label: 'width', parser: Parsers.readUnsigned(true) },
			{ label: 'height', parser: Parsers.readUnsigned(true) },
			{ label: 'gct', bits: {
				exists: { index: 0 },
				resolution: { index: 1, length: 3 },
				sort: { index: 4 },
				size: { index: 5, length: 3 }
			}},
			{ label: 'backgroundColorIndex', parser: Parsers.readByte() },
			{ label: 'pixelAspectRatio', parser: Parsers.readByte() }
		]
	},{
		label: 'gct', // global color table
		requires: function(stream, obj){
			return obj.lsd.gct.exists;
		},
		parser: Parsers.readArray(3, function(stream, obj){
			return Math.pow(2, obj.lsd.gct.size + 1);
		})
	},
	frames // content frames
];


var gifSchema = schemaGIF;

function GIF(arrayBuffer){
	// convert to byte array
	var byteData = new Uint8Array(arrayBuffer);
	var parser = new DataParser(byteData);
	// parse the data
	this.raw = parser.parse(gifSchema);

	// set a flag to make sure the gif contains at least one image
	this.raw.hasImages = false;
	for(var f=0; f<this.raw.frames.length; f++){
		if(this.raw.frames[f].image){
			this.raw.hasImages = true;
			break;
		}
	}
}

// process a single gif image frames data, decompressing it using LZW 
// if buildPatch is true, the returned image will be a clamped 8 bit image patch
// for use directly with a canvas.
GIF.prototype.decompressFrame = function(index, buildPatch){

	// make sure a valid frame is requested
	if(index >= this.raw.frames.length){ return null; }

	var frame = this.raw.frames[index];
	if(frame.image){
		// get the number of pixels
		var totalPixels = frame.image.descriptor.width * frame.image.descriptor.height;

		// do lzw decompression
		var pixels = lzw(frame.image.data.minCodeSize, frame.image.data.blocks, totalPixels);

		// deal with interlacing if necessary
		if(frame.image.descriptor.lct.interlaced){
			pixels = deinterlace(pixels, frame.image.descriptor.width);
		}

		// setup usable image object
		var image = {
			pixels: pixels,
			dims: {
				top: frame.image.descriptor.top,
				left: frame.image.descriptor.left,
				width: frame.image.descriptor.width,
				height: frame.image.descriptor.height
			}
		};

		// color table
		if(frame.image.descriptor.lct && frame.image.descriptor.lct.exists){
			image.colorTable = frame.image.lct;
		}else {
			image.colorTable = this.raw.gct;
		}

		// add per frame relevant gce information
		if(frame.gce){
			image.delay = (frame.gce.delay || 10) * 10; // convert to ms
			image.disposalType = frame.gce.extras.disposal;
			// transparency
			if(frame.gce.extras.transparentColorGiven){
				image.transparentIndex = frame.gce.transparentColorIndex;
			}
		}

		// create canvas usable imagedata if desired
		if(buildPatch){
			image.patch = generatePatch(image);
		}

		return image;		
	}

	// frame does not contains image
	return null;


	/**
	 * javascript port of java LZW decompression
	 * Original java author url: https://gist.github.com/devunwired/4479231
	 */	
	function lzw(minCodeSize, data, pixelCount) {
 		
 		var MAX_STACK_SIZE = 4096;
		var nullCode = -1;

		var npix = pixelCount;
		var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
 
 		var dstPixels = new Array(pixelCount);
		var prefix = new Array(MAX_STACK_SIZE);
		var suffix = new Array(MAX_STACK_SIZE);
		var pixelStack = new Array(MAX_STACK_SIZE + 1);
 
		// Initialize GIF data stream decoder.
		data_size = minCodeSize;
		clear = 1 << data_size;
		end_of_information = clear + 1;
		available = clear + 2;
		old_code = nullCode;
		code_size = data_size + 1;
		code_mask = (1 << code_size) - 1;
		for (code = 0; code < clear; code++) {
			prefix[code] = 0;
			suffix[code] = code;
		}
 
		// Decode GIF pixel stream.
		datum = bits = count = first = top = pi = bi = 0;
		for (i = 0; i < npix; ) {
			if (top === 0) {
				if (bits < code_size) {
					
					// get the next byte			
					datum += data[bi] << bits;

					bits += 8;
					bi++;
					continue;
				}
				// Get the next code.
				code = datum & code_mask;
				datum >>= code_size;
				bits -= code_size;
				// Interpret the code
				if ((code > available) || (code == end_of_information)) {
					break;
				}
				if (code == clear) {
					// Reset decoder.
					code_size = data_size + 1;
					code_mask = (1 << code_size) - 1;
					available = clear + 2;
					old_code = nullCode;
					continue;
				}
				if (old_code == nullCode) {
					pixelStack[top++] = suffix[code];
					old_code = code;
					first = code;
					continue;
				}
				in_code = code;
				if (code == available) {
					pixelStack[top++] = first;
					code = old_code;
				}
				while (code > clear) {
					pixelStack[top++] = suffix[code];
					code = prefix[code];
				}
				
				first = suffix[code] & 0xff;
				pixelStack[top++] = first;

				// add a new string to the table, but only if space is available
				// if not, just continue with current table until a clear code is found
				// (deferred clear code implementation as per GIF spec)
				if(available < MAX_STACK_SIZE){
					prefix[available] = old_code;
					suffix[available] = first;
					available++;
					if (((available & code_mask) === 0) && (available < MAX_STACK_SIZE)) {
						code_size++;
						code_mask += available;
					}
				}
				old_code = in_code;
			}
			// Pop a pixel off the pixel stack.
			top--;
			dstPixels[pi++] = pixelStack[top];
			i++;
		}

		for (i = pi; i < npix; i++) {
			dstPixels[i] = 0; // clear missing pixels
		}

		return dstPixels;
	}

	// deinterlace function from https://github.com/shachaf/jsgif
	function deinterlace(pixels, width) {
		
		var newPixels = new Array(pixels.length);
		var rows = pixels.length / width;
		var cpRow = function(toRow, fromRow) {
			var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
			newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
		};

		// See appendix E.
		var offsets = [0,4,2,1];
		var steps   = [8,8,4,2];

		var fromRow = 0;
		for (var pass = 0; pass < 4; pass++) {
			for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
				cpRow(toRow, fromRow);
				fromRow++;
			}
		}

		return newPixels;
	}

	// create a clamped byte array patch for the frame image to be used directly with a canvas
	// TODO: could potentially squeeze some performance by doing a direct 32bit write per iteration
	function generatePatch(image){

		var totalPixels = image.pixels.length;
		var patchData = new Uint8ClampedArray(totalPixels * 4);
		for(var i=0; i<totalPixels; i++){
			var pos = i * 4;
			var colorIndex = image.pixels[i];
			var color = image.colorTable[colorIndex];
			patchData[pos] = color[0];
			patchData[pos + 1] = color[1];
			patchData[pos + 2] = color[2];
			patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
		}

		return patchData;
	}
};

// returns all frames decompressed
GIF.prototype.decompressFrames = function(buildPatch){
	var frames = [];
	for(var i=0; i<this.raw.frames.length; i++){
		var frame = this.raw.frames[i];
		if(frame.image){
			frames.push(this.decompressFrame(i, buildPatch));
		}
	}
	return frames;
};

const imageDataLibrary = {};

const imageLoaders = {};

const supportWebp = globalThis.navigator && navigator.userAgent.indexOf('Chrome') !== -1;

/** Class representing a file image.
 * @extends BaseImage
 */
class FileImage$1 extends BaseImage {
  /**
   * Create a file image.
   * @param {string} name - The name value.
   * @param {string} filePath - The filePath value.
   * @param {object} params - The params value.
   */
  constructor(name, filePath = '', params = {}) {
    if (filePath.constructor == Object) {
      params = filePath;
    }
    if (name != undefined && name.lastIndexOf('.') != -1) {
      console.warn('Deprecated signature. Please provide a name and filepath to the image constructor');
      name = name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));
    }

    super(name, params);

    this.__loaded = false;

    const fileParam = this.addParameter(new FilePathParameter('FilePath'));
    fileParam.on('valueChanged', () => {
      this.loaded = false;
      if (this.getName() == '') {
        // Generate a name from the file path.
        const stem = fileParam.getStem();
        const decorator = stem.substring(stem.length - 1);
        if (!isNaN(decorator)) {
          // Note: ALL image names have an LOD specifier at the end.
          // remove that off when retrieving the name.
          this.setName(stem.substring(0, stem.length - 1));
        } else {
          this.setName(stem);
        }
      }

      if (fileParam.getValue()) {
        this.__loadData();
      }
    });

    if (filePath && filePath != '') fileParam.setFilepath(filePath);
  }

  /**
   * The __imageDataLibrary method.
   * @return {any} - The return value.
   * @private
   */
  static __imageDataLibrary() {
    return imageDataLibrary
  }

  /**
   * The registerLoader method.
   * @param {any} exts - The exts param.
   * @param {any} loaderClass - The loaderClass param.
   */
  static registerLoader(exts, loaderClass) {
    imageLoaders[exts] = loaderClass;
  }

  /**
   * The constructLoader method.
   * @param {any} file - The file value.
   * @param {any} loaderName - The loaderName value.
   * @return {any} - The return value.
   */
  static constructLoader(file, loaderName) {
    for (const exts of imageLoaders) {
      if (new RegExp('\\.(' + exts + ')$', 'i').test(file.name)) {
        const loader = new imageLoaders[exts](loaderName);
        if (loader) {
          loader.getParameter('FilePath').setValue(file.id);
          return loader
        }
      }
    }
  }

  /**
   * The __loadData method.
   * @private
   */
  __loadData() {
    const ext = this.getParameter('FilePath').get();
    if (ext == '.jpg' || ext == '.png' || ext == '.webp') {
      this.__loadLDRImage(ext);
    } else if (ext == '.mp4' || ext == '.ogg') {
      this.__loadLDRVideo();
      // } else if (ext == '.ldralpha') {
      //     this.__loadLDRAlpha(file, ext);
    } else if (ext == '.vlh') {
      this.__loadVLH();
    } else if (ext == '.gif') {
      this.__loadGIF();
    } else if (ext == '.svg') {
      console.warn('SVG Image not yet supported');
    } else {
      throw new Error('Unsupported file type. Check the ext:' + file)
    }
  }

  /**
   * The __loadLDRImage method.
   * @param {string} ext - The file extension.
   * @private
   */
  __loadLDRImage(ext) {
    const file = this.getParameter('FilePath').getFile();
    if (ext == '.jpg') {
      this.format = 'RGB';
    } else if (ext == '.png') {
      this.format = 'RGBA';
    }
    this.type = 'UNSIGNED_BYTE';
    let imageElem;
    const loaded = () => {
      this.getDOMElement = () => {
        return imageElem
      };
      this.width = imageElem.width;
      this.height = imageElem.height;
      this.__data = imageElem;
      this.__loaded = true;
      this.emit('loaded', {});
    };
    if (file.id in imageDataLibrary) {
      imageElem = imageDataLibrary[file.id];
      if (imageElem.complete) {
        loaded();
      } else {
        imageElem.addEventListener('load', loaded);
      }
    } else {
      resourceLoader.addWork(file.id, 1);

      const prefSizeParam = this.addParameter(new NumberParameter('PreferredSize', -1));

      let url = file.url;
      if (file.assets && Object.keys(file.assets).length > 0) {
        function chooseImage(params, filterAssets) {
          // Note: this is a filter to remove any corrupt data
          // generate by our broken server side processing system.
          filterAssets = filterAssets.filter((asset) => asset !== null);

          if (supportWebp) {
            const resultFilter = filterAssets.filter((asset) => asset.format === 'webp');

            if (resultFilter.length > 1) {
              filterAssets = resultFilter;
            }
          } else {
            filterAssets = filterAssets.filter((asset) => asset.format !== 'webp');
          }

          if (params.maxSize) {
            filterAssets = filterAssets.filter((asset) => asset.w <= params.maxSize);
          }
          if (params.filter) {
            const resultFilter = filterAssets.filter((asset) => asset.url.indexOf(params.filter) !== -1);
            if (resultFilter.length > 1) {
              filterAssets = resultFilter;
            }
          }
          if (params.prefSize) {
            filterAssets = filterAssets.map((asset) =>
              Object.assign(
                {
                  score: Math.abs(params.prefSize - asset.w),
                },
                asset
              )
            );

            // return low score, close to desire
            // return _.sortBy(score, "score")[0].option.url;
            filterAssets.sort((a, b) => (a.score > b.score ? 1 : a.score < b.score ? -1 : 0));
          }
          if (filterAssets.length > 0) return filterAssets[0]
        }
        const params = {
          maxSize: SystemDesc.gpuDesc.maxTextureSize,
        };
        const prefSize = prefSizeParam.getValue();
        if (prefSize == -1) {
          if (file.assets.reduce) params.prefSize = file.assets.reduce.w;
        } else {
          params.prefSize = prefSize;
        }
        const asset = chooseImage(params, Object.values(file.assets));
        if (asset) {
          console.log(
            'Selected image:' +
              file.name +
              ' format:' +
              asset.format +
              ' :' +
              asset.w +
              'x' +
              asset.h +
              ' url:' +
              asset.url
          );
          url = asset.url;
        }
      } else {
        console.warn('Images not processed for this file:' + file.name);
      }

      imageElem = new Image();
      imageElem.crossOrigin = 'anonymous';
      imageElem.src = url;

      imageElem.addEventListener('load', loaded);
      imageElem.addEventListener('load', () => {
        resourceLoader.addWorkDone(file.id, 1);
      });
      imageDataLibrary[file.id] = imageElem;
    }
  }

  /**
   * The __removeVideoParams method.
   * @private
   */
  __removeVideoParams() {
    if (this.getParameterIndex('spatializeAudio')) {
      this.removeParameter(this.getParameterIndex('Loop'));
      this.removeParameter(this.getParameterIndex('spatializeAudio'));
      this.removeParameter(this.getParameterIndex('Gain'));
      this.removeParameter(this.getParameterIndex('refDistance'));
      this.removeParameter(this.getParameterIndex('maxDistance'));
      this.removeParameter(this.getParameterIndex('rolloffFactor'));
      this.removeParameter(this.getParameterIndex('coneInnerAngle'));
      this.removeParameter(this.getParameterIndex('coneOuterAngle'));
      this.removeParameter(this.getParameterIndex('coneOuterGain'));
    }
  }

  /**
   * The __loadLDRVideo method.
   * @param {string} ext - The file extension.
   * @private
   */
  __loadLDRVideo() {
    const file = this.getParameter('FilePath').getFile();
    this.format = 'RGB';
    this.type = 'UNSIGNED_BYTE';
    resourceLoader.addWork(file.id, 1);

    // Note: mute needs to be turned off by an action from the user.
    // Audio is disabled by default now in chrome.
    const muteParam = this.addParameter(new BooleanParameter('Mute', true));
    const loopParam = this.addParameter(new BooleanParameter('Loop', true));

    const videoElem = document.createElement('video');
    // TODO - confirm its necessary to add to DOM
    videoElem.style.display = 'none';
    videoElem.preload = 'auto';
    videoElem.crossOrigin = 'anonymous';
    // videoElem.crossorigin = true;

    this.getAudioSource = () => {
      return videoElem
    };

    document.body.appendChild(videoElem);
    videoElem.on(
      'loadedmetadata',
      () => {
        // videoElem.play();

        videoElem.muted = muteParam.getValue();
        muteParam.on('valueChanged', () => {
          videoElem.muted = muteParam.getValue();
        });
        videoElem.loop = loopParam.getValue();
        loopParam.on('valueChanged', () => {
          videoElem.loop = loopParam.getValue();
        });

        this.width = videoElem.videoHeight;
        this.height = videoElem.videoWidth;
        this.__data = videoElem;
        this.__loaded = true;
        resourceLoader.addWorkDone(file.id, 1);
        this.emit('loaded', {});

        videoElem.play().then(
          () => {
            let prevFrame = 0;
            const frameRate = 29.97;
            const timerCallback = () => {
              if (videoElem.paused || videoElem.ended) {
                return
              }
              // Check to see if the video has progressed to the next frame.
              // If so, then we emit and update, which will cause a redraw.
              const currentFrame = Math.floor(videoElem.currentTime * frameRate);
              if (prevFrame != currentFrame) {
                this.emit('updated', {});
                prevFrame = currentFrame;
              }
              setTimeout(timerCallback, 20); // Sample at 50fps.
            };
            timerCallback();
          },
          (e) => {
            console.log('Autoplay was prevented.', e, e.message);
          }
        );
        // const promise = videoElem.play();
        // if (promise !== undefined) {
        //     promise.then(_ => {
        //         console.log("Autoplay started!")
        //         // Autoplay started!
        //     }).catch(error => {
        //         console.log("Autoplay was prevented.")
        //         // Autoplay was prevented.
        //         // Show a "Play" button so that user can start playback.
        //     });
        // }
      },
      false
    );
    videoElem.src = file.url;
    // videoElem.load();
  }

  /**
   * The __loadVLH method.
   * @param {string} ext - The file extension.
   * @private
   */
  __loadVLH() {
    const file = this.getParameter('FilePath').getFile();
    this.type = 'FLOAT';

    let hdrtint = new Color(1, 1, 1, 1);
    // let stream = 'stream' in params ? params['stream'] : false;

    this.setHDRTint = (value) => {
      hdrtint = value;
    };
    this.getHDRTint = () => {
      return hdrtint
    };

    resourceLoader.loadUrl(file.id, file.url, (entries) => {
      let ldr;
      let cdm;
      for (const name in entries) {
        if (name.endsWith('.jpg')) ldr = entries[name];
        else if (name.endsWith('.bin')) cdm = entries[name];
      }

      // ///////////////////////////////
      // Parse the data.
      const blob = new Blob([ldr.buffer]);
      const ldrPic = new Image();
      ldrPic.onload = () => {
        this.width = ldrPic.width;
        this.height = ldrPic.height;
        // console.log(file.name + ": [" + this.width + ", " + this.height + "]");
        this.__data = {
          ldr: ldrPic,
          cdm: cdm,
        };
        if (!this.__loaded) {
          this.__loaded = true;
          this.emit('loaded', {});
        } else {
          this.emit('updated', {});
        }
      };
      ldrPic.src = URL.createObjectURL(blob);
    });
  }

  /**
   * The __loadGIF method.
   * @param {string} ext - The file extension.
   * @private
   */
  __loadGIF() {
    const file = this.getParameter('FilePath').getFile();
    this.format = 'RGBA';
    this.type = 'UNSIGNED_BYTE';
    this.__streamAtlas = true;

    // this.__streamAtlasDesc = new Vec4();
    this.addParameter(new Vec4Parameter('StreamAtlasDesc', new Vec4$1()));
    this.addParameter(new NumberParameter('StreamAtlasIndex', 0)).setRange([0, 1]);

    this.getFrameDelay = () => {
      return 20
    };
    let playing;
    let incrementFrame;
    this.play = () => {
      resourcePromise.then(() => {
        playing = true;
        if (incrementFrame) incrementFrame();
      });
    };
    this.stop = () => {
      playing = false;
    };
    let resourcePromise;
    if (file.id in imageDataLibrary) {
      resourcePromise = imageDataLibrary[file.id];
    } else {
      resourcePromise = new Promise((resolve, reject) => {
        resourceLoader.addWork(file.id, 1);

        if (file.assets && file.assets.atlas) {
          const imageElem = new Image();
          imageElem.crossOrigin = 'anonymous';
          imageElem.src = file.assets.atlas.url;
          imageElem.addEventListener('load', () => {
            resolve({
              width: file.assets.atlas.width,
              height: file.assets.atlas.height,
              atlasSize: file.assets.atlas.atlasSize,
              frameDelays: file.assets.atlas.frameDelays,
              frameRange: [0, file.assets.atlas.frameDelays.length],
              imageData: imageElem,
            });
            resourceLoader.addWorkDone(file.id, 1);
          });
          return
        }

        loadBinfile(
          file.url,
          (data) => {
            console.warn('Unpacking Gif client side:' + file.name);

            const start = performance.now();

            // Decompressing using: https://github.com/matt-way/gifuct-js
            const gif = new GIF(data);
            const frames = gif.decompressFrames(true);

            // do something with the frame data
            const sideLength = Math.sqrt(frames.length);
            const atlasSize = [sideLength, sideLength];
            if (MathFunctions.fract(sideLength) > 0.0) {
              atlasSize[0] = Math.floor(atlasSize[0] + 1);
              if (MathFunctions.fract(sideLength) > 0.5) {
                atlasSize[1] = Math.floor(atlasSize[1] + 1);
              } else {
                atlasSize[1] = Math.floor(atlasSize[1]);
              }
            }

            const width = frames[0].dims.width;
            const height = frames[0].dims.height;

            // gif patch canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            // full gif canvas
            const gifCanvas = document.createElement('canvas');
            const gifCtx = gifCanvas.getContext('2d');

            gifCanvas.width = width;
            gifCanvas.height = height;

            // The atlas for all the frames.
            const atlasCanvas = document.createElement('canvas');
            const atlasCtx = atlasCanvas.getContext('2d');
            atlasCanvas.width = atlasSize[0] * width;
            atlasCanvas.height = atlasSize[1] * height;

            let frameImageData;
            const frameDelays = [];
            const renderFrame = (frame, index) => {
              const dims = frame.dims;

              // Note: the server side library returns centisecs for
              // frame delays, so normalize here so that client and servers
              // valueus are in the
              frameDelays.push(frame.delay / 10);

              if (!frameImageData || dims.width != frameImageData.width || dims.height != frameImageData.height) {
                tempCanvas.width = dims.width;
                tempCanvas.height = dims.height;
                frameImageData = tempCtx.createImageData(dims.width, dims.height);
              }

              // set the patch data as an override
              frameImageData.data.set(frame.patch);
              tempCtx.putImageData(frameImageData, 0, 0);

              // Note: undocumented disposal method.
              // See Ids here: https://github.com/theturtle32/Flash-Animated-GIF-Library/blob/master/AS3GifPlayer/src/com/worlize/gif/constants/DisposalType.as
              // From what I can gather, 2 means we should clear the background first.
              // this seems towork with Gifs featuring moving transparency.
              // For fully opaque gifs, we should avoid this.
              if (frame.disposalType == 2) gifCtx.clearRect(0, 0, gifCanvas.width, gifCanvas.height);

              gifCtx.drawImage(tempCanvas, dims.left, dims.top);

              atlasCtx.drawImage(gifCanvas, (index % atlasSize[0]) * width, Math.floor(index / atlasSize[0]) * height);
            };

            for (let i = 0; i < frames.length; i++) {
              // console.log(frame);
              renderFrame(frames[i], i);
            }
            resourceLoader.addWorkDone(file.id, 1);

            const imageData = atlasCtx.getImageData(0, 0, atlasCanvas.width, atlasCanvas.height);

            const ms = performance.now() - start;
            console.log(`Decode GIF '${file.name}' time:` + ms);

            resolve({
              width: atlasCanvas.width,
              height: atlasCanvas.height,
              atlasSize,
              frameRange: [0, frames.length],
              frameDelays,
              imageData,
            });
          },
          (statusText) => {
            const msg = 'Unable to Load URL:' + statusText + ':' + fileDesc.url;
            console.warn(msg);
            reject(msg);
          }
        );
      });

      imageDataLibrary[file.id] = resourcePromise;
    }

    resourcePromise.then((unpackedData) => {
      this.width = unpackedData.width;
      this.height = unpackedData.height;

      this.getParameter('StreamAtlasDesc').setValue(
        new Vec4$1(unpackedData.atlasSize[0], unpackedData.atlasSize[1], 0, 0)
      );
      this.getParameter('StreamAtlasIndex').setRange(unpackedData.frameRange);

      this.__data = unpackedData.imageData;

      this.getFrameDelay = (index) => {
        // Note: Frame delays are in centisecs (not millisecs which the timers will require.)
        return unpackedData.frameDelays[index] * 10
      };

      // ////////////////////////
      // Playback
      const frameParam = this.getParameter('StreamAtlasIndex');
      const numFrames = frameParam.getRange()[1];
      let frame = 0;
      incrementFrame = () => {
        frameParam.setValue(frame);
        if (playing) setTimeout(incrementFrame, this.getFrameDelay(frame));
        frame = (frame + 1) % numFrames;
      };
      if (playing) incrementFrame();
      this.__loaded = true;

      this.emit('loaded', {});
    });
  }

  /**
   * The isStream method.
   * @return {boolean} - The return value.
   */
  isStream() {
    return false
  }

  /**
   * The isLoaded method.
   * @return {any} - The return value.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * The getParams method.
   * @return {any} - The return value.
   */
  getParams() {
    const params = super.getParams();
    if (this.__loaded) {
      params['data'] = this.__data;
    }
    return params
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @param {object} context - The context value.
   */
  toJSON(context) {}

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context) {}

  /**
   * The readBinary method.
   * @param {object} reader - The reader param.
   * @param {object} context - The context param.
   */
  readBinary(reader, context) {
    // super.readBinary(reader, context);
    this.setName(reader.loadStr());

    let filePath = reader.loadStr();
    if (typeof filePath === 'string' && filePath != '') {
      if (context.lod >= 0) {
        const suffixSt = filePath.lastIndexOf('.');
        if (suffixSt != -1) {
          const lodPath = filePath.substring(0, suffixSt) + context.lod + filePath.substring(suffixSt);
          if (resourceLoader.resolveFilepath(lodPath)) {
            filePath = lodPath;
          }
        }
      }
      this.getParameter('FilePath').setFilepath(filePath);
    }
  }
}

/** Class representing a 2D file image.
 * @extends FileImage
 */
class FileImage2D extends FileImage$1 {
  /**
   * Create a file image 2D.
   * @param {any} filePath - The filePath value.
   * @param {any} params - The params value.
   */
  constructor(filePath, params = {}) {
    console.warn('FileImage2D is becoming deprecated in favor of simple FileImage');
    super(filePath, params);
  }
}

Registry.register('FileImage2D', FileImage$1);
Registry.register('FileImage', FileImage$1);

/* eslint-disable require-jsdoc */

const supportWebp$1 = globalThis.navigator && navigator.userAgent.indexOf('Chrome') !== -1;

/**
 * Class representing a LDR (low dynamic range) image.
 *
 * ```
 * const image = new LDRImage()
 * image.getParameter('FilePath').setUrl("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
 * ```
 *
 * **Parameters**
 * * **PreferredSize(`NumberParameter`):** _todo_
 *
 * **Events:**
 * * **loaded:** Triggered when image data is loaded.
 *
 * **File Types:** jpg, jpeg, png
 *
 * @extends FileImage
 */
class LDRImage extends FileImage$1 {
  /**
   * Create a LDR image.
   * @param {string} name - The name value.
   * @param {string} filePath - The filePath value.
   * @param {object} params - The params value.
   */
  constructor(name, filePath, params) {
    super(name, filePath, params);
    this.type = 'UNSIGNED_BYTE';
    this.addParameter(new NumberParameter('PreferredSize', -1));
    this.__crossOrigin = 'anonymous';
  }

  /**
   * Defines how to handle cross origin request.
   *
   * **Possible values:**
   * * **anonymous** - CORS requests for this element will have the credentials flag set to 'same-origin'.
   * * **use-credentials** - CORS requests for this element will have the credentials flag set to 'include'.
   * * **""** - Setting the attribute name to an empty value, like crossorigin or crossorigin="", is the same as anonymous.
   *
   * @default anonymous
   * @param {string} crossOrigin - The crossOrigin value.
   */
  setCrossOrigin(crossOrigin) {
    this.__crossOrigin = crossOrigin;
  }

  /**
   * The __loadData method.
   * @param {object} fileDesc - The fileDesc value.
   * @private
   */
  __loadData(fileDesc) {
    const ext = this.getParameter('FilePath').getExt();
    const format = 'RGB';
    if (ext == '.png') {
      this.format = 'RGBA';
    }

    let url = fileDesc.url;
    if (fileDesc.assets && Object.keys(fileDesc.assets).length > 0) {
      function chooseImage(params, filterAssets) {
        // Note: this is a filter to remove any corrupt data
        // generate by our broken server side processing system.
        filterAssets = filterAssets.filter((asset) => asset !== null);

        if (supportWebp$1) {
          const resultFilter = filterAssets.filter((asset) => asset.format === 'webp');

          if (resultFilter.length > 1) {
            filterAssets = resultFilter;
          }
        } else {
          filterAssets = filterAssets.filter((asset) => asset.format !== 'webp');
        }

        if (params.maxSize) {
          filterAssets = filterAssets.filter((asset) => asset.w <= params.maxSize);
        }
        if (params.filter) {
          const resultFilter = filterAssets.filter((asset) => asset.url.indexOf(params.filter) !== -1);
          if (resultFilter.length > 1) {
            filterAssets = resultFilter;
          }
        }
        if (params.prefSize) {
          filterAssets = filterAssets.map((asset) =>
            Object.assign(
              {
                score: Math.abs(params.prefSize - asset.w),
              },
              asset
            )
          );

          // return low score, close to desire
          // return _.sortBy(score, "score")[0].option.url;
          filterAssets.sort((a, b) => (a.score > b.score ? 1 : a.score < b.score ? -1 : 0));
        }
        if (filterAssets.length > 0) return filterAssets[0]
      }
      const params = {
        maxSize: SystemDesc.gpuDesc.maxTextureSize,
      };
      const prefSize = this.getParameter('PreferredSize').getValue();
      if (prefSize == -1) {
        if (fileDesc.assets.reduce) params.prefSize = fileDesc.assets.reduce.w;
      } else {
        params.prefSize = prefSize;
      }
      const asset = chooseImage(params, Object.values(fileDesc.assets));
      if (asset) {
        console.log(
          'Selected image:' +
            fileDesc.name +
            ' format:' +
            asset.format +
            ' :' +
            asset.w +
            'x' +
            asset.h +
            ' url:' +
            asset.url
        );
        url = asset.url;
      }
    } else {
      console.warn('Images not processed for this file:' + fileDesc.name);
    }

    this.setImageURL(url, format);
  }

  /**
   * Uses the specify url to load an Image element and adds it to the data library.
   * Sets the state of the current object.
   *
   * @param {string} url - The url value.
   * @param {string} format - The format value.
   */
  setImageURL(url, format = 'RGB') {
    if (!format) {
      const suffixSt = url.lastIndexOf('.');
      if (suffixSt != -1) {
        const ext = url.substring(suffixSt).toLowerCase();
        if (ext == '.png') {
          format = 'RGBA';
        }
      }
    }
    this.format = format;
    this.__loaded = false;

    let imageElem;
    const loaded = () => {
      this.getDOMElement = () => {
        return imageElem
      };
      this.width = imageElem.width;
      this.height = imageElem.height;
      this.__data = imageElem;
      this.__loaded = true;
      this.emit('loaded', {});
    };
    const imageDataLibrary = FileImage$1.__imageDataLibrary();
    if (url in imageDataLibrary) {
      imageElem = imageDataLibrary[url];
      if (imageElem.complete) {
        loaded();
      } else {
        imageElem.addEventListener('load', loaded);
      }
    } else {
      imageElem = new Image();
      imageElem.crossOrigin = this.__crossOrigin;
      imageElem.src = url;

      imageElem.addEventListener('load', loaded);
      imageDataLibrary[url] = imageElem;
    }
  }
}

FileImage$1.registerLoader('jpg|jpeg|png', LDRImage);
Registry.register('LDRImage', LDRImage);

/**
 * Class representing a LDR (low dynamic range) video.
 *
 * ```
 * const video = new LDRVideo()
 * video.getParameter('FilePath').setUrl("https://storage.googleapis.com/zea-playground-assets/zea-engine/video.mp4")
 * ```
 *
 * **Parameters**
 * * **Mute(`BooleanParameter`):** Mutes video volume.
 * * **Loop(`BooleanParameter`):** Repeats video over and over again.
 * * **Gain(`NumberParameter`):** Sets loudness of the video before going through any processing.
 * * **SpatializeAudio(`BooleanParameter`):** Enables/Disables spatial(Surrounding) audio.
 * * **refDistance(`NumberParameter`):** _todo_
 * * **maxDistance(`NumberParameter`):** _todo_
 * * **rolloffFactor(`NumberParameter`):** _todo_
 * * **coneInnerAngle(`NumberParameter`):** _todo_
 * * **coneOuterAngle(`NumberParameter`):** _todo_
 * * **coneOuterGain(`NumberParameter`):** _todo_
 *
 * **File Types:** mp4, ogg
 *
 * @extends FileImage
 */
class LDRVideo extends FileImage$1 {
  /**
   * Create a LDR video.
   * @param {string} name - The name value.
   * @param {string} filePath - The filePath value.
   * @param {object} params - The params value.
   */
  constructor(name, filePath, params) {
    super(name, filePath, params);
    this.format = 'RGB';
    this.type = 'UNSIGNED_BYTE';

    this.addParameter(new BooleanParameter('Mute', false));
    this.addParameter(new BooleanParameter('Loop', true));
    this.addParameter(new NumberParameter('Gain', 2.0)).setRange([0, 5]);
    this.addParameter(new BooleanParameter('SpatializeAudio', true));
    this.addParameter(new NumberParameter('refDistance', 2));
    this.addParameter(new NumberParameter('maxDistance', 10000));
    this.addParameter(new NumberParameter('rolloffFactor', 1));
    this.addParameter(new NumberParameter('coneInnerAngle', 360));
    this.addParameter(new NumberParameter('coneOuterAngle', 0));
    this.addParameter(new NumberParameter('coneOuterGain', 1));
  }

  /**
   * The __loadData method.
   * @param {object} fileDesc - The fileDesc value.
   * @private
   */
  __loadData(fileDesc) {
    resourceLoader.addWork(fileDesc.id, 1);

    const videoElem = document.createElement('video');
    // TODO - confirm its necessary to add to DOM
    videoElem.style.display = 'none';
    videoElem.preload = 'auto';
    videoElem.crossOrigin = 'anonymous';
    // videoElem.crossorigin = true;

    this.getAudioSource = () => {
      return videoElem
    };

    document.body.appendChild(videoElem);
    videoElem.addEventListener(
      'loadedmetadata',
      () => {
        // videoElem.play();

        const muteParam = this.getParameter('Mute');
        videoElem.muted = muteParam.getValue();
        muteParam.on('valueChanged', () => {
          videoElem.muted = muteParam.getValue();
        });

        const loopParam = this.getParameter('Loop');
        videoElem.loop = loopParam.getValue();
        loopParam.on('valueChanged', () => {
          videoElem.loop = loopParam.getValue();
        });

        this.width = videoElem.videoHeight;
        this.height = videoElem.videoWidth;
        this.__data = videoElem;
        this.__loaded = true;
        resourceLoader.addWorkDone(fileDesc.id, 1);
        this.emit('loaded', {});

        let prevFrame = 0;
        const frameRate = 29.97;
        const timerCallback = () => {
          if (videoElem.paused || videoElem.ended) {
            return
          }
          // Check to see if the video has progressed to the next frame.
          // If so, then we emit and update, which will cause a redraw.
          const currentFrame = Math.floor(videoElem.currentTime * frameRate);
          if (prevFrame != currentFrame) {
            this.emit('updated', {});
            prevFrame = currentFrame;
          }
          setTimeout(timerCallback, 20); // Sample at 50fps.
        };
        timerCallback();
      },
      false
    );
    videoElem.src = fileDesc.url;
    // videoElem.load();
    const promise = videoElem.play();
    if (promise !== undefined) {
      promise
        .then((_) => {
          console.log('Autoplay started!');
          // Autoplay started!
        })
        .catch(() => {
          console.log('Autoplay was prevented.');
          // Autoplay was prevented.
          // Show a "Play" button so that user can start playback.
        });
    }
  }
}

FileImage$1.registerLoader('mp4|ogg', LDRVideo);
Registry.register('LDRVideo', LDRVideo);

/* eslint-disable prefer-promise-reject-errors */

/**
 * Class representing a GIF image.
 *
 * ```
 * const image = new GIFImage()
 * image.getParameter('FilePath').setUrl("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.gif")
 * ```
 *
 * **Parameters**
 * * **StreamAtlasDesc:**
 * * **StreamAtlasIndex:**
 *
 * **Events**
 * * **loaded:** Triggered when the gif data is loaded.
 *
 * **File Types:** gif
 *
 * @extends FileImage
 */
class GIFImage extends FileImage$1 {
  /**
   * Create a GIF image.
   * @param {string} name - The name value.
   * @param {string|object} filePath - The filePath value.
   * @param {object} params - The params value.
   */
  constructor(name, filePath = '', params = {}) {
    super(name, filePath, params);

    this.format = 'RGBA';
    this.type = 'UNSIGNED_BYTE';
    this.__streamAtlas = true;
    // this.getParameter('FilePath').setSupportedExts('gif')

    this.addParameter(new Vec4Parameter('StreamAtlasDesc'));
    this.addParameter(new NumberParameter('StreamAtlasIndex', 0));

    const frameParam = this.getParameter('StreamAtlasIndex');
    frameParam.setRange([0, 1]);

    let playing;
    let frame = 0;
    const incrementFrame = (numFrames) => {
      frameParam.setValue(frame);
      if (playing) setTimeout(() => incrementFrame(numFrames), this.getFrameDelay(frame));
      frame = (frame + 1) % numFrames;
    };
    this.play = () => {
      this.__resourcePromise.then(() => {
        playing = true;
        const numFrames = frameParam.getRange()[1];
        incrementFrame(numFrames);
      });
    };
    this.stop = () => {
      playing = false;
    };
  }

  /**
   * The getFrameDelay method.
   * @param {number} index - The index value.
   * @return {number} - The return value.
   */
  getFrameDelay(index) {
    // Note: Frame delays are in centisecs (not millisecs which the timers will require.)
    return this.__unpackedData.frameDelays[index] * 10
  }

  /**
   * The __loadData method.
   * @param {object} fileDesc - The fileDesc value.
   * @private
   */
  __loadData(fileDesc) {
    // this.__streamAtlasDesc = new Vec4();

    const imageDataLibrary = FileImage$1.__imageDataLibrary();
    if (fileDesc.id in imageDataLibrary) {
      this.__resourcePromise = imageDataLibrary[fileDesc.id];
    } else {
      this.__resourcePromise = new Promise((resolve, reject) => {
        resourceLoader.addWork(fileDesc.id, 1);

        if (fileDesc.assets && fileDesc.assets.atlas) {
          const imageElem = new Image();
          imageElem.crossOrigin = 'anonymous';
          imageElem.src = fileDesc.assets.atlas.url;
          imageElem.addEventListener('load', () => {
            resolve({
              width: fileDesc.assets.atlas.width,
              height: fileDesc.assets.atlas.height,
              atlasSize: fileDesc.assets.atlas.atlasSize,
              frameDelays: fileDesc.assets.atlas.frameDelays,
              frameRange: [0, fileDesc.assets.atlas.frameDelays.length],
              imageData: imageElem,
            });
            resourceLoader.addWorkDone(fileDesc.id, 1);
          });
          return
        }

        loadBinfile(
          fileDesc.url,
          (data) => {
            console.warn('Unpacking Gif client side:' + fileDesc.name);

            const start = performance.now();

            // Decompressing using: https://github.com/matt-way/gifuct-js
            const gif = new GIF(data);
            const frames = gif.decompressFrames(true);

            // do something with the frame data
            const sideLength = Math.sqrt(frames.length);
            const atlasSize = [sideLength, sideLength];
            if (MathFunctions.fract(sideLength) > 0.0) {
              atlasSize[0] = Math.floor(atlasSize[0] + 1);
              if (MathFunctions.fract(sideLength) > 0.5) {
                atlasSize[1] = Math.floor(atlasSize[1] + 1);
              } else {
                atlasSize[1] = Math.floor(atlasSize[1]);
              }
            }

            const width = frames[0].dims.width;
            const height = frames[0].dims.height;

            // gif patch canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            // full gif canvas
            const gifCanvas = document.createElement('canvas');
            const gifCtx = gifCanvas.getContext('2d');

            gifCanvas.width = width;
            gifCanvas.height = height;

            // The atlas for all the frames.
            const atlasCanvas = document.createElement('canvas');
            const atlasCtx = atlasCanvas.getContext('2d');
            atlasCanvas.width = atlasSize[0] * width;
            atlasCanvas.height = atlasSize[1] * height;

            let frameImageData;
            const frameDelays = [];
            const renderFrame = (frame, index) => {
              const dims = frame.dims;

              // Note: the server side library returns centisecs (1/100 second) for
              // frame delays, so normalize here so that client and servers
              // valueus are in the
              frameDelays.push(frame.delay / 10);

              if (!frameImageData || dims.width != frameImageData.width || dims.height != frameImageData.height) {
                tempCanvas.width = dims.width;
                tempCanvas.height = dims.height;
                frameImageData = tempCtx.createImageData(dims.width, dims.height);
              }

              // set the patch data as an override
              frameImageData.data.set(frame.patch);
              tempCtx.putImageData(frameImageData, 0, 0);

              // Note: undocumented disposal method.
              // See Ids here: https://github.com/theturtle32/Flash-Animated-GIF-Library/blob/master/AS3GifPlayer/src/com/worlize/gif/constants/DisposalType.as
              // From what I can gather, 2 means we should clear the background first.
              // this seems to work with Gifs featuring moving transparency.
              // For fully opaque gifs, we should avoid this.
              if (frame.disposalType == 2) gifCtx.clearRect(0, 0, gifCanvas.width, gifCanvas.height);

              gifCtx.drawImage(tempCanvas, dims.left, dims.top);

              atlasCtx.drawImage(gifCanvas, (index % atlasSize[0]) * width, Math.floor(index / atlasSize[0]) * height);
            };

            for (let i = 0; i < frames.length; i++) {
              // console.log(frame);
              renderFrame(frames[i], i);
            }
            resourceLoader.addWorkDone(fileDesc.id, 1);

            const imageData = atlasCtx.getImageData(0, 0, atlasCanvas.width, atlasCanvas.height);

            const ms = performance.now() - start;
            console.log(`Decode GIF '${fileDesc.name}' time:` + ms);

            resolve({
              width: atlasCanvas.width,
              height: atlasCanvas.height,
              atlasSize,
              frameRange: [0, frames.length],
              frameDelays,
              imageData,
            });
          },
          (statusText) => {
            const msg = 'Unable to Load URL:' + statusText + ':' + fileDesc.url;
            console.warn(msg);
            reject(msg);
          }
        );
      });

      imageDataLibrary[fileDesc.id] = this.__resourcePromise;
    }

    this.__resourcePromise.then((unpackedData) => {
      this.width = unpackedData.width;
      this.height = unpackedData.height;

      this.getParameter('StreamAtlasDesc').setValue(
        new Vec4$1(unpackedData.atlasSize[0], unpackedData.atlasSize[1], 0, 0)
      );
      this.getParameter('StreamAtlasIndex').setRange(unpackedData.frameRange);

      this.__unpackedData = unpackedData;
      this.__data = unpackedData.imageData;

      // ////////////////////////
      // Playback
      this.__loaded = true;

      this.emit('loaded', {});
    });
  }
}

FileImage$1.registerLoader('gif', GIFImage);
Registry.register('GIFImage', GIFImage);

/**
 * Class representing a VLH image.
 *
 * **Parameters**
 * * **FilePath(`FilePathParameter`):** Used to specify the path to the file.
 *
 * **Events**
 * * **loaded:** Triggered when image data is loaded.
 * * **updated:** Triggered when image data is updated.
 *
 * @extends BaseImage
 */
class VLHImage extends BaseImage {
  /**
   * Create a VLH image.
   * @param {string} name - The name value.
   * @param {object} params - The params value.
   */
  constructor(name, params = {}) {
    let filepath;
    if (name != undefined && name.lastIndexOf('.') != -1) {
      filepath = name;
      name = name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.'));
    }
    super(name, params);

    this.__loaded = false;
    this.__exposure = 1.0;
    this.__ambientLightFactor = 0.0;
    this.__hdrtint = new Color(1, 1, 1, 1);
    this.__stream = 'stream' in params ? params['stream'] : false;
    this.type = 'FLOAT';

    const fileParam = this.addParameter(new FilePathParameter('FilePath'));
    fileParam.on('valueChanged', () => {
      this.loaded = false;

      if (this.getName() == '') {
        // Generate a name from the file path.
        const stem = fileParam.getStem();
        const decorator = stem.substring(stem.length - 1);
        if (!isNaN(decorator)) {
          // Note: ALL image names have an LOD specifier at the end.
          // remove that off when retrieving the name.
          this.setName(stem.substring(0, stem.length - 1));
        } else {
          this.setName(stem);
        }
      }

      const fileId = fileParam.getValue();
      const file = fileParam.getFile();
      this.__loadVLH(fileId, file);
    });

    if (filepath) {
      this.getParameter('FilePath').setFilepath(filepath);
    }
  }

  /**
   * Returns DOM Element.
   *
   * @return {HTMLElement} - The return value.
   */
  getDOMElement() {
    return this.__domElement
  }

  /**
   * Returns `FilePath` parameter's value.
   *
   * @return {string} - The return value.
   */
  getResourcePath() {
    return this.getParameter('FilePath').getValue()
  }

  /**
   * The __decodeData method.
   * @param {object} entries - The entries value.
   * @private
   */
  __decodeData(entries) {
    const ldr = entries.ldr;
    const cdm = entries.cdm;

    // ///////////////////////////////
    // Parse the data.
    const blob = new Blob([ldr.buffer]);
    const ldrPic = new Image();
    ldrPic.onload = () => {
      this.width = ldrPic.width;
      this.height = ldrPic.height;
      // console.log(resourcePath + ": [" + this.width + ", " + this.height + "]");
      this.__data = {
        ldr: ldrPic,
        cdm: cdm,
      };
      if (!this.__loaded) {
        this.__loaded = true;
        this.emit('loaded', {});
      } else {
        this.emit('updated', {});
      }
    };
    ldrPic.src = URL.createObjectURL(blob);
  }

  /**
   * The __loadVLH method.
   * @param {string} fileId - The fileId value.
   * @param {object} file - The file value.
   * @private
   */
  __loadVLH(fileId, file) {
    this.type = 'FLOAT';

    resourceLoader.loadUrl(fileId, file.url, (entries) => {
      if (!entries.ldr || !entries.cdm) {
        for (const name in entries) {
          if (name.endsWith('.jpg')) {
            entries.ldr = entries[name];
            delete entries[name];
          } else if (name.endsWith('.bin')) {
            entries.cdm = entries[name];
            delete entries[name];
          }
        }
      }
      this.__decodeData(entries);
    });
  }

  /**
   * Returns if the data is a stream or not.
   *
   * @return {boolean} - The return value.
   */
  isStream() {
    return false
  }

  /**
   * Returns the status of the data, whether is loaded or not.
   *
   * @return {boolean} - The return value.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * Returns all parameters and class state values.
   *
   * @return {object} - The return value.
   */
  getParams() {
    const params = super.getParams();
    if (this.__loaded) {
      params['data'] = this.__data;
      params['exposure'] = this.__exposure;
    }
    return params
  }

  /**
   * The setHDRTint method.
   * @private
   * @param {Color} hdrtint - The hdrtint value.
   */
  setHDRTint(hdrtint) {
    this.__hdrtint = hdrtint;
  }

  /**
   * The getHDRTint method.
   * @private
   * @return {Color} - The return value.
   */
  getHDRTint() {
    return this.__hdrtint
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   */
  toJSON(context) {}

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context) {}

  /**
   * Sets state of current Image using a binary reader object, and adds it to the resource loader.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    // super.readBinary(reader, context);
    this.setName(reader.loadStr());
    const resourcePath = reader.loadStr();
    if (typeof resourcePath === 'string' && resourcePath != '') {
      if (context.lod >= 0) {
        const suffixSt = resourcePath.lastIndexOf('.');
        if (suffixSt != -1) {
          const lodPath = resourcePath.substring(0, suffixSt) + context.lod + resourcePath.substring(suffixSt);
          if (resourceLoader.resourceAvailable(lodPath)) {
            resourcePath = lodPath;
          }
        }
      }
      this.getParameter('FilePath').setValue(resourcePath);
    }
  }
}

Registry.register('VLHImage', VLHImage);

/* eslint-disable new-cap */

const EnvMapMapping = {
  LATLONG: 1,
  OCTAHEDRAL: 2,
};

const step = (edge, x) => (x < edge ? 0.0 : 1.0);

function sum_vec2(value) {
  return value.dot(new Vec2(1.0, 1.0))
}
function abs_vec2(value) {
  return new Vec2(Math.abs(value.x), Math.abs(value.y))
}
function max_vec2(vec, value) {
  return new Vec2(Math.max(vec.x, value), Math.max(vec.y, value))
}
function abs_vec3(value) {
  return new Vec3$1(Math.abs(value.x), Math.abs(value.y), Math.abs(value.z))
}
function sectorize_vec2(value) {
  return new Vec2(step(0.0, value.x) * 2.0 - 1.0, step(0.0, value.y) * 2.0 - 1.0)
}
function sectorize_vec3(value) {
  return new Vec3$1(step(0.0, value.x) * 2.0 - 1.0, step(0.0, value.y) * 2.0 - 1.0, step(0.0, value.z) * 2.0 - 1.0)
}

function latLongUVsFromDir(dir) {
  // Math function taken from...
  // http://gl.ict.usc.edu/Data/HighResProbes/
  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]
  const phi = Math.acos(dir.z);
  const theta = Math.atan2(dir.x, -dir.y);
  return new Vec2((1 + theta / Math.PI) / 2, phi / Math.PI)
}

// Note: when u == 0.5 z = 1
function dirFromLatLongUVs(u, v) {
  // http://gl.ict.usc.edu/Data/HighResProbes/
  const theta = Math.PI * (u * 2 - 1);
  const phi = Math.PI * v;
  return new Vec3$1(sin(phi) * sin(theta), -sin(phi) * cos(theta), cos(phi))
}

function dirToSphOctUv(normal) {
  const aNorm = abs_vec3(normal);
  const sNorm = sectorize_vec3(normal);
  const aNorm_xy = new Vec2(aNorm.x, aNorm.y);

  let dir = max_vec2(aNorm_xy, 1e-20);
  const orient = Math.atan2(dir.x, dir.y) / (Math.PI * 0.5);

  dir = max_vec2(new Vec2(aNorm.z, aNorm_xy.length()), 1e-20);
  const pitch = Math.atan2(dir.y, dir.x) / (Math.PI * 0.5);

  let uv = new Vec2(sNorm.x * orient, sNorm.y * (1.0 - orient));
  uv.scaleInPlace(pitch);

  if (normal.z < 0.0) {
    const ts = new Vec2(uv.y, uv.x);
    const sNorm_xy = new Vec2(sNorm.x, sNorm.y);
    uv = sNorm_xy.subtract(abs_vec2(ts).multiply(sNorm_xy));
  }
  return uv.scale(0.5).add(new Vec2(0.5, 0.5))
}

function sphOctUvToDir(uv) {
  uv = uv.scale(2).subtract(new Vec2(1, 1));
  const suv = sectorize_vec2(uv);
  const sabsuv = sum_vec2(abs_vec2(uv));
  const pitch = sabsuv * Math.PI * 0.5;

  if (pitch <= 0.0) {
    return new Vec3$1(0.0, 0.0, 1.0)
  }
  if (Math.abs(pitch - Math.PI) < 0.000001) {
    return new Vec3$1(0.0, 0.0, -1.0)
  }
  if (sabsuv > 1.0) {
    const ts = Vec2(uv.y, uv.x);
    uv = abs_vec2(ts).negate().add(new Vec2(1, 1)).multiply(suv);

    sabsuv = sum_vec2(abs_vec2(uv));
  }

  const orient = (Math.abs(uv.x) / sabsuv) * (Math.PI * 0.5);
  const sOrient = Math.sin(orient);
  const cOrient = Math.cos(orient);
  const sPitch = Math.sin(pitch);
  const cPitch = Math.cos(pitch);

  return new Vec3$1(sOrient * suv.x * sPitch, cOrient * suv.y * sPitch, cPitch)
}

/**
 * Class representing an environment map.
 * @extends VLHImage
 */
class EnvMap extends VLHImage {
  /**
   * Create an env map.
   * @param {string} name - The name value.
   * @param {object} params - The params value.
   */
  constructor(name, params = {}) {
    super(name, params);

    this.mapping = EnvMapMapping.OCTAHEDRAL;
  }

  /**
   * The __decodeData method.
   * @param {object} entries - The entries value.
   * @private
   */
  __decodeData(entries) {
    super.__decodeData(entries);

    const samples = entries.samples;

    if (samples) {
      if (window.TextDecoder) this.__sampleSets = JSON.parse(new TextDecoder('utf-8').decode(samples));
      else this.__sampleSets = JSON.parse(decodeText(samples));

      if (this.__sampleSets.luminanceThumbnail)
        this.__thumbSize = Math.sqrt(this.__sampleSets.luminanceThumbnail.length);
    }
  }

  /**
   * The getSampleSets method.
   * @return {object} - The return value.
   */
  getSampleSets() {
    return this.__sampleSets
  }

  /**
   * The uvToDir method.
   * @param {Vec2} uv - The uv value.
   * @return {Vec2|Vec3} - The return value.
   */
  uvToDir(uv) {
    switch (this.mapping) {
      case EnvMapMapping.LATLONG:
        return dirFromLatLongUVs(uv)
      case EnvMapMapping.OCTAHEDRAL:
        return sphOctUvToDir(uv)
    }
  }

  /**
   * Converts position into UV.
   *
   * @param {Vec2|Vec3} dir - The dir value.
   * @return {Vec2} - The return value.
   */
  dirToUv(dir) {
    switch (this.mapping) {
      case EnvMapMapping.LATLONG:
        return latLongUVsFromDir(dir)
      case EnvMapMapping.OCTAHEDRAL:
        return dirToSphOctUv(dir)
    }
  }

  /**
   * Converts a `Vec2` into luminance.
   *
   * @param {Vec2} uv - The uv value.
   * @return {number} - The return value.
   */
  uvToLuminance(uv) {
    const thmbPixel = Math.floor(uv.y * this.__thumbSize) * this.__thumbSize + Math.floor(uv.x * this.__thumbSize);
    return this.__sampleSets.luminanceThumbnail[thmbPixel]
  }

  /**
   * Converts `Vec2` coordinates into luminance.
   *
   * @param {object} dir - The dir value.
   * @return {number} - The return value.
   */
  dirToLuminance(dir) {
    return this.uvToLuminance(this.dirToUv(dir))
  }
}

Registry.register('EnvMap', EnvMap);

// eslint-disable-next-line require-jsdoc
function getLanguage() {
  if (!globalThis.navigator) return 'en'

  // Check if a language is explicitly selected.
  const searchParams = new URLSearchParams(window.location.search);
  if (searchParams.has('lang')) return searchParams.get('lang')

  const nav = window.navigator;
  const browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'];
  let i;
  let language;

  const clean = (language) => {
    if (language.startsWith('en')) return 'En'
    else if (language.startsWith('es')) return 'Es'
    else if (language.startsWith('fr')) return 'Fr'
    else if (language.startsWith('gb') || language.startsWith('de')) return 'Gb'
    return language
  };

  // support for HTML 5.1 "navigator.languages"
  if (Array.isArray(nav.languages)) {
    for (i = 0; i < nav.languages.length; i++) {
      language = nav.languages[i];
      if (language && language.length) {
        return clean(language)
      }
    }
  }

  // support for other well known properties in browsers
  for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
    language = nav[browserLanguagePropertyKeys[i]];
    if (language && language.length) {
      return clean(language)
    }
  }

  return null
}

/** Class representing a label manager.
 * @private
 */
class LabelManager extends EventEmitter {
  /**
   * Create a label manager.
   */
  constructor() {
    super();
    this.__labelLibraries = {};

    this.__language = getLanguage();
    this.__foundLabelLibraries = {};
  }

  /**
   * Load a label library into the manager.
   * @param {string} name - The name of the library.
   * @param {json} json - The json data of of the library.
   */
  loadLibrary(name, url) {
    const stem = name.substring(0, name.lastIndexOf('.'));
    this.__foundLabelLibraries[stem] = url;

    if (name.endsWith('.labels')) {
      loadTextfile(url, (text) => {
        this.__labelLibraries[stem] = JSON.parse(text);
        this.emit('labelLibraryLoaded', { library: stem });
      });
    } else if (name.endsWith('.xlsx') && globalThis.navigator && window.XLSX) {
      // Note: example taken from here..
      // https://stackoverflow.com/questions/8238407/how-to-parse-excel-file-in-javascript-html5
      // and here:
      // https://github.com/SheetJS/js-xlsx/tree/master/demos/xhr
      loadBinfile(file.url, (data) => {
        const unit8array = new Uint8Array(data);
        const workbook = XLSX.read(unit8array, {
          type: 'array',
        });
        const json = {};
        workbook.SheetNames.forEach(function (sheetName) {
          // Here is your object
          const rows = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName]);
          rows.forEach(function (row) {
            const identifier = row.Identifier;
            delete row.Identifier;
            json[identifier] = row;
          });
        });

        this.__labelLibraries[stem] = json;
        this.emit('labelLibraryLoaded', { library: stem });
      });
    }
  }

  /**
   * Checks if the library is found.
   * @param {string} name - The name of the library.
   * @return {boolean} - Returns true if the library is found.
   */
  isLibraryFound(name) {
    return name in this.__foundLabelLibraries
  }

  /**
   * Checks if the library is loaded.
   * @param {string} name - The name of the library.
   * @return {boolean} - Returns true if the library is loaded.
   */
  isLibraryLoaded(name) {
    return name in this.__labelLibraries
  }

  /**
   * The getLabelText method.
   * @param {string} libraryName - The name of the library.
   * @param {string} labelName - The name of the label.
   * @return {string} - The return value.
   */
  getLabelText(libraryName, labelName) {
    const library = this.__labelLibraries[libraryName];
    if (!library) {
      throw new Error(
        "LabelLibrary: '" +
          libraryName +
          "' not found in LabelManager. Found: [" +
          Object.keys(this.__labelLibraries) +
          ']'
      )
    }
    const label = library[labelName];
    if (!label) {
      throw new Error(
        "Label: '" +
          labelName +
          "' not found in LabelLibrary: '" +
          libraryName +
          "'. Found: [" +
          Object.keys(library) +
          ']'
      )
    }
    const labelText = label[this.__language];
    if (!labelText) {
      if (label['En']) return label['En']
      throw new Error("labelText: '" + language + "' not found in Label. Found: [" + Object.keys(label) + ']')
    }
    return labelText
  }

  /**
   * The setLabelText method.
   * @param {string} libraryName - The name of the library.
   * @param {string} labelName - The name of the label.
   * @param {string} labelText - The text of the label.
   */
  setLabelText(libraryName, labelName, labelText) {
    let library = this.__labelLibraries[libraryName];
    if (!library) {
      library = {};
      this.__labelLibraries[libraryName] = library;
    }
    let label = library[labelName];
    if (!label) {
      label = {};
      library[labelName] = label;
    }
    label[this.__language] = labelText;
    // TODO: Push to server.
  }

  setLanguage(ln) {
    this.__language = ln;
  }
}

const labelManager = new LabelManager();

/* eslint-disable guard-for-in */

// http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
/**
 * Draws a rounded rectangle using the current state of the canvas.
 * If you omit the last three params, it will draw a rectangle
 * outline with a 5 pixel border radius
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x - The top left x coordinate
 * @param {Number} y - The top left y coordinate
 * @param {Number} width - The width of the rectangle
 * @param {Number} height - The height of the rectangle
 * @param {Number} [radius = 5] - The corner radius; It can also be an object
 *                 to specify different radii for corners
 * @param {Number} [radius.tl = 0] - Top left
 * @param {Number} [radius.tr = 0] - Top right
 * @param {Number} [radius.br = 0] - Bottom right
 * @param {Number} [radius.bl = 0] - Bottom left
 * @param {Boolean} [fill = false] - Whether to fill the rectangle.
 * @param {Boolean} [stroke = true] - Whether to stroke the rectangle.
 * @param {Number} [strokeWidth] - The strokeWidth param.
 * @private
 */
function roundRect(ctx, x, y, width, height, radius, fill, stroke, strokeWidth) {
  if (typeof stroke == 'undefined') {
    stroke = true;
  }
  if (typeof radius === 'undefined') {
    radius = 5;
  }
  if (typeof radius === 'number') {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius,
    };
  } else {
    const defaultRadius = {
      tl: 0,
      tr: 0,
      br: 0,
      bl: 0,
    };
    for (const side in defaultRadius) {
      radius[side] = radius[side] || defaultRadius[side];
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + height - radius.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
  ctx.lineTo(x + radius.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();
  if (fill) {
    ctx.fill();
  }
  if (stroke) {
    ctx.lineWidth = strokeWidth;
    ctx.stroke();
  }
}

/**
 * Represents a 2D label item the scene.
 * Since displaying text in the scene is not an easy task,
 * we've abstracted the complicated logic behind this class, transforming any text into a 2D image(`DataImage`).
 *
 * **Library List**
 * * LabelPack
 *
 * **Parameters**
 * * **Library(`StringParameter`):** Library you wan to use for your label, see **Library List** above.
 * * **Text(`StringParameter`):**
 * * **FontColor(`ColorParameter`):**
 * * **Margin(`NumberParameter`):**
 * * **BorderWidth(`NumberParameter`):**
 * * **BorderRadius(`NumberParameter`):**
 * * **Outline(`BooleanParameter`):**
 * * **OutlineColor(`BooleanParameter`):**
 * * **Background(`BooleanParameter`):**
 * * **ColorParameter(`BackgroundColor`):**
 * * **FillBackground(`BooleanParameter`):**
 * * **StrokeBackgroundOutline(`BooleanParameter`):**
 * * **FontSize(`NumberParameter`):** Represents FontSize of the label
 * * **Font(`StringParameter`):**
 *
 * **Events**
 * * **loaded:** Triggered when label's data is loaded.
 * * **updated:** Triggered when label's data changes.
 * * **labelRendered:** Triggered when the text image is rendered. Contains `width`, `height` and data of the image.
 *
 * @extends DataImage
 */
class Label extends DataImage {
  /**
   * Creates a label instance. Creating a canvas element that hosts the specified text.
   *
   * @param {string} name - The name value.
   * @param {string} library - The library value.
   */
  constructor(name, library) {
    super(name);

    this.__canvasElem = document.createElement('canvas');
    const fontSize = 22;

    const libraryParam = this.addParameter(new StringParameter('Library'));
    this.addParameter(new StringParameter('Text', ''));
    // or load the label when it is loaded.

    // const setLabelTextToLibrary = ()=>{
    //     const library = libraryParam.getValue();
    //     const name = this.getName();
    //     const text = textParam.getValue();
    //     labelManager.setLabelTextToLibrary(library, name, text);
    // }
    // textParam.on('valueChanged', setLabelText);

    this.addParameter(new ColorParameter('FontColor', new Color(0, 0, 0)));
    // this.addParameter(new StringParameter('TextAlign', 'left'))
    // this.addParameter(MultiChoiceParameter('TextAlign', 0, ['left', 'right']));
    // this.addParameter(new BooleanParameter('FillText', true))
    this.addParameter(new NumberParameter('Margin', fontSize * 0.5));
    this.addParameter(new NumberParameter('BorderWidth', 2));
    this.addParameter(new NumberParameter('BorderRadius', fontSize * 0.5));
    this.addParameter(new BooleanParameter('Outline', false));
    this.addParameter(new BooleanParameter('OutlineColor', new Color(0, 0, 0)));
    this.addParameter(new BooleanParameter('Background', true));
    this.addParameter(new ColorParameter('BackgroundColor', new Color('#FBC02D')));
    this.addParameter(new BooleanParameter('FillBackground', true));
    this.addParameter(new BooleanParameter('StrokeBackgroundOutline', true));
    this.addParameter(new NumberParameter('FontSize', 22));
    this.addParameter(new StringParameter('Font', 'Helvetica'));

    const reload = () => {
      this.loadLabelData();
    };
    this.on('nameChanged', reload);

    if (library) libraryParam.setValue(library);

    this.__requestedRerender = false;
    this.__needsRender = false;
    this.loadLabelData();
  }

  /**
   * This method can be overridden in derived classes
   * to perform general updates (see GLPass or BaseItem).
   *
   * @param {object} event - The event object.
   * @private
   */
  __parameterValueChanged(event) {
    super.__parameterValueChanged(event);
    if (!this.__requestedRerender) {
      this.__requestedRerender = true;
      this.loadLabelData();
    }
  }

  /**
   * Method in charge of basically do everything, set text, load/update it, get the library, load the font, etc.
   */
  loadLabelData() {
    const onLoaded = () => {
      this.__requestedRerender = false;
      this.__needsRender = true;
      if (!this.__loaded) {
        this.__loaded = true;
        this.emit('loaded', {});
      } else {
        this.emit('updated', {});
      }
    };

    const loadText = () => {
      return new Promise((resolve) => {
        const library = this.getParameter('Library').getValue();
        if (library == '') {
          resolve();
          return
        }
        if (!labelManager.isLibraryFound(library)) {
          console.warn('Label Libary not found:', library);
          resolve();
          return
        }
        const getLibraryText = () => {
          try {
            const name = this.getName();
            // console.log("Text Loaded:" + name);
            const text = labelManager.getLabelText(library, name);
            this.getParameter('Text').setValue(text);
          } catch (e) {
            // Note: if the text is not found in the labels pack
            // an exception is thrown, and we catch it here.
            console.warn(e);
          }
          resolve();
        };
        if (!labelManager.isLibraryLoaded(library)) {
          labelManager.on('labelLibraryLoaded', (event) => {
            const loadedLibrary = event.library;
            if (loadedLibrary == library) getLibraryText();
          });
        } else {
          getLibraryText();
        }
      })
    };
    const loadFont = () => {
      return new Promise((resolve) => {
        if (document.fonts != undefined) {
          const font = this.getParameter('Font').getValue();
          const fontSize = this.getParameter('FontSize').getValue();
          document.fonts.load(fontSize + 'px "' + font + '"').then(() => {
            // console.log("Font Loaded:" + font);
            resolve();
          });
        } else {
          resolve();
        }
      })
    };
    Promise.all([loadText(), loadFont()]).then(onLoaded);
  }

  /**
   * Renders the label text to a canvas element ready to display.
   * Here is where all parameters are applied to the canvas containing the text,
   * then the image data is extracted from the canvas context.
   */
  renderLabelToImage() {
    // console.log("renderLabelToImage")
    const ctx2d = this.__canvasElem.getContext('2d', {
      alpha: true,
    });

    let text = this.getParameter('Text').getValue();
    if (text == '') text = this.getName();

    const font = this.getParameter('Font').getValue();
    const fontColor = this.getParameter('FontColor').getValue();
    const textAlign = 'left'; // this.getParameter('TextAlign').getValue()
    const fontSize = this.getParameter('FontSize').getValue();
    const margin = this.getParameter('Margin').getValue();
    const borderWidth = this.getParameter('BorderWidth').getValue();
    const borderRadius = this.getParameter('BorderRadius').getValue();
    const outline = this.getParameter('Outline').getValue();
    const outlineColor = this.getParameter('OutlineColor').getValue();
    const background = this.getParameter('Background').getValue();
    const backgroundColor = this.getParameter('BackgroundColor').getValue();
    const fillBackground = this.getParameter('FillBackground').getValue();
    const strokeBackgroundOutline = this.getParameter('StrokeBackgroundOutline').getValue();

    // let ratio = devicePixelRatio / backingStoreRatio;
    const marginAndBorder = margin + borderWidth;
    const lines = text.split('\n');

    ctx2d.font = fontSize + 'px "' + font + '"';
    // console.log("renderLabelToImage:" + ctx2d.font);
    let width = 0;
    lines.forEach((line) => {
      width = Math.max(ctx2d.measureText(line).width, width);
    });
    const fontHeight = fontSize; // parseInt(fontSize)
    this.width = Math.ceil(width + marginAndBorder * 2);
    this.height = Math.ceil(fontHeight * lines.length + marginAndBorder * 2);
    ctx2d.canvas.width = this.width;
    ctx2d.canvas.height = this.height;
    this.__canvasElem.width = this.width;
    this.__canvasElem.height = this.height;

    // ctx2d.clearRect(0, 0, this.width, this.height);
    ctx2d.fillStyle = 'rgba(0, 0, 0, 0.0)';
    ctx2d.fillRect(0, 0, this.width, this.height);

    if (background) {
      ctx2d.fillStyle = backgroundColor.toHex();
      ctx2d.strokeStyle = outlineColor.toHex();
      roundRect(
        ctx2d,
        borderWidth,
        borderWidth,
        this.width - borderWidth * 2,
        this.height - borderWidth * 2,
        borderRadius,
        fillBackground,
        strokeBackgroundOutline,
        borderWidth
      );
    }

    ctx2d.font = fontSize + 'px "' + font + '"';
    ctx2d.textAlign = textAlign;
    ctx2d.fillStyle = fontColor.toHex();
    ctx2d.textBaseline = 'hanging';
    lines.forEach((line, index) => {
      ctx2d.fillText(line, marginAndBorder, marginAndBorder + index * fontHeight);
    });

    if (outline) {
      ctx2d.strokeStyle = outlineColor.toHex();
      ctx2d.lineWidth = 1.5;
      ctx2d.strokeText(text, marginAndBorder, marginAndBorder);
    }

    this.__data = ctx2d.getImageData(0, 0, this.width, this.height);
    this.__needsRender = false;
    this.emit('labelRendered', {
      width: this.width,
      height: this.height,
      data: this.__data,
    });
  }

  /**
   *  Returns all parameters and class state values(Including data).
   *
   * @return {object} - The return value.
   */
  getParams() {
    if (this.__needsRender) this.renderLabelToImage();
    return super.getParams()
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);
    this.__getLabelText();
  }
}

Registry.register('Label', Label);

/** Class representing a 2D video stream image.
 * @private
 * @extends BaseImage
 */
class VideoStreamImage2D extends BaseImage {
  /**
   * Create a 2D video stream image.
   */
  constructor() {
    super();
    this.__loaded = false;
  }

  /**
   * The connectWebcam method.
   * @param {number} width - The width of the video.
   * @param {number} height - The height of the video.
   * @param {false} rearCamera - Boolean determining if it is a rear camera or not.
   */
  connectWebcam(width, height, rearCamera = false) {
    const video = {
      width,
      height,
      frameRate: {
        ideal: 60,
        max: 60,
      },
    };
    if (rearCamera) {
      video.facingMode = {
        exact: 'environment',
      };
    } else {
      video.facingMode = {
        facingMode: 'user',
      };
    }

    const domElement = document.createElement('video');
    // TODO - confirm its necessary to add to DOM
    domElement.style.display = 'none';
    domElement.preload = 'auto';
    domElement.crossOrigin = 'anonymous';
    // domElement.crossorigin = true;
    document.body.appendChild(domElement);

    // List cameras and microphones.
    // navigator.mediaDevices.enumerateDevices()
    //     .then((devices)=>{
    //         // devices.forEach((device)=>{
    //         //     if (device.kind == "videoinput") {
    //         //         console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
    //         //         videoinputs.push(device);
    //         //     }
    //         // });

    //     })
    //     .catch(function(err) {
    //         console.log(err.name + ": " + err.message);
    //     });

    navigator.mediaDevices
      .getUserMedia({
        audio: false,
        video,
      })
      .then((mediaStream) => {
        domElement.srcObject = mediaStream;
        domElement.onloadedmetadata = (e) => {
          domElement.play();

          this.width = domElement.videoWidth;
          this.height = domElement.videoHeight;
          console.log('Webcam:[' + this.width + ', ' + this.height + ']');
          this.__data = domElement;
          this.__loaded = true;
          this.emit('loaded', {});

          let prevFrame = 0;
          const frameRate = 60;
          const timerCallback = () => {
            if (domElement.paused || domElement.ended) {
              return
            }
            // Check to see if the video has progressed to the next frame.
            // If so, then we emit and update, which will cause a redraw.
            const currentFrame = Math.floor(domElement.currentTime * frameRate);
            if (prevFrame != currentFrame) {
              this.emit('updated', {});
              prevFrame = currentFrame;
            }
            setTimeout(timerCallback, 20); // Sample at 50fps.
          };
          timerCallback();
        };
      })
      .catch(function (err) {
        /* handle the error */
      });
  }

  /**
   * The setVideoStream method.
   * @param {any} video - The video value.
   */
  setVideoStream(video) {
    this.__loaded = false;
    this.width = video.videoWidth;
    this.height = video.videoHeight;
    this.start();
    this.__data = video;
    this.__loaded = true;
    this.emit('loaded', {});
  }

  // getAudioSource() {
  //     return this.__data;
  // }

  /**
   * The stop method.
   */
  stop() {
    clearInterval(this.__intervalId);
  }

  /**
   * The start method.
   */
  start() {
    this.__intervalId = setInterval(() => {
      this.emit('updated', {});
    }, 20); // Sample at 50fps.
  }

  /**
   * The isLoaded method.
   * @return {boolean} - The return value.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * The getParams method.
   * @return {any} - The return value.
   */
  getParams() {
    return {
      type: this.type,
      format: this.format,
      width: this.width,
      height: this.height,
      data: this.__data,
      flipY: this.getParameter('FlipY').getValue(),
    }
  }
}

Registry.register('VideoStreamImage2D', VideoStreamImage2D);

/** Class representing an operator input.
 */
class OperatorInput {
  /**
   * Create an operator input.
   * @param {string} name - The name value.
   */
  constructor(name) {
    this.__name = name;
    this._param = undefined;
    this._paramValueChanged = this._paramValueChanged.bind(this);
  }

  /**
   * The getName method.
   * @return {any} - The return value.
   */
  getName() {
    return this.__name
  }

  /**
   * Sets operator that owns this input. Called by the operator when adding inputs
   * @param {Operator} op - The operator object.
   */
  setOperator(op) {
    this._op = op;
  }

  /**
   * Returns operator that owns this input.
   * @return {Operator} - The operator object.
   */
  getOperator() {
    return this._op
  }

  /**
   * Returns true if this input is connected to a parameter.
   * @return {boolean} - The return value.
   */
  isConnected() {
    return this._param != undefined
  }

  /**
   * The getParam method.
   * @return {any} - The return value.
   */
  getParam() {
    return this._param
  }

  /**
   * @private
   * The handler function for when the input paramter changes.
   * @param {object} event - The event object.
   */
  _paramValueChanged(event) {
    if (this._op) this._op.setDirty(this.__name);
  }

  /**
   * Assigns the Paramter to be used to provide the input value.
   * @param {Parameter} param - The param value.
   */
  setParam(param) {
    if (this._param) {
      this._param.off('valueChanged', this._paramValueChanged);
    }
    this._param = param;
    if (this._param) {
      this._param.on('valueChanged', this._paramValueChanged);
    }
  }

  /**
   * The getValue method.
   * @return {any} - The return value.
   */
  getValue() {
    if (this._param) return this._param.getValue()
  }

  /**
   * The setValue method.
   * @param {any} value - The value param.
   */
  setValue(value) {
    if (this._param) {
      this._param.setValue(value);
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const paramPath = this._param ? this._param.getPath() : '';
    return {
      name: this.__name,
      paramPath: context && context.makeRelative ? context.makeRelative(paramPath) : paramPath,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.paramPath) {
      // Note: the tree should have fully loaded by the time we are loading operators
      // even new items and groups should have been created. Operators and state machines
      // are loaded last.
      context.resolvePath(
        j.paramPath,
        (param) => {
          this.setParam(param);
        },
        (reason) => {
          console.warn("OperatorInput: '" + this.getName() + "'. Unable to connect to:" + j.paramPath);
        }
      );
    }
  }

  /**
   * The detach method is called when an operator is being removed from the scene tree.
   * It removes all connections to parameters in the scene.
   */
  detach() {
    // This function is called when we want to suspend an operator
    // from functioning because it is deleted and on the undo stack.
    // Once operators have persistent connections,
    // we will simply uninstall the output from the parameter.
    if (this._param) {
      this._param.off('valueChanged', this._paramValueChanged);
    }
  }

  /**
   * The reattach method can be called when re-instating an operator in the scene.
   */
  reattach() {
    this.detached = false;
    if (this._param) {
      this._param.on('valueChanged', this._paramValueChanged);
    }
  }
}

/** Class representing an operator output.
 */
class OperatorOutput {
  /**
   * Create an operator output.
   * @param {string} name - The name value.
   * @param {OperatorOutputMode} operatorOutputMode - The mode which the OperatorOutput uses to bind to its target parameter.
   */
  constructor(name, operatorOutputMode = OperatorOutputMode.OP_WRITE) {
    this.__name = name;
    this._mode = operatorOutputMode;
    this._param = undefined;
    this._paramBindIndex = -1;
    this.detached = false;
  }

  /**
   * Returns name of the output.
   * @return {string} - The name string.
   */
  getName() {
    return this.__name
  }

  /**
   * Sets operator that owns this output. Called by the operator when adding outputs
   * @param {Operator} op - The operator object.
   */
  setOperator(op) {
    this._op = op;
  }

  /**
   * Returns operator that owns this output.
   * @return {Operator} - The operator object.
   */
  getOperator() {
    return this._op
  }

  /**
   * Returns mode that the output writes to be parameter. Must be a number from OperatorOutputMode
   * @return {OperatorOutputMode} - The mode value.
   */
  getMode() {
    return this._mode
  }

  /**
   * Returns true if this output is connected to a parameter.
   * @return {boolean} - The return value.
   */
  isConnected() {
    return this._param != undefined
  }

  /**
   * The getParam method.
   * @return {any} - The return value.
   */
  getParam() {
    return this._param
  }

  /**
   * Sets the Parameter for this out put to write to.
   * @param {Parameter} param - The param value.
   */
  setParam(param, index = -1) {
    if (this._param) {
      this._param.unbindOperator(this, index);
    }
    this._param = param;
    if (this._param) {
      this._paramBindIndex = this._param.bindOperatorOutput(this, index);
    }
  }

  /**
   * Returns the index of the binding on the parameter of this OperatorOutput
   * up to date.
   * @return {number} index - The index of the binding on the parameter.
   */
  getParamBindIndex() {
    return this._paramBindIndex
  }

  /**
   * If bindings change on a Parameter, it will call this method to ensure the output index is
   * up to date.
   * @param {number} index - The index of the binding on the parameter.
   */
  setParamBindIndex(index) {
    this._paramBindIndex = index;
  }

  /**
   * Propagates dirty to the connected parameter.
   */
  setDirty() {
    if (this._param) {
      this._param.setDirty(this._paramBindIndex);
    }
  }

  /**
   * The getValue method.
   * @return {any} - The return value.
   */
  getValue() {
    if (this._param) {
      return this._param.getValueFromOp(this._paramBindIndex)
    } else {
      throw new Error('Cannot call getValue on OperatorOutput that is not connected:', this.__name)
    }
  }

  /**
   * When the value on a Parameter is modified by a user by calling 'setValue,
   * then if any operators are bound, the value of the Parameter cannot be modified
   * directly as it is the result of a computation. Instead, the Parameter calls
   * 'backPropagateValue' on the Operator to cause the Operator to handle propagating
   * the value to one or more of its inputs.
   * to its inputs.
   * @param {any} value - The value param.
   * @return {any} - The modified value.
   */
  backPropagateValue(value) {
    if (this._param) {
      value = this._op.backPropagateValue(value, this);
    }
    return value
  }

  /**
   * The setClean method.
   * @param {any} value - The value param.
   */
  setClean(value) {
    if (this._param) {
      this._param.setCleanFromOp(value, this._paramBindIndex);
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const paramPath = this._param ? this._param.getPath() : '';
    return {
      name: this.__name,
      paramPath: context && context.makeRelative ? context.makeRelative(paramPath) : paramPath,
      paramBindIndex: this._paramBindIndex,
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    if (j.paramPath) {
      // Note: the tree should have fully loaded by the time we are loading operators
      // even new items and groups should have been created. Operators and state machines
      // are loaded last.
      context.resolvePath(
        j.paramPath,
        (param) => {
          this.setParam(param, j.paramBindIndex);
        },
        (reason) => {
          console.warn("OperatorOutput: '" + this.getName() + "'. Unable to connect to:" + j.paramPath);
        }
      );
    }
  }

  /**
   * The detach method is called when an operator is being removed from the scene tree.
   * It removes all connections to parameters in the scene.
   */
  detach() {
    // This function is called when we want to suspend an operator
    // from functioning because it is deleted and on the undo stack.
    // Once operators have persistent connections,
    // we will simply uninstall the output from the parameter.
    this.detached = true;
    this._paramBindIndex = this._param.unbindOperator(this);
  }

  /**
   * The reattach method can be called when re-instating an operator in the scene.
   */
  reattach() {
    this.detached = false;
    this._paramBindIndex = this._param.bindOperatorOutput(this, this._paramBindIndex);
  }

  /**
   * The rebind rebinds the outputs to be at the top of the stack for its parameter.
   */
  rebind() {
    if (this._param) {
      this._param.unbindOperator(this);
      this._paramBindIndex = this._param.bindOperatorOutput(this);
    }
  }
}

/**
 * Class representing an operator.
 *
 * @extends BaseItem
 */
class Operator extends BaseItem {
  /**
   * Create an operator.
   * @param {string} name - The name value.
   */
  constructor(name) {
    super(name);
    this.__inputs = new Map();
    this.__outputs = new Map();
  }

  /**
   * This method sets the state of the operator to dirty which propagates
   * to the outputs of this operator, and which may then propagate to other
   * operators. When the scene is cleaned, which usually is caused by rendering
   * then the chain of operators are cleaned by triggering evaluation.
   * @private
   */
  setDirty() {
    this.__outputs.forEach((output) => output.setDirty());
  }

  /**
   * This method can be overridden in derived classes
   * to perform general updates (see GLPass or BaseItem).
   *
   * @param {object} event
   * @private
   */
  __parameterValueChanged(event) {
    super.__parameterValueChanged(event);
    this.setDirty();
  }

  /**
   * The addInput method.
   * @param {string|OperatorInput} input - The name of the input, or the input object
   * @return {array} - The return value.
   */
  addInput(input) {
    if (typeof input == 'string') input = new OperatorInput(input);
    input.setOperator(this);
    this.__inputs.set(input.getName(), input);
    this.setDirty();
    return input
  }

  /**
   * The removeInput method.
   * @param {string|OperatorInput} input - The name of the input, or the input object
   */
  removeInput(input) {
    if (typeof input == 'string') input = this.getInput(input);
    if (!(input instanceof OperatorInput)) {
      throw new Error('Invalid parameter for removeInput:', input)
    }
    if (input.getParam()) input.setParam(null);
    this.__inputs.delete(input.getName());
  }

  /**
   * Getter for the number of inputs in this operator.
   * @return {number} - Returns the number of inputs.
   */
  getNumInputs() {
    return this.__inputs.size
  }

  /**
   * The getInputByIndex method.
   * @param {number} index - The index value.
   * @return {object} - The return value.
   */
  getInputByIndex(index) {
    return Array.from(this.__inputs.values())[index]
  }

  /**
   * The getInput method.
   * @param {string} name - The name value.
   * @return {OperatorInput} - The return value.
   */
  getInput(name) {
    return this.__inputs.get(name)
  }

  /**
   * The addOutput method.
   * @param {string|OperatorOutput} output - The name of the output, or the output object
   * @return {array} - The return value.
   */
  addOutput(output) {
    if (typeof output == 'string') output = new OperatorOutput(output);
    output.setOperator(this);
    if (this.getOutput(output.getName())) throw new Error(`Operator output already exists ${output.getName()}`)
    this.__outputs.set(output.getName(), output);
    this.setDirty();
    return output
  }

  /**
   * The removeOutput method.
   * @param {string|OperatorOutput} output - The name of the output, or the output object
   */
  removeOutput(output) {
    if (typeof output == 'string') output = this.getOutput(output);
    if (!(output instanceof OperatorOutput)) {
      throw new Error('Invalid parameter for removeOutput:', output)
    }
    if (output.getParam()) output.setParam(null);
    this.__outputs.delete(output.getName());
  }

  /**
   * Getter for the number of outputs in this operator.
   * @return {number} - Returns the number of outputs.
   */
  getNumOutputs() {
    return this.__outputs.size
  }

  /**
   * The getOutputByIndex method.
   * @param {number} index - The index value.
   * @return {object} - The return value.
   */
  getOutputByIndex(index) {
    return Array.from(this.__outputs.values())[index]
  }

  /**
   * The getOutput method.
   * @param {string} name - The name value.
   * @return {OperatorOutput} - The return value.
   */
  getOutput(name) {
    return this.__outputs.get(name)
  }

  /**
   * The evaluate method.
   * Computes the values of each of the outputs based on the values of the inputs
   * and the values of outputs with mode OP_READ_WRITE.
   * This method must be implemented by all Operators.
   */
  evaluate() {
    throw new Error('Not yet implemented')
  }

  /**
   * When the value on a Parameter is modified by a user by calling 'setValue,
   * then if any operators are bound, the value of the Parameter cannot be modified
   * directly as it is the result of a computation. Instead, the Parameter calls
   * 'backPropagateValue' on the Operator to cause the Operator to handle propagating
   * the value to one or more of its inputs.
   * to its inputs.
   * @param {any} value - The value param.
   * @return {any} - The modified value.
   */
  backPropagateValue(value) {
    // TODO: Implement me for custom manipulations.
    return value
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    j.type = Registry.getBlueprintName(this);

    const inputs = [];
    this.__inputs.forEach((input) => {
      inputs.push(input.toJSON(context));
    });
    j.inputs = inputs;

    const outputs = [];
    this.__outputs.forEach((output) => {
      outputs.push(output.toJSON(context));
    });
    j.outputs = outputs;
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);

    if (j.inputs) {
      j.inputs.forEach((inputJson, index) => {
        let input;
        if (inputJson.name) {
          input = this.getInput(inputJson.name);
          if (!input) {
            input = this.addInput(inputJson.name);
          }
        } else {
          input = this.getInputByIndex(index);
        }
        input.fromJSON(inputJson, context);
      });
    }
    if (j.outputs) {
      j.outputs.forEach((outputJson, index) => {
        let output;
        if (outputJson.name) {
          output = this.getOutput(outputJson.name);
          if (!output) {
            output = this.addOutput(outputJson.name);
          }
        } else {
          output = this.getOutputByIndex(index);
        }
        output.fromJSON(outputJson, context);
      });
    }
  }

  /**
   * The detach method.
   */
  detach() {
    this.__inputs.forEach((input) => input.detach());
    this.__outputs.forEach((output) => output.detach());
  }

  /**
   * The reattach method.
   */
  reattach() {
    this.__inputs.forEach((input) => input.reattach());
    this.__outputs.forEach((output) => output.reattach());
  }

  /**
   * The rebind method.
   */
  rebind() {
    this.__outputs.forEach((output) => output.rebind());
  }
}

/** The operator the calculates the global Xfo of a TreeItem based on its parents GlobalXfo and its own LocalXfo
 * @extends Operator
 * @private
 */
class CalcGlobalXfoOperator extends Operator {
  /**
   * Create a CalcGlobalXfoOperator operator.
   * @param {string} name - The name value.
   */
  constructor(globalXfoParam, localXfoParam) {
    super('CalcGlobalXfoOperator');
    this.addInput(new OperatorInput('ParentGlobal'));
    this.addInput(new OperatorInput('LocalXfo')).setParam(localXfoParam);
    this.addOutput(new OperatorOutput('GlobalXfo')).setParam(globalXfoParam);
  }

  /**
   * The backPropagateValue method inverts the mathematics of the 'evaluate'
   * method so it can propagate the value backwards to its inputs.
   * @param {Xfo} value - the new value being set on the output GlobalXfo
   */
  backPropagateValue(value) {
    const localXfoParam = this.getInput('LocalXfo').getParam();
    const parentGlobalInput = this.getInput('ParentGlobal');
    if (parentGlobalInput.isConnected()) {
      const parentGlobalXfo = parentGlobalInput.getValue();
      localXfoParam.setValue(parentGlobalXfo.inverse().multiply(value));
    } else {
      localXfoParam.setValue(value);
    }
  }

  /**
   * The evaluate method calculates a new global Xfo based on the parents Global Xfo,
   * and the local Xfo value.
   */
  evaluate() {
    const localXfo = this.getInput('LocalXfo').getValue();
    const parentGlobalInput = this.getInput('ParentGlobal');
    const globalXfoOutput = this.getOutput('GlobalXfo');
    if (parentGlobalInput.isConnected()) {
      const parentGlobalXfo = parentGlobalInput.getValue();
      globalXfoOutput.setClean(parentGlobalXfo.multiply(localXfo), this);
    } else {
      globalXfoOutput.setClean(localXfo, this);
    }
  }
}

/**
 * Represents a specific type of parameter, that only stores `Box3` values.
 *
 * i.e.:
 * ```javascript
 * const boundingBox = new BoundingBoxParameter('MyBBox', new TreeItem())
 * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
 * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
 * myParameterOwnerItem.addParameter(boundingBox)
 * ```
 * @extends Parameter
 */
class BoundingBoxParameter extends Parameter {
  /**
   * Creates an instance of BoundingBoxParameter.
   * @param {string} name - Name of the parameter
   * @param {TreeItem} treeItem - `TreeItem` that contains `Box3` representing the Bounding Box
   */
  constructor(name, treeItem) {
    super(name, new Box3$1(), 'Box3');
    this.treeItem = treeItem;
    this.dirty = true;
  }

  /**
   * Makes parameter value be dirty, so when `getValue` is called,
   * an evaluation is then executed to re-calculate the BoundingBox
   *
   * @memberof BoundingBoxParameter
   */
  setDirty() {
    this.dirty = true;
    this.emit('valueChanged');
  }

  /**
   * Returns bounding box value
   *
   * @return {Box3} - The return value.
   */
  getValue() {
    if (this.dirty) {
      this.__value = this.treeItem._cleanBoundingBox(this.__value);
    }
    return this.__value
  }
}

let selectionOutlineColor = new Color('#03E3AC');
selectionOutlineColor.a = 0.1;
let branchSelectionOutlineColor = selectionOutlineColor.lerp(new Color('white'), 0.5);
branchSelectionOutlineColor.a = 0.1;

/**
 * Class representing an Item in the scene tree with hierarchy capabilities (has children).
 * It has the capability to add and remove children.
 * <br>
 * <br>
 * **Parameters**
 * * **Visible(`BooleanParameter`):** Shows/Hides the item.
 * * **LocalXfo(`XfoParameter`):** Specifies the offset of this tree item from its parent.
 * * **GlobalXfo(`XfoParameter`):** Provides the computed world Xfo of this tree item.
 * * **BoundingBox(`BoundingBox`):** Provides the bounding box for the tree item and all of its children in the 3d scene.
 *
 * **Events**
 * * **globalXfoChanged:** _todo_
 * * **visibilityChanged:** _todo_
 * * **highlightChanged:** _todo_
 * * **childAdded:** Emitted when a item is added as a child.
 * * **childRemoved:** Emitted when an item is removed from the child nodes.
 * * **mouseDown:** Emitted when a mouseDown event happens in an item.
 * * **mouseUp:** Emitted when a mouseUp event happens in an item.
 * * **mouseMove:** Emitted when a mouseMove event happens in an item.
 * * **mouseEnter:** Emitted when a mouseEnter event happens in an item.
 *
 * @extends {BaseItem}
 */
class TreeItem extends BaseItem {
  /**
   * Creates a tree item with the specified name.
   *
   * @param {string} name - The name of the tree item. It's the identifier of the tree item.
   * It's an identifier intended to be human readable.
   * It's included in the path that we use to access a particular item.
   * It's used to display it in the tree.
   */
  constructor(name) {
    super(name);

    this.__visibleCounter = 1; // Visible by Default.
    this.__visible = true;
    this.__highlightMapping = {};
    this.__highlights = [];

    this.__childItems = [];
    this.__childItemsEventHandlers = [];
    this.__childItemsMapping = {};

    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseEnter = this.onMouseEnter.bind(this);
    this.onMouseLeave = this.onMouseLeave.bind(this);

    // /////////////////////////////////////
    // Add parameters.

    this.__visibleParam = this.addParameter(new BooleanParameter('Visible', true));
    this.__localXfoParam = this.addParameter(new XfoParameter('LocalXfo', new Xfo()));
    this.__globalXfoParam = this.addParameter(new XfoParameter('GlobalXfo', new Xfo()));
    this.__boundingBoxParam = this.addParameter(new BoundingBoxParameter('BoundingBox', this));

    // Bind handlers
    this._setBoundingBoxDirty = this._setBoundingBoxDirty.bind(this);
    this._childNameChanged = this._childNameChanged.bind(this);

    this.globalXfoOp = new CalcGlobalXfoOperator(this.__globalXfoParam, this.__localXfoParam);
    this.__globalXfoParam.on('valueChanged', (event) => {
      this._setBoundingBoxDirty();
      // Note: deprecate this event.
      this.emit('globalXfoChanged', event);
    });

    this.__visibleParam.on('valueChanged', () => {
      this.__visibleCounter += this.__visibleParam.getValue() ? 1 : -1;
      this.__updateVisibility();
    });

    // Note: one day we will remove the concept of 'selection' from the engine
    // and keep it only in UX. to Select an item, we will add it to the selection
    // in the selection manager. Then the selection group will apply a highlight.
    this.on('selectedChanged', () => {
      if (this.__selected) {
        this.addHighlight('selected', selectionOutlineColor, true);
      } else {
        this.removeHighlight('selected', true);
      }
    });
  }

  /**
   * Returns the selection outline color.
   *
   * @return {Color} - Returns a color.
   */
  static getSelectionOutlineColor() {
    return selectionOutlineColor
  }

  /**
   * Sets the selection outline color.
   *
   * @param {Color} color - The color value.
   */
  static setSelectionOutlineColor(color) {
    selectionOutlineColor = color;
  }

  /**
   * Returns the branch selection outline color.
   *
   * @return {Color} - Returns a color.
   */
  static getBranchSelectionOutlineColor() {
    return branchSelectionOutlineColor
  }

  /**
   * Sets the branch selection outline color.
   *
   * @param {Color} color - The color value.
   */
  static setBranchSelectionOutlineColor(color) {
    branchSelectionOutlineColor = color;
  }

  // Parent Item

  /**
   * Sets the owner (another TreeItem) of the current TreeItem.
   * @param {TreeItem} parentItem - The parent item.
   */
  setOwner(parentItem) {
    if (this.__ownerItem) {
      // this.__ownerItem.off('globalXfoChanged', this._setGlobalXfoDirty)

      // The effect of the invisible owner is removed.
      if (!this.__ownerItem.isVisible()) this.__visibleCounter++;
      const index = this.__ownerItem.getChildIndex(this);
      if (index >= 0) this.__ownerItem.__unbindChild(index, this);
    }

    super.setOwner(parentItem);

    // this._setGlobalXfoDirty()
    if (this.__ownerItem) {
      this.setSelectable(this.__ownerItem.getSelectable(), true);

      // The effect of the invisible owner is added.
      if (!this.__ownerItem.isVisible()) this.__visibleCounter--;

      this.globalXfoOp.getInput('ParentGlobal').setParam(this.__ownerItem.getParameter('GlobalXfo'));
      // this.__ownerItem.on('globalXfoChanged', this._setGlobalXfoDirty)
    } else {
      this.globalXfoOp.getInput('ParentGlobal').setParam(null);
    }

    this.__updateVisibility();
  }

  /**
   * The __updatePath method.
   * @private
   */
  __updatePath() {
    super.__updatePath();
    for (const childItem of this.__childItems) {
      if (childItem) childItem.__updatePath();
    }
  }

  /**
   * Returns the parent of current TreeItem.
   *
   * @return {TreeItem|undefined} - Returns the parent item.
   */
  getParentItem() {
    return this.getOwner()
  }

  /**
   * Sets the parent of current TreeItem.
   *
   * @param {TreeItem} parentItem - The parent item.
   */
  setParentItem(parentItem) {
    this.setOwner(parentItem);
  }

  // ////////////////////////////////////////
  // Global Matrix

  /**
   * @deprecated
   * Returns the value of local Xfo transform parameter.
   *
   * @return {Xfo} - Returns the local Xfo.
   */
  getLocalXfo() {
    console.warn(`Deprecated. use "getParameter('LocalXfo').getValue()"`);
    return this.__localXfoParam.getValue()
  }

  /**
   * @deprecated
   * Sets the local Xfo transform parameter.
   *
   * @param {Xfo} xfo - The local xfo transform.
   */
  setLocalXfo(xfo) {
    console.warn(`Deprecated. use "getParameter('LocalXfo').setValue(xfo)"`);
    this.__localXfoParam.setValue(xfo);
  }

  /**
   * @deprecated
   * Returns the global Xfo transform.
   *
   * @return {Xfo} - Returns the global Xfo.
   */
  getGlobalXfo() {
    console.warn(`Deprecated. use "getParameter('GlobalXfo').getValue()"`);
    return this.__globalXfoParam.getValue()
  }

  /**
   * @deprecated
   * Sets the global Xfo transform.
   * @param {Xfo} xfo - The global xfo transform.
   */
  setGlobalXfo(xfo) {
    console.warn(`Deprecated. use "getParameter('GlobalXfo').setValue(xfo)"`);
    this.__globalXfoParam.setValue(xfo);
  }

  // ////////////////////////////////////////
  // Visibility

  /**
   * @deprecated
   * Returns visible parameter value for current TreeItem.
   *
   * @return {boolean} - The visible param value.
   */
  getVisible() {
    console.warn('Deprecated. Use #isVisible');
    return this.isVisible()
  }

  /**
   * Returns visible parameter value for current TreeItem.
   *
   * @return {boolean} - The visible param value.
   */
  isVisible() {
    // Should never be more than 1, but can be less than 0.
    return this.__visibleCounter > 0
  }

  /**
   * Sets visible parameter value.
   *
   * @param {number} val - The val param.
   */
  setVisible(val) {
    this.__visibleParam.setValue(val);
  }

  /**
   * Updates current TreeItem visible state and propagates its value to children elements.
   *
   * @param {number} val - The val param.
   */
  propagateVisibility(val) {
    this.__visibleCounter += val;
    this.__updateVisibility();
  }

  /**
   * The __updateVisibility method.
   * @return {boolean} - Returns a boolean.
   * @private
   */
  __updateVisibility() {
    const visible = this.__visibleCounter > 0;
    if (visible != this.__visible) {
      this.__visible = visible;
      for (const childItem of this.__childItems) {
        if (childItem instanceof TreeItem) childItem.propagateVisibility(this.__visible ? 1 : -1);
      }
      this.emit('visibilityChanged', { visible });
      return true
    }
    return false
  }

  // ////////////////////////////////////////
  // Highlights

  /**
   * Adds a hightlight to the tree item.
   *
   * @param {string} name - The name of the tree item.
   * @param {Color} color - The color of the highlight.
   * @param {boolean} propagateToChildren - A boolean indicating whether to propagate to children.
   */
  addHighlight(name, color, propagateToChildren = false) {
    // If the hilight was already in the list,
    // remove it and put it at the top.
    if (name in this.__highlightMapping) {
      const id = this.__highlights.indexOf(name);
      this.__highlights.splice(id, 1);
    }
    this.__highlights.push(name);
    this.__highlightMapping[name] = color;
    this.emit('highlightChanged', { name, color });

    if (propagateToChildren) {
      this.__childItems.forEach((childItem) => {
        if (childItem instanceof TreeItem) childItem.addHighlight(name, color, propagateToChildren);
      });
    }
  }

  /**
   * Removes a hightlight to the tree item.
   *
   * @param {string} name - The name of the tree item.
   * @param {boolean} propagateToChildren - A boolean indicating whether to propagate to children.
   */
  removeHighlight(name, propagateToChildren = false) {
    if (name in this.__highlightMapping) {
      const id = this.__highlights.indexOf(name);
      this.__highlights.splice(id, 1);
      delete this.__highlightMapping[name];
      this.emit('highlightChanged', {});
    }
    if (propagateToChildren) {
      this.__childItems.forEach((childItem) => {
        if (childItem instanceof TreeItem) childItem.removeHighlight(name, propagateToChildren);
      });
    }
  }

  /**
   * Returns the color of the current hilghlight.
   *
   * @return {Color} - The color value.
   */
  getHighlight() {
    if (this.__highlights.length > 0) return this.__highlightMapping[this.__highlights[this.__highlights.length - 1]]
  }

  /**
   * Returns `true` if this items has a hilghlight color assigned.
   *
   * @return {boolean} - `True` if this item is hilghlighted.
   */
  isHighlighted() {
    return this.__highlights.length > 0
  }

  // ////////////////////////////////////////
  // Bounding Box

  /**
   * Getter for a bounding box.
   * @private
   */
  get boundingBox() {
    console.warn("getter is deprecated. Please use 'getBoundingBox'");
    return this.getBoundingBox()
  }

  /**
   * @deprecated
   * Returns bounding box parameter value.
   * @private
   * @return {Box3} - The return value.
   */
  getBoundingBox() {
    console.warn("getter is deprecated. Please use 'getParameter('BoundingBox').getValue()'");
    return this.__boundingBoxParam.getValue()
  }

  /**
   * The _cleanBoundingBox method.
   * @param {Box3} bbox - The bounding box value.
   * @return {Box3} - The return value.
   * @private
   */
  _cleanBoundingBox(bbox) {
    bbox.reset();
    this.__childItems.forEach((childItem) => {
      if (childItem instanceof TreeItem)
        if (childItem.isVisible()) {
          // console.log(" - ", childItem.constructor.name, childItem.getName(), childItem.getParameter('GlobalXfo').getValue().sc.x, childItem.getBoundingBox().toString())
          bbox.addBox3(childItem.getParameter('BoundingBox').getValue());
        }
    });
    // console.log(this.getName(), bbox.toString())
    return bbox
  }

  /**
   * The _childBBoxChanged method.
   * @private
   */
  _childBBoxChanged() {
    this._setBoundingBoxDirty();
  }

  /**
   * The _setBoundingBoxDirty method.
   * @private
   */
  _setBoundingBoxDirty() {
    if (this.__boundingBoxParam) {
      // Will cause boundingChanged to emit
      this.__boundingBoxParam.setDirty();
    }
  }

  // ////////////////////////////////////////
  // Children

  /**
   * Returns children list, but children are not required to have hierarchy structure(`TreeItem`).
   * Meaning that it could be another kind of item than `TreeItem`.
   * <br>
   * i.e. **BaseImage**
   *
   * @return {array} - List of `BaseItem` owned by current TreeItem.
   */
  getChildren() {
    return this.__childItems
  }

  /**
   * Returns the number of child elements current `TreeItem` has.
   *
   * @deprecated since version 0.0.80
   * @return {number} - The return value.
   */
  numChildren() {
    console.warn('Deprecated. Use #getNumChildren');
    return this.__childItems.length
  }

  /**
   * Returns the number of child elements current `TreeItem` has.
   *
   * @return {number} - The return value.
   */
  getNumChildren() {
    return this.__childItems.length
  }

  /**
   * Verifies if there's a child with the specified name.
   * If there's one, modifiers are applied to the name and returned.
   *
   * @param {string} name - The name value.
   * @return {string} - Returns a unique name.
   */
  generateUniqueName(name) {
    if (!(name in this.__childItemsMapping)) return name

    let index = 1;
    if (name.length > 4 && !Number.isNaN(parseInt(name.substring(name.length - 4))))
      index = parseInt(name.substr(name.length - 4));
    else if (name.length > 3 && !Number.isNaN(parseInt(name.substring(name.length - 3))))
      index = parseInt(name.substr(name.length - 3));
    else if (name.length > 2 && !Number.isNaN(parseInt(name.substring(name.length - 2))))
      index = parseInt(name.substr(name.length - 2));

    const names = [];
    for (const c of this.__childItems) {
      // Sometimes we have an empty child slot.
      // We resize the child vector, and then populate it.
      if (c) {
        names.push(c.getName());
      }
    }

    let uniqueName = name;
    while (true) {
      let suffix = '' + index;
      while (suffix.length < 2) {
        suffix = '0' + suffix;
      }

      uniqueName = name + suffix;
      if (names.indexOf(uniqueName) == -1) break
      index++;
    }
    return uniqueName
  }

  /**
   * The __updateMapping method.
   * @param {any} start - The start value.
   * @private
   */
  __updateMapping(start) {
    // If a child has been added or removed from the
    // tree item, we need to update the acceleration structure.
    for (let i = start; i < this.__childItems.length; i++) {
      this.__childItemsMapping[this.__childItems[i].getName()] = i;
    }
  }

  /**
   * The _childNameChanged event hander.
   * @param {any} start - The start value.
   * @private
   */
  _childNameChanged(event) {
    // Update the acceleration structure.
    const index = this.__childItemsMapping[event.oldName];
    delete this.__childItemsMapping[event.oldName];
    this.__childItemsMapping[event.newName] = index;
  }

  /**
   * Inserts a child. It accepts all kind of `BaseItem`, not only `TreeItem`.
   *
   * @param {BaseItem} childItem - The child BaseItem to insert.
   * @param {number} index - The index to add the child item.
   * @param {boolean} maintainXfo - Boolean that determines if the Xfo value is maintained.
   * @param {boolean} fixCollisions - Modify the name of the item to avoid name collisions.
   * If false, an exception wll be thrown instead if a name collision occurs.
   * @return {number} - The index of the child item in this items children array.
   */
  insertChild(childItem, index, maintainXfo = false, fixCollisions = true) {
    if (childItem.getName() in this.__childItemsMapping) {
      if (fixCollisions) {
        childItem.setName(this.generateUniqueName(childItem.getName()));
      } else {
        throw new Error("Item '" + childItem.getName() + "' is already a child of :" + this.getPath())
      }
    }
    if (!(childItem instanceof BaseItem)) {
      throw new Error('Object is is not a tree item :' + childItem.constructor.name)
    }

    childItem.on('nameChanged', this._childNameChanged);

    let newLocalXfo;
    if (childItem instanceof TreeItem) {
      if (maintainXfo) {
        const globalXfo = this.getParameter('GlobalXfo').getValue();
        const childGlobalXfo = childItem.getParameter('GlobalXfo').getValue();
        newLocalXfo = globalXfo.inverse().multiply(childGlobalXfo);
      }
      childItem.on('boundingChanged', this._setBoundingBoxDirty);
      childItem.on('visibilityChanged', this._setBoundingBoxDirty);
    }

    this.__childItems.splice(index, 0, childItem);
    this.__childItemsMapping[childItem.getName()] = index;
    this.__updateMapping(index);

    childItem.setOwner(this);

    if (childItem instanceof TreeItem) {
      if (maintainXfo) childItem.getParameter('LocalXfo').setValue(newLocalXfo);
      this._setBoundingBoxDirty();
    }

    this.emit('childAdded', { childItem, index });

    return childItem
  }

  /**
   * Adds a child. It accepts all kind of `BaseItem`, not only `TreeItem`.
   *
   * @param {BaseItem} childItem - The child BaseItem to add.
   * @param {boolean} maintainXfo - Boolean that determines if
   * the Global Xfo value is maintained. If true, when moving
   * items in the hierarchy from one parent to another, the local Xfo
   * of the item will be modified to maintaine and the Global Xfo.
   * Note: this option defaults to false because we expect that is the
   * behavior users would expect when manipulating the tree in code.
   * To be safe and unambiguous, always try to specify this value.
   * @param {boolean} fixCollisions - Modify the name of the item to avoid
   * name collisions with other chidrent of the same parent.
   * If false, an exception wll be thrown instead if a name collision occurs.
   * @return {BaseItem} childItem - The child BaseItem that was added.
   */
  addChild(childItem, maintainXfo = true, fixCollisions = true) {
    const index = this.__childItems.length;
    this.insertChild(childItem, index, maintainXfo, fixCollisions);
    return childItem
  }

  /**
   * Returns child element in the specified index.
   *
   * @param {number} index - The index to remove the child TreeItem.
   * @return {BaseItem|undefined} - Return the child TreeItem.
   */
  getChild(index) {
    return this.__childItems[index]
  }

  /**
   * Returns child element with the specified name.
   *
   * @param {string} name - The name value.
   * @return {BaseItem|null} - Return the child BaseItem.
   */
  getChildByName(name) {
    const index = this.__childItemsMapping[name];
    if (index != undefined) {
      return this.__childItems[index]
    }
    return null
  }

  /**
   * Returns children names as an array of strings.
   *
   * @return {array} - An array of names for each child.
   */
  getChildNames() {
    const names = [];
    for (let i = 0; i < this.__childItems.length; i++) {
      const childItem = this.__childItems[i];
      if (childItem != null) names[i] = childItem.getName();
    }
    return names
  }

  /**
   * UnBind an item from the group. This method is called
   * automatically when an item is removed from the group.
   * @param {number} index - The index value.
   * @param {TreeItem} childItem - item to unbind.
   * @private
   */
  __unbindChild(index, childItem) {
    childItem.off('nameChanged', this._childNameChanged);

    if (childItem instanceof TreeItem) {
      childItem.off('boundingChanged', this._setBoundingBoxDirty);
      childItem.off('visibilityChanged', this._setBoundingBoxDirty);
    }

    this.__childItems.splice(index, 1);
    this.__childItemsEventHandlers.splice(index, 1);
    delete this.__childItemsMapping[childItem.getName()];
    this.__updateMapping(index);

    if (childItem instanceof TreeItem) {
      this._setBoundingBoxDirty();
    }

    this.emit('childRemoved', { childItem, index });
  }

  /**
   * Removes a child BaseItem by specifying its index.
   *
   * @param {number} index - The index value.
   */
  removeChild(index) {
    const childItem = this.__childItems[index];

    if (!childItem) {
      return
    }

    this.__unbindChild(index, childItem);
    childItem.setOwner(undefined);
  }

  /**
   * Removes a child BaseItem by specifying its name.
   *
   * @param {string} name - The name param.
   * @return {BaseItem} - Return the child TreeItem.
   */
  removeChildByName(name) {
    const index = this.__childItemsMapping[name];
    if (index != undefined) {
      return this.removeChild(index)
    }
    return null
  }

  /**
   * @deprecated
   *
   * @param {BaseItem} childItem - The child TreeItem to remove.
   */
  removeChildByHandle(childItem) {
    console.warn('Deprecated. Use #removeChild');
    const index = this.__childItems.indexOf(childItem);
    if (index == -1) throw new Error('Error in removeChildByHandle. Child not found:' + childItem.getName())
    this.removeChild(index);
  }

  /**
   * Removes all children Items.
   */
  removeAllChildren() {
    let index = this.__childItems.length;
    while (index--) {
      this.removeChild(index);
    }
    this._setBoundingBoxDirty();
  }

  /**
   * Returns index position of the specified item.
   *
   * @param {BaseItem} childItem - The child TreeItem value.
   * @return {number} - Child index in children array.
   */
  getChildIndex(childItem) {
    return this.__childItems.indexOf(childItem)
  }

  /**
   * @deprecated
   * Returns index position of the specified item.
   *
   * @param {object} childItem - The child TreeItem value.
   * @return {number} - The return value.
   */
  indexOfChild(childItem) {
    console.warn('Deprecated Use #getChildIndex');
    return this.getChildIndex(childItem)
  }

  // ////////////////////////////////////////
  // Path Traversial
  // Note: Path resolution starts at the root of the
  // tree the path was generated from (so index=1, because we don't resolve root).
  // Note: When a path is made relative to an item in its tree, the path
  // starts with the child elements.

  /**
   * The resolvePath method traverses the subtree from this item down
   * matching each name in the path with a child until it reaches the
   * end of the path.
   *
   * @param {array} path - The path value.
   * @param {number} index - The index value.
   * @return {BaseItem|Parameter} - The return value.
   */
  resolvePath(path, index = 0, displayError = false) {
    if (typeof path == 'string') path = path.split('/');

    if (index == 0) {
      if (path[0] == '.' || path[0] == this.__name) index++;
      else if (path[0] == '..') {
        return this.__ownerItem.resolvePath(path, index + 1)
      }
    }

    if (index == path.length) {
      return this
    }

    // if (path[index] == '>' && index == path.length - 2) {
    //   if (this.hasComponent(path[index + 1])) {
    //     const component = this.getComponent(path[index + 1])
    //     return component.resolvePath(path, index + 2)
    //   }
    // }

    const childName = path[index];
    const childItem = this.getChildByName(childName);
    if (childItem == undefined) {
      // Maybe the name is a component name.
      // if (this.hasComponent(path[index])) {
      //   const component = this.getComponent(path[index])
      //   if (index == path.length) {
      //     return component
      //   } else {
      //     return component.resolvePath(path, index + 1)
      //   }
      // }

      // Maybe the name is a parameter name.
      const param = this.getParameter(path[index]);
      if (param) {
        return param
      }

      // Note: consuming code should catch and display errors if necessary.
      // Silent failures are extremely difficult to debug.
      throw new Error(
        `Unable to resolve path : [${path.toString()}] after: ${this.getName()} \nNo child or parameter called : "${
          path[index]
        }"`
      )
    }
    return childItem.resolvePath(path, index + 1)
  }

  /**
   * Traverse the tree structure from this point down
   * and fire the callback for each visited item.
   * Note: Depth only used by selection sets for now.
   *
   * @param {function} callback - The callback value.
   * @param {boolean} includeThis - Fire the callback for this item.
   */
  traverse(callback, includeThis = true) {
    const __c = (treeItem, depth) => {
      const children = treeItem.getChildren();
      for (const childItem of children) {
        if (childItem) __t(childItem, depth + 1);
      }
    };

    const __t = (treeItem, depth) => {
      if (callback(treeItem, depth) == false) return false
      if (treeItem instanceof TreeItem) __c(treeItem, depth);
    };

    if (includeThis) {
      __t(this, 1);
    } else {
      __c(this, 0);
    }
  }

  // ///////////////////////
  // Events

  /**
   * Causes an event to occur when a user presses a mouse button over an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseDown(event) {
    this.emit('mouseDown', event);
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onMouseDown(event);
    }
  }

  /**
   * Causes an event to occur when a user releases a mouse button over a element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseUp(event) {
    this.emit('mouseUp', event);
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onMouseUp(event);
    }
  }

  /**
   * Causes an event to occur when the mouse pointer is moving while over an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseMove(event) {
    this.emit('mouseMove', event);
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onMouseMove(event);
    }
  }

  /**
   * Causes an event to occur when the mouse pointer is moved onto an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseEnter(event) {
    this.emit('mouseEnter', event);
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onMouseEnter(event);
    }
  }

  /**
   * Causes an event to occur when the mouse pointer is moved out of an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseLeave(event) {
    this.emit('mouseLeave', event);
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onMouseLeave(event);
    }
  }

  /**
   * Causes an event to occur when the mouse wheel is rolled up or down over an element.
   *
   * @param {WheelEvent } event - The wheel event that occurs.
   */
  onWheel(event) {
    if (event.propagating && this.__ownerItem) {
      this.__ownerItem.onWheel(event);
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method serializes this instance as a JSON.
   * It can be used for persistence, data transfer, etc.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);

    // Some Items, such as the SliderSceneWidget do not need their children
    // to be saved.
    const childItemsJSON = {};
    for (const childItem of this.__childItems) {
      if (childItem) {
        const childJSON = childItem.toJSON(context);
        if (childJSON) childItemsJSON[childItem.getName()] = childJSON;
      }
    }
    if (Object.keys(childItemsJSON).length > 0) {
      if (j) {
        j.children = childItemsJSON;
      } else {
        j = {
          name: this.__name,
          children: childItemsJSON,
        };
      }
    }

    return j
  }

  /**
   * The fromJSON method takes a JSON and deserializes into an instance of this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);

    if (context && !Number.isNaN(context.numTreeItems)) context.numTreeItems++;

    // if ('bbox' in j){
    //     let box = new Box3();
    //     box.fromJSON(j.bbox);
    //     this.__boundingBoxParam.setValue(box);
    // }

    if (j.children != null) {
      const childrenJson = j.children;
      if (Array.isArray(childrenJson)) {
        for (const childJson of childrenJson) {
          // Note: During loading of asset trees, we have an
          // existing tree generated by loading a bin data file.
          let childItem = this.getChildByName(childJson.name);
          if (childItem) {
            childItem.fromJSON(childJson, context);
          } else {
            if (childJson.type) {
              childItem = Registry.constructClass(childJson.type);
              if (childItem) {
                // Note: we should load the json first, as it
                // may contain the unique name of the item.
                childItem.fromJSON(childJson, context);
                this.addChild(childItem, false, false);
              }
            }
          }
        }
      } else {
        // eslint-disable-next-line guard-for-in
        for (const childName in childrenJson) {
          const childJson = childrenJson[childName];
          // Note: During loading of asset trees, we have an
          // existing tree generated by loading a bin data file.
          let childItem = this.getChildByName(childName);
          if (childItem) {
            childItem.fromJSON(childJson, context);
          } else if (childJson.type) {
            childItem = Registry.constructClass(childJson.type);
            if (childItem) {
              // Note: we add the child now before loading.
              // This is because certain items. (e.g. Groups)
              // Calculate thier global Xfo, and use it to modify
              // the transform of thier members.
              // Note: Groups bind to items in the scene which are
              // already added as children, and so have global Xfos.
              // We prefer to add a child afer its loaded, because sometimes
              // In the tree is asset items, who will only toggled as
              // unloaded once they are loaded(else they are considered inline assets.)
              childItem.fromJSON(childJson, context);
              this.addChild(childItem, false, false);
            }
          }
        }
      }
    }

    // if (j.components) {
    //   for (const cj of j.components) {
    //     const component = Registry.constructClass(cj.type ? cj.type : cj.name)
    //     if (component) {
    //       component.fromJSON(cj, context)
    //       this.addComponent(component)
    //     }
    //   }
    // }
  }

  /**
   * Sets state of current Item(Including parameters & children) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.readBinary(reader, context);

    context.numTreeItems++;

    const itemflags = reader.loadUInt8();

    // const visibilityFlag = 1 << 1
    // this.setVisible(itemflags&visibilityFlag);

    // Note: to save space, some values are skipped if they are identity values
    const localXfoFlag = 1 << 2;
    if (itemflags & localXfoFlag) {
      const xfo = new Xfo();
      xfo.tr = reader.loadFloat32Vec3();
      xfo.ori = reader.loadFloat32Quat();
      xfo.sc.set(reader.loadFloat32());
      // console.log(this.getPath() + " TreeItem:" + xfo.toString());
      this.__localXfoParam.loadValue(xfo);
    }

    const bboxFlag = 1 << 3;
    if (itemflags & bboxFlag) {
      this.__boundingBoxParam.loadValue(new Box3$1(reader.loadFloat32Vec3(), reader.loadFloat32Vec3()));
    }

    const numChildren = reader.loadUInt32();
    if (numChildren > 0) {
      const toc = reader.loadUInt32Array(numChildren);
      for (let i = 0; i < numChildren; i++) {
        try {
          reader.seek(toc[i]); // Reset the pointer to the start of the item data.
          let childType = reader.loadStr();

          if (childType.startsWith('N') && childType.endsWith('E')) {
            // ///////////////////////////////////////
            // hack to work around a linux issue
            // untill we have a fix.
            const ppos = childType.indexOf('podium');
            if (ppos != -1) {
              if (parseInt(childType[ppos + 7])) childType = childType.substring(ppos + 8, childType.length - 1);
              else childType = childType.substring(ppos + 7, childType.length - 1);
            }
            const lnpos = childType.indexOf('livenurbs');
            if (lnpos != -1) {
              childType = childType.substring(childType.indexOf('CAD'), childType.length - 1);
            }
          }
          // const childName = reader.loadStr();
          const childItem = Registry.constructClass(childType);
          if (!childItem) {
            const childName = reader.loadStr();
            console.warn('Unable to construct child:' + childName + ' of type:' + childType);
            continue
          }
          reader.seek(toc[i]); // Reset the pointer to the start of the item data.
          childItem.readBinary(reader, context);

          this.addChild(childItem, false, false);
        } catch (e) {
          console.warn('Error loading tree item: ', e);
        }
      }
    }
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new tree item, copies its values
   * from this item and returns it.
   *
   * @return {TreeItem} - Returns a new cloned tree item.
   */
  clone() {
    const cloned = new TreeItem();
    cloned.copyFrom(this);
    return cloned
  }

  /**
   * Copies current TreeItem with all its children.
   *
   * @param {TreeItem} src - The tree item to copy from.
   */
  copyFrom(src) {
    super.copyFrom(src);

    // Share a local Xfo
    // Note: disabled for now.
    // When cloning instanced trees, the root item should
    // have a unique LocalXfoParam, as it must be re-set.
    // (The root of the tree is a cloned and attached to an Instance node that provides the transform)

    src.getChildren().forEach((srcChildItem) => {
      if (srcChildItem) this.addChild(srcChildItem.clone(), false, false);
    });
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.removeAllChildren();
    super.destroy();
  }
}

Registry.register('TreeItem', TreeItem);

/* eslint-disable no-unused-vars */

/**
 * TreeItem type of class designed for making duplications of parts of the tree.
 *
 * @extends {TreeItem}
 */
class InstanceItem extends TreeItem {
  /**
   * Create an instance item.
   * @param {string} name - The name of the instance item.
   */
  constructor(name) {
    super(name);
  }

  /**
   * Clones passed in `TreeItem` all the way down and adds it as a child of current item.
   *
   * @param {TreeItem} treeItem - The treeItem value.
   */
  setSrcTree(treeItem, context) {
    this.__srcTree = treeItem;

    const numChildren = this.__srcTree.getNumChildren();
    if (numChildren == 0) {
      const clonedTree = this.__srcTree.clone(context);
      clonedTree.getParameter('LocalXfo').loadValue(new Xfo());
      this.addChild(clonedTree, false);
    } else {
      const children = this.__srcTree.getChildren();
      children.forEach((child) => {
        const clonedChild = child.clone(context);
        this.addChild(clonedChild, false);
      });
    }
  }

  /**
   * Returns the last `TreeItem` cloned.
   *
   * @return {TreeItem} - The return value.
   */
  getSrcTree() {
    return this.__srcTree
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Sets state of current Item(Including cloned item) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context = {}) {
    super.readBinary(reader, context);

    // console.log("numTreeItems:", context.numTreeItems, " numGeomItems:", context.numGeomItems)
    const path = reader.loadStrArray();
    // console.log("InstanceItem of:", path)
    try {
      context.resolvePath(path, (treeItem) => {
        this.setSrcTree(treeItem, context);
      });
    } catch (e) {
      console.warn(`Error loading InstanceItem: ${this.getPath()}: ` + e.message);
    }
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context = {}) {
    const j = super.toJSON(context);
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @todo Needs to be implemented.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   * @param {function} onDone - The onDone value.
   */
  fromJSON(j, context = {}, onDone) {}
}

Registry.register('InstanceItem', InstanceItem);

/* eslint-disable constructor-super */

/**
 * A special type of `TreeItem` that let you handle audio files.
 * <br>
 * <br>
 * **Parameters**
 * * **FilePath(`FilePathParameter`):**
 * * **Autoplay(`BooleanParameter`):**
 * * **PlayState(`NumberParameter`):**
 * * **Mute(`BooleanParameter`):**
 * * **Gain(`NumberParameter`):**
 * * **Loop(`BooleanParameter):**
 * * **SpatializeAudio(`BooleanParameter`):**
 * * **refDistance(`NumberParameter`):**
 * * **maxDistance(`NumberParameter`):**
 * * **rolloffFactor(`NumberParameter`):**
 * * **coneInnerAngle(`NumberParameter`):**
 * * **coneOuterGain(`NumberParameter`):**
 *
 * **Events**
 * * **loaded**
 * * **audioSourceCreated**
 * @private
 * @extends TreeItem
 */
class AudioItem extends TreeItem {
  /**
   * Create an audio item.
   * @param {string} name - The name of the audio item.
   */
  constructor(name) {
    super(name);

    this.__loaded = false;

    const fileParam = this.addParameter(new FilePathParameter('FilePath'));
    let audioSource;
    let audioBuffer;
    const startAudioPlayback = () => {
      audioSource = window.ZeaAudioaudioCtx.createBufferSource();
      audioSource.buffer = audioBuffer;
      audioSource.loop = loopParam.getValue();
      audioSource.muted = muteParam.getValue();
      audioSource.start(0);
      this.emit('audioSourceCreated', { audioSource });
    };
    fileParam.on('valueChanged', () => {
      const request = new XMLHttpRequest();
      request.open('GET', fileParam.getURL(), true);
      request.responseType = 'arraybuffer';

      request.onload = () => {
        const audioData = request.response;
        // Note: this code is not pretty and should not access the global object
        // However, its difficult to handle this case.
        // TODO: clean this up.
        window.ZeaAudioaudioCtx.decodeAudioData(
          audioData,
          (buffer) => {
            audioBuffer = buffer;
            this.__loaded = true;
            this.emit('loaded', {});
            if (autoplayParam.getValue()) startAudioPlayback();
          },
          (e) => {
            console.log('Error with decoding audio data' + e.err);
          }
        );
      };

      request.send();
    });
    const autoplayParam = this.addParameter(new BooleanParameter('Autoplay', false));
    const playStateParam = this.addParameter(new NumberParameter('PlayState', 0));
    playStateParam.on('valueChanged', (event) => {
      switch (playStateParam.getValue()) {
        case 0:
          if (this.__loaded) {
            if (audioSource) {
              audioSource.stop(0);
              audioSource = undefined;
            }
          }
          break
        case 1:
          if (this.__loaded) {
            startAudioPlayback();
          }
          break
      }
    });

    this.isPlaying = () => {
      return playStateParam.getValue() != 0
    };

    this.play = () => {
      playStateParam.setValue(1);
    };
    this.stop = () => {
      playStateParam.setValue(0);
    };
    this.pause = () => {
      playStateParam.setValue(0);
    };

    this.getAudioSource = () => {
      return audioSource
    };
    const muteParam = this.addParameter(new BooleanParameter('Mute', false));

    this.addParameter(new NumberParameter('Gain', 1.0)).setRange([0, 5]);
    const loopParam = this.addParameter(new BooleanParameter('Loop', false));
    this.addParameter(new BooleanParameter('SpatializeAudio', true));
    this.addParameter(new NumberParameter('refDistance', 2));
    this.addParameter(new NumberParameter('maxDistance', 10000));
    // Defaults taken from here.: https://github.com/mdn/webaudio-examples/blob/master/panner-node/main.js
    this.addParameter(new NumberParameter('rolloffFactor', 1));
    this.addParameter(new NumberParameter('coneInnerAngle', 360));
    this.addParameter(new NumberParameter('coneOuterAngle', 0));
    this.addParameter(new NumberParameter('coneOuterGain', 1));

    muteParam.on('valueChanged', () => {
      if (audioSource) audioSource.muted = muteParam.getValue();
    });
    loopParam.on('valueChanged', () => {
      if (audioSource) audioSource.loop = loopParam.getValue();
    });

    this.mute = (value) => {
      muteParam.setValue(value);
    };

    // Note: Many parts of the code assume a 'loaded' signal.
    // We should probably deprecate and use only 'updated'.
    this.loaded = false;
  }

  /**
   * Returns loaded status of the audio item
   *
   * @return {boolean} - `The return value`.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * The setAudioStream method.
   * @param {any} audio - The audio value.
   */
  setAudioStream() {
    this.__loaded = true;
    this.emit('loaded', {});
    this.emit('audioSourceCreated', { audioSource });
  }
}

/** Class representing a audio file item in a scene tree.
 * @ignore
 * @extends AudioItem
 */
class FileAudioItem extends AudioItem {
  /**
   * Create a audio file item.
   * @param {string} name - The name of the audio file.
   */
  constructor(name) {}
}

/* eslint-disable require-jsdoc */

const generateParameterInstance = (paramName, defaultValue, range, texturable) => {
  if (typeof defaultValue == 'boolean' || defaultValue === false || defaultValue === true) {
    return new Parameter(paramName, defaultValue, 'Boolean')
  } else if (typeof defaultValue == 'string') {
    return new Parameter(paramName, defaultValue, 'String')
  } else if (MathFunctions.isNumeric(defaultValue)) {
    if (texturable) return new MaterialFloatParam(paramName, defaultValue, range)
    else return new NumberParameter(paramName, defaultValue, range)
  } else if (defaultValue instanceof Vec2) {
    return new Vec2Parameter(paramName, defaultValue)
  } else if (defaultValue instanceof Vec3$1) {
    return new Vec3Parameter(paramName, defaultValue)
  } else if (defaultValue instanceof Color) {
    if (texturable) return new MaterialColorParam(paramName, defaultValue)
    else return new ColorParameter(paramName, defaultValue)
  } else {
    return new Parameter(paramName, defaultValue)
  }
};

/**
 * Represents a type of `BaseItem` class that holds material configuration.
 * Use this to apply materials to your assets or item parts.
 *
 * **Events**
 * * **shaderNameChanged:** Triggered when the shader's name is set through `setShaderName` method.
 *
 * @extends BaseItem
 */
class Material extends BaseItem {
  /**
   * Create a material
   * @param {string} name - The name of the material.
   * @param {string} shaderName - Shader's class name.
   */
  constructor(name, shaderName) {
    super(name);
    this.visibleInGeomDataBuffer = true;

    if (shaderName) this.setShaderName(shaderName);
  }

  /**
   * Getter for the shader name.
   * @return {string} - Returns the shader name.
   */
  getShaderName() {
    return this.__shaderName
  }

  /**
   * Sets shader by using the name of the class with the script.
   * It is important that the shader is registered in `Registry`, otherwise it will error.
   * See all classes that extend from `GLShader`.
   *
   * @param {string} shaderName - The shader name.
   */
  setShaderName(shaderName) {
    if (this.__shaderName == shaderName) return

    const shaderClass = Registry.getBlueprint(shaderName);
    if (!shaderClass) throw new Error('Error setting Shader. Shader not found:' + shaderName)

    const paramDescs = shaderClass.getParamDeclarations();
    const paramMap = {};
    for (const desc of paramDescs) {
      // Note: some shaders specify default images. Like the speckle texture
      // on the car paint shader.
      // let image;
      // let defaultValue = desc.defaultValue;
      // if (desc.defaultValue instanceof BaseImage) {
      //     image = desc.defaultValue;
      //     defaultValue = new Color();
      // }
      let param = this.getParameter(desc.name);
      // if(param && param.getType() != desc.defaultValue)
      // removeParameter
      if (!param)
        param = this.addParameter(
          generateParameterInstance(desc.name, desc.defaultValue, desc.range, desc.texturable != false)
        );
      // if(desc.texturable != false) {// By default, parameters are texturable. texturable must be set to false to disable texturing.
      //     if(!param.getImage)
      //         this.__makeParameterTexturable(param);
      //     // if(image)
      //     //     param.setImage(image)
      // }

      paramMap[desc.name] = true;
    }

    // Remove redundant Params.
    for (const param of this.__params) {
      if (!paramMap[param.getName()]) {
        this.removeParameter(param.getName());
      }
    }

    this.__shaderName = shaderName;
    this.emit('shaderNameChanged', { shaderName });
  }

  /**
   * Remove all textures from Material's parameters.
   */
  removeAllTextures() {
    for (const param of this.__params) {
      if (param.getImage && param.getImage()) {
        // emit a notification so the GLMaterial knows to
        // Remove refs to GLTexture objects.
        param.setImage(undefined);
      }
    }
  }

  // /////////////////////////////
  // Parameters

  /**
   * Returns all texture parameters in current Material.
   *
   * @return {object} - The return value.
   */
  getParamTextures() {
    const textures = {};
    for (const param of this.__params) {
      if (param.getImage && param.getImage()) textures[param.getName()] = param.getImage();
    }
    return textures
  }

  /**
   * The __makeParameterTexturable method.
   * @param {any} param - The param value.
   * @private
   */
  __makeParameterTexturable(param) {
    makeParameterTexturable(param);
  }

  /**
   * Checks if the material is transparent by checking the `Opacity` parameter.
   *
   * @return {boolean} - Returns true if the material is transparent.
   */
  isTransparent() {
    const opacity = this.getParameter('Opacity');
    if (opacity && (opacity.getValue() < 0.99 || opacity.getImage())) return true
    const baseColor = this.getParameter('BaseColor');
    if (baseColor && baseColor.getImage() && baseColor.getImage().format == 'RGBA') return true
    return false
  }

  /**
   * Returns shader's class of current material, if set. Otherwise it returns `undefined`
   *
   * @return {string|undefined} - The return value.
   */
  getShaderClass() {
    return Registry.getBlueprint(this.getShaderName())
  }

  /**
   * Let you modify or set the shader and all the parameters of current material.
   *
   * @param {object} paramValues - The paramValues.
   * @param {string} shaderName - The shader name.
   */
  modifyParams(paramValues, shaderName) {
    if (shaderName) this.setShaderName(shaderName);
    for (const paramName in paramValues) {
      const param = this.getParameter(paramName);
      if (param) {
        if (paramValues[paramName] instanceof Parameter) {
          this.replaceParameter(paramValues[paramName]);
        } else {
          param.setValue(paramValues[paramName]);
        }
      }
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes the current object as a json object.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    return super.toJSON(context)
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context = {}) {
    if (!j.shader) {
      console.warn('Invalid Material JSON');
      return
    }
    this.setShaderName(j.shader);
    super.fromJSON(j, context);
    // let props = this.__params;
    // for (let key in j) {
    //     let value;
    //     if (j[key] instanceof Object) {
    //         value = new Color();
    //         value.fromJSON(j[key]);
    //     } else {
    //         value = j[key];
    //     }
    //     this.addParameter(paramName, value);
    // }
  }

  /**
   * Sets state of current Item(Including Shaders and Materials) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    let shaderName = reader.loadStr();

    if (shaderName == 'StandardMaterial') {
      shaderName = 'StandardSurfaceShader';
    }
    if (shaderName == 'TransparentMaterial') {
      shaderName = 'TransparentSurfaceShader';
    }
    this.setShaderName(shaderName);

    // if (context.version < 3) {
    if (context.versions['zea-engine'].compare([0, 0, 3]) < 0) {
      this.setName(reader.loadStr());

      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1)
      }

      const numParams = reader.loadUInt32();
      for (let i = 0; i < numParams; i++) {
        const paramName = capitalizeFirstLetter(reader.loadStr());
        const paramType = reader.loadStr();
        let value;
        if (paramType == 'MaterialColorParam') {
          value = reader.loadRGBAFloat32Color();
          // If the value is in linear space, then we should convert it to gamma space.
          // Note: !! this should always be done in preprocessing...
          value.applyGamma(2.2);
        } else {
          value = reader.loadFloat32();
        }
        const textureName = reader.loadStr();

        // console.log(paramName +":" + value);
        let param = this.getParameter(paramName);
        if (param) param.setValue(value);
        else param = this.addParameter(generateParameterInstance(paramName, value));
        if (textureName != '' && param.setImage) {
          // if(!param.setImage)
          //     this.__makeParameterTexturable(param);

          if (context.materialLibrary.hasImage(textureName)) {
            // console.log(paramName +":" + textureName + ":" + context.materialLibrary[textureName].resourcePath);
            param.setImage(context.materialLibrary.getImage(textureName));
          } else {
            console.warn('Missing Texture:' + textureName);
          }
        }
      }
    } else {
      super.readBinary(reader, context);
    }
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new material, copies its values
   * from this material and returns it.
   *
   * @return {Material} - Returns a new cloned material.
   */
  clone() {
    const cloned = new Material();
    cloned.copyFrom(this);
    return cloned
  }

  /**
   * When a Material is copied, first runs `BaseItem` copyFrom method, then sets shader.
   *
   * @param {Material} src - The material to copy from.
   */
  copyFrom(src) {
    super.copyFrom(src);
    this.setShaderName(src.getShaderName());
    for (const srcParam of src.getParameters()) {
      const param = src.getParameter(srcParam.getName());
      if (!srcParam.getImage) this.__makeParameterTexturable(param);
    }
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.removeAllTextures();
    super.destroy();
  }
}

/**
 * Base class that represents geometry items with layering, overlaying and cut away features.
 *
 * **Events**
 * * **cutAwayChanged:** Triggered everytime the cutaway variables change(if enabled or not, the vector and the distance).
 * @extends TreeItem
 */
class BaseGeomItem extends TreeItem {
  /**
   * Create a base geometry item.
   * @param {string} name - The name of the base geom item.
   */
  constructor(name) {
    super(name);
    this.overlay = false;
    this.__cutAway = false;
    this.__cutAwayVector = false;
    this.__cutAwayDist = false;
    this.__layers = [];
  }

  /**
   * Sets overlay value.
   *
   * @todo Need to find the layer and add this item to it.
   * @param {boolean} val - `true` to enable it.
   */
  setOverlay(val) {
    // TODO: need to find the layer and add this item to it.
    this.overlay = val;
  }

  /**
   * Returns `true` if overlay is enabled for current item.
   *
   * @return {boolean} - The return value.
   */
  isOverlay() {
    return this.overlay
  }

  /**
   * Adds a layer to current item.
   *
   * @todo Need to find the layer and add this item to it.
   * @param {string} name - The name of the layer.
   */
  addLayer(name) {
    // TODO: need to find the layer and add this item to it.
    this.__layers.push(name);
  }

  /**
   * Returns all layers in current item.
   *
   * @return {array} - The return value.
   */
  getLayers() {
    return this.__layers
  }

  // ////////////////////////////////////////
  // Cutaways

  /**
   * Checks if cutaway is enabled.
   *
   * @return {boolean} - Returns `true` if enabled.
   */
  isCutawayEnabled() {
    return this.__cutAway
  }

  /**
   * Sets cutaway state.
   *
   * @param {boolean} state - `true` to enable it, otherwise `false`.
   */
  setCutawayEnabled(state) {
    this.__cutAway = state;
    this.emit('cutAwayChanged', {});
  }

  /**
   * Returns cutaway vector value.
   *
   * @return {Vec3|boolean} - `Vec3` when it is set, `false` on default.
   */
  getCutVector() {
    return this.__cutAwayVector
  }

  /**
   * Sets cutaway vector value.
   *
   * @param {Vec3} cutAwayVector - The cutAwayVector value.
   */
  setCutVector(cutAwayVector) {
    this.__cutAwayVector = cutAwayVector;
    this.emit('cutAwayChanged', {});
  }

  /**
   * Getter for the cutaway distance.
   *
   * @return {number} - The return value.
   */
  getCutDist() {
    return this.__cutAwayDist
  }

  /**
   * Sets cutaway distance value.
   *
   * @param {number} cutAwayDist - The cutAwayDist value.
   */
  setCutDist(cutAwayDist) {
    this.__cutAwayDist = cutAwayDist;
    this.emit('cutAwayChanged', {});
  }

  // ///////////////////////////
  // Persistence

  /**
   * Sets state of current Item(Including layers & material) using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.readBinary(reader, context);

    if (context.versions['zea-engine'].greaterOrEqualThan([0, 0, 4])) {
      const materialName = reader.loadStr();
      // const materialName = 'Material' + this.__bodyDescId;

      const materialLibrary = context.assetItem.getMaterialLibrary();
      let material = materialLibrary.getMaterial(materialName, false);
      if (!material) {
        // console.warn("BaseGeomItem :'" + this.name + "' Material not found:" + materialName);
        // material = materialLibrary.getMaterial('DefaultMaterial');

        material = new Material(materialName, 'SimpleSurfaceShader');
        material.getParameter('BaseColor').loadValue(Color.random(0.25));
        context.assetItem.getMaterialLibrary().addMaterial(material);
      }
      this.getParameter('Material').loadValue(material);

      this.__layers = reader.loadStrArray();
      if (this.__layers.length > 0) {
        // console.log("Layers:", this.__layers)
        for (const layer of this.__layers) context.addGeomToLayer(this, layer);
      }
    }
  }
}

/** The operator the calculates the global Xfo of a TreeItem based on its parents GlobalXfo and its own LocalXfo
 * @extends Operator
 * @private
 */
class CalcGeomMatOperator extends Operator {
  /**
   *Creates an instance of CalcGeomMatOperator.
   *
   * @param {*} globalXfoParam
   * @param {*} geomOffsetXfoParam
   * @param {*} geomMatParam
   * @memberof CalcGeomMatOperator
   */
  constructor(globalXfoParam, geomOffsetXfoParam, geomMatParam) {
    super('CalcGeomMatOperator');
    this.addInput(new OperatorInput('GlobalXfo')).setParam(globalXfoParam);
    this.addInput(new OperatorInput('GeomOffsetXfo')).setParam(geomOffsetXfoParam);
    this.addOutput(new OperatorOutput('GeomMat')).setParam(geomMatParam);
  }

  /**
   * The evaluate method.
   */
  evaluate() {
    const globalXfo = this.getInput('GlobalXfo').getValue();
    const geomOffsetXfo = this.getInput('GeomOffsetXfo').getValue();
    const geomMatOutput = this.getOutput('GeomMat');

    const globalMat4 = globalXfo.toMat4();
    const geomOffsetMat4 = geomOffsetXfo.toMat4();
    geomMatOutput.setClean(globalMat4.multiply(geomOffsetMat4));
  }
}

/**
 * Class representing a geometry item in a scene tree.
 *
 * **Parameters**
 * * **Geometry(`GeometryParameter`):** The geometry to be rendered for this GeomItem
 * * **Material(`MaterialParameter`):** The Material to use when rendering this GeomItem
 * * **GeomOffsetXfo(`XfoParameter`):** Provides an offset transformation that is applied only to the geometry and not inherited by child items.
 * * **GeomMat(`Mat4Parameter`):** Calculated from the GlobalXfo and the GeomOffsetXfo, this matrix is provided to the renderer for rendering.
 *
 * @extends BaseGeomItem
 */
class GeomItem extends BaseGeomItem {
  /**
   * Creates a geometry item.
   * @param {string} name - The name of the geom item.
   * @param {BaseGeom} geometry - The geometry value.
   * @param {Material} material - The material value.
   */
  constructor(name, geometry = undefined, material = undefined) {
    super(name);

    this.__geomParam = this.addParameter(new GeometryParameter('Geometry'));
    this._setBoundingBoxDirty = this._setBoundingBoxDirty.bind(this);
    this.__geomParam.on('valueChanged', this._setBoundingBoxDirty);
    this.__geomParam.on('boundingBoxChanged', this._setBoundingBoxDirty);
    this.__materialParam = this.addParameter(new MaterialParameter('Material'));
    this.__paramMapping['material'] = this.getParameterIndex(this.__materialParam);

    this.__geomOffsetXfoParam = this.addParameter(new XfoParameter('GeomOffsetXfo'));
    this.__geomMatParam = this.addParameter(new Mat4Parameter('GeomMat'));

    this.calcGeomMatOperator = new CalcGeomMatOperator(
      this.__globalXfoParam,
      this.__geomOffsetXfoParam,
      this.__geomMatParam
    );

    if (geometry) this.getParameter('Geometry').loadValue(geometry);
    if (material) this.getParameter('Material').loadValue(material);
  }

  // ////////////////////////////////////////
  // Geometry

  /**
   * Returns `Geometry` parameter value.
   *
   * @return {BaseGeom} - The return value.
   */
  getGeometry() {
    console.warn(`deprecated. please use 'getParameter('Geometry').getValue`);
    return this.__geomParam.getValue()
  }

  /**
   * Sets geometry object to `Geometry` parameter.
   *
   * @param {BaseGeom} geom - The geom value.
   */
  setGeometry(geom) {
    console.warn(`deprecated. please use 'getParameter('Geometry').setValue`);
    this.__geomParam.setValue(geom);
  }

  /**
   * Getter for geometry (getGeom is deprecated. Please use getGeometry).
   *
   * @deprecated
   * @return {BaseGeom} - The return value.
   */
  getGeom() {
    console.warn(`deprecated. please use 'getParameter('Geometry').getValue`);
    return this.__geomParam.getValue()
  }

  /**
   * Setter for geometry. (setGeom is deprecated. Please use setGeometry).
   *
   * @deprecated
   * @param {BaseGeom} geom - The geom value.
   * @return {number} - The return value.
   */
  setGeom(geom) {
    console.warn("setGeom is deprecated. Please use 'getParameter('Geometry').setValue'");
    return this.__geomParam.setValue(geom)
  }

  /**
   * Returns the specified value of `Material`parameter.
   *
   * @return {Material} - The return value.
   */
  getMaterial() {
    console.warn(`deprecated. please use 'getParameter('Material').getValue`);
    return this.__materialParam.getValue()
  }

  /**
   * Sets material object to `Material` parameter.
   *
   * @param {Material} material - The material value.
   */
  setMaterial(material) {
    console.warn(`deprecated. please use 'getParameter('Material').setValue`);
    this.__materialParam.setValue(material);
  }

  /**
   * The _cleanBoundingBox method.
   * @param {Box3} bbox - The bounding box value.
   * @return {Box3} - The return value.
   * @private
   */
  _cleanBoundingBox(bbox) {
    bbox = super._cleanBoundingBox(bbox);
    const geom = this.__geomParam.getValue();
    if (geom) {
      bbox.addBox3(geom.getBoundingBox(), this.getGeomMat4());
    }
    return bbox
  }

  // ////////////////////////////////////////
  // Xfos

  /**
   * Returns the offset `Xfo` object specified in `GeomOffsetXfo` parameter.
   *
   * @return {Xfo} - Returns the geom offset Xfo.
   */
  getGeomOffsetXfo() {
    return this.__geomOffsetXfoParam.getValue()
  }

  /**
   * Sets `Xfo` object to `GeomOffsetXfo` parameter.
   *
   * @param {Xfo} xfo - The Xfo value.
   */
  setGeomOffsetXfo(xfo) {
    this.__geomOffsetXfoParam.setValue(xfo);
  }

  /**
   * Returns `Mat4` object value of `GeomMat` parameter.
   *
   * @return {Mat4} - Returns the geom Xfo.
   */
  getGeomMat4() {
    return this.__geomMatParam.getValue()
  }

  // ///////////////////////////
  // Debugging

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const json = super.toJSON(context);
    return json
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context) {
    super.fromJSON(json, context);
    context.numGeomItems++;
  }

  /**
   * Loads state of the Item from a binary object.
   *
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context) {
    super.readBinary(reader, context);

    context.numGeomItems++;

    const itemFlags = reader.loadUInt8();
    const geomIndex = reader.loadUInt32();
    const geomLibrary = context.assetItem.getGeometryLibrary();
    const geom = geomLibrary.getGeom(geomIndex);
    if (geom) {
      this.getParameter('Geometry').loadValue(geom);
    } else {
      this.geomIndex = geomIndex;
      const onGeomLoaded = (event) => {
        const { range } = event;
        if (geomIndex >= range[0] && geomIndex < range[1]) {
          const geom = geomLibrary.getGeom(geomIndex);
          if (geom) this.getParameter('Geometry').setValue(geom);
          else console.warn('Geom not loaded:', this.getName());
          geomLibrary.off('rangeLoaded', onGeomLoaded);
        }
      };
      geomLibrary.on('rangeLoaded', onGeomLoaded);
    }

    // this.setVisibility(j.visibility);
    // Note: to save space, some values are skipped if they are identity values
    const geomOffsetXfoFlag = 1 << 2;
    if (itemFlags & geomOffsetXfoFlag) {
      this.__geomOffsetXfoParam.setValue(
        new Xfo(reader.loadFloat32Vec3(), reader.loadFloat32Quat(), reader.loadFloat32Vec3())
      );
    }

    // BaseGeomItem now handles loading materials.
    // if (context.version < 4) {
    if (context.versions['zea-engine'].compare([0, 0, 4]) < 0) {
      const materialFlag = 1 << 3;
      if (itemFlags & materialFlag) {
        const materialLibrary = context.assetItem.getMaterialLibrary();
        const materialName = reader.loadStr();
        let material = materialLibrary.getMaterial(materialName);
        if (!material) {
          console.warn("Geom :'" + this.name + "' Material not found:" + materialName);
          material = materialLibrary.getMaterial('Default');
        }
        this.getParameter('Material').loadValue(material);
      } else {
        // Force nodes to have a material so we can see them.
        this.getParameter('Material').loadValue(context.assetItem.getMaterialLibrary().getMaterial('Default'));
      }
    }

    // Note: deprecated value. Not sure if we need to load this here.
    // I think not, but need to test first.
    const lightmapCoordOffset = reader.loadFloat32Vec2();
  }

  /**
   * Returns string representation of current object's state.
   *
   * @return {string} - The return value.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new geom item, copies its values
   * from this item and returns it.
   *
   * @param {number} context - The context value.
   * @return {GeomItem} - Returns a new cloned geom item.
   */
  clone(context) {
    const cloned = new GeomItem();
    cloned.copyFrom(this, context);
    return cloned
  }

  /**
   * Copies current GeomItem with all its children.
   *
   * @param {GeomItem} src - The geom item to copy from.
   * @param {number} context - The context value.
   */
  copyFrom(src, context) {
    super.copyFrom(src, context);

    if (!src.getParameter('Geometry').getValue() && src.geomIndex != -1) {
      const geomLibrary = context.assetItem.getGeometryLibrary();
      const geomIndex = src.geomIndex;
      const onGeomLoaded = (event) => {
        const { range } = event;
        if (geomIndex >= range[0] && geomIndex < range[1]) {
          const geom = geomLibrary.getGeom(geomIndex);
          if (geom) this.getParameter('Geometry').loadValue(geom);
          else console.warn('Geom not loaded:', this.getName());
          geomLibrary.off('rangeLoaded', onGeomLoaded);
        }
      };
      geomLibrary.on('rangeLoaded', onGeomLoaded);
    }

    // Geom Xfo should be dirty after cloning.
    // Note: this might not be necessary. It should
    // always be dirty after cloning.
    this.__geomMatParam.setDirty(this.__cleanGeomMat);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
  }
}

Registry.register('GeomItem', GeomItem);

/** An operator for aiming items at targets.
 * @extends Operator
 *
 */
class GroupTransformXfoOperator extends Operator {
  /**
   * Create a GroupMemberXfoOperator operator.
   * @param {Parameter} groupGlobalXfoParam - The GlobalXfo param found on the Group.
   * @param {Parameter} groupTransformXfoParam - The parameter on the Group which defines the displacement to apply to the members.
   */
  constructor(groupGlobalXfoParam, groupTransformXfoParam) {
    super();
    this.addInput(new OperatorInput('GroupGlobalXfo')).setParam(groupGlobalXfoParam);
    this.addOutput(new OperatorOutput('GroupTransformXfo')).setParam(groupTransformXfoParam);
  }

  /**
   * Create a GroupMemberXfoOperator operator.
   * @param {Xfo} bindXfo - The Bind Xfo calculated from the initial Transforms of the Group Members.
   */
  setBindXfo(bindXfo) {
    this.bindXfo = bindXfo;
    this.invBindXfo = bindXfo.inverse();
    this.setDirty();
  }

  /**
   * The evaluate method.
   */
  evaluate() {
    const groupTransformOutput = this.getOutput('GroupTransformXfo');
    if (this.invBindXfo) {
      const groupGlobalXfo = this.getInput('GroupGlobalXfo').getValue();
      groupTransformOutput.setClean(groupGlobalXfo.multiply(this.invBindXfo));
    } else {
      groupTransformOutput.setClean(new Xfo());
    }
  }
}

/** An operator for modifying group members by the groups Xfo
 * @private
 * @extends Operator
 *
 */
class GroupMemberXfoOperator extends Operator {
  /**
   * Create a GroupMemberXfoOperator operator.
   * @param {Parameter} groupTransformXfoParam - The parameter on the Group which defines the displacement to apply to the members.
   * @param {Parameter} memberXfoGlobalParam - The GlobalXfo param found on the Member.
   */
  constructor(groupTransformXfoParam, memberXfoGlobalParam) {
    super();
    this.addInput(new OperatorInput('GroupTransformXfo')).setParam(groupTransformXfoParam);
    this.addOutput(new OperatorOutput('MemberGlobalXfo', OperatorOutputMode.OP_READ_WRITE)).setParam(
      memberXfoGlobalParam
    );

    this._enabled = true;
  }

  /**
   * used to temporarily disable/enable the operator when the Group bind Xfo is being calculated
   */
  disable() {
    this._enabled = false;
    this.setDirty();
  }

  /**
   * used to temporarily disable/enable the operator when the Group bind Xfo is being calculated
   */
  enable() {
    this._enabled = true;
    this.setDirty();
  }

  /**
   * The evaluate method.
   */
  evaluate() {
    const memberGlobalXfoOutput = this.getOutput('MemberGlobalXfo');
    const memberGlobalXfo = memberGlobalXfoOutput.getValue();
    if (this._enabled) {
      const groupTransformXfo = this.getInput('GroupTransformXfo').getParam().getValue();
      memberGlobalXfoOutput.setClean(groupTransformXfo.multiply(memberGlobalXfo));
    } else {
      memberGlobalXfoOutput.setClean(memberGlobalXfo);
    }
  }
}

/* eslint-disable no-unused-vars */

const GROUP_XFO_MODES = {
  disabled: 0,
  manual: 1,
  first: 2,
  average: 3,
  globalOri: 4,
};

/**
 * Groups are a special type of `TreeItem` that allows you to gather/classify/organize/modify
 * multiple items contained within the group. Items can be added to the group directly, or using
 * its path.
 * All parameters set to the group are also set to the children; in other words, it's a faster way
 * to apply common things to multiple items.
 *
 * **Parameters**
 * * **Items(`ItemSetParameter`):** _todo_
 * * **Highlighted(`BooleanParameter`):** _todo_
 * * **HighlightColor(`ColorParameter`):** _todo_
 * * **HighlightFill(`NumberParameter`):** _todo_
 * * **Material(`MaterialParameter`):** _todo_
 * * **CutAwayEnabled(`BooleanParameter`):** _todo_
 * * **CutPlaneNormal(`Vec3Parameter`):** _todo_
 * * **CutPlaneDist(`NumberParameter`):** _todo_
 *
 * @extends TreeItem
 */
class Group extends TreeItem {
  /**
   * Creates an instance of a group.
   *
   * @param {string} name - The name of the group.
   */
  constructor(name) {
    super(name);

    // Items which can be constructed by a user (not loaded in binary data.)
    this.groupXfoDirty = false;
    this.calculatingGroupXfo = false;
    this.dirty = false;
    this.searchRoot = null;
    this._bindXfoDirty = false;

    // this.invGroupXfo = undefined
    this.memberXfoOps = [];
    this.__itemsParam = this.addParameter(new ItemSetParameter('Items', (item) => item instanceof TreeItem));
    this.__itemsParam.on('itemAdded', (event) => {
      this.__bindItem(event.item, event.index);
    });
    this.__itemsParam.on('itemRemoved', (event) => {
      this.__unbindItem(event.item, event.index);
    });

    this.__initialXfoModeParam = this.addParameter(
      new MultiChoiceParameter('InitialXfoMode', GROUP_XFO_MODES.average, ['manual', 'first', 'average', 'global'])
    );
    this.__initialXfoModeParam.on('valueChanged', () => {
      this.calcGroupXfo();
    });

    this.__highlightedParam = this.addParameter(new BooleanParameter('Highlighted', false));
    this.__highlightedParam.on('valueChanged', () => {
      this.__updateHighlight();
    });

    this.__updateHighlight = this.__updateHighlight.bind(this);
    const highlightColorParam = this.addParameter(new ColorParameter('HighlightColor', new Color(0.5, 0.5, 1)));
    highlightColorParam.on('valueChanged', this.__updateHighlight);
    const highlightFillParam = this.addParameter(new NumberParameter('HighlightFill', 0.0, [0, 1]));
    highlightFillParam.on('valueChanged', this.__updateHighlight);

    this.__materialParam = this.addParameter(new MaterialParameter('Material'));
    this.__materialParam.on('valueChanged', () => {
      this.__updateMaterial();
    });

    this.__updateCutaway = this.__updateCutaway.bind(this);
    this.addParameter(new BooleanParameter('CutAwayEnabled', false)).on('valueChanged', this.__updateCutaway);
    this.addParameter(new Vec3Parameter('CutPlaneNormal', new Vec3$1(1, 0, 0))).on('valueChanged', this.__updateCutaway);
    this.addParameter(new NumberParameter('CutPlaneDist', 0.0)).on('valueChanged', this.__updateCutaway);

    const groupTransformParam = this.addParameter(new XfoParameter('GroupTransform', new Xfo()));
    this.groupTransformOp = new GroupTransformXfoOperator(this.getParameter('GlobalXfo'), groupTransformParam);
  }

  /**
   * Returns enum of available xfo modes.
   *
   * | Name | Default |
   * | --- | --- |
   * | manual | <code>0</code> |
   * | first | <code>1</code> |
   * | average | <code>2</code> |
   * | globalOri | <code>3</code> |
   */
  static get INITIAL_XFO_MODES() {
    return GROUP_XFO_MODES
  }

  /**
   * The __updateVisibility method.
   * @return {boolean} - The return value.
   * @private
   */
  __updateVisibility() {
    if (super.__updateVisibility()) {
      const value = this.isVisible();
      Array.from(this.__itemsParam.getValue()).forEach((item) => {
        if (item instanceof TreeItem) item.propagateVisibility(value ? 1 : -1);
      });
      return true
    }
    return false
  }

  // /////////////////////////////

  /**
   * The __updateHighlight method.
   * @private
   */
  __updateHighlight() {
    // Make this function async so that we don't pull on the
    // graph immediately when we receive a notification.
    // Note: propagating using an operator would be much better.
    new Promise((resolve) => {
      let highlighted = false;
      let color;
      if (this.getParameter('Highlighted').getValue() || this.isSelected()) {
        highlighted = true;
        color = this.getParameter('HighlightColor').getValue();
        color.a = this.getParameter('HighlightFill').getValue();
      }

      const key = 'groupItemHighlight' + this.getId();
      Array.from(this.__itemsParam.getValue()).forEach((item) => {
        if (item instanceof TreeItem) {
          if (highlighted) item.addHighlight(key, color, true);
          else item.removeHighlight(key, true);
        }
      });
      resolve();
    });
  }

  /**
   * Changes selection's state of the group with all items it owns.
   *
   * @param {boolean} sel - Boolean indicating the new selection state.
   */
  setSelected(sel) {
    super.setSelected(sel);
    this.__updateHighlight();
  }

  // ////////////////////////////////////////
  // Global Xfo

  /**
   * Calculate the group Xfo translate.
   * @private
   * @return {Xfo} - Returns a new Xfo.
   */
  calcGroupXfo() {
    const items = Array.from(this.__itemsParam.getValue());
    if (items.length == 0) return new Xfo()
    this.calculatingGroupXfo = true;

    this.memberXfoOps.forEach((op) => op.disable());

    // TODO: Disable the group operator?
    const initialXfoMode = this.__initialXfoModeParam.getValue();
    let xfo;
    if (initialXfoMode == GROUP_XFO_MODES.manual) {
      // The xfo is manually set by the current global xfo.
      // this.invGroupXfo = this.getParameter('GlobalXfo').getValue().inverse()
      this.groupTransformOp.setBindXfo(this.getParameter('GlobalXfo').getValue());
      this.calculatingGroupXfo = false;
      this.groupXfoDirty = false;
      return
    } else if (initialXfoMode == GROUP_XFO_MODES.first) {
      if (items[0] instanceof TreeItem) {
        xfo = items[0].getParameter('GlobalXfo').getValue();
      }
    } else if (initialXfoMode == GROUP_XFO_MODES.average) {
      xfo = new Xfo();
      xfo.ori.set(0, 0, 0, 0);
      let numTreeItems = 0;
      items.forEach((item, index) => {
        if (item instanceof TreeItem) {
          const itemXfo = item.getParameter('GlobalXfo').getValue();
          xfo.tr.addInPlace(itemXfo.tr);
          xfo.ori.addInPlace(itemXfo.ori);
          numTreeItems++;
        }
      });
      xfo.tr.scaleInPlace(1 / numTreeItems);
      xfo.ori.normalizeInPlace();
      // xfo.sc.scaleInPlace(1/ numTreeItems);
    } else if (initialXfoMode == GROUP_XFO_MODES.globalOri) {
      xfo = new Xfo();
      let numTreeItems = 0;
      items.forEach((item, index) => {
        if (item instanceof TreeItem) {
          const itemXfo = item.getParameter('GlobalXfo').getValue();
          xfo.tr.addInPlace(itemXfo.tr);
          numTreeItems++;
        }
      });
      xfo.tr.scaleInPlace(1 / numTreeItems);
    } else {
      throw new Error('Invalid GROUP_XFO_MODES.')
    }

    // Note: if the Group global param becomes dirty
    // then it stops propagating dirty to its members.
    // const newGlobal = this.getParameter('GlobalXfo').getValue() // force a cleaning.
    // this.invGroupXfo = newGlobal.inverse()

    this.getParameter('GlobalXfo').setValue(xfo);
    this.groupTransformOp.setBindXfo(xfo);

    this.memberXfoOps.forEach((op) => op.enable());
    this.calculatingGroupXfo = false;
    this.groupXfoDirty = false;
  }

  // ////////////////////////////////////////
  // Materials

  /**
   * The __updateMaterial method.
   * @private
   */
  __updateMaterial() {
    // Make this function async so that we don't pull on the
    // graph immediately when we receive a notification.
    // Note: propagating using an operator would be much better.
    new Promise((resolve) => {
      const material = this.getParameter('Material').getValue();

      // TODO: Bind an operator
      Array.from(this.__itemsParam.getValue()).forEach((item) => {
        item.traverse((treeItem) => {
          if (treeItem instanceof TreeItem && treeItem.hasParameter('Material')) {
            const p = treeItem.getParameter('Material');
            if (material) {
              const m = p.getValue();
              if (m != material) {
                p.__backupMaterial = m;
                p.loadValue(material);
              }
            } else if (p.__backupMaterial) {
              p.loadValue(p.__backupMaterial);
            }
          }
        }, false);
      });
      resolve();
    });
  }

  // ////////////////////////////////////////
  // Cutaways

  /**
   * The __updateCutaway method.
   * @private
   */
  __updateCutaway() {
    // Make this function async so that we don't pull on the
    // graph immediately when we receive a notification.
    // Note: propagating using an operator would be much better.
    new Promise((resolve) => {
      const cutEnabled = this.getParameter('CutAwayEnabled').getValue();
      const cutAwayVector = this.getParameter('CutPlaneNormal').getValue();
      const cutAwayDist = this.getParameter('CutPlaneDist').getValue();

      Array.from(this.__itemsParam.getValue()).forEach((item) => {
        item.traverse((treeItem) => {
          if (treeItem instanceof BaseGeomItem) {
            treeItem.setCutawayEnabled(cutEnabled);
            treeItem.setCutVector(cutAwayVector);
            treeItem.setCutDist(cutAwayDist);
          }
        }, true);
      });
      resolve();
    });
  }

  // ////////////////////////////////////////
  // Items

  /**
   *  sets the root item to be used as the search root.
   * @param {TreeItem} treeItem
   */

  setSearchRoot(treeItem) {
    this.searchRoot = treeItem;
  }

  setOwner(owner) {
    if (!this.searchRoot || this.searchRoot == this.getOwner()) this.searchRoot = owner;
    super.setOwner(owner);
  }

  /**
   * This method is mostly used in our demos,
   * and should be removed from the interface.
   *
   * @deprecated
   * @param {array} paths - The paths value.
   * @private
   */
  setPaths(paths) {
    this.clearItems(false);

    const searchRoot = this.getOwner();
    if (this.searchRoot == undefined) {
      console.warn('Group does not have an owner and so cannot resolve paths:', this.getName());
      return
    }
    const items = [];
    paths.forEach((path) => {
      const treeItem = this.searchRoot.resolvePath(path);
      if (treeItem) items.push(treeItem);
      else {
        console.warn('Path does not resolve to an Item:', path, ' group:', this.getName());
      }
    });
    this.setItems(items);
  }

  /**
   * Uses the specified list of paths to look and get each `BaseItem` object and add it to Group's `Items` parameter.
   *
   * @param {array} paths - The paths value.
   */
  resolveItems(paths) {
    this.setPaths(paths);
  }

  /**
   * The __bindItem method.
   * @param {BaseItem} item - The item value.
   * @param {number} index - The index value.
   * @private
   */
  __bindItem(item, index) {
    if (!(item instanceof TreeItem)) return

    item.on('mouseDown', this.onMouseDown);
    item.on('mouseUp', this.onMouseUp);
    item.on('mouseMove', this.onMouseMove);
    item.on('mouseEnter', this.onMouseEnter);
    item.on('mouseLeave', this.onMouseLeave);

    // ///////////////////////////////
    // Update the Material
    const material = this.getParameter('Material').getValue();
    if (material) {
      // TODO: Bind an operator instead
      item.traverse((treeItem) => {
        if (treeItem instanceof TreeItem && treeItem.hasParameter('Material')) {
          const p = treeItem.getParameter('Material');
          if (material) {
            const m = p.getValue();
            if (m != material) {
              p.__backupMaterial = m;
              p.loadValue(material);
            }
          }
        }
      }, true);
    }

    // ///////////////////////////////
    // Update the highlight
    if (item instanceof TreeItem && this.getParameter('Highlighted').getValue()) {
      const color = this.getParameter('HighlightColor').getValue();
      color.a = this.getParameter('HighlightFill').getValue();
      item.addHighlight('groupItemHighlight' + this.getId(), color, true);
    }

    // ///////////////////////////////
    // Update the item cutaway
    const cutEnabled = this.getParameter('CutAwayEnabled').getValue();
    if (cutEnabled) {
      const cutAwayVector = this.getParameter('CutPlaneNormal').getValue();
      const cutAwayDist = this.getParameter('CutPlaneDist').getValue();
      item.traverse((treeItem) => {
        if (treeItem instanceof BaseGeomItem) {
          // console.log("cutEnabled:", treeItem.getPath(), cutAwayVector.toString(), treeItem.getParameter('Material').getValue().getShaderName())
          treeItem.setCutawayEnabled(cutEnabled);
          treeItem.setCutVector(cutAwayVector);
          treeItem.setCutDist(cutAwayDist);
        }
      }, true);
    }

    if (!this.isVisible()) {
      // Decrement the visibility counter which might cause
      // this item to become invisible. (or it might already be invisible.)
      item.propagateVisibility(-1);
    }

    // const updateGlobalXfo = () => {
    //   const initialXfoMode = this.__initialXfoModeParam.getValue()
    //   if (initialXfoMode == GROUP_XFO_MODES.first && index == 0) {
    //     this.calcGroupXfo()
    //   } else if (
    //     initialXfoMode == GROUP_XFO_MODES.average ||
    //     initialXfoMode == GROUP_XFO_MODES.globalOri
    //   ) {
    //     this.calcGroupXfo()
    //   }
    // }

    if (item instanceof TreeItem) {
      const memberGlobalXfoParam = item.getParameter('GlobalXfo');
      const memberXfoOp = new GroupMemberXfoOperator(this.getParameter('GroupTransform'), memberGlobalXfoParam);
      this.memberXfoOps.splice(index, 0, memberXfoOp);

      item.getParameter('BoundingBox').on('valueChanged', this._setBoundingBoxDirty);
      this._bindXfoDirty = true;
    }

    // this.memberXfoOps[index] = item.getParameter('GlobalXfo').getValue()
    // eventHandlers.globalXfoChanged = (event) => {
    //   // If the item's xfo changees, potentially through its own hierarchy
    //   // then we need to re-bind here.
    //   if (!this.propagatingXfoToItems) {
    //     this.memberXfoOps[index] = item.getParameter('GlobalXfo').getValue()
    //     this.groupXfoDirty = true
    //     updateGlobalXfo()
    //   }
    // }
    // item.on('globalXfoChanged', eventHandlers.globalXfoChanged)

    item.on('boundingChanged', this._setBoundingBoxDirty);

    // updateGlobalXfo()
  }

  /**
   * The __unbindItem method.
   * @param {BaseItem} item - The item value.
   * @param {number} index - The index value.
   * @private
   */
  __unbindItem(item, index) {
    if (!(item instanceof TreeItem)) return

    item.removeHighlight('branchselected' + this.getId(), true);
    if (this.getParameter('Highlighted').getValue()) {
      item.removeHighlight('groupItemHighlight' + this.getId(), true);
    }

    if (!this.isVisible()) {
      // Increment the Visibility counter which might cause
      // this item to become visible.
      // It will stay invisible if its parent is invisible, or if
      // multiple groups connect to it and say it is invisible.
      item.propagateVisibility(1);
    }

    // ///////////////////////////////
    // Update the item cutaway
    item.traverse((treeItem) => {
      if (treeItem instanceof BaseGeomItem) {
        treeItem.setCutawayEnabled(false);
      }
    }, true);

    item.off('mouseDown', this.onMouseDown);
    item.off('mouseUp', this.onMouseUp);
    item.off('mouseMove', this.onMouseMove);
    item.off('mouseEnter', this.onMouseEnter);
    item.off('mouseLeave', this.onMouseLeave);

    if (item instanceof TreeItem) {
      this.memberXfoOps[index].detach();
      this.memberXfoOps.splice(index, 1);
      this._setBoundingBoxDirty();
      this._bindXfoDirty = true;
    }

    // const eventHandlers = this.__eventHandlers[index]
    // item.off('globalXfoChanged', eventHandlers.globalXfoChanged)
    item.off('boundingChanged', this._setBoundingBoxDirty);

    // this.__eventHandlers.splice(index, 1)
  }

  /**
   * Adds an item to the group(See `Items` parameter).
   *
   * @param {BaseItem} item - The item value.
   * @param {boolean} emit - The emit value.
   */
  addItem(item, emit = true) {
    if (!item) {
      console.warn('Error adding item to group. Item is null');
      return
    }
    this.__itemsParam.addItem(item, emit);

    if (emit) {
      this.calcGroupXfo();
    }
  }

  /**
   * Removes an item from the group(See `Items` parameter).
   *
   * @param {BaseItem} item - The item value.
   * @param {boolean} emit - The emit value.
   */
  removeItem(item, emit = true) {
    this.__itemsParam.removeItem(item, emit);
    if (emit) {
      this.calcGroupXfo();
    }
  }

  /**
   * Removes all items from the group and kind of returns the object to the default state.
   *
   * @param {boolean} emit - `true` triggers `valueChanged` event.
   */
  clearItems(emit = true) {
    // Note: Unbind reversed so that indices
    // do not get changed during the unbind.
    const items = Array.from(this.__itemsParam.getValue());
    for (let i = items.length - 1; i >= 0; i--) {
      this.__unbindItem(items[i], i);
    }
    // this.__eventHandlers = []
    this.memberXfoOps = [];
    this.__itemsParam.clearItems(emit);
    if (emit) {
      this.calcGroupXfo();
    }
  }

  /**
   * Returns the list of `BaseItem` objects owned by the group.
   *
   * @return {array} - The return value.
   */
  getItems() {
    return this.__itemsParam.getValue()
  }

  /**
   * Removes old items in current group and adds new ones.
   *
   * @param {array} items - List of `BaseItem` you want to add to the group
   */
  setItems(items) {
    this.clearItems(false);
    this.__itemsParam.setItems(items);
    this.calcGroupXfo();
  }

  /**
   * The _cleanBoundingBox method.
   * @param {Box3} bbox - The bounding box value.
   * @return {Box3} - The return value.
   * @private
   */
  _cleanBoundingBox(bbox) {
    const result = super._cleanBoundingBox(bbox);
    const items = Array.from(this.__itemsParam.getValue());
    items.forEach((item) => {
      if (item instanceof TreeItem) {
        if (item.isVisible()) {
          result.addBox3(item.getParameter('BoundingBox').getValue());
        }
      }
    });
    return result
  }

  // ///////////////////////
  // Events

  /**
   * Occurs when a user presses a mouse button over an element.
   * Note: these methods are useful for debugging mouse event propagation to groups
   *
   * @private
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseDown(event) {
    super.onMouseDown(event);
  }

  /**
   * Occurs when a user releases a mouse button over an element.
   * Note: these methods are useful for debugging mouse event propagation to groups
   *
   * @private
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseUp(event) {
    super.onMouseUp(event);
  }

  /**
   * Occur when the mouse pointer is moving  while over an element.
   * Note: these methods are useful for debugging mouse event propagation to groups
   * @private
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseMove(event) {
    super.onMouseMove(event);
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context) {
    const j = super.toJSON(context);
    const items = Array.from(this.__itemsParam.getValue());
    const treeItems = [];
    items.forEach((p) => {
      const path = p.getPath();
      treeItems.push(context ? context.makeRelative(path) : path);
    });
    j.treeItems = treeItems;
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context) {
    super.fromJSON(j, context);

    if (!j.treeItems) {
      console.warn('Invalid Parameter JSON');
      return
    }
    if (!context) {
      throw new Error('Unable to load JSON on a Group without a load context')
    }
    let count = j.treeItems.length;

    const addItem = (path) => {
      context.resolvePath(
        path,
        (treeItem) => {
          this.addItem(treeItem);
          count--;
          if (count == 0) {
            this.calculatingGroupXfo = true;
            this.calcGroupXfo();
            this.calculatingGroupXfo = false;
          }
        },
        (reason) => {
          console.warn("Group: '" + this.getName() + "'. Unable to load item:" + path);
        }
      );
    };
    for (const path of j.treeItems) {
      addItem(path);
    }
  }

  // ////////////////////////////////////////
  // Clone and Destroy

  /**
   * The clone method constructs a new group,
   * copies its values and returns it.
   *
   * @return {Group} - Returns a new cloned group.
   */
  clone() {
    const cloned = new Group();
    cloned.copyFrom(this);
    return cloned
  }

  /**
   * Copies current Group with all owned items.
   *
   * @param {Group} src - The group to copy from.
   */
  copyFrom(src) {
    super.copyFrom(src);
  }
}

Registry.register('Group', Group);

var WorkerFactory$1 = createBase64WorkerFactory$2('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwovKioNCiAqIFN0cmluZyBmdW5jdGlvbnMNCiAqDQogKi8NCmNsYXNzIFN0cmluZ0Z1bmN0aW9ucyB7DQogIC8qKg0KICAgKiBSZXBsYWNlcyBhbGwgbWF0Y2hlcyBpbiBhIHN0cmluZy4NCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0NCiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBwYXR0ZXJuIC0NCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VtZW50IC0NCiAgICogQHJldHVybiB7c3RyaW5nfSAtDQogICAqLw0KICBzdGF0aWMgcmVwbGFjZUFsbChzdHIsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7DQogICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKSwgcmVwbGFjZW1lbnQpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBKU09OIG9iamVjdCBhcyBhIGZvcm1hdHRlZCBzdHJpbmcsIGJ1dCB0aGUgbnVtZXJpYyB2YWx1ZXMgYXJlIGZpeGVkIHRvIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7b2JqZWN0fSB2YWwgLQ0KICAgKiBAcGFyYW0ge251bWJlcn0gW3NwYWNlPTBdIC0NCiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249NV0gLQ0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0NCiAgICovDQogIHN0YXRpYyBzdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHZhbCwgc3BhY2UgPSAwLCBwcmVjaXNpb24gPSA1KSB7DQogICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KA0KICAgICAgdmFsLA0KICAgICAgKGtleSwgdmFsKSA9PiB7DQogICAgICAgIHJldHVybiB2YWwgPyAodmFsLnRvRml4ZWQgPyBOdW1iZXIodmFsLnRvRml4ZWQocHJlY2lzaW9uKSkgOiB2YWwpIDogdmFsDQogICAgICB9LA0KICAgICAgc3BhY2UNCiAgICApDQogIH0NCg0KICAvKioNCiAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSBudW1lcmljIHZhbHVlLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7Kn0gc3RyIC0NCiAgICogQHJldHVybiB7bnVtYmVyfSAtDQogICAqLw0KICBzdGF0aWMgaGFzaFN0cihzdHIpIHsNCiAgICBsZXQgaGFzaCA9IDA7DQogICAgbGV0IGk7DQogICAgbGV0IGNocjsNCiAgICBsZXQgbGVuOw0KICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaA0KICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykgew0KICAgICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7DQogICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyOw0KICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXINCiAgICB9DQogICAgcmV0dXJuIE1hdGguYWJzKGhhc2gpDQogIH0NCn0KCi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2UNCg0KLyoqDQogKiBCYXNlIGNsYXNzIGZvciBNYXRoIHR5cGVzIHRoYXQgY2FuIGJlIHN0b3JlZCBpbiB2ZXJ0ZXggYXR0cmlidXRlcy4NCiAqIDxicj4NCiAqICoqTm90ZToqKiBUaGVzZSB2YWx1ZXMgdXNlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSB2YWx1ZXMgdG8gc3RvcmUgdGhlaXIgZGF0YS4NCiAqLw0KY2xhc3MgQXR0clZhbHVlIHsNCiAgLyoqDQogICAqIFZlcmlmaWVzIGlmIHRoZSB2YWx1ZXMgc3RvcmVkIGluIHRoaXMgTWF0aCB0eXBlIGFyZSB2YWxpZCBudW1lcmljIHZhbHVlcy4NCiAgICogUmV0dXJucyBgZmFsc2VgIElmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGlzIGVpdGhlciB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2lhL09iamV0b3NfZ2xvYmFsZXMvSW5maW5pdHl8SW5maW5pdHl9IG9yDQogICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9OYU58TmFOfS4NCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBib29sZWFuLg0KICAgKi8NCiAgaXNWYWxpZCgpIHsNCiAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5fX2RhdGEpIHsNCiAgICAgIGlmICh2ID09IEluZmluaXR5IHx8IGlzTmFOKHYpKSByZXR1cm4gZmFsc2UNCiAgICB9DQoNCiAgICByZXR1cm4gdHJ1ZQ0KICB9DQoNCiAgLyoqDQogICAqIFRoaXMgbWV0aG9kIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlcyBvZiBtYXRoIHR5cGVzLCBnaXZlbiBhbiBleGlzdGluZyBGbG9hdDMyQXJyYXkgYnVmZmVyLg0KICAgKiBFYWNoIE1hdGggdHlwZSBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGFuIGNvbnN0cnVjdGVkIHZhbHVlLg0KICAgKg0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSB0aGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gdGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7QXR0clZhbHVlfSAtIFJldHVybnMgdGhlIGNvbnN0cnVjdGVkIHZhbHVlLg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0KSB7DQogICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6JyArIHRoaXMuY29uc3RydWN0b3IubmFtZSkNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGlzIG1ldGhvZCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXMgb2YgbWF0aCB0eXBlcywgZ2l2ZW4gYW4gZXhpc3RpbmcgQXJyYXlCdWZmZXIuDQogICAqIEVhY2ggTWF0aCB0eXBlIGltcGxlbWVudHMgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYW4gY29uc3RydWN0ZWQgdmFsdWUuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyDQogICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0DQogICAqIEByZXR1cm4ge0F0dHJWYWx1ZX0gLSBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RlZCB2YWx1ZS4NCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkgew0KICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCBmb3IgdGhpcyB0eXBlOicgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIEZsb2F0MzIgZWxlbWVudHMgdXNlZCBieSB0aGlzIHR5cGUuIFVzZWQgdG8gY2FsY3VsYXRlIHN0b3JhZ2UgcmVxdWlyZW1lbnRzIGZvciBsYXJnZSBhcnJheXMgb2YgdGhpcyB0eXBlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZsb2F0IHZhbHVlcyBzdG9yZWQgaW4gdGhpcyBtYXRoIHR5cGUuDQogICAqLw0KICBzdGF0aWMgbnVtRWxlbWVudHMoKSB7DQogICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6JyArIHRoaXMuY29uc3RydWN0b3IubmFtZSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGN1cnJlbnQgTWF0aCB0eXBlIGRhdGEgYXMgYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLg0KICAgKg0KICAgKiBAcmV0dXJuIHthcnJheX0gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuDQogICAqLw0KICBhc0FycmF5KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRoaXMgTWF0aCB0eXBlIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRvU3RyaW5nKCkgew0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpDQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgdGhpcyBNYXRoIHR5cGUgdG8gYSBKU09OIG9iamVjdC4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTigpIHsNCiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoaXMgdHlwZTonICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKQ0KICB9DQp9Cgpjb25zdCBVSW50OCA9IDA7DQpjb25zdCBTSW50OCA9IDE7DQpjb25zdCBVSW50MTYgPSAyOw0KY29uc3QgU0ludDE2ID0gMzsNCmNvbnN0IFVJbnQzMiA9IDQ7DQpjb25zdCBTSW50MzIgPSA1Ow0KY29uc3QgRmxvYXQzMiA9IDY7DQoNCi8qKg0KICogTWF0aCBGdW5jdGlvbnMNCiAqLw0KY2xhc3MgTWF0aEZ1bmN0aW9ucyB7DQogIC8qKg0KICAgKiBDb252ZXJ0cyBSYWRpYW5zIHRvIERlZ3JlZXMNCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gUmFkaWFucyB2YWx1ZQ0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gRGVncmVlcyBlcXVpdmFsZW50DQogICAqLw0KICBzdGF0aWMgcmFkVG9EZWcocmFkKSB7DQogICAgcmV0dXJuIHJhZCAvIChNYXRoLlBJIC8gMTgwKQ0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIERlZ3JlZXMgdG8gUmFkaWFudHMNCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gZGVnIC0gRGVncmVlcyB2YWx1ZQ0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gIFJhZGlhbnMgZXF1aXZhbGVudA0KICAgKi8NCiAgc3RhdGljIGRlZ1RvUmFkKGRlZykgew0KICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MCkNCiAgfQ0KDQogIC8qKg0KICAgKiBWZXJpZmllcyBpZiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlciBpcyBudW1lcmljLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfGFueX0gbnVtYmVyIC0gTnVtYmVyIHRvIHRlc3QNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBgdHJ1ZWAgd2hlbiBpcyBhIHZhbGlkIG51bWJlcg0KICAgKi8NCiAgc3RhdGljIGlzTnVtZXJpYyhudW1iZXIpIHsNCiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobnVtYmVyKSkgJiYgaXNGaW5pdGUobnVtYmVyKQ0KICB9DQoNCiAgLyoqDQogICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBMb3dlciB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIEhpZ2hlc3QgdmFsdWUgcmFuZG9tIGludCBjYW4gYmUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSYW5kb20gbnVtYmVyIGluc2lkZSByYW5nZS4NCiAgICovDQogIHN0YXRpYyByYW5kb21JbnQobWluLCBtYXgpIHsNCiAgICBtaW4gPSBNYXRoLmNlaWwobWluKTsNCiAgICBtYXggPSBNYXRoLmZsb29yKG1heCk7DQogICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbg0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgYSBsaW5lYWwgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBpbnB1dHMgZm9yIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyKHQpLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2MCAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2MSAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0NCiAgICogQHJldHVybiB7bnVtYmVyfSAtDQogICAqLw0KICBzdGF0aWMgbGVycCh2MCwgdjEsIHQpIHsNCiAgICByZXR1cm4gdjAgKyB0ICogKHYxIC0gdjApDQogIH0NCg0KICAvKioNCiAgICogUmVzdHJpY3RzIHRoZSBzcGVjaWZpZWQgdmFsdWUgYmV0d2VlbiB0d28gbnVtYmVycw0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZQ0KICAgKiBAcGFyYW0ge251bWJlcn0gbWluDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtYXgNCiAgICogQHJldHVybiB7bnVtYmVyfQ0KICAgKi8NCiAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkgew0KICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG5lYXJlc3QgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4NCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLQ0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0NCiAgICovDQogIHN0YXRpYyBuZWFyZXN0UG93Mih2YWx1ZSkgew0KICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLnJvdW5kKE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKDIpKSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBuZWFyZXN0IHBvdyBvZiB0ZW4gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0NCiAgICogQHJldHVybiB7bnVtYmVyfSAtDQogICAqLw0KICBzdGF0aWMgbmVhcmVzdFBvdzEwKHZhbHVlKSB7DQogICAgcmV0dXJuIE1hdGgucG93KDEwLCBNYXRoLnJvdW5kKE1hdGgubG9nMTAodmFsdWUpIC8gTWF0aC5sb2cxMCgxMCkpKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG5leHQgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4NCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLQ0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0NCiAgICovDQogIHN0YXRpYyBuZXh0UG93Mih2YWx1ZSkgew0KICAgIGxldCBleHAgPSAwOw0KDQogICAgd2hpbGUgKHZhbHVlID4gMCkgew0KICAgICAgZXhwKys7DQogICAgICB2YWx1ZSA9IHZhbHVlID4+IDE7DQogICAgfQ0KDQogICAgcmV0dXJuIDEgPDwgZXhwDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgZnJhY3Rpb25hbCBjb21wb25lbnQgb2YgYSBudW1iZXINCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLQ0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0NCiAgICovDQogIHN0YXRpYyBmcmFjdCh2YWx1ZSkgew0KICAgIGlmICh2YWx1ZSA9PSAwKSByZXR1cm4gMA0KICAgIGlmICh2YWx1ZSA8IDApIHsNCiAgICAgIGlmICh2YWx1ZSA+IC0xLjApIHJldHVybiAtdmFsdWUNCiAgICAgIHJldHVybiAtdmFsdWUgJSBNYXRoLmZsb29yKC12YWx1ZSkNCiAgICB9DQogICAgaWYgKHZhbHVlIDwgMS4wKSByZXR1cm4gdmFsdWUNCiAgICByZXR1cm4gdmFsdWUgJSBNYXRoLmZsb29yKHZhbHVlKQ0KICB9DQoNCiAgLyoqDQogICAqIE1vdmVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSBvbmUgbnVtZXJpYyBkb21haW4ocmFuZ2UpIHRvIGFub3RoZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0NCiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0MSAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQxIC0NCiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0MiAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQyIC0NCiAgICogQHJldHVybiB7bnVtYmVyfSAtDQogICAqLw0KICBzdGF0aWMgcmVtYXAodmFsdWUsIHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7DQogICAgcmV0dXJuIHN0YXJ0MiArIChlbmQyIC0gc3RhcnQyKSAqICgodmFsdWUgLSBzdGFydDEpIC8gKGVuZDEgLSBzdGFydDEpKQ0KICB9DQoNCiAgLyoqDQogICAqIFBlcmZvcm0gSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZhbHVlcw0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlMCAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlMSAtDQogICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0NCiAgICogQHJldHVybiB7bnVtYmVyfSAtDQogICAqLw0KICBzdGF0aWMgc21vb3RoU3RlcChlZGdlMCwgZWRnZTEsIHgpIHsNCiAgICBjb25zdCB0ID0gdGhpcy5jbGFtcCgoeCAtIGVkZ2UwKSAvIChlZGdlMSAtIGVkZ2UwKSwgMC4wLCAxLjApOw0KICAgIHJldHVybiB0ICogdCAqICgzLjAgLSAyLjAgKiB0KQ0KICB9DQoNCiAgLyoqDQogICAqIFBlcmZvcm1zIC0gaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2YWx1ZXMNCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZTAgLQ0KICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZTEgLQ0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtDQogICAqIEByZXR1cm4ge251bWJlcn0gLQ0KICAgKi8NCiAgc3RhdGljIGxpblN0ZXAoZWRnZTAsIGVkZ2UxLCB4KSB7DQogICAgcmV0dXJuIHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKQ0KICB9DQoNCiAgLyoqDQogICAqIERlY29kZXMgYSBGbG9hdDE2IGZyb20gdHdvIHVuc2lnbmVkIEludDgNCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGMgLSBBcnJheSB3aXRoIHRoZSB0d28gVUludDgNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIERlY29kZWQgRmxvYXQxNg0KICAgKi8NCiAgc3RhdGljIGRlY29kZTE2Qml0RmxvYXRGcm9tMnhVSW50OChjKSB7DQogICAgY29uc3QgaXggPSBjWzBdOyAvLyAxc3QgYnl0ZTogMSBiaXQgc2lnbmVkIG51bSwgNCBiaXRzIGV4cG9uZW50LCAzIGJpdHMgbWFudGlzc2EgKE1TQikNCiAgICBjb25zdCBpeSA9IGNbMV07IC8vIDJuZCBieXRlOiA4IGJpdCBtYW50aXNzYSAoTFNCKQ0KDQogICAgY29uc3QgcyA9IGl4ICYgMHg4MCA/IDEgOiAtMTsgLy8gZ2V0IGJpdCA4DQogICAgY29uc3QgaWV4cCA9IChpeCAmIDB4NzgpID4+IDM7IC8vIG1hc2sgYml0cyA3LTQNCiAgICBjb25zdCBtc2IgPSBpeCAmIDB4NzsgLy8gbWFzayBiaXRzIDMtMQ0KDQogICAgbGV0IG5vcm0gPSBpZXhwID09IDAgPyAwIDogMjA0ODsgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBub3JtYWxpemVkIGFuZCBzdWItbm9ybWFsaXplZCBudW1iZXJzDQogICAgY29uc3QgbWFudGlzc2EgPSBub3JtICsgKG1zYiA8PCA4KSArIGl5OyAvLyBpbXBsaWNpdCBwcmVjZWRpbmcgMSBvciAwIGFkZGVkIGhlcmUNCiAgICBub3JtID0gaWV4cCA9PSAwID8gMSA6IDA7IC8vIG5vcm1hbGl6YXRpb24gdG9nZ2xlDQogICAgY29uc3QgZXhwb25lbnQgPSBNYXRoLnBvdygyLCBpZXhwICsgbm9ybSAtIDE2KTsgLy8gLTUgZm9yIHRoZSB0aGUgZXhwb25lbnQgYmlhcyBmcm9tIDJeLTUgdG8gMl4xMCBwbHVzIGFub3RoZXIgLTExIGZvciB0aGUgbm9ybWFsaXplZCAxMiBiaXQgbWFudGlzc2ENCiAgICBjb25zdCB2ID0gcyAqIG1hbnRpc3NhICogZXhwb25lbnQ7DQoNCiAgICByZXR1cm4gdg0KICB9DQoNCiAgLyoqDQogICAqIEVuY29kZXMgYW4gYXJyYXkgb2YgdHdvIHVuc2lnbmVkIEludDggdG8gYSBGbG9hdDE2DQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtudW1iZXJ9IHYgLSBGbG9hdDE2IG51bWJlcg0KICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIEVuY29kZWQgVW5zaWduZWQgSW50OCBhcnJheQ0KICAgKi8NCiAgc3RhdGljIGVuY29kZTE2Qml0RmxvYXRJbnRvMnhVSW50OCh2KSB7DQogICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KDIpOw0KICAgIC8vIGNvbnN0IGMgPSBbMCwgMF07DQogICAgY29uc3Qgc2lnbnVtID0gdiA+PSAwID8gMTI4IDogMDsNCiAgICB2ID0gTWF0aC5hYnModik7DQogICAgbGV0IGV4cG9uZW50ID0gMTU7DQogICAgbGV0IGxpbWl0ID0gMTAyNDsgLy8gY29uc2lkZXJpbmcgdGhlIGJpYXMgZnJvbSAyXi01IHRvIDJeMTAgKD09MTAyNCkNCiAgICBmb3IgKGxldCBleHAgPSAxNTsgZXhwID4gMDsgZXhwLS0pIHsNCiAgICAgIGlmICh2IDwgbGltaXQpIHsNCiAgICAgICAgbGltaXQgLz0gMjsNCiAgICAgICAgZXhwb25lbnQtLTsNCiAgICAgIH0NCiAgICB9DQoNCiAgICBsZXQgcmVzdDsNCiAgICBpZiAoZXhwb25lbnQgPT0gMCkgew0KICAgICAgcmVzdCA9IHYgLyBsaW1pdCAvIDI7IC8vICJzdWItbm9ybWFsaXplIiBpbXBsaWNpdCBwcmVjZWRpbmcgMC4NCiAgICB9IGVsc2Ugew0KICAgICAgcmVzdCA9ICh2IC0gbGltaXQpIC8gbGltaXQ7IC8vIG5vcm1hbGl6ZSBhY2NvcmRpbmdseSB0byBpbXBsaWNpdCBwcmVjZWRpbmcgMS4NCiAgICB9DQoNCiAgICBjb25zdCBtYW50aXNzYSA9IE1hdGgucm91bmQocmVzdCAqIDIwNDgpOyAvLyAyMDQ4ID0gMl4xMSBmb3IgdGhlIChzcGxpdCkgMTEgYml0IG1hbnRpc3NhDQogICAgY29uc3QgbXNiID0gbWFudGlzc2EgLyAyNTY7IC8vIHRoZSBtb3N0IHNpZ25pZmljYW50IDMgYml0cyBnbyBpbnRvIHRoZSBsb3dlciBwYXJ0IG9mIHRoZSBmaXJzdCBieXRlDQogICAgY29uc3QgbHNiID0gbWFudGlzc2EgLSBtc2IgKiAyNTY7IC8vIHRoZXJlIGdvIHRoZSBvdGhlciA4IGJpdCBvZiB0aGUgbG93ZXIgc2lnbmlmaWNhbmNlDQoNCiAgICBjWzBdID0gc2lnbnVtICsgZXhwb25lbnQgKiA4ICsgbXNiOyAvLyBjb2xvciBub3JtYWxpemF0aW9uIGZvciB0ZXh0dXJlMkQNCiAgICBjWzFdID0gbHNiOw0KDQogICAgaWYgKHYgPj0gMjA0OCkgew0KICAgICAgY1swXSA9IDI1NTsNCiAgICB9DQoNCiAgICByZXR1cm4gYw0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zZm9ybXMgYSAxNiBiaXQgZmxvYXQgdG8gYW4gZW5jb2RlZCBpbnRlZ2VyLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2IC0gRmxvYXQxNiBudW1iZXIgdG8gZW5jb2RlDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBFbmNvZGVkIG51bWJlcg0KICAgKi8NCiAgc3RhdGljIGVuY29kZTE2Qml0RmxvYXQodikgew0KICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7DQogICAgZmxvYXQzMkFycmF5WzBdID0gdjsNCiAgICBjb25zdCBpbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyQXJyYXkuYnVmZmVyKTsNCg0KICAgIGNvbnN0IHRvVUludDE2ID0gKHgpID0+IHsNCiAgICAgIGxldCBiaXRzID0gKHggPj4gMTYpICYgMHg4MDAwOyAvKiBHZXQgdGhlIHNpZ24gKi8NCiAgICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmOyAvKiBLZWVwIG9uZSBleHRyYSBiaXQgZm9yIHJvdW5kaW5nICovDQogICAgICBjb25zdCBlID0gKHggPj4gMjMpICYgMHhmZjsgLyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovDQoNCiAgICAgIC8qIElmIHplcm8sIG9yIGRlLW5vcm1hbCwgb3IgZXhwb25lbnQgdW5kZXJmbG93cyB0b28gbXVjaCBmb3IgYSBkZS1ub3JtYWwNCiAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi8NCiAgICAgIGlmIChlIDwgMTAzKSB7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIC8qIElmIE5hTiwgcmV0dXJuIE5hTi4gSWYgSW5mIG9yIGV4cG9uZW50IG92ZXJmbG93LCByZXR1cm4gSW5mLiAqLw0KICAgICAgaWYgKGUgPiAxNDIpIHsNCiAgICAgICAgYml0cyB8PSAweDdjMDA7DQogICAgICAgIC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTiwNCiAgICAgICAgICogbm90IEluZiwgc28gbWFrZSBzdXJlIHdlIHNldCBvbmUgbWFudGlzc2EgYml0IHRvby4gKi8NCiAgICAgICAgYml0cyB8PSAoZSA9PSAyNTUgPyAwIDogMSkgJiYgeCAmIDB4MDA3ZmZmZmY7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIC8qIElmIGV4cG9uZW50IHVuZGVyZmxvd3MgYnV0IG5vdCB0b28gbXVjaCwgcmV0dXJuIGEgZGUtbm9ybWFsICovDQogICAgICBpZiAoZSA8IDExMykgew0KICAgICAgICBtIHw9IDB4MDgwMDsNCiAgICAgICAgLyogRXh0cmEgcm91bmRpbmcgbWF5IG92ZXJmbG93IGFuZCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgZXhwb25lbnQNCiAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovDQogICAgICAgIGJpdHMgfD0gKG0gPj4gKDExNCAtIGUpKSArICgobSA+PiAoMTEzIC0gZSkpICYgMSk7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKTsNCiAgICAgIC8qIEV4dHJhIHJvdW5kaW5nLiBBbiBvdmVyZmxvdyB3aWxsIHNldCBtYW50aXNzYSB0byAwIGFuZCBpbmNyZW1lbnQNCiAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovDQogICAgICBiaXRzICs9IG0gJiAxOw0KDQogICAgICByZXR1cm4gYml0cw0KICAgIH07DQoNCiAgICByZXR1cm4gdG9VSW50MTYoaW50MzJWaWV3WzBdKQ0KICB9DQoNCiAgLyoqDQogICAqIEFzIG9wcG9zaXRlIG9mIHRoZSBgZW5jb2RlMTZCaXRGbG9hdGAgbWV0aG9kLCB0aGlzIHRha2VzIGFuIGVuY29kZWQgaW50ZWdlciB2YWx1ZSwNCiAgICogYW5kIHJldHVybnMgdGhlIDE2IGJpdCBmbG9hdC4NCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge251bWJlcn0gaCAtIEVuY29kZWQgaW50ZWdlcg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gRGVjb2RlZCAxNiBiaXQgZmxvYXQuDQogICAqLw0KICBzdGF0aWMgZGVjb2RlMTZCaXRGbG9hdChoKSB7DQogICAgY29uc3QgcyA9IChoICYgMHg4MDAwKSA+PiAxNTsNCiAgICBjb25zdCBlID0gKGggJiAweDdjMDApID4+IDEwOw0KICAgIGNvbnN0IGYgPSBoICYgMHgwM2ZmOw0KDQogICAgaWYgKGUgPT0gMCkgew0KICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIE1hdGgucG93KDIsIC0xNCkgKiAoZiAvIE1hdGgucG93KDIsIDEwKSkNCiAgICB9IGVsc2UgaWYgKGUgPT0gMHgxZikgew0KICAgICAgcmV0dXJuIGYgPyBOYU4gOiAocyA/IC0xIDogMSkgKiBJbmZpbml0eQ0KICAgIH0NCg0KICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBNYXRoLnBvdygyLCBlIC0gMTUpICogKDEgKyBmIC8gTWF0aC5wb3coMiwgMTApKQ0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgRmxvYXQgMzIgdG8gYW4gYXJyYXkgb2YgdW5zaWduZWQgSW50MTYuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJBcnJheSAtDQogICAqIEByZXR1cm4ge1VpbnQxNkFycmF5fSAtIFVuc2lnbmVkIEludDE2IGFycmF5IHJlcHJlc2VudGF0aXZlIG9mIHRoZSBGbG9hdDMyQXJyYXkNCiAgICovDQogIHN0YXRpYyBjb252ZXJ0RmxvYXQzMkFycmF5VG9VSW50MTZBcnJheShmbG9hdDMyQXJyYXkpIHsNCiAgICBjb25zdCB1bml0MTZzID0gbmV3IFVpbnQxNkFycmF5KGZsb2F0MzJBcnJheS5sZW5ndGgpOw0KICAgIGNvbnN0IGludDMyVmlldyA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJBcnJheS5idWZmZXIpOw0KICAgIGNvbnN0IHRvVUludDE2ID0gKHgpID0+IHsNCiAgICAgIGxldCBiaXRzID0gKHggPj4gMTYpICYgMHg4MDAwOyAvKiBHZXQgdGhlIHNpZ24gKi8NCiAgICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmOyAvKiBLZWVwIG9uZSBleHRyYSBiaXQgZm9yIHJvdW5kaW5nICovDQogICAgICBjb25zdCBlID0gKHggPj4gMjMpICYgMHhmZjsgLyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovDQoNCiAgICAgIC8qIElmIHplcm8sIG9yIGRlLW5vcm1hbCwgb3IgZXhwb25lbnQgdW5kZXJmbG93cyB0b28gbXVjaCBmb3IgYSBkZS1ub3JtYWwNCiAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi8NCiAgICAgIGlmIChlIDwgMTAzKSB7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIC8qIElmIE5hTiwgcmV0dXJuIE5hTi4gSWYgSW5mIG9yIGV4cG9uZW50IG92ZXJmbG93LCByZXR1cm4gSW5mLiAqLw0KICAgICAgaWYgKGUgPiAxNDIpIHsNCiAgICAgICAgYml0cyB8PSAweDdjMDA7DQogICAgICAgIC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTiwNCiAgICAgICAgICogbm90IEluZiwgc28gbWFrZSBzdXJlIHdlIHNldCBvbmUgbWFudGlzc2EgYml0IHRvby4gKi8NCiAgICAgICAgYml0cyB8PSAoZSA9PSAyNTUgPyAwIDogMSkgJiYgeCAmIDB4MDA3ZmZmZmY7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIC8qIElmIGV4cG9uZW50IHVuZGVyZmxvd3MgYnV0IG5vdCB0b28gbXVjaCwgcmV0dXJuIGEgZGUtbm9ybWFsICovDQogICAgICBpZiAoZSA8IDExMykgew0KICAgICAgICBtIHw9IDB4MDgwMDsNCiAgICAgICAgLyogRXh0cmEgcm91bmRpbmcgbWF5IG92ZXJmbG93IGFuZCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgZXhwb25lbnQNCiAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovDQogICAgICAgIGJpdHMgfD0gKG0gPj4gKDExNCAtIGUpKSArICgobSA+PiAoMTEzIC0gZSkpICYgMSk7DQogICAgICAgIHJldHVybiBiaXRzDQogICAgICB9DQoNCiAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKTsNCiAgICAgIC8qIEV4dHJhIHJvdW5kaW5nLiBBbiBvdmVyZmxvdyB3aWxsIHNldCBtYW50aXNzYSB0byAwIGFuZCBpbmNyZW1lbnQNCiAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovDQogICAgICBiaXRzICs9IG0gJiAxOw0KDQogICAgICByZXR1cm4gYml0cw0KICAgIH07DQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbG9hdDMyQXJyYXkubGVuZ3RoOyBpKyspIHsNCiAgICAgIHVuaXQxNnNbaV0gPSB0b1VJbnQxNihpbnQzMlZpZXdbaV0pOw0KICAgIH0NCiAgICByZXR1cm4gdW5pdDE2cw0KICB9DQp9CgpsZXQgX3JlZ2lzdGVyZWRCbHVlcHJpbnRzID0ge307DQpsZXQgX2JsdWVwcmludE5hbWVzID0ge307DQpsZXQgX2JsdWVwcmludHMgPSBbXTsNCg0KLyoqDQogKiBSZWdpc3RyeSBpcyBhIHN0YXRpYyBmYWN0b3J5IHRoYXQgaGFuZGxlcyByZWdpc3RyYXRpb24vcmVjb25zdHJ1Y3Rpb24gb2YNCiAqIHBlcnNpc3RlZCB0eXBlIG9mIGRhdGEsIHRoaXMgaW5jbHVkZXMgY2xhc3NlcyBhbmQgdHlwZXMuDQogKg0KICogTm90ZTogYmx1ZXByaW50TmFtZSBpcyByZXF1aXJlZCBiZWNhdXNlIG9uIG1pbmlmaWNhdGlvbiBwcm9jZXNzDQogKiB0aGUgbmFtZSBvZiBjbGFzc2VzIGNoYW5nZSBhbmQgd2UgY2FuJ3Qgc2ltcGx5IHVzZSAnLi4uLmNvbnN0cnVjdG9yLm5hbWUnLg0KICogU28sIHdlIG5lZWQgYSB3YXkgb2YgcmVsYXRpbmcgbWluaWZpZWQgYmx1ZXByaW50IG5hbWVzIHRvIHRoZSBvbmUgc3RvcmVkIGZvciBwZXJzaXN0ZW5jeS4NCiAqIDxicj4NCiAqIGkuZS4NCiAqIGBgYGphdmFzY3JpcHQNCiAqIC8vIEltcG9ydCByZWdpc3RyeSBjbGFzcw0KICogY2xhc3MgRm9vKCkge30NCiAqDQogKiBSZWdpc3RyeS5yZWdpc3RlcignRm9vJywgRm9vKQ0KICogLy8gSW4gY2FzZSAnRm9vJyBjbGFzcyBnZXRzIGl0cyBuYW1lIGNoYW5nZWQgdG8gJ2MnIG9uIG1pbmlmaWNhdGlvbiwNCiAqIC8vIGFuZCB0aGUgcGVyc2lzdGVkIGRhdGEgdHlwZSBpcyAnRm9vJywgd2Ugd291bGQga25vdyBob3cgdG8gcmVsYXRlIHRoZW0uDQogKiBgYGANCiAqDQogKiBAc3RhdGljDQogKiBAY2xhc3MgUmVnaXN0cnkNCiAqLw0KY29uc3QgUmVnaXN0cnkgPSB7DQogIC8qKg0KICAgKiBSZWdpc3RlcnMgYSBuZXcgYmx1ZXByaW50IGluIHRoZSBmYWN0b3J5Lg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gYmx1ZXByaW50TmFtZSAtIE5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgYmx1ZXByaW50KENsYXNzLCB0eXBlLCBldGMpDQogICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVtYmVyfGFueX0gYmx1ZXByaW50IC0gQmx1ZXByaW50IHJlcHJlc2VudGF0aW9uKENsYXNzIGZ1bmN0aW9uLCB0eXBlKQ0KICAgKi8NCiAgcmVnaXN0ZXI6IChibHVlcHJpbnROYW1lLCBibHVlcHJpbnQpID0+IHsNCiAgICBpZiAoX3JlZ2lzdGVyZWRCbHVlcHJpbnRzW2JsdWVwcmludE5hbWVdKSB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlJ3MgYSBjbGFzcyByZWdpc3RlcmVkIHdpdGggJyR7Ymx1ZXByaW50TmFtZX0nIG5hbWVgKQ0KICAgIF9yZWdpc3RlcmVkQmx1ZXByaW50c1tibHVlcHJpbnROYW1lXSA9IHsgYmx1ZXByaW50LCBjYWxsYmFja3M6IFtdIH07DQoNCiAgICAvLyBOb3RlOiBUbyBwcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBzYW1lIGJsdWVwcmludCBjYW4gYmUgc3RvcmVkIHVuZGVyIG11bHRpcGxlIG5hbWVzLg0KICAgIC8vIFRoYXRzIHRoZSByZWFzb24gYmVoaW5kIHVzaW5nIGluZGV4ZXMgaW5zdGVhZCBvZiB0aGUgYmx1ZXByaW50Lg0KICAgIGNvbnN0IGJsdWVwcmludEluZGV4ID0gX2JsdWVwcmludHMubGVuZ3RoOw0KICAgIF9ibHVlcHJpbnRzLnB1c2goYmx1ZXByaW50KTsNCiAgICBfYmx1ZXByaW50TmFtZXNbYmx1ZXByaW50SW5kZXhdID0gYmx1ZXByaW50TmFtZTsNCiAgfSwNCiAgLyoqDQogICAqIFJldHVybnMgYmx1ZXByaW50IGZ1bmN0aW9uL3R5cGUgYnkgc3BlY2lmeWluZyBpdHMgbmFtZS4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGJsdWVwcmludE5hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGJsdWVwcmludChDbGFzcywgdHlwZSwgZXRjKQ0KICAgKiBAcmV0dXJuIHtmdW5jdGlvbnxudW1iZXJ8YW55fSAtIEJsdWVwcmludCByZXByZXNlbnRhdGlvbihDbGFzcyBmdW5jdGlvbiwgdHlwZSkNCiAgICovDQogIGdldEJsdWVwcmludDogKGJsdWVwcmludE5hbWUpID0+IHsNCiAgICBpZiAoX3JlZ2lzdGVyZWRCbHVlcHJpbnRzW2JsdWVwcmludE5hbWVdKSByZXR1cm4gX3JlZ2lzdGVyZWRCbHVlcHJpbnRzW2JsdWVwcmludE5hbWVdLmJsdWVwcmludA0KDQogICAgdGhyb3cgbmV3IEVycm9yKGAke2JsdWVwcmludE5hbWV9IGJsdWVwcmludCBpcyBub3QgcmVnaXN0ZXJlZGApDQogIH0sDQogIC8qKg0KICAgKiBSZXR1cm5zIGNsYXNzIG5hbWUgdXNpbmcgcGFzc2luZyBhbiBpbnN0YW50aWF0ZWQgb2JqZWN0Lg0KICAgKiBJZiBpdCBpcyBub3QgcmVnaXN0ZXJlZCwgdGhlIG5hbWUgaW4gY29uc3RydWN0b3IgaXMgcmV0dXJuZWQuDQogICAqDQogICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVtYmVyfGFueXx1bmRlZmluZWR9IGJsdWVwcmludEluc3RhbmNlIC0gQmx1ZXByaW50IHJlcHJlc2VudGF0aW9uKENsYXNzIGZ1bmN0aW9uLCB0eXBlKQ0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gTmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBibHVlcHJpbnQoQ2xhc3MsIHR5cGUsIGV0YykNCiAgICovDQogIGdldEJsdWVwcmludE5hbWU6IChibHVlcHJpbnRJbnN0YW5jZSkgPT4gew0KICAgIGxldCBibHVlcHJpbnQgPSBibHVlcHJpbnRJbnN0YW5jZTsNCiAgICBsZXQgYmx1ZXByaW50TmFtZSA9IGJsdWVwcmludEluc3RhbmNlOw0KDQogICAgaWYgKHR5cGVvZiBibHVlcHJpbnRJbnN0YW5jZSA9PT0gJ29iamVjdCcpIHsNCiAgICAgIGJsdWVwcmludCA9IGJsdWVwcmludEluc3RhbmNlLmNvbnN0cnVjdG9yOw0KICAgICAgYmx1ZXByaW50TmFtZSA9IGJsdWVwcmludC5uYW1lOw0KICAgIH0NCg0KICAgIGNvbnN0IGJsdWVwcmludElkID0gX2JsdWVwcmludHMuaW5kZXhPZihibHVlcHJpbnQpOw0KICAgIGlmIChibHVlcHJpbnRJZCA+PSAwICYmIF9ibHVlcHJpbnROYW1lc1tibHVlcHJpbnRJZF0pIHJldHVybiBfYmx1ZXByaW50TmFtZXNbYmx1ZXByaW50SWRdDQoNCiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Ymx1ZXByaW50TmFtZX0gYmx1ZXByaW50IGlzIG5vdCByZWdpc3RlcmVkYCkNCiAgfSwNCiAgLyoqDQogICAqIEFjY2VwdGluZyB0aGUgY2xhc3MgbmFtZSBhbmQgYE5gIG51bWJlciBvZiBhcmd1bWVudHMsIGluc3RhbnRpYXRlcyBhIG5ldyBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBjbGFzcy4NCiAgICogSWYgdGhlIGNsYXNzIGlzIG5vdCByZWdpc3RlcmVkLCB0aGVuIGBudWxsYCBpcyByZXR1cm5lZC4NCiAgICogPGJyPg0KICAgKiAqKk5vdGU6KiogQWx0aG91Z2ggdGhlIGNsYXNzIGFyZ3VtZW50cyBhcmUgbm90IGxpdGVyYWxseSBzcGVjaWZpZWQgaW4gdGhlIHBhcmFtZXRlcnMsDQogICAqIHlvdSBjYW4gcGFzcyB0aGVtKEFzIG1hbnkgYXMgbmVlZGVkKS4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGJsdWVwcmludE5hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGJsdWVwcmludChDbGFzcywgdHlwZSwgZXRjKQ0KICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gLSBJbnN0YW50aWF0ZWQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgY2xhc3MNCiAgICovDQogIGNvbnN0cnVjdENsYXNzOiAoYmx1ZXByaW50TmFtZSwgLi4uYXJncykgPT4gew0KICAgIGNvbnN0IGJsdWVwcmludERhdGEgPSBfcmVnaXN0ZXJlZEJsdWVwcmludHNbYmx1ZXByaW50TmFtZV07DQogICAgaWYgKCFibHVlcHJpbnREYXRhKSB0aHJvdyBuZXcgRXJyb3IoYCR7Ymx1ZXByaW50TmFtZX0gYmx1ZXByaW50IGlzIG5vdCByZWdpc3RlcmVkYCkNCg0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgcmV0dXJuIG5ldyBibHVlcHJpbnREYXRhLmJsdWVwcmludCguLi5hcmdzKQ0KICB9LA0KICAvKioNCiAgICogRm9yIHRlc3RpbmcgcHVycG9zZSBvbmx5LCBuZXZlciBjYWxsIHRoaXMgb3V0c2lkZSBvZiB0aGUgdGVzdCBzY29wZS4NCiAgICoNCiAgICogQHByaXZhdGUNCiAgICovDQogIGZsdXNoOiAoKSA9PiB7DQogICAgX3JlZ2lzdGVyZWRCbHVlcHJpbnRzID0ge307DQogICAgX2JsdWVwcmludE5hbWVzID0ge307DQogICAgX2JsdWVwcmludHMgPSBbXTsNCiAgfSwNCn07DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdVSW50OCcsIFVJbnQ4KTsNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdTSW50OCcsIFNJbnQ4KTsNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdVSW50MTYnLCBVSW50MTYpOw0KUmVnaXN0cnkucmVnaXN0ZXIoJ1NJbnQxNicsIFNJbnQxNik7DQpSZWdpc3RyeS5yZWdpc3RlcignVUludDMyJywgVUludDMyKTsNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdTSW50MzInLCBTSW50MzIpOw0KUmVnaXN0cnkucmVnaXN0ZXIoJ0Zsb2F0MzInLCBGbG9hdDMyKTsKCi8qKg0KICogUmVwcmVzZW50aW5nIGEgVmVjMih0d28tZGltZW5zaW9uYWwgZmxvYXRpbmcgcG9pbnQgdmVjdG9yKS4gQSBWZWMyIGlzIGZvciByZXByZXNlbnRpbmcgMiBkaW1lbnNpb25hbCB2YWx1ZXMsIHN1Y2ggYXMgc2NyZWVuIGNvb3JkaW5hdGVzIG9yIHBpeGVsIGNvb3JkaW5hdGVzIHdpdGhpbiBhbiBpbWFnZS4NCiAqDQogKiBNYXRoIHR5cGVzIGludGVybmFsbHkgc3RvcmUgdmFsdWVzIGluIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSBhbmQNCiAqIGV4cG9zZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciB0aGUgY29tcG9uZW50IHZhbHVlcy4NCiAqDQogKiBAZXh0ZW5kcyBBdHRyVmFsdWUNCiAqLw0KY2xhc3MgVmVjMiBleHRlbmRzIEF0dHJWYWx1ZSB7DQogIC8qKg0KICAgKiBDcmVhdGVzIGEgVmVjMi4NCiAgICoNCiAgICogVGhlIHR5cGUgb2YgdmFsdWVzIG9mIHRoZSBgKHgsIHkpYCBjb29yZGluYXRlcyBjYW4gYmUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9LA0KICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVWludDMyQXJyYXl8VWludDMyQXJyYXl9LA0KICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50MzJBcnJheXxJbnQzMkFycmF5fSBhbmQNCiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VzL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNpYS9PYmpldG9zX2dsb2JhbGVzL0FycmF5QnVmZmVyfEFycmF5QnVmZmVyfS4NCiAgICogPGJyPg0KICAgKg0KICAgKiBgYGBqYXZhc2NyaXB0DQogICAqICBjb25zdCBteVZlYzIgPSBuZXcgVmVjMigxLjIsIDMuNCkNCiAgICogYGBgDQogICAqDQogICAqIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cywgY3JlYXRlIGEgVmVjMiB0aGF0IHdyYXBzIHNvbWUgcGFydCBvZiBpdC4NCiAgICogYGBgamF2YXNjcmlwdA0KICAgKiAgY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNikNCiAgICogIGZsb2F0QXJyYXlbMF0gPSAxLjINCiAgICogIGZsb2F0QXJyYXlbMV0gPSAzLjQNCiAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKGZsb2F0QXJyYXkpDQogICAqICBjb25zb2xlLmxvZyhteVZlYzIudG9KU09OKCkpDQogICAqIGBgYA0KICAgKiBUaGUgcmVzdWx0aW5nIG91dHB1dA0KICAgKiBgYGBqc29uDQogICAqICA+IHsgeDoxLjIsIHk6My40IH0NCiAgICogYGBgDQogICAqDQogICAqIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cywgY3JlYXRlIGEgVmVjMiB0aGF0IHdyYXBzIHNvbWUgcGFydCBvZiBpdC4NCiAgICogYGBgamF2YXNjcmlwdA0KICAgKiAgY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNikNCiAgICogIGZsb2F0QXJyYXlbMF0gPSAxLjINCiAgICogIGZsb2F0QXJyYXlbMV0gPSAzLjQNCiAgICogIGZsb2F0QXJyYXlbMl0gPSA1LjYNCiAgICogIGZsb2F0QXJyYXlbM10gPSA3LjgNCiAgICogIGZsb2F0QXJyYXlbNF0gPSA5LjANCiAgICogIGZsb2F0QXJyYXlbNV0gPSAxLjkNCiAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKGZsb2F0QXJyYXkuYnVmZmVyLCA4KQ0KICAgKiAgY29uc29sZS5sb2cobXlWZWMyLnRvSlNPTigpKQ0KICAgKiBgYGANCiAgICogVGhlIHJlc3VsdGluZyBvdXRwdXQNCiAgICogYGBganNvbg0KICAgKiAgPiB7IHg6NS42LCB5OjcuOCB9DQogICAqIGBgYA0KICAgKg0KICAgKiBZb3UgY2FuIGFsc28gcGFzcyBvbmUgSlNPTiBvYmplY3QgcGFyYW1ldGVyLg0KICAgKiBgYGBqYXZhc2NyaXB0DQogICAqICBjb25zdCBteVZlYzIgPSBuZXcgVmVjMih7IHg6MS4yLCB5OjMuNCB9KQ0KICAgKiBgYGANCiAgICoNCiAgICogQHBhcmFtIHtOdW1iZXJ8RmxvYXQzMkFycmF5fFVpbnQzMkFycmF5fGpzb259IHggLSBUaGUgeCB2YWx1ZS4gRGVmYXVsdCBpcyAwLg0KICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB5IHZhbHVlLiBEZWZhdWx0IGlzIDAuDQogICAqLw0KICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHsNCiAgICBzdXBlcigpOw0KDQogICAgaWYgKHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgeCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7DQogICAgICB0aGlzLl9fZGF0YSA9IHg7DQogICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsNCiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYCk7DQogICAgICBjb25zdCBidWZmZXIgPSB4Ow0KICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHk7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAyKTsNCiAgICB9IGVsc2UgaWYgKHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PSAnb2JqZWN0Jykgew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDIpOw0KICAgICAgdGhpcy5mcm9tSlNPTih4KTsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDIpOw0KICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4Ow0KICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5Ow0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB4YCBjb21wb25lbnQuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB4IGNvbXBvbmVudC4NCiAgICovDQogIGdldCB4KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVswXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgYHhgIGNvbXBvbmVudC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeCh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB5YCBjb21wb25lbnQuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IGNvbXBvbmVudC4NCiAgICovDQogIGdldCB5KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgYHlgIGNvbXBvbmVudC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsxXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb21wb25lbnQuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAtIFRoZSB5IGNvbXBvbmVudC4NCiAgICovDQogIHNldCh4LCB5KSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB4Ow0KICAgIHRoaXMuX19kYXRhWzFdID0geTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXBsYWNlcyB0aGlzIFZlYzIgZGF0YSB3aXRoIHRoZSBWZWMyIGRhdGEgcGFzc2VkIGFzIHBhcmFtZXRlci4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHNldCBmcm9tLg0KICAgKi8NCiAgc2V0RnJvbU90aGVyKG90aGVyKSB7DQogICAgdGhpcy54ID0gb3RoZXIueDsNCiAgICB0aGlzLnkgPSBvdGhlci55Ow0KICB9DQoNCiAgLyoqDQogICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBhbm90aGVyIFZlYzIuDQogICAqDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgYXJlIHRoZSBzYW1lIFZlY3Rvciwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgKi8NCiAgZXF1YWwob3RoZXIpIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjaXNFcXVhbCBpbnN0ZWFkLicpOw0KICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpDQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGFub3RoZXIgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiBhcmUgdGhlIHNhbWUgVmVjdG9yLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAqLw0KICBpc0VxdWFsKG90aGVyKSB7DQogICAgcmV0dXJuIHRoaXMueCA9PSBvdGhlci54ICYmIHRoaXMueSA9PSBvdGhlci55DQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuDQogICAqDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFZlYzJzIGFyZSBkaWZmZXJlbnQsIG90aGVyd2lzZSwgYGZhbHNlYC4NCiAgICovDQogIG5vdEVxdWFscyhvdGhlcikgew0KICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNub3RFcXVhbCBpbnN0ZWFkLicpOw0KICAgIHJldHVybiB0aGlzLm5vdEVxdWFsKG90aGVyKQ0KICB9DQoNCiAgLyoqDQogICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWMyLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBWZWMycyBhcmUgZGlmZmVyZW50LCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAqLw0KICBub3RFcXVhbChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnggIT0gb3RoZXIueCAmJiB0aGlzLnkgIT0gb3RoZXIueQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzIgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHByZWNpc2lvbiAmJiBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvbg0KICB9DQoNCiAgLyoqDQogICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGFkZC4NCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAqLw0KICBhZGQob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSkNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIGEgVmVjMiB0byB0aGlzIFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBhZGQuDQogICAqLw0KICBhZGRJblBsYWNlKG90aGVyKSB7DQogICAgdGhpcy54ICs9IG90aGVyLng7DQogICAgdGhpcy55ICs9IG90aGVyLnk7DQogIH0NCg0KICAvKioNCiAgICogU3VidHJhY3RzIGEgVmVjMiBmcm9tIHRoaXMgVmVjMiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBzdWJ0cmFjdC4NCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAqLw0KICBzdWJ0cmFjdChvdGhlcikgew0KICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55KQ0KICB9DQoNCiAgLyoqDQogICAqIFN1YnRyYWN0cyBhIFZlYzIgZnJvbSB0aGlzIFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBzdWJ0cmFjdC4NCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAqLw0KICBzdWJ0cmFjdEluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggLT0gb3RoZXIueDsNCiAgICB0aGlzLnkgLT0gb3RoZXIueTsNCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIFNjYWxlcyB0aGlzIFZlYzIgYnkgc2NhbGFyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgKi8NCiAgc2NhbGUoc2NhbGFyKSB7DQogICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKQ0KICB9DQoNCiAgLyoqDQogICAqIFNjYWxlcyB0aGlzIFZlYzIgYnkgc2NhbGFyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS4NCiAgICovDQogIHNjYWxlSW5QbGFjZShzY2FsYXIpIHsNCiAgICB0aGlzLnggKj0gc2NhbGFyOw0KICAgIHRoaXMueSAqPSBzY2FsYXI7DQogIH0NCg0KICAvKioNCiAgICogSW52ZXJ0cyB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICovDQogIGludmVydCgpIHsNCiAgICByZXR1cm4gbmV3IFZlYzIoMS4wIC8gdGhpcy54LCAxLjAgLyB0aGlzLnkpDQogIH0NCg0KICAvKioNCiAgICogSW52ZXJ0cyB0aGlzIFZlYzIuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGludmVydEluUGxhY2UoKSB7DQogICAgdGhpcy54ID0gMS4wIC8gdGhpcy54Ow0KICAgIHRoaXMueSA9IDEuMCAvIHRoaXMueTsNCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIE11bHRpcGxpZXMgYSBWZWMyIHdpdGggdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIG11bHRpcGx5IHdpdGguDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgKi8NCiAgbXVsdGlwbHkob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICogb3RoZXIueCwgdGhpcy55ICogb3RoZXIueSkNCiAgfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIGEgVmVjMiB3aXRoIHRoaXMgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIG11bHRpcGx5IHdpdGguDQogICAqLw0KICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggKj0gb3RoZXIueDsNCiAgICB0aGlzLnkgKj0gb3RoZXIueTsNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIFZlYzIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGggc3F1YXJlZC4NCiAgICovDQogIGxlbmd0aFNxdWFyZWQoKSB7DQogICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOw0KICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICByZXR1cm4geCAqIHggKyB5ICogeQ0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFZlYzIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAqLw0KICBsZW5ndGgoKSB7DQogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0byBhbm90aGVyIHZlY3Rvci4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciB2YWx1ZS4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9ycy4NCiAgICovDQogIGRpc3RhbmNlVG8ob3RoZXIpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF0gLSBvdGhlci54Ow0KICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXSAtIG90aGVyLnk7DQogICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KQ0KICB9DQoNCiAgLyoqDQogICAqIE5vcm1hbGl6ZXMgdGhlIFZlYzIgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgVmVjMi4NCiAgICogTXVsdGlwbGllcyBjb29yZGVuYXRlcyB2YWx1ZSBieSB0aGUgaW52ZXJzZSBvZiB0aGUgdmVjdG9yIGxlbmd0aC4NCiAgICoNCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIHRoZSBWZWMyIG5vcm1hbGl6ZWQuDQogICAqLw0KICBub3JtYWxpemUoKSB7DQogICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOw0KICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeTsNCiAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgIHJldHVybiBuZXcgVmVjMigpDQogICAgfQ0KDQogICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/DQogICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOw0KICAgIHJldHVybiBuZXcgVmVjMih4ICogbGVuLCB5ICogbGVuKQ0KICB9DQoNCiAgLyoqDQogICAqIE5vcm1hbGl6ZXMgdGhpcyBWZWMyIG11bHRpcGx5aW5nIGNvb3JkZW5hdGUgdmFsdWVzIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLg0KICAgKi8NCiAgbm9ybWFsaXplSW5QbGFjZSgpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5Ow0KICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICB0aGlzLnNldCh4ICogbGVuLCB5ICogbGVuKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzIgYWdhaW5zdCBhbm90aGVyIFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdC4NCiAgICovDQogIGRvdChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueQ0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyBWZWMyIGFnYWluc3QgYW5vdGhlciBWZWMyLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdC4NCiAgICovDQogIGNyb3NzKG90aGVyKSB7DQogICAgLy8ganVzdCBjYWxjdWxhdGUgdGhlIHotY29tcG9uZW50DQogICAgcmV0dXJuIHRoaXMueCAqIG90aGVyLnkgLSB0aGlzLnkgKiBvdGhlci54DQogIH0NCg0KICAvKioNCiAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIFZlYzIgYW5kIG90aGVyIGFzc3VtaW5nIGJvdGggYXJlIG5vcm1hbGl6ZWQgdmVjdG9ycy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuDQogICAqLw0KICBhbmdsZVRvKG90aGVyKSB7DQogICAgY29uc3QgY29zaW5lID0gdGhpcy5ub3JtYWxpemUoKS5kb3Qob3RoZXIubm9ybWFsaXplKCkpOw0KICAgIGlmIChjb3NpbmUgPiAxLjApIHJldHVybiAwLjANCiAgICBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSByZXR1cm4gTWF0aC5QSQ0KICAgIGVsc2UgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpDQogIH0NCg0KICAvKioNCiAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIFZlYzIgYW5kIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucy4NCiAgICovDQogIHNpZ25lZEFuZ2xlVG8ob3RoZXIpIHsNCiAgICBjb25zdCBhbmdsZSA9IHRoaXMuYW5nbGVUbyhvdGhlcik7DQogICAgaWYgKHRoaXMuY3Jvc3Mob3RoZXIpIDwgMC4wKSByZXR1cm4gLWFuZ2xlDQogICAgZWxzZSByZXR1cm4gYW5nbGUNCiAgfQ0KDQogIC8qKg0KICAgKiBSb3RhdGVzIGEgVmVjMiBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgcm90YXRlZCBWZWMyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0ICBvci4NCiAgICovDQogIHJvdGF0ZShhbmdsZSkgew0KICAgIGNvbnN0IGNvc2EgPSBNYXRoLmNvcyhhbmdsZSk7DQogICAgY29uc3Qgc2luYSA9IE1hdGguc2luKGFuZ2xlKTsNCiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICogY29zYSAtIHRoaXMueSAqIHNpbmEsIHRoaXMueCAqIHNpbmEgKyB0aGlzLnkgKiBjb3NhKQ0KICB9DQoNCiAgLyoqDQogICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGlzIFZlYzIgYW5kIG90aGVyIFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgKi8NCiAgbGVycChvdGhlciwgdCkgew0KICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgIHJldHVybiBuZXcgVmVjMihheCArIHQgKiAob3RoZXIueCAtIGF4KSwgYXkgKyB0ICogKG90aGVyLnkgLSBheSkpDQogIH0NCg0KICAvKioNCiAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZS4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkLg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBzZXRSYW5kb21EaXIoc2NhbGUgPSAxLjApIHsNCiAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUEk7DQogICAgdGhpcy5fX2RhdGFbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTsNCiAgICB0aGlzLl9fZGF0YVsxXSA9IE1hdGguc2luKHIpICogelNjYWxlOw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogUmFuZG9taXplcyB0aGUgc2NhbGUgb2YgdGhpcyBWZWMyIGNvb3JkZW5hdGVzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSBUaGUgc2NhbGUgdmFsdWUuDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHNldFJhbmRvbShzY2FsZSA9IDEuMCkgew0KICAgIHRoaXMuX19kYXRhWzBdID0gTWF0aC5yYW5kb20oKSAqIHNjYWxlOw0KICAgIHRoaXMuX19kYXRhWzFdID0gTWF0aC5yYW5kb20oKSAqIHNjYWxlOw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogQ2xvbmVzIHRoaXMgVmVjMiBhbmQgcmV0dXJucyBhIG5ldyBWZWMyLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICovDQogIGNsb25lKCkgew0KICAgIHJldHVybiBuZXcgVmVjMih0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0pDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBjdXJyZW50IFZlYzIgZGF0YSBhcyBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAqDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYW4gYXJyYXkuDQogICAqLw0KICBhc0FycmF5KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBTdGF0aWMgTWV0aG9kcw0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGEgbmV3IFZlYzIuDQogICAqIEBzZWUgYG5ldyBWZWMyYA0KICAgKg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgVmVjMiguLi5hcmdzKQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBuZXcgVmVjMiB0byB3cmFwIGV4aXN0aW5nIG1lbW9yeSBpbiBhIGJ1ZmZlci4NCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkgew0KICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZCwgdXNlICNjcmVhdGVGcm9tQnVmZmVyIGluc3RlYWQnKTsNCiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNCkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgYFZlYzJgIHVzaW5nIGFuIEFycmF5QnVmZmVyLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIGJ5dGVPZmZzZXQpIHsNCiAgICByZXR1cm4gbmV3IFZlYzIobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDIpKSAvLyA0IGJ5dGVzIHBlciAzMmJpdCBmbG9hdA0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBjcmVhdGVGcm9tRmxvYXQzMkFycmF5IG1ldGhvZC4NCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkFycmF5KGFycmF5KSB7DQogICAgcmV0dXJuIG5ldyBWZWMyKGFycmF5KQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBGbG9hdDMyIGVsZW1lbnRzIHVzZWQgYnkgdGhpcyB0eXBlLiBVc2VkIHRvIGNhbGN1bGF0ZSBzdG9yYWdlIHJlcXVpDQogICAqIGVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIG51bUVsZW1lbnRzKCkgew0KICAgIHJldHVybiAyDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogRW5jb2RlcyBWZWMyIENsYXNzIGFzIGEgSlNPTiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICB4OiB0aGlzLngsDQogICAgICB5OiB0aGlzLnksDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIERlY29kZXMgYSBKU09OIG9iamVjdCB0byBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgY2xhc3MuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMueCA9IGoueDsNCiAgICB0aGlzLnkgPSBqLnk7DQogIH0NCg0KICAvKioNCiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgIHRoaXMueCA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdWZWMyJywgVmVjMik7CgovKioNCiAqIFJlcHJlc2VudHMgYSB0aHJlZSBkaW1lbnNpb25hbCBjb29yZGluYXRlLCBzdWNoIGFzIDNEIHNjZW5lIHZhbHVlcywgb3IgbWVzaCB2ZXJ0ZXggcG9zaXRpb25zLg0KICoNCiAqIE1hdGggdHlwZXMgaW50ZXJuYWxseSBzdG9yZSB2YWx1ZXMgaW4ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9IGFuZA0KICogZXhwb3NlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIHRoZSBjb21wb25lbnQgdmFsdWVzLg0KICoNCiAqIEBleHRlbmRzIEF0dHJWYWx1ZQ0KICovDQpjbGFzcyBWZWMzJDEgZXh0ZW5kcyBBdHRyVmFsdWUgew0KICAvKioNCiAgICogQ3JlYXRlcyBhIFZlYzMuDQogICAqDQogICAqIFRoZSB0eXBlIG9mIHZhbHVlcyBvZiB0aGUgYCh4LCB5LCB6KWAgY29vcmRlbmF0ZXMgY2FuIGJlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSwNCiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1VpbnQzMkFycmF5fFVpbnQzMkFycmF5fSwNCiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludDMyQXJyYXl8SW50MzJBcnJheX0gYW5kDQogICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lcy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9BcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlcn0uDQogICAqIDxicj4NCiAgICogWW91IGNhbiBhbHNvIHBhc3Mgb25lIEpTT04gb2JqZWN0IHBhcmFtZXRlci4NCiAgICoNCiAgICogQHBhcmFtIHtOdW1iZXJ8RmxvYXQzMkFycmF5fGpzb259IHggLSBUaGUgeCB2YWx1ZS4gRGVmYXVsdCBpcyAwLg0KICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHZhbHVlLiBEZWZhdWx0IGlzIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHogdmFsdWUuIERlZmF1bHQgaXMgMC4NCiAgICovDQogIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDApIHsNCiAgICBzdXBlcigpOw0KICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSkgew0KICAgICAgdGhpcy5fX2RhdGEgPSB4Ow0KICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7DQogICAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDMpKWApOw0KICAgICAgY29uc3QgYnVmZmVyID0geDsNCiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5Ow0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgMyk7DQogICAgfSBlbHNlIGlmICh4ICE9IG51bGwgJiYgdHlwZW9mIHggPT0gJ29iamVjdCcpIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTsNCiAgICAgIHRoaXMuZnJvbUpTT04oeCk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKTsNCiAgICAgIHRoaXMuX19kYXRhWzBdID0geDsNCiAgICAgIHRoaXMuX19kYXRhWzFdID0geTsNCiAgICAgIHRoaXMuX19kYXRhWzJdID0gejsNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeGAgY29tcG9uZW50Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeCBjb21wb25lbnQuDQogICAqLw0KICBnZXQgeCgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMF0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGB4YCBjb21wb25lbnQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHgodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeWAgY29tcG9uZW50Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeSBjb21wb25lbnQuDQogICAqLw0KICBnZXQgeSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGB5YCBjb21wb25lbnQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHkodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgemAgY29tcG9uZW50Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeiBjb21wb25lbnQuDQogICAqLw0KICBnZXQgeigpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGB6YCBjb21wb25lbnQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHoodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeHlgIHN3aXp6ZWwuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyB0aGUgeiBjb21wb25lbnQuDQogICAqLw0KICBnZXQgeHkoKSB7DQogICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSkNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB5emAgc3dpenplbC4NCiAgICoNCiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudC4NCiAgICovDQogIGdldCB5eigpIHsNCiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdKQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvbXBvbmVudC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb21wb25lbnQuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHkgY29tcG9uZW50Lg0KICAgKi8NCiAgc2V0KHgsIHksIHopIHsNCiAgICB0aGlzLnggPSB4Ow0KICAgIHRoaXMueSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiB4Ow0KICAgIHRoaXMueiA9IHogIT09IHVuZGVmaW5lZCA/IHogOiB4Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIHN0YXRlIG9mIGEgVmVjMyBPYmplY3QuDQogICAqDQogICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyQXJyYXkgLSBUaGUgZmxvYXQzMkFycmF5IHZhbHVlLg0KICAgKi8NCiAgc2V0RGF0YUFycmF5KGZsb2F0MzJBcnJheSkgew0KICAgIHRoaXMuX19kYXRhID0gZmxvYXQzMkFycmF5Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIHN0YXRlIG9mIGEgVmVjMyBPYmplY3QgZnJvbSBhbm90aGVyIFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBzZXQgZnJvbS4NCiAgICovDQogIHNldEZyb21PdGhlcihvdGhlcikgew0KICAgIHRoaXMueCA9IG90aGVyLng7DQogICAgdGhpcy55ID0gb3RoZXIueTsNCiAgICB0aGlzLnogPSBvdGhlci56Ow0KICB9DQoNCiAgLyoqDQogICAqIENoZWNrcyBpZiB0aGUgY29vcmRlbmF0ZXMgb2YgdGhpcyBWZWMzIGFyZSAwIDAgMC4NCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29vcmRlbmF0ZXMgYXJlKDAsIDAsIDApLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAqLw0KICBpc051bGwoKSB7DQogICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnkpIDwgTnVtYmVyLkVQU0lMT04gJiYgTWF0aC5hYnModGhpcy56KSA8IE51bWJlci5FUFNJTE9ODQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoZSBjb29yZGVuYXRlcyBvZiB0aGlzIFZlYzMgYXJlIDEgMSAxLg0KICAgKg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb29yZGVuYXRlcyBhcmUoMSwgMSwgMSksIG90aGVyd2lzZSwgYGZhbHNlYC4NCiAgICovDQogIGlzMTExKCkgew0KICAgIHJldHVybiAoDQogICAgICBNYXRoLmFicygxLjAgLSB0aGlzLngpIDwgTnVtYmVyLkVQU0lMT04gJiYNCiAgICAgIE1hdGguYWJzKDEuMCAtIHRoaXMueSkgPCBOdW1iZXIuRVBTSUxPTiAmJg0KICAgICAgTWF0aC5hYnMoMS4wIC0gdGhpcy56KSA8IE51bWJlci5FUFNJTE9ODQogICAgKQ0KICB9DQoNCiAgLyoqDQogICAqIEBkZXByZWNhdGVkDQogICAqIENoZWNrcyBpZiB0aGlzIFZlYzMgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBhbm90aGVyIFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgYXJlIHRoZSBzYW1lIFZlY3Rvciwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgKi8NCiAgZXF1YWwob3RoZXIpIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjaXNFcXVhbCBpbnN0ZWFkLicpOw0KICAgIHJldHVybiB0aGlzLmVxdWFscyhvdGhlcikNCiAgfQ0KDQogIC8qKg0KICAgKiBDaGVja3MgaWYgdGhpcyBWZWMzIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgYW5vdGhlciBWZWMzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIGFyZSB0aGUgc2FtZSBWZWN0b3IsIG90aGVyd2lzZSwgYGZhbHNlYC4NCiAgICovDQogIGlzRXF1YWwob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnoNCiAgfQ0KDQogIC8qKg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKiBDaGVja3MgaWYgdGhpcyBWZWMyIGlzIGRpZmZlcmVudCBmcm9tIGFub3RoZXIgVmVjMi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgVmVjM3MgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgKi8NCiAgbm90RXF1YWxzKG90aGVyKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI25vdEVxdWFsIGluc3RlYWQuJyk7DQogICAgcmV0dXJuIHRoaXMubm90RXF1YWwob3RoZXIpDQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFZlYzNzIGFyZSBkaWZmZXJlbnQsIG90aGVyd2lzZSwgYGZhbHNlYC4NCiAgICovDQogIG5vdEVxdWFsKG90aGVyKSB7DQogICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55ICYmIHRoaXMueiAhPSBvdGhlci56DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgVmVjMiBpcyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIC0gVGhlIHByZWNpc2lvbiB0byB3aGljaCB0aGUgdmFsdWVzIG11c3QgbWF0Y2guDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgKi8NCiAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7DQogICAgcmV0dXJuICgNCiAgICAgIE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgcHJlY2lzaW9uICYmDQogICAgICBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvbiAmJg0KICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb24NCiAgICApDQogIH0NCg0KICAvKioNCiAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzMgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBhZGQuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgYWRkKG90aGVyKSB7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueikNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgVmVjMy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGFkZC4NCiAgICovDQogIGFkZEluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggKz0gb3RoZXIueDsNCiAgICB0aGlzLnkgKz0gb3RoZXIueTsNCiAgICB0aGlzLnogKz0gb3RoZXIuejsNCiAgfQ0KDQogIC8qKg0KICAgKiBTdWJ0cmFjdHMgb3RoZXIgZnJvbSB0aGlzIFZlYzMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gc3VidHJhY3QuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56KQ0KICB9DQoNCiAgLyoqDQogICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjMy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIHN1YnRyYWN0Lg0KICAgKi8NCiAgc3VidHJhY3RJblBsYWNlKG90aGVyKSB7DQogICAgdGhpcy54IC09IG90aGVyLng7DQogICAgdGhpcy55IC09IG90aGVyLnk7DQogICAgdGhpcy56IC09IG90aGVyLno7DQogIH0NCg0KICAvKioNCiAgICogTXVsdGlwbGllcyB0d28gVmVjM3MgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqLw0KICBtdWx0aXBseShvdGhlcikgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKHRoaXMueCAqIG90aGVyLngsIHRoaXMueSAqIG90aGVyLnksIHRoaXMueiAqIG90aGVyLnopDQogIH0NCg0KICAvKioNCiAgICogTXVsdGlwbGllcyB0d28gVmVjM3MuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBtdWx0aXBseSB3aXRoLg0KICAgKi8NCiAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7DQogICAgdGhpcy54ICo9IG90aGVyLng7DQogICAgdGhpcy55ICo9IG90aGVyLnk7DQogICAgdGhpcy56ICo9IG90aGVyLno7DQogIH0NCg0KICAvKioNCiAgICogRGl2aWRlcyB0d28gVmVjM3MgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgb3RoZXIgVmVjMyB0byBkaXZpZGUgYnkuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgZGl2aWRlKHZlYzMpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSh0aGlzLnggLyB2ZWMzLngsIHRoaXMueSAvIHZlYzMueSwgdGhpcy56IC8gdmVjMy56KQ0KICB9DQoNCiAgLyoqDQogICAqIERpdmlkZXMgdHdvIFZlYzNzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgb3RoZXIgVmVjMyB0byBkaXZpZGUgYnkuDQogICAqLw0KICBkaXZpZGVJblBsYWNlKHZlYzMpIHsNCiAgICB0aGlzLnggLz0gdmVjMy54Ow0KICAgIHRoaXMueSAvPSB2ZWMzLnk7DQogICAgdGhpcy56IC89IHZlYzMuejsNCiAgfQ0KDQogIC8qKg0KICAgKiBTY2FsZXMgdGhpcyBWZWMzIGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICovDQogIHNjYWxlKHNjYWxhcikgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIpDQogIH0NCg0KICAvKioNCiAgICogU2NhbGVzIHRoaXMgVmVjMyBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgIHRoaXMueCAqPSBzY2FsYXI7DQogICAgdGhpcy55ICo9IHNjYWxhcjsNCiAgICB0aGlzLnogKj0gc2NhbGFyOw0KICB9DQoNCiAgLyoqDQogICAqIE5lZ2F0ZXMgdGhpcyBWZWMzICh4ID0gLXgsIHkgPSAteSBhbmQgeiA9IC16KSwgYnV0IHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICovDQogIG5lZ2F0ZSgpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSgtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56KQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBWZWMzLCBidXQgcmV0dXJucy4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgaW52ZXJzZSgpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSgxLjAgLyB0aGlzLngsIDEuMCAvIHRoaXMueSwgMS4wIC8gdGhpcy56KQ0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgVmVjMy4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICovDQogIGxlbmd0aFNxdWFyZWQoKSB7DQogICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOw0KICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl07DQogICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeg0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFZlYzMuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAqLw0KICBsZW5ndGgoKSB7DQogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0byBhbm90aGVyIFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB2ZWN0b3JzLg0KICAgKi8NCiAgZGlzdGFuY2VUbyhvdGhlcikgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXSAtIG90aGVyLng7DQogICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdIC0gb3RoZXIueTsNCiAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl0gLSBvdGhlci56Ow0KICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KQ0KICB9DQoNCiAgLyoqDQogICAqIE5vcm1hbGl6ZXMgdGhlIFZlYzMgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgVmVjMy4NCiAgICogTXVsdGlwbGllcyBjb29yZGVuYXRlcyB2YWx1ZSBieSB0aGUgaW52ZXJzZSBvZiB0aGUgdmVjdG9yIGxlbmd0aC4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBWZWMzIG5vcm1hbGl6ZWQuDQogICAqLw0KICBub3JtYWxpemUoKSB7DQogICAgbGV0IGxlbiA9IHRoaXMuX19kYXRhWzBdICogdGhpcy5fX2RhdGFbMF0gKyB0aGlzLl9fZGF0YVsxXSAqIHRoaXMuX19kYXRhWzFdICsgdGhpcy5fX2RhdGFbMl0gKiB0aGlzLl9fZGF0YVsyXTsNCiAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgIHJldHVybiBuZXcgVmVjMyQxKCkNCiAgICB9DQoNCiAgICAvLyBUT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT8NCiAgICBsZW4gPSAxLjAgLyBNYXRoLnNxcnQobGVuKTsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSh0aGlzLl9fZGF0YVswXSAqIGxlbiwgdGhpcy5fX2RhdGFbMV0gKiBsZW4sIHRoaXMuX19kYXRhWzJdICogbGVuKQ0KICB9DQoNCiAgLyoqDQogICAqIE5vcm1hbGl6ZXMgdGhpcyBWZWMzIG11bHRpcGx5aW5nIGNvb3JkZW5hdGUgdmFsdWVzIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIG5vcm1hbGl6ZUluUGxhY2UoKSB7DQogICAgbGV0IGxlbiA9IHRoaXMuX19kYXRhWzBdICogdGhpcy5fX2RhdGFbMF0gKyB0aGlzLl9fZGF0YVsxXSAqIHRoaXMuX19kYXRhWzFdICsgdGhpcy5fX2RhdGFbMl0gKiB0aGlzLl9fZGF0YVsyXTsNCiAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgIHJldHVybg0KICAgIH0NCiAgICBsZW4gPSBNYXRoLnNxcnQobGVuKTsNCiAgICBjb25zdCB0bXAgPSAxLjAgLyBsZW47DQogICAgdGhpcy5fX2RhdGFbMF0gKj0gdG1wOw0KICAgIHRoaXMuX19kYXRhWzFdICo9IHRtcDsNCiAgICB0aGlzLl9fZGF0YVsyXSAqPSB0bXA7DQoNCiAgICByZXR1cm4gbGVuDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBWZWMzIHdpdGggdGhlIG5ldyBjb29yZGVuYXRlcyhjYWxjdWxhdGVkIHdpdGggdGhpcyBWZWMzIGNvb3JkZW5hdGVzIGFuZCB0aGUgc3BlY2lmaWVkIGxlbmd0aCkuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICByZXNpemUobGVuZ3RoKSB7DQogICAgY29uc3QgY3VycmxlbiA9IHRoaXMuX19kYXRhWzBdICogdGhpcy5fX2RhdGFbMF0gKyB0aGlzLl9fZGF0YVsxXSAqIHRoaXMuX19kYXRhWzFdICsgdGhpcy5fX2RhdGFbMl0gKiB0aGlzLl9fZGF0YVsyXTsNCiAgICBpZiAoY3VycmxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgY29uc3Qgc2NsID0gbGVuZ3RoIC8gTWF0aC5zcXJ0KGN1cnJsZW4pOw0KICAgIHJldHVybiBuZXcgVmVjMyQxKHRoaXMuX19kYXRhWzBdICogc2NsLCB0aGlzLl9fZGF0YVsxXSAqIHNjbCwgdGhpcy5fX2RhdGFbMl0gKiBzY2wpDQogIH0NCg0KICAvKioNCiAgICogTW9kaWZpZXMgY3VycmVudCBjb29yZGVuYXRlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGxlbmd0aC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggdmFsdWUuDQogICAqLw0KICByZXNpemVJblBsYWNlKGxlbmd0aCkgew0KICAgIGNvbnN0IGN1cnJsZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl07DQogICAgaWYgKGN1cnJsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIGNvbnN0IHNjbCA9IGxlbmd0aCAvIE1hdGguc3FydChjdXJybGVuKTsNCiAgICB0aGlzLl9fZGF0YVswXSAqPSBzY2w7DQogICAgdGhpcy5fX2RhdGFbMV0gKj0gc2NsOw0KICAgIHRoaXMuX19kYXRhWzJdICo9IHNjbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzMgYWdhaW5zdCBhbm90aGVyIFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdC4NCiAgICovDQogIGRvdChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLnoNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byBWZWMzcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjYWxjdWxhdGUgd2l0aC4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IGFzIGEgbmV3IFZlYzMuDQogICAqLw0KICBjcm9zcyhvdGhlcikgew0KICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgIGNvbnN0IGF6ID0gdGhpcy56Ow0KICAgIGNvbnN0IGJ4ID0gb3RoZXIueDsNCiAgICBjb25zdCBieSA9IG90aGVyLnk7DQogICAgY29uc3QgYnogPSBvdGhlci56Ow0KDQogICAgcmV0dXJuIG5ldyBWZWMzJDEoYXkgKiBieiAtIGF6ICogYnksIGF6ICogYnggLSBheCAqIGJ6LCBheCAqIGJ5IC0gYXkgKiBieCkNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjMyBhbmQgYi4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuDQogICAqLw0KICBhbmdsZVRvKG90aGVyKSB7DQogICAgY29uc3QgY29zaW5lID0gdGhpcy5kb3Qob3RoZXIpOw0KICAgIGlmIChjb3NpbmUgPiAxLjApIHsNCiAgICAgIHJldHVybiAwDQogICAgfSBlbHNlIHsNCiAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKQ0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBWZWMzIGFuZCBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGludGVycG9sYXRlIGJldHdlZW4uDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqLw0KICBsZXJwKG90aGVyLCB0KSB7DQogICAgY29uc3QgYXggPSB0aGlzLng7DQogICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEoYXggKyB0ICogKG90aGVyLnggLSBheCksIGF5ICsgdCAqIChvdGhlci55IC0gYXkpLCBheiArIHQgKiAob3RoZXIueiAtIGF6KSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgbmV3IFZlYzMgd2hvc2UgY29tcG9uZW50IHZhbHVlcyBhcmUgdGhlIGFicyBvZiB0aGlzIFZlYzNzIGNvbXBvbmVudCB2YWx1ZXMuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgYWJzKCkgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKE1hdGguYWJzKHRoaXMueCksIE1hdGguYWJzKHRoaXMueSksIE1hdGguYWJzKHRoaXMueikpDQogIH0NCg0KICAvKioNCiAgICogU2V0cyB0aGUgdmVjdG9yIGEgcmFuZG9tIHZlY3RvciBvbiB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZSB3aXRoIHRoZSByYWRpdXMgb2YgdGhlIGdpdmVubiBzY2FsZSB2YWx1ZS4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHJhZGl1cyBvZiB0aGUgc3VyZmFjZSBzcGhlcmUuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gVGhlIHJhbmRvbSBWZWMzLg0KICAgKi8NCiAgc2V0UmFuZG9tRGlyKHNjYWxlID0gMS4wKSB7DQogICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJOw0KICAgIGNvbnN0IHogPSBNYXRoLnJhbmRvbSgpICogMi4wIC0gMS4wOw0KICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTsNCg0KICAgIHRoaXMuX19kYXRhWzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7DQogICAgdGhpcy5fX2RhdGFbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IHogKiBzY2FsZTsNCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIEdlbmVyYXRlcyBhIHJhbmRvbWUgdmVjdG9yIGFueXdoZXJlIGluIHRoZSBzcGhlcmUgZGVmaW5lZCBieSB0aGUgcHJvdmlkZWQgc2NhbGUgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSByYWRpdXMgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZS4NCiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmFuZG9tIFZlYzMuDQogICAqLw0KICBzZXRSYW5kb20oc2NhbGUgPSAxLjApIHsNCiAgICB0aGlzLl9fZGF0YVswXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHNjYWxlOw0KICAgIHRoaXMuX19kYXRhWzFdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc2NhbGU7DQogICAgdGhpcy5fX2RhdGFbMl0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBzY2FsZTsNCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIENsb25lcyB0aGlzIFZlYzMgYW5kIHJldHVybnMgYSBuZXcgVmVjMy4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLg0KICAgKg0KICAgKiBAcmV0dXJuIHthcnJheX0gLSBSZXR1cm5zIGFzIGFuIGFycmF5Lg0KICAgKi8NCiAgYXNBcnJheSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGENCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBWZWMzLg0KICAgKg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKC4uLmFyZ3MpDQogIH0NCg0KICAvKioNCiAgICogVGhlIGNyZWF0ZUZyb21KU09OIG1ldGhvZC4NCiAgICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUganNvbiBwYXJhbS4NCiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21KU09OKGpzb24pIHsNCiAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjMyQxKCk7DQogICAgcmVzdWx0LmZyb21KU09OKGpzb24pOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIgbWV0aG9kLg0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIoYnVmZmVyLCBvZmZzZXQgPSAwKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpOw0KICAgIHJldHVybiB0aGlzLmNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBvZmZzZXQgKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgVmVjM2AgdXNpbmcgYW4gQXJyYXlCdWZmZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAzKSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXQNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgY3JlYXRlRnJvbUZsb2F0MzJBcnJheSBtZXRob2QuDQogICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSAtIEEgRmxvYXQzMkFycmF5IHZhbHVlDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQXJyYXkoYXJyYXkpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMShhcnJheSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRmxvYXQzMiBlbGVtZW50cyB1c2VkIGJ5IHRoaXMgdHlwZS4gVXNlZCB0byBjYWxjdWxhdGUgc3RvcmFnZSByZXF1aXJlbWVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIG51bUVsZW1lbnRzKCkgew0KICAgIHJldHVybiAzDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogRW5jb2RlcyBWZWMzIENsYXNzIGFzIGEgSlNPTiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICB4OiB0aGlzLngsDQogICAgICB5OiB0aGlzLnksDQogICAgICB6OiB0aGlzLnosDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIERlY29kZXMgYSBKU09OIG9iamVjdCB0byBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgY2xhc3MuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMueCA9IGoueDsNCiAgICB0aGlzLnkgPSBqLnk7DQogICAgdGhpcy56ID0gai56Ow0KICB9DQoNCiAgLyoqDQogICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAqDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKi8NCiAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICB0aGlzLnggPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICB0aGlzLnogPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgfQ0KfQ0KDQpSZWdpc3RyeS5yZWdpc3RlcignVmVjMycsIFZlYzMkMSk7CgovKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovDQovKioNCiAqIFJlcHJlc2VudHMgYSBmb3VyLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUuDQogKiBNYXRoIHR5cGVzIGludGVybmFsbHkgc3RvcmUgdmFsdWVzIGluIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSBhbmQNCiAqIGV4cG9zZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciB0aGUgY29tcG9uZW50IHZhbHVlcy4NCiAqDQogKiBAZXh0ZW5kcyBBdHRyVmFsdWUNCiAqLw0KY2xhc3MgVmVjNCQxIGV4dGVuZHMgQXR0clZhbHVlIHsNCiAgLyoqDQogICAvKioNCiAgICogQ3JlYXRlcyBhIFZlYzQuDQogICAqDQogICAqIFRoZSB0eXBlIG9mIHZhbHVlcyBvZiB0aGUgYCh4LCB5LCB6LCB0KWAgY29vcmRpbmF0ZXMgY2FuIGJlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSwNCiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1VpbnQzMkFycmF5fFVpbnQzMkFycmF5fSwNCiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludDMyQXJyYXl8SW50MzJBcnJheX0gYW5kDQogICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lcy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9BcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlcn0uDQogICAqIDxicj4NCiAgICogWW91IGNhbiBhbHNvIHBhc3Mgb25lIEpTT04gb2JqZWN0IHBhcmFtZXRlci4NCiAgICogDQogICAqIEBwYXJhbSB7TnVtYmVyfEZsb2F0MzJBcnJheXxqc29ufSB4IC0gVGhlIHggdmFsdWUuIERlZmF1bHQgaXMgMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLg0KICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB5IHZhbHVlLiBEZWZhdWx0IGlzIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gVGhlIHQgdmFsdWUuIERlZmF1bHQgaXMgMC4NCiAgICovDQogIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHQgPSAwKSB7DQogICAgc3VwZXIoKTsNCg0KICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSkgew0KICAgICAgdGhpcy5fX2RhdGEgPSB4Ow0KICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7DQogICAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbmV3IFZlYzQobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpKWApOw0KICAgICAgY29uc3QgYnVmZmVyID0geDsNCiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5Ow0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCk7DQogICAgfSBlbHNlIGlmICh4ICE9IG51bGwgJiYgdHlwZW9mIHggPT0gJ29iamVjdCcpIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTsNCiAgICAgIHRoaXMuZnJvbUpTT04oeCk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTsNCiAgICAgIHRoaXMuX19kYXRhWzBdID0geDsNCiAgICAgIHRoaXMuX19kYXRhWzFdID0geTsNCiAgICAgIHRoaXMuX19kYXRhWzJdID0gejsNCiAgICAgIHRoaXMuX19kYXRhWzNdID0gdDsNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeGAgdmFsdWUuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB4IHZhbHVlLg0KICAgKi8NCiAgZ2V0IHgoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgeGAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHgodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeWAgdmFsdWUuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IHZhbHVlLg0KICAgKi8NCiAgZ2V0IHkoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgeWAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHkodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgemAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgZ2V0IHooKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgemAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHoodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgdGAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgZ2V0IHQoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzNdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgdGAgdmFsdWUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHQodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbM10gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBgeHlgIHN3aXp6ZWwuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB6IHZhbHVlLg0KICAgKi8NCiAgZ2V0IHh5eigpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdKQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0geSAgLSBUaGUgeSB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHogIC0gVGhlIHkgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0ICAtIFRoZSB0IHZhbHVlLg0KICAgKi8NCiAgc2V0KHgsIHksIHosIHQpIHsNCiAgICB0aGlzLnggPSB4Ow0KICAgIHRoaXMueSA9IHk7DQogICAgdGhpcy56ID0gejsNCiAgICB0aGlzLnQgPSB0Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIHN0YXRlIG9mIGEgVmVjNCBPYmplY3QgZnJvbSBhbm90aGVyIFZlYzQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzZXQgZnJvbS4NCiAgICovDQogIHNldEZyb21PdGhlcihvdGhlcikgew0KICAgIHRoaXMueCA9IG90aGVyLng7DQogICAgdGhpcy55ID0gb3RoZXIueTsNCiAgICB0aGlzLnogPSBvdGhlci56Ow0KICAgIHRoaXMudCA9IG90aGVyLnQ7DQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjNCBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGFub3RoZXIgVmVjNC4NCiAgICoNCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBlcXVhbChvdGhlcikgew0KICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNpc0VxdWFsIGluc3RlYWQuJyk7DQogICAgcmV0dXJuIHRoaXMuaXNFcXVhbChvdGhlcikNCiAgfQ0KDQogIC8qKg0KICAgKiBDaGVja3MgaWYgdGhpcyBWZWM0IGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgYW5vdGhlciBWZWM0Lg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIGlzRXF1YWwob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnogJiYgdGhpcy50ID09IG90aGVyLnQNCiAgfQ0KDQogIC8qKg0KICAgKiBDaGVja3MgaWYgdGhpcyBWZWM0IGlzIGRpZmZlcmVudCBmcm9tIGFub3RoZXIgVmVjNC4NCiAgICoNCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBub3RFcXVhbHMob3RoZXIpIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjbm90RXF1YWwgaW5zdGVhZC4nKTsNCiAgICByZXR1cm4gdGhpcy5ub3RFcXVhbChvdGhlcikNCiAgfQ0KDQogIC8qKg0KICAgKiBDaGVja3MgaWYgdGhpcyBWZWM0IGlzIGRpZmZlcmVudCBmcm9tIGFub3RoZXIgVmVjNC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBub3RFcXVhbChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnggIT0gb3RoZXIueCAmJiB0aGlzLnkgIT0gb3RoZXIueSAmJiB0aGlzLnogIT0gb3RoZXIueiAmJiB0aGlzLnQgIT0gb3RoZXIudA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzQgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHsNCiAgICByZXR1cm4gKA0KICAgICAgTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiYNCiAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmDQogICAgICBNYXRoLmFicyh0aGlzLnogLSBvdGhlci56KSA8IHByZWNpc2lvbiAmJg0KICAgICAgTWF0aC5hYnModGhpcy50IC0gb3RoZXIudCkgPCBwcmVjaXNpb24NCiAgICApDQogIH0NCg0KICAvKioNCiAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0Lg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gYWRkLg0KICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC4NCiAgICovDQogIGFkZChvdGhlcikgew0KICAgIHJldHVybiBuZXcgVmVjNCQxKHRoaXMueCArIG90aGVyLngsIHRoaXMueSArIG90aGVyLnksIHRoaXMueiArIG90aGVyLnosIHRoaXMudCArIG90aGVyLnQpDQogIH0NCg0KICAvKioNCiAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzQgbXV0YXRpbmcgdGhlIHZhbHVlcyBvZiB0aGlzIGluc3RhbmNlDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBhZGQuDQogICAqLw0KICBhZGRJblBsYWNlKG90aGVyKSB7DQogICAgdGhpcy54ICs9IG90aGVyLng7DQogICAgdGhpcy55ICs9IG90aGVyLnk7DQogICAgdGhpcy56ICs9IG90aGVyLno7DQogICAgdGhpcy50ICs9IG90aGVyLnQ7DQogIH0NCg0KICAvKioNCiAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IGFuZCByZXR1cm5zIHRoZW4gcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzdWJ0cmFjdC4NCiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIGEgbmV3IFZlYzQuDQogICAqLw0KICBzdWJ0cmFjdChvdGhlcikgew0KICAgIHJldHVybiBuZXcgVmVjNCQxKHRoaXMueCAtIG90aGVyLngsIHRoaXMueSAtIG90aGVyLnksIHRoaXMueiAtIG90aGVyLnosIHRoaXMudCAtIG90aGVyLnQpDQogIH0NCg0KICAvKioNCiAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IG11dGF0aW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBpbnN0YW5jZQ0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gc3VidHJhY3QuDQogICAqLw0KICBzdWJ0cmFjdEluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggLT0gb3RoZXIueDsNCiAgICB0aGlzLnkgLT0gb3RoZXIueTsNCiAgICB0aGlzLnogLT0gb3RoZXIuejsNCiAgICB0aGlzLnQgLT0gb3RoZXIudDsNCiAgfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBtdWx0aXBseSB3aXRoLg0KICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC4NCiAgICovDQogIG11bHRpcGx5KG90aGVyKSB7DQogICAgcmV0dXJuIG5ldyBWZWM0JDEodGhpcy54ICogb3RoZXIueCwgdGhpcy55ICogb3RoZXIueSwgdGhpcy56ICogb3RoZXIueiwgdGhpcy50ICogb3RoZXIudCkNCiAgfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBtdXRhdGluZyB0aGUgdmFsdWVzIG9mIHRoaXMgaW5zdGFuY2UNCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIG11bHRpcGx5IHdpdGguDQogICAqLw0KICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggKj0gb3RoZXIueDsNCiAgICB0aGlzLnkgKj0gb3RoZXIueTsNCiAgICB0aGlzLnogKj0gb3RoZXIuejsNCiAgICB0aGlzLnQgKj0gb3RoZXIudDsNCiAgfQ0KDQogIC8qKg0KICAgKiBEaXZpZGVzIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBkaXZpZGUgYnkuDQogICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyBhIG5ldyBWZWM0Lg0KICAgKi8NCiAgZGl2aWRlKG90aGVyKSB7DQogICAgcmV0dXJuIG5ldyBWZWM0JDEodGhpcy54IC8gb3RoZXIueCwgdGhpcy55IC8gb3RoZXIueSwgdGhpcy56IC8gb3RoZXIueiwgdGhpcy50IC8gb3RoZXIudCkNCiAgfQ0KDQogIC8qKg0KICAgKiBEaXZpZGVzIHR3byBWZWM0cy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGRpdmlkZSBieS4NCiAgICovDQogIGRpdmlkZUluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggLz0gb3RoZXIueDsNCiAgICB0aGlzLnkgLz0gb3RoZXIueTsNCiAgICB0aGlzLnogLz0gb3RoZXIuejsNCiAgICB0aGlzLnQgLz0gb3RoZXIudDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTY2FsZXMgdGhpcyBWZWM0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWM0fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBzY2FsZShzY2FsYXIpIHsNCiAgICByZXR1cm4gbmV3IFZlYzQkMSh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyLCB0aGlzLnQgKiBzY2FsYXIpDQogIH0NCg0KICAvKioNCiAgICogU2NhbGVzIHRoaXMgVmVjNCBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgIHRoaXMuc2V0KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIsIHRoaXMudCAqIHNjYWxhcik7DQogIH0NCg0KICAvKioNCiAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgVmVjNC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICovDQogIGxlbmd0aCgpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCB0ID0gdGhpcy5fX2RhdGFbMl07DQogICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB0ICogdCkNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIFZlYzQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAqLw0KICBsZW5ndGhTcXVhcmVkKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IHQgPSB0aGlzLl9fZGF0YVszXTsNCiAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHQNCiAgfQ0KDQogIC8qKg0KICAgKiBOb3JtYWxpemVzIHRoZSBWZWM0IGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFZlYzQuDQogICAqIE11bHRpcGxpZXMgY29vcmRlbmF0ZXMgdmFsdWUgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyB0aGUgVmVjNCBub3JtYWxpemVkLg0KICAgKi8NCiAgbm9ybWFsaXplKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IHQgPSB0aGlzLl9fZGF0YVszXTsNCiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHQ7DQogICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICByZXR1cm4gbmV3IFZlYzQkMSgpDQogICAgfQ0KDQogICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/DQogICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOw0KICAgIHJldHVybiBuZXcgVmVjNCQxKHggKiBsZW4sIHkgKiBsZW4sIHogKiBsZW4pDQogIH0NCg0KICAvKioNCiAgICogTm9ybWFsaXplcyB0aGlzIFZlYzQgbXVsdGlwbHlpbmcgY29vcmRlbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAqLw0KICBub3JtYWxpemVJblBsYWNlKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IHQgPSB0aGlzLl9fZGF0YVszXTsNCiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHQ7DQogICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOw0KICAgIHRoaXMuc2V0KHggKiBsZW4sIHkgKiBsZW4sIHogKiBsZW4sIHQgKiBsZW4pOw0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgVmVjNCBhZ2FpbnN0IGFub3RoZXIgVmVjNC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0Lg0KICAgKi8NCiAgZG90KG90aGVyKSB7DQogICAgcmV0dXJuIHRoaXMueCAqIG90aGVyLnggKyB0aGlzLnkgKiBvdGhlci55ICsgdGhpcy56ICogb3RoZXIueiArIHRoaXMudCAqIGIudA0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlYzRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNhbGN1bGF0ZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3QgYXMgYSBuZXcgVmVjNC4NCiAgICovDQogIGNyb3NzKG90aGVyKSB7DQogICAgY29uc3QgYXggPSB0aGlzLng7DQogICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgY29uc3QgYXQgPSB0aGlzLnQ7DQogICAgY29uc3QgYnggPSBvdGhlci54Ow0KICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsNCiAgICBjb25zdCBieiA9IG90aGVyLno7DQogICAgY29uc3QgYnQgPSBvdGhlci50Ow0KDQogICAgcmV0dXJuIG5ldyBWZWM0JDEoYXkgKiBieiAtIGF6ICogYnksIGF6ICogYnQgLSBhdCAqIGJ6LCBhdCAqIGJ4IC0gYXggKiBidCwgYXggKiBieSAtIGF5ICogYngpDQogIH0NCg0KICAvKioNCiAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIFZlYzQgYW5kIGIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLg0KICAgKi8NCiAgYW5nbGVUbyhvdGhlcikgew0KICAgIGNvbnN0IHRlbXBBID0gdGhpcy5ub3JtYWxpemUoKTsNCiAgICBjb25zdCB0ZW1wQiA9IG90aGVyLm5vcm1hbGl6ZSgpOw0KICAgIGNvbnN0IGNvc2luZSA9IHRlbXBBLmRvdCh0ZW1wQik7DQoNCiAgICBpZiAoY29zaW5lID4gMS4wKSB7DQogICAgICByZXR1cm4gMA0KICAgIH0gZWxzZSB7DQogICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSkNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgVmVjNCBhbmQgb3RoZXIuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuDQogICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyBhIG5ldyBWZWM0Lg0KICAgKi8NCiAgbGVycChvdGhlciwgdCkgew0KICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgIGNvbnN0IGF6ID0gdGhpcy56Ow0KICAgIGF0ID0gdGhpcy50Ow0KICAgIHJldHVybiBuZXcgVmVjNCQxKGF4ICsgdCAqIChvdGhlci54IC0gYXgpLCBheSArIHQgKiAob3RoZXIueSAtIGF5KSwgYXogKyB0ICogKG90aGVyLnogLSBheiksIGF0ICsgdCAqIChvdGhlci50IC0gYXQpKQ0KICB9DQoNCiAgLyoqDQogICAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGUuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZC4NCiAgICogQHJldHVybiB7VmVjNH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgcmFuZG9tKHNjYWxlID0gMS4wKSB7DQogICAgY29uc3QgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTsNCiAgICBjb25zdCB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjA7DQogICAgY29uc3QgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlOw0KDQogICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7DQogICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7DQogICAgb3V0WzJdID0geiAqIHNjYWxlOw0KICAgIHJldHVybiBvdXQNCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBWZWM0IGFuZCByZXR1cm5zIGEgbmV3IFZlYzQuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyBhIG5ldyBWZWM0Lg0KICAgKi8NCiAgY2xvbmUoKSB7DQogICAgcmV0dXJuIG5ldyBWZWM0JDEodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbM10pDQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgdGhpcyBWZWM0IGludG8gYSBWZWMzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIHZhbHVlIGFzIGEgbmV3IFZlYzMuDQogICAqLw0KICB0b1ZlYzMoKSB7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSB0eXBlIGFzIGFuIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4NCiAgICoNCiAgICogQHJldHVybiB7YXJheX0gLSBSZXR1cm5zIGFzIGFuIGFycmF5Lg0KICAgKi8NCiAgYXNBcnJheSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGENCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBWZWMzLg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgVmVjMyQxKC4uLmFyZ3MpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBWZWM0IHRvIHdyYXAgZXhpc3RpbmcgbWVtb3J5IGluIGEgYnVmZmVyLg0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIoYnVmZmVyLCBvZmZzZXQgPSAwKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpOw0KICAgIHJldHVybiBuZXcgVmVjNCQxKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQgKiA0LCA0KSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXQNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgYFZlYzRgIHVzaW5nIGFuIEFycmF5QnVmZmVyLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIGEgbmV3IFZlYzQuDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIGJ5dGVPZmZzZXQpIHsNCiAgICByZXR1cm4gbmV3IFZlYzQkMShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIEZsb2F0MzIgZWxlbWVudHMgdXNlZCBieSB0aGlzIHR5cGUuIFVzZWQgdG8gY2FsY3VsYXRlIHN0b3JhZ2UgcmVxdWlyZW1lbnRzIGZvciBsYXJnZSBhcnJheXMgb2YgdGhpcyB0eXBlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBudW1FbGVtZW50cygpIHsNCiAgICByZXR1cm4gNA0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFBlcnNpc3RlbmNlDQoNCiAgLyoqDQogICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICB4OiB0aGlzLngsDQogICAgICB5OiB0aGlzLnksDQogICAgICB6OiB0aGlzLnosDQogICAgICB0OiB0aGlzLnQsDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIERlY29kZXMgYSBKU09OIG9iamVjdCB0byBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgY2xhc3MuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMueCA9IGoueDsNCiAgICB0aGlzLnkgPSBqLnk7DQogICAgdGhpcy56ID0gai56Ow0KICAgIHRoaXMudCA9IGoudDsNCiAgfQ0KDQogIC8qKg0KICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICovDQogIHJlYWRCaW5hcnkocmVhZGVyKSB7DQogICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgdGhpcy55ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgdGhpcy50ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogIH0NCn0NCg0KUmVnaXN0cnkucmVnaXN0ZXIoJ1ZlYzQnLCBWZWM0JDEpOwoKLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYyAqLw0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgY2hhbm5lbCBvZiBhIGNvbG9yLg0KICoNCiAqIEBleHRlbmRzIEF0dHJWYWx1ZQ0KICovDQpjbGFzcyBSR0JBIGV4dGVuZHMgQXR0clZhbHVlIHsNCiAgLyoqDQogICAqIENyZWF0ZSBhIFJHQkEuDQogICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgRmxvYXQzMkFycmF5IHwgQXJyYXlCdWZmZXJ9IHIgLSBUaGUgcmVkIGNoYW5uZWwgb2YgYSBjb2xvci4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBUaGUgZ3JlZW4gY2hhbm5lbCBvZiBhIGNvbG9yLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBibHVlIGNoYW5uZWwgb2YgYSBjb2xvci4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBUaGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgY2hhbm5lbCBvZiBhIGNvbG9yLg0KICAgKi8NCiAgY29uc3RydWN0b3IociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDI1NSkgew0KICAgIHN1cGVyKCk7DQoNCiAgICBpZiAociBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsNCiAgICAgIHRoaXMuX19kYXRhID0gcjsNCiAgICB9IGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgew0KICAgICAgY29uc3QgYnVmZmVyID0gcjsNCiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBnOw0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBVaW50OEFycmF5KDQpOw0KICAgICAgaWYgKHR5cGVvZiByID09ICdzdHJpbmcnKSB7DQogICAgICAgIGlmIChyLnN0YXJ0c1dpdGgoJyMnKSkgew0KICAgICAgICAgIHRoaXMuc2V0RnJvbUhleChyKTsNCiAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICB0aGlzLnNldEZyb21DU1NDb2xvck5hbWUocik7DQogICAgICAgIH0NCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHRoaXMuX19kYXRhWzBdID0gcjsNCiAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSBnOw0KICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IGI7DQogICAgICAgIHRoaXMuX19kYXRhWzNdID0gYTsNCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByZWQgY2hhbm5lbC4NCiAgICoNCiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIHRoZSByZWQgY2hhbm5lbC4NCiAgICovDQogIGdldCByKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVswXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgcmVkIGNoYW5uZWwuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBncmVlbiBjaGFubmVsLg0KICAgKg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgdGhlIGdyZWVuIGNoYW5uZWwuDQogICAqLw0KICBnZXQgZygpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGdyZWVuIGNoYW5uZWwuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IGcodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBibHVlIGNoYW5uZWwuDQogICAqDQogICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyB0aGUgYmx1ZSBjaGFubmVsLg0KICAgKi8NCiAgZ2V0IGIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBibHVlIGNoYW5uZWwuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IGIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBhbHBoYSBjaGFubmVsLg0KICAgKg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgdGhlIGFscGhhIGNoYW5uZWwuDQogICAqLw0KICBnZXQgYSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbM10NCiAgfQ0KICAvKioNCiAgICogU2V0dGVyIGZvciBhbHBoYSB2YWx1ZS4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgYSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVszXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBUaGUgcmVkIGNoYW5uZWwuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBnICAtIFRoZSBncmVlbiBjaGFubmVsLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYiAgLSBUaGUgYmx1ZSBjaGFubmVsLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYSAgLSBUaGUgYWxwaGEgY2hhbm5lbC4NCiAgICovDQogIHNldChyLCBnLCBiLCBhID0gMjU1KSB7DQogICAgdGhpcy5yID0gcjsNCiAgICB0aGlzLmcgPSBnOw0KICAgIHRoaXMuYiA9IGI7DQogICAgdGhpcy5hID0gYTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBhbm90aGVyIFJHQkEgY29sb3IuDQogICAqDQogICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSBUaGUgb3RoZXIgUkdCQSB0byBzZXQgZnJvbS4NCiAgICovDQogIHNldEZyb21PdGhlcihvdGhlcikgew0KICAgIHRoaXMuciA9IG90aGVyLnI7DQogICAgdGhpcy5nID0gb3RoZXIuZzsNCiAgICB0aGlzLmIgPSBvdGhlci5iOw0KICAgIHRoaXMuYSA9IG90aGVyLmE7DQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZyb20gYSBzY2FsYXIgYXJyYXkuDQogICAqDQogICAqIEBwYXJhbSB7YXJyYXl9IHZhbHMgLSBUaGUgdmFscyBwYXJhbS4NCiAgICovDQogIHNldEZyb21BcnJheSh2YWxzKSB7DQogICAgdGhpcy5yID0gdmFsc1swXTsNCiAgICB0aGlzLmcgPSB2YWxzWzFdOw0KICAgIHRoaXMuYiA9IHZhbHNbMl07DQogICAgdGhpcy5hID0gdmFscy5sZW5ndGggPT0gNCA/IHZhbHNbM10gOiAxLjA7DQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZyb20gYSBoZXhhZGVjaW1hbCB2YWx1ZS4NCiAgICogRS5nLiAjZmYwMDAwDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBoZXggLSBUaGUgaGV4IHZhbHVlLg0KICAgKi8NCiAgc2V0RnJvbUhleChoZXgpIHsNCiAgICBmdW5jdGlvbiBoZXhUb1JnYihoZXgpIHsNCiAgICAgIGNvbnN0IHJlc3VsdCA9IC9eIz8oW2EtZlxkXXsyfSkoW2EtZlxkXXsyfSkoW2EtZlxkXXsyfSkkL2kuZXhlYyhoZXgpOw0KICAgICAgcmV0dXJuIHJlc3VsdA0KICAgICAgICA/IHsNCiAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLA0KICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksDQogICAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDE2KSwNCiAgICAgICAgICB9DQogICAgICAgIDogbnVsbA0KICAgIH0NCiAgICBjb25zdCByZ2IgPSBoZXhUb1JnYihoZXgpOw0KICAgIGlmICghcmdiKSB7DQogICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgaGV4IGNvZGU6JyArIGhleCk7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgdGhpcy5zZXQocmdiLnIsIHJnYi5nLCByZ2IuYik7DQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZyb20gYSBDU1MgY29sb3IgbmFtZS4NCiAgICogRS5nLiAicmVkIg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBDU1MgY29sb3IgbmFtZS4NCiAgICovDQogIHNldEZyb21DU1NDb2xvck5hbWUobmFtZSkgew0KICAgIGNvbnN0IGNvbG91ck5hbWVUb0hleCA9IChjb2xvdXIpID0+IHsNCiAgICAgIGNvbnN0IGNvbG9ycyA9IHsNCiAgICAgICAgYWxpY2VibHVlOiAnI2YwZjhmZicsDQogICAgICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLA0KICAgICAgICBhcXVhOiAnIzAwZmZmZicsDQogICAgICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JywNCiAgICAgICAgYXp1cmU6ICcjZjBmZmZmJywNCiAgICAgICAgYmVpZ2U6ICcjZjVmNWRjJywNCiAgICAgICAgYmlzcXVlOiAnI2ZmZTRjNCcsDQogICAgICAgIGJsYWNrOiAnIzAwMDAwMCcsDQogICAgICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsDQogICAgICAgIGJsdWU6ICcjMDAwMGZmJywNCiAgICAgICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLA0KICAgICAgICBicm93bjogJyNhNTJhMmEnLA0KICAgICAgICBidXJseXdvb2Q6ICcjZGViODg3JywNCiAgICAgICAgY2FkZXRibHVlOiAnIzVmOWVhMCcsDQogICAgICAgIGNoYXJ0cmV1c2U6ICcjN2ZmZjAwJywNCiAgICAgICAgY2hvY29sYXRlOiAnI2QyNjkxZScsDQogICAgICAgIGNvcmFsOiAnI2ZmN2Y1MCcsDQogICAgICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsDQogICAgICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsDQogICAgICAgIGNyaW1zb246ICcjZGMxNDNjJywNCiAgICAgICAgY3lhbjogJyMwMGZmZmYnLA0KICAgICAgICBkYXJrYmx1ZTogJyMwMDAwOGInLA0KICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLA0KICAgICAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsDQogICAgICAgIGRhcmtncmF5OiAnI2E5YTlhOScsDQogICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLA0KICAgICAgICBkYXJra2hha2k6ICcjYmRiNzZiJywNCiAgICAgICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJywNCiAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJywNCiAgICAgICAgZGFya29yYW5nZTogJyNmZjhjMDAnLA0KICAgICAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsDQogICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJywNCiAgICAgICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLA0KICAgICAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJywNCiAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLA0KICAgICAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsDQogICAgICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJywNCiAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLA0KICAgICAgICBkZWVwcGluazogJyNmZjE0OTMnLA0KICAgICAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLA0KICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsDQogICAgICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJywNCiAgICAgICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsDQogICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsDQogICAgICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsDQogICAgICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJywNCiAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsDQogICAgICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJywNCiAgICAgICAgZ29sZDogJyNmZmQ3MDAnLA0KICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJywNCiAgICAgICAgZ3JheTogJyM4MDgwODAnLA0KICAgICAgICBncmVlbjogJyMwMDgwMDAnLA0KICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLA0KICAgICAgICBob25leWRldzogJyNmMGZmZjAnLA0KICAgICAgICBob3RwaW5rOiAnI2ZmNjliNCcsDQogICAgICAgICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLA0KICAgICAgICBpbmRpZ286ICcjNGIwMDgyJywNCiAgICAgICAgaXZvcnk6ICcjZmZmZmYwJywNCiAgICAgICAga2hha2k6ICcjZjBlNjhjJywNCiAgICAgICAgbGF2ZW5kZXI6ICcjZTZlNmZhJywNCiAgICAgICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLA0KICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJywNCiAgICAgICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsDQogICAgICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLA0KICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsDQogICAgICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLA0KICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLA0KICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJywNCiAgICAgICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLA0KICAgICAgICBsaWdodHBpbms6ICcjZmZiNmMxJywNCiAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJywNCiAgICAgICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLA0KICAgICAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJywNCiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywNCiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJywNCiAgICAgICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJywNCiAgICAgICAgbGltZTogJyMwMGZmMDAnLA0KICAgICAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJywNCiAgICAgICAgbGluZW46ICcjZmFmMGU2JywNCiAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLA0KICAgICAgICBtYXJvb246ICcjODAwMDAwJywNCiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLA0KICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsDQogICAgICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLA0KICAgICAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGQ4JywNCiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJywNCiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsDQogICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsDQogICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLA0KICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JywNCiAgICAgICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsDQogICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLA0KICAgICAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJywNCiAgICAgICAgbW9jY2FzaW46ICcjZmZlNGI1JywNCiAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJywNCiAgICAgICAgbmF2eTogJyMwMDAwODAnLA0KICAgICAgICBvbGRsYWNlOiAnI2ZkZjVlNicsDQogICAgICAgIG9saXZlOiAnIzgwODAwMCcsDQogICAgICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLA0KICAgICAgICBvcmFuZ2U6ICcjZmZhNTAwJywNCiAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsDQogICAgICAgIG9yY2hpZDogJyNkYTcwZDYnLA0KICAgICAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsDQogICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLA0KICAgICAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsDQogICAgICAgIHBhbGV2aW9sZXRyZWQ6ICcjZDg3MDkzJywNCiAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLA0KICAgICAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JywNCiAgICAgICAgcGVydTogJyNjZDg1M2YnLA0KICAgICAgICBwaW5rOiAnI2ZmYzBjYicsDQogICAgICAgIHBsdW06ICcjZGRhMGRkJywNCiAgICAgICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLA0KICAgICAgICBwdXJwbGU6ICcjODAwMDgwJywNCiAgICAgICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLA0KICAgICAgICByZWQ6ICcjZmYwMDAwJywNCiAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsDQogICAgICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLA0KICAgICAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLA0KICAgICAgICBzYWxtb246ICcjZmE4MDcyJywNCiAgICAgICAgc2FuZHlicm93bjogJyNmNGE0NjAnLA0KICAgICAgICBzZWFncmVlbjogJyMyZThiNTcnLA0KICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLA0KICAgICAgICBzaWVubmE6ICcjYTA1MjJkJywNCiAgICAgICAgc2lsdmVyOiAnI2MwYzBjMCcsDQogICAgICAgIHNreWJsdWU6ICcjODdjZWViJywNCiAgICAgICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsDQogICAgICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLA0KICAgICAgICBzbm93OiAnI2ZmZmFmYScsDQogICAgICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsDQogICAgICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLA0KICAgICAgICB0YW46ICcjZDJiNDhjJywNCiAgICAgICAgdGVhbDogJyMwMDgwODAnLA0KICAgICAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsDQogICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLA0KICAgICAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJywNCiAgICAgICAgdmlvbGV0OiAnI2VlODJlZScsDQogICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsDQogICAgICAgIHdoaXRlOiAnI2ZmZmZmZicsDQogICAgICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JywNCiAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsDQogICAgICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMicsDQogICAgICB9Ow0KDQogICAgICBpZiAodHlwZW9mIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV0gIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBjb2xvcnNbY29sb3VyLnRvTG93ZXJDYXNlKCldDQoNCiAgICAgIHJldHVybiBmYWxzZQ0KICAgIH07DQogICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnIycpKSB7DQogICAgICB0aGlzLnNldEZyb21IZXgobmFtZSk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuc2V0RnJvbUhleChjb2xvdXJOYW1lVG9IZXgobmFtZSkpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiB0aGlzIFJHQkEgY29sb3IuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBSZXR1cm5zIHRoZSBoZXggdmFsdWUuDQogICAqLw0KICB0b0hleCgpIHsNCiAgICBmdW5jdGlvbiBjb21wb25lbnRUb0hleChpbnQpIHsNCiAgICAgIGNvbnN0IGhleCA9IGludC50b1N0cmluZygxNik7DQogICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4DQogICAgfQ0KICAgIHJldHVybiAnIycgKyBjb21wb25lbnRUb0hleCh0aGlzLnIpICsgY29tcG9uZW50VG9IZXgodGhpcy5nKSArIGNvbXBvbmVudFRvSGV4KHRoaXMuYikNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBSR0JBIGNvbG9yIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAqDQogICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSBUaGUgb3RoZXIgUkdCQSB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgKi8NCiAgZXF1YWwob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy5yID09IG90aGVyLnIgJiYgdGhpcy5nID09IG90aGVyLmcgJiYgdGhpcy5iID09IG90aGVyLmIgJiYgdGhpcy5hID09IG90aGVyLmENCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBSR0JBIGNvbG9yIGlzIE5PVCBleGFjdGx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge1JHQkF9IG90aGVyIC0gIFRoZSBvdGhlciBSR0JBIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBub3RFcXVhbHMob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy5yICE9IG90aGVyLnIgJiYgdGhpcy5nICE9IG90aGVyLmcgJiYgdGhpcy5iICE9IG90aGVyLmIgJiYgdGhpcy5hICE9IG90aGVyLmENCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBSR0JBIGNvbG9yIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAqDQogICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSBUaGUgb3RoZXIgUkdCQSB0byBjb21wYXJlIHdpdGguDQogICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHsNCiAgICByZXR1cm4gKA0KICAgICAgTWF0aC5hYnModGhpcy5yIC0gb3RoZXIucikgPCBwcmVjaXNpb24gJiYNCiAgICAgIE1hdGguYWJzKHRoaXMuZyAtIG90aGVyLmcpIDwgcHJlY2lzaW9uICYmDQogICAgICBNYXRoLmFicyh0aGlzLmIgLSBvdGhlci5iKSA8IHByZWNpc2lvbiAmJg0KICAgICAgTWF0aC5hYnModGhpcy5hIC0gb3RoZXIuYSkgPCBwcmVjaXNpb24NCiAgICApDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBhIG5ldyBSR0JBIGNvbG9yIHdoaWNoIGlzIHRoaXMgUkdCQSBjb2xvciBhZGRlZCB0byBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtSR0JBfSBvdGhlciAtIFRoZSBvdGhlciBSR0JBIHRvIGFkZC4NCiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuDQogICAqLw0KICBhZGQob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFJHQkEodGhpcy5yICsgb3RoZXIuciwgdGhpcy5nICsgb3RoZXIuZywgdGhpcy5iICsgb3RoZXIuYiwgdGhpcy5hICsgb3RoZXIuYSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgbmV3IFJHQkEgY29sb3Igd2hpY2ggaXMgdGhpcyBSR0JBIGNvbG9yIHN1YnRyYWN0ZWQgZnJvbSBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtSR0JBfSBvdGhlciAtIFRoZSBvdGhlciBSR0JBIHRvIHN1YnRyYWN0Lg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS4NCiAgICovDQogIHN1YnRyYWN0KG90aGVyKSB7DQogICAgcmV0dXJuIG5ldyBSR0JBKHRoaXMuciAtIG90aGVyLnIsIHRoaXMuZyAtIG90aGVyLmcsIHRoaXMuYiAtIG90aGVyLmIsIHRoaXMuYSAtIG90aGVyLmEpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBhIG5ldyBSR0JBIGNvbG9yIHdoaWNoIGlzIHRoaXMgdmVjdG9yIHNjYWxlZCBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS4NCiAgICovDQogIHNjYWxlKHNjYWxhcikgew0KICAgIHJldHVybiBuZXcgUkdCQSh0aGlzLnIgKiBzY2FsYXIsIHRoaXMuZyAqIHNjYWxhciwgdGhpcy5iICogc2NhbGFyLCB0aGlzLmEgKiBzY2FsYXIpDQogIH0NCg0KICAvKioNCiAgICogU2NhbGVzIHRoaXMgUkdCQSBjb2xvciBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgIHRoaXMuciAqPSBzY2FsYXI7DQogICAgdGhpcy5nICo9IHNjYWxhcjsNCiAgICB0aGlzLmIgKj0gc2NhbGFyOw0KICAgIHRoaXMuYSAqPSBzY2FsYXI7DQogIH0NCg0KICAvKioNCiAgICogQXBwbHkgZ2FtbWEgY29ycmVjdGlvbiB0byB0aGlzIFJHQkEgY29sb3IuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS4NCiAgICovDQogIGFwcGx5R2FtbWEoZ2FtbWEpIHsNCiAgICB0aGlzLnNldChNYXRoLnBvdyh0aGlzLnIsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5nLCBnYW1tYSksIE1hdGgucG93KHRoaXMuYiwgZ2FtbWEpLCB0aGlzLmEpOw0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRvIGxpbmVhciBjb2xvciBzcGFjZSBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuDQogICAqLw0KICB0b0xpbmVhcihnYW1tYSA9IDIuMikgew0KICAgIHJldHVybiBuZXcgUkdCQShNYXRoLnBvdyh0aGlzLnIsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5nLCBnYW1tYSksIE1hdGgucG93KHRoaXMuYiwgZ2FtbWEpLCB0aGlzLmEpDQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgdG8gZ2FtbWEgY29sb3Igc3BhY2UgYW5kIHJldHVybnMgYSBuZXcgUkdCQSBjb2xvci4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS4NCiAgICovDQogIHRvR2FtbWEoZ2FtbWEgPSAyLjIpIHsNCiAgICByZXR1cm4gbmV3IFJHQkEoTWF0aC5wb3codGhpcy5yLCAxLjAgLyBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgMS4wIC8gZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIDEuMCAvIGdhbW1hKSwgdGhpcy5hKQ0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHJlbGF0aXZlIGx1bWluYW5jZSBvZiB0aGUgbGluZWFyIFJHQiBjb21wb25lbnQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbHVtaW5hbmNlKCkgew0KICAgIHJldHVybiAwLjIxMjYgKiB0aGlzLnIgKyAwLjcxNTIgKiB0aGlzLmcgKyAwLjA3MjIgKiB0aGlzLmINCiAgfQ0KDQogIC8qKg0KICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBSR0JBIGNvbG9yIGFuZCBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtSR0JBfSBvdGhlciAtIFRoZSBvdGhlciBSR0JBIHRvIGludGVycG9sYXRlIGJldHdlZW4uDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy4NCiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuDQogICAqLw0KICBsZXJwKG90aGVyLCB0KSB7DQogICAgY29uc3QgYXIgPSB0aGlzLnI7DQogICAgY29uc3QgYWcgPSB0aGlzLmc7DQogICAgY29uc3QgYWIgPSB0aGlzLmI7DQogICAgY29uc3QgYWEgPSB0aGlzLmE7DQogICAgcmV0dXJuIG5ldyBSR0JBKGFyICsgdCAqIChvdGhlci5yIC0gYXIpLCBhZyArIHQgKiAob3RoZXIuZyAtIGFnKSwgYWIgKyB0ICogKG90aGVyLmIgLSBhYiksIGFhICsgdCAqIChvdGhlci5hIC0gYWEpKQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSByYW5kb20gUkdCQS4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGdhbW1hT2Zmc2V0IC0gVGhlIGdhbW1hIG9mZnNldC4NCiAgICogQHBhcmFtIHtib29sZWFufSByYW5kb21BbHBoYSAtIERldGVybWluZXMgd2hldGhlciB0aGUgYWxwaGEgY2hhbm5lbCBpcyByYW5kb20uDQogICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyBhIG5ldyByYW5kb20gUkdCQS4NCiAgICovDQogIHN0YXRpYyByYW5kb20oZ2FtbWFPZmZzZXQgPSAwLjAsIHJhbmRvbUFscGhhID0gZmFsc2UpIHsNCiAgICBpZiAoZ2FtbWFPZmZzZXQgPiAwLjApIHsNCiAgICAgIHJldHVybiBuZXcgUkdCQSgNCiAgICAgICAgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwNCiAgICAgICAgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwNCiAgICAgICAgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwNCiAgICAgICAgcmFuZG9tQWxwaGEgPyBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpIDogMS4wDQogICAgICApDQogICAgfSBlbHNlIGlmIChnYW1tYU9mZnNldCA8IDAuMCkgew0KICAgICAgcmV0dXJuIG5ldyBSR0JBKA0KICAgICAgICBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSwNCiAgICAgICAgTWF0aC5yYW5kb20oKSAqICgxLjAgKyBnYW1tYU9mZnNldCksDQogICAgICAgIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLA0KICAgICAgICByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpIDogMS4wDQogICAgICApDQogICAgfSBlbHNlIHsNCiAgICAgIHJldHVybiBuZXcgUkdCQShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgOiAxLjApDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIENsb25lcyB0aGlzIFJHQkEgY29sb3IgYW5kIHJldHVybnMgYSBuZXcgUkdCQSBjb2xvci4NCiAgICoNCiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IFJHQkEodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbM10pDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdHlwZSBhcyBhbiBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAqDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYW4gYXJyYXkuDQogICAqLw0KICBhc0FycmF5KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAqDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4NCiAgICovDQogIGFzM0NvbXBvbmVudEFycmF5KCkgew0KICAgIHJldHVybiBbdGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXV0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBSR0JBIGNvbG9yLg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgUkdCQSguLi5hcmdzKQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlciBtZXRob2QuDQogICAqDQogICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIoYnVmZmVyLCBvZmZzZXQgPSAwKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpOw0KICAgIHJldHVybiB0aGlzLmNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBvZmZzZXQgKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgUkdCQWAgdXNpbmcgYW4gQXJyYXlCdWZmZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS4NCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkgew0KICAgIHJldHVybiBuZXcgUkdCQShuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpKSAvLyA0IGJ5dGVzIHBlciAzMmJpdCBmbG9hdA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBGbG9hdDMyIGVsZW1lbnRzIHVzZWQgYnkgdGhpcyB0eXBlLiBVc2VkIHRvIGNhbGN1bGF0ZSBzdG9yYWdlIHJlcXVpcmVtZW50cyBmb3IgbGFyZ2UgYXJyYXlzIG9mIHRoaXMgdHlwZS4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgbnVtRWxlbWVudHMoKSB7DQogICAgcmV0dXJuIDQNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICByOiB0aGlzLnIsDQogICAgICBnOiB0aGlzLmcsDQogICAgICBiOiB0aGlzLmIsDQogICAgICBhOiB0aGlzLmEsDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMuciA9IGoucjsNCiAgICB0aGlzLmcgPSBqLmc7DQogICAgdGhpcy5iID0gai5iOw0KICAgIHRoaXMuYSA9IGouYTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBDU1MgcmdiYSBzdHJpbmcuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgdG9DU1NTdHJpbmcoKSB7DQogICAgcmV0dXJuICgNCiAgICAgICdyZ2JhKCcgKw0KICAgICAgTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpICsNCiAgICAgICcsICcgKw0KICAgICAgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpICsNCiAgICAgICcsICcgKw0KICAgICAgTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpICsNCiAgICAgICcsICcgKw0KICAgICAgdGhpcy5hICsNCiAgICAgICcpJw0KICAgICkNCiAgfQ0KfQ0KDQpSZWdpc3RyeS5yZWdpc3RlcignUkdCQScsIFJHQkEpOwoKLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYyAqLw0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNvbG9yIGFzIDQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLg0KICoNCiAqIEBleHRlbmRzIEF0dHJWYWx1ZQ0KICovDQpjbGFzcyBDb2xvciBleHRlbmRzIEF0dHJWYWx1ZSB7DQogIC8qKg0KICAgKiBDcmVhdGVzIGEgYENvbG9yYCBvYmplY3Qgd2l0aCBhbiBSR0JBIHN0cnVjdHVyZS4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCBGbG9hdDMyQXJyYXkgfCBBcnJheUJ1ZmZlcn0gciAtIFRoZSByZWQgY2hhbm5lbCBvZiBhIGNvbG9yLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZyAtIFRoZSBncmVlbiBjaGFubmVsIG9mIGEgY29sb3IuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gVGhlIGJsdWUgY2hhbm5lbCBvZiBhIGNvbG9yLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBhbHBoYSAodHJhbnNwYXJlbmN5KSBjaGFubmVsIG9mIGEgY29sb3IuDQogICAqLw0KICBjb25zdHJ1Y3RvcihyID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMS4wKSB7DQogICAgc3VwZXIoKTsNCg0KICAgIGlmIChyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7DQogICAgICB0aGlzLl9fZGF0YSA9IHI7DQogICAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsNCiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYCk7DQogICAgICBjb25zdCBidWZmZXIgPSByOw0KICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGc7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KTsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpOw0KICAgICAgaWYgKHR5cGVvZiByID09ICdzdHJpbmcnKSB7DQogICAgICAgIGlmIChyLnN0YXJ0c1dpdGgoJyMnKSkgew0KICAgICAgICAgIHRoaXMuc2V0RnJvbUhleChyKTsNCiAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICB0aGlzLnNldEZyb21DU1NDb2xvck5hbWUocik7DQogICAgICAgIH0NCiAgICAgIH0gZWxzZSB7DQogICAgICAgIHRoaXMuX19kYXRhWzBdID0gcjsNCiAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSBnOw0KICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IGI7DQogICAgICAgIHRoaXMuX19kYXRhWzNdID0gYTsNCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByZWQgY2hhbm5lbC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHJlZCBjaGFubmVsLg0KICAgKi8NCiAgZ2V0IHIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByZWQgY2hhbm5lbC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgcih2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGdyZWVuIGNoYW5uZWwuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBncmVlbiBjaGFubmVsLg0KICAgKi8NCiAgZ2V0IGcoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBncmVlbiBjaGFubmVsLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBnKHZhbCkgew0KICAgIHRoaXMuX19kYXRhWzFdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3IgYmx1ZSBjaGFubmVsLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgYmx1ZSBjaGFubmVsLg0KICAgKi8NCiAgZ2V0IGIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBibHVlIGNoYW5uZWwuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IGIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciBhbHBoYSBjaGFubmVsLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgYWxwaGEgY2hhbm5lbC4NCiAgICovDQogIGdldCBhKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVszXQ0KICB9DQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGFscGhhIHZhbHVlLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBhKHZhbCkgew0KICAgIHRoaXMuX19kYXRhWzNdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSByZWQgY2hhbm5lbC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGcgIC0gVGhlIGdyZWVuIGNoYW5uZWwuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBiICAtIFRoZSBibHVlIGNoYW5uZWwuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBhICAtIFRoZSBhbHBoYSBjaGFubmVsLg0KICAgKi8NCiAgc2V0KHIsIGcsIGIsIGEgPSAxLjApIHsNCiAgICB0aGlzLnIgPSByOw0KICAgIHRoaXMuZyA9IGc7DQogICAgdGhpcy5iID0gYjsNCiAgICB0aGlzLmEgPSBhOw0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgY3VycmVudCBjb2xvciBzdGF0ZSB3aXRoIGFub3RoZXIgYENvbG9yYCBvYmplY3QuDQogICAqDQogICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIHNldCBmcm9tLg0KICAgKi8NCiAgc2V0RnJvbU90aGVyKG90aGVyKSB7DQogICAgdGhpcy5yID0gb3RoZXIucjsNCiAgICB0aGlzLmcgPSBvdGhlci5nOw0KICAgIHRoaXMuYiA9IG90aGVyLmI7DQogICAgdGhpcy5hID0gb3RoZXIuYTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBhIHNjYWxhciBhcnJheS4NCiAgICoNCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZhbHMgLSBUaGUgdmFscyBwYXJhbS4NCiAgICovDQogIHNldEZyb21TY2FsYXJBcnJheSh2YWxzKSB7DQogICAgdGhpcy5yID0gdmFsc1swXTsNCiAgICB0aGlzLmcgPSB2YWxzWzFdOw0KICAgIHRoaXMuYiA9IHZhbHNbMl07DQogICAgdGhpcy5hID0gdmFscy5sZW5ndGggPT0gNCA/IHZhbHNbM10gOiAxLjA7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZyb20gYW4gUkdCIGFycmF5Lg0KICAgKg0KICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0QXNSR0JBcnJheSgpIHsNCiAgICByZXR1cm4gW3RoaXMuciAqIDI1NSwgdGhpcy5nICogMjU1LCB0aGlzLmIgKiAyNTVdDQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZyb20gYW4gUkdCIGRpY3QuDQogICAqDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0QXNSR0JEaWN0KCkgew0KICAgIHJldHVybiB7DQogICAgICByOiB0aGlzLnIgKiAyNTUsDQogICAgICBnOiB0aGlzLmcgKiAyNTUsDQogICAgICBiOiB0aGlzLmIgKiAyNTUsDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmcm9tIGEgUkdCIHZhbHVlLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSByZWQgY2hhbm5lbC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGcgIC0gVGhlIGdyZWVuIGNoYW5uZWwuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBiICAtIFRoZSBibHVlIGNoYW5uZWwuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBhICAtIFRoZSBhbHBoYSBjaGFubmVsLg0KICAgKi8NCiAgc2V0RnJvbVJHQihyLCBnLCBiLCBhKSB7DQogICAgdGhpcy5yID0gciAvIDI1NTsNCiAgICB0aGlzLmcgPSBnIC8gMjU1Ow0KICAgIHRoaXMuYiA9IGIgLyAyNTU7DQogICAgdGhpcy5hID0gYSA/IGEgLyAyNTUgOiAxLjA7DQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZyb20gYW4gUkdCIGFycmF5Lg0KICAgKg0KICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLg0KICAgKi8NCiAgc2V0RnJvbVJHQkFycmF5KHZhbHMpIHsNCiAgICB0aGlzLnIgPSB2YWxzWzBdIC8gMjU1Ow0KICAgIHRoaXMuZyA9IHZhbHNbMV0gLyAyNTU7DQogICAgdGhpcy5iID0gdmFsc1syXSAvIDI1NTsNCiAgICB0aGlzLmEgPSB2YWxzLmxlbmd0aCA9PSA0ID8gdmFsc1szXSAvIDI1NSA6IDEuMDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBhbiBSR0IgZGljdC4NCiAgICoNCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZhbHMgLSBUaGUgdmFscyBwYXJhbS4NCiAgICovDQogIHNldEZyb21SR0JEaWN0KHZhbHMpIHsNCiAgICB0aGlzLnIgPSB2YWxzLnIgLyAyNTU7DQogICAgdGhpcy5nID0gdmFscy5nIC8gMjU1Ow0KICAgIHRoaXMuYiA9IHZhbHMuYiAvIDI1NTsNCiAgICB0aGlzLmEgPSB2YWxzLmEgPT0gNCA/IHZhbHMuYSAvIDI1NSA6IDEuMDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBhIGhleGFkZWNpbWFsIHZhbHVlLg0KICAgKiBFLmcuICNmZjAwMDANCiAgICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBoZXggdmFsdWUuDQogICAqLw0KICBzZXRGcm9tSGV4KGhleCkgew0KICAgIGZ1bmN0aW9uIGhleFRvUmdiKGhleCkgew0KICAgICAgY29uc3QgcmVzdWx0ID0gL14jPyhbYS1mXGRdezJ9KShbYS1mXGRdezJ9KShbYS1mXGRdezJ9KSQvaS5leGVjKGhleCk7DQogICAgICByZXR1cm4gcmVzdWx0DQogICAgICAgID8gew0KICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksDQogICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSwNCiAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLA0KICAgICAgICAgIH0NCiAgICAgICAgOiBudWxsDQogICAgfQ0KICAgIGNvbnN0IHJnYiA9IGhleFRvUmdiKGhleCk7DQogICAgaWYgKCFyZ2IpIHsNCiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBoZXggY29kZTonICsgaGV4KTsNCiAgICAgIHJldHVybg0KICAgIH0NCiAgICB0aGlzLnNldEZyb21SR0IocmdiLnIsIHJnYi5nLCByZ2IuYik7DQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZyb20gYSBDU1MgY29sb3IgbmFtZS4NCiAgICogRS5nLiAicmVkIg0KICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBDU1MgY29sb3IgbmFtZS4NCiAgICovDQogIHNldEZyb21DU1NDb2xvck5hbWUobmFtZSkgew0KICAgIGNvbnN0IGNvbG91ck5hbWVUb0hleCA9IChjb2xvdXIpID0+IHsNCiAgICAgIGNvbnN0IGNvbG9ycyA9IHsNCiAgICAgICAgYWxpY2VibHVlOiAnI2YwZjhmZicsDQogICAgICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLA0KICAgICAgICBhcXVhOiAnIzAwZmZmZicsDQogICAgICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JywNCiAgICAgICAgYXp1cmU6ICcjZjBmZmZmJywNCiAgICAgICAgYmVpZ2U6ICcjZjVmNWRjJywNCiAgICAgICAgYmlzcXVlOiAnI2ZmZTRjNCcsDQogICAgICAgIGJsYWNrOiAnIzAwMDAwMCcsDQogICAgICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsDQogICAgICAgIGJsdWU6ICcjMDAwMGZmJywNCiAgICAgICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLA0KICAgICAgICBicm93bjogJyNhNTJhMmEnLA0KICAgICAgICBidXJseXdvb2Q6ICcjZGViODg3JywNCiAgICAgICAgY2FkZXRibHVlOiAnIzVmOWVhMCcsDQogICAgICAgIGNoYXJ0cmV1c2U6ICcjN2ZmZjAwJywNCiAgICAgICAgY2hvY29sYXRlOiAnI2QyNjkxZScsDQogICAgICAgIGNvcmFsOiAnI2ZmN2Y1MCcsDQogICAgICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsDQogICAgICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsDQogICAgICAgIGNyaW1zb246ICcjZGMxNDNjJywNCiAgICAgICAgY3lhbjogJyMwMGZmZmYnLA0KICAgICAgICBkYXJrYmx1ZTogJyMwMDAwOGInLA0KICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLA0KICAgICAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsDQogICAgICAgIGRhcmtncmF5OiAnI2E5YTlhOScsDQogICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLA0KICAgICAgICBkYXJra2hha2k6ICcjYmRiNzZiJywNCiAgICAgICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJywNCiAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJywNCiAgICAgICAgZGFya29yYW5nZTogJyNmZjhjMDAnLA0KICAgICAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsDQogICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJywNCiAgICAgICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLA0KICAgICAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJywNCiAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLA0KICAgICAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsDQogICAgICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJywNCiAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLA0KICAgICAgICBkZWVwcGluazogJyNmZjE0OTMnLA0KICAgICAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLA0KICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsDQogICAgICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJywNCiAgICAgICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsDQogICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsDQogICAgICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsDQogICAgICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJywNCiAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsDQogICAgICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJywNCiAgICAgICAgZ29sZDogJyNmZmQ3MDAnLA0KICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJywNCiAgICAgICAgZ3JheTogJyM4MDgwODAnLA0KICAgICAgICBncmVlbjogJyMwMDgwMDAnLA0KICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLA0KICAgICAgICBob25leWRldzogJyNmMGZmZjAnLA0KICAgICAgICBob3RwaW5rOiAnI2ZmNjliNCcsDQogICAgICAgICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLA0KICAgICAgICBpbmRpZ286ICcjNGIwMDgyJywNCiAgICAgICAgaXZvcnk6ICcjZmZmZmYwJywNCiAgICAgICAga2hha2k6ICcjZjBlNjhjJywNCiAgICAgICAgbGF2ZW5kZXI6ICcjZTZlNmZhJywNCiAgICAgICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLA0KICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJywNCiAgICAgICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsDQogICAgICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLA0KICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsDQogICAgICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLA0KICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNmYWZhZDInLA0KICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJywNCiAgICAgICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLA0KICAgICAgICBsaWdodHBpbms6ICcjZmZiNmMxJywNCiAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJywNCiAgICAgICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLA0KICAgICAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJywNCiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywNCiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJywNCiAgICAgICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJywNCiAgICAgICAgbGltZTogJyMwMGZmMDAnLA0KICAgICAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJywNCiAgICAgICAgbGluZW46ICcjZmFmMGU2JywNCiAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLA0KICAgICAgICBtYXJvb246ICcjODAwMDAwJywNCiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLA0KICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsDQogICAgICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLA0KICAgICAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGQ4JywNCiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJywNCiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsDQogICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsDQogICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLA0KICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JywNCiAgICAgICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsDQogICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLA0KICAgICAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJywNCiAgICAgICAgbW9jY2FzaW46ICcjZmZlNGI1JywNCiAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJywNCiAgICAgICAgbmF2eTogJyMwMDAwODAnLA0KICAgICAgICBvbGRsYWNlOiAnI2ZkZjVlNicsDQogICAgICAgIG9saXZlOiAnIzgwODAwMCcsDQogICAgICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLA0KICAgICAgICBvcmFuZ2U6ICcjZmZhNTAwJywNCiAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsDQogICAgICAgIG9yY2hpZDogJyNkYTcwZDYnLA0KICAgICAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsDQogICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLA0KICAgICAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsDQogICAgICAgIHBhbGV2aW9sZXRyZWQ6ICcjZDg3MDkzJywNCiAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLA0KICAgICAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JywNCiAgICAgICAgcGVydTogJyNjZDg1M2YnLA0KICAgICAgICBwaW5rOiAnI2ZmYzBjYicsDQogICAgICAgIHBsdW06ICcjZGRhMGRkJywNCiAgICAgICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLA0KICAgICAgICBwdXJwbGU6ICcjODAwMDgwJywNCiAgICAgICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLA0KICAgICAgICByZWQ6ICcjZmYwMDAwJywNCiAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsDQogICAgICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLA0KICAgICAgICBzYWRkbGVicm93bjogJyM4YjQ1MTMnLA0KICAgICAgICBzYWxtb246ICcjZmE4MDcyJywNCiAgICAgICAgc2FuZHlicm93bjogJyNmNGE0NjAnLA0KICAgICAgICBzZWFncmVlbjogJyMyZThiNTcnLA0KICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLA0KICAgICAgICBzaWVubmE6ICcjYTA1MjJkJywNCiAgICAgICAgc2lsdmVyOiAnI2MwYzBjMCcsDQogICAgICAgIHNreWJsdWU6ICcjODdjZWViJywNCiAgICAgICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsDQogICAgICAgIHNsYXRlZ3JheTogJyM3MDgwOTAnLA0KICAgICAgICBzbm93OiAnI2ZmZmFmYScsDQogICAgICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsDQogICAgICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLA0KICAgICAgICB0YW46ICcjZDJiNDhjJywNCiAgICAgICAgdGVhbDogJyMwMDgwODAnLA0KICAgICAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsDQogICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLA0KICAgICAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJywNCiAgICAgICAgdmlvbGV0OiAnI2VlODJlZScsDQogICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsDQogICAgICAgIHdoaXRlOiAnI2ZmZmZmZicsDQogICAgICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JywNCiAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsDQogICAgICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMicsDQogICAgICB9Ow0KDQogICAgICBpZiAodHlwZW9mIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV0gIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBjb2xvcnNbY29sb3VyLnRvTG93ZXJDYXNlKCldDQoNCiAgICAgIHJldHVybiBmYWxzZQ0KICAgIH07DQogICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnIycpKSB7DQogICAgICB0aGlzLnNldEZyb21IZXgobmFtZSk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuc2V0RnJvbUhleChjb2xvdXJOYW1lVG9IZXgobmFtZSkpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiB0aGlzIGNvbG9yLg0KICAgKg0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gUmV0dXJucyB0aGUgaGV4IHZhbHVlLg0KICAgKi8NCiAgdG9IZXgoKSB7DQogICAgZnVuY3Rpb24gY29tcG9uZW50VG9IZXgoYykgew0KICAgICAgY29uc3QgaW50ID0gTWF0aC5yb3VuZChjICogMjU1KTsNCiAgICAgIGNvbnN0IGhleCA9IGludC50b1N0cmluZygxNik7DQogICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4DQogICAgfQ0KICAgIHJldHVybiAnIycgKyBjb21wb25lbnRUb0hleCh0aGlzLnIpICsgY29tcG9uZW50VG9IZXgodGhpcy5nKSArIGNvbXBvbmVudFRvSGV4KHRoaXMuYikNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xvciBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge0NvbG9yfSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgKi8NCiAgZXF1YWwob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy5yID09IG90aGVyLnIgJiYgdGhpcy5nID09IG90aGVyLmcgJiYgdGhpcy5iID09IG90aGVyLmIgJiYgdGhpcy5hID09IG90aGVyLmENCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xvciBpcyBOT1QgZXhhY3RseSB0aGUgc2FtZSBhcyBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtDb2xvcn0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIG5vdEVxdWFscyhvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnIgIT0gb3RoZXIuciAmJiB0aGlzLmcgIT0gb3RoZXIuZyAmJiB0aGlzLmIgIT0gb3RoZXIuYiAmJiB0aGlzLmEgIT0gb3RoZXIuYQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbG9yIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAqDQogICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgIHJldHVybiAoDQogICAgICBNYXRoLmFicyh0aGlzLnIgLSBvdGhlci5yKSA8IHByZWNpc2lvbiAmJg0KICAgICAgTWF0aC5hYnModGhpcy5nIC0gb3RoZXIuZykgPCBwcmVjaXNpb24gJiYNCiAgICAgIE1hdGguYWJzKHRoaXMuYiAtIG90aGVyLmIpIDwgcHJlY2lzaW9uICYmDQogICAgICBNYXRoLmFicyh0aGlzLmEgLSBvdGhlci5hKSA8IHByZWNpc2lvbg0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgbmV3IENvbG9yIHdoaWNoIGlzIHRoaXMgQ29sb3IgYWRkZWQgdG8gb3RoZXIuDQogICAqDQogICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGFkZC4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICovDQogIGFkZChvdGhlcikgew0KICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yICsgb3RoZXIuciwgdGhpcy5nICsgb3RoZXIuZywgdGhpcy5iICsgb3RoZXIuYiwgdGhpcy5hICsgb3RoZXIuYSkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHdoaWNoIGlzIHRoaXMgY29sb3Igc3VidHJhY3RlZCBmcm9tIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge0NvbG9yfSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBzdWJ0cmFjdC4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICovDQogIHN1YnRyYWN0KG90aGVyKSB7DQogICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIgLSBvdGhlci5yLCB0aGlzLmcgLSBvdGhlci5nLCB0aGlzLmIgLSBvdGhlci5iLCB0aGlzLmEgLSBvdGhlci5hKQ0KICB9DQoNCiAgLyoqDQogICAqIFNjYWxlcyB0aGlzIGNvbG9yIGJ5IHNjYWxhciBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAqLw0KICBzY2FsZShzY2FsYXIpIHsNCiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciAqIHNjYWxhciwgdGhpcy5nICogc2NhbGFyLCB0aGlzLmIgKiBzY2FsYXIsIHRoaXMuYSAqIHNjYWxhcikNCiAgfQ0KDQogIC8qKg0KICAgKiBTY2FsZXMgdGhpcyBjb2xvciBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgIHRoaXMuciAqPSBzY2FsYXI7DQogICAgdGhpcy5nICo9IHNjYWxhcjsNCiAgICB0aGlzLmIgKj0gc2NhbGFyOw0KICAgIHRoaXMuYSAqPSBzY2FsYXI7DQogIH0NCg0KICAvKioNCiAgICogQXBwbHkgZ2FtbWEgY29ycmVjdGlvbiB0byB0aGlzIGNvbG9yDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS4NCiAgICovDQogIGFwcGx5R2FtbWEoZ2FtbWEpIHsNCiAgICB0aGlzLnNldChNYXRoLnBvdyh0aGlzLnIsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5nLCBnYW1tYSksIE1hdGgucG93KHRoaXMuYiwgZ2FtbWEpLCB0aGlzLmEpOw0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRvIGxpbmVhciBjb2xvciBzcGFjZSBhbmQgcmV0dXJucyBhIG5ldyBjb2xvcg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAqLw0KICB0b0xpbmVhcihnYW1tYSA9IDIuMikgew0KICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5wb3codGhpcy5yLCBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIGdhbW1hKSwgdGhpcy5hKQ0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRvIGdhbW1hIGNvbG9yIHNwYWNlIGFuZCByZXR1cm5zIGEgbmV3IGNvbG9yLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAqLw0KICB0b0dhbW1hKGdhbW1hID0gMi4yKSB7DQogICAgcmV0dXJuIG5ldyBDb2xvcigNCiAgICAgIE1hdGgucG93KHRoaXMuciwgMS4wIC8gZ2FtbWEpLA0KICAgICAgTWF0aC5wb3codGhpcy5nLCAxLjAgLyBnYW1tYSksDQogICAgICBNYXRoLnBvdyh0aGlzLmIsIDEuMCAvIGdhbW1hKSwNCiAgICAgIHRoaXMuYQ0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSByZWxhdGl2ZSBsdW1pbmFuY2Ugb2YgdGhlIGxpbmVhciBSR0IgY29tcG9uZW50Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGx1bWluYW5jZSgpIHsNCiAgICByZXR1cm4gMC4yMTI2ICogdGhpcy5yICsgMC43MTUyICogdGhpcy5nICsgMC4wNzIyICogdGhpcy5iDQogIH0NCg0KICAvKioNCiAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgY29sb3IgYW5kIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge0NvbG9yfSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAqLw0KICBsZXJwKG90aGVyLCB0KSB7DQogICAgY29uc3QgYXIgPSB0aGlzLnI7DQogICAgY29uc3QgYWcgPSB0aGlzLmc7DQogICAgY29uc3QgYWIgPSB0aGlzLmI7DQogICAgY29uc3QgYWEgPSB0aGlzLmE7DQogICAgcmV0dXJuIG5ldyBDb2xvcihhciArIHQgKiAob3RoZXIuciAtIGFyKSwgYWcgKyB0ICogKG90aGVyLmcgLSBhZyksIGFiICsgdCAqIChvdGhlci5iIC0gYWIpLCBhYSArIHQgKiAob3RoZXIuYSAtIGFhKSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGEgcmFuZG9tIGNvbG9yLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWFPZmZzZXQgLSBUaGUgZ2FtbWEgb2Zmc2V0Lg0KICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJhbmRvbUFscGhhIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhbHBoYSBjaGFubmVsIGlzIHJhbmRvbS4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyByYW5kb20gY29sb3IuDQogICAqLw0KICBzdGF0aWMgcmFuZG9tKGdhbW1hT2Zmc2V0ID0gMC4wLCByYW5kb21BbHBoYSA9IGZhbHNlKSB7DQogICAgaWYgKGdhbW1hT2Zmc2V0ID4gMC4wKSB7DQogICAgICByZXR1cm4gbmV3IENvbG9yKA0KICAgICAgICBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLA0KICAgICAgICBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLA0KICAgICAgICBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLA0KICAgICAgICByYW5kb21BbHBoYSA/IGdhbW1hT2Zmc2V0ICsgTWF0aC5yYW5kb20oKSAqICgxLjAgLSBnYW1tYU9mZnNldCkgOiAxLjANCiAgICAgICkNCiAgICB9IGVsc2UgaWYgKGdhbW1hT2Zmc2V0IDwgMC4wKSB7DQogICAgICByZXR1cm4gbmV3IENvbG9yKA0KICAgICAgICBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSwNCiAgICAgICAgTWF0aC5yYW5kb20oKSAqICgxLjAgKyBnYW1tYU9mZnNldCksDQogICAgICAgIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLA0KICAgICAgICByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpIDogMS4wDQogICAgICApDQogICAgfSBlbHNlIHsNCiAgICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgcmFuZG9tQWxwaGEgPyBNYXRoLnJhbmRvbSgpIDogMS4wKQ0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBjb2xvciBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICoNCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICovDQogIGNsb25lKCkgew0KICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbM10pDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdHlwZSBhcyBhbiBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAqDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYW4gYXJyYXkuDQogICAqLw0KICBhc0FycmF5KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAqDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIGFzM0NvbXBvbmVudEFycmF5KCkgew0KICAgIHJldHVybiBbdGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXV0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBjb2xvci4NCiAgICogQHBhcmFtIHsuLi5vYmplY3R9IC4uLmFyZ3MgLSBUaGUgLi4uYXJncyBwYXJhbS4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgQ29sb3IoLi4uYXJncykNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIgbWV0aG9kLg0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihidWZmZXIsIG9mZnNldCA9IDApIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQsIHVzZSAjY3JlYXRlRnJvbUJ1ZmZlciBpbnN0ZWFkJyk7DQogICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIG9mZnNldCAqIDQpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGBDb2xvcmAgdXNpbmcgYW4gQXJyYXlCdWZmZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLg0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7DQogICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIEZsb2F0MzIgZWxlbWVudHMgdXNlZCBieSB0aGlzIHR5cGUuIFVzZWQgdG8gY2FsY3VsYXRlIHN0b3JhZ2UgcmVxdWlyZW1lbnRzIGZvciBsYXJnZSBhcnJheXMgb2YgdGhpcyB0eXBlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBudW1FbGVtZW50cygpIHsNCiAgICByZXR1cm4gNA0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTigpIHsNCiAgICByZXR1cm4gew0KICAgICAgcjogdGhpcy5yLA0KICAgICAgZzogdGhpcy5nLA0KICAgICAgYjogdGhpcy5iLA0KICAgICAgYTogdGhpcy5hLA0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgKg0KICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIGZyb21KU09OKGopIHsNCiAgICB0aGlzLnIgPSBqLnI7DQogICAgdGhpcy5nID0gai5nOw0KICAgIHRoaXMuYiA9IGouYjsNCiAgICB0aGlzLmEgPSBqLmE7DQogIH0NCg0KICAvKioNCiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgIHRoaXMuciA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMuZyA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMuYiA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMuYSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIENTUyByZ2JhIHN0cmluZy4NCiAgICoNCiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICB0b0NTU1N0cmluZygpIHsNCiAgICByZXR1cm4gKA0KICAgICAgJ3JnYmEoJyArDQogICAgICBNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkgKw0KICAgICAgJywgJyArDQogICAgICBNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSkgKw0KICAgICAgJywgJyArDQogICAgICBNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSkgKw0KICAgICAgJywgJyArDQogICAgICB0aGlzLmEgKw0KICAgICAgJyknDQogICAgKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdDb2xvcicsIENvbG9yKTsKCi8qKg0KICogQ2xhc3MgcmVwcmVzZW50aW5nIGV1bGVyIGFuZ2xlcy4gRXVsZXIgYW5nbGVzIGRlc2NyaWJlIHJvdGF0aW5nIGFuIG9iamVjdA0KICogYXJvdW5kIGl0cyB2YXJpb3VzIGF4aXMgaW4gYSBzcGVjaWZpZWQgYXhpcyBvcmRlci4NCiAqDQogKiBAZXh0ZW5kcyBBdHRyVmFsdWUNCiAqLw0KY2xhc3MgRXVsZXJBbmdsZXMgZXh0ZW5kcyBBdHRyVmFsdWUgew0KICAvKioNCiAgICogQ3JlYXRlIGEgZXVsZXIgYW5nbGUuIFJlY2VpdmVzIHRoZSB4eXogdmFsdWVzIGluIGRlZ3JlZXMgYW5kIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuDQogICAqIDxicj4NCiAgICogT3JkZXIgcGFyYW1ldGVyIHZhbHVlczogYFhZWjogMGAsIGBZWlg6IDFgLCBgWlhZOiAyYCwgYFhaWTogM2AsIGBaWVg6IDRgLCBgWVhaOiA1YA0KICAgKiA8YnI+DQogICAqIEl0IGNvdWxkIGJlIGVpdGhlciB0aGUgYHN0cmluZ2Agb3IgdGhlIGBudW1iZXJgIHZhbHVlLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBhbmdsZSBvZiB0aGUgeCBheGlzIGluIGRlZ3JlZXMuIERlZmF1bHQgaXMgMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW5nbGUgb2YgdGhlIHkgYXhpcyBpbiBkZWdyZWVzLiBEZWZhdWx0IGlzIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIGFuZ2xlIG9mIHRoZSB6IGF4aXMgaW4gZGVncmVlcy4gRGVmYXVsdCBpcyAwLg0KICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gb3JkZXIgLSBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC4NCiAgICovDQogIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gMCkgew0KICAgIHN1cGVyKCk7DQoNCiAgICBpZiAoIWlzTmFOKG9yZGVyKSkgdGhpcy5vcmRlciA9IG9yZGVyOw0KICAgIGVsc2Ugew0KICAgICAgc3dpdGNoIChvcmRlcikgew0KICAgICAgICBjYXNlICdYWVonOg0KICAgICAgICAgIHRoaXMub3JkZXIgPSAwOw0KICAgICAgICAgIGJyZWFrDQogICAgICAgIGNhc2UgJ1laWCc6DQogICAgICAgICAgdGhpcy5vcmRlciA9IDE7DQogICAgICAgICAgYnJlYWsNCiAgICAgICAgY2FzZSAnWlhZJzoNCiAgICAgICAgICB0aGlzLm9yZGVyID0gMjsNCiAgICAgICAgICBicmVhaw0KICAgICAgICBjYXNlICdYWlknOg0KICAgICAgICAgIHRoaXMub3JkZXIgPSAzOw0KICAgICAgICAgIGJyZWFrDQogICAgICAgIGNhc2UgJ1pZWCc6DQogICAgICAgICAgdGhpcy5vcmRlciA9IDQ7DQogICAgICAgICAgYnJlYWsNCiAgICAgICAgY2FzZSAnWVhaJzoNCiAgICAgICAgICB0aGlzLm9yZGVyID0gNTsNCiAgICAgICAgICBicmVhaw0KICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFdWxlciBBbmdsZXMgT3JkZXI6JyArIG9yZGVyKQ0KICAgICAgfQ0KICAgIH0NCiAgICBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7DQogICAgICBjb25zdCBidWZmZXIgPSB4Ow0KICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHk7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KTsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDMpOw0KICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4Ow0KICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5Ow0KICAgICAgdGhpcy5fX2RhdGFbMl0gPSB6Ow0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHggYXhpcyByb3RhdGlvbi4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHggYXhpcyByb3RhdGlvbi4NCiAgICovDQogIGdldCB4KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVswXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgeCBheGlzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCB4KHZhbCkgew0KICAgIHRoaXMuX19kYXRhWzBdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3IgeSBheGlzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeSBheGlzIHJvdGF0aW9uLg0KICAgKi8NCiAgZ2V0IHkoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciB5IGF4aXMgcm90YXRpb24uDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IHkodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB6IGF4aXMgcm90YXRpb24uDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB6IGF4aXMgcm90YXRpb24uDQogICAqLw0KICBnZXQgeigpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIHogYXhpcyByb3RhdGlvbi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeih2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBFdWxlckFuZ2xlcw0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGF4aXMgcm90YXRpb24uDQogICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAtIFRoZSB5IGF4aXMgcm90YXRpb24uDQogICAqIEBwYXJhbSB7bnVtYmVyfSB6ICAtIFRoZSB6IGF4aXMgcm90YXRpb24uDQogICAqLw0KICBzZXQoeCwgeSwgeikgew0KICAgIHRoaXMuX19kYXRhWzBdID0geDsNCiAgICB0aGlzLl9fZGF0YVsxXSA9IHk7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB6Ow0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdFdWxlckFuZ2xlcycsIEV1bGVyQW5nbGVzKTsKCi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8NCg0KLyoqDQogKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIDN4MyBtYXRyaXguDQogKiBUaGlzIG1hdHJpeCBjbGFzcyBpcyBiYXNlZCBvbiBHTE0sIGFuZCBpcyBjb2x1bW4gbWFqb3IuDQogKg0KICogQGV4dGVuZHMgQXR0clZhbHVlDQogKi8NCmNsYXNzIE1hdDMgZXh0ZW5kcyBBdHRyVmFsdWUgew0KICAvKioNCiAgICogSW5pdGlhbGl6ZXMgdGhlIE1hdDMgY2xhc3Mgd2l0aCBnaXZlbiBkYXRhLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlciB8IEFycmF5QnVmZmVyfSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMDEgLSBSb3cgMCwgY29sdW1uIDEuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMDIgLSBSb3cgMCwgY29sdW1uIDIuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMTAgLSBSb3cgMSwgY29sdW1uIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMTEgLSBSb3cgMSwgY29sdW1uIDEuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMjAgLSBSb3cgMiwgY29sdW1uIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMjEgLSBSb3cgMiwgY29sdW1uIDEuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBtMjIgLSBSb3cgMiwgY29sdW1uIDIuDQogICAqLw0KICBjb25zdHJ1Y3RvcihtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxKSB7DQogICAgc3VwZXIoKTsNCg0KICAgIGlmIChtMDAgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgbTAwIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbTAwOw0KICAgIH0gZWxzZSBpZiAobTAwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsNCiAgICAgIGNvbnNvbGUud2FybihgRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjMyhuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgOSkpYCk7DQogICAgICBjb25zdCBidWZmZXIgPSBtMDA7DQogICAgICBjb25zdCBieXRlT2Zmc2V0ID0gbTAxOw0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgOSk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg5KTsNCiAgICAgIHRoaXMuc2V0KG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpOw0KICAgIH0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIHByb3BlcnRpZXMNCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDAuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDAgdmFsdWUuDQogICAqLw0KICBnZXQgbTAwKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVswXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDEgdmFsdWUuDQogICAqLw0KICBnZXQgbTAxKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDEodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDIgdmFsdWUuDQogICAqLw0KICBnZXQgbTAyKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDAuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTAgdmFsdWUuDQogICAqLw0KICBnZXQgbTEwKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVszXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMTAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbM10gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDENCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0xMSB2YWx1ZS4NCiAgICovDQogIGdldCBtMTEoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzRdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDEuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0xMSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs0XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMi4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0xMiB2YWx1ZS4NCiAgICovDQogIGdldCBtMTIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzVdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0xMih2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs1XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMCB2YWx1ZS4NCiAgICovDQogIGdldCBtMjAoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzZdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDAuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0yMCh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs2XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMS4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMSB2YWx1ZS4NCiAgICovDQogIGdldCBtMjEoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzddDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDEuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0yMSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs3XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMiB2YWx1ZS4NCiAgICovDQogIGdldCBtMjIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzhdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0yMih2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs4XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBgeGAgYXhpcyBhcyBhIFZlYzMuDQogICAqLw0KICBnZXQgeEF4aXMoKSB7DQogICAgcmV0dXJuIFZlYzMkMS5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgMCkNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuDQogICAqLw0KICBzZXQgeEF4aXModmVjMykgew0KICAgIHRoaXMueEF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3IgdGhlIGB5YCBheGlzLg0KICAgKiAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgYHlgIGF4aXMgYXMgYSBWZWMzLg0KICAgKi8NCiAgZ2V0IHlBeGlzKCkgew0KICAgIHJldHVybiBWZWMzJDEuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsIDMgKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICovDQogIHNldCB5QXhpcyh2ZWMzKSB7DQogICAgdGhpcy55QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAqICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBgemAgYXhpcyBhcyBhIFZlYzMuDQogICAqLw0KICBnZXQgekF4aXMoKSB7DQogICAgcmV0dXJuIFZlYzMkMS5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgNiAqIDQpDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLg0KICAgKi8NCiAgc2V0IHpBeGlzKHZlYzMpIHsNCiAgICB0aGlzLnpBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFNldHRlcnMNCg0KICAvKioNCiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDMgY2xhc3MNCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMiAtIFJvdyAwLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMiAtIFJvdyAxLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4NCiAgICovDQogIHNldChtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSBtMDA7DQogICAgdGhpcy5fX2RhdGFbMV0gPSBtMDE7DQogICAgdGhpcy5fX2RhdGFbMl0gPSBtMDI7DQogICAgdGhpcy5fX2RhdGFbM10gPSBtMTA7DQogICAgdGhpcy5fX2RhdGFbNF0gPSBtMTE7DQogICAgdGhpcy5fX2RhdGFbNV0gPSBtMTI7DQogICAgdGhpcy5fX2RhdGFbNl0gPSBtMjA7DQogICAgdGhpcy5fX2RhdGFbN10gPSBtMjE7DQogICAgdGhpcy5fX2RhdGFbOF0gPSBtMjI7DQogIH0NCg0KICAvKioNCiAgICogU2V0cyBzdGF0ZSBvZiB0aGUgTWF0MyB3aXRoIHRoZSBpZGVudGl0eSAgTWF0cml4DQogICAqLw0KICBzZXRJZGVudGl0eSgpIHsNCiAgICB0aGlzLnNldCgpOw0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDMgZnJvbSBhbm90aGVyIE1hdDMNCiAgICogPGJyPg0KICAgKiBOb3RlOiB3b3JrcyB3aXRoIGVpdGhlciBNYXQzIG9yIE1hdDQuDQogICAqDQogICAqIEBwYXJhbSB7TWF0M30gbWF0IC0gVGhlIG1hdCB2YWx1ZS4NCiAgICovDQogIHNldEZyb21NYXQobWF0KSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSBtYXQubTAwOw0KICAgIHRoaXMuX19kYXRhWzFdID0gbWF0Lm0wMTsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IG1hdC5tMDI7DQogICAgdGhpcy5fX2RhdGFbM10gPSBtYXQubTEwOw0KICAgIHRoaXMuX19kYXRhWzRdID0gbWF0Lm0xMTsNCiAgICB0aGlzLl9fZGF0YVs1XSA9IG1hdC5tMTI7DQogICAgdGhpcy5fX2RhdGFbNl0gPSBtYXQubTIwOw0KICAgIHRoaXMuX19kYXRhWzddID0gbWF0Lm0yMTsNCiAgICB0aGlzLl9fZGF0YVs4XSA9IG1hdC5tMjI7DQogIH0NCg0KICAvKioNCiAgICogU2NhbGVzIGFuZCBjYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSBgVmVjM2AgYW5kIHNldHMgdGhlIHJlc3VsdCBpbiB0aGUgTWF0Mw0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IGRpciAtIFRoZSBkaXIgdmFsdWUuDQogICAqIEBwYXJhbSB7VmVjM30gdXAgLSBUaGUgdXAgdmFsdWUuDQogICAqLw0KICBzZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IoZGlyLCB1cCkgew0KICAgIGNvbnN0IHpBeGlzID0gZGlyOw0KICAgIGNvbnN0IHpMZW4gPSB6QXhpcy5sZW5ndGgoKTsNCiAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICB0aGlzLnNldElkZW50aXR5KCk7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgekF4aXMuc2NhbGVJblBsYWNlKDEgLyB6TGVuKTsNCg0KICAgIGNvbnN0IHhBeGlzID0gdXAuY3Jvc3MoekF4aXMpOw0KICAgIGNvbnN0IHhMZW4gPSB4QXhpcy5sZW5ndGgoKTsNCiAgICBpZiAoeExlbiA+IE51bWJlci5FUFNJTE9OKSB4QXhpcy5zY2FsZUluUGxhY2UoMSAvIHhMZW4pOw0KDQogICAgY29uc3QgeUF4aXMgPSB6QXhpcy5jcm9zcyh4QXhpcyk7DQogICAgY29uc3QgeUxlbiA9IHlBeGlzLmxlbmd0aCgpOw0KICAgIGlmICh5TGVuID4gTnVtYmVyLkVQU0lMT04pIHlBeGlzLnNjYWxlSW5QbGFjZSgxIC8geUxlbik7DQoNCiAgICB0aGlzLnNldCh4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56KTsNCiAgfQ0KDQogIC8qKg0KICAgKiBJbnZlcnRzIGEgTWF0MyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtNYXQzfSAtIFJldHVybnMgYSBuZXcgTWF0My4NCiAgICovDQogIGludmVyc2UoKSB7DQogICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgYTAyID0gdGhpcy5fX2RhdGFbMl07DQogICAgY29uc3QgYTEwID0gdGhpcy5fX2RhdGFbM107DQogICAgY29uc3QgYTExID0gdGhpcy5fX2RhdGFbNF07DQogICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNV07DQogICAgY29uc3QgYTIwID0gdGhpcy5fX2RhdGFbNl07DQogICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbN107DQogICAgY29uc3QgYTIyID0gdGhpcy5fX2RhdGFbOF07DQogICAgY29uc3QgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxOw0KICAgIGNvbnN0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7DQogICAgY29uc3QgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOw0KICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQNCiAgICBjb25zdCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7DQoNCiAgICBpZiAoIWRldCkgew0KICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDMnKTsNCiAgICAgIHJldHVybiBudWxsDQogICAgfQ0KICAgIGRldCA9IDEuMCAvIGRldDsNCg0KICAgIHJldHVybiBuZXcgTWF0MygNCiAgICAgIGIwMSAqIGRldCwNCiAgICAgICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldCwNCiAgICAgIChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0LA0KICAgICAgYjExICogZGV0LA0KICAgICAgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQsDQogICAgICAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQsDQogICAgICBiMjEgKiBkZXQsDQogICAgICAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQsDQogICAgICAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldA0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBJbnZlcnRzIGEgTWF0My4NCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaW52ZXJ0SW5QbGFjZSgpIHsNCiAgICBjb25zdCBhMDAgPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCBhMDEgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCBhMTAgPSB0aGlzLl9fZGF0YVszXTsNCiAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs0XTsNCiAgICBjb25zdCBhMTIgPSB0aGlzLl9fZGF0YVs1XTsNCiAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs2XTsNCiAgICBjb25zdCBhMjEgPSB0aGlzLl9fZGF0YVs3XTsNCiAgICBjb25zdCBhMjIgPSB0aGlzLl9fZGF0YVs4XTsNCiAgICBjb25zdCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7DQogICAgY29uc3QgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDsNCiAgICBjb25zdCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7DQogICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudA0KICAgIGNvbnN0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTsNCg0KICAgIGlmICghZGV0KSB7DQogICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBpbnZlcnQgTWF0MycpOw0KICAgICAgcmV0dXJuIGZhbHNlDQogICAgfQ0KICAgIGRldCA9IDEuMCAvIGRldDsNCg0KICAgIHRoaXMuc2V0KA0KICAgICAgYjAxICogZGV0LA0KICAgICAgKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0LA0KICAgICAgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQsDQogICAgICBiMTEgKiBkZXQsDQogICAgICAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldCwNCiAgICAgICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldCwNCiAgICAgIGIyMSAqIGRldCwNCiAgICAgICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldCwNCiAgICAgIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0DQogICAgKTsNCiAgICByZXR1cm4gdHJ1ZQ0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXgNCiAgICogYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBpbnN0YW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm4gYSBuZXcgdHJhbnNwb3NlZCBNYXQzLg0KICAgKi8NCiAgdHJhbnNwb3NlKCkgew0KICAgIHJldHVybiBNYXQzKA0KICAgICAgdGhpcy5fX2RhdGFbMF0sDQogICAgICB0aGlzLl9fZGF0YVszXSwNCiAgICAgIHRoaXMuX19kYXRhWzZdLA0KICAgICAgdGhpcy5fX2RhdGFbMV0sDQogICAgICB0aGlzLl9fZGF0YVs0XSwNCiAgICAgIHRoaXMuX19kYXRhWzddLA0KICAgICAgdGhpcy5fX2RhdGFbMl0sDQogICAgICB0aGlzLl9fZGF0YVs1XSwNCiAgICAgIHRoaXMuX19kYXRhWzhdDQogICAgKQ0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXguDQogICAqLw0KICB0cmFuc3Bvc2VJblBsYWNlKCkgew0KICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXMNCiAgICBjb25zdCBhMDEgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCBhMTIgPSB0aGlzLl9fZGF0YVs1XTsNCg0KICAgIHRoaXMuX19kYXRhWzFdID0gdGhpcy5fX2RhdGFbM107DQogICAgdGhpcy5fX2RhdGFbMl0gPSB0aGlzLl9fZGF0YVs2XTsNCiAgICB0aGlzLl9fZGF0YVszXSA9IGEwMTsNCiAgICB0aGlzLl9fZGF0YVs1XSA9IHRoaXMuX19kYXRhWzddOw0KICAgIHRoaXMuX19kYXRhWzZdID0gYTAyOw0KICAgIHRoaXMuX19kYXRhWzddID0gYTEyOw0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zZm9ybXMgdGhlIFZlYzMgd2l0aCBhIE1hdDMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAqLw0KICB0cmFuc2Zvcm1WZWMzKHZlYzMpIHsNCiAgICByZXR1cm4gbmV3IFZlYzMkMSgNCiAgICAgIHRoaXMuX19kYXRhWzBdICogdmVjMy54ICsgdGhpcy5fX2RhdGFbMV0gKiB2ZWMzLnkgKyB0aGlzLl9fZGF0YVsyXSAqIHZlYzMueiwNCiAgICAgIHRoaXMuX19kYXRhWzNdICogdmVjMy54ICsgdGhpcy5fX2RhdGFbNF0gKiB2ZWMzLnkgKyB0aGlzLl9fZGF0YVs1XSAqIHZlYzMueiwNCiAgICAgIHRoaXMuX19kYXRhWzZdICogdmVjMy54ICsgdGhpcy5fX2RhdGFbN10gKiB2ZWMzLnkgKyB0aGlzLl9fZGF0YVs4XSAqIHZlYzMueg0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBNYXQzIHJldHVybmluZyBhIG5ldyBpbnN0YW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IE1hdDMoDQogICAgICB0aGlzLl9fZGF0YVswXSwNCiAgICAgIHRoaXMuX19kYXRhWzFdLA0KICAgICAgdGhpcy5fX2RhdGFbMl0sDQogICAgICB0aGlzLl9fZGF0YVszXSwNCiAgICAgIHRoaXMuX19kYXRhWzRdLA0KICAgICAgdGhpcy5fX2RhdGFbNV0sDQogICAgICB0aGlzLl9fZGF0YVs2XSwNCiAgICAgIHRoaXMuX19kYXRhWzddLA0KICAgICAgdGhpcy5fX2RhdGFbOF0sDQogICAgICB0aGlzLl9fZGF0YVs5XQ0KICAgICkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlIGEgbmV3IE1hdDMuDQogICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uDQogICAqIEByZXR1cm4ge01hdDN9IC0gUmV0dXJucyBhIG5ldyBNYXQzLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7DQogICAgcmV0dXJuIG5ldyBNYXQzKC4uLmFyZ3MpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBNYXQzIHRvIHdyYXAgZXhpc3RpbmcgbWVtb3J5IGluIGEgYnVmZmVyLg0KICAgKg0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAqIEBkZXByZWNhdGVkDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIoYnVmZmVyLCBvZmZzZXQgPSAwKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpOw0KICAgIHJldHVybiB0aGlzLmNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBvZmZzZXQgKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgTWF0M2AgdXNpbmcgYW4gQXJyYXlCdWZmZXIuDQogICAqDQogICAqIEBzdGF0aWMNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtNYXQzfSAtIFJldHVybnMgYSBuZXcgTWF0My4NCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkgew0KICAgIHJldHVybiBuZXcgTWF0MyhuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgOSkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0DQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgIHRoaXMuX19kYXRhID0gcmVhZGVyLmxvYWRGbG9hdDMyQXJyYXkoOSk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAqDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuDQogICAqLw0KICB0b0pTT04oKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhDQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUganNvbiBwYXJhbS4NCiAgICovDQogIGZyb21KU09OKGpzb24pIHsNCiAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoanNvbik7DQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gRGVidWdnaW5nDQoNCiAgLyoqDQogICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgdG9TdHJpbmcoKSB7DQogICAgcmV0dXJuIHRoaXMudG9KU09OKCkudG9TdHJpbmcoKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdNYXQzJywgTWF0Myk7CgovKioNCiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgNHg0IG1hdHJpeC4NCiAqIFRoaXMgbWF0cml4IGNsYXNzIGlzIGJhc2VkIG9uIEdMTSwgYW5kIGlzIGNvbHVtbiBtYWpvci4NCiAqDQogKiBAZXh0ZW5kcyBBdHRyVmFsdWUNCiAqLw0KY2xhc3MgTWF0NCBleHRlbmRzIEF0dHJWYWx1ZSB7DQogIC8qKg0KICAgKiBJbml0aWFsaXplcyB0aGUgTWF0MyBjbGFzcyB3aXRoIGdpdmVuIGRhdGEuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyIHwgRmxvYXQzMkFycmF5IHwgQXJyYXlCdWZmZXJ9IG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMiAtIFJvdyAwLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMyAtIFJvdyAwLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMiAtIFJvdyAxLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMyAtIFJvdyAxLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMyAtIFJvdyAyLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMCAtIFJvdyAzLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMSAtIFJvdyAzLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMiAtIFJvdyAzLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMyAtIFJvdyAzLCBjb2x1bW4gMy4NCiAgICovDQogIGNvbnN0cnVjdG9yKA0KICAgIG0wMCA9IDEsDQogICAgbTAxID0gMCwNCiAgICBtMDIgPSAwLA0KICAgIG0wMyA9IDAsDQogICAgbTEwID0gMCwNCiAgICBtMTEgPSAxLA0KICAgIG0xMiA9IDAsDQogICAgbTEzID0gMCwNCiAgICBtMjAgPSAwLA0KICAgIG0yMSA9IDAsDQogICAgbTIyID0gMSwNCiAgICBtMjMgPSAwLA0KICAgIG0zMCA9IDAsDQogICAgbTMxID0gMCwNCiAgICBtMzIgPSAwLA0KICAgIG0zMyA9IDENCiAgKSB7DQogICAgc3VwZXIoKTsNCg0KICAgIGlmIChtMDAgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbTAwOw0KICAgIH0gZWxzZSBpZiAobTAwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsNCiAgICAgIGNvbnN0IGJ1ZmZlciA9IG0wMDsNCiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBtMDE7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAxNik7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxNik7DQogICAgICB0aGlzLnNldChtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpOw0KICAgIH0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIHByb3BlcnRpZXMNCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDAuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDAgdmFsdWUuDQogICAqLw0KICBnZXQgbTAwKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVswXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDEgdmFsdWUuDQogICAqLw0KICBnZXQgbTAxKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDEodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDIgdmFsdWUuDQogICAqLw0KICBnZXQgbTAyKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDMuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDMgdmFsdWUuDQogICAqLw0KICBnZXQgbTAzKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVszXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMDModmFsKSB7DQogICAgdGhpcy5fX2RhdGFbM10gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDAuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTAgdmFsdWUuDQogICAqLw0KICBnZXQgbTEwKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs0XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMTAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbNF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDEuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTEgdmFsdWUuDQogICAqLw0KICBnZXQgbTExKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs1XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAxLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMTEodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbNV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTIgdmFsdWUuDQogICAqLw0KICBnZXQgbTEyKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs2XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMTIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbNl0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDMuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTMgdmFsdWUuDQogICAqLw0KICBnZXQgbTEzKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs3XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMTModmFsKSB7DQogICAgdGhpcy5fX2RhdGFbN10gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDAuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMjAgdmFsdWUuDQogICAqLw0KICBnZXQgbTIwKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs4XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMjAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbOF0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDEuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMjEgdmFsdWUuDQogICAqLw0KICBnZXQgbTIxKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVs5XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAxDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0yMSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVs5XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMiB2YWx1ZS4NCiAgICovDQogIGdldCBtMjIoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzEwXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAyLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMjIodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMTBdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3Igcm93IDIsIGNvbHVtbiAzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTIzIHZhbHVlLg0KICAgKi8NCiAgZ2V0IG0yMygpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTFdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDMuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0yMyh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsxMV0gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMywgY29sdW1uIDANCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0zMCB2YWx1ZS4NCiAgICovDQogIGdldCBtMzAoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzEyXQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDMsIGNvbHVtbiAwLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMzAodmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMTJdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3Igcm93IDMsIGNvbHVtbiAxLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTMxIHZhbHVlLg0KICAgKi8NCiAgZ2V0IG0zMSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTNdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciByb3cgMywgY29sdW1uIDEuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLg0KICAgKi8NCiAgc2V0IG0zMSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsxM10gPSB2YWw7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciByb3cgMywgY29sdW1uIDIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMzIgdmFsdWUuDQogICAqLw0KICBnZXQgbTMyKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVsxNF0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgbTMyKHZhbCkgew0KICAgIHRoaXMuX19kYXRhWzE0XSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMy4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0zMyB2YWx1ZS4NCiAgICovDQogIGdldCBtMzMoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzE1XQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3Igcm93IDMsIGNvbHVtbiAzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICovDQogIHNldCBtMzModmFsKSB7DQogICAgdGhpcy5fX2RhdGFbMTVdID0gdmFsOw0KICB9DQoNCiAgLyoqDQogICAqIEdldHRlciBmb3IgdGhlIGB4YCBheGlzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGB4YCBheGlzIGFzIGEgVmVjMy4NCiAgICovDQogIGdldCB4QXhpcygpIHsNCiAgICByZXR1cm4gVmVjMyQxLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCAwKQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgdGhlIGB4YCBheGlzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICovDQogIHNldCB4QXhpcyh2ZWMzKSB7DQogICAgdGhpcy54QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB0aGUgYHlgIGF4aXMuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgYHlgIGF4aXMgYXMgYSBWZWMzLg0KICAgKi8NCiAgZ2V0IHlBeGlzKCkgew0KICAgIHJldHVybiBWZWMzJDEuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsIDQgKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICovDQogIHNldCB5QXhpcyh2ZWMzKSB7DQogICAgdGhpcy55QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgYHpgIGF4aXMgYXMgYSBWZWMzLg0KICAgKi8NCiAgZ2V0IHpBeGlzKCkgew0KICAgIHJldHVybiBWZWMzJDEuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsIDggKiA0KQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmb3IgdGhlIGB6YCBheGlzLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICovDQogIHNldCB6QXhpcyh2ZWMzKSB7DQogICAgdGhpcy56QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIG1hdHJpeC4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbi4NCiAgICovDQogIGdldCB0cmFuc2xhdGlvbigpIHsNCiAgICByZXR1cm4gVmVjMyQxLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCAxMiAqIDQpDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIG1hdHJpeC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHRyYW5zbGF0aW9uLg0KICAgKi8NCiAgc2V0IHRyYW5zbGF0aW9uKHZlYzMpIHsNCiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFNldHRlcnMNCg0KICAvKioNCiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3MNCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMiAtIFJvdyAwLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMyAtIFJvdyAwLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMiAtIFJvdyAxLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMyAtIFJvdyAxLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMyAtIFJvdyAyLCBjb2x1bW4gMy4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMCAtIFJvdyAzLCBjb2x1bW4gMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMSAtIFJvdyAzLCBjb2x1bW4gMS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMiAtIFJvdyAzLCBjb2x1bW4gMi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMyAtIFJvdyAzLCBjb2x1bW4gMy4NCiAgICovDQogIHNldCgNCiAgICBtMDAgPSAxLA0KICAgIG0wMSA9IDAsDQogICAgbTAyID0gMCwNCiAgICBtMDMgPSAwLA0KICAgIG0xMCA9IDAsDQogICAgbTExID0gMSwNCiAgICBtMTIgPSAwLA0KICAgIG0xMyA9IDAsDQogICAgbTIwID0gMCwNCiAgICBtMjEgPSAwLA0KICAgIG0yMiA9IDEsDQogICAgbTIzID0gMCwNCiAgICBtMzAgPSAwLA0KICAgIG0zMSA9IDAsDQogICAgbTMyID0gMCwNCiAgICBtMzMgPSAxDQogICkgew0KICAgIHRoaXMuX19kYXRhWzBdID0gbTAwOw0KICAgIHRoaXMuX19kYXRhWzFdID0gbTAxOw0KICAgIHRoaXMuX19kYXRhWzJdID0gbTAyOw0KICAgIHRoaXMuX19kYXRhWzNdID0gbTAzOw0KICAgIHRoaXMuX19kYXRhWzRdID0gbTEwOw0KICAgIHRoaXMuX19kYXRhWzVdID0gbTExOw0KICAgIHRoaXMuX19kYXRhWzZdID0gbTEyOw0KICAgIHRoaXMuX19kYXRhWzddID0gbTEzOw0KICAgIHRoaXMuX19kYXRhWzhdID0gbTIwOw0KICAgIHRoaXMuX19kYXRhWzldID0gbTIxOw0KICAgIHRoaXMuX19kYXRhWzEwXSA9IG0yMjsNCiAgICB0aGlzLl9fZGF0YVsxMV0gPSBtMjM7DQogICAgdGhpcy5fX2RhdGFbMTJdID0gbTMwOw0KICAgIHRoaXMuX19kYXRhWzEzXSA9IG0zMTsNCiAgICB0aGlzLl9fZGF0YVsxNF0gPSBtMzI7DQogICAgdGhpcy5fX2RhdGFbMTVdID0gbTMzOw0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeA0KICAgKi8NCiAgc2V0SWRlbnRpdHkoKSB7DQogICAgdGhpcy5zZXQoKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgTWF0NCBPYmplY3QuDQogICAqDQogICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyQXJyYXkgLSBUaGUgZmxvYXQzMkFycmF5IHZhbHVlLg0KICAgKi8NCiAgc2V0RGF0YUFycmF5KGZsb2F0MzJBcnJheSkgew0KICAgIHRoaXMuX19kYXRhID0gZmxvYXQzMkFycmF5Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgZnJvbSBhbm90aGVyIE1hdDQNCiAgICogPGJyPg0KICAgKiBOb3RlOiB3b3JrcyB3aXRoIGVpdGhlciBNYXQzIG9yIE1hdDQuDQogICAqDQogICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLg0KICAgKi8NCiAgc2V0RnJvbU1hdDQobWF0NCkgew0KICAgIHRoaXMuX19kYXRhWzBdID0gbWF0NC5tMDA7DQogICAgdGhpcy5fX2RhdGFbMV0gPSBtYXQ0Lm0wMTsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IG1hdDQubTAyOw0KICAgIHRoaXMuX19kYXRhWzNdID0gbWF0NC5tMDM7DQogICAgdGhpcy5fX2RhdGFbNF0gPSBtYXQ0Lm0xMDsNCiAgICB0aGlzLl9fZGF0YVs1XSA9IG1hdDQubTExOw0KICAgIHRoaXMuX19kYXRhWzZdID0gbWF0NC5tMTI7DQogICAgdGhpcy5fX2RhdGFbN10gPSBtYXQ0Lm0xMzsNCiAgICB0aGlzLl9fZGF0YVs4XSA9IG1hdDQubTIwOw0KICAgIHRoaXMuX19kYXRhWzldID0gbWF0NC5tMjE7DQogICAgdGhpcy5fX2RhdGFbMTBdID0gbWF0NC5tMjI7DQogICAgdGhpcy5fX2RhdGFbMTFdID0gbWF0NC5tMjM7DQogICAgdGhpcy5fX2RhdGFbMTJdID0gbWF0NC5tMzA7DQogICAgdGhpcy5fX2RhdGFbMTNdID0gbWF0NC5tMzE7DQogICAgdGhpcy5fX2RhdGFbMTRdID0gbWF0NC5tMzI7DQogICAgdGhpcy5fX2RhdGFbMTVdID0gbWF0NC5tMzM7DQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgYSBNYXQ0IHRvIGEgTWF0My4NCiAgICoNCiAgICogQHBhcmFtIHtNYXQ0fSBtYXQ0IC0gVGhlIE1hdDQgdmFsdWUgdG8gY29udmVydC4NCiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAqLw0KICB0b01hdDMobWF0NCkgew0KICAgIHJldHVybiBuZXcgTWF0MygNCiAgICAgIHRoaXMuX19kYXRhWzBdLA0KICAgICAgdGhpcy5fX2RhdGFbMV0sDQogICAgICB0aGlzLl9fZGF0YVsyXSwNCiAgICAgIHRoaXMuX19kYXRhWzRdLA0KICAgICAgdGhpcy5fX2RhdGFbNV0sDQogICAgICB0aGlzLl9fZGF0YVs2XSwNCiAgICAgIHRoaXMuX19kYXRhWzhdLA0KICAgICAgdGhpcy5fX2RhdGFbOV0sDQogICAgICB0aGlzLl9fZGF0YVsxMF0NCiAgICApDQogIH0NCg0KICAvKioNCiAgICogVHJhbnNwb3NlcyAoZXhjaGFuZ2VzIGNvbHVtbnMgd2l0aCByb3dzKSB0aGlzIG1hdHJpeC4NCiAgICovDQogIHRyYW5zcG9zZUluUGxhY2UoKSB7DQogICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlcw0KICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IGEwMyA9IHRoaXMuX19kYXRhWzNdOw0KICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzZdOw0KICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOw0KICAgIGNvbnN0IGEyMyA9IHRoaXMuX19kYXRhWzExXTsNCg0KICAgIHRoaXMuX19kYXRhWzFdID0gdGhpcy5fX2RhdGFbNF07DQogICAgdGhpcy5fX2RhdGFbMl0gPSB0aGlzLl9fZGF0YVs4XTsNCiAgICB0aGlzLl9fZGF0YVszXSA9IHRoaXMuX19kYXRhWzEyXTsNCiAgICB0aGlzLl9fZGF0YVs0XSA9IGEwMTsNCiAgICB0aGlzLl9fZGF0YVs2XSA9IHRoaXMuX19kYXRhWzldOw0KICAgIHRoaXMuX19kYXRhWzddID0gdGhpcy5fX2RhdGFbMTNdOw0KICAgIHRoaXMuX19kYXRhWzhdID0gYTAyOw0KICAgIHRoaXMuX19kYXRhWzldID0gYTEyOw0KICAgIHRoaXMuX19kYXRhWzExXSA9IHRoaXMuX19kYXRhWzE0XTsNCiAgICB0aGlzLl9fZGF0YVsxMl0gPSBhMDM7DQogICAgdGhpcy5fX2RhdGFbMTNdID0gYTEzOw0KICAgIHRoaXMuX19kYXRhWzE0XSA9IGEyMzsNCiAgfQ0KDQogIC8qKg0KICAgKiBUcmFuc3Bvc2VzIChleGNoYW5nZXMgY29sdW1ucyB3aXRoIHJvd3MpIHRoaXMgbWF0cml4DQogICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuDQogICAqDQogICAqIEByZXR1cm4ge01hdDR9IC0gUmV0dXJuIGEgbmV3IHRyYW5zcG9zZWQgTWF0NC4NCiAgICovDQogIHRyYW5zcG9zZSgpIHsNCiAgICByZXR1cm4gbmV3IE1hdDQoDQogICAgICB0aGlzLl9fZGF0YVswXSwNCiAgICAgIHRoaXMuX19kYXRhWzRdLA0KICAgICAgdGhpcy5fX2RhdGFbOF0sDQogICAgICB0aGlzLl9fZGF0YVsxMl0sDQogICAgICB0aGlzLl9fZGF0YVsxXSwNCiAgICAgIHRoaXMuX19kYXRhWzVdLA0KICAgICAgdGhpcy5fX2RhdGFbOV0sDQogICAgICB0aGlzLl9fZGF0YVsxM10sDQogICAgICB0aGlzLl9fZGF0YVsyXSwNCiAgICAgIHRoaXMuX19kYXRhWzZdLA0KICAgICAgdGhpcy5fX2RhdGFbMTBdLA0KICAgICAgdGhpcy5fX2RhdGFbMTRdLA0KICAgICAgdGhpcy5fX2RhdGFbM10sDQogICAgICB0aGlzLl9fZGF0YVs3XSwNCiAgICAgIHRoaXMuX19kYXRhWzExXSwNCiAgICAgIHRoaXMuX19kYXRhWzE1XQ0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBJbnZlcnRzIGEgTWF0NCBub3QgdXNpbmcgU0lNRCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICovDQogIGludmVyc2UoKSB7DQogICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgYTAyID0gdGhpcy5fX2RhdGFbMl07DQogICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM107DQogICAgY29uc3QgYTEwID0gdGhpcy5fX2RhdGFbNF07DQogICAgY29uc3QgYTExID0gdGhpcy5fX2RhdGFbNV07DQogICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl07DQogICAgY29uc3QgYTEzID0gdGhpcy5fX2RhdGFbN107DQogICAgY29uc3QgYTIwID0gdGhpcy5fX2RhdGFbOF07DQogICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbOV07DQogICAgY29uc3QgYTIyID0gdGhpcy5fX2RhdGFbMTBdOw0KICAgIGNvbnN0IGEyMyA9IHRoaXMuX19kYXRhWzExXTsNCiAgICBjb25zdCBhMzAgPSB0aGlzLl9fZGF0YVsxMl07DQogICAgY29uc3QgYTMxID0gdGhpcy5fX2RhdGFbMTNdOw0KICAgIGNvbnN0IGEzMiA9IHRoaXMuX19kYXRhWzE0XTsNCiAgICBjb25zdCBhMzMgPSB0aGlzLl9fZGF0YVsxNV07DQoNCiAgICBjb25zdCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7DQogICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwOw0KICAgIGNvbnN0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDsNCiAgICBjb25zdCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7DQogICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExOw0KICAgIGNvbnN0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjsNCiAgICBjb25zdCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7DQogICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwOw0KICAgIGNvbnN0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDsNCiAgICBjb25zdCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7DQogICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxOw0KICAgIGNvbnN0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsNCg0KICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQNCiAgICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2Ow0KDQogICAgaWYgKCFkZXQpIHsNCiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7DQogICAgICByZXR1cm4gbnVsbA0KICAgIH0NCiAgICBkZXQgPSAxLjAgLyBkZXQ7DQoNCiAgICByZXR1cm4gbmV3IE1hdDQoDQogICAgICAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwNCiAgICAgIChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0LA0KICAgICAgKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQsDQogICAgICAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwNCiAgICAgIChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0LA0KICAgICAgKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQsDQogICAgICAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwNCiAgICAgIChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0LA0KICAgICAgKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQsDQogICAgICAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwNCiAgICAgIChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0LA0KICAgICAgKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQsDQogICAgICAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwNCiAgICAgIChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0LA0KICAgICAgKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQsDQogICAgICAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldA0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBJbnZlcnRzIGEgTWF0NC4NCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaW52ZXJ0SW5QbGFjZSgpIHsNCiAgICBjb25zdCBhMDAgPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCBhMDEgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCBhMDMgPSB0aGlzLl9fZGF0YVszXTsNCiAgICBjb25zdCBhMTAgPSB0aGlzLl9fZGF0YVs0XTsNCiAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs1XTsNCiAgICBjb25zdCBhMTIgPSB0aGlzLl9fZGF0YVs2XTsNCiAgICBjb25zdCBhMTMgPSB0aGlzLl9fZGF0YVs3XTsNCiAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs4XTsNCiAgICBjb25zdCBhMjEgPSB0aGlzLl9fZGF0YVs5XTsNCiAgICBjb25zdCBhMjIgPSB0aGlzLl9fZGF0YVsxMF07DQogICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdOw0KICAgIGNvbnN0IGEzMCA9IHRoaXMuX19kYXRhWzEyXTsNCiAgICBjb25zdCBhMzEgPSB0aGlzLl9fZGF0YVsxM107DQogICAgY29uc3QgYTMyID0gdGhpcy5fX2RhdGFbMTRdOw0KICAgIGNvbnN0IGEzMyA9IHRoaXMuX19kYXRhWzE1XTsNCg0KICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsNCiAgICBjb25zdCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7DQogICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwOw0KICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsNCiAgICBjb25zdCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7DQogICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyOw0KICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsNCiAgICBjb25zdCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7DQogICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwOw0KICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsNCiAgICBjb25zdCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7DQogICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOw0KDQogICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudA0KICAgIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7DQoNCiAgICBpZiAoIWRldCkgew0KICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDQnKTsNCiAgICAgIHJldHVybiBmYWxzZQ0KICAgIH0NCiAgICBkZXQgPSAxLjAgLyBkZXQ7DQoNCiAgICB0aGlzLnNldCgNCiAgICAgIChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0LA0KICAgICAgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsDQogICAgICAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldCwNCiAgICAgIChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0LA0KICAgICAgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsDQogICAgICAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldCwNCiAgICAgIChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0LA0KICAgICAgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsDQogICAgICAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldCwNCiAgICAgIChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0LA0KICAgICAgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsDQogICAgICAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldCwNCiAgICAgIChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0LA0KICAgICAgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsDQogICAgICAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldCwNCiAgICAgIChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0DQogICAgKTsNCiAgICByZXR1cm4gdHJ1ZQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhpcyBtYXRyaXggYXMgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIE1hdDQuDQogICAqDQogICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtudWxsfSAtIEluIGNhc2UgdGhlIGBkZXRlcm1pbmFudGAgY2FuJ3QgYmUgY2FsY3VsYXRlZCwgYSBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlLCBub3RoaW5nIGlzIHJldHVybmVkDQogICAqLw0KICBzZXRJbnZlcnNlKG1hdDQpIHsNCiAgICBjb25zdCBhMDAgPSBtYXQ0Ll9fZGF0YVswXTsNCiAgICBjb25zdCBhMDEgPSBtYXQ0Ll9fZGF0YVsxXTsNCiAgICBjb25zdCBhMDIgPSBtYXQ0Ll9fZGF0YVsyXTsNCiAgICBjb25zdCBhMDMgPSBtYXQ0Ll9fZGF0YVszXTsNCiAgICBjb25zdCBhMTAgPSBtYXQ0Ll9fZGF0YVs0XTsNCiAgICBjb25zdCBhMTEgPSBtYXQ0Ll9fZGF0YVs1XTsNCiAgICBjb25zdCBhMTIgPSBtYXQ0Ll9fZGF0YVs2XTsNCiAgICBjb25zdCBhMTMgPSBtYXQ0Ll9fZGF0YVs3XTsNCiAgICBjb25zdCBhMjAgPSBtYXQ0Ll9fZGF0YVs4XTsNCiAgICBjb25zdCBhMjEgPSBtYXQ0Ll9fZGF0YVs5XTsNCiAgICBjb25zdCBhMjIgPSBtYXQ0Ll9fZGF0YVsxMF07DQogICAgY29uc3QgYTIzID0gbWF0NC5fX2RhdGFbMTFdOw0KICAgIGNvbnN0IGEzMCA9IG1hdDQuX19kYXRhWzEyXTsNCiAgICBjb25zdCBhMzEgPSBtYXQ0Ll9fZGF0YVsxM107DQogICAgY29uc3QgYTMyID0gbWF0NC5fX2RhdGFbMTRdOw0KICAgIGNvbnN0IGEzMyA9IG1hdDQuX19kYXRhWzE1XTsNCg0KICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsNCiAgICBjb25zdCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7DQogICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwOw0KICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsNCiAgICBjb25zdCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7DQogICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyOw0KICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsNCiAgICBjb25zdCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7DQogICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwOw0KICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsNCiAgICBjb25zdCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7DQogICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOw0KDQogICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudA0KICAgIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7DQoNCiAgICBpZiAoIWRldCkgew0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDQnKQ0KICAgIH0NCiAgICBkZXQgPSAxLjAgLyBkZXQ7DQoNCiAgICB0aGlzLnNldCgNCiAgICAgIChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0LA0KICAgICAgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsDQogICAgICAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldCwNCiAgICAgIChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0LA0KICAgICAgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsDQogICAgICAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldCwNCiAgICAgIChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0LA0KICAgICAgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsDQogICAgICAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldCwNCiAgICAgIChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0LA0KICAgICAgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsDQogICAgICAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldCwNCiAgICAgIChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0LA0KICAgICAgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsDQogICAgICAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldCwNCiAgICAgIChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0DQogICAgKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIHR3byBNYXQ0cyBub3QgdXNpbmcgU0lNRCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLg0KICAgKg0KICAgKiBAcGFyYW0ge01hdDR9IG90aGVyIC0gVGhlIG90aGVyIE1hdDQgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICBtdWx0aXBseShvdGhlcikgew0KICAgIGNvbnN0IGEwMCA9IHRoaXMuX19kYXRhWzBdOw0KICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IGEwMyA9IHRoaXMuX19kYXRhWzNdOw0KICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzRdOw0KICAgIGNvbnN0IGExMSA9IHRoaXMuX19kYXRhWzVdOw0KICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzZdOw0KICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOw0KICAgIGNvbnN0IGEyMCA9IHRoaXMuX19kYXRhWzhdOw0KICAgIGNvbnN0IGEyMSA9IHRoaXMuX19kYXRhWzldOw0KICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzEwXTsNCiAgICBjb25zdCBhMjMgPSB0aGlzLl9fZGF0YVsxMV07DQogICAgY29uc3QgYTMwID0gdGhpcy5fX2RhdGFbMTJdOw0KICAgIGNvbnN0IGEzMSA9IHRoaXMuX19kYXRhWzEzXTsNCiAgICBjb25zdCBhMzIgPSB0aGlzLl9fZGF0YVsxNF07DQogICAgY29uc3QgYTMzID0gdGhpcy5fX2RhdGFbMTVdOw0KDQogICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4DQogICAgY29uc3QgYiA9IG90aGVyLmFzQXJyYXkoKTsNCiAgICBsZXQgYjAgPSBiWzBdOw0KICAgIGxldCBiMSA9IGJbMV07DQogICAgbGV0IGIyID0gYlsyXTsNCiAgICBsZXQgYjMgPSBiWzNdOw0KICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXQ0KCk7DQogICAgcmVzdWx0Lm0wMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHJlc3VsdC5tMDEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICByZXN1bHQubTAyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7DQogICAgcmVzdWx0Lm0wMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KDQogICAgYjAgPSBiWzRdOw0KICAgIGIxID0gYls1XTsNCiAgICBiMiA9IGJbNl07DQogICAgYjMgPSBiWzddOw0KICAgIHJlc3VsdC5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICByZXN1bHQubTExID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgcmVzdWx0Lm0xMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgIHJlc3VsdC5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCg0KICAgIGIwID0gYls4XTsNCiAgICBiMSA9IGJbOV07DQogICAgYjIgPSBiWzEwXTsNCiAgICBiMyA9IGJbMTFdOw0KICAgIHJlc3VsdC5tMjAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICByZXN1bHQubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgcmVzdWx0Lm0yMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgIHJlc3VsdC5tMjMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCg0KICAgIGIwID0gYlsxMl07DQogICAgYjEgPSBiWzEzXTsNCiAgICBiMiA9IGJbMTRdOw0KICAgIGIzID0gYlsxNV07DQogICAgcmVzdWx0Lm0zMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHJlc3VsdC5tMzEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICByZXN1bHQubTMyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7DQogICAgcmVzdWx0Lm0zMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIHR3byBNYXQ0cyBpbiBwbGFjZSBleHBsaWNpdGx5IG5vdCB1c2luZyBTSU1ELg0KICAgKg0KICAgKiBAcGFyYW0ge01hdDR9IG90aGVyIC0gVGhlIG90aGVyIE1hdDQgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICBjb25zdCBhID0gdGhpcy5hc0FycmF5KCk7DQogICAgY29uc3QgYTAwID0gYVswXTsNCiAgICBjb25zdCBhMDEgPSBhWzFdOw0KICAgIGNvbnN0IGEwMiA9IGFbMl07DQogICAgY29uc3QgYTAzID0gYVszXTsNCiAgICBjb25zdCBhMTAgPSBhWzRdOw0KICAgIGNvbnN0IGExMSA9IGFbNV07DQogICAgY29uc3QgYTEyID0gYVs2XTsNCiAgICBjb25zdCBhMTMgPSBhWzddOw0KICAgIGNvbnN0IGEyMCA9IGFbOF07DQogICAgY29uc3QgYTIxID0gYVs5XTsNCiAgICBjb25zdCBhMjIgPSBhWzEwXTsNCiAgICBjb25zdCBhMjMgPSBhWzExXTsNCiAgICBjb25zdCBhMzAgPSBhWzEyXTsNCiAgICBjb25zdCBhMzEgPSBhWzEzXTsNCiAgICBjb25zdCBhMzIgPSBhWzE0XTsNCiAgICBjb25zdCBhMzMgPSBhWzE1XTsNCg0KICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeA0KICAgIGNvbnN0IGIgPSBvdGhlci5hc0FycmF5KCk7DQogICAgbGV0IGIwID0gYlswXTsNCiAgICBsZXQgYjEgPSBiWzFdOw0KICAgIGxldCBiMiA9IGJbMl07DQogICAgbGV0IGIzID0gYlszXTsNCiAgICB0aGlzLm0wMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMDIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0wMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KDQogICAgYjAgPSBiWzRdOw0KICAgIGIxID0gYls1XTsNCiAgICBiMiA9IGJbNl07DQogICAgYjMgPSBiWzddOw0KICAgIHRoaXMubTEwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgdGhpcy5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICB0aGlzLm0xMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgIHRoaXMubTEzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQoNCiAgICBiMCA9IGJbOF07DQogICAgYjEgPSBiWzldOw0KICAgIGIyID0gYlsxMF07DQogICAgYjMgPSBiWzExXTsNCiAgICB0aGlzLm0yMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMjIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0yMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KDQogICAgYjAgPSBiWzEyXTsNCiAgICBiMSA9IGJbMTNdOw0KICAgIGIyID0gYlsxNF07DQogICAgYjMgPSBiWzE1XTsNCiAgICB0aGlzLm0zMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMzIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0zMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogUG9zdCBtdWx0aXBsaWVzIHR3byBNYXQ0cyBpbiBwbGFjZSBleHBsaWNpdGx5IG5vdCB1c2luZyBTSU1ELg0KICAgKg0KICAgKiBAcGFyYW0ge01hdDR9IG90aGVyIC0gVGhlIG90aGVyIE1hdDQgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgTWF0NC4NCiAgICovDQogIHBvc3RtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICBjb25zdCBhID0gb3RoZXIuYXNBcnJheSgpOw0KICAgIGNvbnN0IGEwMCA9IGFbMF07DQogICAgY29uc3QgYTAxID0gYVsxXTsNCiAgICBjb25zdCBhMDIgPSBhWzJdOw0KICAgIGNvbnN0IGEwMyA9IGFbM107DQogICAgY29uc3QgYTEwID0gYVs0XTsNCiAgICBjb25zdCBhMTEgPSBhWzVdOw0KICAgIGNvbnN0IGExMiA9IGFbNl07DQogICAgY29uc3QgYTEzID0gYVs3XTsNCiAgICBjb25zdCBhMjAgPSBhWzhdOw0KICAgIGNvbnN0IGEyMSA9IGFbOV07DQogICAgY29uc3QgYTIyID0gYVsxMF07DQogICAgY29uc3QgYTIzID0gYVsxMV07DQogICAgY29uc3QgYTMwID0gYVsxMl07DQogICAgY29uc3QgYTMxID0gYVsxM107DQogICAgY29uc3QgYTMyID0gYVsxNF07DQogICAgY29uc3QgYTMzID0gYVsxNV07DQoNCiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXgNCiAgICBjb25zdCBiID0gdGhpcy5hc0FycmF5KCk7DQogICAgbGV0IGIwID0gYlswXTsNCiAgICBsZXQgYjEgPSBiWzFdOw0KICAgIGxldCBiMiA9IGJbMl07DQogICAgbGV0IGIzID0gYlszXTsNCiAgICB0aGlzLm0wMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMDIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0wMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KDQogICAgYjAgPSBiWzRdOw0KICAgIGIxID0gYls1XTsNCiAgICBiMiA9IGJbNl07DQogICAgYjMgPSBiWzddOw0KICAgIHRoaXMubTEwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgdGhpcy5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICB0aGlzLm0xMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgIHRoaXMubTEzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQoNCiAgICBiMCA9IGJbOF07DQogICAgYjEgPSBiWzldOw0KICAgIGIyID0gYlsxMF07DQogICAgYjMgPSBiWzExXTsNCiAgICB0aGlzLm0yMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMjIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0yMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KDQogICAgYjAgPSBiWzEyXTsNCiAgICBiMSA9IGJbMTNdOw0KICAgIGIyID0gYlsxNF07DQogICAgYjMgPSBiWzE1XTsNCiAgICB0aGlzLm0zMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgdGhpcy5tMzIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICB0aGlzLm0zMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogVHJhbnNsYXRlIGEgTWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIG5vdCB1c2luZyBTSU1ELg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHYzIC0gVGhlIGdpdmVuIHZlY3RvciB0byB0cmFuc2xhdGUgYWxvbmcuDQogICAqIEByZXR1cm4ge01hdDR9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRyYW5zbGF0ZUluUGxhY2UodjMpIHsNCiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7DQogICAgY29uc3QgeCA9IHYzLng7DQogICAgY29uc3QgeSA9IHYzLnk7DQogICAgY29uc3QgeiA9IHYzLno7DQogICAgYVsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTsNCiAgICBhWzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdOw0KICAgIGFbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdOw0KICAgIGFbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdOw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBwb3MgLSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyLg0KICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCAtIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdC4NCiAgICogQHBhcmFtIHtWZWMzfSB1cCAtIFZlYzMgcG9pbnRpbmcgdXAuDQogICAqLw0KICBzZXRMb29rQXQocG9zLCB0YXJnZXQsIHVwKSB7DQogICAgY29uc3QgekF4aXMgPSBwb3Muc3VidHJhY3QodGFyZ2V0KTsNCiAgICBjb25zdCB6TGVuID0gekF4aXMubGVuZ3RoKCk7DQogICAgaWYgKHpMZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgdGhpcy5zZXRJZGVudGl0eSgpOw0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB6TGVuKTsNCg0KICAgIGNvbnN0IHhBeGlzID0gdXAuY3Jvc3MoekF4aXMpOw0KICAgIGNvbnN0IHhMZW4gPSB4QXhpcy5sZW5ndGgoKTsNCiAgICBpZiAoeExlbiA+IE51bWJlci5FUFNJTE9OKSB4QXhpcy5zY2FsZUluUGxhY2UoMS4wIC8geExlbik7DQoNCiAgICBjb25zdCB5QXhpcyA9IHpBeGlzLmNyb3NzKHhBeGlzKTsNCiAgICBjb25zdCB5TGVuID0geUF4aXMubGVuZ3RoKCk7DQogICAgaWYgKHlMZW4gPiBOdW1iZXIuRVBTSUxPTikgeUF4aXMuc2NhbGVJblBsYWNlKDEuMCAvIHlMZW4pOw0KDQogICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgIHRoaXMuc2V0KA0KICAgICAgeEF4aXMueCwNCiAgICAgIHhBeGlzLnksDQogICAgICB4QXhpcy56LA0KICAgICAgMCwNCiAgICAgIHlBeGlzLngsDQogICAgICB5QXhpcy55LA0KICAgICAgeUF4aXMueiwNCiAgICAgIDAsDQogICAgICB6QXhpcy54LA0KICAgICAgekF4aXMueSwNCiAgICAgIHpBeGlzLnosDQogICAgICAwLA0KICAgICAgcG9zLngsDQogICAgICBwb3MueSwNCiAgICAgIHBvcy56LA0KICAgICAgMQ0KICAgICk7DQogICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpcy4NCiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6DQogICAqDQogICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpOw0KICAgKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTsNCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBheGlzIC0gVGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS4NCiAgICogQHJldHVybiB7TWF0NH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgc2V0Um90YXRpb24oYXhpcywgcmFkKSB7DQogICAgY29uc3QgbGVuID0gYXhpcy5sZW5ndGgoKTsNCg0KICAgIGlmIChNYXRoLmFicyhsZW4pIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgIHJldHVybiBudWxsDQogICAgfQ0KDQogICAgY29uc3QgeCA9IGF4aXMueCAvIGxlbjsNCiAgICBjb25zdCB5ID0gYXhpcy55IC8gbGVuOw0KICAgIGNvbnN0IHogPSBheGlzLnogLyBsZW47DQoNCiAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTsNCiAgICBjb25zdCBjID0gTWF0aC5jb3MocmFkKTsNCiAgICBjb25zdCB0ID0gMSAtIGM7DQoNCiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvbg0KICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YTsNCiAgICBhWzBdID0geCAqIHggKiB0ICsgYzsNCiAgICBhWzFdID0geSAqIHggKiB0ICsgeiAqIHM7DQogICAgYVsyXSA9IHogKiB4ICogdCAtIHkgKiBzOw0KICAgIGFbM10gPSAwOw0KICAgIGFbNF0gPSB4ICogeSAqIHQgLSB6ICogczsNCiAgICBhWzVdID0geSAqIHkgKiB0ICsgYzsNCiAgICBhWzZdID0geiAqIHkgKiB0ICsgeCAqIHM7DQogICAgYVs3XSA9IDA7DQogICAgYVs4XSA9IHggKiB6ICogdCArIHkgKiBzOw0KICAgIGFbOV0gPSB5ICogeiAqIHQgLSB4ICogczsNCiAgICBhWzEwXSA9IHogKiB6ICogdCArIGM7DQogICAgYVsxMV0gPSAwOw0KICAgIGFbMTJdID0gMDsNCiAgICBhWzEzXSA9IDA7DQogICAgYVsxNF0gPSAwOw0KICAgIGFbMTVdID0gMTsNCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMuDQogICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOg0KICAgKg0KICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTsNCiAgICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpOw0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5Lg0KICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBzZXRYUm90YXRpb24ocmFkKSB7DQogICAgY29uc3QgcyA9IE1hdGguc2luKHJhZCk7DQogICAgY29uc3QgYyA9IE1hdGguY29zKHJhZCk7DQoNCiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uDQogICAgY29uc3QgYSA9IHRoaXMuX19kYXRhOw0KICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICBhWzBdID0gMTsNCiAgICBhWzFdID0gMDsNCiAgICBhWzJdID0gMDsNCiAgICBhWzNdID0gMDsNCiAgICBhWzRdID0gMDsNCiAgICBhWzVdID0gYzsNCiAgICBhWzZdID0gczsNCiAgICBhWzddID0gMDsNCiAgICBhWzhdID0gMDsNCiAgICBhWzldID0gLXM7DQogICAgYVsxMF0gPSBjOw0KICAgIGFbMTFdID0gMDsNCiAgICBhWzEyXSA9IDA7DQogICAgYVsxM10gPSAwOw0KICAgIGFbMTRdID0gMDsNCiAgICBhWzE1XSA9IDE7DQogICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgcmV0dXJuIHRoaXMNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLg0KICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKToNCiAgICoNCiAgICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7DQogICAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTsNCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS4NCiAgICogQHJldHVybiB7TWF0NH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgc2V0WVJvdGF0aW9uKHJhZCkgew0KICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyYWQpOw0KICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyYWQpOw0KDQogICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvbg0KICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YTsNCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgYVswXSA9IGM7DQogICAgYVsxXSA9IDA7DQogICAgYVsyXSA9IC1zOw0KICAgIGFbM10gPSAwOw0KICAgIGFbNF0gPSAwOw0KICAgIGFbNV0gPSAxOw0KICAgIGFbNl0gPSAwOw0KICAgIGFbN10gPSAwOw0KICAgIGFbOF0gPSBzOw0KICAgIGFbOV0gPSAwOw0KICAgIGFbMTBdID0gYzsNCiAgICBhWzExXSA9IDA7DQogICAgYVsxMl0gPSAwOw0KICAgIGFbMTNdID0gMDsNCiAgICBhWzE0XSA9IDA7DQogICAgYVsxNV0gPSAxOw0KICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgIHJldHVybiB0aGlzDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcy4NCiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6DQogICAqDQogICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpOw0KICAgKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7DQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgLSBUaGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnkuDQogICAqIEByZXR1cm4ge01hdDR9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHNldFpSb3RhdGlvbihyYWQpIHsNCiAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTsNCiAgICBjb25zdCBjID0gTWF0aC5jb3MocmFkKTsNCg0KICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb24NCiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7DQogICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgIGFbMF0gPSBjOw0KICAgIGFbMV0gPSBzOw0KICAgIGFbMl0gPSAwOw0KICAgIGFbM10gPSAwOw0KICAgIGFbNF0gPSAtczsNCiAgICBhWzVdID0gYzsNCiAgICBhWzZdID0gMDsNCiAgICBhWzddID0gMDsNCiAgICBhWzhdID0gMDsNCiAgICBhWzldID0gMDsNCiAgICBhWzEwXSA9IDE7DQogICAgYVsxMV0gPSAwOw0KICAgIGFbMTJdID0gMDsNCiAgICBhWzEzXSA9IDA7DQogICAgYVsxNF0gPSAwOw0KICAgIGFbMTVdID0gMTsNCiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICByZXR1cm4gdGhpcw0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zZm9ybXMgdGhlIFZlYzQgd2l0aCBhIE1hdDQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjNH0gdmVjIC0gVGhlIHZlYyB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0Lg0KICAgKi8NCiAgdHJhbnNmb3JtVmVjNCh2ZWMpIHsNCiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7DQogICAgY29uc3QgeCA9IHZlYy54Ow0KICAgIGNvbnN0IHkgPSB2ZWMueTsNCiAgICBjb25zdCB6ID0gdmVjLno7DQogICAgY29uc3QgdyA9IHZlYy50Ow0KICAgIHJldHVybiBuZXcgVmVjNCgNCiAgICAgIGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdICogdywNCiAgICAgIGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdICogdywNCiAgICAgIGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XSAqIHcsDQogICAgICBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV0gKiB3DQogICAgKQ0KICB9DQoNCiAgLyoqDQogICAqIFRyYW5zZm9ybXMgdGhlIFZlYzMgd2l0aCBhIE1hdDQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gdmVjIC0gVGhlIHZlYyB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgdHJhbnNmb3JtVmVjMyh2ZWMpIHsNCiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7DQogICAgY29uc3QgeCA9IHZlYy54Ow0KICAgIGNvbnN0IHkgPSB2ZWMueTsNCiAgICBjb25zdCB6ID0gdmVjLno7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEoDQogICAgICBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXSwNCiAgICAgIGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdLA0KICAgICAgYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdDQogICAgKQ0KICB9DQoNCiAgLyoqDQogICAqIFJvdGF0ZXMgYSBnaXZlbiBgVmVjM2AgYW5kIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQgYXMgYSBuZXcgYFZlYzNgDQogICAqIEBwYXJhbSB7VmVjM30gdmVjIC0gVGhlIHZlYyB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLg0KICAgKi8NCiAgcm90YXRlVmVjMyh2ZWMpIHsNCiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7DQogICAgY29uc3QgeCA9IHZlYy54Ow0KICAgIGNvbnN0IHkgPSB2ZWMueTsNCiAgICBjb25zdCB6ID0gdmVjLno7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEoYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6LCBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHosIGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHopDQogIH0NCg0KICAvKioNCiAgICogU2V0IHRoZSBwZXJzcGVjdGl2ZSBmcm9tIGEgTWF0NC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgLSBUaGUgZm92eSB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCAtIFRoZSBhc3BlY3QgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIC0gVGhlIG5lYXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgLSBUaGUgZmFyIHZhbHVlLg0KICAgKi8NCiAgc2V0UGVyc3BlY3RpdmVNYXRyaXgoZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHsNCiAgICBjb25zdCBmID0gTWF0aC50YW4oTWF0aC5QSSAqIDAuNSAtIDAuNSAqIGZvdnkpOw0KICAgIGNvbnN0IHJhbmdlSW52ID0gMS4wIC8gKG5lYXIgLSBmYXIpOw0KICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICB0aGlzLnNldChmIC8gYXNwZWN0LCAwLCAwLCAwLCAwLCBmLCAwLCAwLCAwLCAwLCAobmVhciArIGZhcikgKiByYW5nZUludiwgLTEsIDAsIDAsIG5lYXIgKiBmYXIgKiByYW5nZUludiAqIDIsIDApOw0KICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ3JhcGhpYyBtYXRyaXggYW5kIHNldHMgdGhlIHN0YXRlIG9mIHRoZSBNYXQ0IGNsYXNzDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IC0gVGhlIGxlZnQgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCAtIFRoZSByaWdodCB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSAtIFRoZSBib3R0b20gdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgdG9wIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gbmVhciAtIFRoZSBuZWFyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFyIC0gVGhlIGZhciB2YWx1ZS4NCiAgICovDQogIHNldE9ydGhvZ3JhcGhpY01hdHJpeChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikgew0KICAgIGNvbnN0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpOw0KICAgIGNvbnN0IGJ0ID0gMSAvIChib3R0b20gLSB0b3ApOw0KICAgIGNvbnN0IG5mID0gMSAvIChuZWFyIC0gZmFyKTsNCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgdGhpcy5zZXQoDQogICAgICAtMiAqIGxyLA0KICAgICAgMCwNCiAgICAgIDAsDQogICAgICAwLA0KICAgICAgMCwNCiAgICAgIC0yICogYnQsDQogICAgICAwLA0KICAgICAgMCwNCiAgICAgIDAsDQogICAgICAwLA0KICAgICAgMiAqIG5mLA0KICAgICAgMCwNCiAgICAgIChsZWZ0ICsgcmlnaHQpICogbHIsDQogICAgICAodG9wICsgYm90dG9tKSAqIGJ0LA0KICAgICAgKGZhciArIG5lYXIpICogbmYsDQogICAgICAxDQogICAgKTsNCiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgfQ0KDQogIC8qKg0KICAgKiBTY2FsZXMgTWF0NCBNYXRyaXgNCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiB2YWx1ZS4NCiAgICovDQogIHNldFNjYWxlKHgsIHksIHopIHsNCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgaWYgKHggaW5zdGFuY2VvZiBWZWMzJDEpIHsNCiAgICAgIHRoaXMuc2V0KHgueCwgMCwgMCwgMCwgMCwgeC55LCAwLCAwLCAwLCAwLCB4LnosIDAsIDAsIDAsIDAsIDEpOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLnNldCh4LCAwLCAwLCAwLCAwLCB5LCAwLCAwLCAwLCAwLCB6LCAwLCAwLCAwLCAwLCAxKTsNCiAgICB9DQogICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogIH0NCg0KICAvKioNCiAgICogVHJhbnNmb3JtcyBhIDN4NCBtYXRyaXggaW50byBhIDR4NCBtYXRyaXggYW5kIHNldCB0aGUgcmVzdWx0IHRvIHRoZSBNYXRoNCBzdGF0ZS4NCiAgICoNCiAgICogQHBhcmFtIHthcnJheX0gbTN4NCAtIFRoZSBtM3g0IHZhbHVlLg0KICAgKi8NCiAgc2V0RnJvbU1hdDN4NEFycmF5KG0zeDQpIHsNCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgdGhpcy5zZXQoDQogICAgICBtM3g0WzBdLA0KICAgICAgbTN4NFsxXSwNCiAgICAgIG0zeDRbMl0sDQogICAgICAwLA0KICAgICAgbTN4NFszXSwNCiAgICAgIG0zeDRbNF0sDQogICAgICBtM3g0WzVdLA0KICAgICAgMCwNCiAgICAgIG0zeDRbNl0sDQogICAgICBtM3g0WzddLA0KICAgICAgbTN4NFs4XSwNCiAgICAgIDAsDQogICAgICBtM3g0WzldLA0KICAgICAgbTN4NFsxMF0sDQogICAgICBtM3g0WzExXSwNCiAgICAgIDENCiAgICApOw0KICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBuZXcgTWF0NCB0byB3cmFwIGV4aXN0aW5nIG1lbW9yeSBpbiBhIGJ1ZmZlci4NCiAgICoNCiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuDQogICAqIEByZXR1cm4ge01hdDR9IC0gUmV0dXJucyBhIG5ldyBNYXQ0Lg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkgew0KICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZCwgdXNlICNjcmVhdGVGcm9tQnVmZmVyIGluc3RlYWQnKTsNCiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNCkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgYE1hdDRgIHVzaW5nIGFuIEFycmF5QnVmZmVyLg0KICAgKg0KICAgKiBAc3RhdGljDQogICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS4NCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICBzdGF0aWMgY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIGJ5dGVPZmZzZXQpIHsNCiAgICByZXR1cm4gbmV3IE1hdDQobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDE2KSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXQNCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBNYXQ0IHJldHVybmluZyBhIG5ldyBpbnN0YW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IE1hdDQoDQogICAgICB0aGlzLl9fZGF0YVswXSwNCiAgICAgIHRoaXMuX19kYXRhWzFdLA0KICAgICAgdGhpcy5fX2RhdGFbMl0sDQogICAgICB0aGlzLl9fZGF0YVszXSwNCiAgICAgIHRoaXMuX19kYXRhWzRdLA0KICAgICAgdGhpcy5fX2RhdGFbNV0sDQogICAgICB0aGlzLl9fZGF0YVs2XSwNCiAgICAgIHRoaXMuX19kYXRhWzddLA0KICAgICAgdGhpcy5fX2RhdGFbOF0sDQogICAgICB0aGlzLl9fZGF0YVs5XSwNCiAgICAgIHRoaXMuX19kYXRhWzEwXSwNCiAgICAgIHRoaXMuX19kYXRhWzExXSwNCiAgICAgIHRoaXMuX19kYXRhWzEyXSwNCiAgICAgIHRoaXMuX19kYXRhWzEzXSwNCiAgICAgIHRoaXMuX19kYXRhWzE0XSwNCiAgICAgIHRoaXMuX19kYXRhWzE1XQ0KICAgICkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBNYXQ0Lg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgTWF0NCguLi5hcmdzKQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFBlcnNpc3RlbmNlDQoNCiAgLyoqDQogICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIGpzb24gcGFyYW0uDQogICAqLw0KICBmcm9tSlNPTihqc29uKSB7DQogICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGpzb24pOw0KICB9DQoNCiAgLyoqDQogICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAqDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKi8NCiAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICB0aGlzLl9fZGF0YSA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KDE2KTsNCiAgfQ0KfQ0KDQpSZWdpc3RyeS5yZWdpc3RlcignTWF0NCcsIE1hdDQpOwoKLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8NCg0KLyoqDQogKiBDbGFzcyByZXByZXNlbnRpbmcgYSBxdWF0ZXJuaW9uLiBRdWF0ZXJuaW9ucyBhcmUgdXNlZCB0byByZXByZXNlbnQgcm90YXRpb25zDQogKiB3aXRob3V0IGVuY291bnRlcmluZyBnaW1ibGUgbG9jay4gQmFzZWQgb24gY29tcGxleCBudW1iZXJzIHRoYXQgYXJlIG5vdCBlYXN5DQogKiB0byB1bmRlcnN0YW5kIGludHVpdGl2ZWx5Lg0KICoNCiAqIEBleHRlbmRzIEF0dHJWYWx1ZQ0KICovDQpjbGFzcyBRdWF0IGV4dGVuZHMgQXR0clZhbHVlIHsNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlciB8IEFycmF5QnVmZmVyIHwgb2JqZWN0fSB4IC0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMuIERlZmF1bHQgaXMgMC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW5nbGUgb2YgdGhlIHkgYXhpcy4gRGVmYXVsdCBpcyAwLg0KICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzLiBEZWZhdWx0IGlzIDAuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB3IC0gVGhlIHcgdmFsdWUuIERlZmF1bHQgaXMgMS4NCiAgICovDQogIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7DQogICAgc3VwZXIoKTsNCg0KICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7DQogICAgICB0aGlzLl9fZGF0YSA9IHg7DQogICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsNCiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYCk7DQogICAgICBjb25zdCBidWZmZXIgPSB4Ow0KICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHk7DQogICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KTsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpOw0KICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykgew0KICAgICAgICB0aGlzLl9fZGF0YVswXSA9IDA7DQogICAgICAgIHRoaXMuX19kYXRhWzFdID0gMDsNCiAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSAwOw0KICAgICAgICB0aGlzLl9fZGF0YVszXSA9IDE7DQogICAgICAgIGZvciAoY29uc3Qga2V5IGluIHgpIHsNCiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4W2tleV0pKSB0aGlzW2tleV0uY2FsbCh0aGlzLCAuLi54W2tleV0pOw0KICAgICAgICAgIGVsc2UgdGhpc1trZXldLmNhbGwodGhpcywgeFtrZXldKTsNCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4Ow0KICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHk7DQogICAgICAgIHRoaXMuX19kYXRhWzJdID0gejsNCiAgICAgICAgdGhpcy5fX2RhdGFbM10gPSB3Ow0KICAgICAgfQ0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB4YCBheGlzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeCBheGlzIHJvdGF0aW9uLg0KICAgKi8NCiAgZ2V0IHgoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgeGAgYXhpcyByb3RhdGlvbi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeCh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB5YCBheGlzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeSBheGlzIHJvdGF0aW9uLg0KICAgKi8NCiAgZ2V0IHkoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgeWAgYXhpcyByb3RhdGlvbi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeSh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsxXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB6YCBheGlzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeiBheGlzIHJvdGF0aW9uLg0KICAgKi8NCiAgZ2V0IHooKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdDQogIH0NCg0KICAvKioNCiAgICogU2V0dGVyIGZvciBgemAgYXhpcyByb3RhdGlvbi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgeih2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIGB3YCB2YWx1ZS4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHcgdmFsdWUuDQogICAqLw0KICBnZXQgdygpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFbM10NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZm9yIGB3YC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAqLw0KICBzZXQgdyh2YWwpIHsNCiAgICB0aGlzLl9fZGF0YVszXSA9IHZhbDsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIHJvdGF0aW9uLg0KICAgKiBAcGFyYW0ge251bWJlcn0geSAgLSBUaGUgeSBheGlzIHJvdGF0aW9uLg0KICAgKiBAcGFyYW0ge251bWJlcn0geiAgLSBUaGUgeiBheGlzIHJvdGF0aW9uLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdyAgLSBUaGUgdyB2YWx1ZS4NCiAgICovDQogIHNldCh4LCB5LCB6LCB3KSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSB4Ow0KICAgIHRoaXMuX19kYXRhWzFdID0geTsNCiAgICB0aGlzLl9fZGF0YVsyXSA9IHo7DQogICAgdGhpcy5fX2RhdGFbM10gPSB3Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBRdWF0IGNsYXNzIHVzaW5nIGEgRmxvYXQzMkFycmF5Lg0KICAgKg0KICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZmxvYXQzMkFycmF5IC0gVGhlIGZsb2F0MzJBcnJheSB2YWx1ZS4NCiAgICovDQogIHNldERhdGFBcnJheShmbG9hdDMyQXJyYXkpIHsNCiAgICB0aGlzLl9fZGF0YSA9IGZsb2F0MzJBcnJheTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXR0ZXIgZnJvbSBhbm90aGVyIHZlY3Rvci4NCiAgICoNCiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciB2ZWN0b3IgdG8gc2V0IGZyb20uDQogICAqLw0KICBzZXRGcm9tT3RoZXIob3RoZXIpIHsNCiAgICB0aGlzLl9fZGF0YVswXSA9IG90aGVyLng7DQogICAgdGhpcy5fX2RhdGFbMV0gPSBvdGhlci55Ow0KICAgIHRoaXMuX19kYXRhWzJdID0gb3RoZXIuejsNCiAgICB0aGlzLl9fZGF0YVszXSA9IG90aGVyLnc7DQogIH0NCg0KICAvKioNCiAgICogU2V0IHRoaXMgcXVhdCBmcm9tIGEgZXVsZXIgcm90YXRpb24uDQogICAqDQogICAqIEBwYXJhbSB7RXVsZXJBbmdsZXN9IGV1bGVyQW5nbGVzIC0gVGhlIGV1bGVyIGFuZ2xlcyByb3RhdGlvbi4NCiAgICovDQogIHNldEZyb21FdWxlckFuZ2xlcyhldWxlckFuZ2xlcykgew0KICAgIGNvbnN0IG9yZGVyZWQgPSBuZXcgVmVjMyQxKCk7DQoNCiAgICBzd2l0Y2ggKGV1bGVyQW5nbGVzLm9yZGVyKSB7DQogICAgICBjYXNlIDA6DQogICAgICAgIC8qICdYWVonICovDQogICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLngsIC1ldWxlckFuZ2xlcy55LCBldWxlckFuZ2xlcy56KTsNCiAgICAgICAgYnJlYWsNCiAgICAgIGNhc2UgMToNCiAgICAgICAgLyogJ1laWCcgKi8NCiAgICAgICAgb3JkZXJlZC5zZXQoZXVsZXJBbmdsZXMueSwgLWV1bGVyQW5nbGVzLnosIGV1bGVyQW5nbGVzLngpOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSAyOg0KICAgICAgICAvKiAnWlhZJyAqLw0KICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy56LCAtZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueSk7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlIDM6DQogICAgICAgIC8qICdYWlknICovDQogICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLngsIGV1bGVyQW5nbGVzLnosIGV1bGVyQW5nbGVzLnkpOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSA0Og0KICAgICAgICAvKiAnWllYJyAqLw0KICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy56LCBldWxlckFuZ2xlcy55LCBldWxlckFuZ2xlcy54KTsNCiAgICAgICAgYnJlYWsNCiAgICAgIGNhc2UgNToNCiAgICAgICAgLyogJ1lYWicgKi8NCiAgICAgICAgb3JkZXJlZC5zZXQoZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueik7DQogICAgICAgIGJyZWFrDQogICAgICBkZWZhdWx0Og0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NkcnR5JykNCiAgICB9DQoNCiAgICBjb25zdCB0aSA9IG9yZGVyZWQueCAqIDAuNTsNCiAgICBjb25zdCB0aiA9IG9yZGVyZWQueSAqIDAuNTsNCiAgICBjb25zdCB0ayA9IG9yZGVyZWQueiAqIDAuNTsNCiAgICBjb25zdCBjaSA9IE1hdGguY29zKHRpKTsNCiAgICBjb25zdCBjaiA9IE1hdGguY29zKHRqKTsNCiAgICBjb25zdCBjayA9IE1hdGguY29zKHRrKTsNCiAgICBjb25zdCBzaSA9IE1hdGguc2luKHRpKTsNCiAgICBjb25zdCBzaiA9IE1hdGguc2luKHRqKTsNCiAgICBjb25zdCBzayA9IE1hdGguc2luKHRrKTsNCiAgICBjb25zdCBjYyA9IGNpICogY2s7DQogICAgY29uc3QgY3MgPSBjaSAqIHNrOw0KICAgIGNvbnN0IHNjID0gc2kgKiBjazsNCiAgICBjb25zdCBzcyA9IHNpICogc2s7DQogICAgY29uc3QgYWkgPSBjaiAqIHNjIC0gc2ogKiBjczsNCiAgICBjb25zdCBhaiA9IGNqICogc3MgKyBzaiAqIGNjOw0KICAgIGNvbnN0IGFrID0gY2ogKiBjcyAtIHNqICogc2M7DQoNCiAgICB0aGlzLncgPSBjaiAqIGNjICsgc2ogKiBzczsNCg0KICAgIHN3aXRjaCAoZXVsZXJBbmdsZXMub3JkZXIpIHsNCiAgICAgIGNhc2UgMDoNCiAgICAgICAgLyogJyBYWVonICovDQogICAgICAgIHRoaXMueCA9IGFpOw0KICAgICAgICB0aGlzLnkgPSAtYWo7DQogICAgICAgIHRoaXMueiA9IGFrOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSAxOg0KICAgICAgICAvKiAnWVpYJyAqLw0KICAgICAgICB0aGlzLnggPSBhazsNCiAgICAgICAgdGhpcy55ID0gYWk7DQogICAgICAgIHRoaXMueiA9IC1hajsNCiAgICAgICAgYnJlYWsNCiAgICAgIGNhc2UgMjoNCiAgICAgICAgLyogJ1pYWScgKi8NCiAgICAgICAgdGhpcy54ID0gLWFqOw0KICAgICAgICB0aGlzLnkgPSBhazsNCiAgICAgICAgdGhpcy56ID0gYWk7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlIDM6DQogICAgICAgIC8qICdYWlknICovDQogICAgICAgIHRoaXMueCA9IGFpOw0KICAgICAgICB0aGlzLnkgPSBhazsNCiAgICAgICAgdGhpcy56ID0gYWo7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlIDQ6DQogICAgICAgIC8qICdaWVgnICovDQogICAgICAgIHRoaXMueCA9IGFrOw0KICAgICAgICB0aGlzLnkgPSBhajsNCiAgICAgICAgdGhpcy56ID0gYWk7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlIDU6DQogICAgICAgIC8qICdZWFonICovDQogICAgICAgIHRoaXMueCA9IGFqOw0KICAgICAgICB0aGlzLnkgPSBhaTsNCiAgICAgICAgdGhpcy56ID0gYWs7DQogICAgICAgIGJyZWFrDQogICAgICBkZWZhdWx0Og0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NkcnR5JykNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgUXVhdCB0byBhbiBFdWxlckFuZ2xlcw0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gcm90YXRpb25PcmRlciAtIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLg0KICAgKiBAcmV0dXJuIHtFdWxlckFuZ2xlc30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgdG9FdWxlckFuZ2xlcyhyb3RhdGlvbk9yZGVyKSB7DQogICAgY29uc3Qgb3JkZXJlZCA9IG5ldyBWZWMzJDEoKTsNCiAgICBzd2l0Y2ggKHJvdGF0aW9uT3JkZXIpIHsNCiAgICAgIGNhc2UgMDoNCiAgICAgICAgLyogJyBYWVonICovDQogICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSAxOg0KICAgICAgICAvKiAnWVpYJyAqLw0KICAgICAgICBvcmRlcmVkLnNldCh0aGlzLngsIHRoaXMueSwgdGhpcy56KTsNCiAgICAgICAgYnJlYWsNCiAgICAgIGNhc2UgMjoNCiAgICAgICAgLyogJ1pYWScgKi8NCiAgICAgICAgb3JkZXJlZC5zZXQodGhpcy55LCB0aGlzLnosIHRoaXMueCk7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlIDM6DQogICAgICAgIC8qICdYWlknICovDQogICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueSwgLXRoaXMueCwgdGhpcy56KTsNCiAgICAgICAgYnJlYWsNCiAgICAgIGNhc2UgNDoNCiAgICAgICAgLyogJ1pZWCcgKi8NCiAgICAgICAgb3JkZXJlZC5zZXQodGhpcy54LCAtdGhpcy56LCB0aGlzLnkpOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSA1Og0KICAgICAgICAvKiAnWVhaJyAqLw0KICAgICAgICBvcmRlcmVkLnNldCh0aGlzLnosIC10aGlzLnksIHRoaXMueCk7DQogICAgICAgIGJyZWFrDQogICAgICBkZWZhdWx0Og0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm90YXRpb24gb3JkZXI6JyArIHJvdGF0aW9uT3JkZXIpDQogICAgfQ0KDQogICAgY29uc3QgZXVsZXIgPSBuZXcgVmVjMyQxKCk7DQogICAgY29uc3QgdGVzdCA9IG9yZGVyZWQueCAqIG9yZGVyZWQueSArIG9yZGVyZWQueiAqIHRoaXMudzsNCiAgICBpZiAodGVzdCA+IDAuNDk5OTkpIHsNCiAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IG5vcnRoIHBvbGUNCiAgICAgIGV1bGVyLnkgPSAyLjAgKiBNYXRoLmF0YW4yKG9yZGVyZWQueCwgdGhpcy53KTsNCiAgICAgIGV1bGVyLnogPSBNYXRoLlBJICogMC41Ow0KICAgICAgZXVsZXIueCA9IDAuMDsNCiAgICB9IGVsc2UgaWYgKHRlc3QgPCAtMC40OTk5OSkgew0KICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZQ0KICAgICAgZXVsZXIueSA9IC0yLjAgKiBNYXRoLmF0YW4yKG9yZGVyZWQueCwgdGhpcy53KTsNCiAgICAgIGV1bGVyLnogPSBNYXRoLlBJICogLTAuNTsNCiAgICAgIGV1bGVyLnggPSAwLjA7DQogICAgfSBlbHNlIHsNCiAgICAgIGNvbnN0IHNxeCA9IG9yZGVyZWQueCAqIG9yZGVyZWQueDsNCiAgICAgIGNvbnN0IHNxeSA9IG9yZGVyZWQueSAqIG9yZGVyZWQueTsNCiAgICAgIGNvbnN0IHNxeiA9IG9yZGVyZWQueiAqIG9yZGVyZWQuejsNCiAgICAgIGV1bGVyLnkgPSBNYXRoLmF0YW4yKDIuMCAqIG9yZGVyZWQueSAqIHRoaXMudyAtIDIuMCAqIG9yZGVyZWQueCAqIG9yZGVyZWQueiwgMS4wIC0gMi4wICogc3F5IC0gMi4wICogc3F6KTsNCiAgICAgIGV1bGVyLnogPSBNYXRoLmFzaW4oMi4wICogdGVzdCk7DQogICAgICBldWxlci54ID0gTWF0aC5hdGFuMigyLjAgKiBvcmRlcmVkLnggKiB0aGlzLncgLSAyLjAgKiBvcmRlcmVkLnkgKiBvcmRlcmVkLnosIDEuMCAtIDIuMCAqIHNxeCAtIDIuMCAqIHNxeik7DQogICAgfQ0KDQogICAgc3dpdGNoIChyb3RhdGlvbk9yZGVyKSB7DQogICAgICBjYXNlIDA6DQogICAgICAgIC8qICcgWFlaJyAqLw0KICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLnksIGV1bGVyLnosIGV1bGVyLngsIHJvdGF0aW9uT3JkZXIpDQogICAgICBjYXNlIDE6DQogICAgICAgIC8qICdZWlgnICovDQogICAgICAgIHJldHVybiBuZXcgRXVsZXJBbmdsZXMoZXVsZXIueCwgZXVsZXIueSwgZXVsZXIueiwgcm90YXRpb25PcmRlcikNCiAgICAgIGNhc2UgMjoNCiAgICAgICAgLyogJ1pYWScgKi8NCiAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci56LCBldWxlci54LCBldWxlci55LCByb3RhdGlvbk9yZGVyKQ0KICAgICAgY2FzZSAzOg0KICAgICAgICAvKiAnWFpZJyAqLw0KICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKC1ldWxlci55LCBldWxlci54LCBldWxlci56LCByb3RhdGlvbk9yZGVyKQ0KICAgICAgY2FzZSA0Og0KICAgICAgICAvKiAnWllYJyAqLw0KICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLngsIGV1bGVyLnosIC1ldWxlci55LCByb3RhdGlvbk9yZGVyKQ0KICAgICAgY2FzZSA1Og0KICAgICAgICAvKiAnWVhaJyAqLw0KICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLnosIC1ldWxlci55LCBldWxlci54LCByb3RhdGlvbk9yZGVyKQ0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXQgdGhpcyBxdWF0IHRvIGEgcm90YXRpb24gZGVmaW5lZCBieSBhbiBheGlzIGFuZCBhbiBhbmdsZSAoaW4gcmFkaWFucykuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gYXhpcyAtIFRoZSBheGlzIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYXhpcyBhbmdsZS4NCiAgICovDQogIHNldEZyb21BeGlzQW5kQW5nbGUoYXhpcywgYW5nbGUpIHsNCiAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIuMDsNCiAgICBjb25zdCB2ZWMgPSBheGlzLm5vcm1hbGl6ZSgpLnNjYWxlKE1hdGguc2luKGhhbGZBbmdsZSkpOw0KICAgIHRoaXMuc2V0KHZlYy54LCB2ZWMueSwgdmVjLnosIE1hdGguY29zKGhhbGZBbmdsZSkpOw0KICB9DQoNCiAgLyoqDQogICAqIFNjYWxlcyBhbmQgY2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgYFZlYzNgIGFuZCBzZXRzIHRoZSByZXN1bHQgaW4gdGhlIE1hdDMNCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBkaXIgLSBUaGUgZGlyZWN0aW9uIHZhbHVlLg0KICAgKiBAcGFyYW0ge1ZlYzN9IHVwIC0gVGhlIHVwIGFuZ2xlLg0KICAgKi8NCiAgc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGRpciwgdXApIHsNCiAgICBjb25zdCBtYXQzID0gbmV3IE1hdDMoKTsNCiAgICBtYXQzLnNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3RvcihkaXIsIHVwKTsNCiAgICB0aGlzLnNldEZyb21NYXQzKG1hdDMpOw0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgUXVhdGAgZnJvbSB0d28gYFZlYzNgLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHYwIC0gVGhlIHYwIHVuaXQgdmVjdG9yLg0KICAgKiBAcGFyYW0ge1ZlYzN9IHYxIC0gVGhlIHYxIHVuaXQgdmVjdG9yLg0KICAgKi8NCiAgc2V0RnJvbTJWZWN0b3JzKHYwLCB2MSkgew0KICAgIGNvbnN0IGMgPSB2MC5jcm9zcyh2MSk7DQogICAgY29uc3QgZCA9IHYwLmRvdCh2MSk7DQogICAgY29uc3QgcyA9IE1hdGguc3FydCgoMSArIGQpICogMik7DQogICAgLy8gdGhpcy5zZXQoIHMvMiwgYy54IC8gcywgYy55IC8gcywgYy56IC8gcyApOw0KICAgIHRoaXMuc2V0KGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMsIHMgLyAyKTsNCiAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXQgdGhlIHF1YXQgZnJvbSBhIE1hdDMuDQogICAqDQogICAqIEBwYXJhbSB7TWF0M30gbWF0MyAtIFRoZSBtYXQzIHZhbHVlLg0KICAgKi8NCiAgc2V0RnJvbU1hdDMobWF0Mykgew0KICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzDQogICAgLy8gYXJ0aWNsZSAiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb24iLg0KICAgIGNvbnN0IGZUcmFjZSA9IG1hdDMuX19kYXRhWzBdICsgbWF0My5fX2RhdGFbNF0gKyBtYXQzLl9fZGF0YVs4XTsNCiAgICBsZXQgZlJvb3Q7DQoNCiAgICBpZiAoZlRyYWNlID4gMC4wKSB7DQogICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yDQogICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxKTsgLy8gMncNCiAgICAgIHRoaXMuX19kYXRhWzNdID0gMC41ICogZlJvb3Q7DQogICAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dykNCiAgICAgIHRoaXMuX19kYXRhWzBdID0gKG1hdDMuX19kYXRhWzVdIC0gbWF0My5fX2RhdGFbN10pICogZlJvb3Q7DQogICAgICB0aGlzLl9fZGF0YVsxXSA9IChtYXQzLl9fZGF0YVs2XSAtIG1hdDMuX19kYXRhWzJdKSAqIGZSb290Ow0KICAgICAgdGhpcy5fX2RhdGFbMl0gPSAobWF0My5fX2RhdGFbMV0gLSBtYXQzLl9fZGF0YVszXSkgKiBmUm9vdDsNCiAgICB9IGVsc2Ugew0KICAgICAgLy8gfHd8IDw9IDEvMg0KICAgICAgbGV0IGkgPSAwOw0KICAgICAgaWYgKG1hdDMuX19kYXRhWzRdID4gbWF0My5fX2RhdGFbMF0pIGkgPSAxOw0KICAgICAgaWYgKG1hdDMuX19kYXRhWzhdID4gbWF0My5fX2RhdGFbaSAqIDMgKyBpXSkgaSA9IDI7DQogICAgICBjb25zdCBqID0gKGkgKyAxKSAlIDM7DQogICAgICBjb25zdCBrID0gKGkgKyAyKSAlIDM7DQoNCiAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1hdDMuX19kYXRhW2kgKiAzICsgaV0gLSBtYXQzLl9fZGF0YVtqICogMyArIGpdIC0gbWF0My5fX2RhdGFbayAqIDMgKyBrXSArIDEuMCk7DQogICAgICB0aGlzLl9fZGF0YVtpXSA9IDAuNSAqIGZSb290Ow0KICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsNCiAgICAgIHRoaXMuX19kYXRhWzNdID0gKG1hdDMuX19kYXRhW2ogKiAzICsga10gLSBtYXQzLl9fZGF0YVtrICogMyArIGpdKSAqIGZSb290Ow0KICAgICAgdGhpcy5fX2RhdGFbal0gPSAobWF0My5fX2RhdGFbaiAqIDMgKyBpXSArIG1hdDMuX19kYXRhW2kgKiAzICsgal0pICogZlJvb3Q7DQogICAgICB0aGlzLl9fZGF0YVtrXSA9IChtYXQzLl9fZGF0YVtrICogMyArIGldICsgbWF0My5fX2RhdGFbaSAqIDMgKyBrXSkgKiBmUm9vdDsNCiAgICB9DQogICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKCk7DQogIH0NCg0KICAvKioNCiAgICogU2V0IHRoZSBxdWF0IGZyb20gYSBNYXQ0Lg0KICAgKg0KICAgKiBAcGFyYW0ge01hdDR9IG1hdDQgLSBUaGUgbWF0NCB2YWx1ZS4NCiAgICovDQogIHNldEZyb21NYXQ0KG1hdDQpIHsNCiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlcw0KICAgIC8vIGFydGljbGUgIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uIi4NCiAgICBjb25zdCBmVHJhY2UgPSBtYXQ0Ll9fZGF0YVswXSArIG1hdDQuX19kYXRhWzVdICsgbWF0NC5fX2RhdGFbMTBdOw0KICAgIGxldCBmUm9vdDsNCg0KICAgIGlmIChmVHJhY2UgPiAwLjApIHsNCiAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzINCiAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEpOyAvLyAydw0KICAgICAgdGhpcy5fX2RhdGFbM10gPSAwLjUgKiBmUm9vdDsNCiAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7IC8vIDEvKDR3KQ0KICAgICAgdGhpcy5fX2RhdGFbMF0gPSAobWF0NC5fX2RhdGFbNl0gLSBtYXQ0Ll9fZGF0YVs5XSkgKiBmUm9vdDsNCiAgICAgIHRoaXMuX19kYXRhWzFdID0gKG1hdDQuX19kYXRhWzhdIC0gbWF0NC5fX2RhdGFbMl0pICogZlJvb3Q7DQogICAgICB0aGlzLl9fZGF0YVsyXSA9IChtYXQ0Ll9fZGF0YVsxXSAtIG1hdDQuX19kYXRhWzRdKSAqIGZSb290Ow0KICAgIH0gZWxzZSB7DQogICAgICAvLyB8d3wgPD0gMS8yDQogICAgICBsZXQgaSA9IDA7DQogICAgICBpZiAobWF0NC5fX2RhdGFbNV0gPiBtYXQ0Ll9fZGF0YVswXSkgaSA9IDE7DQogICAgICBpZiAobWF0NC5fX2RhdGFbMTBdID4gbWF0NC5fX2RhdGFbaSAqIDQgKyBpXSkgaSA9IDI7DQogICAgICBjb25zdCBqID0gKGkgKyAxKSAlIDM7DQogICAgICBjb25zdCBrID0gKGkgKyAyKSAlIDM7DQoNCiAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1hdDQuX19kYXRhW2kgKiA0ICsgaV0gLSBtYXQ0Ll9fZGF0YVtqICogNCArIGpdIC0gbWF0NC5fX2RhdGFbayAqIDQgKyBrXSArIDEuMCk7DQogICAgICB0aGlzLl9fZGF0YVtpXSA9IDAuNSAqIGZSb290Ow0KICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsNCiAgICAgIHRoaXMuX19kYXRhWzNdID0gKG1hdDQuX19kYXRhW2ogKiA0ICsga10gLSBtYXQ0Ll9fZGF0YVtrICogNCArIGpdKSAqIGZSb290Ow0KICAgICAgdGhpcy5fX2RhdGFbal0gPSAobWF0NC5fX2RhdGFbaiAqIDQgKyBpXSArIG1hdDQuX19kYXRhW2kgKiA0ICsgal0pICogZlJvb3Q7DQogICAgICB0aGlzLl9fZGF0YVtrXSA9IChtYXQ0Ll9fZGF0YVtrICogNCArIGldICsgbWF0NC5fX2RhdGFbaSAqIDQgKyBrXSkgKiBmUm9vdDsNCiAgICB9DQogICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKCk7DQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoZSBhbmdsZSBvZiB0aGUgUXVhdCBpcyBsZXNzIHRoYXQgYCBOdW1iZXIuRVBTSUxPTmANCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBpc0lkZW50aXR5KCkgew0KICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKCkgPCBOdW1iZXIuRVBTSUxPTg0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybiB0aGUgYW5nbGUgb2YgdGhlIFF1YXQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0QW5nbGUoKSB7DQogICAgcmV0dXJuIE1hdGguYWNvcyh0aGlzLncpICogMi4wDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUXVhdCBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIGVxdWFsKG90aGVyKSB7DQogICAgcmV0dXJuIHRoaXMueCA9PSBvdGhlci54ICYmIHRoaXMueSA9PSBvdGhlci55ICYmIHRoaXMueiA9PSBvdGhlci56ICYmIHRoaXMudyA9PSBvdGhlci53DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUXVhdCBpcyBOT1QgZXhhY3RseSB0aGUgc2FtZSBvdGhlci4NCiAgICoNCiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAqLw0KICBub3RFcXVhbHMob3RoZXIpIHsNCiAgICByZXR1cm4gdGhpcy54ICE9IG90aGVyLnggJiYgdGhpcy55ICE9IG90aGVyLnkgJiYgdGhpcy56ICE9IG90aGVyLnogJiYgdGhpcy53ICE9IG90aGVyLncNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBRdWF0IGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXINCiAgICoNCiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICovDQogIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgIHJldHVybiAoDQogICAgICBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHByZWNpc2lvbiAmJg0KICAgICAgTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCBwcmVjaXNpb24gJiYNCiAgICAgIE1hdGguYWJzKHRoaXMueiAtIG90aGVyLnopIDwgcHJlY2lzaW9uICYmDQogICAgICBNYXRoLmFicyh0aGlzLncgLSBvdGhlci53KSA8IHByZWNpc2lvbg0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgUXVhdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC4NCiAgICoNCiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGFkZC4NCiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAqLw0KICBhZGQob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueiwgdGhpcy53ICsgb3RoZXIudykNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgUXVhdC4NCiAgICoNCiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGFkZC4NCiAgICovDQogIGFkZEluUGxhY2Uob3RoZXIpIHsNCiAgICB0aGlzLnggKz0gb3RoZXIueDsNCiAgICB0aGlzLnkgKz0gb3RoZXIueTsNCiAgICB0aGlzLnogKz0gb3RoZXIuejsNCiAgICB0aGlzLncgKz0gb3RoZXIudzsNCiAgfQ0KDQogIC8qKg0KICAgKiBTdWJ0cmFjdHMgb3RoZXIgZnJvbSB0aGlzIFF1YXQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgKg0KICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gc3VidHJhY3QuDQogICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0Lg0KICAgKi8NCiAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54IC0gb3RoZXIueCwgdGhpcy55IC0gb3RoZXIueSwgdGhpcy56IC0gb3RoZXIueiwgdGhpcy53IC0gb3RoZXIudykNCiAgfQ0KDQogIC8qKg0KICAgKiBTY2FsZXMgdGhpcyBRdWF0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICovDQogIHNjYWxlKHNjYWxhcikgew0KICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyLCB0aGlzLncgKiBzY2FsYXIpDQogIH0NCg0KICAvKioNCiAgICogU2NhbGVzIHRoaXMgUXVhdCBieSBzY2FsYXIuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgIHRoaXMueCAqPSBzY2FsYXI7DQogICAgdGhpcy55ICo9IHNjYWxhcjsNCiAgICB0aGlzLnogKj0gc2NhbGFyOw0KICAgIHRoaXMudyAqPSBzY2FsYXI7DQogIH0NCg0KICAvKioNCiAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgUXVhdC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICovDQogIGxlbmd0aCgpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCB3ID0gdGhpcy5fX2RhdGFbM107DQogICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdykNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIFF1YXQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAqLw0KICBsZW5ndGhTcXVhcmVkKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IHcgPSB0aGlzLl9fZGF0YVszXTsNCiAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcNCiAgfQ0KDQogIC8qKg0KICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0IGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFF1YXQuDQogICAqDQogICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyB0aGUgUXVhdCBub3JtYWxpemVkLg0KICAgKi8NCiAgbm9ybWFsaXplKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsNCiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IHcgPSB0aGlzLl9fZGF0YVszXTsNCiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7DQogICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICByZXR1cm4gbmV3IFF1YXQoKQ0KICAgIH0NCg0KICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlPw0KICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICByZXR1cm4gbmV3IFF1YXQoeCAqIGxlbiwgeSAqIGxlbiwgeiAqIGxlbikNCiAgfQ0KDQogIC8qKg0KICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0LCBtb2RpZnlpbmcgaXQgYW5kIHJldHVybmluZyBpdCBub3JtYWxpemVkLg0KICAgKi8NCiAgbm9ybWFsaXplSW5QbGFjZSgpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOw0KICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCB3ID0gdGhpcy5fX2RhdGFbM107DQogICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3Ow0KICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICB0aGlzLnNldCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuLCB3ICogbGVuKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gUXVhdHMuDQogICAqDQogICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdC4NCiAgICovDQogIGRvdChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLnogKyB0aGlzLncgKiBvdGhlci53DQogIH0NCg0KICAvKioNCiAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gUXVhdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgKg0KICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gY2FsY3VsYXRlIHdpdGguDQogICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdCBhcyBhIG5ldyBRdWF0Lg0KICAgKi8NCiAgY3Jvc3Mob3RoZXIpIHsNCiAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICBjb25zdCBheSA9IHRoaXMueTsNCiAgICBjb25zdCBheiA9IHRoaXMuejsNCiAgICBjb25zdCBhdCA9IHRoaXMudzsNCiAgICBjb25zdCBieCA9IG90aGVyLng7DQogICAgY29uc3QgYnkgPSBvdGhlci55Ow0KICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsNCiAgICBjb25zdCBidCA9IG90aGVyLnc7DQoNCiAgICByZXR1cm4gbmV3IFF1YXQoYXkgKiBieiAtIGF6ICogYnksIGF6ICogYnQgLSBhdCAqIGJ6LCBhdCAqIGJ4IC0gYXggKiBidCwgYXggKiBieSAtIGF5ICogYngpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgcm90YXRpb25hbCBjb25qdWdhdGUgb2YgdGhpcyBRdWF0Lg0KICAgKiBDb25qdWdhdGlvbiByZXByZXNlbnRzIHRoZSBzYW1lIHJvdGF0aW9uIG9mIHRoZSBRdWF0IGJ1dA0KICAgKiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGFyb3VuZCB0aGUgcm90YXRpb25hbCBheGlzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIHRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBjb25qdWdhdGUoKSB7DQogICAgcmV0dXJuIG5ldyBRdWF0KC10aGlzLngsIC10aGlzLnksIC10aGlzLnosIHRoaXMudykNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm4gdGhlIGludmVyc2Ugb2YgdGhlIGBRdWF0YA0KICAgKg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICovDQogIGludmVyc2UoKSB7DQogICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKCkNCiAgfQ0KDQogIC8qKg0KICAgKiBBbGlnbnMgdGhpcyBxdWF0ZXJuaW9uIHdpdGggYW5vdGhlciBvbmUgZW5zdXJpbmcgdGhhdCB0aGUgZGVsdGEgYmV0d2Vlbg0KICAgKiB0aGUgUXVhdCB2YWx1ZXMgaXMgdGhlIHNob3J0ZXN0IHBhdGggb3ZlciB0aGUgaHlwZXJzcGhlcmUuDQogICAqDQogICAqICBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gZGl2aWRlIGJ5Lg0KICAgKi8NCiAgYWxpZ25XaXRoKG90aGVyKSB7DQogICAgaWYgKHRoaXMuZG90KG90aGVyKSA8IDAuMCkgew0KICAgICAgdGhpcy5zZXQoLXRoaXMueCwgLXRoaXMueSwgLXRoaXMueiwgLXRoaXMudyk7DQogICAgfQ0KICB9DQoNCiAgLy8gbXVsdGlwbHkocXVhdCkgew0KICAvLyAgICAgcmV0dXJuIG5ldyBRdWF0KA0KICAvLyAgICAgICAgIHRoaXMueCAqIHF1YXQudyArIHRoaXMudyAqIHF1YXQueCArIHRoaXMueSAqIHF1YXQueiAtIHRoaXMueiAqIHF1YXQueSwNCiAgLy8gICAgICAgICB0aGlzLnkgKiBxdWF0LncgKyB0aGlzLncgKiBxdWF0LnkgKyB0aGlzLnogKiBxdWF0LnggLSB0aGlzLnggKiBxdWF0LnosDQogIC8vICAgICAgICAgdGhpcy56ICogcXVhdC53ICsgdGhpcy53ICogcXVhdC56ICsgdGhpcy54ICogcXVhdC55IC0gdGhpcy55ICogcXVhdC54LA0KICAvLyAgICAgICAgIHRoaXMudyAqIHF1YXQudyAtIHRoaXMueCAqIHF1YXQueCAtIHRoaXMueSAqIHF1YXQueSAtIHRoaXMueiAqIHF1YXQueg0KICAvLyAgICAgKTsNCiAgLy8gfQ0KDQogIC8qKg0KICAgKiBNdWx0aXBsaWVzIHR3byBRdWF0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuDQogICAqDQogICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBtdWx0aXBseS4NCiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAqLw0KICBtdWx0aXBseShvdGhlcikgew0KICAgIGNvbnN0IGF4ID0gdGhpcy5fX2RhdGFbMF07DQogICAgY29uc3QgYXkgPSB0aGlzLl9fZGF0YVsxXTsNCiAgICBjb25zdCBheiA9IHRoaXMuX19kYXRhWzJdOw0KICAgIGNvbnN0IGF3ID0gdGhpcy5fX2RhdGFbM107DQogICAgY29uc3QgYnggPSBvdGhlci5fX2RhdGFbMF07DQogICAgY29uc3QgYnkgPSBvdGhlci5fX2RhdGFbMV07DQogICAgY29uc3QgYnogPSBvdGhlci5fX2RhdGFbMl07DQogICAgY29uc3QgYncgPSBvdGhlci5fX2RhdGFbM107DQoNCiAgICByZXR1cm4gbmV3IFF1YXQoDQogICAgICBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LA0KICAgICAgYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieiwNCiAgICAgIGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsDQogICAgICBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6DQogICAgKQ0KICB9DQoNCiAgLyoqDQogICAqIE11bHRpcGxpZXMgdHdvIFF1YXRzLg0KICAgKg0KICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gbXVsdGlwbHkuDQogICAqLw0KICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICBjb25zdCBheCA9IHRoaXMuX19kYXRhWzBdOw0KICAgIGNvbnN0IGF5ID0gdGhpcy5fX2RhdGFbMV07DQogICAgY29uc3QgYXogPSB0aGlzLl9fZGF0YVsyXTsNCiAgICBjb25zdCBhdyA9IHRoaXMuX19kYXRhWzNdOw0KICAgIGNvbnN0IGJ4ID0gb3RoZXIuX19kYXRhWzBdOw0KICAgIGNvbnN0IGJ5ID0gb3RoZXIuX19kYXRhWzFdOw0KICAgIGNvbnN0IGJ6ID0gb3RoZXIuX19kYXRhWzJdOw0KICAgIGNvbnN0IGJ3ID0gb3RoZXIuX19kYXRhWzNdOw0KDQogICAgdGhpcy5zZXQoDQogICAgICBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LA0KICAgICAgYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieiwNCiAgICAgIGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsDQogICAgICBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6DQogICAgKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IHRoaXMgcXVhdGVyaW9uLg0KICAgKiBEb24ndCBmb3JnZXQgdG8gbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHVubGVzcw0KICAgKiB5b3Ugd2FudCBheGlhbCB0cmFuc2xhdGlvbiBhcyB3ZWxsIGFzIHJvdGF0aW9uLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAqLw0KICByb3RhdGVWZWMzKHZlYzMpIHsNCiAgICBjb25zdCB2cSA9IG5ldyBRdWF0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnosIDAuMCk7DQogICAgY29uc3QgcHEgPSB0aGlzLm11bHRpcGx5KHZxKS5tdWx0aXBseSh0aGlzLmNvbmp1Z2F0ZSgpKTsNCiAgICByZXR1cm4gbmV3IFZlYzMkMShwcS54LCBwcS55LCBwcS56KQ0KICB9DQoNCiAgLyoqDQogICAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gQW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZS4NCiAgICovDQogIHJvdGF0ZVgocmFkKSB7DQogICAgcmFkICo9IDAuNTsNCg0KICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgIGNvbnN0IGF6ID0gdGhpcy56Ow0KICAgIGNvbnN0IGF3ID0gdGhpcy53Ow0KICAgIGNvbnN0IGJ4ID0gTWF0aC5zaW4ocmFkKTsNCiAgICBjb25zdCBidyA9IE1hdGguY29zKHJhZCk7DQoNCiAgICB0aGlzLnggPSBheCAqIGJ3ICsgYXcgKiBieDsNCiAgICB0aGlzLnkgPSBheSAqIGJ3ICsgYXogKiBieDsNCiAgICB0aGlzLnogPSBheiAqIGJ3IC0gYXkgKiBieDsNCiAgICB0aGlzLncgPSBhdyAqIGJ3IC0gYXggKiBieDsNCiAgfQ0KDQogIC8qKg0KICAgKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpcy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIEFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGUuDQogICAqLw0KICByb3RhdGVZKHJhZCkgew0KICAgIHJhZCAqPSAwLjU7DQoNCiAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICBjb25zdCBheSA9IHRoaXMueTsNCiAgICBjb25zdCBheiA9IHRoaXMuejsNCiAgICBjb25zdCBhdyA9IHRoaXMudzsNCiAgICBjb25zdCBieSA9IE1hdGguc2luKHJhZCk7DQogICAgY29uc3QgYncgPSBNYXRoLmNvcyhyYWQpOw0KDQogICAgdGhpcy54ID0gYXggKiBidyAtIGF6ICogYnk7DQogICAgdGhpcy55ID0gYXkgKiBidyArIGF3ICogYnk7DQogICAgdGhpcy56ID0gYXogKiBidyArIGF4ICogYnk7DQogICAgdGhpcy53ID0gYXcgKiBidyAtIGF5ICogYnk7DQogIH0NCg0KICAvKioNCiAgICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXMuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgLSBBbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLg0KICAgKi8NCiAgcm90YXRlWihyYWQpIHsNCiAgICByYWQgKj0gMC41Ow0KDQogICAgY29uc3QgYXggPSB0aGlzLng7DQogICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgY29uc3QgYXcgPSB0aGlzLnc7DQogICAgY29uc3QgYnogPSBNYXRoLnNpbihyYWQpOw0KICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MocmFkKTsNCg0KICAgIHRoaXMueCA9IGF4ICogYncgKyBheSAqIGJ6Ow0KICAgIHRoaXMueSA9IGF5ICogYncgLSBheCAqIGJ6Ow0KICAgIHRoaXMueiA9IGF6ICogYncgKyBhdyAqIGJ6Ow0KICAgIHRoaXMudyA9IGF3ICogYncgLSBheiAqIGJ6Ow0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRoaXMgUXVhdCB0byBhIE1hdDMgKGEgM3gzIG1hdHJpeCkuDQogICAqDQogICAqIEByZXR1cm4ge01hdDN9IC0gVFJldHVybnMgYSBuZXcgTWF0My4NCiAgICovDQogIHRvTWF0MygpIHsNCiAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgIGNvbnN0IHkgPSB0aGlzLnk7DQogICAgY29uc3QgeiA9IHRoaXMuejsNCiAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgIGNvbnN0IHgyID0geCArIHg7DQogICAgY29uc3QgeTIgPSB5ICsgeTsNCiAgICBjb25zdCB6MiA9IHogKyB6Ow0KICAgIGNvbnN0IHh4ID0geCAqIHgyOw0KICAgIGNvbnN0IHl4ID0geSAqIHgyOw0KICAgIGNvbnN0IHl5ID0geSAqIHkyOw0KICAgIGNvbnN0IHp4ID0geiAqIHgyOw0KICAgIGNvbnN0IHp5ID0geiAqIHkyOw0KICAgIGNvbnN0IHp6ID0geiAqIHoyOw0KICAgIGNvbnN0IHd4ID0gdyAqIHgyOw0KICAgIGNvbnN0IHd5ID0gdyAqIHkyOw0KICAgIGNvbnN0IHd6ID0gdyAqIHoyOw0KDQogICAgY29uc3QgbWF0MyA9IG5ldyBNYXQzKCk7DQogICAgbWF0My5fX2RhdGFbMF0gPSAxIC0geXkgLSB6ejsNCiAgICBtYXQzLl9fZGF0YVszXSA9IHl4IC0gd3o7DQogICAgbWF0My5fX2RhdGFbNl0gPSB6eCArIHd5Ow0KDQogICAgbWF0My5fX2RhdGFbMV0gPSB5eCArIHd6Ow0KICAgIG1hdDMuX19kYXRhWzRdID0gMSAtIHh4IC0geno7DQogICAgbWF0My5fX2RhdGFbN10gPSB6eSAtIHd4Ow0KDQogICAgbWF0My5fX2RhdGFbMl0gPSB6eCAtIHd5Ow0KICAgIG1hdDMuX19kYXRhWzVdID0genkgKyB3eDsNCiAgICBtYXQzLl9fZGF0YVs4XSA9IDEgLSB4eCAtIHl5Ow0KDQogICAgcmV0dXJuIG1hdDMNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBYIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIFggYXhpcyBhcyBhIFZlYzMuDQogICAqLw0KICBnZXRYYXhpcygpIHsNCiAgICBjb25zdCB4eSA9IHRoaXMueCAqIHRoaXMueTsNCiAgICBjb25zdCB4eiA9IHRoaXMueCAqIHRoaXMuejsNCiAgICBjb25zdCB5eSA9IHRoaXMueSAqIHRoaXMueTsNCiAgICBjb25zdCB5dyA9IHRoaXMueSAqIHRoaXMudzsNCiAgICBjb25zdCB6eiA9IHRoaXMueiAqIHRoaXMuejsNCiAgICBjb25zdCB6dyA9IHRoaXMueiAqIHRoaXMudzsNCg0KICAgIHJldHVybiBuZXcgVmVjMyQxKDEuMCAtIDIuMCAqICh6eiArIHl5KSwgMi4wICogKHh5ICsgencpLCAyLjAgKiAoeHogLSB5dykpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgWSBheGlzIG9mIHRoaXMgcXVhdGVybmlvbi4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBZIGF4aXMgYXMgYSBWZWMzLg0KICAgKi8NCiAgZ2V0WWF4aXMoKSB7DQogICAgY29uc3QgeHggPSB0aGlzLnggKiB0aGlzLng7DQogICAgY29uc3QgeHkgPSB0aGlzLnggKiB0aGlzLnk7DQogICAgY29uc3QgeHcgPSB0aGlzLnggKiB0aGlzLnc7DQogICAgY29uc3QgeXogPSB0aGlzLnkgKiB0aGlzLno7DQogICAgY29uc3QgenogPSB0aGlzLnogKiB0aGlzLno7DQogICAgY29uc3QgencgPSB0aGlzLnogKiB0aGlzLnc7DQoNCiAgICByZXR1cm4gbmV3IFZlYzMkMSgyLjAgKiAoeHkgLSB6dyksIDEuMCAtIDIuMCAqICh6eiArIHh4KSwgMi4wICogKHl6ICsgeHcpKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIFogYXhpcyBvZiB0aGlzIHF1YXRlcm5pb24uDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgWiBheGlzIGFzIGEgVmVjMy4NCiAgICovDQogIGdldFpheGlzKCkgew0KICAgIGNvbnN0IHh4ID0gdGhpcy54ICogdGhpcy54Ow0KICAgIGNvbnN0IHh6ID0gdGhpcy54ICogdGhpcy56Ow0KICAgIGNvbnN0IHh3ID0gdGhpcy54ICogdGhpcy53Ow0KDQogICAgY29uc3QgeXkgPSB0aGlzLnkgKiB0aGlzLnk7DQogICAgY29uc3QgeXogPSB0aGlzLnkgKiB0aGlzLno7DQogICAgY29uc3QgeXcgPSB0aGlzLnkgKiB0aGlzLnc7DQogICAgY29uc3QgdGVtcCA9IG5ldyBWZWMzJDEoKTsNCg0KICAgIHJldHVybiBuZXcgVmVjMyQxKDIuMCAqICh5dyArIHh6KSwgMi4wICogKHl6IC0geHcpLCAxLjAgLSAyLjAgKiAoeXkgKyB4eCkpDQogIH0NCg0KICAvKioNCiAgICogUmVmbGVjdHMgdGhpcyBxdWF0ZXJuaW9uIGFjY29yZGluZyB0byB0aGUgYXhpcyBwcm92aWRlZC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleCAtIEFuIGludGVnZXIgd2l0aCB2YWx1ZSBvZiAwIGZvciB0aGUgWCBheGlzLCAxIGZvciB0aGUgWSBheGlzLCBhbmQgMiBmb3IgdGhlIFogYXhpcy4NCiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAqLw0KICBtaXJyb3IoYXhpc0luZGV4KSB7DQogICAgc3dpdGNoIChheGlzSW5kZXgpIHsNCiAgICAgIGNhc2UgMDoNCiAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueiwgdGhpcy53LCB0aGlzLngsIHRoaXMueSkNCiAgICAgIGNhc2UgMToNCiAgICAgICAgcmV0dXJuIG5ldyBRdWF0KC10aGlzLncsIHRoaXMueiwgdGhpcy55LCAtdGhpcy54KQ0KICAgICAgY2FzZSAyOg0KICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54LCB0aGlzLnksIHRoaXMueiwgLXRoaXMudykNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgdGhpcyBRdWF0IHRvIGEgTWF0NCAoYSA0eDQgbWF0cml4KS4NCiAgICoNCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICB0b01hdDQoKSB7DQogICAgY29uc3QgeCA9IHRoaXMueDsNCiAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgY29uc3QgdyA9IHRoaXMudzsNCiAgICBjb25zdCB4MiA9IHggKyB4Ow0KICAgIGNvbnN0IHkyID0geSArIHk7DQogICAgY29uc3QgejIgPSB6ICsgejsNCiAgICBjb25zdCB4eCA9IHggKiB4MjsNCiAgICBjb25zdCB5eCA9IHkgKiB4MjsNCiAgICBjb25zdCB5eSA9IHkgKiB5MjsNCiAgICBjb25zdCB6eCA9IHogKiB4MjsNCiAgICBjb25zdCB6eSA9IHogKiB5MjsNCiAgICBjb25zdCB6eiA9IHogKiB6MjsNCiAgICBjb25zdCB3eCA9IHcgKiB4MjsNCiAgICBjb25zdCB3eSA9IHcgKiB5MjsNCiAgICBjb25zdCB3eiA9IHcgKiB6MjsNCg0KICAgIC8vIFNldCB0aGUgY29sdW1ucw0KICAgIGNvbnN0IG1hdDQgPSBuZXcgTWF0NCgpOw0KICAgIG1hdDQuX19kYXRhWzBdID0gMSAtIHl5IC0geno7DQogICAgbWF0NC5fX2RhdGFbNF0gPSB5eCAtIHd6Ow0KICAgIG1hdDQuX19kYXRhWzhdID0genggKyB3eTsNCg0KICAgIG1hdDQuX19kYXRhWzFdID0geXggKyB3ejsNCiAgICBtYXQ0Ll9fZGF0YVs1XSA9IDEgLSB4eCAtIHp6Ow0KICAgIG1hdDQuX19kYXRhWzldID0genkgLSB3eDsNCg0KICAgIG1hdDQuX19kYXRhWzJdID0genggLSB3eTsNCiAgICBtYXQ0Ll9fZGF0YVs2XSA9IHp5ICsgd3g7DQogICAgbWF0NC5fX2RhdGFbMTBdID0gMSAtIHh4IC0geXk7DQoNCiAgICByZXR1cm4gbWF0NA0KICB9DQoNCiAgLyoqDQogICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gUXVhdHMuDQogICAqDQogICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgIC0gVGhlIG90aGVyIFF1YXQgdG8gaW50ZXJwb2xhdGUgYmV0d2Vlbi4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICovDQogIGxlcnAob3RoZXIsIHQpIHsNCiAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVhdCgNCiAgICAgIHRoaXMueCArIHQgKiAob3RoZXIueCAtIHRoaXMueCksDQogICAgICB0aGlzLnkgKyB0ICogKG90aGVyLnkgLSB0aGlzLnkpLA0KICAgICAgdGhpcy56ICsgdCAqIChvdGhlci56IC0gdGhpcy56KSwNCiAgICAgIHRoaXMudyArIHQgKiAob3RoZXIudyAtIHRoaXMudykNCiAgICApOw0KICAgIHJlc3VsdC5ub3JtYWxpemVJblBsYWNlKCk7DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLy8gLyoqDQogIC8vICAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGUuDQogIC8vICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtICBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWQuDQogIC8vICAqIEByZXR1cm5zIHt2ZWM0fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogIC8vICAqLw0KICAvLyByYW5kb20oc2NhbGUgPSAxLjApIHsNCiAgLy8gICAgIGNvbnN0IHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7DQogIC8vICAgICBjb25zdCB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDsNCiAgLy8gICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTsNCg0KICAvLyAgICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7DQogIC8vICAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTsNCiAgLy8gICAgIG91dFsyXSA9IHogKiBzY2FsZTsNCiAgLy8gICAgIHJldHVybiBvdXQ7DQogIC8vIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFN0YXRpYyBNZXRob2RzDQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBuZXcgUXVhdC4NCiAgICogQHBhcmFtIHsuLi5vYmplY3R9IC4uLmFyZ3MgLSBUaGUgLi4uYXJncyBwYXJhbS4NCiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHsNCiAgICByZXR1cm4gbmV3IFF1YXQoLi4uYXJncykNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGEgbmV3IFF1YXQgdG8gd3JhcCBleGlzdGluZyBtZW1vcnkgaW4gYSBidWZmZXIuDQogICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihidWZmZXIsIG9mZnNldCA9IDApIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQsIHVzZSAjY3JlYXRlRnJvbUJ1ZmZlciBpbnN0ZWFkJyk7DQogICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIG9mZnNldCAqIDQpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGBRdWF0YCB1c2luZyBhbiBBcnJheUJ1ZmZlci4NCiAgICoNCiAgICogQHN0YXRpYw0KICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuDQogICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0Lg0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7DQogICAgcmV0dXJuIG5ldyBRdWF0KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXQNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRmxvYXQzMiBlbGVtZW50cyB1c2VkIGJ5IHRoaXMgdHlwZS4gVXNlZCB0byBjYWxjdWxhdGUgc3RvcmFnZSByZXF1aXJlbWVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIG51bUVsZW1lbnRzKCkgew0KICAgIHJldHVybiA0DQogIH0NCg0KICAvKioNCiAgICogQ2xvbmVzIHRoaXMgUXVhdCBhbmQgcmV0dXJucyBhIG5ldyBRdWF0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICovDQogIGNsb25lKCkgew0KICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdLCB0aGlzLl9fZGF0YVszXSkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZXMuDQogICAqDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuDQogICAqLw0KICB0b0pTT04oKSB7DQogICAgcmV0dXJuIHsNCiAgICAgIHg6IHRoaXMueCwNCiAgICAgIHk6IHRoaXMueSwNCiAgICAgIHo6IHRoaXMueiwNCiAgICAgIHc6IHRoaXMudywNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuDQogICAqLw0KICBmcm9tSlNPTihqKSB7DQogICAgdGhpcy5fX2RhdGFbMF0gPSBqLng7DQogICAgdGhpcy5fX2RhdGFbMV0gPSBqLnk7DQogICAgdGhpcy5fX2RhdGFbMl0gPSBqLno7DQogICAgdGhpcy5fX2RhdGFbM10gPSBqLnc7DQogICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKCk7DQogIH0NCg0KICAvKioNCiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgIHRoaXMueCA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMueiA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgIHRoaXMudyA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdRdWF0JywgUXVhdCk7CgovKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovDQoNCi8qKg0KICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmF5IHRoYXQgZW1pdHMgZnJvbSBhbiBvcmlnaW4gaW4gYSBzcGVjaWZpZWQgZGlyZWN0aW9uLg0KICovDQpjbGFzcyBSYXkgew0KICAvKioNCiAgICogQ3JlYXRlIGEgcmF5Lg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHN0YXJ0IC0gVGhlIG9yaWdpbiBvZiB0aGUgcmF5Lg0KICAgKiBAcGFyYW0ge1ZlYzN9IGRpciAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheS4NCiAgICovDQogIGNvbnN0cnVjdG9yKHN0YXJ0ID0gdW5kZWZpbmVkLCBkaXIgPSB1bmRlZmluZWQpIHsNCiAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBWZWMzJDEpIHsNCiAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5zdGFydCA9IG5ldyBWZWMzJDEoKTsNCiAgICB9DQogICAgaWYgKGRpciBpbnN0YW5jZW9mIFZlYzMkMSkgew0KICAgICAgdGhpcy5kaXIgPSBkaXI7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuZGlyID0gbmV3IFZlYzMkMSgpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBHZXQgdGhlIGNsb3Nlc3QgcG9pbnQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gcG9pbnQgLSBUaGUgcG9pbnQgaW4gM0Qgc3BhY2UuDQogICAqIEByZXR1cm4ge1JheX0gLSBSZXR1cm5zIGEgUmF5Lg0KICAgKi8NCiAgY2xvc2VzdFBvaW50KHBvaW50KSB7DQogICAgY29uc3QgdyA9IHBvaW50LnN1YnRyYWN0KHRoaXMuc3RhcnQpOw0KICAgIGNvbnN0IGMxID0gdy5kb3QodGhpcy5kaXIpOw0KICAgIGlmIChjMSA8IE51bWJlci5FUFNJTE9OKSByZXR1cm4gdGhpcy5zdGFydA0KICAgIGNvbnN0IGMyID0gdGhpcy5kaXIuZG90KHRoaXMuZGlyKTsNCiAgICAvLyBpZiAoYzIgPCBOdW1iZXIuRVBTSUxPTikgcmV0dXJuIHRoaXMuc3RhcnQNCiAgICBjb25zdCBmcmFjdCA9IGMxIC8gYzI7DQogICAgcmV0dXJuIHRoaXMuc3RhcnQuYWRkKHRoaXMuZGlyLnNjYWxlKGZyYWN0KSkNCiAgfQ0KDQogIC8qKg0KICAgKiBHZXQgdGhlIGNsb3Nlc3QgcG9pbnQgYXQgYSBkaXN0YW5jZS4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBkaXN0IC0gVGhlIGRpc3RhbmNlIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSYXl9IC0gUmV0dXJucyBhIFJheS4NCiAgICovDQogIHBvaW50QXREaXN0KGRpc3QpIHsNCiAgICByZXR1cm4gdGhpcy5zdGFydC5hZGQodGhpcy5kaXIuc2NhbGUoZGlzdCkpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdHdvIHJheSBwYXJhbXMgdGhhdCByZXByZXNlbnQgdGhlIGNsb3Nlc3QgcG9pbnQgYmV0d2VlbiB0aGUgdHdvIHJheXMuDQogICAqDQogICAqIEBwYXJhbSB7UmF5fSByYXkgLSBUaGUgcmF5IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtSYXl9IC0gUmV0dXJucyBhIFJheS4NCiAgICovDQogIGludGVyc2VjdFJheVZlY3RvcihyYXkpIHsNCiAgICBjb25zdCB1ID0gdGhpcy5kaXI7DQogICAgY29uc3QgdiA9IHJheS5kaXI7DQogICAgY29uc3QgdyA9IHRoaXMuc3RhcnQuc3VidHJhY3QocmF5LnN0YXJ0KTsNCiAgICBjb25zdCBhID0gdS5kb3QodSk7IC8vIGFsd2F5cyA+PSAwDQogICAgY29uc3QgYiA9IHUuZG90KHYpOw0KICAgIGNvbnN0IGMgPSB2LmRvdCh2KTsgLy8gYWx3YXlzID49IDANCiAgICBjb25zdCBkID0gdS5kb3Qodyk7DQogICAgY29uc3QgZSA9IHYuZG90KHcpOw0KICAgIGlmIChhID09IDAuMCAmJiBjID09IDAuMCkgew0KICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyhyYXkuc3RhcnQpDQogICAgfQ0KICAgIGlmIChhID09IDAuMCkgew0KICAgICAgcmV0dXJuIHJheS5jbG9zZXN0UG9pbnQodGhpcy5zdGFydCkNCiAgICB9DQogICAgaWYgKGMgPT0gMC4wKSB7DQogICAgICByZXR1cm4gdGhpcy5jbG9zZXN0UG9pbnQocmF5LnN0YXJ0KQ0KICAgIH0NCiAgICBjb25zdCBEID0gYSAqIGMgLSBiICogYjsgLy8gYWx3YXlzID49IDANCg0KICAgIC8vIGNvbXB1dGUgdGhlIHJheSBwYXJhbWV0ZXJzIG9mIHRoZSB0d28gY2xvc2VzdCBwb2ludHMNCiAgICBsZXQgdGhpc190Ow0KICAgIGxldCByYXlfdDsNCiAgICBpZiAoRCA8IDAuMDAxKSB7DQogICAgICAvLyB0aGUgbGluZXMgYXJlIGFsbW9zdCBwYXJhbGxlbA0KICAgICAgdGhpc190ID0gMC4wOw0KICAgICAgaWYgKGIgPiBjKSB7DQogICAgICAgIC8vIHVzZSB0aGUgbGFyZ2VzdCBkZW5vbWluYXRvcg0KICAgICAgICByYXlfdCA9IGQgLyBiOw0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgcmF5X3QgPSBlIC8gYzsNCiAgICAgIH0NCiAgICB9IGVsc2Ugew0KICAgICAgdGhpc190ID0gKGIgKiBlIC0gYyAqIGQpIC8gRDsNCiAgICAgIHJheV90ID0gKGEgKiBlIC0gYiAqIGQpIC8gRDsNCiAgICB9DQogICAgcmV0dXJuIFt0aGlzX3QsIHJheV90XQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgb25lIHJheSBwYXJhbSByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbg0KICAgKiBvZiB0aGlzIHJheSBhZ2FpbnN0IHRoZSBwbGFuZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiByYXkuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gcGxhbmUgLSBUaGUgcGxhbmUgdG8gaW50ZXJzZWN0IHdpdGguDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaW50ZXJzZWN0UmF5UGxhbmUocGxhbmUpIHsNCiAgICBjb25zdCB3ID0gdGhpcy5zdGFydC5zdWJ0cmFjdChwbGFuZS5zdGFydCk7DQogICAgY29uc3QgRCA9IHBsYW5lLmRpci5kb3QodGhpcy5kaXIpOw0KICAgIGNvbnN0IE4gPSAtcGxhbmUuZGlyLmRvdCh3KTsNCg0KICAgIGlmIChNYXRoLmFicyhEKSA8IE51bWJlci5QUkVDSVNJT04pIHsNCiAgICAgIC8vIHNlZ21lbnQgaXMgcGFyYWxsZWwgdG8gcGxhbmUNCiAgICAgIGlmIChOID09IDAuMCkgcmV0dXJuIC0xLjANCiAgICAgIC8vIHNlZ21lbnQgbGllcyBpbiBwbGFuZQ0KICAgICAgZWxzZSByZXR1cm4gLTEuMCAvLyBubyBpbnRlcnNlY3Rpb24NCiAgICB9DQogICAgLy8gdGhleSBhcmUgbm90IHBhcmFsbGVsDQogICAgLy8gY29tcHV0ZSBpbnRlcnNlY3QgcGFyYW0NCiAgICBjb25zdCBzSSA9IE4gLyBEOw0KICAgIGlmIChzSSA8IC1OdW1iZXIuUFJFQ0lTSU9OKSB7DQogICAgICByZXR1cm4gLTEgLy8gbm8gaW50ZXJzZWN0aW9uDQogICAgfQ0KICAgIHJldHVybiBzSQ0KICB9DQoNCiAgLyoqDQogICAqIENsb25lcyB0aGlzIFJheSBhbmQgcmV0dXJucyBhIG5ldyBSYXkuDQogICAqDQogICAqIEByZXR1cm4ge1JheX0gLSBSZXR1cm5zIGEgbmV3IFJheS4NCiAgICovDQogIGNsb25lKCkgew0KICAgIHJldHVybiBuZXcgUmF5KHRoaXMuc3RhcnQuY2xvbmUoKSwgdGhpcy5kaXIuY2xvbmUoKSkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBSYXkuDQogICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uDQogICAqIEByZXR1cm4ge1JheX0gLSBSZXR1cm5zIGEgbmV3IFJheS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgUmF5KC4uLmFyZ3MpDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICBzdGFydDogdGhpcy5zdGFydCwNCiAgICAgIGRpcjogdGhpcy5kaXIsDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMuc3RhcnQuZnJvbUpTT04oai5zdGFydCk7DQogICAgdGhpcy5kaXIuZnJvbUpTT04oai5kaXIpOw0KICB9DQoNCiAgLyoqDQogICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgdG9TdHJpbmcoKSB7DQogICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpDQogIH0NCn0NCg0KUmVnaXN0cnkucmVnaXN0ZXIoJ1JheScsIFJheSk7CgovKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqLw0KDQpjb25zdCBzY19oZWxwZXIgPSBuZXcgVmVjMyQxKDEsIDEsIDEpOw0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBYZm8gdHJhbnNmb3JtLCB3aGljaCBpcyBhIHRyYW5zZm9ybWF0aW9uIGRlY29tcG9zZWQgaW50byAzIGNvbXBvbmVudCB2YWx1ZXMuIFRyYW5zbGF0aW9uLCBPcmllbnRhdGlvbiwgYW5kIFNjYWxpbmcuDQogKi8NCmNsYXNzIFhmbyB7DQogIC8qKg0KICAgKiBJbml0aWFsaXplcyB0aGUgWGZvIG9iamVjdC4NCiAgICogPGJyPg0KICAgKiAqKk5vdGU6KiogWW91IGNhbiBsZWF2ZSBpdCBlbXB0eSBhbmQgdXNlIG90aGVyIG1ldGhvZHMgdGkgc2V0IHRoZSBzdGF0ZSBvZiB0aGUgY2xhc3MuDQogICAqDQogICAqIEBzZWUgW2BzZXRGcm9tT3RoZXJgXSgjc2V0RnJvbU90aGVyKSBbYGZyb21NYXQ0YF0oI2Zyb21NYXQ0KSBbYHNldEZyb21GbG9hdDMyQXJyYXlgXSgjc2V0RnJvbUZsb2F0MzJBcnJheSkgW2Bmcm9tSlNPTmBdKCNmcm9tSlNPTikNCiAgICoNCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXkgfCBWZWMzfSB0ciAtIFRoZSB0cmFuc2xhdGlvbiB2YWx1ZS4NCiAgICogQHBhcmFtIHtRdWF0fSBvcmkgLSBUaGUgb3JpZW50YXRpb24gdmFsdWUuDQogICAqIEBwYXJhbSB7VmVjM30gc2MgLSBUaGUgc2NhbGluZyB2YWx1ZS4NCiAgICovDQogIGNvbnN0cnVjdG9yKHRyID0gdW5kZWZpbmVkLCBvcmkgPSB1bmRlZmluZWQsIHNjID0gdW5kZWZpbmVkKSB7DQogICAgaWYgKHRyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7DQogICAgICB0aGlzLnNldEZyb21GbG9hdDMyQXJyYXkodHIpOw0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIGlmICh0ciBpbnN0YW5jZW9mIFZlYzMkMSkgew0KICAgICAgdGhpcy50ciA9IHRyOw0KICAgIH0gZWxzZSBpZiAodHIgaW5zdGFuY2VvZiBRdWF0ICYmIG9yaSA9PSB1bmRlZmluZWQgJiYgc2MgPT0gdW5kZWZpbmVkKSB7DQogICAgICB0aGlzLnRyID0gbmV3IFZlYzMkMSgpOw0KICAgICAgdGhpcy5vcmkgPSB0cjsgLy8gWGZvIGNvbnN0cnVjdG9yIHdpdGgganVzdCBhIFF1YXQuDQogICAgICB0aGlzLnNjID0gbmV3IFZlYzMkMSgxLCAxLCAxKTsNCiAgICAgIHJldHVybg0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLnRyID0gbmV3IFZlYzMkMSgpOw0KICAgIH0NCiAgICBpZiAob3JpIGluc3RhbmNlb2YgUXVhdCkgew0KICAgICAgdGhpcy5vcmkgPSBvcmk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMub3JpID0gbmV3IFF1YXQoKTsNCiAgICB9DQogICAgaWYgKHNjIGluc3RhbmNlb2YgVmVjMyQxKSB7DQogICAgICB0aGlzLnNjID0gc2M7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuc2MgPSBuZXcgVmVjMyQxKDEsIDEsIDEpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSB0ciAtIFRoZSB0cmFuc2xhdGlvbiB2YWx1ZS4NCiAgICogQHBhcmFtIHtRdWF0fSBvcmkgLSBUaGUgb3JpZW50YXRpb24gdmFsdWUuDQogICAqIEBwYXJhbSB7VmVjM30gc2MgLSBUaGUgc2NhbGluZyB2YWx1ZS4NCiAgICovDQogIHNldCh0ciwgb3JpLCBzYyA9IHVuZGVmaW5lZCkgew0KICAgIHRoaXMudHIgPSB0cjsNCiAgICB0aGlzLm9yaSA9IG9yaTsNCiAgICBpZiAoc2MgaW5zdGFuY2VvZiBWZWMzJDEpIHRoaXMuc2MgPSBzYzsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdCB1c2luZyBhbm90aGVyIFhmbyBvYmplY3QuDQogICAqDQogICAqIEBwYXJhbSB7WGZvfSBvdGhlciAtIFRoZSBvdGhlciBYZm8gdG8gc2V0IGZyb20uDQogICAqLw0KICBzZXRGcm9tT3RoZXIob3RoZXIpIHsNCiAgICB0aGlzLnRyID0gb3RoZXIudHI7DQogICAgdGhpcy5vcmkgPSBvdGhlci5vcmk7DQogICAgdGhpcy5zYyA9IG90aGVyLnNjOw0KICB9DQoNCiAgLyoqDQogICAqIFZlcmlmaWVzIHRoYXQgdGhlIFhmbyBvYmplY3QgaXMgYW4gYGlkZW50aXR5YCwgY2hlY2tpbmcgdGhhdCB0aGUgdHJhbnNsYXRpb24sIG9yaWVudGF0aW9uIGFuZCBzY2FsaW5nIGF0dHJpYnV0ZXMgYXJlIGluIHRoZWlyIGluaXRpYWwgc3RhdGUuDQogICAqDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGlzSWRlbnRpdHkoKSB7DQogICAgcmV0dXJuIHRoaXMudHIuaXNOdWxsKCkgJiYgdGhpcy5vcmkuaXNJZGVudGl0eSgpICYmIHRoaXMuc2MuaXMxMTEoKQ0KICB9DQoNCiAgLyoqDQogICAqIENoZWNrcyBpZiB0aGlzIFZlYzMgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBhbm90aGVyIFZlYzMuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgYXJlIHRoZSBzYW1lIFZlY3Rvciwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgKi8NCiAgaXNFcXVhbChvdGhlcikgew0KICAgIHJldHVybiB0aGlzLnRyLmlzRXF1YWwob3RoZXIudHIpICYmIHRoaXMub3JpLmlzRXF1YWwob3RoZXIub3JpKSAmJiB0aGlzLnNjLmlzRXF1YWwob3RoZXIuc2MpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgVmVjMiBpcyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIC0gVGhlIHByZWNpc2lvbiB0byB3aGljaCB0aGUgdmFsdWVzIG11c3QgbWF0Y2guDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgKi8NCiAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7DQogICAgcmV0dXJuICgNCiAgICAgIChvdGhlci50ciA/IHRoaXMudHIuYXBwcm94RXF1YWwob3RoZXIudHIsIHByZWNpc2lvbikgOiB0cnVlKSAmJg0KICAgICAgKG90aGVyLm9yaSA/IHRoaXMub3JpLmFwcHJveEVxdWFsKG90aGVyLm9yaSwgcHJlY2lzaW9uKSA6IHRydWUpICYmDQogICAgICAob3RoZXIuc2MgPyB0aGlzLnNjLmFwcHJveEVxdWFsKG90aGVyLnNjLCBwcmVjaXNpb24pIDogdHJ1ZSkNCiAgICApDQogIH0NCg0KICAvKioNCiAgICogVGhlIHNldExvb2tBdCBtZXRob2QuDQogICAqIEBwYXJhbSB7VmVjM30gcG9zIC0gVGhlIHBvc2l0aW9uIHZhbHVlLg0KICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCAtIFRoZSB0YXJnZXQgdmFsdWUuDQogICAqIEBwYXJhbSB7VmVjM30gdXAgLSBUaGUgdXAgdmFsdWUuDQogICAqLw0KICBzZXRMb29rQXQocG9zLCB0YXJnZXQsIHVwKSB7DQogICAgLy8gTm90ZTogV2UgbG9vayBhbG9uZyB0aGUgLXogYXhpcy4gTmVnYXRlIHRoZSBkaXJlY3Rpb24uDQogICAgY29uc3QgZGlyID0gcG9zLnN1YnRyYWN0KHRhcmdldCk7DQogICAgY29uc3QgZGlyTGVuID0gZGlyLmxlbmd0aCgpOw0KICAgIGlmIChkaXJMZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpcicpDQogICAgfQ0KICAgIHRoaXMub3JpLnNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3RvcihkaXIsIHVwKTsNCiAgICB0aGlzLnRyID0gcG9zOw0KICB9DQoNCiAgLyoqDQogICAqIE11bHRpcGxpZXMgdHdvIFhmbyB0cmFuc2Zvcm1zLg0KICAgKg0KICAgKiBAcGFyYW0ge1hmb30geGZvIC0gVGhlIHhmbyB0byBtdWx0aXBseSB3aXRoLg0KICAgKiBAcmV0dXJuIHtYZm99IC0gUmV0dXJucyBhbiBYZm8uDQogICAqLw0KICBtdWx0aXBseSh4Zm8pIHsNCiAgICBsZXQgdGhpc19zYyA9IHRoaXMuc2M7DQogICAgaWYgKHRoaXMuc2MueCAhPSB0aGlzLnNjLnkgfHwgdGhpcy5zYy54ICE9IHRoaXMuc2Mueikgew0KICAgICAgdGhpc19zYyA9IHhmby5vcmkucm90YXRlVmVjMyh0aGlzLnNjKTsNCiAgICAgIGlmIChNYXRoLnNpZ24odGhpc19zYy54KSAhPSBNYXRoLnNpZ24odGhpcy5zYy54KSkgdGhpc19zYy54ID0gLXRoaXNfc2MueDsNCiAgICAgIGlmIChNYXRoLnNpZ24odGhpc19zYy55KSAhPSBNYXRoLnNpZ24odGhpcy5zYy55KSkgdGhpc19zYy55ID0gLXRoaXNfc2MueTsNCiAgICAgIGlmIChNYXRoLnNpZ24odGhpc19zYy56KSAhPSBNYXRoLnNpZ24odGhpcy5zYy56KSkgdGhpc19zYy56ID0gLXRoaXNfc2MuejsNCiAgICB9DQogICAgY29uc3QgcmVzdWx0ID0gbmV3IFhmbygNCiAgICAgIHRoaXMudHIuYWRkKHRoaXMub3JpLnJvdGF0ZVZlYzModGhpc19zYy5tdWx0aXBseSh4Zm8udHIpKSksDQogICAgICB0aGlzLm9yaS5tdWx0aXBseSh4Zm8ub3JpKSwNCiAgICAgIHRoaXNfc2MubXVsdGlwbHkoeGZvLnNjKQ0KICAgICk7DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIFhmbyBvYmplY3QsIGJ1dCByZXR1cm5zLiB0aGUgcmVzdWx0IGFzIGEgbmV3IFhmby4NCiAgICoNCiAgICogQHJldHVybiB7WGZvfSAtIFJldHVybnMgYSBuZXcgWGZvLg0KICAgKi8NCiAgaW52ZXJzZSgpIHsNCiAgICBjb25zdCByZXN1bHQgPSBuZXcgWGZvKCk7DQogICAgcmVzdWx0Lm9yaSA9IHRoaXMub3JpLmludmVyc2UoKTsNCg0KICAgIGlmICh0aGlzLnNjLnggIT0gdGhpcy5zYy55IHx8IHRoaXMuc2MueCAhPSB0aGlzLnNjLnopIHsNCiAgICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgY29kZSBoYXMgbm90IGJlZW4gdGVzdGVkIGFuZA0KICAgICAgLy8gbWF5IG5vdCBiZSBxdWl0ZSBjb3JyZWN0LiBXZSBuZWVkIHRvIHNldHVwDQogICAgICAvLyB1bml0IHRlc3RzIGZvciB0aGlzIGtpbmQgb2Ygc2FtcGxlLg0KICAgICAgLy8gQW4gZXhhbXBsZSB3b3VsZCBiZSB0byBsYXkgb3V0IHNvbWUgYm94ZXMgb24gZGlmZmVyZW50IHJvdGF0aW9ucw0KICAgICAgLy8gYW5kIHdpdGggbm9uLXVuaWZvcm0gc2NhbGUuIFRoZW4gcGFyZW50IHRoZW0gdG9nZXRoZXIuIElmIHRoZXkNCiAgICAgIC8vIHJlbWFpbiBzdGF0aW9uYXJ5LCBhZnRlciBwYXJlbnRpbmcsIHRoZW4gdGhpcyBtYXRoIGlzIGNvcnJlY3QuDQogICAgICByZXN1bHQuc2MgPSByZXN1bHQub3JpLnJvdGF0ZVZlYzModGhpcy5zYyk7DQogICAgICBpZiAoTWF0aC5zaWduKHJlc3VsdC5zYy54KSAhPSBNYXRoLnNpZ24odGhpcy5zYy54KSkgcmVzdWx0LnNjLnggPSAtcmVzdWx0LnNjLng7DQogICAgICBpZiAoTWF0aC5zaWduKHJlc3VsdC5zYy55KSAhPSBNYXRoLnNpZ24odGhpcy5zYy55KSkgcmVzdWx0LnNjLnkgPSAtcmVzdWx0LnNjLnk7DQogICAgICBpZiAoTWF0aC5zaWduKHJlc3VsdC5zYy56KSAhPSBNYXRoLnNpZ24odGhpcy5zYy56KSkgcmVzdWx0LnNjLnogPSAtcmVzdWx0LnNjLno7DQogICAgfSBlbHNlIHsNCiAgICAgIHJlc3VsdC5zYyA9IHRoaXMuc2MuaW52ZXJzZSgpOw0KICAgIH0NCiAgICByZXN1bHQudHIgPSByZXN1bHQub3JpLnJvdGF0ZVZlYzModGhpcy50ci5uZWdhdGUoKS5tdWx0aXBseShyZXN1bHQuc2MpKTsNCiAgICByZXR1cm4gcmVzdWx0DQogIH0NCg0KICAvKioNCiAgICogVHJhbnNmb3JtcyBYZm8gb2JqZWN0IHVzaW5nIGEgYFZlYzNgIG9iamVjdC4gRmlyc3Qgc2NhbGluZyBpdCwgdGhlbiByb3RhdGluZyBhbmQgZmluYWxseSBhZGRpbmcgdGhlIHJlc3VsdCB0byBjdXJyZW50IHRyYW5zbGF0aW9uIG9iamVjdC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRyYW5zZm9ybVZlYzModmVjMykgew0KICAgIHJldHVybiB0aGlzLnRyLmFkZCh0aGlzLm9yaS5yb3RhdGVWZWMzKHRoaXMuc2MubXVsdGlwbHkodmVjMykpKQ0KICB9DQoNCiAgLyoqDQogICAqIENvbnZlcnRzIHRoaXMgWGZvIHRvIGEgTWF0NCAoYSA0eDQgbWF0cml4KS4NCiAgICoNCiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAqLw0KICB0b01hdDQoKSB7DQogICAgY29uc3Qgc2NsID0gbmV3IE1hdDQodGhpcy5zYy54LCAwLCAwLCAwLCAwLCB0aGlzLnNjLnksIDAsIDAsIDAsIDAsIHRoaXMuc2MueiwgMCwgMCwgMCwgMCwgMS4wKTsNCg0KICAgIGNvbnN0IHJvdCA9IHRoaXMub3JpLnRvTWF0NCgpOw0KDQogICAgY29uc3QgdHJuID0gbmV3IE1hdDQoKTsNCiAgICB0cm4udHJhbnNsYXRpb24gPSB0aGlzLnRyOw0KDQogICAgcmV0dXJuIHRybi5tdWx0aXBseShyb3QpLm11bHRpcGx5KHNjbCkNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdCB1c2luZyBNYXQ0Lg0KICAgKg0KICAgKiBAcGFyYW0ge01hdDR9IG1hdDQgLSBUaGUgbWF0NCB2YWx1ZS4NCiAgICovDQogIGZyb21NYXQ0KG1hdDQpIHsNCiAgICB0aGlzLnRyID0gbWF0NC50cmFuc2xhdGlvbjsNCiAgICB0aGlzLm9yaS5zZXRGcm9tTWF0NChtYXQ0KTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdCB1c2luZyBhbiBgRmxvYXQzMmFycmF5YC4NCiAgICogPGJyPg0KICAgKiAqKk5vdGU6KiogWW91IGNhbiBzZXQgdGhlIGJ5dGVPZmZzZXQgaW4geW91ciBgRmxvYXQzMmFycmF5YCBvYmplY3QNCiAgICoNCiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJhcnJheSAtIFRoZSBmbG9hdDMyYXJyYXkgdmFsdWUuDQogICAqLw0KICBzZXRGcm9tRmxvYXQzMkFycmF5KGZsb2F0MzJhcnJheSkgew0KICAgIGlmIChmbG9hdDMyYXJyYXkubGVuZ3RoID09IDcpIHsNCiAgICAgIHRoaXMudHIgPSBuZXcgVmVjMyQxKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0KTsNCiAgICAgIHRoaXMub3JpID0gbmV3IFF1YXQoZmxvYXQzMmFycmF5LmJ1ZmZlciwgZmxvYXQzMmFycmF5LmJ5dGVPZmZzZXQgKyAxMik7DQogICAgICB0aGlzLnNjID0gbmV3IFZlYzMkMSgxLCAxLCAxKTsNCiAgICAgIHJldHVybg0KICAgIH0NCiAgICBpZiAoZmxvYXQzMmFycmF5Lmxlbmd0aCA9PSA4KSB7DQogICAgICB0aGlzLnRyID0gbmV3IFZlYzMkMShmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCk7DQogICAgICB0aGlzLm9yaSA9IG5ldyBRdWF0KGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0ICsgMTIpOw0KICAgICAgY29uc3Qgc2NsID0gZmxvYXQzMmFycmF5WzddOw0KICAgICAgdGhpcy5zYyA9IG5ldyBWZWMzJDEoc2NsLCBzY2wsIHNjbCk7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgaWYgKGZsb2F0MzJhcnJheS5sZW5ndGggPT0gMTApIHsNCiAgICAgIHRoaXMudHIgPSBuZXcgVmVjMyQxKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0KTsNCiAgICAgIHRoaXMub3JpID0gbmV3IFF1YXQoZmxvYXQzMmFycmF5LmJ1ZmZlciwgZmxvYXQzMmFycmF5LmJ5dGVPZmZzZXQgKyAxMik7DQogICAgICB0aGlzLnNjID0gbmV3IFZlYzMkMShmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCArIDIxKTsNCiAgICAgIHJldHVybg0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBYZm8gYW5kIHJldHVybnMgYSBuZXcgWGZvLg0KICAgKg0KICAgKiBAcmV0dXJuIHtYZm99IC0gUmV0dXJucyBhIG5ldyBYZm8uDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IFhmbyh0aGlzLnRyLmNsb25lKCksIHRoaXMub3JpLmNsb25lKCksIHRoaXMuc2MuY2xvbmUoKSkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBYZm8uDQogICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uDQogICAqIEByZXR1cm4ge1hmb30gLSBldHVybnMgYSBuZXcgWGZvLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7DQogICAgcmV0dXJuIG5ldyBYZm8oLi4uYXJncykNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTigpIHsNCiAgICBjb25zdCBqID0gew0KICAgICAgdHI6IHRoaXMudHIudG9KU09OKCksDQogICAgICBvcmk6IHRoaXMub3JpLnRvSlNPTigpLA0KICAgIH07DQogICAgaWYgKCF0aGlzLnNjLmlzMTExKCkpIGouc2MgPSB0aGlzLnNjLnRvSlNPTigpOw0KICAgIHJldHVybiBqDQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuDQogICAqLw0KICBmcm9tSlNPTihqKSB7DQogICAgdGhpcy50ci5mcm9tSlNPTihqLnRyKTsNCiAgICB0aGlzLm9yaS5mcm9tSlNPTihqLm9yaSk7DQogICAgaWYgKGouc2MpIHsNCiAgICAgIHRoaXMuc2MuZnJvbUpTT04oai5zYyk7DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAqDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKi8NCiAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICB0aGlzLnRyLnJlYWRCaW5hcnkocmVhZGVyKTsNCiAgICB0aGlzLm9yaS5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgdGhpcy5zYy5yZWFkQmluYXJ5KHJlYWRlcik7DQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICB0b1N0cmluZygpIHsNCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdYZm8nLCBYZm8pOwoKLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovDQoNCi8qKg0KICogUmVwcmVzZW50cyBhIGJveCBpbiAyRCBzcGFjZS4gTmVlZGluZyB0d28gVmVjMiB2ZWN0b3JzIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnMNCiAqLw0KY2xhc3MgQm94MiB7DQogIC8qKg0KICAgKiBDcmVhdGVzIGEgQm94MiBvYmplY3QgdXNpbmcgVmVjMnMuDQogICAqIEluIGNhc2UgdGhlIHBhcmFtZXRlcnMgYXJlIG5vdCBwYXNzZWQgYnksIHRoZWlyIHZhbHVlcyBhcmUgcHJlLWRlZmluZWQ6DQogICAqIDxicj4NCiAgICogcDAgaXMgYSBWZWMyIHdpdGgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9QT1NJVElWRV9JTkZJTklUWXxgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYH0NCiAgICogPGJyPg0KICAgKiBwMSBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL05FR0FUSVZFX0lORklOSVRZfGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgfQ0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzJ9IHAwIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAyRCBib3guDQogICAqIEBwYXJhbSB7VmVjMn0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC4NCiAgICovDQogIGNvbnN0cnVjdG9yKHAwID0gdW5kZWZpbmVkLCBwMSA9IHVuZGVmaW5lZCkgew0KICAgIGlmIChwMCBpbnN0YW5jZW9mIFZlYzIpIHsNCiAgICAgIHRoaXMucDAgPSBwMDsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5wMCA9IG5ldyBWZWMyKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTsNCiAgICB9DQogICAgaWYgKHAxIGluc3RhbmNlb2YgVmVjMikgew0KICAgICAgdGhpcy5wMSA9IHAxOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLnAxID0gbmV3IFZlYzIoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIGJvdGggVmVjdDIgcG9pbnRzDQogICAqDQogICAqIEBwYXJhbSB7VmVjMn0gcDAgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC4NCiAgICogQHBhcmFtIHtWZWMyfSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94Lg0KICAgKi8NCiAgc2V0KHAwLCBwMSkgew0KICAgIHRoaXMucDAgPSBwMDsNCiAgICB0aGlzLnAxID0gcDE7DQogIH0NCg0KICAvKioNCiAgICogUmVzZXRzIHRoZSBib3gyIGJhY2sgdG8gYW4gdW5pbml0aWFsaXplZCBzdGF0ZS4NCiAgICoNCiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfQ0KICAgKiBhbmQge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9ORUdBVElWRV9JTkZJTklUWXxgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZYH0NCiAgICovDQogIHJlc2V0KCkgew0KICAgIHRoaXMucDAueCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsNCiAgICB0aGlzLnAxLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgdGhpcy5wMC55ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOw0KICAgIHRoaXMucDEueSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm94IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGNvbnRhaW4gYSBwb2ludC4NCiAgICoNCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaXNWYWxpZCgpIHsNCiAgICByZXR1cm4gKA0KICAgICAgdGhpcy5wMC54ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJg0KICAgICAgdGhpcy5wMS54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAmJg0KICAgICAgdGhpcy5wMC55ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJg0KICAgICAgdGhpcy5wMS55ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWQ0KICAgICkNCiAgfQ0KDQogIC8qKg0KICAgKiBFeHBhbmRzIHRoZSBCb3gyIHRvIGNvbnRhaW4gdGhlIG5ldyBwb2ludC4NCiAgICoNCiAgICogQHBhcmFtIHtWZWMyfSBwb2ludCAtIEEgcG9pbnQgcmVwcmVzZW50cyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC4NCiAgICovDQogIGFkZFBvaW50KHBvaW50KSB7DQogICAgaWYgKHRoaXMucDAueCA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueCA8IHRoaXMucDAueCkgdGhpcy5wMC54ID0gcG9pbnQueDsNCiAgICBpZiAodGhpcy5wMC55ID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCBwb2ludC55IDwgdGhpcy5wMC55KSB0aGlzLnAwLnkgPSBwb2ludC55Ow0KDQogICAgaWYgKHRoaXMucDEueSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueCA+IHRoaXMucDEueCkgdGhpcy5wMS54ID0gcG9pbnQueDsNCiAgICBpZiAodGhpcy5wMS55ID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSB8fCBwb2ludC55ID4gdGhpcy5wMS55KSB0aGlzLnAxLnkgPSBwb2ludC55Ow0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBCb3gyLg0KICAgKg0KICAgKiBAcmV0dXJuIHtCb3gyfSAtIFJldHVybnMgYSBCb3gyLg0KICAgKi8NCiAgc2l6ZSgpIHsNCiAgICByZXR1cm4gdGhpcy5wMS5zdWJ0cmFjdCh0aGlzLnAwKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBCb3gyIC0gdGhlIHNhbWUgYXMgc2l6ZSgpLg0KICAgKg0KICAgKiBAcmV0dXJuIHtCb3gyfSAtIFJldHVybnMgYSBCb3gyLg0KICAgKi8NCiAgZGlhZ29uYWwoKSB7DQogICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgYSBCb3gyLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBWZWMyLg0KICAgKi8NCiAgY2VudGVyKCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7DQogICAgcmVzdWx0LnNjYWxlSW5QbGFjZSgwLjUpOw0KICAgIHJlc3VsdC5hZGRJblBsYWNlKHRoaXMucDApOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBCb3gyLg0KICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtCb3gyfSAtIFJldHVybnMgYSBuZXcgQm94Mi4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgQm94MiguLi5hcmdzKQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBFbmNvZGVzIGBCb3gyYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTigpIHsNCiAgICByZXR1cm4gew0KICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksDQogICAgICBwMTogdGhpcy5wMS50b0pTT04oKSwNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ2FsbHMgYHRvSlNPTmAgbWV0aG9kIGFuZCBzdHJpbmdpZmllcyBpdC4NCiAgICoNCiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICB0b1N0cmluZygpIHsNCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdCb3gyJywgQm94Mik7CgovKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovDQoNCi8qKg0KICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc3BoZXJlLg0KICoNCiAqIEBleHRlbmRzIEF0dHJWYWx1ZQ0KICovDQpjbGFzcyBTcGhlcmVUeXBlIGV4dGVuZHMgQXR0clZhbHVlIHsNCiAgLyoqDQogICAqIENyZWF0ZSBhIHNwaGVyZS4NCiAgICogQHBhcmFtIHtWZWMzfSBwb3MgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHNwaGVyZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS4NCiAgICovDQogIGNvbnN0cnVjdG9yKHBvcywgcmFkaXVzID0gMCkgew0KICAgIHN1cGVyKCk7DQogICAgaWYgKHBvcyBpbnN0YW5jZW9mIFZlYzMkMSkgew0KICAgICAgdGhpcy5wb3MgPSBwb3M7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMucG9zID0gbmV3IFZlYzMkMSgpOw0KICAgIH0NCiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1czsNCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBzcGhlcmUgYW5kIHJldHVybnMgYSBuZXcgc3BoZXJlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtTcGhlcmV9IC0gUmV0dXJucyBhIG5ldyBzcGhlcmUuDQogICAqLw0KICBjbG9uZSgpIHsNCiAgICByZXR1cm4gbmV3IFNwaGVyZSh0aGlzLnBvcy5jbG9uZSgpLCB0aGlzLnJhZGl1cykNCiAgfQ0KDQogIC8qKg0KICAgKiBDaGVja3MgaWYgdGhpcyBzcGhlcmUgaW50ZXJzZWN0cyBhIGJveC4NCiAgICoNCiAgICogQHBhcmFtIHtCb3gzfSBib3ggLSBUaGUgYm94IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBpbnRlcnNlY3RzQm94KGJveCkgew0KICAgIHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSh0aGlzKQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFBlcnNpc3RlbmNlDQoNCiAgLyoqDQogICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICBwb3M6IHRoaXMucG9zLnRvSlNPTigpLA0KICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cywNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ2FsbHMgYHRvSlNPTmAgbWV0aG9kIGFuZCBzdHJpbmdpZmllcyBpdC4NCiAgICoNCiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICB0b1N0cmluZygpIHsNCiAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSkNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gU3RhdGljIE1ldGhvZHMNCg0KICAvKioNCiAgICogQ3JlYXRlcyBhIG5ldyBzcGhlcmUuDQogICAqDQogICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uDQogICAqIEByZXR1cm4ge1NwaGVyZX0gLSBSZXR1cm5zIGEgbmV3IHNwaGVyZS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIHN0YXRpYyBjcmVhdGUoLi4uYXJncykgew0KICAgIHJldHVybiBuZXcgU3BoZXJlKC4uLmFyZ3MpDQogIH0NCn0NCg0KUmVnaXN0cnkucmVnaXN0ZXIoJ1NwaGVyZVR5cGUnLCBTcGhlcmVUeXBlKTsKCi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqLw0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGJveCBpbiAzRCBzcGFjZS4NCiAqIFJlcHJlc2VudHMgYSBib3ggaW4gM0Qgc3BhY2UgZGVmaW5lZCBieSB0d28gVmVjMyB2YWx1ZXMgd2hpY2ggZGVmaW5lIG9wcG9zaW5nIGNvcm5lcnMgb2YgdGhlIGJveC4NCiAqLw0KY2xhc3MgQm94MyQxIHsNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBCb3gzIG9iamVjdCB1c2luZyBWZWMzcy4NCiAgICogSW4gY2FzZSB0aGUgcGFyYW1ldGVycyBhcmUgbm90IHBhc3NlZCBieSwgdGhlaXIgdmFsdWVzIGFyZSBwcmUtZGVmaW5lZDoNCiAgICogPGJyPg0KICAgKiBwMCBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfQ0KICAgKiA8YnI+DQogICAqIHAxIGlzIGEgVmVjMiB3aXRoIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTkVHQVRJVkVfSU5GSU5JVFl8YE51bWJlci5ORUdBVElWRV9JTkZJTklUWWB9DQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gcDAgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4NCiAgICogQHBhcmFtIHtWZWMzfSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94Lg0KICAgKi8NCiAgY29uc3RydWN0b3IocDAgPSB1bmRlZmluZWQsIHAxID0gdW5kZWZpbmVkKSB7DQogICAgaWYgKHAwIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7DQogICAgICB0aGlzLnNldEZyb21GbG9hdDMyQXJyYXkocDApOw0KICAgICAgcmV0dXJuDQogICAgfQ0KICAgIGlmIChwMCBpbnN0YW5jZW9mIFZlYzMkMSkgew0KICAgICAgdGhpcy5wMCA9IHAwOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLnAwID0gbmV3IFZlYzMkMShOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTsNCiAgICB9DQogICAgaWYgKHAxIGluc3RhbmNlb2YgVmVjMyQxKSB7DQogICAgICB0aGlzLnAxID0gcDE7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMucDEgPSBuZXcgVmVjMyQxKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBHZXR0ZXIgZm9yIHRoZSBsb3dlciAoeCwgeSwgeikgYm91bmRhcnkgb2YgdGhlIGJveC4NCiAgICoNCiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBtaW51bXVtIFZlYzMuDQogICAqLw0KICBnZXQgbWluKCkgew0KICAgIHJldHVybiB0aGlzLnAwDQogIH0NCg0KICAvKioNCiAgICogR2V0dGVyIGZvciB0aGUgdXBwZXIgKHgsIHksIHopIGJvdW5kYXJ5IG9mIHRoZSBib3guDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgbWludW11bSBWZWMzLg0KICAgKi8NCiAgZ2V0IG1heCgpIHsNCiAgICByZXR1cm4gdGhpcy5wMQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgYm90aCBWZWN0MyBwb2ludHMNCiAgICoNCiAgICogQHBhcmFtIHtWZWMzfSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94Lg0KICAgKiBAcGFyYW0ge1ZlYzN9IHAxIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guDQogICAqLw0KICBzZXQocDAsIHAxKSB7DQogICAgdGhpcy5wMCA9IHAwOw0KICAgIHRoaXMucDEgPSBwMTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXNldHMgdGhlIGJveDMgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLg0KICAgKi8NCiAgcmVzZXQoKSB7DQogICAgdGhpcy5wMC54ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOw0KICAgIHRoaXMucDEueCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTsNCiAgICB0aGlzLnAwLnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgdGhpcy5wMS55ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOw0KICAgIHRoaXMucDAueiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsNCiAgICB0aGlzLnAxLnogPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJveCBoYXMgYmVlbiBleHBhbmRlZCB0byBjb250YWluIGEgcG9pbnQuDQogICAqDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGlzVmFsaWQoKSB7DQogICAgcmV0dXJuICgNCiAgICAgIHRoaXMucDAueCAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgIHRoaXMucDEueCAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgIHRoaXMucDAueSAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgIHRoaXMucDEueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgIHRoaXMucDAueiAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgIHRoaXMucDEueiAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkNCiAgICApDQogIH0NCg0KICAvKioNCiAgICogRXhwYW5kcyB0aGUgQm94MyB0byBjb250YWluIHRoZSBuZXcgcG9pbnQuDQogICAqDQogICAqIEBwYXJhbSB7VmVjM30gcG9pbnQgLSBBIHBvaW50IHJlcHJlc2VudHMgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guDQogICAqLw0KICBhZGRQb2ludChwb2ludCkgew0KICAgIGlmIChwb2ludC54ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBwb2ludC54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgew0KICAgICAgaWYgKHBvaW50LnggPCB0aGlzLnAwLngpIHRoaXMucDAueCA9IHBvaW50Lng7DQogICAgICBpZiAocG9pbnQueCA+IHRoaXMucDEueCkgdGhpcy5wMS54ID0gcG9pbnQueDsNCiAgICB9DQogICAgaWYgKHBvaW50LnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIHBvaW50LnkgIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7DQogICAgICBpZiAocG9pbnQueSA8IHRoaXMucDAueSkgdGhpcy5wMC55ID0gcG9pbnQueTsNCiAgICAgIGlmIChwb2ludC55ID4gdGhpcy5wMS55KSB0aGlzLnAxLnkgPSBwb2ludC55Ow0KICAgIH0NCiAgICBpZiAocG9pbnQueiAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYgcG9pbnQueiAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHsNCiAgICAgIGlmIChwb2ludC56IDwgdGhpcy5wMC56KSB0aGlzLnAwLnogPSBwb2ludC56Ow0KICAgICAgaWYgKHBvaW50LnogPiB0aGlzLnAxLnopIHRoaXMucDEueiA9IHBvaW50Lno7DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIEFkZHMgYEJveDNgIHRvIHRoaXMgYEJveDNgLCBvZiB0aGUgWGZvIGluc3RhbmNlIGlzIHBhc3NlZCBpbiB0aGUgcGFyYW1ldGVycw0KICAgKiBpdCBwcm9jZWVkcyB0byBhcHBseSB0aGUgdHJhbnNmb3JtIGZvciB0aGUgVmVjMy4NCiAgICoNCiAgICogQHBhcmFtIHtCb3gzfSBib3gzIC0gQSAzRCBib3guDQogICAqIEBwYXJhbSB7WGZvfSB4Zm8gLSBBIDNEIHRyYW5zZm9ybS4NCiAgICovDQogIGFkZEJveDMoYm94MywgeGZvID0gdW5kZWZpbmVkKSB7DQogICAgaWYgKHhmbykgew0KICAgICAgLy8gVHJhbnNmb3JtIGVhY2ggY29ybmVyIG9mIHRoZSBCb3gzIGludG8gdGhlIG5ldyBjb29yZGluYXRlIHN5c3RlbS4NCiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMoYm94My5wMCkpOw0KICAgICAgdGhpcy5hZGRQb2ludCh4Zm8udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyQxKGJveDMucDAueCwgYm94My5wMC55LCBib3gzLnAxLnopKSk7DQogICAgICB0aGlzLmFkZFBvaW50KHhmby50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzJDEoYm94My5wMC54LCBib3gzLnAxLnksIGJveDMucDAueikpKTsNCiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMkMShib3gzLnAxLngsIGJveDMucDAueSwgYm94My5wMC56KSkpOw0KICAgICAgdGhpcy5hZGRQb2ludCh4Zm8udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyQxKGJveDMucDAueCwgYm94My5wMS55LCBib3gzLnAxLnopKSk7DQogICAgICB0aGlzLmFkZFBvaW50KHhmby50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzJDEoYm94My5wMS54LCBib3gzLnAwLnksIGJveDMucDEueikpKTsNCiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMkMShib3gzLnAxLngsIGJveDMucDEueSwgYm94My5wMC56KSkpOw0KICAgICAgdGhpcy5hZGRQb2ludCh4Zm8udHJhbnNmb3JtVmVjMyhib3gzLnAxKSk7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMuYWRkUG9pbnQoYm94My5wMCk7DQogICAgICB0aGlzLmFkZFBvaW50KGJveDMucDEpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBCb3gzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtCb3gzfSAtIFJldHVybnMgYSBCb3gzLg0KICAgKi8NCiAgc2l6ZSgpIHsNCiAgICByZXR1cm4gdGhpcy5wMS5zdWJ0cmFjdCh0aGlzLnAwKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBCb3gzIC0gdGhlIHNhbWUgYXMgc2l6ZSgpLg0KICAgKg0KICAgKiBAcmV0dXJuIHtCb3gzfSAtIFJldHVybnMgYSBCb3gzLg0KICAgKi8NCiAgZGlhZ29uYWwoKSB7DQogICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCkNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgYSBCb3gzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBWZWMzLg0KICAgKi8NCiAgY2VudGVyKCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7DQogICAgcmVzdWx0LnNjYWxlSW5QbGFjZSgwLjUpOw0KICAgIHJlc3VsdC5hZGRJblBsYWNlKHRoaXMucDApOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBDb252ZXJ0cyB0aGlzIEJveDMgdG8gYSBNYXQ0IChhIDR4NCBtYXRyaXgpLg0KICAgKg0KICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICovDQogIHRvTWF0NCgpIHsNCiAgICBjb25zdCBzY3ggPSB0aGlzLnAxLnggLSB0aGlzLnAwLng7DQogICAgY29uc3Qgc2N5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55Ow0KICAgIGNvbnN0IHNjeiA9IHRoaXMucDEueiAtIHRoaXMucDAuejsNCiAgICByZXR1cm4gbmV3IE1hdDQoc2N4LCAwLCAwLCAwLCAwLCBzY3ksIDAsIDAsIDAsIDAsIHNjeiwgMCwgdGhpcy5wMC54LCB0aGlzLnAwLnksIHRoaXMucDAueiwgMS4wKQ0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGJvdW5kaW5nIFNwaGVyZSBvZiB0aGUgQm94Mw0KICAgKg0KICAgKiBAcmV0dXJuIHtTcGhlcmVUeXBlfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRCb3VuZGluZ1NwaGVyZSgpIHsNCiAgICByZXR1cm4gbmV3IFNwaGVyZVR5cGUodGhpcy5jZW50ZXIoKSwgdGhpcy5kaWFnb25hbCgpLmxlbmd0aCgpICogMC41KQ0KICB9DQoNCiAgLyoqDQogICAqIERldGVybWluZXMgaWYgdGhpcyBCb3gzIGludGVyc2VjdHMgYSBwbGFuZS4NCiAgICoNCiAgICogQHBhcmFtIHtCb3gzfSBib3ggLSBUaGUgYm94IHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gYWdhaW5zdC4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaW50ZXJzZWN0c0JveChib3gpIHsNCiAgICAvLyBVc2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy4NCiAgICByZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fA0KICAgICAgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fA0KICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fA0KICAgICAgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fA0KICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fA0KICAgICAgYm94Lm1pbi56ID4gdGhpcy5tYXgueg0KICAgICAgPyBmYWxzZQ0KICAgICAgOiB0cnVlDQogIH0NCg0KICAvKioNCiAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEJveDMgaW50ZXJzZWN0cyBhIHNwaGVyZS4NCiAgICoNCiAgICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0Lg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkgew0KICAgIC8vIHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpOw0KDQogICAgLy8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci4NCiAgICAvLyB0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIGNsb3Nlc3RQb2ludCApOw0KDQogICAgLy8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuDQogICAgcmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZChzcGhlcmUuY2VudGVyKSA8PSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cw0KICB9DQoNCiAgLyoqDQogICAqIERldGVybWluZXMgaWYgdGhpcyBCb3gzIGludGVyc2VjdHMgYSBwbGFuZS4NCiAgICoNCiAgICogQHBhcmFtIHtQbGFuZX0gcGxhbmUgLSBUaGUgcGxhbmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0Lg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBpbnRlcnNlY3RzUGxhbmUocGxhbmUpIHsNCiAgICAvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzDQogICAgLy8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uDQoNCiAgICBsZXQgbWluOw0KICAgIGxldCBtYXg7DQoNCiAgICBpZiAocGxhbmUubm9ybWFsLnggPiAwKSB7DQogICAgICBtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7DQogICAgICBtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7DQogICAgfSBlbHNlIHsNCiAgICAgIG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDsNCiAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDsNCiAgICB9DQoNCiAgICBpZiAocGxhbmUubm9ybWFsLnkgPiAwKSB7DQogICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55Ow0KICAgICAgbWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTsNCiAgICB9IGVsc2Ugew0KICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTsNCiAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7DQogICAgfQ0KDQogICAgaWYgKHBsYW5lLm5vcm1hbC56ID4gMCkgew0KICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejsNCiAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7DQogICAgfSBlbHNlIHsNCiAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7DQogICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56Ow0KICAgIH0NCg0KICAgIHJldHVybiBtaW4gPD0gLXBsYW5lLmNvbnN0YW50ICYmIG1heCA+PSAtcGxhbmUuY29uc3RhbnQNCiAgfQ0KDQogIC8qKg0KICAgKiBDbG9uZXMgdGhpcyBCb3gzIGFuZCByZXR1cm5zIGEgbmV3IEJveDMuDQogICAqIEByZXR1cm4ge0JveDN9IC0gUmV0dXJucyBhIG5ldyBCb3gzLg0KICAgKi8NCiAgY2xvbmUoKSB7DQogICAgcmV0dXJuIG5ldyBCb3gzJDEodGhpcy5wMC5jbG9uZSgpLCB0aGlzLnAxLmNsb25lKCkpDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFN0YXRpYyBNZXRob2RzDQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBuZXcgQm94My4NCiAgICogQHBhcmFtIHsuLi5vYmplY3R9IC4uLmFyZ3MgLSBUaGUgLi4uYXJncyBwYXJhbS4NCiAgICogQHJldHVybiB7Qm94M30gLSBSZXR1cm5zIGEgbmV3IEJveDMuDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHsNCiAgICByZXR1cm4gbmV3IEJveDMkMSguLi5hcmdzKQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBzaXplSW5CeXRlcyBtZXRob2QuDQogICAqIEByZXR1cm4ge2FueX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc3RhdGljIHNpemVJbkJ5dGVzKCkgew0KICAgIHJldHVybiAyNA0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBFbmNvZGVzIGBCb3gzYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTigpIHsNCiAgICByZXR1cm4gew0KICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksDQogICAgICBwMTogdGhpcy5wMS50b0pTT04oKSwNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogRGVjb2RlcyBhIEpTT04gb2JqZWN0IHRvIHNldCB0aGUgc3RhdGUgb2YgdGhpcyBjbGFzcy4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuDQogICAqLw0KICBmcm9tSlNPTihqKSB7DQogICAgLy8gV2UgbmVlZCB0byB2ZXJpZnkgdGhhdCBwMCBhbmQgcDEgYXhlcyBhcmUgbnVtZXJpYywgc28gaW4gY2FzZSB0aGV5IGFyZSBub3QsIHdlIHJlc3RvcmUgdGhlbSB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy4NCiAgICAvLyBUaGlzLCBiZWNhdXNlICdJbmZpbml0eScgYW5kICctSW5maW5pdHknIGFyZSBzdHJpbmdpZmllZCBhcyAnbnVsbCcuDQogICAgY29uc3QgcDAgPSB7DQogICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAwLngpID8gai5wMC54IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLA0KICAgICAgeTogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC55KSA/IGoucDAueSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwNCiAgICAgIHo6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDAueikgPyBqLnAwLnogOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksDQogICAgfTsNCiAgICBjb25zdCBwMSA9IHsNCiAgICAgIHg6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDEueCkgPyBqLnAxLnggOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksDQogICAgICB5OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLnkpID8gai5wMS55IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLA0KICAgICAgejogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMS56KSA/IGoucDEueiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwNCiAgICB9Ow0KICAgIHRoaXMucDAuZnJvbUpTT04ocDApOw0KICAgIHRoaXMucDEuZnJvbUpTT04ocDEpOw0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBsb2FkQmluIG1ldGhvZC4NCiAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS4NCiAgICogQHBhcmFtIHthbnl9IGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZU9mZnNldCB2YWx1ZS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIGxvYWRCaW4oZGF0YSwgYnl0ZU9mZnNldCkgew0KICAgIHRoaXMucDAubG9hZEJpbihkYXRhLCBieXRlT2Zmc2V0KTsNCiAgICB0aGlzLnAwLmxvYWRCaW4oZGF0YSwgYnl0ZU9mZnNldCArIDEyKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgc2V0RnJvbUZsb2F0MzJBcnJheSBtZXRob2QuDQogICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyYXJyYXkgLSBUaGUgZmxvYXQzMmFycmF5IHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgc2V0RnJvbUZsb2F0MzJBcnJheShmbG9hdDMyYXJyYXkpIHsNCiAgICB0aGlzLnAwID0gbmV3IFZlYzMkMShmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCk7DQogICAgdGhpcy5wMSA9IG5ldyBWZWMzJDEoZmxvYXQzMmFycmF5LmJ1ZmZlciwgZmxvYXQzMmFycmF5LmJ5dGVPZmZzZXQgKyAxMik7DQogIH0NCg0KICAvKioNCiAgICogQ2FsbHMgYHRvSlNPTmAgbWV0aG9kIGFuZCBzdHJpbmdpZmllcyBpdC4NCiAgICoNCiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICB0b1N0cmluZygpIHsNCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdCb3gzJywgQm94MyQxKTsKCi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8NCg0KLyoqDQogKiBDbGFzcyByZXByZXNlbnRpbmcgYSBwbGFuZS4NCiAqDQogKiBAZXh0ZW5kcyBBdHRyVmFsdWUNCiAqLw0KY2xhc3MgUGxhbmVUeXBlIGV4dGVuZHMgQXR0clZhbHVlIHsNCiAgLyoqDQogICAqIENyZWF0ZSBhIHBsYW5lLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbCAtIFRoZSBub3JtYWwgb2YgdGhlIHBsYW5lLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB3IHZhbHVlLg0KICAgKi8NCiAgY29uc3RydWN0b3Iobm9ybWFsLCB3ID0gMCkgew0KICAgIHN1cGVyKCk7DQogICAgaWYgKG5vcm1hbCBpbnN0YW5jZW9mIFZlYzMkMSkgew0KICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7DQogICAgfSBlbHNlIHsNCiAgICAgIHRoaXMubm9ybWFsID0gbmV3IFZlYzMkMSgpOw0KICAgIH0NCiAgICB0aGlzLncgPSB3Ow0KICB9DQoNCiAgLyoqDQogICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB6IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB3IHZhbHVlLg0KICAgKi8NCiAgc2V0KHgsIHksIHosIHcpIHsNCiAgICB0aGlzLm5vcm1hbC5zZXQoeCwgeSwgeik7DQogICAgdGhpcy53ID0gdzsNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGV0IGRpdmlkZVNjYWxhciBtZXRob2QNCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgKi8NCiAgZGl2aWRlU2NhbGFyKHZhbHVlKSB7DQogICAgdGhpcy5ub3JtYWwuc2NhbGVJblBsYWNlKDEgLyB2YWx1ZSk7DQogICAgdGhpcy53IC89IHZhbHVlOw0KICB9DQoNCiAgLyoqDQogICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byB0aGlzIHBsYWNlLg0KICAgKg0KICAgKiBAcGFyYW0ge1ZlYzN9IHBvaW50IC0gVGhlIHBvaW50IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJyZXR1cm4gdmFsdWUuDQogICAqLw0KICBkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHsNCiAgICByZXR1cm4gcG9pbnQuZG90KHRoaXMubm9ybWFsKSArIHRoaXMudw0KICB9DQoNCiAgLyoqDQogICAqIE5vcm1hbGl6ZSB0aGlzIHBsYW5lIGluIHBsYWNlIG1vZGlmeWluZyBpdHMgdmFsdWVzLg0KICAgKi8NCiAgbm9ybWFsaXplSW5QbGFjZSgpIHsNCiAgICBjb25zdCBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7DQogICAgdGhpcy5ub3JtYWwuc2NhbGVJblBsYWNlKGludmVyc2VOb3JtYWxMZW5ndGgpOw0KICAgIHRoaXMudyAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoOw0KICB9DQoNCiAgLyoqDQogICAqIENsb25lcyB0aGlzIHBsYW5lIGFuZCByZXR1cm5zIGEgbmV3IHBsYW5lLg0KICAgKg0KICAgKiBAcmV0dXJuIHtQbGFuZX0gLSBSZXR1cm5zIGEgbmV3IHBsYW5lLg0KICAgKi8NCiAgY2xvbmUoKSB7DQogICAgcmV0dXJuIG5ldyBQbGFuZSh0aGlzLm5vcm1hbC5jbG9uZSgpLCB0aGlzLncpDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFN0YXRpYyBNZXRob2RzDQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYSBuZXcgcGxhbmUuDQogICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uDQogICAqIEByZXR1cm4ge1BsYW5lfSAtIFJldHVybnMgYSBuZXcgcGxhbmUuDQogICAqIEBwcml2YXRlDQogICAqLw0KICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHsNCiAgICByZXR1cm4gbmV3IFBsYW5lKC4uLmFyZ3MpDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICBub3JtYWw6IHRoaXMubm9ybWFsLnRvSlNPTigpLA0KICAgICAgdzogdGhpcy53LA0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRvU3RyaW5nKCkgew0KICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKQ0KICB9DQp9DQoNClJlZ2lzdHJ5LnJlZ2lzdGVyKCdQbGFuZVR5cGUnLCBQbGFuZVR5cGUpOwoKLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqLw0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyBhIEZydXN0dW0uIEZydXN0dW1zIGFyZSB1c2VkIHRvIGRldGVybWluZSB3aGF0DQogKiBpcyBpbnNpZGUgdGhlIGNhbWVyYSdzIGZpZWxkIG9mIHZpZXcuDQogKiBAcHJpdmF0ZQ0KICogKi8NCmNsYXNzIEZydXN0dW0gew0KICAvKioNCiAgICogQ3JlYXRlIGEgRnJ1c3R1bQ0KICAgKiBAcGFyYW0ge1BsYW5lVHlwZX0gcDAgLSB0aGUgcDAgdmFsdWUuDQogICAqIEBwYXJhbSB7UGxhbmVUeXBlfSBwMSAtIHRoZSBwMSB2YWx1ZS4NCiAgICogQHBhcmFtIHtQbGFuZVR5cGV9IHAyIC0gdGhlIHAyIHZhbHVlLg0KICAgKiBAcGFyYW0ge1BsYW5lVHlwZX0gcDMgLSB0aGUgcDMgdmFsdWUuDQogICAqIEBwYXJhbSB7UGxhbmVUeXBlfSBwNCAtIHRoZSBwNCB2YWx1ZS4NCiAgICogQHBhcmFtIHtQbGFuZVR5cGV9IHA1IC0gdGhlIHA1IHZhbHVlLg0KICAgKi8NCiAgY29uc3RydWN0b3IocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkgew0KICAgIHRoaXMucGxhbmVzID0gWw0KICAgICAgcDAgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgICAgcDEgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgICAgcDIgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgICAgcDMgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgICAgcDQgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgICAgcDUgfHwgbmV3IFBsYW5lVHlwZSgpLA0KICAgIF07DQogIH0NCg0KICAvKioNCiAgICogVGhlIHNldEZyb21NYXRyaXggY29uZmlndXJlcyBhIEZydXN0dW0gb2JqZWN0IHVzaW5nIGEgbWF0cml4Lg0KICAgKiBUeXBpY2FsbHkgdGhlIG1hdHJpeCBpcyBhIG1vZGVsIHZpZXcgcHJvamVjdGlvbiBtYXRyaXguDQogICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBtYXRyaXggdG8gdXNlLg0KICAgKi8NCiAgc2V0RnJvbU1hdHJpeChtYXQ0KSB7DQogICAgY29uc3QgbSA9IG1hdDQ7DQogICAgY29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7DQogICAgcGxhbmVzWzBdLnNldChtLm0wMyAtIG0ubTAwLCBtLm0xMyAtIG0ubTEwLCBtLm0yMyAtIG0ubTIwLCBtLm0zMyAtIG0ubTMwKTsNCiAgICBwbGFuZXNbMV0uc2V0KG0ubTAzICsgbS5tMDAsIG0ubTEzICsgbS5tMTAsIG0ubTIzICsgbS5tMjAsIG0ubTMzICsgbS5tMzApOw0KICAgIHBsYW5lc1syXS5zZXQobS5tMDMgKyBtLm0wMSwgbS5tMTMgKyBtLm0xMSwgbS5tMjMgKyBtLm0yMSwgbS5tMzMgKyBtLm0zMSk7DQogICAgcGxhbmVzWzNdLnNldChtLm0wMyAtIG0ubTAxLCBtLm0xMyAtIG0ubTExLCBtLm0yMyAtIG0ubTIxLCBtLm0zMyAtIG0ubTMxKTsNCiAgICBwbGFuZXNbNF0uc2V0KG0ubTAzIC0gbS5tMDIsIG0ubTEzIC0gbS5tMTIsIG0ubTIzIC0gbS5tMjIsIG0ubTMzIC0gbS5tMzIpOw0KICAgIHBsYW5lc1s1XS5zZXQobS5tMDMgKyBtLm0wMiwgbS5tMTMgKyBtLm0xMiwgbS5tMjMgKyBtLm0yMiwgbS5tMzMgKyBtLm0zMik7DQoNCiAgICBwbGFuZXMuZm9yRWFjaCgocGxhbmUpID0+IHBsYW5lLm5vcm1hbGl6ZUluUGxhY2UoKSk7DQogIH0NCg0KICAvKioNCiAgICogVGVzdHMgYSBib3ggdG8gc2VlIGlmIGl0IGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgZnJ1c3R1bS4NCiAgICogQHBhcmFtIHtCb3gzfSBib3gzIC0gVGhlIGJveCB0byB0ZXN0Lg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGZydXN0dW0gaW50ZXJzZWN0cyB0aGUgYm94Lg0KICAgKi8NCiAgaW50ZXJzZWN0c0JveChib3gzKSB7DQogICAgY29uc3QgcCA9IG5ldyBWZWMzJDEoKTsNCiAgICBjb25zdCBwbGFuZXMgPSB0aGlzLnBsYW5lczsNCiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBib3gzOw0KDQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHsNCiAgICAgIGNvbnN0IHBsYW5lID0gcGxhbmVzW2ldOw0KDQogICAgICAvLyBjb3JuZXIgYXQgbWF4IGRpc3RhbmNlDQogICAgICBwLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBtYXgueCA6IG1pbi54Ow0KICAgICAgcC55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gbWF4LnkgOiBtaW4ueTsNCiAgICAgIHAueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IG1heC56IDogbWluLno7DQoNCiAgICAgIGlmIChwbGFuZS5kaXN0YW5jZVRvUG9pbnQocCkgPCAwKSByZXR1cm4gZmFsc2UNCiAgICB9DQogICAgcmV0dXJuIHRydWUNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKCkgew0KICAgIHJldHVybiB7DQogICAgICBwMDogdGhpcy5wMC50b0pTT04oKSwNCiAgICAgIHAxOiB0aGlzLnAxLnRvSlNPTigpLA0KICAgICAgcDI6IHRoaXMucDIudG9KU09OKCksDQogICAgICBwMzogdGhpcy5wMy50b0pTT04oKSwNCiAgICAgIHA0OiB0aGlzLnA0LnRvSlNPTigpLA0KICAgICAgcDU6IHRoaXMucDUudG9KU09OKCksDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMucDAuZnJvbUpTT04oai5wMCk7DQogICAgdGhpcy5wMS5mcm9tSlNPTihqLnAxKTsNCiAgICB0aGlzLnAyLmZyb21KU09OKGoucDIpOw0KICAgIHRoaXMucDMuZnJvbUpTT04oai5wMyk7DQogICAgdGhpcy5wNC5mcm9tSlNPTihqLnA0KTsNCiAgICB0aGlzLnA1LmZyb21KU09OKGoucDUpOw0KICB9DQoNCiAgLyoqDQogICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgdG9TdHJpbmcoKSB7DQogICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpDQogIH0NCn0NCg0KUmVnaXN0cnkucmVnaXN0ZXIoJ0ZydXN0dW0nLCBGcnVzdHVtKTsKCi8qKg0KICogUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlbWl0dGluZyBldmVudHMgdW5kZXIgZ2l2ZW4gbmFtZXMsIGFuZCByZWdpc3RlcmluZyBsaXN0ZW5lcnMgdG8gdGhvc2UgZXZlbnRzLg0KICogVGhpcyBpcyBhIGJhc2UgY2xhc3MgZm9yIG1vc3QgY2xhc3NlcyBpbiB0aGUgU2NlbmUgVHJlZSBhbmQgUmVuZGVyZXIsIGVuYWJsaW5nIG9ic2VydmVycyB0byBsaXN0ZW4gdG8gY2hhbmdlcyB0aHJvdWdob3V0IHRoZSBzeXN0ZW0uDQogKiBUaGUgaW50ZXJmYWNlIGV4cG9zZWQgaXMgc2ltaWxhciB0byBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpIGluIE5vZGUuDQogKg0KICogU2ltaWxhciB0byBob3cgdGhlIERPTSBldmVudCBzeXN0ZW0gaW4gdGhlIGJyb3dzZXIgd29ya3MsIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBieSBuYW1lLg0KICogRXhhbXBsZTogUmVnaXN0ZXJpbmcgYSBsaXN0ZW5lciBmb3IgYSBjdXN0b20gZXZlbnQsIGFuZCB0aGVuIGVtaXR0aW5nIHRoYXQgZXZlbnQuDQogKiBgYGBqYXZhc2NyaXB0DQogKiAgY29uc3QgZWUgPSBuZXcgRXZlbnRFbWl0dGVyKCkNCiAqDQogKiAgZWUub24oJ215RXZlbnQnLCAoZXZlbnQpID0+IHsNCiAqICAgIGNvbnNvbGUubG9nKCdNeSBFdmVudCB3YXMgZW1pdHRlZDonLCBldmVudCkNCiAqICB9KQ0KICoNCiAqICBlZS5lbWl0KCdteUV2ZW50JywgeyBkYXRhOiA0MiB9KQ0KICogYGBgDQogKg0KICoNCiAqLw0KY2xhc3MgRXZlbnRFbWl0dGVyIHsNCiAgLyoqDQogICAqIEluaXRpYWxpemVzIGFuIGVtcHR5IGBsaXN0ZW5lcnNgIG1hcCB0aGF0IHdpbGwgaG9zdCBhbGwgdGhlIGV2ZW50cywNCiAgICogd2hpY2ggaW1wbGllcyB0aGF0IGl0IGRvZXNuJ3QgYWxsb3cgbXVsdGlwbGUgZXZlbnRzIHdpdGggdGhlIHNhbWUgbmFtZS4NCiAgICogPGJyPg0KICAgKi8NCiAgY29uc3RydWN0b3IoKSB7DQogICAgdGhpcy5saXN0ZW5lcnMgPSB7fTsNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gZXZlbnQgbmFtZS4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4NCiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24oY2FsbGJhY2spLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gSWQgdG8gcmVmZXJlbmNlIHRoZSBsaXN0ZW5lci4NCiAgICovDQogIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHsNCiAgICBpZiAoIWxpc3RlbmVyKSB7DQogICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2sgZnVuY3Rpb24gKGxpc3RlbmVyKS4nKQ0KICAgIH0NCg0KICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkgew0KICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdOw0KICAgIH0NCg0KICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07DQoNCiAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpICE9IC0xKSB7DQogICAgICB0aHJvdyBuZXcgRXJyb3IoYExpc3RlbmVyICIke2xpc3RlbmVyLm5hbWV9IiBhbHJlYWR5IGNvbm5lY3RlZCB0byBldmVudCAiJHtldmVudE5hbWV9Ii5gKQ0KICAgIH0NCg0KICAgIC8vIFRPRE86IERlcHJlY2F0ZSBhbG9uZ3NpZGUgI2FkZExpc3RlbmVyLg0KICAgIGNvbnN0IGlkID0gbGlzdGVuZXJzLmxlbmd0aDsNCiAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7DQoNCiAgICByZXR1cm4gaWQNCiAgfQ0KDQogIC8qKg0KICAgKiBTaW1pbGFyIHRvIHRoZSBgb25gIG1ldGhvZCB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLA0KICAgKiBpdCBpcyBhdXRvbWF0aWNhbGx5IHVucmVnaXN0ZXJlZCBtZWFuaW5nIHRoYXQgdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25lIHRpbWUuDQogICAqDQogICAqIFVzZWZ1bCBmb3IgZXZlbnRzIHRoYXQgd2UgZXhwZWN0IHRvIHRyaWdnZXIgb25lIHRpbWUsIHN1Y2ggYXMgd2hlbiBhc3NldHMgbG9hZC4NCiAgICogYGBgamF2YXNjcmlwdA0KICAgKiBjb25zdCBhc3NldCA9IG5ldyBBc3NldCgpOw0KICAgKiBhc3NldC5vbmNlKCdsb2FkZWQnLCAoKSA9PiB7DQogICAqICAgY29uc29sZS5sb2coIllheSEgdGhlIGFzc2V0IGlzIGxvYWRlZCIpDQogICAqIH0pDQogICAqIGBgYA0KICAgKg0KICAgKi8NCiAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7DQogICAgY29uc3QgY2IgPSAoZXZlbnQpID0+IHsNCiAgICAgIGxpc3RlbmVyKGV2ZW50KTsNCiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgY2IpOw0KICAgIH07DQoNCiAgICB0aGlzLm9uKGV2ZW50TmFtZSwgY2IpOw0KICB9DQoNCiAgLyoqDQogICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHVzaW5nIGVpdGhlciB0aGUgZnVuY3Rpb24gb3IgdGhlIGluZGV4IGlkLiBEZXBlbmRzIG9uIHdoYXQgaXMgcGFzc2VkIGluLg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50Lg0KICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bWJlcn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgdGhlIGlkIG51bWJlci4NCiAgICovDQogIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7DQogICAgaWYgKCFsaXN0ZW5lcikgew0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrIGZ1bmN0aW9uIChsaXN0ZW5lcikuJykNCiAgICB9DQoNCiAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09ICdudW1iZXInKSB7DQogICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVuLXJlZ2lzdGVyIHVzaW5nIHRoZSBvcmlnaW5hbCBsaXN0ZW5lciBpbnN0ZWFkLicpOw0KICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lckJ5SWQoZXZlbnROYW1lLCBsaXN0ZW5lcik7DQogICAgICByZXR1cm4NCiAgICB9DQoNCiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdOw0KDQogICAgY29uc3QgaWRzID0gW107DQoNCiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZSwgaSkgPT4gew0KICAgICAgaWYgKGUgPT09IGxpc3RlbmVyKSB7DQogICAgICAgIGlkcy5wdXNoKGkpOw0KICAgICAgfQ0KICAgIH0pOw0KDQogICAgaWYgKGlkcy5sZW5ndGggPT0gMCkgew0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaXN0ZW5lciAiJHtsaXN0ZW5lci5uYW1lfSIgaXMgbm90IGNvbm5lY3RlZCB0byAiJHtldmVudE5hbWV9IiBldmVudGApDQogICAgfSBlbHNlIHsNCiAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7DQogICAgICAgIGxpc3RlbmVyc1tpZF0gPSB1bmRlZmluZWQ7DQogICAgICB9DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIEBkZXByZWNhdGVkIFVzZSAjb24gaW5zdGVhZC4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4NCiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24oY2FsbGJhY2spLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gSWQgdG8gcmVmZXJlbmNlIHRoZSBsaXN0ZW5lci4NCiAgICovDQogIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjb24gaW5zdGVhZC4nKTsNCg0KICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpDQogIH0NCg0KICAvKioNCiAgICogQGRlcHJlY2F0ZWQgVXNlICNvZmYgaW5zdGVhZC4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4NCiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uDQogICAqLw0KICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7DQogICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI29mZiBpbnN0ZWFkLicpOw0KDQogICAgdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7DQogIH0NCg0KICAvKioNCiAgICogQGRlcHJlY2F0ZWQgVXNlICNvZmYsIHBhc3NpbmcgdGhlIGxpc3RlbmVyIGl0c2VsZiBpbnN0ZWFkIG9mIHRoZSBpZC4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGhlIGlkIHJldHVybmVkIGJ5IGFkZExpc3RlbmVyDQogICAqLw0KICByZW1vdmVMaXN0ZW5lckJ5SWQoZXZlbnROYW1lLCBpZCkgew0KICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNvZmYsIHBhc3NpbmcgdGhlIGxpc3RlbmVyIGl0c2VsZiBpbnN0ZWFkIG9mIHRoZSBpZC4nKTsNCg0KICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07DQoNCiAgICBpZiAoIWxpc3RlbmVycykgew0KICAgICAgY29uc29sZS53YXJuKCdjYWxsYmFjayA6JyArIGlkICsgJyB3YXMgbm90IGNvbm5lY3RlZCB0byB0aGlzIHNpZ25hbDonICsgZXZlbnROYW1lKTsNCiAgICAgIHJldHVybg0KICAgIH0NCg0KICAgIGlmICghbGlzdGVuZXJzW2lkXSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElEJykNCg0KICAgIGxpc3RlbmVyc1tpZF0gPSB1bmRlZmluZWQ7DQogIH0NCg0KICAvKioNCiAgICogVHJpZ2dlcnMgYWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBpbiBhbiBldmVudC4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4NCiAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfGFueX0gZXZlbnQgLSBUaGUgZGF0YSB5b3Ugd2FudCB0byBwYXNzIGRvd24gdG8gYWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBhcyBwYXJhbWV0ZXIuDQogICAqLw0KICBlbWl0KGV2ZW50TmFtZSwgZXZlbnQpIHsNCiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdOw0KDQogICAgbGlzdGVuZXJzLmZvckVhY2goKGZuKSA9PiB7DQogICAgICAvLyBTa2lwIGRpc2Nvbm5lY3RlZCBsaXN0ZW5lcnMuDQogICAgICBpZiAoZm4pIHsNCiAgICAgICAgZm4oZXZlbnQpOw0KICAgICAgfQ0KICAgIH0pOw0KICB9DQp9CgovKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi8NCg0KLy8gRXhwbGljaXQgaW1wb3J0IG9mIGZpbGVzIHRvIGF2b2lkIGltcG9ydGluZyBhbGwgdGhlIHBhcmFtZXRlciB0eXBlcy4NCi8vIE5vdGU6IFNvb24gdGhlc2UgaW1wb3J0cyBzaG91bGQgYmUgcmVtb3ZlZCwgb25jZSBhbGwgY29kZSBhdm9pZHMgY2FsbGluZw0KLy8gJ2FkZFBhcmFtZXRlcicgd2l0aG91dCB0aGUgcGFyYW1ldGVyIGluc3RhbmNlLg0KDQpsZXQgY291bnRlciA9IDA7DQoNCi8qKg0KICogQ2xhc3MgdGhhdCBhbGxvd3Mgb3RoZXIgY2xhc3NlcyB0byBiZSBwYXJhbWV0ZXJpemVkIGJ5IGBQYXJhbWV0ZXJgIHR5cGUgb2Ygb2JqZWN0cy4NCiAqIE5vdCBvbmx5IGhvc3RpbmcgcGFyYW1ldGVycywgYnV0IHRoZWlyIGV2ZW50cy4NCiAqDQogKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfQ0KICovDQpjbGFzcyBQYXJhbWV0ZXJPd25lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7DQogIC8qKg0KICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBhcmFtZXRlck93bmVyIGJ5IGluaXRpYWxpemluZyBwYXJhbWV0ZXIgaG9zdGluZyBtYXBwaW5ncyBhbmQgZXZlbnRzLg0KICAgKiA8YnI+DQogICAqIEV2ZXJ5IE9iamVjdCBoYXMgYSB1bmlxdWUgaWRlbnRpZmllciB3aGljaCBpcyBiYXNlZCBvbiBhIGNvdW50ZXIgdGhhdCBpcyBpbmNyZW1lbnRlZC4NCiAgICovDQogIGNvbnN0cnVjdG9yKCkgew0KICAgIHN1cGVyKCk7DQogICAgdGhpcy5fX2lkID0gKytjb3VudGVyOw0KDQogICAgdGhpcy5fX3BhcmFtcyA9IFtdOw0KICAgIHRoaXMuX19wYXJhbU1hcHBpbmcgPSB7fTsNCiAgICB0aGlzLl9fcGFyYW1FdmVudEhhbmRsZXJzID0ge307DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkIG9mIHRoZSBvYmplY3QuDQogICAqIEBwcml2YXRlDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgSWQgb2YgdGhlIFBhcmFtZXRlck93bmVyIG9iamVjdC4NCiAgICovDQogIGdldElkKCkgew0KICAgIHJldHVybiB0aGlzLl9faWQNCiAgfQ0KDQogIC8vIC0tLSBQYXJhbXMgLS0tDQoNCiAgLyoqDQogICAqIEBkZXByZWNhdGVkDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGN1cnJlbnQgb2JqZWN0IGhhcy4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIEFtb3VudCBvZiBwYXJhbWV0ZXJzIGluIGN1cnJlbnQgb2JqZWN0Lg0KICAgKi8NCiAgbnVtUGFyYW1ldGVycygpIHsNCiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjZ2V0TnVtUGFyYW1ldGVycyBpbnN0ZWFkLicpOw0KICAgIHJldHVybiB0aGlzLmdldE51bVBhcmFtZXRlcnMoKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGN1cnJlbnQgb2JqZWN0IGhhcy4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIEFtb3VudCBvZiBwYXJhbWV0ZXJzIGluIGN1cnJlbnQgb2JqZWN0Lg0KICAgKi8NCiAgZ2V0TnVtUGFyYW1ldGVycygpIHsNCiAgICByZXR1cm4gdGhpcy5fX3BhcmFtcy5sZW5ndGgNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGFsbCB0aGUgcGFyYW1ldGVycyBvZiB0aGUgb2JqZWN0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHthcnJheX0gLSBQYXJhbWV0ZXIgTGlzdA0KICAgKi8NCiAgZ2V0UGFyYW1ldGVycygpIHsNCiAgICByZXR1cm4gdGhpcy5fX3BhcmFtcw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgcGFyYW1ldGVyIGluIHBhcmFtZXRlciBsaXN0Lg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUG9zaXRpb24gaW4gdGhlIGFycmF5DQogICAqLw0KICBnZXRQYXJhbWV0ZXJJbmRleChwYXJhbU5hbWUpIHsNCiAgICByZXR1cm4gdGhpcy5fX3BhcmFtTWFwcGluZ1twYXJhbU5hbWVdDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBgUGFyYW1ldGVyYCBvYmplY3QgaW4gYSBnaXZlbiBpbmRleA0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBQb3NpdGlvbiBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBhcnJheQ0KICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gUGFyYW1ldGVyIG9iamVjdCB2YWx1ZQ0KICAgKi8NCiAgZ2V0UGFyYW1ldGVyQnlJbmRleChpbmRleCkgew0KICAgIHJldHVybiB0aGlzLl9fcGFyYW1zW2luZGV4XQ0KICB9DQoNCiAgLyoqDQogICAqIFZhbGlkYXRlcyBpZiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlciBleGlzdHMgaW4gdGhlIG9iamVjdC4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaGFzUGFyYW1ldGVyKHBhcmFtTmFtZSkgew0KICAgIHJldHVybiBwYXJhbU5hbWUgaW4gdGhpcy5fX3BhcmFtTWFwcGluZw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgYFBhcmFtZXRlcmAgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBuYW1lDQogICAqDQogICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuDQogICAqIEByZXR1cm4ge1BhcmFtZXRlcn0gLSBQYXJhbWV0ZXIgb2JqZWN0IHZhbHVlDQogICAqLw0KICBnZXRQYXJhbWV0ZXIocGFyYW1OYW1lKSB7DQogICAgY29uc3QgaW5kZXggPSB0aGlzLl9fcGFyYW1NYXBwaW5nW3BhcmFtTmFtZV07DQogICAgaWYgKGluZGV4ID09IC0xKSByZXR1cm4gbnVsbA0KICAgIHJldHVybiB0aGlzLl9fcGFyYW1zW2luZGV4XQ0KICB9DQoNCiAgLyoqDQogICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3Nlcw0KICAgKiB0byBwZXJmb3JtIGdlbmVyYWwgdXBkYXRlcyAoc2VlIEdMUGFzcyBvciBCYXNlSXRlbSkuDQogICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSB0aGUgcGFyYW1ldGVyLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgX19wYXJhbWV0ZXJWYWx1ZUNoYW5nZWQoZXZlbnQpIHsNCiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlclZhbHVlQ2hhbmdlZCcsIGV2ZW50KTsNCiAgfQ0KDQogIC8qKg0KICAgKiBBZGRzIGBQYXJhbWV0ZXJgIG9iamVjdCB0byB0aGUgb3duZXIncyBwYXJhbWV0ZXIgbGlzdC4NCiAgICoNCiAgICogQGVtaXRzIGBwYXJhbWV0ZXJBZGRlZGAgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcGFyYW0uDQogICAqIEBwYXJhbSB7UGFyYW1ldGVyfSBwYXJhbSAtIFRoZSBwYXJhbWV0ZXIgdG8gYWRkLg0KICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gV2l0aCBgb3duZXJgIGFuZCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuDQogICAqLw0KICBhZGRQYXJhbWV0ZXIocGFyYW0pIHsNCiAgICByZXR1cm4gdGhpcy5pbnNlcnRQYXJhbWV0ZXIocGFyYW0sIHRoaXMuX19wYXJhbXMubGVuZ3RoKQ0KICB9DQoNCiAgLyoqDQogICAqIEFkZHMgYFBhcmFtZXRlcmAgb2JqZWN0IHRvIHRoZSBvd25lcidzIHBhcmFtZXRlciBsaXN0IHVzaW5nIHRoZSBpbmRleC4NCiAgICogSXQgcmVwbGFjZXMgdGhlIGV2ZW50IGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAqDQogICAqDQogICAqIEBlbWl0cyBgcGFyYW1ldGVyQWRkZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLg0KICAgKiBAcGFyYW0ge1BhcmFtZXRlcn0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIGluc2VydC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gV2l0aCBgb3duZXJgIGFuZCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuDQogICAqLw0KICBpbnNlcnRQYXJhbWV0ZXIocGFyYW0sIGluZGV4KSB7DQogICAgY29uc3QgbmFtZSA9IHBhcmFtLmdldE5hbWUoKTsNCiAgICBpZiAodGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXSAhPSB1bmRlZmluZWQpIHsNCiAgICAgIGNvbnNvbGUud2FybignUmVwbGFjaW5nIFBhcmFtZXRlcjonICsgbmFtZSk7DQogICAgICB0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTsNCiAgICB9DQogICAgcGFyYW0uc2V0T3duZXIodGhpcyk7DQogICAgY29uc3QgcGFyYW1DaGFuZ2VkSGFuZGxlciA9IChldmVudCkgPT4gdGhpcy5fX3BhcmFtZXRlclZhbHVlQ2hhbmdlZCh7IC4uLmV2ZW50LCBwYXJhbSB9KTsNCiAgICBwYXJhbS5vbigndmFsdWVDaGFuZ2VkJywgcGFyYW1DaGFuZ2VkSGFuZGxlcik7DQogICAgdGhpcy5fX3BhcmFtRXZlbnRIYW5kbGVyc1tuYW1lXSA9IHBhcmFtQ2hhbmdlZEhhbmRsZXI7DQogICAgdGhpcy5fX3BhcmFtcy5zcGxpY2UoaW5kZXgsIDAsIHBhcmFtKTsNCg0KICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuX19wYXJhbXMubGVuZ3RoOyBpKyspIHsNCiAgICAgIHRoaXMuX19wYXJhbU1hcHBpbmdbdGhpcy5fX3BhcmFtc1tpXS5nZXROYW1lKCldID0gaTsNCiAgICB9DQogICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJBZGRlZCcsIHsgbmFtZSB9KTsNCiAgICByZXR1cm4gcGFyYW0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZW1vdmVzIGBQYXJhbWV0ZXJgIGZyb20gb3duZXIsIGJ5IHVzaW5nIHBhcmFtZXRlcidzIG5hbWUuDQogICAqIEBlbWl0cyBgcGFyYW1ldGVyUmVtb3ZlZGAgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcGFyYW0uDQogICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLg0KICAgKi8NCiAgcmVtb3ZlUGFyYW1ldGVyKG5hbWUpIHsNCiAgICBpZiAodGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlbW92ZSBQYXJhbWV0ZXI6JyArIG5hbWUpDQogICAgfQ0KICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXTsNCiAgICBjb25zdCBwYXJhbSA9IHRoaXMuX19wYXJhbXNbdGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXV07DQoNCiAgICBwYXJhbS5vZmYoJ3ZhbHVlQ2hhbmdlZCcsIHRoaXMuX19wYXJhbUV2ZW50SGFuZGxlcnNbbmFtZV0pOw0KICAgIHRoaXMuX19wYXJhbXMuc3BsaWNlKGluZGV4LCAxKTsNCg0KICAgIGRlbGV0ZSB0aGlzLl9fcGFyYW1NYXBwaW5nW25hbWVdOw0KICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuX19wYXJhbXMubGVuZ3RoOyBpKyspIHsNCiAgICAgIHRoaXMuX19wYXJhbU1hcHBpbmdbdGhpcy5fX3BhcmFtc1tpXS5nZXROYW1lKCldID0gaTsNCiAgICB9DQoNCiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlclJlbW92ZWQnLCB7IG5hbWUgfSk7DQogIH0NCg0KICAvKioNCiAgICogUmVwbGFjZXMgb2xkIGBQYXJhbWV0ZXJgIGJ5IHBhc3NpbmcgYSBuZXcgb25lIHdpdGggdGhlIHNhbWUgbmFtZS4NCiAgICoNCiAgICogQHBhcmFtIHtQYXJhbWV0ZXJ9IHBhcmFtIC0gVGhlIHBhcmFtZXRlciB0byByZXBsYWNlLg0KICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gYFBhcmFtZXRlcmAgd2l0aCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuDQogICAqLw0KICByZXBsYWNlUGFyYW1ldGVyKHBhcmFtKSB7DQogICAgY29uc3QgbmFtZSA9IHBhcmFtLmdldE5hbWUoKTsNCiAgICBpZiAodGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlcGxhY2UgUGFyYW1ldGVyOicgKyBwYXJhbU5hbWUpDQogICAgfQ0KICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXTsNCiAgICB0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTsNCiAgICB0aGlzLmluc2VydFBhcmFtZXRlcihwYXJhbSwgaW5kZXgpOw0KICAgIHJldHVybiBwYXJhbQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBQZXJzaXN0ZW5jZQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKGNvbnRleHQpIHsNCiAgICBjb25zdCBqc29uID0ge307DQogICAgY29uc3QgcGFyYW1zSlNPTiA9IHt9Ow0KICAgIGxldCBzYXZlZFBhcmFtcyA9IDA7DQogICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLl9fcGFyYW1zKSB7DQogICAgICBjb25zdCBwYXJhbUpTT04gPSBwYXJhbS50b0pTT04oY29udGV4dCk7DQogICAgICBpZiAocGFyYW1KU09OKSB7DQogICAgICAgIHBhcmFtc0pTT05bcGFyYW0uZ2V0TmFtZSgpXSA9IHBhcmFtSlNPTjsNCiAgICAgICAgc2F2ZWRQYXJhbXMrKzsNCiAgICAgIH0NCiAgICB9DQogICAgaWYgKHNhdmVkUGFyYW1zID4gMCkganNvbi5wYXJhbXMgPSBwYXJhbXNKU09OOw0KICAgIHJldHVybiBqc29uDQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgKi8NCiAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgIGlmIChqLnBhcmFtcykgew0KICAgICAgZm9yIChjb25zdCBrZXkgaW4gai5wYXJhbXMpIHsNCiAgICAgICAgY29uc3QgcGogPSBqLnBhcmFtc1trZXldOw0KICAgICAgICBjb25zdCBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKGtleSk7DQogICAgICAgIGlmICghcGFyYW0pIGNvbnNvbGUud2FybignUGFyYW0gbm90IGZvdW5kOicgKyBrZXkpOw0KICAgICAgICBlbHNlIHsNCiAgICAgICAgICBpZiAocGoucGFyYW1QYXRoKSB7DQogICAgICAgICAgICBjb250ZXh0LnJlc29sdmVQYXRoKA0KICAgICAgICAgICAgICBwai5wYXJhbVBhdGgsDQogICAgICAgICAgICAgIChwYXJhbSkgPT4gew0KICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVBhcmFtZXRlcihwYXJhbSk7DQogICAgICAgICAgICAgIH0sDQogICAgICAgICAgICAgIChyZWFzb24pID0+IHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byByZXNvbHZlIHNoYXJlZCBwYXJhbWV0ZXI6JyArIHBqLnBhcmFtUGF0aCk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICk7DQogICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgIHBhcmFtLmZyb21KU09OKHBqLCBjb250ZXh0KTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogVXNlcyBwYXNzZWQgaW4gQmluUmVhZGVyIG9iamVjdChjb250YWluaW5nIGFuIEludDMyIGFycmF5IHdpdGggYWxsIHRoZSBwYXJhbWV0ZXJzKSB0byByZWNvbnN0cnVjdCBhbGwgcGFyYW1ldGVycyBzdGF0ZS4NCiAgICogPGJyPg0KICAgKiBJbiBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgYXJyYXksIHByb3BUeXBlIGFuZCBwcm9wTmFtZSBhcmUgZXh0cmFjdGVkIGFuZA0KICAgKiB1c2VkIHRvIGJ1aWxkIHRoZSByaWdodCBgUGFyYW1ldGVyYCBjbGFzcy4gVGhlbiBhbGwgb2YgdGhlbSBhcmUgYWRkZWQgdG8gdGhlIG9iamVjdC4NCiAgICoNCiAgICogQGVtaXRzIGBwYXJhbWV0ZXJBZGRlZGAgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcGFyYW0uDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgKi8NCiAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgd29yaw0KDQogICAgaWYgKGNvbnRleHQudmVyc2lvbnNbJ3plYS1lbmdpbmUnXS5jb21wYXJlKFswLCAwLCAzXSkgPj0gMCkgew0KICAgICAgY29uc3QgbnVtUHJvcHMgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qcm9wczsgaSsrKSB7DQogICAgICAgIGNvbnN0IHByb3BUeXBlID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICAgICAgY29uc3QgcHJvcE5hbWUgPSByZWFkZXIubG9hZFN0cigpOw0KICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLmdldFBhcmFtZXRlcihwcm9wTmFtZSk7DQogICAgICAgIGlmICghcGFyYW0pIHsNCiAgICAgICAgICBwYXJhbSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKHByb3BUeXBlLCBwcm9wTmFtZSk7DQogICAgICAgICAgaWYgKCFwYXJhbSkgew0KICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbnN0cnVjdCBwcm9wOicgKyBwcm9wTmFtZSArICcgb2YgdHlwZTonICsgcHJvcFR5cGUpOw0KICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICB9DQogICAgICAgICAgdGhpcy5hZGRQYXJhbWV0ZXIocGFyYW0pOw0KICAgICAgICB9DQogICAgICAgIHBhcmFtLnJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KTsNCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ29udmVydHMgb2JqZWN0J3MgSlNPTiB2YWx1ZSBhbmQgY29udmVydHMgaXQgdG8gYSBzdHJpbmcuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBTdHJpbmcgb2Ygb2JqZWN0J3MgcGFyYW1ldGVyIGxpc3Qgc3RhdGUuDQogICAqLw0KICB0b1N0cmluZygpIHsNCiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgMikNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gQ2xvbmUgYW5kIERlc3Ryb3kNCg0KICAvKioNCiAgICogQ29waWVzIFBhcmFtZXRlcnMgZnJvbSBhbm90aGVyIGBQYXJhbWV0ZXJPd25lcmAgdG8gY3VycmVudCBvYmplY3QuDQogICAqDQogICAqIEBwYXJhbSB7UGFyYW1ldGVyT3duZXJ9IHNyYyAtIFRoZSBQYXJhbWV0ZXJPd25lciBjb3B5IGZyb20uDQogICAqLw0KICBjb3B5RnJvbShzcmMpIHsNCiAgICAvLyBOb3RlOiBMb29wIG92ZXIgdGhlIHBhcmFtZXRlcnMgaW4gcmV2ZXJzZSBvcmRlciwNCiAgICAvLyB0aGlzIGlzIGJlY2F1c2Ugb2Z0ZW4sIHBhcmFtZXRlciBkZXBlbmRlbmNpZXMNCiAgICAvLyBhcmUgYm90dG9tIHRvIHRvcCAoYm90dG9tIHBhcmFtcyBkZXBlbmRlbnQgb24gaGlnaGVyIHBhcmFtcykuDQogICAgLy8gVGhpcyBtZWFucyB0aGF0IGFzIGEgcGFyYW1ldGVyIGlzIHNldCB3aXRoIGEgbmV3IHZhbHVlDQogICAgLy8gaXQgd2lsbCBkaXJ0eSB0aGUgcGFyYW1zIGJlbG93IGl0Lg0KICAgIGxldCBpID0gc3JjLmdldE51bVBhcmFtZXRlcnMoKTsNCiAgICB3aGlsZSAoaS0tKSB7DQogICAgICBjb25zdCBzcmNQYXJhbSA9IHNyYy5nZXRQYXJhbWV0ZXJCeUluZGV4KGkpOw0KICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLmdldFBhcmFtZXRlcihzcmNQYXJhbS5nZXROYW1lKCkpOw0KICAgICAgaWYgKHBhcmFtKSB7DQogICAgICAgIC8vIE5vdGU6IHdlIGFyZSBub3QgY2xvbmluZyB0aGUgdmFsdWVzLg0KICAgICAgICBwYXJhbS5sb2FkVmFsdWUoc3JjUGFyYW0uZ2V0VmFsdWUoKSk7DQogICAgICB9IGVsc2Ugew0KICAgICAgICB0aGlzLmFkZFBhcmFtZXRlcihzcmNQYXJhbS5jbG9uZSgpKTsNCiAgICAgIH0NCiAgICB9DQogIH0NCn0KCi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi8NCg0KZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iaikgew0KICByZXR1cm4gISFvYmogJiYgb2JqLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZA0KfQ0KDQovKioNCiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBhdHRyaWJ1dGUuDQogKi8NCmNsYXNzIEF0dHJpYnV0ZSB7DQogIC8qKg0KICAgKiBDcmVhdGUgYW4gYXR0cmlidXRlLg0KICAgKiBAcGFyYW0ge0F0dHJWYWx1ZXxudW1iZXJ9IGRhdGFUeXBlIC0gVGhlIGRhdGFUeXBlIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcnxUeXBlZEFycmF5fSBleHBlY3RlZFNpemUgLSBUaGUgZXhwZWN0ZWRTaXplIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHRWYWx1ZSB2YWx1ZS4NCiAgICovDQogIGNvbnN0cnVjdG9yKGRhdGFUeXBlLCBleHBlY3RlZFNpemUsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgew0KICAgIHRoaXMuX19kYXRhVHlwZSA9IGRhdGFUeXBlOw0KICAgIHRoaXMubm9ybWFsaXplZCA9IGZhbHNlOw0KICAgIGlmIChkYXRhVHlwZS5udW1FbGVtZW50cyAhPSB1bmRlZmluZWQpIHsNCiAgICAgIHRoaXMuX19kaW1lbnNpb24gPSB0aGlzLl9fZGF0YVR5cGUubnVtRWxlbWVudHMoKTsNCiAgICB9IGVsc2Ugew0KICAgICAgc3dpdGNoIChkYXRhVHlwZSkgew0KICAgICAgICBjYXNlIEZsb2F0MzI6DQogICAgICAgIGNhc2UgVUludDMyOg0KICAgICAgICBjYXNlIFNJbnQzMjoNCiAgICAgICAgICB0aGlzLl9fZGltZW5zaW9uID0gMTsNCiAgICAgICAgICBicmVhaw0KICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUgZm9yIGF0dHJpYnV0ZTonICsgZGF0YVR5cGUpDQogICAgICB9DQogICAgfQ0KICAgIHRoaXMuX19kZWZhdWx0RWxlbWVudFZhbHVlID0gZGVmYXVsdFZhbHVlICE9IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IE51bWJlci5NQVhfVkFMVUU7DQogICAgaWYgKGlzVHlwZWRBcnJheShleHBlY3RlZFNpemUpKSB7DQogICAgICB0aGlzLl9fZGF0YSA9IGV4cGVjdGVkU2l6ZTsNCiAgICB9IGVsc2Ugew0KICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGV4cGVjdGVkU2l6ZSAqIHRoaXMuX19kaW1lbnNpb24pOw0KICAgICAgdGhpcy5pbml0UmFuZ2UoMCk7DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFJlc2l6ZXMgY3VycmVudCBkYXRhIGFycmF5IHRvIHRvIGEgbmV3IHNpemUuDQogICAqIEluIGNhc2UgdGhlIG5ldyBzaXplIGlzIGJpZ2dlciB0aGFuIGN1cnJlbnQgc2l6ZSwgdGhlIG5ldyB2YWx1ZXMgYXJlIGZpbGxlZCB1cCB3aXRoIGRlZmF1bHQgb25lcy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSB2YWx1ZS4NCiAgICovDQogIHJlc2l6ZShzaXplKSB7DQogICAgY29uc3QgcHJldkxlbmd0aCA9IHRoaXMuX19kYXRhLmxlbmd0aDsNCiAgICBjb25zdCBuZXdMZW5ndGggPSBzaXplICogdGhpcy5fX2RpbWVuc2lvbjsNCg0KICAgIGlmIChuZXdMZW5ndGggPiBwcmV2TGVuZ3RoKSB7DQogICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShuZXdMZW5ndGgpOw0KICAgICAgZGF0YS5zZXQodGhpcy5fX2RhdGEpOw0KICAgICAgdGhpcy5fX2RhdGEgPSBkYXRhOw0KICAgICAgdGhpcy5pbml0UmFuZ2UocHJldkxlbmd0aCk7DQogICAgfSBlbHNlIGlmIChuZXdMZW5ndGggPCBwcmV2TGVuZ3RoKSB7DQogICAgICB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLnNsaWNlKDAsIG5ld0xlbmd0aCk7DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIEZpbGxzIHVwIGRhdGEgdmFsdWVzIHdpdGggZGVmYXVsdCBvbmVzIHN0YXJ0aW5nIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IHZhbHVlLg0KICAgKi8NCiAgaW5pdFJhbmdlKHN0YXJ0KSB7DQogICAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFsdWVzIHRvIGludmFsaWQgdmFsdWVzLg0KICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRoaXMuX19kYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICB0aGlzLl9fZGF0YVtpXSA9IHRoaXMuX19kZWZhdWx0RWxlbWVudFZhbHVlOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBhdHRyaWJ1dGUgdmFsdWVzIGluIHRoZSBkYXRhLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldENvdW50KCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YS5sZW5ndGggLyB0aGlzLl9fZGltZW5zaW9uDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgYXR0cmlidXRlIHZhbHVlcyBpbiB0aGUgZGF0YS4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXQgbGVuZ3RoKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YS5sZW5ndGggLyB0aGlzLl9fZGltZW5zaW9uDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBhdHRyaWJ1dGUgdmFsdWUuDQogICAqDQogICAqIEByZXR1cm4ge0F0dHJWYWx1ZXxudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldCBkYXRhVHlwZSgpIHsNCiAgICByZXR1cm4gdGhpcy5fX2RhdGFUeXBlDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBjdXJyZW50IGRhdGEgYXJyYXkuDQogICAqDQogICAqIEByZXR1cm4ge1R5cGVkQXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldCBkYXRhKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YQ0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgZGF0YSB2YWx1ZS4NCiAgICoNCiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdmFsdWUuDQogICAqLw0KICBzZXQgZGF0YShkYXRhKSB7DQogICAgdGhpcy5fX2RhdGEgPSBkYXRhOw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgaW4gZWFjaCBgQXR0clZhbHVlYC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXQgbnVtRWxlbWVudHMoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kaW1lbnNpb24NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldEZsb2F0MzJWYWx1ZShpbmRleCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVtpbmRleF0NCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIGRhdGEgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAqLw0KICBzZXRGbG9hdDMyVmFsdWUoaW5kZXgsIHZhbHVlKSB7DQogICAgdGhpcy5fX2RhdGFbaW5kZXhdID0gdmFsdWU7DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgYEF0dHJWYWx1ZWAgb2JqZWN0IHBsYWNlZCBpbiB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAqIEByZXR1cm4ge0F0dHJWYWx1ZX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0VmFsdWVSZWYoaW5kZXgpIHsNCiAgICBjb25zdCBudW1FbGVtcyA9IHRoaXMuX19kaW1lbnNpb247DQogICAgaWYgKGluZGV4ID49IHRoaXMuX19kYXRhLmxlbmd0aCAvIG51bUVsZW1zKQ0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuX19kYXRhLmxlbmd0aCAvIDMpDQogICAgcmV0dXJuIHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgaW5kZXggKiBudW1FbGVtcyAqIDQpDQogIH0NCg0KICAvKioNCiAgICogU2V0cyBgQXR0clZhbHVlYCBvYmplY3QgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgKiBAcGFyYW0ge0F0dHJWYWx1ZX0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAqLw0KICBzZXRWYWx1ZShpbmRleCwgdmFsdWUpIHsNCiAgICBjb25zdCBudW1FbGVtcyA9IHRoaXMuX19kaW1lbnNpb247DQogICAgaWYgKGluZGV4ID49IHRoaXMuX19kYXRhLmxlbmd0aCAvIG51bUVsZW1zKQ0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuX19kYXRhLmxlbmd0aCAvIDMpDQogICAgdGhpcy5fX2RhdGFUeXBlLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCBpbmRleCAqIG51bUVsZW1zICogNCkuc2V0RnJvbU90aGVyKHZhbHVlKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKGNvbnRleHQpIHsNCiAgICByZXR1cm4gew0KICAgICAgZGF0YTogQXJyYXkuZnJvbSh0aGlzLl9fZGF0YSksDQogICAgICBkYXRhVHlwZTogUmVnaXN0cnkuZ2V0Qmx1ZXByaW50TmFtZSh0aGlzLl9fZGF0YVR5cGUpLA0KICAgICAgZGVmYXVsdFZhbHVlOiB0aGlzLl9fZGVmYXVsdEVsZW1lbnRWYWx1ZSwNCiAgICAgIGxlbmd0aDogdGhpcy5fX2RhdGEubGVuZ3RoIC8gdGhpcy5fX2RpbWVuc2lvbiwNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgKi8NCiAgZnJvbUpTT04oaikgew0KICAgIHRoaXMuX19kYXRhID0gRmxvYXQzMkFycmF5LmZyb20oai5kYXRhKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCdzIHN0YXRlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRvU3RyaW5nKCkgew0KICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAyKQ0KICB9DQp9CgovKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jICovDQoNCi8vIERlZmluZXMgdXNlZCB0byBleHBsaWNpdHkgc3BlY2lmeSB0eXBlcyBmb3IgV2ViR0wuDQpmdW5jdGlvbiBpc1R5cGVkQXJyYXkkMShvYmopIHsNCiAgcmV0dXJuICEhb2JqICYmIG9iai5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQNCn0NCg0KLyoqDQogKiBSZXByZXNlbnRzIGEgYmFzZSBjbGFzcyBmb3IgM0QgZ2VvbWV0cnkgaXRlbXMuDQogKg0KICogKipFdmVudHMqKg0KICogKiAqKmJvdW5kaW5nQm94Q2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgYm91bmRpbmcgYm94IGNoYW5nZXMuDQogKg0KICogQGV4dGVuZHMgUGFyYW1ldGVyT3duZXINCiAqLw0KY2xhc3MgQmFzZUdlb20gZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7DQogIC8qKg0KICAgKiBDcmVhdGUgYSBiYXNlIGdlb20uDQogICAqLw0KICBjb25zdHJ1Y3RvcigpIHsNCiAgICBzdXBlcigpOw0KICAgIHRoaXMuX19udW1WZXJ0aWNlcyA9IDA7DQogICAgdGhpcy5fX2JvdW5kaW5nQm94ID0gbmV3IEJveDMkMSgpOw0KICAgIHRoaXMuX19ib3VuZGluZ0JveERpcnR5ID0gdHJ1ZTsNCiAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsNCiAgICB0aGlzLl9fbWV0YURhdGEgPSBuZXcgTWFwKCk7DQogICAgdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycsIFZlYzMkMSwgMC4wKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBFc3RhYmxpc2hlcyBhIG5hbWUgZm9yIHRoZSBnZW9tZXRyeS4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgZGVidWcgbmFtZSB2YWx1ZS4NCiAgICovDQogIHNldERlYnVnTmFtZShuYW1lKSB7DQogICAgdGhpcy5fX25hbWUgPSBuYW1lOw0KICB9DQoNCiAgLyoqDQogICAqIEFkZHMgYSBuZXcgdmVydGV4IGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnkuDQogICAqDQogICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuDQogICAqIEBwYXJhbSB7QXR0clZhbHVlfG51bWJlcn0gZGF0YVR5cGUgLSBUaGUgZGF0YVR5cGUgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0U2NhbGFyVmFsdWUgLSBUaGUgZGVmYXVsdCBzY2FsYXIgdmFsdWUuDQogICAqIEByZXR1cm4ge0F0dHJpYnV0ZX0gLSBSZXR1cm5zIGFuIGF0dHJpYnV0ZS4NCiAgICovDQogIGFkZFZlcnRleEF0dHJpYnV0ZShuYW1lLCBkYXRhVHlwZSwgZGVmYXVsdFNjYWxhclZhbHVlID0gdW5kZWZpbmVkKSB7DQogICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpOw0KICAgIGxldCBhdHRyOw0KICAgIGlmIChpc1R5cGVkQXJyYXkkMShkZWZhdWx0U2NhbGFyVmFsdWUpKSB7DQogICAgICBhdHRyID0gbmV3IEF0dHJpYnV0ZShkYXRhVHlwZSwgZGVmYXVsdFNjYWxhclZhbHVlKTsNCiAgICB9IGVsc2Ugew0KICAgICAgYXR0ciA9IG5ldyBBdHRyaWJ1dGUoZGF0YVR5cGUsIHBvc2l0aW9ucyAhPSB1bmRlZmluZWQgPyBwb3NpdGlvbnMubGVuZ3RoIDogMCwgZGVmYXVsdFNjYWxhclZhbHVlKTsNCiAgICB9DQogICAgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpOw0KICAgIHJldHVybiBhdHRyDQogIH0NCg0KICAvKioNCiAgICogQ2hlY2tzIGlmIHRoZSB0aGUgZ2VvbWV0cnkgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4NCiAgICoNCiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgaGFzVmVydGV4QXR0cmlidXRlKG5hbWUpIHsNCiAgICByZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuaGFzKG5hbWUpDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLg0KICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldFZlcnRleEF0dHJpYnV0ZShuYW1lKSB7DQogICAgcmV0dXJuIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldChuYW1lKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgYWxsIHZlcnRleCBhdHRyaWJ1dGVzIGluIGFuIG9iamVjdCB3aXRoIHRoZWlyIG5hbWVzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldFZlcnRleEF0dHJpYnV0ZXMoKSB7DQogICAgY29uc3QgdmVydGV4QXR0cmlidXRlcyA9IHt9Ow0KICAgIGZvciAoY29uc3QgW2tleSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKSB2ZXJ0ZXhBdHRyaWJ1dGVzW2tleV0gPSBhdHRyOw0KICAgIHJldHVybiB2ZXJ0ZXhBdHRyaWJ1dGVzDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyAncG9zaXRpb25zJyB2ZXJ0ZXggYXR0cmlidXRlLg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKi8NCiAgZ2V0IHZlcnRpY2VzKCkgew0KICAgIGNvbnNvbGUud2FybigiZGVwcmVjYXRlZCB1c2UgI2dldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJykiKTsNCiAgICByZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KCdwb3NpdGlvbnMnKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2ZXJ0ZXggYXR0cmlidXRlcy4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBudW1WZXJ0aWNlcygpIHsNCiAgICByZXR1cm4gdGhpcy5fX251bVZlcnRpY2VzDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHZlcnRleCBhdHRyaWJ1dGVzLg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldE51bVZlcnRpY2VzKCkgew0KICAgIHJldHVybiB0aGlzLl9fbnVtVmVydGljZXMNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgdGhlIGdlb21ldHJ5IGhhcy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIGNvdW50IHZhbHVlLg0KICAgKi8NCiAgc2V0TnVtVmVydGljZXMoY291bnQpIHsNCiAgICB0aGlzLl9fbnVtVmVydGljZXMgPSBjb3VudDsNCiAgICAvLyBSZXNpemVzIGVhY2ggb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGVzIHRvIG1hdGNoIHRoZSBuZXcgY291bnQuDQogICAgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4gYXR0ci5yZXNpemUodGhpcy5fX251bVZlcnRpY2VzKSk7DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiB2ZXJ0ZXgNCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBWZWMzLg0KICAgKi8NCiAgZ2V0VmVydGV4KGluZGV4KSB7DQogICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIHVzZSAjZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKS5nZXRWYWx1ZVJlZigpYCk7DQogICAgcmV0dXJuIFZlYzMkMS5jcmVhdGVGcm9tQnVmZmVyKHRoaXMudmVydGljZXMuZGF0YS5idWZmZXIsIGluZGV4ICogMyAqIDQpDQogIH0NCg0KICAvKioNCiAgICogU2V0cyB0aGUgcG9zaXRpb24gYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiB2ZXJ0ZXgNCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHBhcmFtIHtpbmRleH0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAqIEBwYXJhbSB7VmVjM30gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIFZlYzMuDQogICAqLw0KICBzZXRWZXJ0ZXgoaW5kZXgsIHZhbHVlKSB7DQogICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIHVzZSAjZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKS5nZXRWYWx1ZVJlZigpLnNldEZyb21PdGhlcih2YWx1ZSlgKTsNCiAgICByZXR1cm4gVmVjMyQxLmNyZWF0ZUZyb21CdWZmZXIodGhpcy52ZXJ0aWNlcy5kYXRhLmJ1ZmZlciwgaW5kZXggKiAzICogNCkuc2V0RnJvbU90aGVyKHZhbHVlKQ0KICB9DQoNCiAgLyoqDQogICAqIEFwcGxpZXMgYW4gb2Zmc2V0IHRvIGVhY2ggb2YgdGhlIHZlcnRpY2VzIGluIHRoZSBnZW9tZXRyeS4NCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHBhcmFtIHtWZWMzfSBkZWx0YSAtIFRoZSBkZWx0YSB2YWx1ZS4NCiAgICovDQogIG1vdmVWZXJ0aWNlcyhkZWx0YSkgew0KICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCB1c2UgI2dldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJykuZ2V0VmFsdWVSZWYoKWApOw0KICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlczsNCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB2ZXJ0aWNlcy5nZXRWYWx1ZVJlZihpKS5hZGRJblBsYWNlKGRlbHRhKTsNCiAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgdHJhbnNmb3JtVmVydGljZXMgbWV0aG9kLg0KICAgKiBAZGVwcmVjYXRlZA0KICAgKiBAcGFyYW0ge1hmb30geGZvIC0gVGhlIHhmbyB0cmFuZm9ybS4NCiAgICovDQogIHRyYW5zZm9ybVZlcnRpY2VzKHhmbykgew0KICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHRyYW5zZm9ybSB0aGUgdmVydGljZXMgbWFudWFsbHlgKTsNCiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7DQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykgew0KICAgICAgY29uc3QgdiA9IHZlcnRpY2VzLmdldFZhbHVlUmVmKGkpOw0KICAgICAgY29uc3QgdjIgPSB4Zm8udHJhbnNmb3JtVmVjMyh2KTsNCiAgICAgIHYuc2V0KHYyLngsIHYyLnksIHYyLnopOw0KICAgIH0NCiAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTsNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gQm91bmRpbmdCb3gNCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBnZW9tZXRyeS4NCiAgICogQGRlcHJlY2F0ZWQNCiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0IGJvdW5kaW5nQm94KCkgew0KICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAjZ2V0Qm91bmRpbmdCb3goKWApOw0KICAgIGlmICh0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eSkgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpOw0KICAgIHJldHVybiB0aGlzLl9fYm91bmRpbmdCb3gNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIGdlb21ldHJ5Lg0KICAgKiBAcmV0dXJuIHtWZWMzfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRCb3VuZGluZ0JveCgpIHsNCiAgICBpZiAodGhpcy5fX2JvdW5kaW5nQm94RGlydHkpIHRoaXMudXBkYXRlQm91bmRpbmdCb3goKTsNCiAgICByZXR1cm4gdGhpcy5fX2JvdW5kaW5nQm94DQogIH0NCg0KICAvKioNCiAgICogVGhlIHNldEJvdW5kaW5nQm94RGlydHkgbWV0aG9kLg0KICAgKi8NCiAgc2V0Qm91bmRpbmdCb3hEaXJ0eSgpIHsNCiAgICB0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7DQogICAgdGhpcy5lbWl0KCdib3VuZGluZ0JveENoYW5nZWQnLCB7fSk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIHVwZGF0ZUJvdW5kaW5nQm94IG1ldGhvZC4NCiAgICovDQogIHVwZGF0ZUJvdW5kaW5nQm94KCkgew0KICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKTsNCiAgICBjb25zdCBiYm94ID0gbmV3IEJveDMkMSgpOw0KICAgIGNvbnN0IG51bVZlcnRzID0gcG9zaXRpb25zLmxlbmd0aDsNCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRzOyBpKyspIGJib3guYWRkUG9pbnQocG9zaXRpb25zLmdldFZhbHVlUmVmKGkpKTsNCiAgICB0aGlzLl9fYm91bmRpbmdCb3ggPSBiYm94Ow0KICAgIHRoaXMuX19ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7DQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIE1ldGFkYXRhDQoNCiAgLyoqDQogICAqIFJldHVybnMgbWV0YWRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBuYW1lLg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB2YWx1ZS4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRNZXRhZGF0YShrZXkpIHsNCiAgICByZXR1cm4gdGhpcy5fX21ldGFEYXRhLmdldChrZXkpDQogIH0NCg0KICAvKioNCiAgICogVmVyaWZpZXMgaWYgZ2VvbWV0cnkncyBtZXRhZGF0YSBjb250YWlucyBhIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuDQogICAqDQogICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBoYXNNZXRhZGF0YShrZXkpIHsNCiAgICByZXR1cm4gdGhpcy5fX21ldGFEYXRhLmhhcyhrZXkpDQogIH0NCg0KICAvKioNCiAgICogU2V0cyBtZXRhZGF0YSB2YWx1ZSB0byB0aGUgZ2VvbWV0cnkuDQogICAqDQogICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHZhbHVlLg0KICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YURhdGEgLSBUaGUgbWV0YURhdGEgdmFsdWUuDQogICAqLw0KICBzZXRNZXRhZGF0YShrZXksIG1ldGFEYXRhKSB7DQogICAgdGhpcy5fX21ldGFEYXRhLnNldChrZXksIG1ldGFEYXRhKTsNCiAgfQ0KDQogIC8qKg0KICAgKiBSZW1vdmVzIG1ldGFkYXRhIHZhbHVlIGZyb20gdGhlIGdlb21ldHJ5IHdpdGggdGhlIHNwZWNpZmllZCBrZXkuDQogICAqDQogICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHZhbHVlLg0KICAgKi8NCiAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7DQogICAgdGhpcy5fX21ldGFEYXRhLmRlbGV0ZShrZXkpOw0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBNZW1vcnkNCg0KICAvKioNCiAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlcyBidWZmZXJzIGFuZCBpdHMgY291bnQuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIG9wdHMgdmFsdWUuDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2VuQnVmZmVycyhvcHRzKSB7DQogICAgY29uc3QgYXR0ckJ1ZmZlcnMgPSB7fTsNCiAgICBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgIGF0dHJCdWZmZXJzW2F0dHJOYW1lXSA9IHsNCiAgICAgICAgdmFsdWVzOiBhdHRyLmRhdGEsDQogICAgICAgIGNvdW50OiBhdHRyLmxlbmd0aCwNCiAgICAgICAgZGF0YVR5cGU6IGF0dHIuZGF0YVR5cGUsDQogICAgICAgIG5vcm1hbGl6ZWQ6IGF0dHIubm9ybWFsaXplZCwNCiAgICAgIH07DQogICAgfQ0KICAgIHJldHVybiB7DQogICAgICBudW1WZXJ0aWNlczogdGhpcy5udW1WZXJ0aWNlcygpLA0KICAgICAgYXR0ckJ1ZmZlcnMsDQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcmVlQnVmZmVycyBtZXRob2QuDQogICAqLw0KICBmcmVlQnVmZmVycygpIHsNCiAgICAvLyBCZWZvcmUgZGVzdHJveWluZyBhbGwgb3VyIGRhdGEsDQogICAgLy8gbWFrZSBzdXJlIHRoZSBiYm94IGlzIHVwIHRvIGRhdGUuDQogICAgLy8gaWYgKHRoaXMuX19ib3VuZGluZ0JveERpcnR5KQ0KICAgIC8vICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KCk7DQogICAgLy8gLy8gVE9ETzogcHVzaCB0aGUgZGF0YSB0byBhIHdvcmtlciB0aHJlYWQgYW5kIHRlcm1pbmF0ZSBsaWtlIGluIE1lc2hQcm94eS4NCiAgICAvLyB0aGlzLl9fdmVydGV4QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsNCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCiAgLyoqDQogICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBHZW9tZXRyeShJbmNsdWRpbmcgVmVydGljZXMgYW5kIEJvdW5kaW5nIEJveCkgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqLw0KICBsb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyKSB7DQogICAgdGhpcy5uYW1lID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICBjb25zdCBmbGFncyA9IHJlYWRlci5sb2FkVUludDgoKTsNCiAgICB0aGlzLmRlYnVnQ29sb3IgPSByZWFkZXIubG9hZFJHQkZsb2F0MzJDb2xvcigpOw0KICAgIGNvbnN0IG51bVZlcnRzID0gcmVhZGVyLmxvYWRVSW50MzIoKTsNCiAgICB0aGlzLl9fYm91bmRpbmdCb3guc2V0KHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSwgcmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpKTsNCg0KICAgIHRoaXMuc2V0TnVtVmVydGljZXMobnVtVmVydHMpOw0KICAgIGNvbnN0IHBvc2l0aW9uc0F0dHIgPSB0aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJyk7DQoNCiAgICBsZXQgbm9ybWFsc0F0dHI7DQogICAgbGV0IHRleENvb3Jkc0F0dHI7DQogICAgaWYgKGZsYWdzICYgKDEgPDwgMSkpIHsNCiAgICAgIG5vcm1hbHNBdHRyID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKTsNCiAgICAgIGlmICghbm9ybWFsc0F0dHIpIG5vcm1hbHNBdHRyID0gdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnLCBWZWMzJDEsIDAuMCk7DQogICAgfQ0KICAgIGlmIChmbGFncyAmICgxIDw8IDIpKSB7DQogICAgICB0ZXhDb29yZHNBdHRyID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3RleENvb3JkcycpOw0KICAgICAgaWYgKCF0ZXhDb29yZHNBdHRyKSB0ZXhDb29yZHNBdHRyID0gdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoJ3RleENvb3JkcycsIFZlYzIsIDAuMCk7DQogICAgfQ0KDQogICAgY29uc3QgcGFyc2U4Qml0UG9zaXRpb25zQXJyYXkgPSAocmFuZ2UsIG9mZnNldCwgc2NsVmVjLCBwb3NpdGlvbnNfOGJpdCkgPT4gew0KICAgICAgZm9yIChsZXQgaSA9IHJhbmdlWzBdOyBpIDwgcmFuZ2VbMV07IGkrKykgew0KICAgICAgICBjb25zdCBwb3MgPSBuZXcgVmVjMyQxKA0KICAgICAgICAgIHBvc2l0aW9uc184Yml0W2kgKiAzICsgMF0gLyAyNTUuMCwNCiAgICAgICAgICBwb3NpdGlvbnNfOGJpdFtpICogMyArIDFdIC8gMjU1LjAsDQogICAgICAgICAgcG9zaXRpb25zXzhiaXRbaSAqIDMgKyAyXSAvIDI1NS4wDQogICAgICAgICk7DQogICAgICAgIHBvcy5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKTsNCiAgICAgICAgcG9zLmFkZEluUGxhY2Uob2Zmc2V0KTsNCiAgICAgICAgcG9zaXRpb25zQXR0ci5zZXRWYWx1ZShpLCBwb3MpOw0KICAgICAgfQ0KICAgIH07DQoNCiAgICBjb25zdCBwYXJzZThCaXROb3JtYWxzQXJyYXkgPSAocmFuZ2UsIG9mZnNldCwgc2NsVmVjLCBub3JtYWxzXzhiaXQpID0+IHsNCiAgICAgIGlmIChzY2xWZWMuaXNOdWxsKCkpIHNjbFZlYy5zZXQoMSwgMSwgMSk7DQogICAgICBmb3IgKGxldCBpID0gcmFuZ2VbMF07IGkgPCByYW5nZVsxXTsgaSsrKSB7DQogICAgICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWMzJDEoDQogICAgICAgICAgbm9ybWFsc184Yml0W2kgKiAzICsgMF0gLyAyNTUuMCwNCiAgICAgICAgICBub3JtYWxzXzhiaXRbaSAqIDMgKyAxXSAvIDI1NS4wLA0KICAgICAgICAgIG5vcm1hbHNfOGJpdFtpICogMyArIDJdIC8gMjU1LjANCiAgICAgICAgKTsNCiAgICAgICAgbm9ybWFsLm11bHRpcGx5SW5QbGFjZShzY2xWZWMpOw0KICAgICAgICBub3JtYWwuYWRkSW5QbGFjZShvZmZzZXQpOw0KICAgICAgICBub3JtYWwubm9ybWFsaXplSW5QbGFjZSgpOw0KICAgICAgICBub3JtYWxzQXR0ci5zZXRWYWx1ZShpLCBub3JtYWwpOw0KICAgICAgfQ0KICAgIH07DQogICAgY29uc3QgcGFyc2U4Qml0VGV4dHVyZUNvb3Jkc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgdGV4Q29vcmRzXzhiaXQpID0+IHsNCiAgICAgIC8vIGlmIChzY2xWZWMuaXNOdWxsKCkpDQogICAgICAvLyAgICAgc2NsVmVjLnNldCgxLCAxLCAxKTsNCiAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsNCiAgICAgICAgY29uc3QgdGV4dHVyZUNvb3JkID0gbmV3IFZlYzIodGV4Q29vcmRzXzhiaXRbaSAqIDIgKyAwXSAvIDI1NS4wLCB0ZXhDb29yZHNfOGJpdFtpICogMiArIDFdIC8gMjU1LjApOw0KICAgICAgICB0ZXh0dXJlQ29vcmQubXVsdGlwbHlJblBsYWNlKHNjbFZlYyk7DQogICAgICAgIHRleHR1cmVDb29yZC5hZGRJblBsYWNlKG9mZnNldCk7DQogICAgICAgIHRleENvb3Jkc0F0dHIuc2V0VmFsdWUoaSwgdGV4dHVyZUNvb3JkKTsNCiAgICAgIH0NCiAgICB9Ow0KDQogICAgY29uc3QgbnVtQ2x1c3RlcnMgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgIGlmIChudW1DbHVzdGVycyA9PSAxKSB7DQogICAgICB7DQogICAgICAgIGNvbnN0IGJveDMgPSB0aGlzLl9fYm91bmRpbmdCb3g7DQogICAgICAgIGNvbnN0IHBvc2l0aW9uc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMyk7DQogICAgICAgIHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgcG9zaXRpb25zXzhiaXQpOw0KICAgICAgfQ0KDQogICAgICBpZiAobm9ybWFsc0F0dHIpIHsNCiAgICAgICAgY29uc3QgYm94MyA9IG5ldyBCb3gzJDEocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpOw0KICAgICAgICBjb25zdCBub3JtYWxzXzhiaXQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKTsNCiAgICAgICAgcGFyc2U4Qml0Tm9ybWFsc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc184Yml0KTsNCg0KICAgICAgICBub3JtYWxzQXR0ci5sb2FkU3BsaXRWYWx1ZXMocmVhZGVyKTsNCiAgICAgIH0NCiAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgIGNvbnN0IGJveDIgPSBuZXcgQm94MihyZWFkZXIubG9hZEZsb2F0MzJWZWMyKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzIoKSk7DQogICAgICAgIGNvbnN0IHRleENvb3Jkc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMik7DQogICAgICAgIHBhcnNlOEJpdFRleHR1cmVDb29yZHNBcnJheShbMCwgbnVtVmVydHNdLCBib3gyLnAwLCBib3gyLmRpYWdvbmFsKCksIHRleENvb3Jkc184Yml0KTsNCg0KICAgICAgICB0ZXhDb29yZHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpOw0KICAgICAgfQ0KICAgIH0gZWxzZSB7DQogICAgICBjb25zdCBjbHVzdGVycyA9IFtdOw0KICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsdXN0ZXJzOyBpKyspIHsNCiAgICAgICAgY29uc3QgY291bnQgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgICBjb25zdCBib3gzID0gbmV3IEJveDMkMShyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSk7DQogICAgICAgIGNvbnN0IGNsdXN0ZXJEYXRhID0gew0KICAgICAgICAgIHJhbmdlOiBbb2Zmc2V0LCBvZmZzZXQgKyBjb3VudF0sDQogICAgICAgICAgYmJveDogYm94MywNCiAgICAgICAgfTsNCiAgICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7DQogICAgICAgICAgY2x1c3RlckRhdGEubm9ybWFsc1JhbmdlID0gbmV3IEJveDMkMShyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSk7DQogICAgICAgIH0NCiAgICAgICAgaWYgKHRleENvb3Jkc0F0dHIpIHsNCiAgICAgICAgICBjbHVzdGVyRGF0YS50ZXhDb29yZHNSYW5nZSA9IG5ldyBCb3gyKHJlYWRlci5sb2FkRmxvYXQzMlZlYzIoKSwgcmVhZGVyLmxvYWRGbG9hdDMyVmVjMigpKTsNCiAgICAgICAgfQ0KDQogICAgICAgIGNsdXN0ZXJzLnB1c2goY2x1c3RlckRhdGEpOw0KICAgICAgICBvZmZzZXQgKz0gY291bnQ7DQogICAgICB9DQogICAgICBjb25zdCBwb3NpdGlvbnNfOGJpdCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMpOw0KICAgICAgbGV0IG5vcm1hbHNfOGJpdDsNCiAgICAgIGxldCB0ZXhDb29yZHNfOGJpdDsNCiAgICAgIGlmIChub3JtYWxzQXR0cikgew0KICAgICAgICBub3JtYWxzXzhiaXQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKTsNCiAgICAgIH0NCiAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgIHRleENvb3Jkc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMik7DQogICAgICB9DQoNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2x1c3RlcnM7IGkrKykgew0KICAgICAgICB7DQogICAgICAgICAgY29uc3QgYm94MyA9IGNsdXN0ZXJzW2ldLmJib3g7DQogICAgICAgICAgcGFyc2U4Qml0UG9zaXRpb25zQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgcG9zaXRpb25zXzhiaXQpOw0KICAgICAgICB9DQoNCiAgICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7DQogICAgICAgICAgY29uc3QgYm94MyA9IGNsdXN0ZXJzW2ldLm5vcm1hbHNSYW5nZTsNCiAgICAgICAgICBwYXJzZThCaXROb3JtYWxzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc184Yml0KTsNCiAgICAgICAgfQ0KICAgICAgICBpZiAodGV4Q29vcmRzQXR0cikgew0KICAgICAgICAgIGNvbnN0IGJveDIgPSBjbHVzdGVyc1tpXS50ZXhDb29yZHNSYW5nZTsNCiAgICAgICAgICBwYXJzZThCaXRUZXh0dXJlQ29vcmRzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzXzhiaXQpOw0KICAgICAgICB9DQogICAgICB9DQogICAgICBpZiAobm9ybWFsc0F0dHIpIHsNCiAgICAgICAgbm9ybWFsc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcik7DQogICAgICB9DQogICAgICBpZiAodGV4Q29vcmRzQXR0cikgew0KICAgICAgICB0ZXhDb29yZHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpOw0KICAgICAgfQ0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKGNvbnRleHQpIHsNCiAgICBsZXQganNvbiA9IHN1cGVyLnRvSlNPTihjb250ZXh0KTsNCiAgICBpZiAoIWpzb24pIGpzb24gPSB7fTsNCiAgICBqc29uLnR5cGUgPSBSZWdpc3RyeS5nZXRCbHVlcHJpbnROYW1lKHRoaXMpOw0KICAgIGpzb24ubnVtVmVydGljZXMgPSB0aGlzLl9fbnVtVmVydGljZXM7DQoNCiAgICBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGVzID0ge307DQogICAgZm9yIChjb25zdCBba2V5LCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5lbnRyaWVzKCkpIHsNCiAgICAgIC8vIGlmICghb3B0cyB8fCAhKCdhdHRyTGlzdCcgaW4gb3B0cykgfHwgb3B0cy5hdHRyTGlzdC5pbmRleE9mKGtleSkgIT0gLTEpDQogICAgICB2ZXJ0ZXhBdHRyaWJ1dGVzW2tleV0gPSBhdHRyLnRvSlNPTihjb250ZXh0KTsNCiAgICB9DQogICAganNvbi52ZXJ0ZXhBdHRyaWJ1dGVzID0gdmVydGV4QXR0cmlidXRlczsNCg0KICAgIHJldHVybiBqc29uDQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgKi8NCiAgZnJvbUpTT04oanNvbiwgY29udGV4dCkgew0KICAgIHN1cGVyLmZyb21KU09OKGpzb24sIGNvbnRleHQpOw0KICAgIHRoaXMuc2V0TnVtVmVydGljZXMoanNvbi5udW1WZXJ0aWNlcyk7DQogICAgZm9yIChjb25zdCBuYW1lIGluIGpzb24udmVydGV4QXR0cmlidXRlcykgew0KICAgICAgbGV0IGF0dHIgPSB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5nZXQobmFtZSk7DQogICAgICBjb25zdCBhdHRySlNPTiA9IGpzb24udmVydGV4QXR0cmlidXRlc1tuYW1lXTsNCiAgICAgIGlmICghYXR0cikgew0KICAgICAgICBjb25zdCBkYXRhVHlwZSA9IFJlZ2lzdHJ5LmdldEJsdWVwcmludChhdHRySlNPTi5kYXRhVHlwZSk7DQogICAgICAgIGF0dHIgPSBuZXcgVmVydGV4QXR0cmlidXRlKHRoaXMsIGRhdGFUeXBlLCAwLCBhdHRySlNPTi5kZWZhdWx0U2NhbGFyVmFsdWUpOw0KICAgICAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7DQogICAgICB9DQogICAgICBhdHRyLmZyb21KU09OKGF0dHJKU09OKTsNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyBnZW9tZXRyeSBkYXRhIHZhbHVlIGluIGpzb24gZm9ybWF0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIHRvU3RyaW5nKCkgew0KICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAyKQ0KICB9DQp9CgovKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi8NCg0KLyoqDQogKiBDbGFzcyByZXByZXNlbnRpbmcgYSBwb2ludCBwcmltaXRpdmUgZHJhd2luZyB0eXBlLCBldmVyeSB2ZXJ0ZXggc3BlY2lmaWVkIGlzIGEgcG9pbnQuDQogKg0KICogYGBgDQogKiBjb25zdCBwb2ludHMgPSBuZXcgUG9pbnRzKCkNCiAqIGBgYA0KICoNCiAqICogKipFdmVudHMqKg0KICogKiAqKmJvdW5kaW5nQm94Q2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgYm91bmRpbmcgYm94IGNoYW5nZXMuDQogKg0KICogQGV4dGVuZHMgQmFzZUdlb20NCiAqLw0KY2xhc3MgUG9pbnRzIGV4dGVuZHMgQmFzZUdlb20gew0KICAvKioNCiAgICogQ3JlYXRlIHBvaW50cy4NCiAgICovDQogIGNvbnN0cnVjdG9yKCkgew0KICAgIHN1cGVyKCk7DQogIH0NCg0KICAvKioNCiAgICogTG9hZHMgYW5kIHBvcHVsYXRlcyBgUG9pbnRzYCBvYmplY3QgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAqDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKi8NCiAgbG9hZEJpbihyZWFkZXIpIHsNCiAgICB0aGlzLm5hbWUgPSByZWFkZXIubG9hZFN0cigpOw0KICAgIGNvbnN0IG51bVZlcnRzID0gcmVhZGVyLmxvYWRVSW50MzIoKTsNCiAgICB0aGlzLl9fYm91bmRpbmdCb3guc2V0KHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSwgcmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpKTsNCiAgICB0aGlzLnNldE51bVZlcnRpY2VzKG51bVZlcnRzKTsNCiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJyk7DQoNCiAgICBpZiAobnVtVmVydHMgPCAyNTYpIHsNCiAgICAgIGNvbnN0IGJib3hNYXQgPSB0aGlzLl9fYm91bmRpbmdCb3gudG9NYXQ0KCk7DQogICAgICBjb25zdCBwb3NBdHRyXzhiaXQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykgew0KICAgICAgICBjb25zdCBwb3MgPSBuZXcgVmVjMygNCiAgICAgICAgICBwb3NBdHRyXzhiaXRbaSAqIDMgKyAwXSAvIDI1NS4wLA0KICAgICAgICAgIHBvc0F0dHJfOGJpdFtpICogMyArIDFdIC8gMjU1LjAsDQogICAgICAgICAgcG9zQXR0cl84Yml0W2kgKiAzICsgMl0gLyAyNTUuMA0KICAgICAgICApOw0KICAgICAgICBwb3NpdGlvbnMuc2V0VmFsdWUoaSwgYmJveE1hdC50cmFuc2Zvcm1WZWMzKHBvcykpOw0KICAgICAgfQ0KICAgIH0gZWxzZSB7DQogICAgICBjb25zdCBudW1DbHVzdGVycyA9IHJlYWRlci5sb2FkVUludDMyKCk7DQogICAgICBjb25zdCBjbHVzdGVycyA9IFtdOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbHVzdGVyczsgaSsrKSB7DQogICAgICAgIGNvbnN0IHJhbmdlID0gcmVhZGVyLmxvYWRVSW50MzJWZWMyKCk7DQogICAgICAgIGNvbnN0IHAwID0gcmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpOw0KICAgICAgICBjb25zdCBwMSA9IHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKTsNCiAgICAgICAgY2x1c3RlcnMucHVzaCh7DQogICAgICAgICAgcmFuZ2U6IHJhbmdlLA0KICAgICAgICAgIGJib3g6IG5ldyBCb3gzKHAwLCBwMSksDQogICAgICAgIH0pOw0KICAgICAgfQ0KICAgICAgY29uc3QgcG9zQXR0cl84Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMyk7DQoNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2x1c3RlcnM7IGkrKykgew0KICAgICAgICBjb25zdCBiYm94TWF0ID0gY2x1c3RlcnNbaV1bJ2Jib3gnXS50b01hdDQoKTsNCiAgICAgICAgZm9yIChsZXQgaiA9IGNsdXN0ZXJzW2ldWydyYW5nZSddLng7IGogPCBjbHVzdGVyc1tpXVsncmFuZ2UnXS55OyBqKyspIHsNCiAgICAgICAgICBjb25zdCBwb3MgPSBuZXcgVmVjMygNCiAgICAgICAgICAgIHBvc0F0dHJfOGJpdFtqICogMyArIDBdIC8gMjU1LjAsDQogICAgICAgICAgICBwb3NBdHRyXzhiaXRbaiAqIDMgKyAxXSAvIDI1NS4wLA0KICAgICAgICAgICAgcG9zQXR0cl84Yml0W2ogKiAzICsgMl0gLyAyNTUuMA0KICAgICAgICAgICk7DQogICAgICAgICAgcG9zaXRpb25zLnNldFZhbHVlKGosIGJib3hNYXQudHJhbnNmb3JtVmVjMyhwb3MpKTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gUGVyc2lzdGVuY2UNCg0KICAvKioNCiAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IGdlb21ldHJ5KEluY2x1ZGluZyBsaW5lIHNlZ21lbnRzKSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0Lg0KICAgKg0KICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICovDQogIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgc3VwZXIubG9hZEJhc2VHZW9tQmluYXJ5KHJlYWRlcik7DQoNCiAgICAvLyB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7DQogICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnLCB7fSk7DQogIH0NCn0NCg0KUmVnaXN0cnkucmVnaXN0ZXIoJ1BvaW50cycsIFBvaW50cyk7CgovKioNCiAqDQogKiBDbGFzcyByZXByZXNlbnRpbmcgbGluZXMgcHJpbWl0aXZlIGRyYXdpbmcgdHlwZSwgY29ubmVjdGluZyB2ZXJ0aWNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGluZGljZXMuDQogKiBpLmUuIFdlIGhhdmUgNCBwb2ludHModmVydGljZXMpIGJ1dCB3ZSBkb24ndCBrbm93IGhvdyB0aGV5IGNvbm5lY3QgdG8gZWFjaCBvdGhlciwNCiAqIGFuZCB0aGF0J3Mgd2h5IHdlIG5lZWQgaW5kaWNlcyhOdW1iZXJzIGluZGljYXRpbmcgd2hpY2ggdmVydGV4IGNvbm5lY3RzIHRvIHdoaWNoKS4NCiAqIEluIHRoaXMgY2FzZSBpZiB3ZSBzYXkgdGhhdCBgaW5kaWNlc2AgaXMgYFswLDEsMiwzXWAsIGl0IHdvdWxkIGNvbm5lY3QgdGhlIGZpcnN0IHZlcnRleCB0byB0aGUgc2Vjb25kLA0KICogYW5kIHRoZSB0aGlyZCB0byB0aGUgZm91cnRoLg0KICoNCiAqIGBgYA0KICogY29uc3QgbGluZXMgPSBuZXcgTGluZXMoKQ0KICogYGBgDQogKg0KICogKipFdmVudHMqKg0KICogKiAqKmdlb21EYXRhQ2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgZ2VvbWV0cnkgaXMgc2V0KFRoaXMgaW5jbHVkZXMgcmVhZGluZyBiaW5hcnkpDQogKg0KICogQGV4dGVuZHMgQmFzZUdlb20NCiAqLw0KY2xhc3MgTGluZXMgZXh0ZW5kcyBCYXNlR2VvbSB7DQogIC8qKg0KICAgKiBDcmVhdGUgbGluZXMuDQogICAqLw0KICBjb25zdHJ1Y3RvcigpIHsNCiAgICBzdXBlcigpOw0KICAgIHRoaXMuX19pbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KCk7DQogICAgdGhpcy5saW5lVGhpY2tuZXNzID0gMC4wOw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBpbmRpY2VzKFZlcnRleCBjb25uZWN0b3JzKQ0KICAgKg0KICAgKiBAcmV0dXJuIHtVaW50MzJBcnJheX0gLSBUaGUgaW5kaWNlcyBpbmRleCBhcnJheS4NCiAgICovDQogIGdldEluZGljZXMoKSB7DQogICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpbmUgc2VnbWVudHMuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2VnbWVudHMuDQogICAqLw0KICBnZXROdW1TZWdtZW50cygpIHsNCiAgICByZXR1cm4gdGhpcy5fX2luZGljZXMubGVuZ3RoIC8gMg0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzIGluIHRoZSBnZW9tZXRyeS48YnI+DQogICAqICoqSW1wb3J0YW50OioqIEl0IHJlc2V0cyBpbmRpY2VzIHZhbHVlcy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IG51bU9mU2VnbWVudHMgLSBUaGUgY291bnQgdmFsdWUuDQogICAqLw0KICBzZXROdW1TZWdtZW50cyhudW1PZlNlZ21lbnRzKSB7DQogICAgaWYgKG51bU9mU2VnbWVudHMgPiB0aGlzLmdldE51bVNlZ21lbnRzKCkpIHsNCiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobnVtT2ZTZWdtZW50cyAqIDIpOw0KICAgICAgaW5kaWNlcy5zZXQodGhpcy5fX2luZGljZXMpOw0KICAgICAgdGhpcy5fX2luZGljZXMgPSBpbmRpY2VzOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLl9faW5kaWNlcyA9IHRoaXMuX19pbmRpY2VzLnNsaWNlKDAsIG51bU9mU2VnbWVudHMgKiAyKTsNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogU2V0cyBzZWdtZW50IHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBwMCAtIFRoZSBwMCB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHAxIC0gVGhlIHAxIHZhbHVlLg0KICAgKi8NCiAgc2V0U2VnbWVudFZlcnRleEluZGljZXMoaW5kZXgsIHAwLCBwMSkgew0KICAgIGlmIChpbmRleCA+PSB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyKQ0KICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpbmUgaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFNlZ21lbnRzOicgKyB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyKQ0KICAgIHRoaXMuX19pbmRpY2VzW2luZGV4ICogMiArIDBdID0gcDA7DQogICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMV0gPSBwMTsNCiAgfQ0KDQogIC8qKg0KICAgKiBTZXRzIHNlZ21lbnQgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHAwIC0gVGhlIHAwIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gcDEgLSBUaGUgcDEgdmFsdWUuDQogICAqLw0KICBzZXRTZWdtZW50KGluZGV4LCBwMCwgcDEpIHsNCiAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQgdXNlICNzZXRTZWdtZW50VmVydGV4SW5kaWNlc2ApOw0KICAgIHRoaXMuc2V0U2VnbWVudFZlcnRleEluZGljZXMoaW5kZXgsIHAwLCBwMSk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIGdldFNlZ21lbnRWZXJ0ZXhJbmRleCBtZXRob2QuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIC0gVGhlIGxpbmUgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lVmVydGV4IC0gVGhlIGxpbmVWZXJ0ZXggdmFsdWUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKiBAcHJpdmF0ZQ0KICAgKi8NCiAgZ2V0U2VnbWVudFZlcnRleEluZGV4KGxpbmUsIGxpbmVWZXJ0ZXgpIHsNCiAgICBjb25zdCBudW1TZWdtZW50cyA9IHRoaXMuZ2V0TnVtU2VnbWVudHMoKTsNCiAgICBpZiAobGluZSA8IG51bVNlZ21lbnRzKSByZXR1cm4gdGhpcy5fX2luZGljZXNbbGluZSAqIDIgKyBsaW5lVmVydGV4XQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBNZW1vcnkNCg0KICAvKioNCiAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlcyBidWZmZXJzIGFuZCBpdHMgY291bnQuDQogICAqDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2VuQnVmZmVycygpIHsNCiAgICBjb25zdCBidWZmZXJzID0gc3VwZXIuZ2VuQnVmZmVycygpOw0KDQogICAgbGV0IGluZGljZXM7DQogICAgaWYgKGJ1ZmZlcnMubnVtVmVydGljZXMgPCBNYXRoLnBvdygyLCA4KSkgew0KICAgICAgaW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19pbmRpY2VzLmxlbmd0aCk7DQogICAgICB0aGlzLl9faW5kaWNlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHsNCiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSB2YWx1ZTsNCiAgICAgIH0pOw0KICAgIH0gZWxzZSBpZiAoYnVmZmVycy5udW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkgew0KICAgICAgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLl9faW5kaWNlcy5sZW5ndGgpOw0KICAgICAgdGhpcy5fX2luZGljZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7DQogICAgICAgIGluZGljZXNbaW5kZXhdID0gdmFsdWU7DQogICAgICB9KTsNCiAgICB9IGVsc2Ugew0KICAgICAgaW5kaWNlcyA9IHRoaXMuX19pbmRpY2VzOw0KICAgIH0NCiAgICBidWZmZXJzLmluZGljZXMgPSBpbmRpY2VzOw0KICAgIHJldHVybiBidWZmZXJzDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFBlcnNpc3RlbmNlDQoNCiAgLyoqDQogICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBnZW9tZXRyeShJbmNsdWRpbmcgbGluZSBzZWdtZW50cykgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIpOw0KDQogICAgdGhpcy5zZXROdW1TZWdtZW50cyhyZWFkZXIubG9hZFVJbnQzMigpKTsNCg0KICAgIGNvbnN0IGJ5dGVzID0gcmVhZGVyLmxvYWRVSW50OCgpOw0KICAgIGlmIChieXRlcyA9PSAxKSB0aGlzLl9faW5kaWNlcyA9IHJlYWRlci5sb2FkVUludDhBcnJheSgpOw0KICAgIGVsc2UgaWYgKGJ5dGVzID09IDIpIHRoaXMuX19pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheSgpOw0KICAgIGVsc2UgaWYgKGJ5dGVzID09IDQpIHRoaXMuX19pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MzJBcnJheSgpOw0KDQogICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnLCB7fSk7DQogIH0NCiAgLyoqDQogICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgKg0KICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAqLw0KICB0b0pTT04oY29udGV4dCkgew0KICAgIGNvbnN0IGogPSBzdXBlci50b0pTT04oY29udGV4dCk7DQogICAgai5pbmRpY2VzID0gQXJyYXkuZnJvbSh0aGlzLl9faW5kaWNlcyk7DQoNCiAgICByZXR1cm4gag0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICovDQogIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICBzdXBlci5mcm9tSlNPTihqLCBjb250ZXh0KTsNCiAgICB0aGlzLl9faW5kaWNlcyA9IFVpbnQzMkFycmF5LmZyb20oai5pbmRpY2VzKTsNCiAgfQ0KfQ0KDQpSZWdpc3RyeS5yZWdpc3RlcignTGluZXMnLCBMaW5lcyk7CgovKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi8NCg0KLyoqDQogKiBDbGFzcyByZXByZXNlbnRpbmcgdmVydGV4IGF0dHJpYnV0ZXMuDQogKg0KICogYGBgDQogKiBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGUgPSBuZXcgVmVydGV4QXR0cmlidXRlKHRoaXMsIEZsb2F0MzIsIDApDQogKiBgYGANCiAqDQogKiBAZXh0ZW5kcyBBdHRyaWJ1dGUNCiAqLw0KY2xhc3MgVmVydGV4QXR0cmlidXRlJDEgZXh0ZW5kcyBBdHRyaWJ1dGUgew0KICAvKioNCiAgICogQ3JlYXRlIHZlcnRleCBhdHRyaWJ1dGVzDQogICAqIEBwYXJhbSB7TWVzaH0gZ2VvbSAtIFRoZSBnZW9tIHZhbHVlLg0KICAgKiBAcGFyYW0ge0F0dHJWYWx1ZXxudW1iZXJ9IGRhdGFUeXBlIC0gVGhlIGRhdGFUeXBlIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcnxUeXBlZEFycmF5fSBleHBlY3RlZFNpemUgLSBUaGUgZXhwZWN0ZWRTaXplIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFNjYWxhclZhbHVlIC0gVGhlIGRlZmF1bHQgc2NhbGFyIHZhbHVlLg0KICAgKi8NCiAgY29uc3RydWN0b3IoZ2VvbSwgZGF0YVR5cGUsIGV4cGVjdGVkU2l6ZSwgZGVmYXVsdFNjYWxhclZhbHVlKSB7DQogICAgc3VwZXIoZGF0YVR5cGUsIGV4cGVjdGVkU2l6ZSwgZGVmYXVsdFNjYWxhclZhbHVlKTsNCiAgICB0aGlzLl9fZ2VvbSA9IGdlb207IC8vIFRPRE86IFdlYWtSZWY/Pw0KDQogICAgdGhpcy5fX3NwbGl0cyA9IHt9Ow0KICAgIHRoaXMuX19zcGxpdFZhbHVlcyA9IFtdOw0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBnZXRGYWNlVmVydGV4VmFsdWVSZWYgbWV0aG9kLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZSAtIFRoZSBmYWNlIHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZXZlcnRleCAtIFRoZSBmYWNlIHZlcnRleCB2YWx1ZS4NCiAgICogQHJldHVybiB7QXR0clZhbHVlfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRGYWNlVmVydGV4VmFsdWVSZWYoZmFjZSwgZmFjZXZlcnRleCkgew0KICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuX19nZW9tLmdldEZhY2VWZXJ0ZXhJbmRleChmYWNlLCBmYWNldmVydGV4KTsNCiAgICBpZiAodmVydGV4IGluIHRoaXMuX19zcGxpdHMgJiYgZmFjZSBpbiB0aGlzLl9fc3BsaXRzW3ZlcnRleF0pIHsNCiAgICAgIHJldHVybiB0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXQ0KICAgIH0NCiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZVJlZih2ZXJ0ZXgpDQogIH0NCg0KICAvKioNCiAgICogVGhlIHNldEZhY2VWZXJ0ZXhWYWx1ZSBtZXRob2QuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlIC0gVGhlIGZhY2UgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNldmVydGV4IC0gVGhlIGZhY2V2ZXJ0ZXggdmFsdWUuDQogICAqIEBwYXJhbSB7QXR0clZhbHVlfSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICovDQogIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNldmVydGV4LCB2YWx1ZSkgew0KICAgIGNvbnN0IHZlcnRleCA9IHRoaXMuX19nZW9tLmdldEZhY2VWZXJ0ZXhJbmRleChmYWNlLCBmYWNldmVydGV4KTsNCiAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpOw0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBzZXRGYWNlVmVydGV4VmFsdWVfQnlWZXJ0ZXhJbmRleCBtZXRob2QuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlIC0gVGhlIGZhY2UgdmFsdWUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLg0KICAgKiBAcGFyYW0ge0F0dHJWYWx1ZX0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAqLw0KICBzZXRGYWNlVmVydGV4VmFsdWVfQnlWZXJ0ZXhJbmRleChmYWNlLCB2ZXJ0ZXgsIHZhbHVlKSB7DQogICAgY29uc3QgdmFsdWVSZWYgPSB0aGlzLmdldFZhbHVlUmVmKHZlcnRleCk7DQogICAgaWYgKCF2YWx1ZVJlZi5pc1ZhbGlkKCkpIHsNCiAgICAgIC8vIHRoZSB2YWx1ZSBpcyB1bmluaXRpYWxpemVkLiBJbml0aWFsaXplIGl0Lg0KICAgICAgdmFsdWVSZWYuc2V0RnJvbU90aGVyKHZhbHVlKTsNCiAgICB9IGVsc2UgaWYgKHZhbHVlUmVmLmFwcHJveEVxdWFsKHZhbHVlKSkgOyBlbHNlIHsNCiAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHZhbHVlDQoNCiAgICAgIGlmICh2ZXJ0ZXggaW4gdGhpcy5fX3NwbGl0cykgew0KICAgICAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGV4aXN0aW5nIHNwbGl0cyBmb3IgdGhpcyB2ZXJ0ZXggbWF0Y2ggdGhlIHZhbHVlIGJlaW5nIHNldC4NCiAgICAgICAgLy8gaS5lLiBmb3IgZmFjZXMgYXJvdW5kIGEgdmVydGV4LCB0aGVyZSB3aWxsIG9mdGVuIGJlIGEgc2VhbSBhbG9uZyAyIGVkZ2VzDQogICAgICAgIC8vIHdoZXJlIHRoZSB2YWx1ZXMgZGlmZmVyLiBPbiBlYWNoIHNpZGUgb2YgdGhlIHNlYW0sIGFsbCBmYWNlcyBjYW4gdXNlIHRoZSBzYW1lDQogICAgICAgIC8vIHZhbHVlLiBXZSBzaG91bGQgc2VlIHRoZW4gb25seSBvbmUgc3BsaXQgdmFsdWUgZm9yIHRoZSB2ZXJ0ZXguDQogICAgICAgIGNvbnN0IHZlcnRleFNwbGl0SWRzID0gdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdOw0KICAgICAgICBmb3IgKGNvbnN0IGZpZCBpbiB2ZXJ0ZXhTcGxpdElkcykgew0KICAgICAgICAgIGNvbnN0IHNwbGl0SWQgPSB2ZXJ0ZXhTcGxpdElkc1tmaWRdOw0KICAgICAgICAgIGlmICh0aGlzLl9fc3BsaXRWYWx1ZXNbc3BsaXRJZF0uYXBwcm94RXF1YWwodmFsdWUpKSB7DQogICAgICAgICAgICAvLyByZS11c2UgdGhpcyBzcGxpdCB2YWx1ZQ0KICAgICAgICAgICAgdmVydGV4U3BsaXRJZHNbZmFjZV0gPSBzcGxpdElkOw0KICAgICAgICAgICAgcmV0dXJuDQogICAgICAgICAgfQ0KICAgICAgICB9DQoNCiAgICAgICAgLy8gSWYgYSBzcGxpdCBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBmYWNlLCByZS11c2UgaXQuDQogICAgICAgIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkgew0KICAgICAgICAgIGNvbnN0IHZhbHVlUmVmID0gdGhpcy5fX3NwbGl0VmFsdWVzW3RoaXMuX19zcGxpdHNbdmVydGV4XVtmYWNlXV07DQogICAgICAgICAgdmFsdWVSZWYuc2V0RnJvbU90aGVyKHZhbHVlKTsNCiAgICAgICAgICByZXR1cm4NCiAgICAgICAgfQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdID0ge307DQogICAgICB9DQogICAgICB0aGlzLl9fc3BsaXRzW3ZlcnRleF1bZmFjZV0gPSB0aGlzLl9fc3BsaXRWYWx1ZXMubGVuZ3RoOw0KICAgICAgdGhpcy5fX3NwbGl0VmFsdWVzLnB1c2godmFsdWUpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSBtZXRob2QuDQogICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZSAtIFRoZSBmYWNlIHZhbHVlLg0KICAgKiBAcGFyYW0ge0F0dHJWYWx1ZX0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAqLw0KICBzZXRTcGxpdFZlcnRleFZhbHVlKHZlcnRleCwgZmFjZSwgdmFsdWUpIHsNCiAgICBpZiAoISh2ZXJ0ZXggaW4gdGhpcy5fX3NwbGl0cykpIHRoaXMuX19zcGxpdHNbdmVydGV4XSA9IHt9Ow0KICAgIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkgew0KICAgICAgY29uc3QgY3VyclZhbHVlID0gdGhpcy5fX3NwbGl0VmFsdWVzW3RoaXMuX19zcGxpdHNbdmVydGV4XVtmYWNlXV07DQogICAgICBpZiAoY3VyclZhbHVlLmFwcHJveEVxdWFsKHZhbHVlKSkgcmV0dXJuDQogICAgICBjb25zb2xlLndhcm4oJ0ZhY2UgVmVydGV4IEFscmVhZHkgU3BsaXQgd2l0aCBkaWZmZXJlbnQgdmFsdWUnKTsNCiAgICB9DQogICAgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdID0gdGhpcy5fX3NwbGl0VmFsdWVzLmxlbmd0aDsNCiAgICB0aGlzLl9fc3BsaXRWYWx1ZXMucHVzaCh2YWx1ZSk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIHNldFNwbGl0VmVydGV4VmFsdWVzIG1ldGhvZC4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuDQogICAqIEBwYXJhbSB7YXJyYXl9IGZhY2VHcm91cCAtIFRoZSBmYWNlR3JvdXAgdmFsdWUuDQogICAqIEBwYXJhbSB7QXR0clZhbHVlfSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICovDQogIHNldFNwbGl0VmVydGV4VmFsdWVzKHZlcnRleCwgZmFjZUdyb3VwLCB2YWx1ZSkgew0KICAgIGlmICghKHZlcnRleCBpbiB0aGlzLl9fc3BsaXRzKSkgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdID0ge307DQogICAgY29uc3Qgc3BsaXRJbmRleCA9IHRoaXMuX19zcGxpdFZhbHVlcy5sZW5ndGg7DQogICAgdGhpcy5fX3NwbGl0VmFsdWVzLnB1c2godmFsdWUpOw0KICAgIGZvciAoY29uc3QgZmFjZSBvZiBmYWNlR3JvdXApIHsNCiAgICAgIC8vIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkgew0KICAgICAgLy8gICAgIGxldCBjdXJyVmFsdWUgPSB0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXTsNCiAgICAgIC8vICAgICBpZiAoY3VyclZhbHVlLmFwcHJveEVxdWFsKHZhbHVlKSkNCiAgICAgIC8vICAgICAgICAgcmV0dXJuOw0KICAgICAgLy8gICAgIGNvbnNvbGUud2FybigiRmFjZSBWZXJ0ZXggQWxyZWFkeSBTcGxpdCB3aXRoIGRpZmZlcmVudCB2YWx1ZSIpOw0KICAgICAgLy8gfQ0KICAgICAgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdID0gc3BsaXRJbmRleDsNCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogVGhlIGdldFNwbGl0cyBtZXRob2QuDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRTcGxpdHMoKSB7DQogICAgcmV0dXJuIHRoaXMuX19zcGxpdHMNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgZ2V0U3BsaXRDb3VudCBtZXRob2QuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0U3BsaXRDb3VudCgpIHsNCiAgICBsZXQgc3BsaXRDb3VudCA9IDA7DQogICAgZm9yIChjb25zdCB2ZXJ0ZXggaW4gdGhpcy5fX3NwbGl0cykgc3BsaXRDb3VudCArPSBPYmplY3Qua2V5cyh0aGlzLl9fc3BsaXRzW3ZlcnRleF0pLmxlbmd0aDsNCiAgICByZXR1cm4gc3BsaXRDb3VudA0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBnZW5lcmF0ZVNwbGl0VmFsdWVzIG1ldGhvZC4NCiAgICogQHBhcmFtIHthcnJheX0gc3BsaXRJbmRpY2VzIC0gVGhlIHNwbGl0SW5kaWNlcyB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IHNwbGl0Q291bnQgLSBUaGUgc3BsaXRDb3VudCB2YWx1ZS4NCiAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZW5lcmF0ZVNwbGl0VmFsdWVzKHNwbGl0SW5kaWNlcywgc3BsaXRDb3VudCkgew0KICAgIGlmIChzcGxpdENvdW50ID09IDApIHJldHVybiB0aGlzLl9fZGF0YQ0KDQogICAgY29uc3QgbnVtVW5TcGxpdFZhbHVlcyA9IHRoaXMubGVuZ3RoOw0KICAgIGNvbnN0IGNvdW50ID0gdGhpcy5sZW5ndGggKyBzcGxpdENvdW50Ow0KICAgIGNvbnN0IG51bUVsZW1zID0gdGhpcy5fX2RhdGFUeXBlLm51bUVsZW1lbnRzID8gdGhpcy5fX2RhdGFUeXBlLm51bUVsZW1lbnRzKCkgOiAxOw0KICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogbnVtRWxlbXMpOw0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fX2RhdGEubGVuZ3RoOyBpKyspIGRhdGFbaV0gPSB0aGlzLl9fZGF0YVtpXTsNCg0KICAgIC8vIE5vdyBkdXBsaWNhdGUgdGhlIHNwbGl0IHZhbHVlcyB0byBnZW5lcmF0ZSBhbiBhdHRyaWJ1dGVzIGFycmF5DQogICAgLy8gdXNpZyB0aGUgc2hhcmVkIHNwbGl0cyBhY2Nyb3NzIGFsbCBhdHRyaWJ1dGVzLg0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4NCiAgICBmb3IgKGNvbnN0IHZlcnRleCBpbiBzcGxpdEluZGljZXMpIHsNCiAgICAgIGNvbnN0IGZhY2VzID0gc3BsaXRJbmRpY2VzW3ZlcnRleF07DQogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluDQogICAgICBmb3IgKGNvbnN0IGZhY2UgaW4gZmFjZXMpIHsNCiAgICAgICAgY29uc3QgdGd0ID0gbnVtVW5TcGxpdFZhbHVlcyArIGZhY2VzW2ZhY2VdOw0KICAgICAgICBpZiAodmVydGV4IGluIHRoaXMuX19zcGxpdHMgJiYgZmFjZSBpbiB0aGlzLl9fc3BsaXRzW3ZlcnRleF0pIHsNCiAgICAgICAgICAvLyB0aGlzIGF0dHJpYnVlIGhhcyBhIHNwbGl0IHZhbHVlIGluIGl0cyBhcnJheS4NCiAgICAgICAgICAvLyB3ZSBtdXN0IHVzZSB0aGF0IHZhbHVlLi4uDQogICAgICAgICAgY29uc3Qgc3JjID0gdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdOw0KICAgICAgICAgIGlmICh0aGlzLl9fZGF0YVR5cGUgPT0gRmxvYXQzMikgZGF0YVt0Z3QgKiBudW1FbGVtc10gPSB0aGlzLl9fc3BsaXRWYWx1ZXNbc3JjXTsNCiAgICAgICAgICBlbHNlIHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tQnVmZmVyKGRhdGEuYnVmZmVyLCB0Z3QgKiBudW1FbGVtcyAqIDQpLnNldEZyb21PdGhlcih0aGlzLl9fc3BsaXRWYWx1ZXNbc3JjXSk7DQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgLy8gQ29weSBlYWNoIHNjYWxhciB2YWx1ZSB0byB0aGUgbmV3IHBsYWNlIGluIHRoZSBhcnJheS4NCiAgICAgICAgICBjb25zdCBzcmMgPSBwYXJzZUludCh2ZXJ0ZXgpOw0KICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbnVtRWxlbXM7IGUrKykgew0KICAgICAgICAgICAgaWYgKHNyYyAqIG51bUVsZW1zICsgZSA+IHRoaXMuX19kYXRhLmxlbmd0aCkgew0KICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcmVtYXBwaW5nIHNyYzonICsgc3JjICogbnVtRWxlbXMgKyBlKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICh0Z3QgKiBudW1FbGVtcyArIGUgPiBkYXRhLmxlbmd0aCkgew0KICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcmVtYXBwaW5nIHRndDonICsgdGd0ICogbnVtRWxlbXMgKyBlKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGRhdGFbdGd0ICogbnVtRWxlbXMgKyBlXSA9IHRoaXMuX19kYXRhW3NyYyAqIG51bUVsZW1zICsgZV07DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQogICAgfQ0KICAgIHJldHVybiBkYXRhDQogIH0NCg0KICAvKioNCiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICovDQogIHRvSlNPTihjb250ZXh0KSB7DQogICAgY29uc3QganNvbiA9IHN1cGVyLnRvSlNPTihjb250ZXh0KTsNCiAgICBqc29uLnNwbGl0cyA9IHRoaXMuX19zcGxpdHM7DQogICAganNvbi5zcGxpdFZhbHVlcyA9IHRoaXMuX19zcGxpdFZhbHVlczsNCiAgICByZXR1cm4ganNvbg0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICovDQogIGZyb21KU09OKGpzb24sIGNvbnRleHQpIHsNCiAgICBzdXBlci5mcm9tSlNPTihqc29uLCBjb250ZXh0KTsNCiAgICB0aGlzLl9fc3BsaXRzID0ganNvbi5zcGxpdHM7DQogICAgdGhpcy5fX3NwbGl0VmFsdWVzID0gW107DQogICAgZm9yIChjb25zdCB2YWxqc29uIG9mIGpzb24uc3BsaXRWYWx1ZXMpIHRoaXMuX19zcGxpdFZhbHVlcy5wdXNoKHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tSlNPTih2YWxqc29uKSk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIGxvYWRTcGxpdFZhbHVlcyBtZXRob2QuDQogICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgKi8NCiAgbG9hZFNwbGl0VmFsdWVzKHJlYWRlcikgew0KICAgIGNvbnN0IHNwbGl0SW5kaWNlcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsNCiAgICBpZiAoc3BsaXRJbmRpY2VzLmxlbmd0aCA9PSAwKSByZXR1cm4NCiAgICBsZXQgb2Zmc2V0ID0gMDsNCiAgICBsZXQgbnVtU3BsaXRWYWx1ZXMgPSAwOw0KICAgIHdoaWxlICh0cnVlKSB7DQogICAgICBjb25zdCB2ZXJ0ZXhJZCA9IHNwbGl0SW5kaWNlc1tvZmZzZXQrK107DQogICAgICBjb25zdCBudW1TcGxpdHMgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdOw0KDQogICAgICBjb25zdCBzcGxpdHMgPSB7fTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3BsaXRzOyBpKyspIHsNCiAgICAgICAgY29uc3QgZmFjZUlkID0gc3BsaXRJbmRpY2VzW29mZnNldCsrXTsNCiAgICAgICAgY29uc3Qgc3BsaXRJZCA9IHNwbGl0SW5kaWNlc1tvZmZzZXQrK107DQogICAgICAgIHNwbGl0c1tmYWNlSWRdID0gc3BsaXRJZDsNCiAgICAgICAgaWYgKHNwbGl0SWQgPj0gbnVtU3BsaXRWYWx1ZXMpIG51bVNwbGl0VmFsdWVzID0gc3BsaXRJZCArIDE7DQogICAgICB9DQogICAgICB0aGlzLl9fc3BsaXRzW3ZlcnRleElkXSA9IHNwbGl0czsNCiAgICAgIGlmIChvZmZzZXQgPj0gc3BsaXRJbmRpY2VzLmxlbmd0aCkgYnJlYWsNCiAgICB9DQogICAgY29uc3QgZGltID0gdGhpcy5fX251bUZsb2F0MzJFbGVtZW50czsNCiAgICBjb25zdCBzcGxpdFZhbHVlcyA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KG51bVNwbGl0VmFsdWVzICogZGltKTsNCiAgICB0aGlzLl9fc3BsaXRWYWx1ZXMgPSBbXTsNCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNwbGl0VmFsdWVzOyBpKyspIHsNCiAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tRmxvYXQzMkFycmF5KHNwbGl0VmFsdWVzLnNsaWNlKGkgKiBkaW0sIGkgKiBkaW0gKyBkaW0pKTsNCiAgICAgIHRoaXMuX19zcGxpdFZhbHVlcy5wdXNoKHZhbCk7DQogICAgfQ0KICB9DQp9CgovKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi8NCg0KLyoqDQogKiBUaGUgTWVzaCBjbGFzcyBwcm92aWRlcyBhIGZsZXhpYmxlIGFuZCBmYXN0IHBvbHlnb24gbWVzaCByZXByZXNlbnRhdGlvbi4gSXQgc3VwcG9ydHMgcG9seWdvbnMgb2YgYXJiaXRyYXJ5IGNvbXBsZXhpdHksDQogKiBmcm9tIGJhc2ljIHRyaWFuZ2xlcyBhbmQgcXVhZHMgdG8gcGVudGFnb25zIG1vcmUuDQogKiBJdCBzdXBwb3J0cyBzdG9yaW5nIHBlciBmYWNlIGF0dHJpYnV0ZXMsIGFuZCBwZXIgZWRnZSBhdHRyaWJ1dGVzLg0KICogVGhlIE1lc2ggY2xhc3MgaGFuZGxlcyBjb252ZXJ0aW5nIGl0cyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBwb2x5Z29ucyBpbnRvIGEgc2ltcGxlciB0cmlhbmdsZXMgcmVwcmVzZW50YXRpb24gZm9yIHJlbmRlcmluZy4NCiAqDQogKiBgYGANCiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaCgpDQogKiBgYGANCiAqDQogKiAqKkV2ZW50cyoqDQogKiAqICoqZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIHRvcG9sb2d5IG9mIHRoZSBtZXNoIGhhcyBiZWVuIGNoYW5nZWQuDQogKiAqICoqZ2VvbURhdGFDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgbWVzaCBoYXZlIGNoYW5nZWQsIGJ1dCBub3QgbmVjZXNzYXJpbHkgdGhlIHRvcG9sb2d5Lg0KICoNCiAqIEBleHRlbmRzIEJhc2VHZW9tDQogKi8NCmNsYXNzIE1lc2ggZXh0ZW5kcyBCYXNlR2VvbSB7DQogIC8qKg0KICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1lc2guDQogICAqLw0KICBjb25zdHJ1Y3RvcigpIHsNCiAgICBzdXBlcigpOw0KICAgIHRoaXMuaW5pdCgpOw0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBpbml0IG1ldGhvZC4NCiAgICogQHByaXZhdGUNCiAgICovDQogIGluaXQoKSB7DQogICAgdGhpcy5fX2ZhY2VDb3VudHMgPSBbXTsNCiAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKTsNCg0KICAgIHRoaXMuX19mYWNlQXR0cmlidXRlcyA9IG5ldyBNYXAoKTsNCiAgICB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7DQoNCiAgICB0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyA9IGZhbHNlOw0KDQogICAgdGhpcy5lZGdlVmVydHMgPSB1bmRlZmluZWQ7DQogICAgdGhpcy52ZXJ0ZXhFZGdlcyA9IHVuZGVmaW5lZDsNCiAgICB0aGlzLm51bUVkZ2VzID0gMDsNCiAgICB0aGlzLmVkZ2VBbmdsZXMgPSBuZXcgRmxvYXQzMkFycmF5KCk7DQogIH0NCg0KICAvKioNCiAgICogVGhlIGdldEZhY2VDb3VudHMgbWV0aG9kLg0KICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0RmFjZUNvdW50cygpIHsNCiAgICByZXR1cm4gdGhpcy5fX2ZhY2VDb3VudHMNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgZ2V0TnVtRmFjZXMgbWV0aG9kLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldE51bUZhY2VzKCkgew0KICAgIHJldHVybiB0aGlzLl9fZmFjZUNvdW50cy5sZW5ndGggPT0gMCA/IDAgOiB0aGlzLl9fZmFjZUNvdW50cy5yZWR1Y2UoKG51bUZhY2VzLCBmYykgPT4gKG51bUZhY2VzICs9IGZjKSkNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgY2xlYXIgbWV0aG9kLg0KICAgKi8NCiAgY2xlYXIoKSB7DQogICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gdW5kZWZpbmVkOw0KICAgIHRoaXMuX19mYWNlQ291bnRzID0gW107DQogIH0NCg0KICAvKioNCiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGZhY2VzIG9uIHRoZSBtZXNoIHVzaW5nIGFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGNvdW50cyBwZXIgcG9seWdvbiBzaXplLg0KICAgKiBUaGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLCB0aGUgc2Vjb25kLCB0aGUgbnVtYmVyIG9mIHF1YWRzLCB0aGUgM3JkLCB0aGUgbnVtYmVyIG8gZjUgc2lkZWQgcG9seWdvbnMgZXRjLi4NCiAgICogZS5nLiB0byBzcGVjaWZ5IDIgdHJpYW5nbGVzLCBhbmQgNyBxdWFkcywgd2Ugd291bGQgcGFzcyBbMiwgN10NCiAgICogQHBhcmFtIHthcnJheX0gZmFjZUNvdW50cyAtIFRoZSBmYWNlQ291bnRzIHZhbHVlLg0KICAgKi8NCiAgc2V0RmFjZUNvdW50cyhmYWNlQ291bnRzKSB7DQogICAgbGV0IG51bUZhY2VzID0gMDsNCiAgICBsZXQgbnVtRmFjZXNWZXJ0aWNlcyA9IDA7DQogICAgbGV0IG51bVZlcnRzUGVyRmFjZSA9IDM7DQogICAgZm9yIChjb25zdCBmYyBvZiBmYWNlQ291bnRzKSB7DQogICAgICBudW1GYWNlcyArPSBmYzsNCiAgICAgIG51bUZhY2VzVmVydGljZXMgKz0gZmMgKiBudW1WZXJ0c1BlckZhY2U7DQogICAgICBudW1WZXJ0c1BlckZhY2UrKzsNCiAgICB9DQoNCiAgICBjb25zdCBwcmV2TnVtRmFjZXMgPSB0aGlzLmdldE51bUZhY2VzKCk7DQogICAgaWYgKHByZXZOdW1GYWNlcyA9PSAwKSB7DQogICAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobnVtRmFjZXNWZXJ0aWNlcyk7DQogICAgfSBlbHNlIHsNCiAgICAgIGNvbnN0IGZhY2VWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG51bUZhY2VzVmVydGljZXMpOw0KDQogICAgICAvLyBOb3cgd2UgcHJlc2VydmUgdGhlIGV4aXN0aW5nIGluZGljZXMgaWYgdGhleSBmaXQgd2l0aGluIHRoZSBuZXcgZmFjZVZlcnRleEluZGljZXMgYXJyYXkuDQogICAgICBsZXQgc3RhcnRTcmMgPSAwOw0KICAgICAgbGV0IHN0YXJ0VGd0ID0gMDsNCiAgICAgIG51bUZhY2VzVmVydGljZXMgPSAwOw0KICAgICAgbnVtVmVydHNQZXJGYWNlID0gMzsNCiAgICAgIGZhY2VDb3VudHMuZm9yRWFjaCgoZmMsIGluZGV4KSA9PiB7DQogICAgICAgIGNvbnN0IGVuZFNyYyA9IHN0YXJ0U3JjICsgTWF0aC5taW4oZmMsIHRoaXMuX19mYWNlQ291bnRzW2luZGV4XSkgKiBudW1WZXJ0c1BlckZhY2U7DQogICAgICAgIGZhY2VWZXJ0ZXhJbmRpY2VzLnNldCh0aGlzLl9fZmFjZVZlcnRleEluZGljZXMuc2xpY2Uoc3RhcnRTcmMsIGVuZFNyYyksIHN0YXJ0VGd0KTsNCiAgICAgICAgc3RhcnRTcmMgKz0gdGhpcy5fX2ZhY2VDb3VudHNbaW5kZXhdICogbnVtVmVydHNQZXJGYWNlOw0KICAgICAgICBzdGFydFRndCArPSBmYyAqIG51bVZlcnRzUGVyRmFjZTsNCiAgICAgICAgbnVtVmVydHNQZXJGYWNlKys7DQogICAgICB9KTsNCiAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcyA9IGZhY2VWZXJ0ZXhJbmRpY2VzOw0KICAgIH0NCiAgICB0aGlzLl9fZmFjZUNvdW50cyA9IGZhY2VDb3VudHM7DQoNCiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgdGhpcy5fX2ZhY2VBdHRyaWJ1dGVzKSBhdHRyLnJlc2l6ZShudW1GYWNlcyk7DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluZGV4ZWQgYnkgdGhpcyBmYWNlDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpIHsNCiAgICBsZXQgaWR4ID0gMDsNCiAgICBsZXQgY291bnQgPSAwOw0KICAgIHRoaXMuX19mYWNlQ291bnRzLnNvbWUoKGZjLCBpbmRleCkgPT4gew0KICAgICAgaWR4ICs9IGZjOw0KICAgICAgaWYgKGlkeCA+IGZhY2VJbmRleCkgew0KICAgICAgICBjb3VudCA9IGluZGV4ICsgMzsNCiAgICAgICAgcmV0dXJuIHRydWUNCiAgICAgIH0NCiAgICB9KTsNCiAgICByZXR1cm4gY291bnQNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIGZhY2UgaW5kaWNlcyB3aXRoaW4gdGhlIGVudGlyZSBpbmRleCBhcnJheS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY2VJbmRleCAtIFRoZSBmYWNlSW5kZXggdmFsdWUuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2V0RmFjZVZlcnRleE9mZnNldChmYWNlSW5kZXgpIHsNCiAgICBsZXQgaWR4ID0gMDsNCiAgICBsZXQgb2Zmc2V0ID0gMDsNCiAgICB0aGlzLl9fZmFjZUNvdW50cy5zb21lKChmYywgaW5kZXgpID0+IHsNCiAgICAgIGlmIChpZHggKyBmYyA+IGZhY2VJbmRleCkgew0KICAgICAgICBvZmZzZXQgKz0gKGZhY2VJbmRleCAtIGlkeCkgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgcmV0dXJuIHRydWUNCiAgICAgIH0NCiAgICAgIGlkeCArPSBmYzsNCiAgICAgIG9mZnNldCArPSBmYyAqIChpbmRleCArIDMpOw0KICAgIH0pOw0KICAgIHJldHVybiBvZmZzZXQNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgc2V0RmFjZVZlcnRleEluZGljZXMgbWV0aG9kLg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZUluZGV4IC0gVGhlIGZhY2VJbmRleCB2YWx1ZS4NCiAgICogQHBhcmFtIHthcnJheX0gdmVydGV4SW5kaWNlcyAtIFRoZSBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBmb3IgdGhpcyBmYWNlIHZhbHVlLg0KICAgKi8NCiAgc2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRpY2VzKSB7DQogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT0gMikgew0KICAgICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIGludGVyZmFjZS4gUGxlYXNlIHBhc3MgdmVydGV4SW5kaWNlcyBhcyBhbiBhcnJheWApOw0KICAgICAgdmVydGV4SW5kaWNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7DQogICAgfQ0KICAgIGNvbnN0IGZhY2VWZXJ0ZXhDb3VudCA9IHRoaXMuZ2V0RmFjZVZlcnRleENvdW50KGZhY2VJbmRleCk7DQogICAgaWYgKHZlcnRleEluZGljZXMubGVuZ3RoICE9IGZhY2VWZXJ0ZXhDb3VudCkgew0KICAgICAgdGhyb3cgbmV3IEVycm9yKA0KICAgICAgICBgSW52YWxpZCBpbmRpY2VzIGZvciBmYWNlOiR7ZmFjZUluZGV4fSB2ZXJ0ZXhJbmRpY2VzOiR7dmVydGV4SW5kaWNlc30uIEV4cGVjdGVkICR7ZmFjZVZlcnRleENvdW50fSBpbmRpY2VzYA0KICAgICAgKQ0KICAgIH0NCiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsNCiAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXMuc2V0KHZlcnRleEluZGljZXMsIG9mZnNldCk7DQogIH0NCg0KICAvKioNCiAgICogQWRkcyBhIG5ldyBmYWNlIHRvIHRoZSBtZXNoDQogICAqIEBwYXJhbSB7YXJyYXl9IHZlcnRleEluZGljZXMgLSBUaGUgdmVydGV4IGluZGljZXMgb2YgdGhlIGZhY2UuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgaW5kZXggb2YgdGhlIGZhY2UgaW4gdGhlIG1lc2guDQogICAqLw0KICBhZGRGYWNlKHZlcnRleEluZGljZXMpIHsNCiAgICBjb25zdCBmYWNlQ291bnRzID0gWy4uLnRoaXMuX19mYWNlQ291bnRzXTsNCiAgICBpZiAoZmFjZUNvdW50cy5sZW5ndGggPD0gdmVydGV4SW5kaWNlcy5sZW5ndGggLSAzKSB7DQogICAgICBmb3IgKGxldCBpID0gZmFjZUNvdW50cy5sZW5ndGg7IGkgPCB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCAtIDM7IGkrKykgZmFjZUNvdW50c1tpXSA9IDA7DQogICAgICBmYWNlQ291bnRzW3ZlcnRleEluZGljZXMubGVuZ3RoIC0gM10gPSAxOw0KICAgIH0gZWxzZSB7DQogICAgICBmYWNlQ291bnRzW3ZlcnRleEluZGljZXMubGVuZ3RoIC0gM10rKzsNCiAgICB9DQogICAgdGhpcy5zZXRGYWNlQ291bnRzKGZhY2VDb3VudHMpOw0KDQogICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgaW4gdGhlIGZhY2VWZXJ0ZXhJbmRpY2VzIG9mIHRoaXMgbmV3IGZhY2UuDQogICAgbGV0IGZhY2VJbmRleCA9IDA7DQogICAgbGV0IG9mZnNldCA9IDA7DQogICAgdGhpcy5fX2ZhY2VDb3VudHMuc29tZSgoZmMsIGluZGV4KSA9PiB7DQogICAgICBpZiAoaW5kZXggKyAzID09IHZlcnRleEluZGljZXMubGVuZ3RoKSB7DQogICAgICAgIGZhY2VJbmRleCArPSBmYyAtIDE7DQogICAgICAgIG9mZnNldCArPSAoZmMgLSAxKSAqIChpbmRleCArIDMpOw0KICAgICAgICByZXR1cm4gdHJ1ZQ0KICAgICAgfQ0KICAgICAgZmFjZUluZGV4ICs9IGZjOw0KICAgICAgb2Zmc2V0ICs9IGZjICogKGluZGV4ICsgMyk7DQogICAgfSk7DQogICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzLnNldCh2ZXJ0ZXhJbmRpY2VzLCBvZmZzZXQpOw0KICAgIHJldHVybiBmYWNlSW5kZXgNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSB2ZXJ0ZXggaW5kaWNlcyBvZiB0aGUgc3BlY2lmaWVkIGZhY2UuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBmYWNlDQogICAqIEByZXR1cm4ge2FycmF5fSAtIEFuIGFycmF5IG9mIGluZGljZXMgaW50byB0aGUgdmVydGV4IGF0dHJpYnV0ZXMNCiAgICovDQogIGdldEZhY2VWZXJ0ZXhJbmRpY2VzKGZhY2VJbmRleCkgew0KICAgIGNvbnN0IHZlcnRleEluZGljZXMgPSBbXTsNCiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsNCiAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0RmFjZVZlcnRleENvdW50KGZhY2VJbmRleCk7DQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7DQogICAgICB2ZXJ0ZXhJbmRpY2VzLnB1c2godGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW29mZnNldCArIGldKTsNCiAgICB9DQogICAgcmV0dXJuIHZlcnRleEluZGljZXMNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgc2luZ2xlIHZlcnRleCBpbmRleCBmb3IgYSBnaXZlbiBmYWNlIGFuZCBmYWNldmVydGV4Lg0KICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZUluZGV4IC0gVGhlIGZhY2VJbmRleCB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY2V2ZXJ0ZXggLSBUaGUgZmFjZSB2ZXJ0ZXggaXMgdGhlIGluZGV4IHdpdGhpbiB0aGUgZmFjZS4gU28gdGhlIGZpcnN0IHZlcnRleCBpbmRleCBpcyAwLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHZlcnRleCBpbmRleA0KICAgKi8NCiAgZ2V0RmFjZVZlcnRleEluZGV4KGZhY2VJbmRleCwgZmFjZXZlcnRleCkgew0KICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0RmFjZVZlcnRleE9mZnNldChmYWNlSW5kZXgpOw0KICAgIHJldHVybiB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbb2Zmc2V0ICsgZmFjZXZlcnRleF0NCiAgfQ0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAvLyBWZXJ0ZXggQXR0cmlidXRlcw0KDQogIC8qKg0KICAgKiBBZGRzIGEgYFZlcnRleEF0dHJpYnV0ZWAgdG8gdGhlIGdlb21ldHJ5Lg0KICAgKg0KICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIHRvIGFkZC4NCiAgICogQHBhcmFtIHtBdHRyVmFsdWV8bnVtYmVyfSBkYXRhVHlwZSAtIFRoZSBkYXRhVHlwZSB2YWx1ZS4NCiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRTY2FsYXJWYWx1ZSAtIFRoZSBkZWZhdWx0IHNjYWxhciB2YWx1ZS4NCiAgICogQHJldHVybiB7VmVydGV4QXR0cmlidXRlfSAtIFJldHVybnMgYSB2ZXJ0ZXggYXR0cmlidXRlLg0KICAgKi8NCiAgYWRkVmVydGV4QXR0cmlidXRlKG5hbWUsIGRhdGFUeXBlLCBkZWZhdWx0U2NhbGFyVmFsdWUgPSB1bmRlZmluZWQpIHsNCiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJyk7DQogICAgY29uc3QgYXR0ciA9IG5ldyBWZXJ0ZXhBdHRyaWJ1dGUkMSh0aGlzLCBkYXRhVHlwZSwgcG9zaXRpb25zICE9IHVuZGVmaW5lZCA/IHBvc2l0aW9ucy5sZW5ndGggOiAwLCBkZWZhdWx0U2NhbGFyVmFsdWUpOw0KICAgIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLnNldChuYW1lLCBhdHRyKTsNCiAgICByZXR1cm4gYXR0cg0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIEZhY2UgQXR0cmlidXRlcw0KDQogIC8qKg0KICAgKiBUaGUgYWRkRmFjZUF0dHJpYnV0ZSBtZXRob2QuDQogICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZhY2UgYXR0cmlidXRlIHRvIGFkZC4NCiAgICogQHBhcmFtIHtBdHRyVmFsdWV8bnVtYmVyfSBkYXRhVHlwZSAtIFRoZSBkYXRhIHR5cGUuDQogICAqIEBwYXJhbSB7bnVtYmVyfFR5cGVkQXJyYXl9IGNvdW50IC0gVGhlIGNvdW50IHZhbHVlLg0KICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IC0gUmV0dXJucyBhIGZhY2UgYXR0cmlidXRlLg0KICAgKi8NCiAgYWRkRmFjZUF0dHJpYnV0ZShuYW1lLCBkYXRhVHlwZSwgY291bnQgPSB1bmRlZmluZWQpIHsNCiAgICBjb25zdCBhdHRyID0gbmV3IEF0dHJpYnV0ZShkYXRhVHlwZSwgY291bnQgIT0gdW5kZWZpbmVkID8gY291bnQgOiB0aGlzLmdldE51bUZhY2VzKCkpOw0KICAgIHRoaXMuX19mYWNlQXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7DQogICAgcmV0dXJuIGF0dHINCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgaGFzRmFjZUF0dHJpYnV0ZSBtZXRob2QuDQogICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZhY2UgYXR0cmlidXRlLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBoYXNGYWNlQXR0cmlidXRlKG5hbWUpIHsNCiAgICByZXR1cm4gdGhpcy5fX2ZhY2VBdHRyaWJ1dGVzLmhhcyhuYW1lKQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBnZXRGYWNlQXR0cmlidXRlIG1ldGhvZC4NCiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZSBhdHRyaWJ1dGUuDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGdldEZhY2VBdHRyaWJ1dGUobmFtZSkgew0KICAgIHJldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuZ2V0KG5hbWUpDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIEVkZ2UgQXR0cmlidXRlcw0KDQogIC8qKg0KICAgKiBUaGUgYWRkRWRnZUF0dHJpYnV0ZSBtZXRob2QuDQogICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVkZ2UgYXR0cmlidXRlIHQgb2FkZC4NCiAgICogQHBhcmFtIHtBdHRyVmFsdWV8bnVtYmVyfSBkYXRhVHlwZSAtIFRoZSBkYXRhIHR5cGUuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBkZWZhdWx0IHNjYWxhciB2YWx1ZS4NCiAgICogQHJldHVybiB7QXR0cmlidXRlfSAtIFJldHVybnMgYW4gZWRnZSBhdHRyaWJ1dGUuDQogICAqLw0KICBhZGRFZGdlQXR0cmlidXRlKG5hbWUsIGRhdGFUeXBlLCBjb3VudCA9IHVuZGVmaW5lZCkgew0KICAgIGNvbnN0IGF0dHIgPSBuZXcgQXR0cmlidXRlKGRhdGFUeXBlLCBjb3VudCAhPSB1bmRlZmluZWQgPyBjb3VudCA6IHRoaXMuZ2V0TnVtRWRnZXMoKSk7DQogICAgdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLnNldChuYW1lLCBhdHRyKTsNCiAgICByZXR1cm4gYXR0cg0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBoYXNFZGdlQXR0cmlidXRlIG1ldGhvZC4NCiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGUuDQogICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGhhc0VkZ2VBdHRyaWJ1dGUobmFtZSkgew0KICAgIHJldHVybiB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMuaGFzKG5hbWUpDQogIH0NCg0KICAvKioNCiAgICogVGhlIGdldEVkZ2VBdHRyaWJ1dGUgbWV0aG9kLg0KICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlZGdlIGF0dHJpYnV0ZS4NCiAgICogQHJldHVybiB7QXR0cmlidXRlfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBnZXRFZGdlQXR0cmlidXRlKG5hbWUpIHsNCiAgICByZXR1cm4gdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLmdldChuYW1lKQ0KICB9DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQoNCiAgLyoqDQogICAqIFRoZSBnZW5Ub3BvbG9neUluZm8gbWV0aG9kLg0KICAgKi8NCiAgZ2VuVG9wb2xvZ3lJbmZvKCkgew0KICAgIGNvbnN0IGNvbm5lY3RlZFZlcnRpY2VzID0ge307IC8vIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUuDQogICAgdGhpcy52ZXJ0ZXhFZGdlcyA9IFtdOyAvLyAyZCBhcnJheSBvZiB2ZXJ0ZXggdG8gZWRnZXMuDQogICAgLy8gdGhpcy52ZXJ0ZXhGYWNlcyA9IFtdOyAvLyAyZCBhcnJheSBvZiB2ZXJ0ZXggdG8gZmFjZXMuDQogICAgdGhpcy5lZGdlRmFjZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiAyIGZhY2UgaW5kaWNlcyBwZXIgZWRnZQ0KICAgIHRoaXMuZWRnZVZlcnRzID0gW107IC8vIGZsYXQgYXJyYXkgb2YgMiB2ZXJ0IGluZGljZXMgcGVyIGVkZ2UNCiAgICB0aGlzLmZhY2VFZGdlcyA9IFtdOyAvLyB0aGUgZWRnZXMgYm9yZGVyaW5nIGVhY2ggZmFjZS4NCiAgICB0aGlzLm51bUVkZ2VzID0gMDsNCg0KICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKTsNCiAgICBjb25zdCBnZXRFZGdlSW5kZXggPSAodjAsIHYxKSA9PiB7DQogICAgICBsZXQgdG1wMCA9IHYwOw0KICAgICAgbGV0IHRtcDEgPSB2MTsNCiAgICAgIGlmICh0bXAxIDwgdG1wMCkgew0KICAgICAgICBjb25zdCB0bXAgPSB0bXAwOw0KICAgICAgICB0bXAwID0gdG1wMTsNCiAgICAgICAgdG1wMSA9IHRtcDsNCiAgICAgIH0NCiAgICAgIGNvbnN0IGtleSA9IHRtcDAgKyAnPicgKyB0bXAxOw0KICAgICAgaWYgKGtleSBpbiBjb25uZWN0ZWRWZXJ0aWNlcykgew0KICAgICAgICAvLyBjb25zb2xlLmxvZyhrZXkgKyAnOicgKyBjb25uZWN0ZWRWZXJ0aWNlc1trZXldICsgIiBmYWNlOiIgKyAoIHYwIDwgdjEgPyAwIDogMSkgKTsNCiAgICAgICAgcmV0dXJuIGNvbm5lY3RlZFZlcnRpY2VzW2tleV0NCiAgICAgIH0NCg0KICAgICAgY29uc3QgcDAgPSBwb3NpdGlvbnMuZ2V0VmFsdWVSZWYodG1wMCk7DQogICAgICBjb25zdCBwMSA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZih0bXAxKTsNCiAgICAgIGNvbnN0IGVkZ2VWZWMgPSBwMS5zdWJ0cmFjdChwMCk7DQoNCiAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IHRoaXMuZWRnZUZhY2VzLmxlbmd0aCAvIDI7DQogICAgICBjb25zdCBlZGdlRGF0YSA9IHsNCiAgICAgICAgZWRnZUluZGV4OiBlZGdlSW5kZXgsDQogICAgICAgIGVkZ2VWZWM6IGVkZ2VWZWMsDQogICAgICB9Ow0KICAgICAgY29ubmVjdGVkVmVydGljZXNba2V5XSA9IGVkZ2VEYXRhOw0KDQogICAgICB0aGlzLmVkZ2VGYWNlcy5wdXNoKC0xKTsNCiAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpOw0KICAgICAgdGhpcy5lZGdlVmVydHMucHVzaCh0bXAwKTsNCiAgICAgIHRoaXMuZWRnZVZlcnRzLnB1c2godG1wMSk7DQogICAgICAvLyBjb25zb2xlLmxvZyhrZXkgKyAnOicgKyBjb25uZWN0ZWRWZXJ0aWNlc1trZXldICsgIiBmYWNlOiIgKyAoIHYwIDwgdjEgPyAwIDogMSkpOw0KDQogICAgICB0aGlzLm51bUVkZ2VzKys7DQogICAgICByZXR1cm4gZWRnZURhdGENCiAgICB9Ow0KDQogICAgY29uc3QgYWRkRWRnZSA9ICh2MCwgdjEsIGZhY2VJbmRleCkgPT4gew0KICAgICAgLy8gY29uc29sZS5sb2coJ2FkZEVkZ2U6JyArIHYwICsgIiA6IiArIHYxICsgIiBmYWNlSW5kZXg6IiArIGZhY2VJbmRleCApOw0KICAgICAgY29uc3QgZWRnZURhdGEgPSBnZXRFZGdlSW5kZXgodjAsIHYxKTsNCiAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IGVkZ2VEYXRhLmVkZ2VJbmRleDsNCiAgICAgIGlmICh2MSA8IHYwKSB7DQogICAgICAgIGNvbnN0IGVkZ2VGYWNlSW5kZXggPSBlZGdlSW5kZXggKiAyICsgMDsNCiAgICAgICAgaWYgKHRoaXMuX19sb2dUb3BvbG9neVdhcm5pbmdzICYmIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdICE9IC0xKQ0KICAgICAgICAgIGNvbnNvbGUud2FybignRWRnZSBwb2x5IDAgYWxyZWFkeSBzZXQuIE1lc2ggaXMgbm9uLW1hbmlmb2xkLicpOw0KICAgICAgICB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSA9IGZhY2VJbmRleDsNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIGNvbnN0IGVkZ2VGYWNlSW5kZXggPSBlZGdlSW5kZXggKiAyICsgMTsNCiAgICAgICAgaWYgKHRoaXMuX19sb2dUb3BvbG9neVdhcm5pbmdzICYmIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdICE9IC0xKQ0KICAgICAgICAgIGNvbnNvbGUud2FybignRWRnZSBwb2x5IDEgYWxyZWFkeSBzZXQuIE1lc2ggaXMgbm9uLW1hbmlmb2xkLicpOw0KICAgICAgICB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSA9IGZhY2VJbmRleDsNCiAgICAgIH0NCg0KICAgICAgaWYgKCEoZmFjZUluZGV4IGluIHRoaXMuZmFjZUVkZ2VzKSkgdGhpcy5mYWNlRWRnZXNbZmFjZUluZGV4XSA9IFtdOw0KICAgICAgdGhpcy5mYWNlRWRnZXNbZmFjZUluZGV4XS5wdXNoKGVkZ2VJbmRleCk7DQoNCiAgICAgIC8vIFB1c2ggdGhlIGVkZ2UgaW5kZXggb250byBib3RoIHZlcnRleCBlZGdlIGxpc3RzLg0KICAgICAgLy8gV2UgdXNlIFNldHMgdG8gYXZvaWQgYWRkaW5nIHRoZSBzYW1lIGVkZ2UgMnggdG8gdGhlIHNhbWUgdmVydGV4Lg0KICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbdjBdID09IHVuZGVmaW5lZCkgew0KICAgICAgICB0aGlzLnZlcnRleEVkZ2VzW3YwXSA9IG5ldyBTZXQoKTsNCiAgICAgIH0NCiAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW3YxXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MV0gPSBuZXcgU2V0KCk7DQogICAgICB9DQogICAgICB0aGlzLnZlcnRleEVkZ2VzW3YwXS5hZGQoZWRnZUluZGV4KTsNCiAgICAgIHRoaXMudmVydGV4RWRnZXNbdjFdLmFkZChlZGdlSW5kZXgpOw0KDQogICAgICAvLyBpZiAodGhpcy52ZXJ0ZXhGYWNlc1t2MF0gPT0gdW5kZWZpbmVkKSB7DQogICAgICAvLyAgICAgdGhpcy52ZXJ0ZXhGYWNlc1t2MF0gPSBbXTsNCiAgICAgIC8vIH0NCiAgICAgIC8vIHRoaXMudmVydGV4RmFjZXNbdjBdLnB1c2goZmFjZUluZGV4KTsNCiAgICB9Ow0KDQogICAgY29uc3QgbnVtRmFjZXMgPSB0aGlzLmdldE51bUZhY2VzKCk7DQogICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICBjb25zdCBmYWNlVmVydHMgPSB0aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKGZhY2VJbmRleCk7DQogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VWZXJ0cy5sZW5ndGg7IGorKykgew0KICAgICAgICBjb25zdCB2MCA9IGZhY2VWZXJ0c1tqXTsNCiAgICAgICAgY29uc3QgdjEgPSBmYWNlVmVydHNbKGogKyAxKSAlIGZhY2VWZXJ0cy5sZW5ndGhdOw0KICAgICAgICBhZGRFZGdlKHYwLCB2MSwgZmFjZUluZGV4KTsNCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ29tcHV0ZXMgYSBub3JtYWwgdmFsdWUgcGVyIGZhY2UgYnkgYXZlcmFnaW5nIHRoZSB0cmlhbmdsZSBub3JtYWxzIG9mIHRoZSBmYWNlLg0KICAgKi8NCiAgY29tcHV0ZUZhY2VOb3JtYWxzKCkgew0KICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKTsNCiAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuYWRkRmFjZUF0dHJpYnV0ZSgnbm9ybWFscycsIFZlYzMkMSk7DQogICAgY29uc3QgbnVtRmFjZXMgPSB0aGlzLmdldE51bUZhY2VzKCk7DQogICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICBjb25zdCBmYWNlVmVydHMgPSB0aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKGZhY2VJbmRleCk7DQogICAgICBjb25zdCBwMCA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZihmYWNlVmVydHNbMF0pOw0KICAgICAgY29uc3QgcDEgPSBwb3NpdGlvbnMuZ2V0VmFsdWVSZWYoZmFjZVZlcnRzWzFdKTsNCiAgICAgIGxldCBwcmV2ID0gcDE7DQogICAgICBjb25zdCBmYWNlTm9ybWFsID0gbmV3IFZlYzMkMSgpOw0KICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCBmYWNlVmVydHMubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgY29uc3QgcG4gPSBwb3NpdGlvbnMuZ2V0VmFsdWVSZWYoZmFjZVZlcnRzW2pdKTsNCiAgICAgICAgY29uc3QgdjAgPSBwcmV2LnN1YnRyYWN0KHAwKTsNCiAgICAgICAgY29uc3QgdjEgPSBwbi5zdWJ0cmFjdChwMCk7DQogICAgICAgIGZhY2VOb3JtYWwuYWRkSW5QbGFjZSh2MC5jcm9zcyh2MSkubm9ybWFsaXplKCkpOw0KICAgICAgICBwcmV2ID0gcG47DQogICAgICB9DQogICAgICBpZiAoZmFjZU5vcm1hbC5sZW5ndGhTcXVhcmVkKCkgPCBOdW1iZXIuRVBTSUxPTikgOyBlbHNlIHsNCiAgICAgICAgZmFjZU5vcm1hbHMuc2V0VmFsdWUoZmFjZUluZGV4LCBmYWNlTm9ybWFsLm5vcm1hbGl6ZSgpKTsNCiAgICAgIH0NCiAgICB9DQogIH0NCg0KICAvKioNCiAgICogQ2FsY3VsYXRlcyB0aGUgYW5nbGVzIGF0IGVhY2ggZWRnZSBiZXR3ZWVuIHRoZSBhZGpvaW5pbmcgZmFjZXMNCiAgICovDQogIGNhbGN1bGF0ZUVkZ2VBbmdsZXMoKSB7DQogICAgaWYgKHRoaXMudmVydGV4RWRnZXMgPT0gdW5kZWZpbmVkKSB0aGlzLmdlblRvcG9sb2d5SW5mbygpOw0KDQogICAgaWYgKCF0aGlzLmhhc0ZhY2VBdHRyaWJ1dGUoJ25vcm1hbHMnKSkgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTsNCg0KICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKTsNCiAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpOw0KICAgIHRoaXMuZWRnZVZlY3MgPSBbXTsNCiAgICB0aGlzLmVkZ2VBbmdsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtRWRnZXMpOw0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlRmFjZXMubGVuZ3RoOyBpICs9IDIpIHsNCiAgICAgIGNvbnN0IHYwID0gdGhpcy5lZGdlVmVydHNbaV07DQogICAgICBjb25zdCB2MSA9IHRoaXMuZWRnZVZlcnRzW2kgKyAxXTsNCiAgICAgIGNvbnN0IGVfdmVjID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKHYxKS5zdWJ0cmFjdChwb3NpdGlvbnMuZ2V0VmFsdWVSZWYodjApKTsNCiAgICAgIGVfdmVjLm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgICAgIHRoaXMuZWRnZVZlY3MucHVzaChlX3ZlYyk7DQoNCiAgICAgIGNvbnN0IHAwID0gdGhpcy5lZGdlRmFjZXNbaV07DQogICAgICBjb25zdCBwMSA9IHRoaXMuZWRnZUZhY2VzW2kgKyAxXTsNCiAgICAgIGlmIChwMCA9PSAtMSB8fCBwMSA9PSAtMSkgew0KICAgICAgICAvLyBGbGFnIHRoZSBlZGdlIGFzIGEgYm9yZGVyIGVkZ2UuLi4uDQogICAgICAgIHRoaXMuZWRnZUFuZ2xlc1tpIC8gMl0gPSBNYXRoLlBJICogMi4wOw0KICAgICAgICBjb250aW51ZQ0KICAgICAgfQ0KDQogICAgICBjb25zdCBuMCA9IGZhY2VOb3JtYWxzLmdldFZhbHVlUmVmKHAwKTsNCiAgICAgIGNvbnN0IG4xID0gZmFjZU5vcm1hbHMuZ2V0VmFsdWVSZWYocDEpOw0KICAgICAgdGhpcy5lZGdlQW5nbGVzW2kgLyAyXSA9IG4wLmFuZ2xlVG8objEpOw0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBDb21wdXRlIHZlcnRleCBub3JtYWxzLg0KICAgKiBAcGFyYW0ge251bWJlcn0gaGFyZEFuZ2xlIC0gVGhlIGhhcmRBbmdsZSB2YWx1ZSBpbiByYWRpYW5zLg0KICAgKiBAcmV0dXJuIHtWZXJ0ZXhBdHRyaWJ1dGV9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKGhhcmRBbmdsZSA9IDEuMCAvKiByYWRpYW5zICovKSB7DQogICAgLy8gY29uc29sZS5sb2coImNvbXB1dGVWZXJ0ZXhOb3JtYWxzIik7DQoNCiAgICB0aGlzLmNhbGN1bGF0ZUVkZ2VBbmdsZXMoKTsNCg0KICAgIGNvbnN0IGZhY2VOb3JtYWxzID0gdGhpcy5nZXRGYWNlQXR0cmlidXRlKCdub3JtYWxzJyk7DQogICAgY29uc3Qgbm9ybWFsc0F0dHIgPSB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgnbm9ybWFscycsIFZlYzMkMSk7DQoNCiAgICAvLyB0aGVzZSBtZXRob2RzIGFyZSBmYXN0ZXIgdmVyc2lvbnMgdGhhbiB1c2luZyB0aGUgbWV0aG9kcw0KICAgIC8vIHByb3ZpZGVkIG9uIHRoZSBhdHRyaWJ1dGVzLiBXZSBjYWNoZSB2YWx1ZXMgYW5kIHVzZSBoYXJkIGNvZGVkIGNvbnN0YW50cy4NCiAgICBjb25zdCBmYWNlTm9ybWFsc0J1ZmZlciA9IGZhY2VOb3JtYWxzLmRhdGEuYnVmZmVyOw0KICAgIGNvbnN0IGdldEZhY2VOb3JtYWwgPSAoaW5kZXgpID0+IHsNCiAgICAgIHJldHVybiBWZWMzJDEuY3JlYXRlRnJvbUJ1ZmZlcihmYWNlTm9ybWFsc0J1ZmZlciwgaW5kZXggKiAzICogNCkgLy8gMyBjb21wb25lbnRzIGF0IDQgYnl0ZXMgZWFjaC4NCiAgICB9Ow0KICAgIGNvbnN0IHZlcnRleE5vcm1hbHNBcnJheSA9IG5vcm1hbHNBdHRyLmRhdGE7DQogICAgY29uc3Qgc2V0VmVydGV4Tm9ybWFsID0gKGluZGV4LCB2YWx1ZSkgPT4gew0KICAgICAgdmVydGV4Tm9ybWFsc0FycmF5W2luZGV4ICogMyArIDBdID0gdmFsdWUueDsNCiAgICAgIHZlcnRleE5vcm1hbHNBcnJheVtpbmRleCAqIDMgKyAxXSA9IHZhbHVlLnk7DQogICAgICB2ZXJ0ZXhOb3JtYWxzQXJyYXlbaW5kZXggKiAzICsgMl0gPSB2YWx1ZS56Ow0KICAgIH07DQogICAgY29uc3QgZ2V0Q29ubmVjdGVkRWRnZVZlY3MgPSAoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRleCkgPT4gew0KICAgICAgbGV0IGUwOw0KICAgICAgbGV0IGUxOw0KICAgICAgY29uc3QgZmFjZUVkZ2VzID0gdGhpcy5mYWNlRWRnZXNbZmFjZUluZGV4XTsNCiAgICAgIGZvciAoY29uc3QgZSBvZiBmYWNlRWRnZXMpIHsNCiAgICAgICAgaWYgKHRoaXMuZWRnZVZlcnRzW2UgKiAyXSA9PSB2ZXJ0ZXhJbmRleCkgew0KICAgICAgICAgIGlmICghZTApIGUwID0gdGhpcy5lZGdlVmVjc1tlXTsNCiAgICAgICAgICBlbHNlIGUxID0gdGhpcy5lZGdlVmVjc1tlXTsNCiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVkZ2VWZXJ0c1tlICogMiArIDFdID09IHZlcnRleEluZGV4KSB7DQogICAgICAgICAgaWYgKCFlMCkgZTAgPSB0aGlzLmVkZ2VWZWNzW2VdOw0KICAgICAgICAgIGVsc2UgZTEgPSB0aGlzLmVkZ2VWZWNzW2VdOw0KICAgICAgICB9DQogICAgICB9DQogICAgICByZXR1cm4gW2UwLCBlMV0NCiAgICB9Ow0KDQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDsgaSsrKSB7DQogICAgICAvLyBJZiB0aGlzIGZhY2UgaW5kZXhpbmcgZG9lc24ndCBzdGFydCBhdCAwLCB0aGVuIHRoZSB2ZXJ0ZXhFZGdlcyBkb24ndCBlaXRoZXIuDQogICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1tpXSA9PSB1bmRlZmluZWQpIGNvbnRpbnVlDQoNCiAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy52ZXJ0ZXhFZGdlc1tpXTsNCg0KICAgICAgLy8gR3JvdXBzIG9mIGZhY2VzIGhhdmluZyBhIHNtb290aCBub3JtYWwgYXQgdGhlIGN1cnJlbnQgdmVydGV4Lg0KICAgICAgY29uc3QgZmFjZUdyb3VwcyA9IFtdOw0KICAgICAgY29uc3QgYWRkRmFjZVRvR3JvdXAgPSAoZmFjZSkgPT4gew0KICAgICAgICBsZXQgaW5Hcm91cCA9IGZhbHNlOw0KICAgICAgICBmb3IgKGNvbnN0IGZhY2VHcm91cCBvZiBmYWNlR3JvdXBzKSB7DQogICAgICAgICAgaW5Hcm91cCA9IGZhY2VHcm91cC5pbmRleE9mKGZhY2UpICE9IC0xOw0KICAgICAgICAgIGlmIChpbkdyb3VwKSBicmVhaw0KICAgICAgICB9DQogICAgICAgIGlmICghaW5Hcm91cCkgZmFjZUdyb3Vwcy5wdXNoKFtmYWNlXSk7DQogICAgICB9Ow0KICAgICAgZm9yIChjb25zdCBlIG9mIGVkZ2VzKSB7DQogICAgICAgIGNvbnN0IGYwID0gdGhpcy5lZGdlRmFjZXNbZSAqIDJdOw0KICAgICAgICBjb25zdCBmMSA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyICsgMV07DQogICAgICAgIGlmIChmMCAhPSAtMSAmJiBmMSA9PSAtMSAmJiB0aGlzLmVkZ2VBbmdsZXNbZV0gPCBoYXJkQW5nbGUpIHsNCiAgICAgICAgICBsZXQgZjBncm91cEluZGV4ID0gLTE7DQogICAgICAgICAgbGV0IGYxZ3JvdXBJbmRleCA9IC0xOw0KICAgICAgICAgIGZvciAobGV0IGdyb3VwSW5kZXggPSAwOyBncm91cEluZGV4IDwgZmFjZUdyb3Vwcy5sZW5ndGg7IGdyb3VwSW5kZXgrKykgew0KICAgICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSAmJiBmYWNlR3JvdXBzW2dyb3VwSW5kZXhdLmluZGV4T2YoZjApICE9IC0xKSBmMGdyb3VwSW5kZXggPSBncm91cEluZGV4Ow0KICAgICAgICAgICAgaWYgKGYxZ3JvdXBJbmRleCA9PSAtMSAmJiBmYWNlR3JvdXBzW2dyb3VwSW5kZXhdLmluZGV4T2YoZjEpICE9IC0xKSBmMWdyb3VwSW5kZXggPSBncm91cEluZGV4Ow0KICAgICAgICAgIH0NCiAgICAgICAgICBpZiAoZjBncm91cEluZGV4ID09IC0xICYmIGYxZ3JvdXBJbmRleCA9PSAtMSkgew0KICAgICAgICAgICAgZmFjZUdyb3Vwcy5wdXNoKFtmMCwgZjFdKTsNCiAgICAgICAgICB9IGVsc2UgaWYgKGYwZ3JvdXBJbmRleCAhPSAtMSAmJiBmMWdyb3VwSW5kZXggIT0gLTEpIHsNCiAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggIT0gZjFncm91cEluZGV4KSB7DQogICAgICAgICAgICAgIC8vIE1lcmdlIHRoZSAyIGdyb3VwcyB0aGF0IHRoZSBzbW9vdGggZWRnZSBqb2lucy4NCiAgICAgICAgICAgICAgZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdID0gZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdLmNvbmNhdChmYWNlR3JvdXBzW2YxZ3JvdXBJbmRleF0pOw0KICAgICAgICAgICAgICBmYWNlR3JvdXBzLnNwbGljZShmMWdyb3VwSW5kZXgsIDEpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICBpZiAoZjBncm91cEluZGV4ID09IC0xKSB7DQogICAgICAgICAgICAgIGZhY2VHcm91cHNbZjFncm91cEluZGV4XS5wdXNoKGYwKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChmMWdyb3VwSW5kZXggPT0gLTEpIHsNCiAgICAgICAgICAgICAgZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdLnB1c2goZjEpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICBjb250aW51ZQ0KICAgICAgICB9DQogICAgICAgIC8vIFRoaXMgaXMgYSBoYXJkIGVkZ2Ugb3IgYSBib3JkZXIgZWRnZS4uLiBBZGQgZmFjZXMgc2VwYXJhdGVseSBncm91cC4NCiAgICAgICAgaWYgKGYwICE9IC0xKSBhZGRGYWNlVG9Hcm91cChmMCk7DQogICAgICAgIGlmIChmMSAhPSAtMSkgYWRkRmFjZVRvR3JvdXAoZjEpOw0KICAgICAgfQ0KDQogICAgICAvLyBTb3J0IHRoZSBncm91cHMgdG8gaGF2ZSB0aGUgYmlnZ2VzdCBncm91cCBmaXJzdC4NCiAgICAgIGZhY2VHcm91cHMuc29ydCgoYSwgYikgPT4gKGEubGVuZ3RoIDwgYi5sZW5ndGggPyAxIDogYS5sZW5ndGggPiBiLmxlbmd0aCA/IC0xIDogMCkpOw0KDQogICAgICBsZXQgZmlyc3RWaXJ0ZXggPSB0cnVlOw0KICAgICAgZm9yIChjb25zdCBmYWNlR3JvdXAgb2YgZmFjZUdyb3Vwcykgew0KICAgICAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjMyQxKCk7DQogICAgICAgIGZvciAoY29uc3QgZmFjZUluZGV4IG9mIGZhY2VHcm91cCkgew0KICAgICAgICAgIGNvbnN0IGZhY2VfZWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlVmVjcyhmYWNlSW5kZXgsIGkpOw0KICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGZhY2VfZWRnZXNbMF0uYW5nbGVUbyhmYWNlX2VkZ2VzWzFdKTsNCiAgICAgICAgICAvLyBpZiAoaSA9PSAxKQ0KICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZygiRmFjZU5vcm1hbDoiICsgZmFjZUluZGV4ICsgIjoiICsgZ2V0RmFjZU5vcm1hbChmYWNlSW5kZXgpLnRvU3RyaW5nKCkpOw0KICAgICAgICAgIG5vcm1hbC5hZGRJblBsYWNlKGdldEZhY2VOb3JtYWwoZmFjZUluZGV4KS5zY2FsZSh3ZWlnaHQpKTsNCiAgICAgICAgfQ0KICAgICAgICBub3JtYWwubm9ybWFsaXplSW5QbGFjZSgpOw0KICAgICAgICBpZiAoZmlyc3RWaXJ0ZXgpIHsNCiAgICAgICAgICBzZXRWZXJ0ZXhOb3JtYWwoaSwgbm9ybWFsKTsNCiAgICAgICAgICBmaXJzdFZpcnRleCA9IGZhbHNlOw0KICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgIG5vcm1hbHNBdHRyLnNldFNwbGl0VmVydGV4VmFsdWVzKGksIGZhY2VHcm91cCwgbm9ybWFsKTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0NCg0KICAgIHJldHVybiBub3JtYWxzQXR0cg0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBjb21wdXRlSGFyZEVkZ2VzSW5kaWNlcyBtZXRob2QuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBoYXJkQW5nbGUgLSBUaGUgaGFyZEFuZ2xlIHZhbHVlIGluIHJhZGlhbnMuDQogICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBjb21wdXRlSGFyZEVkZ2VzSW5kaWNlcyhoYXJkQW5nbGUgPSAxLjApIHsNCiAgICBpZiAoIXRoaXMuZWRnZVZlcnRzKSB0aGlzLmNhbGN1bGF0ZUVkZ2VBbmdsZXMoKTsNCg0KICAgIGNvbnN0IGhhcmRFZGdlcyA9IFtdOw0KICAgIGNvbnN0IGFkZEVkZ2UgPSAoaW5kZXgpID0+IHsNCiAgICAgIGhhcmRFZGdlcy5wdXNoKHRoaXMuZWRnZVZlcnRzW2luZGV4XSk7DQogICAgICBoYXJkRWRnZXMucHVzaCh0aGlzLmVkZ2VWZXJ0c1tpbmRleCArIDFdKTsNCiAgICB9Ow0KICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlQW5nbGVzLmxlbmd0aDsgaSsrKSB7DQogICAgICBpZiAodGhpcy5lZGdlQW5nbGVzW2ldID4gaGFyZEFuZ2xlKSB7DQogICAgICAgIGFkZEVkZ2UoaSAqIDIpOw0KICAgICAgfQ0KICAgIH0NCiAgICByZXR1cm4gVWludDMyQXJyYXkuZnJvbShoYXJkRWRnZXMpDQogIH0NCg0KICAvKioNCiAgICogVGhlIGdldFdpcmVmcmFtZUluZGljZXMgbWV0aG9kLg0KICAgKiBAcmV0dXJuIHthbnl9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICogQHByaXZhdGUNCiAgICovDQogIGdldFdpcmVmcmFtZUluZGljZXMoKSB7DQogICAgY29uc29sZS53YXJuKCdAdG9kby1yZXZpZXcgLSBUaGlzIHJldHVybnMgbm90aGluZycpOw0KICAgIHJldHVybiBpbmRpY2VzDQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFJlbmRlcmluZw0KDQogIC8qKg0KICAgKiBUaGUgZ2VuQnVmZmVycyBtZXRob2QuDQogICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gVGhlIG9wdHMgdmFsdWUuDQogICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ2VuQnVmZmVycyhvcHRzKSB7DQogICAgLy8gQ29tcHV0ZSB0aGUgbm9ybWFscyBvbiBkZW1hbmQuDQogICAgLy8gaWYgKCEoJ25vcm1hbHMnIGluIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSkgew0KICAgIC8vICAgICAvLyB0aGlzLl9fZ2VvbS5jb21wdXRlVmVydGV4Tm9ybWFscygpOw0KICAgIC8vICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIsIFZlYzMsIDAuMCk7DQogICAgLy8gfQ0KDQogICAgY29uc3Qgc3BsaXRJbmRpY2VzID0ge307DQogICAgbGV0IHNwbGl0Q291bnQgPSAwOw0KICAgIGZvciAoY29uc3QgWywgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgIGNvbnN0IGF0dHJTcGxpdHMgPSBhdHRyLmdldFNwbGl0cygpOw0KICAgICAgZm9yIChjb25zdCBwb2x5Z29uIGluIGF0dHJTcGxpdHMpIHsNCiAgICAgICAgaWYgKCEocG9seWdvbiBpbiBzcGxpdEluZGljZXMpKSBzcGxpdEluZGljZXNbcG9seWdvbl0gPSB7fTsNCiAgICAgICAgY29uc3QgdmVydGljZXMgPSBhdHRyU3BsaXRzW3BvbHlnb25dOw0KICAgICAgICBmb3IgKGNvbnN0IHYgaW4gdmVydGljZXMpIHsNCiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBwYXJzZUludCh2KTsNCiAgICAgICAgICBpZiAoISh2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzW3BvbHlnb25dKSkgew0KICAgICAgICAgICAgc3BsaXRJbmRpY2VzW3BvbHlnb25dW3ZlcnRleF0gPSBzcGxpdENvdW50Ow0KICAgICAgICAgICAgc3BsaXRDb3VudCsrOw0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfQ0KICAgIH0NCg0KICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKTsNCiAgICBjb25zdCBudW1VblNwbGl0VmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoOw0KICAgIGNvbnN0IHRvdGFsTnVtVmVydGljZXMgPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdENvdW50Ow0KDQogICAgbGV0IGluZGljZXM7DQogICAgaWYgKCFvcHRzIHx8IG9wdHMuaW5jbHVkZUluZGljZXMgIT0gZmFsc2UpIHsNCiAgICAgIGluZGljZXMgPSB0aGlzLmdlbmVyYXRlVHJpYW5ndWxhdGVkSW5kaWNlcyh0b3RhbE51bVZlcnRpY2VzLCBudW1VblNwbGl0VmVydGljZXMsIHNwbGl0SW5kaWNlcyk7DQogICAgfQ0KDQogICAgLy8gbGV0IG1heEluZGV4Ow0KICAgIC8vIGlmIChkZWJ1Z0F0dHJWYWx1ZXMpDQogICAgLy8gICAgIG1heEluZGV4ID0gTWF0aC5tYXgoLi4uaW5kaWNlcyk7DQogICAgY29uc3QgYXR0ckJ1ZmZlcnMgPSB7fTsNCiAgICBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgIGxldCB2YWx1ZXM7DQogICAgICBpZiAoc3BsaXRDb3VudCA9PSAwKSB2YWx1ZXMgPSBhdHRyLmRhdGE7DQogICAgICBlbHNlIHZhbHVlcyA9IGF0dHIuZ2VuZXJhdGVTcGxpdFZhbHVlcyhzcGxpdEluZGljZXMsIHNwbGl0Q291bnQpOw0KDQogICAgICBjb25zdCBkaW1lbnNpb24gPSBhdHRyLm51bUVsZW1lbnRzOw0KICAgICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoIC8gZGltZW5zaW9uOw0KDQogICAgICAvLyBpZiAoZGVidWdBdHRyVmFsdWVzKSB7DQogICAgICAvLyAgICAgaWYgKGNvdW50IDw9IG1heEluZGV4KQ0KICAgICAgLy8gICAgICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgaW5kZXhpbmcuIEF0dHIgdmFsdWUgaXMgaW5zdWZmaWNpZW50IGZvciBpbmRleGluZzoiICsgYXR0ck5hbWUgKyAiLiBNYXggSW5kZXg6IiArIG1heEluZGV4ICsgIiBBdHRyIFNpemU6IiArIGNvdW50KTsNCiAgICAgIC8vIH0NCg0KICAgICAgYXR0ckJ1ZmZlcnNbYXR0ck5hbWVdID0gew0KICAgICAgICB2YWx1ZXM6IHZhbHVlcywNCiAgICAgICAgY291bnQ6IGNvdW50LA0KICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvbiwNCiAgICAgICAgbm9ybWFsaXplZDogYXR0ck5hbWUgPT0gJ25vcm1hbHMnLA0KICAgICAgICBkYXRhVHlwZTogYXR0ci5kYXRhVHlwZSwNCiAgICAgIH07DQogICAgfQ0KDQogICAgY29uc3QgcmVzdWx0ID0gew0KICAgICAgbnVtVmVydGljZXM6IHRoaXMubnVtVmVydGljZXMoKSwNCiAgICAgIG51bVJlbmRlclZlcnRzOiB0b3RhbE51bVZlcnRpY2VzLA0KICAgICAgaW5kaWNlcywNCiAgICAgIGF0dHJCdWZmZXJzLA0KICAgIH07DQoNCiAgICBpZiAob3B0cyAmJiBvcHRzLmluY2x1ZGVWZXJ0ZXhOZWlnaGJvcnMpIHsNCiAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzID09IHVuZGVmaW5lZCkgdGhpcy5nZW5Ub3BvbG9neUluZm8oKTsNCg0KICAgICAgbGV0IGNvdW50ID0gMDsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAvLyBJZiB0aGlzIGZhY2UgaW5kZXhpbmcgZG9lc24ndCBzdGFydCBhdCAwLCB0aGVuIHRoZSB2ZXJ0ZXhFZGdlcyBkb24ndCBlaXRoZXIuDQogICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW2ldKSBjb3VudCArPSB0aGlzLnZlcnRleEVkZ2VzW2ldLnNpemU7DQogICAgICB9DQogICAgICAvLyBUaGUgYXJyYXkgd2lsbCBiZSBzdHJ1Y3R1cmVkIGFzIGEgc3RhcnQrb2Zmc2V0IGZvciBlYWNoIHZlcnRleCwgZm9sbG93ZWQNCiAgICAgIC8vIGJ5IGEgMmQgYXJyYXkgb2YgbmVpZ2hib3IgaW5kaWNlcy4NCiAgICAgIGNvbnN0IHZlcnRleE5laWdoYm9ycyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aCAqIDIgKyBjb3VudCk7DQoNCiAgICAgIGNvbnN0IHNvcnRGYW5FZGdlcyA9IChmYW5FZGdlcykgPT4gew0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhbkVkZ2VzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgY29uc3QgZmVBID0gZmFuRWRnZXNbaV07DQogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHsNCiAgICAgICAgICAgIGNvbnN0IGZlQiA9IGZhbkVkZ2VzW2pdOw0KICAgICAgICAgICAgaWYgKGZlQVswXSAhPSAtMSAmJiBmZUFbMF0gPT0gZmVCWzFdKSB7DQogICAgICAgICAgICAgIC8vICBtb3ZlIGZlQSBhZnRlciBmZUI7DQogICAgICAgICAgICAgIGlmIChpICE9IGogKyAxKSB7DQogICAgICAgICAgICAgICAgZmFuRWRnZXMuc3BsaWNlKGksIDEpOw0KICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqICsgMSwgMCwgZmVBKTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGZlQVsxXSAhPSAtMSAmJiBmZUFbMV0gPT0gZmVCWzBdKSB7DQogICAgICAgICAgICAgIC8vICBtb3ZlIGZlQSBiZWZvcmUgZmVCOw0KICAgICAgICAgICAgICBmYW5FZGdlcy5zcGxpY2UoaSwgMSk7DQogICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqLCAwLCBmZUEpOw0KICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfTsNCg0KICAgICAgY29uc3QgY2hlY2tGYW5FZGdlcyA9IChmYW5FZGdlcykgPT4gew0KICAgICAgICAvLyBub3cgY2hlY2sgdGhhdCB0aGUgZmFjZXMgYWxsIGJ1aWxkIGEgZmFuLiBNYXliZSBzdGFydGluZyBhbmQgZW5kaW5nIHdpdGggLTENCiAgICAgICAgaWYgKGZhbkVkZ2VzWzBdWzBdID09IC0xIHx8IGZhbkVkZ2VzW2ZhbkVkZ2VzLmxlbmd0aCAtIDFdWzFdID09IC0xKSB7DQogICAgICAgICAgaWYgKGZhbkVkZ2VzWzBdWzBdICE9IC0xIHx8IGZhbkVkZ2VzW2ZhbkVkZ2VzLmxlbmd0aCAtIDFdWzFdICE9IC0xKSB7DQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGZhbiBzdGFydHMgd2l0aCAtMSwgaXQgbXVzdCBhbHNvIGVuZCB3aXRoIC0xJykNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYW5FZGdlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgIGNvbnN0IGZlID0gZmFuRWRnZXNbaV07DQogICAgICAgICAgaWYgKGZlWzBdID09IC0xIHx8IGZlWzFdID09IC0xKSB7DQogICAgICAgICAgICBpZiAoaSAhPSAwICYmIGkgIT0gZmFuRWRnZXMubGVuZ3RoIC0gMSkgew0KICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy0xIG9ubHkgYWxsb3dlZCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBmYW4uJykNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKGZlWzBdICE9IC0xKSB7DQogICAgICAgICAgICBsZXQgcHJldiA9IGkgLSAxOw0KICAgICAgICAgICAgaWYgKHByZXYgPCAwKSBwcmV2ICs9IGZhbkVkZ2VzLmxlbmd0aDsNCiAgICAgICAgICAgIGlmIChmZVswXSAhPSBmYW5FZGdlc1twcmV2XVsxXSkgew0KICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhY2VzIGFyZSBub3Qgc2VxdWVudGlhbCcpDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICAgIGlmIChmZVsxXSAhPSAtMSkgew0KICAgICAgICAgICAgY29uc3QgbmV4dCA9IChpICsgMSkgJSBmYW5FZGdlcy5sZW5ndGg7DQogICAgICAgICAgICBpZiAoZmVbMV0gIT0gZmFuRWRnZXNbbmV4dF1bMF0pIHsNCiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlcyBhcmUgbm90IHNlcXVlbnRpYWwnKQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgfTsNCg0KICAgICAgLy8gUG9wdWxhdGUgdGhlIHN0YXJ0IGFuZCBvZmZzZXQgdmFsdWVzLg0KICAgICAgbGV0IG9mZnNldCA9IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoICogMjsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1tpXSA9PSB1bmRlZmluZWQpIGNvbnRpbnVlDQogICAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy52ZXJ0ZXhFZGdlc1tpXTsNCg0KICAgICAgICAvLyBCdWlsZCBhIHNvcnRlZCBsaXN0IG9mIGZhY2VzIGJhc2VkIG9uIGEgZmFuIGFyb3VuZA0KICAgICAgICAvLyB0aGUgdmVydGV4Lg0KICAgICAgICBjb25zdCBmYW5FZGdlcyA9IFtdOw0KICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZWRnZXMpIHsNCiAgICAgICAgICBjb25zdCB2MCA9IHRoaXMuZWRnZVZlcnRzW2UgKiAyXTsNCiAgICAgICAgICBjb25zdCB2MSA9IHRoaXMuZWRnZVZlcnRzW2UgKiAyICsgMV07DQogICAgICAgICAgbGV0IGYwID0gdGhpcy5lZGdlRmFjZXNbZSAqIDJdOw0KICAgICAgICAgIGxldCBmMSA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyICsgMV07DQogICAgICAgICAgbGV0IG5laWdWZXJ0Ow0KICAgICAgICAgIGlmICh2MCA9PSBpKSB7DQogICAgICAgICAgICBuZWlnVmVydCA9IHYxOw0KICAgICAgICAgIH0gZWxzZSBpZiAodjEgPT0gaSkgew0KICAgICAgICAgICAgbmVpZ1ZlcnQgPSB2MDsNCiAgICAgICAgICAgIC8vIHN3YXAgdGhlIGZhY2VzDQogICAgICAgICAgICBjb25zdCB0bXAgPSBmMDsNCiAgICAgICAgICAgIGYwID0gZjE7DQogICAgICAgICAgICBmMSA9IHRtcDsNCiAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcG9sb2d5JykNCiAgICAgICAgICB9DQogICAgICAgICAgZmFuRWRnZXMucHVzaChbZjAsIGYxLCBuZWlnVmVydF0pOw0KICAgICAgICB9DQogICAgICAgIHNvcnRGYW5FZGdlcyhmYW5FZGdlcyk7DQogICAgICAgIGNoZWNrRmFuRWRnZXMoZmFuRWRnZXMpOw0KICAgICAgICBjb25zdCBjbG9zZWQgPSBmYW5FZGdlc1swXVswXSAhPSAtMSB8fCBmYW5FZGdlc1tmYW5FZGdlcy5sZW5ndGggLSAxXVsxXSAhPSAtMTsNCiAgICAgICAgbGV0IGZsYWdzID0gMDsNCiAgICAgICAgaWYgKGNsb3NlZCkgZmxhZ3MgKz0gMTsNCiAgICAgICAgdmVydGV4TmVpZ2hib3JzW2kgKiAyXSA9IG9mZnNldDsNCiAgICAgICAgdmVydGV4TmVpZ2hib3JzW2kgKiAyICsgMV0gPSBlZGdlcy5zaXplICsgKGZsYWdzIDw8IDgpOw0KICAgICAgICBmb3IgKGNvbnN0IGZlIG9mIGZhbkVkZ2VzKSB7DQogICAgICAgICAgdmVydGV4TmVpZ2hib3JzW29mZnNldF0gPSBmZVsyXTsNCiAgICAgICAgICBvZmZzZXQrKzsNCiAgICAgICAgfQ0KICAgICAgfQ0KDQogICAgICByZXN1bHQudmVydGV4TmVpZ2hib3JzID0gdmVydGV4TmVpZ2hib3JzOw0KICAgIH0NCg0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBDb21wdXRlIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLiBGb3IgaGlnaGVyIGRlZ3JlZSBwb2x5Z29ucywgdGhleSBhcmUgZGl2aWRlZCBpbnRvIG11bHRpcGxlIHRyaWFuZ2xlcyBmb3IgcmVuZGVyaW5nLg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy4NCiAgICovDQogIGNvbXB1dGVOdW1UcmlhbmdsZXMoKSB7DQogICAgbGV0IG51bVZlcnRzUGVyRmFjZSA9IDM7DQogICAgbGV0IHRyaXNDb3VudCA9IDA7DQogICAgZm9yIChjb25zdCBmYyBvZiB0aGlzLl9fZmFjZUNvdW50cykgew0KICAgICAgdHJpc0NvdW50ICs9IGZjICogKG51bVZlcnRzUGVyRmFjZSAtIDIpOw0KICAgICAgbnVtVmVydHNQZXJGYWNlKys7DQogICAgfQ0KICAgIHJldHVybiB0cmlzQ291bnQNCiAgfQ0KDQogIC8qKg0KICAgKiBUbyBwcmVwYXJlIGRhdGEgZm9yIHJlbmRlcmluZywgdGhlIGluZGljZXMgZm9yIHRoZSBwb2x5Z29ucyBpcyB1c2VkIHRvIGNvbXB1dGUgYSBuZXcgaW5kZXggYnVmZmVyIGJhc2VkIG9uDQogICAqIG9ubHkgdHJpYW5nbGVzLiBUaGlzIGlzIHVzZWQgZHVyaW5nIHJlbmRlcmluZyBhbmQgdGhlIHJlc3VsdGluZyBpbmRpY2VzIHVwbG9hZGVkIG90IHRoZSBHUFUgIGJ5IEdMTWVzaCBjbGFzcy4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsTnVtVmVydGljZXMgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzLg0KICAgKiBAcGFyYW0ge251bWJlcn0gbnVtVW5TcGxpdFZlcnRpY2VzIC0gVGhlIHRvdGFsIG51bWJlciBvZiB1bnNwbGl0IHZlcnRpY2VzLg0KICAgKiBAcGFyYW0ge2FycmF5fSBzcGxpdEluZGljZXMgLSBUaGUgc3BsaXRJbmRpY2VzIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtUeXBlZEFycmF5fSAtIFJldHVyZXMgYSB0eXBlZCBhcnJheSBjb250YWluaW5nIHRoZSB0cmlhbmd1bGF0ZWQgaW5kaWNlcy4NCiAgICovDQogIGdlbmVyYXRlVHJpYW5ndWxhdGVkSW5kaWNlcyh0b3RhbE51bVZlcnRpY2VzLCBudW1VblNwbGl0VmVydGljZXMsIHNwbGl0SW5kaWNlcykgew0KICAgIGNvbnN0IHRyaXNDb3VudCA9IHRoaXMuY29tcHV0ZU51bVRyaWFuZ2xlcygpOw0KDQogICAgbGV0IHRyaWFuZ2x1bGF0ZWRJbmRpY2VzOw0KICAgIGlmICh0b3RhbE51bVZlcnRpY2VzIDwgTWF0aC5wb3coMiwgOCkpIHRyaWFuZ2x1bGF0ZWRJbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkodHJpc0NvdW50ICogMyk7DQogICAgZWxzZSBpZiAodG90YWxOdW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkgdHJpYW5nbHVsYXRlZEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodHJpc0NvdW50ICogMyk7DQogICAgZWxzZSB0cmlhbmdsdWxhdGVkSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSh0cmlzQ291bnQgKiAzKTsNCg0KICAgIGxldCB0cmlhbmdsZVZlcnRleCA9IDA7DQogICAgY29uc3QgYWRkVHJpYW5nbGVWZXJ0ZXhJbmRleCA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIGZhY2VJbmRleCkgew0KICAgICAgaWYgKHZlcnRleCBpbiBzcGxpdEluZGljZXMgJiYgZmFjZUluZGV4IGluIHNwbGl0SW5kaWNlc1t2ZXJ0ZXhdKQ0KICAgICAgICB2ZXJ0ZXggPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdEluZGljZXNbdmVydGV4XVtmYWNlSW5kZXhdOw0KICAgICAgdHJpYW5nbHVsYXRlZEluZGljZXNbdHJpYW5nbGVWZXJ0ZXhdID0gdmVydGV4Ow0KICAgICAgdHJpYW5nbGVWZXJ0ZXgrKzsNCiAgICB9Ow0KICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOw0KICAgIGZvciAobGV0IGZhY2VJbmRleCA9IDA7IGZhY2VJbmRleCA8IG51bUZhY2VzOyBmYWNlSW5kZXgrKykgew0KICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpOw0KICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlVmVydHMubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgaWYgKGogPj0gMykgew0KICAgICAgICAgIC8vIEZvciBlYWNoIGFkaXRpb25hbCB0cmlhbmdsZSwgd2UgaGF2ZSB0byBhZGQgMiBpbmRpY2VzLg0KICAgICAgICAgIGFkZFRyaWFuZ2xlVmVydGV4SW5kZXgoZmFjZVZlcnRzWzBdLCBmYWNlSW5kZXgpOw0KICAgICAgICAgIGFkZFRyaWFuZ2xlVmVydGV4SW5kZXgoZmFjZVZlcnRzW2ogLSAxXSwgZmFjZUluZGV4KTsNCiAgICAgICAgfQ0KICAgICAgICBhZGRUcmlhbmdsZVZlcnRleEluZGV4KGZhY2VWZXJ0c1tqXSwgZmFjZUluZGV4KTsNCiAgICAgIH0NCiAgICB9DQogICAgcmV0dXJuIHRyaWFuZ2x1bGF0ZWRJbmRpY2VzDQogIH0NCg0KICAvKioNCiAgICogVGhlIGZyZWVCdWZmZXJzIG1ldGhvZC4NCiAgICovDQogIGZyZWVCdWZmZXJzKCkgew0KICAgIHN1cGVyLmZyZWVCdWZmZXJzKCk7DQogICAgdGhpcy5pbml0KCk7DQogIH0NCg0KICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIFBlcnNpc3RlbmNlDQoNCiAgLyoqDQogICAqIFJlc3RvcmVzIG1lc2ggcHJvcGVydGllcyBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAqLw0KICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIpOw0KICAgIHRoaXMuc2V0RmFjZUNvdW50cyhyZWFkZXIubG9hZFVJbnQzMkFycmF5KCkpOw0KDQogICAgLy8gTm90ZTogd2UgY2FuIHJlbW92ZSB0aGlzLiBXZSBjYW4gaW5mZXIgdGhpcyBmcm9tIHRoZSBhYm92ZSBmYWNlQ291bnRzIGFycmF5Lg0KICAgIGNvbnN0IGZhY2VWZXJ0ZXhDb3VudHMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkodGhpcy5nZXROdW1GYWNlcygpKTsNCiAgICBjb25zdCBvZmZzZXRSYW5nZSA9IHJlYWRlci5sb2FkU0ludDMyVmVjMigpOw0KICAgIGNvbnN0IGJ5dGVzID0gcmVhZGVyLmxvYWRVSW50OCgpOw0KICAgIGxldCBmYWNlVmVydGV4SW5kZXhEZWx0YXM7DQogICAgaWYgKGJ5dGVzID09IDEpIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDhBcnJheSgpOw0KICAgIGVsc2UgaWYgKGJ5dGVzID09IDIpIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDE2QXJyYXkoKTsNCiAgICBlbHNlIGlmIChieXRlcyA9PSA0KSBmYWNlVmVydGV4SW5kZXhEZWx0YXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KCk7DQoNCiAgICBjb25zdCBudW1GYWNlcyA9IHRoaXMuZ2V0TnVtRmFjZXMoKTsNCiAgICBsZXQgb2Zmc2V0ID0gMDsNCiAgICBsZXQgcHJldkNvdW50ID0gMDsNCiAgICBsZXQgZmFjZU9mZnNldHMgPSBbXTsNCiAgICBmb3IgKGxldCBmYWNlSW5kZXggPSAwOyBmYWNlSW5kZXggPCBudW1GYWNlczsgZmFjZUluZGV4KyspIHsNCiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRGYWNlVmVydGV4Q291bnQoZmFjZUluZGV4KTsNCiAgICAgIGZhY2VPZmZzZXRzW2ZhY2VJbmRleF0gPSBvZmZzZXQ7DQogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHsNCiAgICAgICAgY29uc3QgZmFjZVZlcnRleCA9IG9mZnNldCArIGo7DQogICAgICAgIGNvbnN0IGRlbHRhID0gZmFjZVZlcnRleEluZGV4RGVsdGFzW2ZhY2VWZXJ0ZXhdICsgb2Zmc2V0UmFuZ2UueDsNCiAgICAgICAgaWYgKGZhY2VJbmRleCA9PSAwKSB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbZmFjZVZlcnRleF0gPSBkZWx0YTsNCiAgICAgICAgZWxzZSB7DQogICAgICAgICAgbGV0IHByZXZGYWNlVmVydGV4ID0gZmFjZU9mZnNldHNbZmFjZUluZGV4IC0gMV07DQogICAgICAgICAgcHJldkZhY2VWZXJ0ZXggKz0gaiA8IHByZXZDb3VudCA/IGogOiBwcmV2Q291bnQgLSAxOw0KICAgICAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1tmYWNlVmVydGV4XSA9IHRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1twcmV2RmFjZVZlcnRleF0gKyBkZWx0YTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgb2Zmc2V0ICs9IGNvdW50Ow0KICAgICAgcHJldkNvdW50ID0gY291bnQ7DQogICAgfQ0KICAgIHRoaXMuX19udW1Qb3B1bGF0ZWRGYWNlVmVydGV4SW5kaWNlcyA9IG9mZnNldDsNCg0KICAgIGlmICghdGhpcy5oYXNWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKSkgew0KICAgICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOw0KICAgIH0NCg0KICAgIC8vIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsNCiAgICB0aGlzLmVtaXQoJ2dlb21EYXRhQ2hhbmdlZCcsIHt9KTsNCiAgfQ0KDQogIC8qKg0KICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICoNCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgKi8NCiAgdG9KU09OKGNvbnRleHQpIHsNCiAgICBjb25zdCBqID0gc3VwZXIudG9KU09OKGNvbnRleHQpOw0KICAgIGouZmFjZUNvdW50cyA9IEFycmF5LmZyb20odGhpcy5fX2ZhY2VDb3VudHMpOw0KICAgIGouZmFjZVZlcnRleEluZGljZXMgPSBBcnJheS5mcm9tKHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcyk7DQoNCiAgICByZXR1cm4gag0KICB9DQoNCiAgLyoqDQogICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAqDQogICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICovDQogIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICBzdXBlci5mcm9tSlNPTihqLCBjb250ZXh0KTsNCiAgICBpZiAoai5mYWNlQ291bnRzKSB0aGlzLl9fZmFjZUNvdW50cyA9IGouZmFjZUNvdW50czsNCiAgICBpZiAoai5mYWNlVmVydGV4SW5kaWNlcykgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gVWludDMyQXJyYXkuZnJvbShqLmZhY2VWZXJ0ZXhJbmRpY2VzKTsNCiAgfQ0KfQ0KDQpSZWdpc3RyeS5yZWdpc3RlcignTWVzaCcsIE1lc2gpOwoKLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8NCg0KLyoqDQogKiBSZWFkcyBiaW5hcnkgZGF0YSBpbiBhIHNwZWNpZmljIGVuY29kaW5nLiBVc2VkIGluIGxvYWRpbmcgYmluYXJ5IGRhdGEgc3VjaCBhcyB6Y2FkIGZpbGVzLg0KICovDQpjbGFzcyBCaW5SZWFkZXIgew0KICAvKioNCiAgICogQ3JlYXRlIGEgYmluIHJlYWRlci4NCiAgICoNCiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgLSBUaGUgZGF0YSBidWZmZXIuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IHZhbHVlIHRvIHN0YXJ0IHJlYWRpbmcgdGhlIGJ1ZmZlci4NCiAgICogQHBhcmFtIHtib29sZWFufSBpc01vYmlsZURldmljZSAtIFRoZSBpc01vYmlsZURldmljZSB2YWx1ZS4NCiAgICovDQogIGNvbnN0cnVjdG9yKGRhdGEsIGJ5dGVPZmZzZXQgPSAwLCBpc01vYmlsZURldmljZSA9IHRydWUpIHsNCiAgICB0aGlzLl9fZGF0YSA9IGRhdGE7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgPSBieXRlT2Zmc2V0Ow0KICAgIHRoaXMuX19kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9fZGF0YSk7DQogICAgdGhpcy5fX2lzTW9iaWxlRGV2aWNlID0gaXNNb2JpbGVEZXZpY2U7DQogICAgdGhpcy51dGY4ZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpOw0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgc3RhdGUgb2Ygd2hldGhlciBvciBub3QgdGhlIGBCaW5SZWFkZXJgIG9iamVjdCB3YXMgaW5zdGFuY2lhdGVkIGZyb20gYSBtb2JpbGUgZGV2aWNlLg0KICAgKg0KICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIFJldHVybnMgdHJ1ZSBpcyBhIG1vYmlsZSBkZXZpY2UgaXMgZGV0ZWN0ZWQuDQogICAqLw0KICBnZXQgaXNNb2JpbGVEZXZpY2UoKSB7DQogICAgcmV0dXJuIHRoaXMuX19pc01vYmlsZURldmljZQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIGRhdGEgYnVmZmVyIHdlJ3JlIHJlYWRpbmcgZnJvbS4NCiAgICoNCiAgICogQHJldHVybiB7QnVmZmVyfSAtIFRoZSBkYXRhIGJ1ZmZlciB3ZSBhcmUgcmVhZGluZyBmcm9tLA0KICAgKi8NCiAgZ2V0IGRhdGEoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhDQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBidWZmZXINCiAgICovDQogIGdldCBieXRlTGVuZ3RoKCkgew0KICAgIHJldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgcmVtYWluaW5nIGxlbmd0aCBvZiB0aGUgYnVmZmVyIHRvIHJlYWQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmVlbWFpbmluZyBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byByZWFkLg0KICAgKi8NCiAgZ2V0IHJlbWFpbmluZ0J5dGVMZW5ndGgoKSB7DQogICAgcmV0dXJuIHRoaXMuX19kYXRhVmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5fX2J5dGVPZmZzZXQNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGN1cnJlbnQgYnl0ZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlci4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgYmluYXJ5IGJ1ZmZlcg0KICAgKi8NCiAgcG9zKCkgew0KICAgIHJldHVybiB0aGlzLl9fYnl0ZU9mZnNldA0KICB9DQoNCiAgLyoqDQogICAqIFNldHMgdGhlIGJ5dGUgb2Zmc2V0IHZhbHVlLg0KICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IHBhcmFtLg0KICAgKi8NCiAgc2VlayhieXRlT2Zmc2V0KSB7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgPSBieXRlT2Zmc2V0Ow0KICB9DQoNCiAgLyoqDQogICAqIEFkZHMgb2Zmc2V0IGJ5dGVzIHRvIGN1cnJlbnQgb2Zmc2V0IHZhbHVlLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIE9mZnNldCBhbW91bnQuDQogICAqLw0KICBhZHZhbmNlKGJ5dGVPZmZzZXQpIHsNCiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBieXRlT2Zmc2V0Ow0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHVuc2lnbmVkIFVpbnQ4IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sDQogICAqIGFuZCBhZGRzIG9uZSBieXRlIHRvIHRoZSBvZmZzZXQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFVJbnQ4KCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50OCh0aGlzLl9fYnl0ZU9mZnNldCk7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gMTsNCiAgICByZXR1cm4gcmVzdWx0DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdW5zaWduZWQgVWludDE2IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sDQogICAqIGFuZCBhZGRzIHR3byBieXRlcyB0byB0aGUgb2Zmc2V0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGxvYWRVSW50MTYoKSB7DQogICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldFVpbnQxNih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gMjsNCiAgICByZXR1cm4gcmVzdWx0DQogIH0NCg0KICAvKioNCiAgICogUmV0dXJucyB0aGUgdW5zaWduZWQgVWludDMyIHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sDQogICAqIGFuZCBhZGRzIGZvdXIgYnl0ZXMgdG8gdGhlIG9mZnNldC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsb2FkVUludDMyKCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIHNpZ25lZCBJbnQzMiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLA0KICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFNJbnQzMigpIHsNCiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0SW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIEZsb2F0MTYgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwNCiAgICogYW5kIGFkZHMgZm91ciBieXRlcyB0byB0aGUgb2Zmc2V0Lg0KICAgKg0KICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGxvYWRGbG9hdDE2KCkgew0KICAgIGNvbnN0IHVpbnQxNiA9IHRoaXMubG9hZFVJbnQxNigpOw0KICAgIHJldHVybiBNYXRoRnVuY3Rpb25zLmRlY29kZTE2Qml0RmxvYXQodWludDE2KQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgdGhlIEZsb2F0MTYgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwNCiAgICogYW5kIGFkZHMgdHdvIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAqDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFVGbG9hdDE2KCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICBpZiAocmVzdWx0IDwgMC4wKSB7DQogICAgICByZXR1cm4gMjA0OC4wIC0gcmVzdWx0IC8vIE5vdGU6IHN1YnRyYWN0IGEgbmVnYXRpdmUgbnVtYmVyIHRvIGFkZCBpdC4NCiAgICB9IGVsc2Ugew0KICAgICAgcmV0dXJuIHJlc3VsdA0KICAgIH0NCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIGEgc2luZ2xlIHNpZ25lZCBGbG9hdDE2IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24gZnJvbSAyIHVuc2lnbmVkIEludDggdmFsdWVzLA0KICAgKiBhbmQgYWRkcyB0d28gYnl0ZXMgdG8gdGhlIG9mZnNldC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsb2FkRmxvYXQxNkZyb20yeFVJbnQ4KCkgew0KICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsNCiAgICAvLyBjb25zdCB1aW50OHMgPSB0aGlzLmxvYWRVSW50OEFycmF5KDIpOw0KICAgIC8vIHJldHVybiBNYXRoLmRlY29kZTE2Qml0RmxvYXQodWludDhzKTsNCiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAyOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBMb2FkcyBhbmQgcmV0dXJucyBhIHNpbmdsZSBTaWduZWQgaW50ZWdlciB2YWx1ZSBmcm9tIDIgVW5zaWduZWQgRmxvYXQxNiB2YWx1ZXMuDQogICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFVJbnQzMkZyb20yeFVGbG9hdDE2KCkgew0KICAgIGNvbnN0IHBhcnRBID0gdGhpcy5sb2FkVUZsb2F0MTYoKTsNCiAgICBjb25zdCBwYXJ0QiA9IHRoaXMubG9hZFVGbG9hdDE2KCk7DQogICAgcmV0dXJuIHBhcnRBICsgcGFydEIgKiA0MDk2DQogIH0NCg0KICAvKioNCiAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIHNpZ25lZCBGbG9hdDE2IHZhbHVlcy4NCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpIHsNCiAgICBjb25zdCBwYXJ0QSA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICBjb25zdCBwYXJ0QiA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICByZXR1cm4gcGFydEEgKyBwYXJ0QiAqIDIwNDgNCiAgfQ0KDQogIC8qKg0KICAgKiBSZXR1cm5zIHRoZSBGbG9hdDMyIHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sDQogICAqIGFuZCBhZGRzIGZvdXIgYnl0ZXMgdG8gdGhlIG9mZnNldC4NCiAgICoNCiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsb2FkRmxvYXQzMigpIHsNCiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNDsNCiAgICByZXR1cm4gcmVzdWx0DQogIH0NCg0KICAvKioNCiAgICogUmVhZHMgYnVmZmVyIGFuZCByZXR1cm4gYW4gdW5zaW5nZWQgSW50OCBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSwNCiAgICogc3RhcnRpbmcgZnJvbSBjdXJyZW50IGJ5dGUgb2Zmc2V0Ljxicj4NCiAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplLg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLg0KICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb25lIC0gVGhlIGNsb25lIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsb2FkVUludDhBcnJheShzaXplID0gdW5kZWZpbmVkLCBjbG9uZSA9IGZhbHNlKSB7DQogICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKSBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7DQogICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKTsNCiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplOw0KICAgIGNvbnN0IHBhZGQgPSB0aGlzLl9fYnl0ZU9mZnNldCAlIDQ7DQogICAgLy8gdGhpcy5yZWFkUGFkZCgpOw0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhbiB1bnNpbmdlZCBJbnQxNiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSwNCiAgICogc3RhcnRpbmcgZnJvbSBjdXJyZW50IGJ5dGUgb2Zmc2V0Ljxicj4NCiAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplIHggMi4NCiAgICoNCiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSBwYXJhbS4NCiAgICogQHBhcmFtIHtib29sZWFufSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS4NCiAgICogQHJldHVybiB7VWludDE2QXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICovDQogIGxvYWRVSW50MTZBcnJheShzaXplID0gdW5kZWZpbmVkLCBjbG9uZSA9IGZhbHNlKSB7DQogICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKSBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7DQogICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIG5ldyBVaW50MTZBcnJheSgpDQogICAgdGhpcy5yZWFkUGFkZCgyKTsNCiAgICBsZXQgcmVzdWx0Ow0KICAgIGlmICh0aGlzLl9faXNNb2JpbGVEZXZpY2UpIHsNCiAgICAgIHJlc3VsdCA9IG5ldyBVaW50MTZBcnJheShzaXplKTsNCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7DQogICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAyOw0KICAgICAgfQ0KICAgIH0gZWxzZSB7DQogICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKTsNCiAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IHNpemUgKiAyOw0KICAgIH0NCiAgICAvLyB0aGlzLnJlYWRQYWRkKCk7DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLyoqDQogICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGFuIHVuc2luZ2VkIEludDMyIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLA0KICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuPGJyPg0KICAgKiBCeXRlIG9mZnNldCBpcyBpbmNyZWFzZWQgYnkgdGhlIHNwZWNpZmllZCBieXRlIHNpemUgeCA0Lg0KICAgKg0KICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLg0KICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb25lIC0gVGhlIGNsb25lIHBhcmFtLg0KICAgKiBAcmV0dXJuIHtVaW50MzJBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFVJbnQzMkFycmF5KHNpemUgPSB1bmRlZmluZWQsIGNsb25lID0gZmFsc2UpIHsNCiAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsNCiAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gbmV3IFVpbnQzMkFycmF5KCkNCiAgICB0aGlzLnJlYWRQYWRkKDQpOw0KICAgIGxldCByZXN1bHQ7DQogICAgaWYgKHRoaXMuX19pc01vYmlsZURldmljZSkgew0KICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KHNpemUpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsNCiAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5fX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7DQogICAgICB9DQogICAgfSBlbHNlIHsNCiAgICAgIHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIHNpemUpOw0KICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZSAqIDQ7DQogICAgfQ0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhIEZsb2F0MzIgYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUsDQogICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC48YnI+DQogICAqIEJ5dGUgb2Zmc2V0IGlzIGluY3JlYXNlZCBieSB0aGUgc3BlY2lmaWVkIGJ5dGUgc2l6ZSB4IDQuDQogICAqDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgcGFyYW0uDQogICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uDQogICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZEZsb2F0MzJBcnJheShzaXplID0gdW5kZWZpbmVkLCBjbG9uZSA9IGZhbHNlKSB7DQogICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKSBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7DQogICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoKQ0KICAgIHRoaXMucmVhZFBhZGQoNCk7DQogICAgbGV0IHJlc3VsdDsNCiAgICBpZiAodGhpcy5fX2lzTW9iaWxlRGV2aWNlKSB7DQogICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsNCiAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5fX2RhdGFWaWV3LmdldEZsb2F0MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0Ow0KICAgICAgfQ0KICAgIH0gZWxzZSB7DQogICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX19kYXRhLCB0aGlzLl9fYnl0ZU9mZnNldCwgc2l6ZSk7DQogICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplICogNDsNCiAgICB9DQogICAgcmV0dXJuIHJlc3VsdA0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgbmV4dCBzdHJpbmcuDQogICAqIEZpcnN0IGxvb2tzIGZvciB0aGUgc3RyaW5nIGxlbmd0aCBkZXNjcmlwdGlvbiBpbiB0aGUgbmV4dCBmb3VyIGJ5dGVzIGluIHRoZSBidWZmZXIoU3RhcnRpbmcgZnJvbSBieXRlIG9mZnNldCkuDQogICAqDQogICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFN0cigpIHsNCiAgICBjb25zdCBudW1DaGFycyA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgIGNvbnN0IGNoYXJzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBudW1DaGFycyk7DQogICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gbnVtQ2hhcnM7DQogICAgcmV0dXJuIHRoaXMudXRmOGRlY29kZXIuZGVjb2RlKGNoYXJzKQ0KICB9DQoNCiAgLyoqDQogICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncy4NCiAgICogRmlyc3QgcmVhZGluZyB0aGUgc2l6ZSBvZiB0aGUgYXJyYXkgdGhlbiByZWFkaW5nIGVhY2ggc3RyaW5nLg0KICAgKg0KICAgKiBAcmV0dXJuIHtBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgbG9hZFN0ckFycmF5KCkgew0KICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsNCiAgICBjb25zdCByZXN1bHQgPSBbXTsNCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgew0KICAgICAgcmVzdWx0W2ldID0gdGhpcy5sb2FkU3RyKCk7DQogICAgfQ0KICAgIHJldHVybiByZXN1bHQNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBzaWduZWQgSW50MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIFZlYzIuDQogICAqLw0KICBsb2FkU0ludDMyVmVjMigpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5sb2FkU0ludDMyKCk7DQogICAgY29uc3QgeSA9IHRoaXMubG9hZFNJbnQzMigpOw0KICAgIHJldHVybiBuZXcgVmVjMih4LCB5KQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjMmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdHdvIHVuc2lnbmVkIEludDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBWZWMyLg0KICAgKi8NCiAgbG9hZFVJbnQzMlZlYzIoKSB7DQogICAgY29uc3QgeCA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRVSW50MzIoKTsNCiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBGbG9hdDE2IHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgKg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBWZWMyLg0KICAgKi8NCiAgbG9hZEZsb2F0MTZWZWMyKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBWZWMyLg0KICAgKi8NCiAgbG9hZEZsb2F0MzJWZWMyKCkgew0KICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzNgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIEZsb2F0MTYgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIFZlYzMuDQogICAqLw0KICBsb2FkRmxvYXQxNlZlYzMoKSB7DQogICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEoeCwgeSwgeikNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzNgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqDQogICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIFZlYzMuDQogICAqLw0KICBsb2FkRmxvYXQzMlZlYzMoKSB7DQogICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgcmV0dXJuIG5ldyBWZWMzJDEoeCwgeSwgeikNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFF1YXRgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICoNCiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgUXVhdC4NCiAgICovDQogIGxvYWRGbG9hdDE2UXVhdCgpIHsNCiAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICBjb25zdCB3ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgIHJldHVybiBuZXcgUXVhdCh4LCB5LCB6LCB3KQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgUXVhdGAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBRdWF0Lg0KICAgKi8NCiAgbG9hZEZsb2F0MzJRdWF0KCkgew0KICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICBjb25zdCB6ID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgIGNvbnN0IHcgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgcmV0dXJuIG5ldyBRdWF0KHgsIHksIHosIHcpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBDb2xvcmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdGhyZWUgRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICoNCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIENvbG9yLg0KICAgKi8NCiAgbG9hZFJHQkZsb2F0MzJDb2xvcigpIHsNCiAgICBjb25zdCByID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgY29uc3QgYiA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpDQogIH0NCg0KICAvKioNCiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFJHQkEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBDb2xvci4NCiAgICovDQogIGxvYWRSR0JBRmxvYXQzMkNvbG9yKCkgew0KICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgY29uc3QgZyA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICBjb25zdCBiID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgIGNvbnN0IGEgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgQ29sb3JgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIHVuc2lnbmVkIEludDggdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBDb2xvci4NCiAgICovDQogIGxvYWRSR0JVSW50OENvbG9yKCkgew0KICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgUkdCQSBgQ29sb3JgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgdW5zaWduZWQgSW50OCB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIENvbG9yLg0KICAgKi8NCiAgbG9hZFJHQkFVSW50OENvbG9yKCkgew0KICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIGNvbnN0IGEgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYEJveDJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICogTmV4dCBmb3VyIGJlY2F1c2UgaXQgY3JlYXRlcyB0d28gVmVjMi4NCiAgICoNCiAgICogQHJldHVybiB7Qm94Mn0gLSBSZXR1cm5zIGEgQm94Mi4NCiAgICovDQogIGxvYWRCb3gyKCkgew0KICAgIHJldHVybiBuZXcgQm94Mih0aGlzLmxvYWRGbG9hdDMyVmVjMigpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMigpKQ0KICB9DQoNCiAgLyoqDQogICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgQm94MmAgb2JqZWN0IHdpdGggdGhlIG5leHQgc2l4IEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAqIE5leHQgZm91ciBiZWNhdXNlIGl0IGNyZWF0ZXMgdHdvIFZlYzMuDQogICAqDQogICAqIEByZXR1cm4ge0JveDN9IC0gUmV0dXJucyBhIEJveDMuDQogICAqLw0KICBsb2FkQm94MygpIHsNCiAgICByZXR1cm4gbmV3IEJveDMkMSh0aGlzLmxvYWRGbG9hdDMyVmVjMygpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMygpKQ0KICB9DQoNCiAgLyoqDQogICAqIFRoZSByZWFkUGFkZCBtZXRob2QuDQogICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBUaGUgc3RyaWRlIHBhcmFtLg0KICAgKi8NCiAgcmVhZFBhZGQoc3RyaWRlKSB7DQogICAgY29uc3QgcGFkZCA9IHRoaXMuX19ieXRlT2Zmc2V0ICUgc3RyaWRlOw0KICAgIGlmIChwYWRkICE9IDApIHRoaXMuX19ieXRlT2Zmc2V0ICs9IHN0cmlkZSAtIHBhZGQ7DQogIH0NCn0KCi8qKg0KICogQ2xhc3MgZGVzaWduZWQgdG8gc3RvcmUgdmVyc2lvbiBkYXRhLiBXaWRlbHkgdXNlZCBpbiB0aGUgemVhIGVuZ2luZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuDQogKi8NCmNsYXNzIFZlcnNpb24gew0KICAvKioNCiAgICogQ3JlYXRlcyBhIHZlcnNpb24uDQogICAqIFRoZSB2ZXJzaW9uIHN0cmluZyBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTogPGJyPg0KICAgKiBtYWpvciwgbWlub3IgYW5kIHBhdGNoIHNlcGFyYXRlZCBieSBhIGRvdChgLmApIGFuZCBwYXJ0cyBzZXBhcmF0ZWQgYnkgYSBkYXNoKGAtYCkuDQogICAqDQogICAqIEBwYXJhbSB7c3RyfSB2ZXJzaW9uU3RyIC0gVGhlIHZlcnNpb24gc3RyaW5nIHZhbHVlLg0KICAgKi8NCiAgY29uc3RydWN0b3IodmVyc2lvblN0cikgew0KICAgIGlmICh2ZXJzaW9uU3RyKSB7DQogICAgICBjb25zdCBwYXJ0cyA9IHZlcnNpb25TdHIuc3BsaXQoJy0nKTsNCiAgICAgIGNvbnN0IG51bWJlcnMgPSBwYXJ0c1swXS5zcGxpdCgnLicpOw0KICAgICAgdGhpcy5tYWpvciA9IHBhcnNlSW50KG51bWJlcnNbMF0pOw0KICAgICAgdGhpcy5taW5vciA9IHBhcnNlSW50KG51bWJlcnNbMV0pOw0KICAgICAgdGhpcy5wYXRjaCA9IHBhcnNlSW50KG51bWJlcnNbMl0pOw0KICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAyKSB0aGlzLmJyYW5jaCA9IHBhcnRzWzFdOw0KICAgIH0gZWxzZSB7DQogICAgICB0aGlzLm1ham9yID0gMDsNCiAgICAgIHRoaXMubWlub3IgPSAwOw0KICAgICAgdGhpcy5wYXRjaCA9IDA7DQogICAgfQ0KICB9DQoNCiAgLyoqDQogICAqIENvbXBhcmUgYSB2ZXJzaW9uIG9iamVjdCBhZ2FpbnN0IGEgdmVyc2lvbiBudW1iZXJzIGFycmF5Lg0KICAgKg0KICAgKiBAcGFyYW0ge2FycmF5fSBudW1iZXJzIC0gQW4gYXJyYXkgY29udGFpbmluZyAzIHZlcnNpb24gbnVtYmVycy4gW01ham9yLCBNaW5vciwgUGF0Y2hdDQogICAqIEByZXR1cm4ge251bWJlcn0gLSByZXR1cm4gcG9zaXRpdmU6IHYxID4gdjIsIHplcm86djEgPT0gdjIsIG5lZ2F0aXZlOiB2MSA8IHYyDQogICAqLw0KICBjb21wYXJlKG51bWJlcnMpIHsNCiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82ODMyNTk2L2hvdy10by1jb21wYXJlLXNvZnR3YXJlLXZlcnNpb24tbnVtYmVyLXVzaW5nLWpzLW9ubHktbnVtYmVyDQogICAgLy8gMm5kIGFuc3dlci4NCiAgICBjb25zdCB2MSA9IFt0aGlzLm1ham9yLCB0aGlzLm1pbm9yLCB0aGlzLnBhdGNoXTsNCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykgew0KICAgICAgaWYgKHYxW2ldICE9PSBudW1iZXJzW2ldKSByZXR1cm4gdjFbaV0gLSBudW1iZXJzW2ldDQogICAgfQ0KICAgIHJldHVybiAwDQogIH0NCg0KICAvKioNCiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuDQogICAqDQogICAqIEBwYXJhbSB7YXJyYXl9IG51bWJlcnMgLSBUaGUgbnVtYmVycyB2YWx1ZS4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZXF1YWxzKG51bWJlcnMpIHsNCiAgICByZXR1cm4gISh0aGlzLnBhdGNoID09IG51bWJlcnNbMl0gJiYgdGhpcy5taW5vciA9PSBudW1iZXJzWzFdICYmIHRoaXMubWFqb3IgPT0gbnVtYmVyc1swXSkNCiAgfQ0KDQogIC8qKg0KICAgKiBDb21wYXJlIGEgdmVyc2lvbiBvYmplY3QgYWdhaW5zdCBhIHZlcnNpb24gbnVtYmVycyBhcnJheS4NCiAgICoNCiAgICogQHBhcmFtIHthcnJheX0gbnVtYmVycyAtIFRoZSBudW1iZXJzIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBsZXNzVGhhbihudW1iZXJzKSB7DQogICAgcmV0dXJuICEodGhpcy5tYWpvciA+PSBudW1iZXJzWzBdIHx8IHRoaXMubWlub3IgPj0gbnVtYmVyc1sxXSB8fCB0aGlzLnBhdGNoID49IG51bWJlcnNbMl0pDQogICAgLy8gaWYgKHRoaXMubWFqb3IgPj0gbnVtYmVyc1swXSkgcmV0dXJuIGZhbHNlDQogICAgLy8gaWYgKHRoaXMubWlub3IgPj0gbnVtYmVyc1sxXSkgcmV0dXJuIGZhbHNlDQogICAgLy8gaWYgKHRoaXMucGF0Y2ggPj0gbnVtYmVyc1syXSkgcmV0dXJuIGZhbHNlDQogICAgLy8gcmV0dXJuIHRydWUNCiAgICAvLyByZXR1cm4gKA0KICAgIC8vICAgdGhpcy5tYWpvciA8IG51bWJlcnNbMF0gfHwNCiAgICAvLyAgIHRoaXMubWlub3IgPCBudW1iZXJzWzFdIHx8DQogICAgLy8gICB0aGlzLnBhdGNoIDwgbnVtYmVyc1syXQ0KICAgIC8vICkNCiAgfQ0KDQogIC8qKg0KICAgKiBDb21wYXJlIGEgdmVyc2lvbiBvYmplY3QgYWdhaW5zdCBhIHZlcnNpb24gbnVtYmVycyBhcnJheS4NCiAgICoNCiAgICogQHBhcmFtIHthcnJheX0gbnVtYmVycyAtIFRoZSBudW1iZXJzIHZhbHVlLg0KICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAqLw0KICBncmVhdGVyVGhhbihudW1iZXJzKSB7DQogICAgcmV0dXJuIHRoaXMubWFqb3IgPiBudW1iZXJzWzBdIHx8IHRoaXMubWlub3IgPiBudW1iZXJzWzFdIHx8IHRoaXMucGF0Y2ggPiBudW1iZXJzWzJdDQogIH0NCg0KICAvKioNCiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuDQogICAqDQogICAqIEBwYXJhbSB7YXJyYXl9IG51bWJlcnMgLSBUaGUgbnVtYmVycyB2YWx1ZS4NCiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgKi8NCiAgZ3JlYXRlck9yRXF1YWxUaGFuKG51bWJlcnMpIHsNCiAgICBpZiAodGhpcy5tYWpvciA8IG51bWJlcnNbMF0pIHJldHVybiBmYWxzZQ0KICAgIGlmICh0aGlzLm1ham9yID4gbnVtYmVyc1swXSkgcmV0dXJuIHRydWUNCg0KICAgIGlmICh0aGlzLm1pbm9yIDwgbnVtYmVyc1sxXSkgcmV0dXJuIGZhbHNlDQogICAgaWYgKHRoaXMubWlub3IgPiBudW1iZXJzWzFdKSByZXR1cm4gdHJ1ZQ0KDQogICAgaWYgKHRoaXMucGF0Y2ggPCBudW1iZXJzWzJdKSByZXR1cm4gZmFsc2UNCiAgICByZXR1cm4gdHJ1ZQ0KICAgIC8vIHJldHVybiAoDQogICAgLy8gICB0aGlzLm1ham9yID49IG51bWJlcnNbMF0gJiYNCiAgICAvLyAgIHRoaXMubWlub3IgPj0gbnVtYmVyc1sxXSAmJg0KICAgIC8vICAgdGhpcy5wYXRjaCA+PSBudW1iZXJzWzJdDQogICAgLy8gKQ0KICB9DQp9CgovKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi8NCg0KLy8ga2V5LCB0b2MsIGdlb21JbmRleE9mZnNldCwgZ2VvbXNSYW5nZSwgaXNNb2JpbGVEZXZpY2UsIGJ1ZmZlclNsaWNlLCBnZW5CdWZmZXJzT3B0cywgY29udGV4dA0KY29uc3QgcGFyc2VHZW9tc0JpbmFyeSA9IChkYXRhLCBjYWxsYmFjaykgPT4gew0KICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluDQogIGZvciAoY29uc3Qga2V5IGluIGRhdGEuY29udGV4dC52ZXJzaW9ucykgew0KICAgIGNvbnN0IHYgPSBkYXRhLmNvbnRleHQudmVyc2lvbnNba2V5XTsNCiAgICBjb25zdCB2ZXJzaW9uID0gbmV3IFZlcnNpb24oKTsNCiAgICB2ZXJzaW9uLm1ham9yID0gdi5tYWpvcjsNCiAgICB2ZXJzaW9uLm1pbm9yID0gdi5taW5vcjsNCiAgICB2ZXJzaW9uLnBhdGNoID0gdi5wYXRjaDsNCiAgICB2ZXJzaW9uLmJyYW5jaCA9IHYuYnJhbmNoOw0KICAgIGRhdGEuY29udGV4dC52ZXJzaW9uc1trZXldID0gdmVyc2lvbjsNCiAgfQ0KICBjb25zdCBnZW9tRGF0YXMgPSBbXTsNCiAgY29uc3Qgb2Zmc2V0ID0gZGF0YS50b2NbZGF0YS5nZW9tc1JhbmdlWzBdXTsNCiAgLy8gY29uc29sZS5sb2coIm9mZnNldDoiICsgIG9mZnNldCk7DQogIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTsNCiAgZm9yIChsZXQgaSA9IGRhdGEuZ2VvbXNSYW5nZVswXTsgaSA8IGRhdGEuZ2VvbXNSYW5nZVsxXTsgaSsrKSB7DQogICAgY29uc3QgcmVhZGVyID0gbmV3IEJpblJlYWRlcihkYXRhLmJ1ZmZlclNsaWNlLCBkYXRhLnRvY1tpXSAtIG9mZnNldCwgZGF0YS5pc01vYmlsZURldmljZSk7DQogICAgY29uc3QgY2xhc3NOYW1lID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICBjb25zdCBwb3MgPSByZWFkZXIucG9zKCk7DQogICAgLy8gY29uc3QgbmFtZSA9IHJlYWRlci5sb2FkU3RyKCkNCiAgICAvLyBjb25zb2xlLmxvZyhpICsgIjoiICsgb2Zmc2V0ICsgIiBjbGFzc05hbWU6IiArICBjbGFzc05hbWUgICsgIiBuYW1lOiIgKyAgbmFtZS8qICsgIiBwb3M6IiArIChkYXRhLnRvY1tpXSAtIG9mZnNldCkgKyAiIGJ1ZmZlclNsaWNlLmJ5dGVMZW5ndGg6IiArICBidWZmZXJTbGljZS5ieXRlTGVuZ3RoKi8pOw0KICAgIGxldCBnZW9tOw0KICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7DQogICAgICBjYXNlICdQb2ludHMnOg0KICAgICAgICBnZW9tID0gbmV3IFBvaW50cygpOw0KICAgICAgICBicmVhaw0KICAgICAgY2FzZSAnTGluZXMnOg0KICAgICAgICBnZW9tID0gbmV3IExpbmVzKCk7DQogICAgICAgIGJyZWFrDQogICAgICBjYXNlICdNZXNoJzoNCiAgICAgICAgZ2VvbSA9IG5ldyBNZXNoKCk7DQogICAgICAgIGJyZWFrDQogICAgICBkZWZhdWx0Og0KICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEdlb20gdHlwZTonICsgY2xhc3NOYW1lKQ0KICAgIH0NCiAgICB0cnkgew0KICAgICAgcmVhZGVyLnNlZWsocG9zKTsgLy8gUmVzZXQgdGhlIHBvaW50ZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBpdGVtIGRhdGEuDQogICAgICBnZW9tLnJlYWRCaW5hcnkocmVhZGVyLCBkYXRhLmNvbnRleHQpOw0KICAgIH0gY2F0Y2ggKGUpIHsNCiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9hZGluZzonICsgZ2VvbS5uYW1lICsgJ1xuOicgKyBlKTsNCiAgICAgIGdlb21EYXRhcy5wdXNoKHt9KTsNCiAgICAgIGNvbnRpbnVlDQogICAgfQ0KDQogICAgY29uc3QgZ2VvbUJ1ZmZlcnMgPSBnZW9tLmdlbkJ1ZmZlcnMoZGF0YS5nZW5CdWZmZXJzT3B0cyk7DQogICAgaWYgKGdlb21CdWZmZXJzLmluZGljZXMpIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy5pbmRpY2VzLmJ1ZmZlcik7DQogICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBnZW9tQnVmZmVycy5hdHRyQnVmZmVycykgew0KICAgICAgLy8gTm90ZTogVGhlIHR5cGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIGF0dHJpYnV0ZSBjYW4NCiAgICAgIC8vIG5vdCBiZSB0cmFuc2ZlcmVkIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLiBDb252ZXJ0IHRvDQogICAgICAvLyB0aGUgdHlwZSBuYW1lIGhlcmUgYW5kIHNlbmQgYmFjayBhcyBhIHN0cmluZy4NCiAgICAgIGNvbnN0IGF0dHJEYXRhID0gZ2VvbUJ1ZmZlcnMuYXR0ckJ1ZmZlcnNbYXR0ck5hbWVdOw0KICAgICAgY29uc3QgdHlwZU5hbWUgPSBSZWdpc3RyeS5nZXRCbHVlcHJpbnROYW1lKGF0dHJEYXRhLmRhdGFUeXBlKTsNCiAgICAgIGF0dHJEYXRhLmRhdGFUeXBlID0gdHlwZU5hbWU7DQoNCiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhdHRyRGF0YS52YWx1ZXMuYnVmZmVyKTsNCiAgICB9DQoNCiAgICBpZiAoZ2VvbUJ1ZmZlcnMudmVydGV4TmVpZ2hib3JzKSB7DQogICAgICB0cmFuc2ZlcmFibGVzLnB1c2goZ2VvbUJ1ZmZlcnMudmVydGV4TmVpZ2hib3JzLmJ1ZmZlcik7DQogICAgfQ0KDQogICAgLy8gVHJhbnNmZXIgdGhlIGJib3ggcG9pbnQgYnVmZmVycy4NCiAgICBjb25zdCBiYm94ID0gZ2VvbS5nZXRCb3VuZGluZ0JveCgpOw0KICAgIHRyYW5zZmVyYWJsZXMucHVzaChiYm94LnAwLl9fZGF0YS5idWZmZXIpOw0KICAgIHRyYW5zZmVyYWJsZXMucHVzaChiYm94LnAxLl9fZGF0YS5idWZmZXIpOw0KDQogICAgZ2VvbURhdGFzLnB1c2goew0KICAgICAgbmFtZTogZ2VvbS5uYW1lLA0KICAgICAgdHlwZTogY2xhc3NOYW1lLA0KICAgICAgZ2VvbUJ1ZmZlcnMsDQogICAgICBiYm94LA0KICAgIH0pOw0KICB9DQogIGNhbGxiYWNrKA0KICAgIHsNCiAgICAgIGtleTogZGF0YS5rZXksDQogICAgICBnZW9tSW5kZXhPZmZzZXQ6IGRhdGEuZ2VvbUluZGV4T2Zmc2V0LA0KICAgICAgZ2VvbXNSYW5nZTogZGF0YS5nZW9tc1JhbmdlLA0KICAgICAgZ2VvbURhdGFzLA0KICAgIH0sDQogICAgdHJhbnNmZXJhYmxlcw0KICApOw0KfTsKCnNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7DQogIHBhcnNlR2VvbXNCaW5hcnkoZXZlbnQuZGF0YSwgKGRhdGEsIHRyYW5zZmVyYWJsZXMpID0+IHsNCiAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyYWJsZXMpOw0KICB9KTsNCn07Cgo=', 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2VvbVBhcnNlcldvcmtlci5qcyIsInNvdXJjZXMiOlsic3JjL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMuanMiLCJzcmMvTWF0aC9BdHRyVmFsdWUuanMiLCJzcmMvVXRpbGl0aWVzL01hdGhGdW5jdGlvbnMuanMiLCJzcmMvUmVnaXN0cnkuanMiLCJzcmMvTWF0aC9WZWMyLmpzIiwic3JjL01hdGgvVmVjMy5qcyIsInNyYy9NYXRoL1ZlYzQuanMiLCJzcmMvTWF0aC9SR0JBLmpzIiwic3JjL01hdGgvQ29sb3IuanMiLCJzcmMvTWF0aC9FdWxlckFuZ2xlcy5qcyIsInNyYy9NYXRoL01hdDMuanMiLCJzcmMvTWF0aC9NYXQ0LmpzIiwic3JjL01hdGgvUXVhdC5qcyIsInNyYy9NYXRoL1JheS5qcyIsInNyYy9NYXRoL1hmby5qcyIsInNyYy9NYXRoL0JveDIuanMiLCJzcmMvTWF0aC9TcGhlcmVUeXBlLmpzIiwic3JjL01hdGgvQm94My5qcyIsInNyYy9NYXRoL1BsYW5lVHlwZS5qcyIsInNyYy9NYXRoL0ZydXN0dW0uanMiLCJzcmMvVXRpbGl0aWVzL0V2ZW50RW1pdHRlci5qcyIsInNyYy9TY2VuZVRyZWUvUGFyYW1ldGVyT3duZXIuanMiLCJzcmMvU2NlbmVUcmVlL0dlb21ldHJ5L0F0dHJpYnV0ZS5qcyIsInNyYy9TY2VuZVRyZWUvR2VvbWV0cnkvQmFzZUdlb20uanMiLCJzcmMvU2NlbmVUcmVlL0dlb21ldHJ5L1BvaW50cy5qcyIsInNyYy9TY2VuZVRyZWUvR2VvbWV0cnkvTGluZXMuanMiLCJzcmMvU2NlbmVUcmVlL0dlb21ldHJ5L1ZlcnRleEF0dHJpYnV0ZS5qcyIsInNyYy9TY2VuZVRyZWUvR2VvbWV0cnkvTWVzaC5qcyIsInNyYy9TY2VuZVRyZWUvQmluUmVhZGVyLmpzIiwic3JjL1NjZW5lVHJlZS9WZXJzaW9uLmpzIiwic3JjL1NjZW5lVHJlZS9HZW9tZXRyeS9wYXJzZUdlb21zQmluYXJ5LmpzIiwic3JjL1NjZW5lVHJlZS9HZW9tZXRyeS9HZW9tUGFyc2VyV29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdHJpbmcgZnVuY3Rpb25zXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBTdHJpbmdGdW5jdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIGFsbCBtYXRjaGVzIGluIGEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gcGF0dGVybiAtXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VtZW50IC1cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC1cclxuICAgKi9cclxuICBzdGF0aWMgcmVwbGFjZUFsbChzdHIsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpLCByZXBsYWNlbWVudClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgSlNPTiBvYmplY3QgYXMgYSBmb3JtYXR0ZWQgc3RyaW5nLCBidXQgdGhlIG51bWVyaWMgdmFsdWVzIGFyZSBmaXhlZCB0byB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbi5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NwYWNlPTBdIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj01XSAtXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtXHJcbiAgICovXHJcbiAgc3RhdGljIHN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odmFsLCBzcGFjZSA9IDAsIHByZWNpc2lvbiA9IDUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcclxuICAgICAgdmFsLFxyXG4gICAgICAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICByZXR1cm4gdmFsID8gKHZhbC50b0ZpeGVkID8gTnVtYmVyKHZhbC50b0ZpeGVkKHByZWNpc2lvbikpIDogdmFsKSA6IHZhbFxyXG4gICAgICB9LFxyXG4gICAgICBzcGFjZVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSBudW1lcmljIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7Kn0gc3RyIC1cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC1cclxuICAgKi9cclxuICBzdGF0aWMgaGFzaFN0cihzdHIpIHtcclxuICAgIGxldCBoYXNoID0gMFxyXG4gICAgbGV0IGlcclxuICAgIGxldCBjaHJcclxuICAgIGxldCBsZW5cclxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaFxyXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpXHJcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHJcclxuICAgICAgaGFzaCB8PSAwIC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGguYWJzKGhhc2gpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHJpbmdGdW5jdGlvbnNcclxuZXhwb3J0IHsgU3RyaW5nRnVuY3Rpb25zIH1cclxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxyXG5pbXBvcnQgU3RyaW5nRnVuY3Rpb25zIGZyb20gJy4uL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMnXHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgTWF0aCB0eXBlcyB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gdmVydGV4IGF0dHJpYnV0ZXMuXHJcbiAqIDxicj5cclxuICogKipOb3RlOioqIFRoZXNlIHZhbHVlcyB1c2Uge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9IHZhbHVlcyB0byBzdG9yZSB0aGVpciBkYXRhLlxyXG4gKi9cclxuY2xhc3MgQXR0clZhbHVlIHtcclxuICAvKipcclxuICAgKiBWZXJpZmllcyBpZiB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGlzIE1hdGggdHlwZSBhcmUgdmFsaWQgbnVtZXJpYyB2YWx1ZXMuXHJcbiAgICogUmV0dXJucyBgZmFsc2VgIElmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGlzIGVpdGhlciB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2lhL09iamV0b3NfZ2xvYmFsZXMvSW5maW5pdHl8SW5maW5pdHl9IG9yXHJcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNpYS9PYmpldG9zX2dsb2JhbGVzL05hTnxOYU59LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBib29sZWFuLlxyXG4gICAqL1xyXG4gIGlzVmFsaWQoKSB7XHJcbiAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5fX2RhdGEpIHtcclxuICAgICAgaWYgKHYgPT0gSW5maW5pdHkgfHwgaXNOYU4odikpIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXMgb2YgbWF0aCB0eXBlcywgZ2l2ZW4gYW4gZXhpc3RpbmcgRmxvYXQzMkFycmF5IGJ1ZmZlci5cclxuICAgKiBFYWNoIE1hdGggdHlwZSBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGFuIGNvbnN0cnVjdGVkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gdGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtBdHRyVmFsdWV9IC0gUmV0dXJucyB0aGUgY29uc3RydWN0ZWQgdmFsdWUuXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6JyArIHRoaXMuY29uc3RydWN0b3IubmFtZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlcyBvZiBtYXRoIHR5cGVzLCBnaXZlbiBhbiBleGlzdGluZyBBcnJheUJ1ZmZlci5cclxuICAgKiBFYWNoIE1hdGggdHlwZSBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGFuIGNvbnN0cnVjdGVkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0XHJcbiAgICogQHJldHVybiB7QXR0clZhbHVlfSAtIFJldHVybnMgdGhlIGNvbnN0cnVjdGVkIHZhbHVlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6JyArIHRoaXMuY29uc3RydWN0b3IubmFtZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBGbG9hdDMyIGVsZW1lbnRzIHVzZWQgYnkgdGhpcyB0eXBlLiBVc2VkIHRvIGNhbGN1bGF0ZSBzdG9yYWdlIHJlcXVpcmVtZW50cyBmb3IgbGFyZ2UgYXJyYXlzIG9mIHRoaXMgdHlwZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZsb2F0IHZhbHVlcyBzdG9yZWQgaW4gdGhpcyBtYXRoIHR5cGUuXHJcbiAgICovXHJcbiAgc3RhdGljIG51bUVsZW1lbnRzKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6JyArIHRoaXMuY29uc3RydWN0b3IubmFtZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBNYXRoIHR5cGUgZGF0YSBhcyBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuXHJcbiAgICovXHJcbiAgYXNBcnJheSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhpcyBNYXRoIHR5cGUgdG8gYSBzdHJpbmcgaW4gSlNPTiBmb3JtYXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXHJcbiAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgTWF0aCB0eXBlIHRvIGEgSlNPTiBvYmplY3QuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQgZm9yIHRoaXMgdHlwZTonICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHsgQXR0clZhbHVlIH1cclxuZXhwb3J0IGRlZmF1bHQgQXR0clZhbHVlXHJcbiIsImNvbnN0IFVJbnQ4ID0gMFxyXG5jb25zdCBTSW50OCA9IDFcclxuY29uc3QgVUludDE2ID0gMlxyXG5jb25zdCBTSW50MTYgPSAzXHJcbmNvbnN0IFVJbnQzMiA9IDRcclxuY29uc3QgU0ludDMyID0gNVxyXG5jb25zdCBGbG9hdDMyID0gNlxyXG5cclxuLyoqXHJcbiAqIE1hdGggRnVuY3Rpb25zXHJcbiAqL1xyXG5jbGFzcyBNYXRoRnVuY3Rpb25zIHtcclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBSYWRpYW5zIHRvIERlZ3JlZXNcclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gUmFkaWFucyB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBEZWdyZWVzIGVxdWl2YWxlbnRcclxuICAgKi9cclxuICBzdGF0aWMgcmFkVG9EZWcocmFkKSB7XHJcbiAgICByZXR1cm4gcmFkIC8gKE1hdGguUEkgLyAxODApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBEZWdyZWVzIHRvIFJhZGlhbnRzXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyAtIERlZ3JlZXMgdmFsdWVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gIFJhZGlhbnMgZXF1aXZhbGVudFxyXG4gICAqL1xyXG4gIHN0YXRpYyBkZWdUb1JhZChkZWcpIHtcclxuICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZlcmlmaWVzIGlmIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIGlzIG51bWVyaWMuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8YW55fSBudW1iZXIgLSBOdW1iZXIgdG8gdGVzdFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gYHRydWVgIHdoZW4gaXMgYSB2YWxpZCBudW1iZXJcclxuICAgKi9cclxuICBzdGF0aWMgaXNOdW1lcmljKG51bWJlcikge1xyXG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpICYmIGlzRmluaXRlKG51bWJlcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBMb3dlciB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gSGlnaGVzdCB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmFuZG9tIG51bWJlciBpbnNpZGUgcmFuZ2UuXHJcbiAgICovXHJcbiAgc3RhdGljIHJhbmRvbUludChtaW4sIG1heCkge1xyXG4gICAgbWluID0gTWF0aC5jZWlsKG1pbilcclxuICAgIG1heCA9IE1hdGguZmxvb3IobWF4KVxyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBhIGxpbmVhbCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIGlucHV0cyBmb3IgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIodCkuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHYwIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdjEgLVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IC1cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC1cclxuICAgKi9cclxuICBzdGF0aWMgbGVycCh2MCwgdjEsIHQpIHtcclxuICAgIHJldHVybiB2MCArIHQgKiAodjEgLSB2MClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3RyaWN0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIGJldHdlZW4gdHdvIG51bWJlcnNcclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG5lYXJlc3QgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLVxyXG4gICAqL1xyXG4gIHN0YXRpYyBuZWFyZXN0UG93Mih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGgucm91bmQoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coMikpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbmVhcmVzdCBwb3cgb2YgdGVuIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtXHJcbiAgICovXHJcbiAgc3RhdGljIG5lYXJlc3RQb3cxMCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCBNYXRoLnJvdW5kKE1hdGgubG9nMTAodmFsdWUpIC8gTWF0aC5sb2cxMCgxMCkpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbmV4dCBwb3cgb2YgdHdvIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtXHJcbiAgICovXHJcbiAgc3RhdGljIG5leHRQb3cyKHZhbHVlKSB7XHJcbiAgICBsZXQgZXhwID0gMFxyXG5cclxuICAgIHdoaWxlICh2YWx1ZSA+IDApIHtcclxuICAgICAgZXhwKytcclxuICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDEgPDwgZXhwXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBmcmFjdGlvbmFsIGNvbXBvbmVudCBvZiBhIG51bWJlclxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtXHJcbiAgICovXHJcbiAgc3RhdGljIGZyYWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gMCkgcmV0dXJuIDBcclxuICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgaWYgKHZhbHVlID4gLTEuMCkgcmV0dXJuIC12YWx1ZVxyXG4gICAgICByZXR1cm4gLXZhbHVlICUgTWF0aC5mbG9vcigtdmFsdWUpXHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPCAxLjApIHJldHVybiB2YWx1ZVxyXG4gICAgcmV0dXJuIHZhbHVlICUgTWF0aC5mbG9vcih2YWx1ZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSBvbmUgbnVtZXJpYyBkb21haW4ocmFuZ2UpIHRvIGFub3RoZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQxIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kMSAtXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0MiAtXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZDIgLVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLVxyXG4gICAqL1xyXG4gIHN0YXRpYyByZW1hcCh2YWx1ZSwgc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpIHtcclxuICAgIHJldHVybiBzdGFydDIgKyAoZW5kMiAtIHN0YXJ0MikgKiAoKHZhbHVlIC0gc3RhcnQxKSAvIChlbmQxIC0gc3RhcnQxKSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm0gSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZhbHVlc1xyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlMCAtXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2UxIC1cclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtXHJcbiAgICovXHJcbiAgc3RhdGljIHNtb290aFN0ZXAoZWRnZTAsIGVkZ2UxLCB4KSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcy5jbGFtcCgoeCAtIGVkZ2UwKSAvIChlZGdlMSAtIGVkZ2UwKSwgMC4wLCAxLjApXHJcbiAgICByZXR1cm4gdCAqIHQgKiAoMy4wIC0gMi4wICogdClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIC0gaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2YWx1ZXNcclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZTAgLVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlMSAtXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLVxyXG4gICAqL1xyXG4gIHN0YXRpYyBsaW5TdGVwKGVkZ2UwLCBlZGdlMSwgeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb2RlcyBhIEZsb2F0MTYgZnJvbSB0d28gdW5zaWduZWQgSW50OFxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYyAtIEFycmF5IHdpdGggdGhlIHR3byBVSW50OFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBEZWNvZGVkIEZsb2F0MTZcclxuICAgKi9cclxuICBzdGF0aWMgZGVjb2RlMTZCaXRGbG9hdEZyb20yeFVJbnQ4KGMpIHtcclxuICAgIGNvbnN0IGl4ID0gY1swXSAvLyAxc3QgYnl0ZTogMSBiaXQgc2lnbmVkIG51bSwgNCBiaXRzIGV4cG9uZW50LCAzIGJpdHMgbWFudGlzc2EgKE1TQilcclxuICAgIGNvbnN0IGl5ID0gY1sxXSAvLyAybmQgYnl0ZTogOCBiaXQgbWFudGlzc2EgKExTQilcclxuXHJcbiAgICBjb25zdCBzID0gaXggJiAweDgwID8gMSA6IC0xIC8vIGdldCBiaXQgOFxyXG4gICAgY29uc3QgaWV4cCA9IChpeCAmIDB4NzgpID4+IDMgLy8gbWFzayBiaXRzIDctNFxyXG4gICAgY29uc3QgbXNiID0gaXggJiAweDcgLy8gbWFzayBiaXRzIDMtMVxyXG5cclxuICAgIGxldCBub3JtID0gaWV4cCA9PSAwID8gMCA6IDIwNDggLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBub3JtYWxpemVkIGFuZCBzdWItbm9ybWFsaXplZCBudW1iZXJzXHJcbiAgICBjb25zdCBtYW50aXNzYSA9IG5vcm0gKyAobXNiIDw8IDgpICsgaXkgLy8gaW1wbGljaXQgcHJlY2VkaW5nIDEgb3IgMCBhZGRlZCBoZXJlXHJcbiAgICBub3JtID0gaWV4cCA9PSAwID8gMSA6IDAgLy8gbm9ybWFsaXphdGlvbiB0b2dnbGVcclxuICAgIGNvbnN0IGV4cG9uZW50ID0gTWF0aC5wb3coMiwgaWV4cCArIG5vcm0gLSAxNikgLy8gLTUgZm9yIHRoZSB0aGUgZXhwb25lbnQgYmlhcyBmcm9tIDJeLTUgdG8gMl4xMCBwbHVzIGFub3RoZXIgLTExIGZvciB0aGUgbm9ybWFsaXplZCAxMiBiaXQgbWFudGlzc2FcclxuICAgIGNvbnN0IHYgPSBzICogbWFudGlzc2EgKiBleHBvbmVudFxyXG5cclxuICAgIHJldHVybiB2XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbmNvZGVzIGFuIGFycmF5IG9mIHR3byB1bnNpZ25lZCBJbnQ4IHRvIGEgRmxvYXQxNlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IC0gRmxvYXQxNiBudW1iZXJcclxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIEVuY29kZWQgVW5zaWduZWQgSW50OCBhcnJheVxyXG4gICAqL1xyXG4gIHN0YXRpYyBlbmNvZGUxNkJpdEZsb2F0SW50bzJ4VUludDgodikge1xyXG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KDIpXHJcbiAgICAvLyBjb25zdCBjID0gWzAsIDBdO1xyXG4gICAgY29uc3Qgc2lnbnVtID0gdiA+PSAwID8gMTI4IDogMFxyXG4gICAgdiA9IE1hdGguYWJzKHYpXHJcbiAgICBsZXQgZXhwb25lbnQgPSAxNVxyXG4gICAgbGV0IGxpbWl0ID0gMTAyNCAvLyBjb25zaWRlcmluZyB0aGUgYmlhcyBmcm9tIDJeLTUgdG8gMl4xMCAoPT0xMDI0KVxyXG4gICAgZm9yIChsZXQgZXhwID0gMTU7IGV4cCA+IDA7IGV4cC0tKSB7XHJcbiAgICAgIGlmICh2IDwgbGltaXQpIHtcclxuICAgICAgICBsaW1pdCAvPSAyXHJcbiAgICAgICAgZXhwb25lbnQtLVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc3RcclxuICAgIGlmIChleHBvbmVudCA9PSAwKSB7XHJcbiAgICAgIHJlc3QgPSB2IC8gbGltaXQgLyAyIC8vIFwic3ViLW5vcm1hbGl6ZVwiIGltcGxpY2l0IHByZWNlZGluZyAwLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdCA9ICh2IC0gbGltaXQpIC8gbGltaXQgLy8gbm9ybWFsaXplIGFjY29yZGluZ2x5IHRvIGltcGxpY2l0IHByZWNlZGluZyAxLlxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1hbnRpc3NhID0gTWF0aC5yb3VuZChyZXN0ICogMjA0OCkgLy8gMjA0OCA9IDJeMTEgZm9yIHRoZSAoc3BsaXQpIDExIGJpdCBtYW50aXNzYVxyXG4gICAgY29uc3QgbXNiID0gbWFudGlzc2EgLyAyNTYgLy8gdGhlIG1vc3Qgc2lnbmlmaWNhbnQgMyBiaXRzIGdvIGludG8gdGhlIGxvd2VyIHBhcnQgb2YgdGhlIGZpcnN0IGJ5dGVcclxuICAgIGNvbnN0IGxzYiA9IG1hbnRpc3NhIC0gbXNiICogMjU2IC8vIHRoZXJlIGdvIHRoZSBvdGhlciA4IGJpdCBvZiB0aGUgbG93ZXIgc2lnbmlmaWNhbmNlXHJcblxyXG4gICAgY1swXSA9IHNpZ251bSArIGV4cG9uZW50ICogOCArIG1zYiAvLyBjb2xvciBub3JtYWxpemF0aW9uIGZvciB0ZXh0dXJlMkRcclxuICAgIGNbMV0gPSBsc2JcclxuXHJcbiAgICBpZiAodiA+PSAyMDQ4KSB7XHJcbiAgICAgIGNbMF0gPSAyNTVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyBhIDE2IGJpdCBmbG9hdCB0byBhbiBlbmNvZGVkIGludGVnZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHYgLSBGbG9hdDE2IG51bWJlciB0byBlbmNvZGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gRW5jb2RlZCBudW1iZXJcclxuICAgKi9cclxuICBzdGF0aWMgZW5jb2RlMTZCaXRGbG9hdCh2KSB7XHJcbiAgICBjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpXHJcbiAgICBmbG9hdDMyQXJyYXlbMF0gPSB2XHJcbiAgICBjb25zdCBpbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyQXJyYXkuYnVmZmVyKVxyXG5cclxuICAgIGNvbnN0IHRvVUludDE2ID0gKHgpID0+IHtcclxuICAgICAgbGV0IGJpdHMgPSAoeCA+PiAxNikgJiAweDgwMDAgLyogR2V0IHRoZSBzaWduICovXHJcbiAgICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmIC8qIEtlZXAgb25lIGV4dHJhIGJpdCBmb3Igcm91bmRpbmcgKi9cclxuICAgICAgY29uc3QgZSA9ICh4ID4+IDIzKSAmIDB4ZmYgLyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovXHJcblxyXG4gICAgICAvKiBJZiB6ZXJvLCBvciBkZS1ub3JtYWwsIG9yIGV4cG9uZW50IHVuZGVyZmxvd3MgdG9vIG11Y2ggZm9yIGEgZGUtbm9ybWFsXHJcbiAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi9cclxuICAgICAgaWYgKGUgPCAxMDMpIHtcclxuICAgICAgICByZXR1cm4gYml0c1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBJZiBOYU4sIHJldHVybiBOYU4uIElmIEluZiBvciBleHBvbmVudCBvdmVyZmxvdywgcmV0dXJuIEluZi4gKi9cclxuICAgICAgaWYgKGUgPiAxNDIpIHtcclxuICAgICAgICBiaXRzIHw9IDB4N2MwMFxyXG4gICAgICAgIC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTixcclxuICAgICAgICAgKiBub3QgSW5mLCBzbyBtYWtlIHN1cmUgd2Ugc2V0IG9uZSBtYW50aXNzYSBiaXQgdG9vLiAqL1xyXG4gICAgICAgIGJpdHMgfD0gKGUgPT0gMjU1ID8gMCA6IDEpICYmIHggJiAweDAwN2ZmZmZmXHJcbiAgICAgICAgcmV0dXJuIGJpdHNcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogSWYgZXhwb25lbnQgdW5kZXJmbG93cyBidXQgbm90IHRvbyBtdWNoLCByZXR1cm4gYSBkZS1ub3JtYWwgKi9cclxuICAgICAgaWYgKGUgPCAxMTMpIHtcclxuICAgICAgICBtIHw9IDB4MDgwMFxyXG4gICAgICAgIC8qIEV4dHJhIHJvdW5kaW5nIG1heSBvdmVyZmxvdyBhbmQgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGV4cG9uZW50XHJcbiAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovXHJcbiAgICAgICAgYml0cyB8PSAobSA+PiAoMTE0IC0gZSkpICsgKChtID4+ICgxMTMgLSBlKSkgJiAxKVxyXG4gICAgICAgIHJldHVybiBiaXRzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKVxyXG4gICAgICAvKiBFeHRyYSByb3VuZGluZy4gQW4gb3ZlcmZsb3cgd2lsbCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgaW5jcmVtZW50XHJcbiAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovXHJcbiAgICAgIGJpdHMgKz0gbSAmIDFcclxuXHJcbiAgICAgIHJldHVybiBiaXRzXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvVUludDE2KGludDMyVmlld1swXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzIG9wcG9zaXRlIG9mIHRoZSBgZW5jb2RlMTZCaXRGbG9hdGAgbWV0aG9kLCB0aGlzIHRha2VzIGFuIGVuY29kZWQgaW50ZWdlciB2YWx1ZSxcclxuICAgKiBhbmQgcmV0dXJucyB0aGUgMTYgYml0IGZsb2F0LlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIC0gRW5jb2RlZCBpbnRlZ2VyXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIERlY29kZWQgMTYgYml0IGZsb2F0LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBkZWNvZGUxNkJpdEZsb2F0KGgpIHtcclxuICAgIGNvbnN0IHMgPSAoaCAmIDB4ODAwMCkgPj4gMTVcclxuICAgIGNvbnN0IGUgPSAoaCAmIDB4N2MwMCkgPj4gMTBcclxuICAgIGNvbnN0IGYgPSBoICYgMHgwM2ZmXHJcblxyXG4gICAgaWYgKGUgPT0gMCkge1xyXG4gICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogTWF0aC5wb3coMiwgLTE0KSAqIChmIC8gTWF0aC5wb3coMiwgMTApKVxyXG4gICAgfSBlbHNlIGlmIChlID09IDB4MWYpIHtcclxuICAgICAgcmV0dXJuIGYgPyBOYU4gOiAocyA/IC0xIDogMSkgKiBJbmZpbml0eVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBNYXRoLnBvdygyLCBlIC0gMTUpICogKDEgKyBmIC8gTWF0aC5wb3coMiwgMTApKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBGbG9hdCAzMiB0byBhbiBhcnJheSBvZiB1bnNpZ25lZCBJbnQxNi5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZmxvYXQzMkFycmF5IC1cclxuICAgKiBAcmV0dXJuIHtVaW50MTZBcnJheX0gLSBVbnNpZ25lZCBJbnQxNiBhcnJheSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgRmxvYXQzMkFycmF5XHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRGbG9hdDMyQXJyYXlUb1VJbnQxNkFycmF5KGZsb2F0MzJBcnJheSkge1xyXG4gICAgY29uc3QgdW5pdDE2cyA9IG5ldyBVaW50MTZBcnJheShmbG9hdDMyQXJyYXkubGVuZ3RoKVxyXG4gICAgY29uc3QgaW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkoZmxvYXQzMkFycmF5LmJ1ZmZlcilcclxuICAgIGNvbnN0IHRvVUludDE2ID0gKHgpID0+IHtcclxuICAgICAgbGV0IGJpdHMgPSAoeCA+PiAxNikgJiAweDgwMDAgLyogR2V0IHRoZSBzaWduICovXHJcbiAgICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmIC8qIEtlZXAgb25lIGV4dHJhIGJpdCBmb3Igcm91bmRpbmcgKi9cclxuICAgICAgY29uc3QgZSA9ICh4ID4+IDIzKSAmIDB4ZmYgLyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovXHJcblxyXG4gICAgICAvKiBJZiB6ZXJvLCBvciBkZS1ub3JtYWwsIG9yIGV4cG9uZW50IHVuZGVyZmxvd3MgdG9vIG11Y2ggZm9yIGEgZGUtbm9ybWFsXHJcbiAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi9cclxuICAgICAgaWYgKGUgPCAxMDMpIHtcclxuICAgICAgICByZXR1cm4gYml0c1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvKiBJZiBOYU4sIHJldHVybiBOYU4uIElmIEluZiBvciBleHBvbmVudCBvdmVyZmxvdywgcmV0dXJuIEluZi4gKi9cclxuICAgICAgaWYgKGUgPiAxNDIpIHtcclxuICAgICAgICBiaXRzIHw9IDB4N2MwMFxyXG4gICAgICAgIC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTixcclxuICAgICAgICAgKiBub3QgSW5mLCBzbyBtYWtlIHN1cmUgd2Ugc2V0IG9uZSBtYW50aXNzYSBiaXQgdG9vLiAqL1xyXG4gICAgICAgIGJpdHMgfD0gKGUgPT0gMjU1ID8gMCA6IDEpICYmIHggJiAweDAwN2ZmZmZmXHJcbiAgICAgICAgcmV0dXJuIGJpdHNcclxuICAgICAgfVxyXG5cclxuICAgICAgLyogSWYgZXhwb25lbnQgdW5kZXJmbG93cyBidXQgbm90IHRvbyBtdWNoLCByZXR1cm4gYSBkZS1ub3JtYWwgKi9cclxuICAgICAgaWYgKGUgPCAxMTMpIHtcclxuICAgICAgICBtIHw9IDB4MDgwMFxyXG4gICAgICAgIC8qIEV4dHJhIHJvdW5kaW5nIG1heSBvdmVyZmxvdyBhbmQgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGV4cG9uZW50XHJcbiAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovXHJcbiAgICAgICAgYml0cyB8PSAobSA+PiAoMTE0IC0gZSkpICsgKChtID4+ICgxMTMgLSBlKSkgJiAxKVxyXG4gICAgICAgIHJldHVybiBiaXRzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKVxyXG4gICAgICAvKiBFeHRyYSByb3VuZGluZy4gQW4gb3ZlcmZsb3cgd2lsbCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgaW5jcmVtZW50XHJcbiAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovXHJcbiAgICAgIGJpdHMgKz0gbSAmIDFcclxuXHJcbiAgICAgIHJldHVybiBiaXRzXHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICB1bml0MTZzW2ldID0gdG9VSW50MTYoaW50MzJWaWV3W2ldKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXQxNnNcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hdGhGdW5jdGlvbnNcclxuZXhwb3J0IHsgVUludDgsIFNJbnQ4LCBTSW50MTYsIFVJbnQxNiwgU0ludDMyLCBVSW50MzIsIEZsb2F0MzIsIE1hdGhGdW5jdGlvbnMgfVxyXG4iLCJpbXBvcnQgeyBVSW50OCwgU0ludDgsIFVJbnQxNiwgU0ludDE2LCBVSW50MzIsIFNJbnQzMiwgRmxvYXQzMiB9IGZyb20gJy4vVXRpbGl0aWVzL01hdGhGdW5jdGlvbnMnXHJcblxyXG5sZXQgX3JlZ2lzdGVyZWRCbHVlcHJpbnRzID0ge31cclxubGV0IF9ibHVlcHJpbnROYW1lcyA9IHt9XHJcbmxldCBfYmx1ZXByaW50cyA9IFtdXHJcblxyXG4vKipcclxuICogUmVnaXN0cnkgaXMgYSBzdGF0aWMgZmFjdG9yeSB0aGF0IGhhbmRsZXMgcmVnaXN0cmF0aW9uL3JlY29uc3RydWN0aW9uIG9mXHJcbiAqIHBlcnNpc3RlZCB0eXBlIG9mIGRhdGEsIHRoaXMgaW5jbHVkZXMgY2xhc3NlcyBhbmQgdHlwZXMuXHJcbiAqXHJcbiAqIE5vdGU6IGJsdWVwcmludE5hbWUgaXMgcmVxdWlyZWQgYmVjYXVzZSBvbiBtaW5pZmljYXRpb24gcHJvY2Vzc1xyXG4gKiB0aGUgbmFtZSBvZiBjbGFzc2VzIGNoYW5nZSBhbmQgd2UgY2FuJ3Qgc2ltcGx5IHVzZSAnLi4uLmNvbnN0cnVjdG9yLm5hbWUnLlxyXG4gKiBTbywgd2UgbmVlZCBhIHdheSBvZiByZWxhdGluZyBtaW5pZmllZCBibHVlcHJpbnQgbmFtZXMgdG8gdGhlIG9uZSBzdG9yZWQgZm9yIHBlcnNpc3RlbmN5LlxyXG4gKiA8YnI+XHJcbiAqIGkuZS5cclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBJbXBvcnQgcmVnaXN0cnkgY2xhc3NcclxuICogY2xhc3MgRm9vKCkge31cclxuICpcclxuICogUmVnaXN0cnkucmVnaXN0ZXIoJ0ZvbycsIEZvbylcclxuICogLy8gSW4gY2FzZSAnRm9vJyBjbGFzcyBnZXRzIGl0cyBuYW1lIGNoYW5nZWQgdG8gJ2MnIG9uIG1pbmlmaWNhdGlvbixcclxuICogLy8gYW5kIHRoZSBwZXJzaXN0ZWQgZGF0YSB0eXBlIGlzICdGb28nLCB3ZSB3b3VsZCBrbm93IGhvdyB0byByZWxhdGUgdGhlbS5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQGNsYXNzIFJlZ2lzdHJ5XHJcbiAqL1xyXG5jb25zdCBSZWdpc3RyeSA9IHtcclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgYSBuZXcgYmx1ZXByaW50IGluIHRoZSBmYWN0b3J5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsdWVwcmludE5hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGJsdWVwcmludChDbGFzcywgdHlwZSwgZXRjKVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVtYmVyfGFueX0gYmx1ZXByaW50IC0gQmx1ZXByaW50IHJlcHJlc2VudGF0aW9uKENsYXNzIGZ1bmN0aW9uLCB0eXBlKVxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyOiAoYmx1ZXByaW50TmFtZSwgYmx1ZXByaW50KSA9PiB7XHJcbiAgICBpZiAoX3JlZ2lzdGVyZWRCbHVlcHJpbnRzW2JsdWVwcmludE5hbWVdKSB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlJ3MgYSBjbGFzcyByZWdpc3RlcmVkIHdpdGggJyR7Ymx1ZXByaW50TmFtZX0nIG5hbWVgKVxyXG4gICAgX3JlZ2lzdGVyZWRCbHVlcHJpbnRzW2JsdWVwcmludE5hbWVdID0geyBibHVlcHJpbnQsIGNhbGxiYWNrczogW10gfVxyXG5cclxuICAgIC8vIE5vdGU6IFRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHNhbWUgYmx1ZXByaW50IGNhbiBiZSBzdG9yZWQgdW5kZXIgbXVsdGlwbGUgbmFtZXMuXHJcbiAgICAvLyBUaGF0cyB0aGUgcmVhc29uIGJlaGluZCB1c2luZyBpbmRleGVzIGluc3RlYWQgb2YgdGhlIGJsdWVwcmludC5cclxuICAgIGNvbnN0IGJsdWVwcmludEluZGV4ID0gX2JsdWVwcmludHMubGVuZ3RoXHJcbiAgICBfYmx1ZXByaW50cy5wdXNoKGJsdWVwcmludClcclxuICAgIF9ibHVlcHJpbnROYW1lc1tibHVlcHJpbnRJbmRleF0gPSBibHVlcHJpbnROYW1lXHJcbiAgfSxcclxuICAvKipcclxuICAgKiBSZXR1cm5zIGJsdWVwcmludCBmdW5jdGlvbi90eXBlIGJ5IHNwZWNpZnlpbmcgaXRzIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmx1ZXByaW50TmFtZSAtIE5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgYmx1ZXByaW50KENsYXNzLCB0eXBlLCBldGMpXHJcbiAgICogQHJldHVybiB7ZnVuY3Rpb258bnVtYmVyfGFueX0gLSBCbHVlcHJpbnQgcmVwcmVzZW50YXRpb24oQ2xhc3MgZnVuY3Rpb24sIHR5cGUpXHJcbiAgICovXHJcbiAgZ2V0Qmx1ZXByaW50OiAoYmx1ZXByaW50TmFtZSkgPT4ge1xyXG4gICAgaWYgKF9yZWdpc3RlcmVkQmx1ZXByaW50c1tibHVlcHJpbnROYW1lXSkgcmV0dXJuIF9yZWdpc3RlcmVkQmx1ZXByaW50c1tibHVlcHJpbnROYW1lXS5ibHVlcHJpbnRcclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Ymx1ZXByaW50TmFtZX0gYmx1ZXByaW50IGlzIG5vdCByZWdpc3RlcmVkYClcclxuICB9LFxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZSB1c2luZyBwYXNzaW5nIGFuIGluc3RhbnRpYXRlZCBvYmplY3QuXHJcbiAgICogSWYgaXQgaXMgbm90IHJlZ2lzdGVyZWQsIHRoZSBuYW1lIGluIGNvbnN0cnVjdG9yIGlzIHJldHVybmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxudW1iZXJ8YW55fHVuZGVmaW5lZH0gYmx1ZXByaW50SW5zdGFuY2UgLSBCbHVlcHJpbnQgcmVwcmVzZW50YXRpb24oQ2xhc3MgZnVuY3Rpb24sIHR5cGUpXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIE5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgYmx1ZXByaW50KENsYXNzLCB0eXBlLCBldGMpXHJcbiAgICovXHJcbiAgZ2V0Qmx1ZXByaW50TmFtZTogKGJsdWVwcmludEluc3RhbmNlKSA9PiB7XHJcbiAgICBsZXQgYmx1ZXByaW50ID0gYmx1ZXByaW50SW5zdGFuY2VcclxuICAgIGxldCBibHVlcHJpbnROYW1lID0gYmx1ZXByaW50SW5zdGFuY2VcclxuXHJcbiAgICBpZiAodHlwZW9mIGJsdWVwcmludEluc3RhbmNlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBibHVlcHJpbnQgPSBibHVlcHJpbnRJbnN0YW5jZS5jb25zdHJ1Y3RvclxyXG4gICAgICBibHVlcHJpbnROYW1lID0gYmx1ZXByaW50Lm5hbWVcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBibHVlcHJpbnRJZCA9IF9ibHVlcHJpbnRzLmluZGV4T2YoYmx1ZXByaW50KVxyXG4gICAgaWYgKGJsdWVwcmludElkID49IDAgJiYgX2JsdWVwcmludE5hbWVzW2JsdWVwcmludElkXSkgcmV0dXJuIF9ibHVlcHJpbnROYW1lc1tibHVlcHJpbnRJZF1cclxuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Ymx1ZXByaW50TmFtZX0gYmx1ZXByaW50IGlzIG5vdCByZWdpc3RlcmVkYClcclxuICB9LFxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdGluZyB0aGUgY2xhc3MgbmFtZSBhbmQgYE5gIG51bWJlciBvZiBhcmd1bWVudHMsIGluc3RhbnRpYXRlcyBhIG5ldyBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBjbGFzcy5cclxuICAgKiBJZiB0aGUgY2xhc3MgaXMgbm90IHJlZ2lzdGVyZWQsIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxyXG4gICAqIDxicj5cclxuICAgKiAqKk5vdGU6KiogQWx0aG91Z2ggdGhlIGNsYXNzIGFyZ3VtZW50cyBhcmUgbm90IGxpdGVyYWxseSBzcGVjaWZpZWQgaW4gdGhlIHBhcmFtZXRlcnMsXHJcbiAgICogeW91IGNhbiBwYXNzIHRoZW0oQXMgbWFueSBhcyBuZWVkZWQpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsdWVwcmludE5hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGJsdWVwcmludChDbGFzcywgdHlwZSwgZXRjKVxyXG4gICAqIEByZXR1cm4ge29iamVjdHxudWxsfSAtIEluc3RhbnRpYXRlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBjbGFzc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdENsYXNzOiAoYmx1ZXByaW50TmFtZSwgLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYmx1ZXByaW50RGF0YSA9IF9yZWdpc3RlcmVkQmx1ZXByaW50c1tibHVlcHJpbnROYW1lXVxyXG4gICAgaWYgKCFibHVlcHJpbnREYXRhKSB0aHJvdyBuZXcgRXJyb3IoYCR7Ymx1ZXByaW50TmFtZX0gYmx1ZXByaW50IGlzIG5vdCByZWdpc3RlcmVkYClcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxyXG4gICAgcmV0dXJuIG5ldyBibHVlcHJpbnREYXRhLmJsdWVwcmludCguLi5hcmdzKVxyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICogRm9yIHRlc3RpbmcgcHVycG9zZSBvbmx5LCBuZXZlciBjYWxsIHRoaXMgb3V0c2lkZSBvZiB0aGUgdGVzdCBzY29wZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZmx1c2g6ICgpID0+IHtcclxuICAgIF9yZWdpc3RlcmVkQmx1ZXByaW50cyA9IHt9XHJcbiAgICBfYmx1ZXByaW50TmFtZXMgPSB7fVxyXG4gICAgX2JsdWVwcmludHMgPSBbXVxyXG4gIH0sXHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdVSW50OCcsIFVJbnQ4KVxyXG5SZWdpc3RyeS5yZWdpc3RlcignU0ludDgnLCBTSW50OClcclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1VJbnQxNicsIFVJbnQxNilcclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1NJbnQxNicsIFNJbnQxNilcclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1VJbnQzMicsIFVJbnQzMilcclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1NJbnQzMicsIFNJbnQzMilcclxuUmVnaXN0cnkucmVnaXN0ZXIoJ0Zsb2F0MzInLCBGbG9hdDMyKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnlcclxuZXhwb3J0IHsgUmVnaXN0cnkgfVxyXG4iLCJpbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudGluZyBhIFZlYzIodHdvLWRpbWVuc2lvbmFsIGZsb2F0aW5nIHBvaW50IHZlY3RvcikuIEEgVmVjMiBpcyBmb3IgcmVwcmVzZW50aW5nIDIgZGltZW5zaW9uYWwgdmFsdWVzLCBzdWNoIGFzIHNjcmVlbiBjb29yZGluYXRlcyBvciBwaXhlbCBjb29yZGluYXRlcyB3aXRoaW4gYW4gaW1hZ2UuXHJcbiAqXHJcbiAqIE1hdGggdHlwZXMgaW50ZXJuYWxseSBzdG9yZSB2YWx1ZXMgaW4ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9IGFuZFxyXG4gKiBleHBvc2UgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhlIGNvbXBvbmVudCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEF0dHJWYWx1ZVxyXG4gKi9cclxuY2xhc3MgVmVjMiBleHRlbmRzIEF0dHJWYWx1ZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIFZlYzIuXHJcbiAgICpcclxuICAgKiBUaGUgdHlwZSBvZiB2YWx1ZXMgb2YgdGhlIGAoeCwgeSlgIGNvb3JkaW5hdGVzIGNhbiBiZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0sXHJcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1VpbnQzMkFycmF5fFVpbnQzMkFycmF5fSxcclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50MzJBcnJheXxJbnQzMkFycmF5fSBhbmRcclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZXMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2lhL09iamV0b3NfZ2xvYmFsZXMvQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJ9LlxyXG4gICAqIDxicj5cclxuICAgKlxyXG4gICAqIGBgYGphdmFzY3JpcHRcclxuICAgKiAgY29uc3QgbXlWZWMyID0gbmV3IFZlYzIoMS4yLCAzLjQpXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBHaXZlbiBhbiBhcnJheSBvZiBmbG9hdHMsIGNyZWF0ZSBhIFZlYzIgdGhhdCB3cmFwcyBzb21lIHBhcnQgb2YgaXQuXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqICBjb25zdCBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg2KVxyXG4gICAqICBmbG9hdEFycmF5WzBdID0gMS4yXHJcbiAgICogIGZsb2F0QXJyYXlbMV0gPSAzLjRcclxuICAgKiAgY29uc3QgbXlWZWMyID0gbmV3IFZlYzIoZmxvYXRBcnJheSlcclxuICAgKiAgY29uc29sZS5sb2cobXlWZWMyLnRvSlNPTigpKVxyXG4gICAqIGBgYFxyXG4gICAqIFRoZSByZXN1bHRpbmcgb3V0cHV0XHJcbiAgICogYGBganNvblxyXG4gICAqICA+IHsgeDoxLjIsIHk6My40IH1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cywgY3JlYXRlIGEgVmVjMiB0aGF0IHdyYXBzIHNvbWUgcGFydCBvZiBpdC5cclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDYpXHJcbiAgICogIGZsb2F0QXJyYXlbMF0gPSAxLjJcclxuICAgKiAgZmxvYXRBcnJheVsxXSA9IDMuNFxyXG4gICAqICBmbG9hdEFycmF5WzJdID0gNS42XHJcbiAgICogIGZsb2F0QXJyYXlbM10gPSA3LjhcclxuICAgKiAgZmxvYXRBcnJheVs0XSA9IDkuMFxyXG4gICAqICBmbG9hdEFycmF5WzVdID0gMS45XHJcbiAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKGZsb2F0QXJyYXkuYnVmZmVyLCA4KVxyXG4gICAqICBjb25zb2xlLmxvZyhteVZlYzIudG9KU09OKCkpXHJcbiAgICogYGBgXHJcbiAgICogVGhlIHJlc3VsdGluZyBvdXRwdXRcclxuICAgKiBgYGBqc29uXHJcbiAgICogID4geyB4OjUuNiwgeTo3LjggfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogWW91IGNhbiBhbHNvIHBhc3Mgb25lIEpTT04gb2JqZWN0IHBhcmFtZXRlci5cclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKHsgeDoxLjIsIHk6My40IH0pXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcnxGbG9hdDMyQXJyYXl8VWludDMyQXJyYXl8anNvbn0geCAtIFRoZSB4IHZhbHVlLiBEZWZhdWx0IGlzIDAuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IHhcclxuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYClcclxuICAgICAgY29uc3QgYnVmZmVyID0geFxyXG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0geVxyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAyKVxyXG4gICAgfSBlbHNlIGlmICh4ICE9IG51bGwgJiYgdHlwZW9mIHggPT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDIpXHJcbiAgICAgIHRoaXMuZnJvbUpTT04oeClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgyKVxyXG4gICAgICB0aGlzLl9fZGF0YVswXSA9IHhcclxuICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGB4YCBjb21wb25lbnQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHggY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIGdldCB4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIGB4YCBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHgodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgeWAgY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IGNvbXBvbmVudC5cclxuICAgKi9cclxuICBnZXQgeSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBgeWAgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB5KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAtIFRoZSB5IGNvbXBvbmVudC5cclxuICAgKi9cclxuICBzZXQoeCwgeSkge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSB4XHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IHlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIHRoaXMgVmVjMiBkYXRhIHdpdGggdGhlIFZlYzIgZGF0YSBwYXNzZWQgYXMgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHNldCBmcm9tLlxyXG4gICAqL1xyXG4gIHNldEZyb21PdGhlcihvdGhlcikge1xyXG4gICAgdGhpcy54ID0gb3RoZXIueFxyXG4gICAgdGhpcy55ID0gb3RoZXIueVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGFub3RoZXIgVmVjMi5cclxuICAgKlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIGFyZSB0aGUgc2FtZSBWZWN0b3IsIG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgKi9cclxuICBlcXVhbChvdGhlcikge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI2lzRXF1YWwgaW5zdGVhZC4nKVxyXG4gICAgcmV0dXJuIHRoaXMuaXNFcXVhbChvdGhlcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBhbm90aGVyIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgYXJlIHRoZSBzYW1lIFZlY3Rvciwgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGlzRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnggPT0gb3RoZXIueCAmJiB0aGlzLnkgPT0gb3RoZXIueVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuXHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgVmVjMnMgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI25vdEVxdWFsIGluc3RlYWQuJylcclxuICAgIHJldHVybiB0aGlzLm5vdEVxdWFsKG90aGVyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFZlYzJzIGFyZSBkaWZmZXJlbnQsIG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgKi9cclxuICBub3RFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBWZWMyIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHByZWNpc2lvbiAmJiBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGFkZC5cclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi5cclxuICAgKi9cclxuICBhZGQob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIFZlYzIgdG8gdGhpcyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGFkZC5cclxuICAgKi9cclxuICBhZGRJblBsYWNlKG90aGVyKSB7XHJcbiAgICB0aGlzLnggKz0gb3RoZXIueFxyXG4gICAgdGhpcy55ICs9IG90aGVyLnlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnRyYWN0cyBhIFZlYzIgZnJvbSB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHN1YnRyYWN0LlxyXG4gICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLlxyXG4gICAqL1xyXG4gIHN1YnRyYWN0KG90aGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54IC0gb3RoZXIueCwgdGhpcy55IC0gb3RoZXIueSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnRyYWN0cyBhIFZlYzIgZnJvbSB0aGlzIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gc3VidHJhY3QuXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICovXHJcbiAgc3VidHJhY3RJblBsYWNlKG90aGVyKSB7XHJcbiAgICB0aGlzLnggLT0gb3RoZXIueFxyXG4gICAgdGhpcy55IC09IG90aGVyLnlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgdGhpcyBWZWMyIGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi5cclxuICAgKi9cclxuICBzY2FsZShzY2FsYXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjYWxlcyB0aGlzIFZlYzIgYnkgc2NhbGFyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICovXHJcbiAgc2NhbGVJblBsYWNlKHNjYWxhcikge1xyXG4gICAgdGhpcy54ICo9IHNjYWxhclxyXG4gICAgdGhpcy55ICo9IHNjYWxhclxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52ZXJ0cyB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICovXHJcbiAgaW52ZXJ0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKDEuMCAvIHRoaXMueCwgMS4wIC8gdGhpcy55KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52ZXJ0cyB0aGlzIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgaW52ZXJ0SW5QbGFjZSgpIHtcclxuICAgIHRoaXMueCA9IDEuMCAvIHRoaXMueFxyXG4gICAgdGhpcy55ID0gMS4wIC8gdGhpcy55XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyBhIFZlYzIgd2l0aCB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIG11bHRpcGx5IHdpdGguXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICovXHJcbiAgbXVsdGlwbHkob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggKiBvdGhlci54LCB0aGlzLnkgKiBvdGhlci55KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyBhIFZlYzIgd2l0aCB0aGlzIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gbXVsdGlwbHkgd2l0aC5cclxuICAgKi9cclxuICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHtcclxuICAgIHRoaXMueCAqPSBvdGhlci54XHJcbiAgICB0aGlzLnkgKj0gb3RoZXIueVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyBWZWMyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aCBzcXVhcmVkLlxyXG4gICAqL1xyXG4gIGxlbmd0aFNxdWFyZWQoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF1cclxuICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXVxyXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFZlYzIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbGVuZ3RoLlxyXG4gICAqL1xyXG4gIGxlbmd0aCgpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0byBhbm90aGVyIHZlY3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgdmFsdWUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9ycy5cclxuICAgKi9cclxuICBkaXN0YW5jZVRvKG90aGVyKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF0gLSBvdGhlci54XHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV0gLSBvdGhlci55XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVzIHRoZSBWZWMyIGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFZlYzIuXHJcbiAgICogTXVsdGlwbGllcyBjb29yZGVuYXRlcyB2YWx1ZSBieSB0aGUgaW52ZXJzZSBvZiB0aGUgdmVjdG9yIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyB0aGUgVmVjMiBub3JtYWxpemVkLlxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZSgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeVxyXG4gICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjMigpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XHJcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcclxuICAgIHJldHVybiBuZXcgVmVjMih4ICogbGVuLCB5ICogbGVuKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplcyB0aGlzIFZlYzIgbXVsdGlwbHlpbmcgY29vcmRlbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguXHJcbiAgICovXHJcbiAgbm9ybWFsaXplSW5QbGFjZSgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeVxyXG4gICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXHJcbiAgICB0aGlzLnNldCh4ICogbGVuLCB5ICogbGVuKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyBWZWMyIGFnYWluc3QgYW5vdGhlciBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuXHJcbiAgICovXHJcbiAgZG90KG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyBWZWMyIGFnYWluc3QgYW5vdGhlciBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICAgKi9cclxuICBjcm9zcyhvdGhlcikge1xyXG4gICAgLy8ganVzdCBjYWxjdWxhdGUgdGhlIHotY29tcG9uZW50XHJcbiAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueSAtIHRoaXMueSAqIG90aGVyLnhcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBWZWMyIGFuZCBvdGhlciBhc3N1bWluZyBib3RoIGFyZSBub3JtYWxpemVkIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqL1xyXG4gIGFuZ2xlVG8ob3RoZXIpIHtcclxuICAgIGNvbnN0IGNvc2luZSA9IHRoaXMubm9ybWFsaXplKCkuZG90KG90aGVyLm5vcm1hbGl6ZSgpKVxyXG4gICAgaWYgKGNvc2luZSA+IDEuMCkgcmV0dXJuIDAuMFxyXG4gICAgZWxzZSBpZiAoY29zaW5lIDwgLTEuMCkgcmV0dXJuIE1hdGguUElcclxuICAgIGVsc2UgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjMiBhbmQgb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzJ9IG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqL1xyXG4gIHNpZ25lZEFuZ2xlVG8ob3RoZXIpIHtcclxuICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5hbmdsZVRvKG90aGVyKVxyXG4gICAgaWYgKHRoaXMuY3Jvc3Mob3RoZXIpIDwgMC4wKSByZXR1cm4gLWFuZ2xlXHJcbiAgICBlbHNlIHJldHVybiBhbmdsZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUm90YXRlcyBhIFZlYzIgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IHJvdGF0ZWQgVmVjMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdCAgb3IuXHJcbiAgICovXHJcbiAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICBjb25zdCBjb3NhID0gTWF0aC5jb3MoYW5nbGUpXHJcbiAgICBjb25zdCBzaW5hID0gTWF0aC5zaW4oYW5nbGUpXHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICogY29zYSAtIHRoaXMueSAqIHNpbmEsIHRoaXMueCAqIHNpbmEgKyB0aGlzLnkgKiBjb3NhKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgVmVjMiBhbmQgb3RoZXIgVmVjMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjMn0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy5cclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi5cclxuICAgKi9cclxuICBsZXJwKG90aGVyLCB0KSB7XHJcbiAgICBjb25zdCBheCA9IHRoaXMueFxyXG4gICAgY29uc3QgYXkgPSB0aGlzLnlcclxuICAgIHJldHVybiBuZXcgVmVjMihheCArIHQgKiAob3RoZXIueCAtIGF4KSwgYXkgKyB0ICogKG90aGVyLnkgLSBheSkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAqIEByZXR1cm4ge1ZlYzJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRSYW5kb21EaXIoc2NhbGUgPSAxLjApIHtcclxuICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJhbmRvbWl6ZXMgdGhlIHNjYWxlIG9mIHRoaXMgVmVjMiBjb29yZGVuYXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0UmFuZG9tKHNjYWxlID0gMS4wKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IE1hdGgucmFuZG9tKCkgKiBzY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBNYXRoLnJhbmRvbSgpICogc2NhbGVcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBWZWMyIGFuZCByZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgYSBuZXcgVmVjMi5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgVmVjMiBkYXRhIGFzIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYW4gYXJyYXkuXHJcbiAgICovXHJcbiAgYXNBcnJheSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgVmVjMi5cclxuICAgKiBAc2VlIGBuZXcgVmVjMmBcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMiguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBWZWMyIHRvIHdyYXAgZXhpc3RpbmcgbWVtb3J5IGluIGEgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihidWZmZXIsIG9mZnNldCA9IDApIHtcclxuICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZCwgdXNlICNjcmVhdGVGcm9tQnVmZmVyIGluc3RlYWQnKVxyXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIG9mZnNldCAqIDQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgYFZlYzJgIHVzaW5nIGFuIEFycmF5QnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBidWZmZXIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIG5ldyBWZWMyLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAyKSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjcmVhdGVGcm9tRmxvYXQzMkFycmF5IG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgbmV3IFZlYzIuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJBcnJheShhcnJheSkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMyKGFycmF5KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIEZsb2F0MzIgZWxlbWVudHMgdXNlZCBieSB0aGlzIHR5cGUuIFVzZWQgdG8gY2FsY3VsYXRlIHN0b3JhZ2UgcmVxdWlcclxuICAgKiBlbnRzIGZvciBsYXJnZSBhcnJheXMgb2YgdGhpcyB0eXBlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIG51bUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIDJcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIEVuY29kZXMgVmVjMiBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogdGhpcy54LFxyXG4gICAgICB5OiB0aGlzLnksXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaikge1xyXG4gICAgdGhpcy54ID0gai54XHJcbiAgICB0aGlzLnkgPSBqLnlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS5cclxuICAgKi9cclxuICByZWFkQmluYXJ5KHJlYWRlcikge1xyXG4gICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignVmVjMicsIFZlYzIpXHJcblxyXG5leHBvcnQgeyBWZWMyIH1cclxuIiwiaW1wb3J0IHsgQXR0clZhbHVlIH0gZnJvbSAnLi9BdHRyVmFsdWUuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuaW1wb3J0IHsgVmVjMiB9IGZyb20gJy4vVmVjMi5qcydcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgdGhyZWUgZGltZW5zaW9uYWwgY29vcmRpbmF0ZSwgc3VjaCBhcyAzRCBzY2VuZSB2YWx1ZXMsIG9yIG1lc2ggdmVydGV4IHBvc2l0aW9ucy5cclxuICpcclxuICogTWF0aCB0eXBlcyBpbnRlcm5hbGx5IHN0b3JlIHZhbHVlcyBpbiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0gYW5kXHJcbiAqIGV4cG9zZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciB0aGUgY29tcG9uZW50IHZhbHVlcy5cclxuICpcclxuICogQGV4dGVuZHMgQXR0clZhbHVlXHJcbiAqL1xyXG5jbGFzcyBWZWMzIGV4dGVuZHMgQXR0clZhbHVlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgVmVjMy5cclxuICAgKlxyXG4gICAqIFRoZSB0eXBlIG9mIHZhbHVlcyBvZiB0aGUgYCh4LCB5LCB6KWAgY29vcmRlbmF0ZXMgY2FuIGJlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSxcclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVWludDMyQXJyYXl8VWludDMyQXJyYXl9LFxyXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnQzMkFycmF5fEludDMyQXJyYXl9IGFuZFxyXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lcy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9BcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlcn0uXHJcbiAgICogPGJyPlxyXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIG9uZSBKU09OIG9iamVjdCBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcnxGbG9hdDMyQXJyYXl8anNvbn0geCAtIFRoZSB4IHZhbHVlLiBEZWZhdWx0IGlzIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHogdmFsdWUuIERlZmF1bHQgaXMgMC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSB4XHJcbiAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDMpKWApXHJcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHhcclxuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHlcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgMylcclxuICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsICYmIHR5cGVvZiB4ID09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgzKVxyXG4gICAgICB0aGlzLmZyb21KU09OKHgpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMylcclxuICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4XHJcbiAgICAgIHRoaXMuX19kYXRhWzFdID0geVxyXG4gICAgICB0aGlzLl9fZGF0YVsyXSA9IHpcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYHhgIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB4IGNvbXBvbmVudC5cclxuICAgKi9cclxuICBnZXQgeCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVswXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBgeGAgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHgodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgeWAgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHkgY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIGdldCB5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIGB5YCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgeSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzFdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGB6YCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeiBjb21wb25lbnQuXHJcbiAgICovXHJcbiAgZ2V0IHooKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYHpgIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB6KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYHh5YCBzd2l6emVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudC5cclxuICAgKi9cclxuICBnZXQgeHkoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgeXpgIHN3aXp6ZWwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMyfSAtIFJldHVybnMgdGhlIHogY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIGdldCB5eigpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMih0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIHkgY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIHNldCh4LCB5LCB6KSB7XHJcbiAgICB0aGlzLnggPSB4XHJcbiAgICB0aGlzLnkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogeFxyXG4gICAgdGhpcy56ID0geiAhPT0gdW5kZWZpbmVkID8geiA6IHhcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHN0YXRlIG9mIGEgVmVjMyBPYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZmxvYXQzMkFycmF5IC0gVGhlIGZsb2F0MzJBcnJheSB2YWx1ZS5cclxuICAgKi9cclxuICBzZXREYXRhQXJyYXkoZmxvYXQzMkFycmF5KSB7XHJcbiAgICB0aGlzLl9fZGF0YSA9IGZsb2F0MzJBcnJheVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgYSBWZWMzIE9iamVjdCBmcm9tIGFub3RoZXIgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBzZXQgZnJvbS5cclxuICAgKi9cclxuICBzZXRGcm9tT3RoZXIob3RoZXIpIHtcclxuICAgIHRoaXMueCA9IG90aGVyLnhcclxuICAgIHRoaXMueSA9IG90aGVyLnlcclxuICAgIHRoaXMueiA9IG90aGVyLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGUgY29vcmRlbmF0ZXMgb2YgdGhpcyBWZWMzIGFyZSAwIDAgMC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvb3JkZW5hdGVzIGFyZSgwLCAwLCAwKSwgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGlzTnVsbCgpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpIDwgTnVtYmVyLkVQU0lMT04gJiYgTWF0aC5hYnModGhpcy55KSA8IE51bWJlci5FUFNJTE9OICYmIE1hdGguYWJzKHRoaXMueikgPCBOdW1iZXIuRVBTSUxPTlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBjb29yZGVuYXRlcyBvZiB0aGlzIFZlYzMgYXJlIDEgMSAxLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29vcmRlbmF0ZXMgYXJlKDEsIDEsIDEpLCBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgaXMxMTEoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBNYXRoLmFicygxLjAgLSB0aGlzLngpIDwgTnVtYmVyLkVQU0lMT04gJiZcclxuICAgICAgTWF0aC5hYnMoMS4wIC0gdGhpcy55KSA8IE51bWJlci5FUFNJTE9OICYmXHJcbiAgICAgIE1hdGguYWJzKDEuMCAtIHRoaXMueikgPCBOdW1iZXIuRVBTSUxPTlxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBDaGVja3MgaWYgdGhpcyBWZWMzIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgYW5vdGhlciBWZWMzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIGFyZSB0aGUgc2FtZSBWZWN0b3IsIG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgKi9cclxuICBlcXVhbChvdGhlcikge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI2lzRXF1YWwgaW5zdGVhZC4nKVxyXG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKG90aGVyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMyBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGFub3RoZXIgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiBhcmUgdGhlIHNhbWUgVmVjdG9yLCBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMueCA9PSBvdGhlci54ICYmIHRoaXMueSA9PSBvdGhlci55ICYmIHRoaXMueiA9PSBvdGhlci56XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWMyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBWZWMzcyBhcmUgZGlmZmVyZW50LCBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVzZSAjbm90RXF1YWwgaW5zdGVhZC4nKVxyXG4gICAgcmV0dXJuIHRoaXMubm90RXF1YWwob3RoZXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhpcyBWZWMyIGlzIGRpZmZlcmVudCBmcm9tIGFub3RoZXIgVmVjMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgVmVjM3MgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlLCBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIG5vdEVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ICE9IG90aGVyLnggJiYgdGhpcy55ICE9IG90aGVyLnkgJiYgdGhpcy56ICE9IG90aGVyLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzIgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiZcclxuICAgICAgTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCBwcmVjaXNpb24gJiZcclxuICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb25cclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMzIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGFkZC5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICBhZGQob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55LCB0aGlzLnogKyBvdGhlci56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gYWRkLlxyXG4gICAqL1xyXG4gIGFkZEluUGxhY2Uob3RoZXIpIHtcclxuICAgIHRoaXMueCArPSBvdGhlci54XHJcbiAgICB0aGlzLnkgKz0gb3RoZXIueVxyXG4gICAgdGhpcy56ICs9IG90aGVyLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjMyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gc3VidHJhY3QuXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgc3VidHJhY3Qob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWMzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIHN1YnRyYWN0LlxyXG4gICAqL1xyXG4gIHN1YnRyYWN0SW5QbGFjZShvdGhlcikge1xyXG4gICAgdGhpcy54IC09IG90aGVyLnhcclxuICAgIHRoaXMueSAtPSBvdGhlci55XHJcbiAgICB0aGlzLnogLT0gb3RoZXIuelxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0d28gVmVjM3MgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIG11bHRpcGx5IHdpdGguXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgbXVsdGlwbHkob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKiBvdGhlci54LCB0aGlzLnkgKiBvdGhlci55LCB0aGlzLnogKiBvdGhlci56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0d28gVmVjM3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gbXVsdGlwbHkgd2l0aC5cclxuICAgKi9cclxuICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHtcclxuICAgIHRoaXMueCAqPSBvdGhlci54XHJcbiAgICB0aGlzLnkgKj0gb3RoZXIueVxyXG4gICAgdGhpcy56ICo9IG90aGVyLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpdmlkZXMgdHdvIFZlYzNzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSBvdGhlciBWZWMzIHRvIGRpdmlkZSBieS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICBkaXZpZGUodmVjMykge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCAvIHZlYzMueCwgdGhpcy55IC8gdmVjMy55LCB0aGlzLnogLyB2ZWMzLnopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXZpZGVzIHR3byBWZWMzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSBvdGhlciBWZWMzIHRvIGRpdmlkZSBieS5cclxuICAgKi9cclxuICBkaXZpZGVJblBsYWNlKHZlYzMpIHtcclxuICAgIHRoaXMueCAvPSB2ZWMzLnhcclxuICAgIHRoaXMueSAvPSB2ZWMzLnlcclxuICAgIHRoaXMueiAvPSB2ZWMzLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjYWxlcyB0aGlzIFZlYzMgYnkgc2NhbGFyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLlxyXG4gICAqL1xyXG4gIHNjYWxlKHNjYWxhcikge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgdGhpcyBWZWMzIGJ5IHNjYWxhci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNjYWxlSW5QbGFjZShzY2FsYXIpIHtcclxuICAgIHRoaXMueCAqPSBzY2FsYXJcclxuICAgIHRoaXMueSAqPSBzY2FsYXJcclxuICAgIHRoaXMueiAqPSBzY2FsYXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5lZ2F0ZXMgdGhpcyBWZWMzICh4ID0gLXgsIHkgPSAteSBhbmQgeiA9IC16KSwgYnV0IHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgbmVnYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKC10aGlzLngsIC10aGlzLnksIC10aGlzLnopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoaXMgVmVjMywgYnV0IHJldHVybnMuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjM1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgaW52ZXJzZSgpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMygxLjAgLyB0aGlzLngsIDEuMCAvIHRoaXMueSwgMS4wIC8gdGhpcy56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyBWZWMzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aC5cclxuICAgKi9cclxuICBsZW5ndGhTcXVhcmVkKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogelxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgVmVjMy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguXHJcbiAgICovXHJcbiAgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHZlY3RvcnMuXHJcbiAgICovXHJcbiAgZGlzdGFuY2VUbyhvdGhlcikge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdIC0gb3RoZXIueFxyXG4gICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdIC0gb3RoZXIueVxyXG4gICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdIC0gb3RoZXIuelxyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVzIHRoZSBWZWMzIGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFZlYzMuXHJcbiAgICogTXVsdGlwbGllcyBjb29yZGVuYXRlcyB2YWx1ZSBieSB0aGUgaW52ZXJzZSBvZiB0aGUgdmVjdG9yIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgVmVjMyBub3JtYWxpemVkLlxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZSgpIHtcclxuICAgIGxldCBsZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl1cclxuICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgICByZXR1cm4gbmV3IFZlYzMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xyXG4gICAgbGVuID0gMS4wIC8gTWF0aC5zcXJ0KGxlbilcclxuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLl9fZGF0YVswXSAqIGxlbiwgdGhpcy5fX2RhdGFbMV0gKiBsZW4sIHRoaXMuX19kYXRhWzJdICogbGVuKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplcyB0aGlzIFZlYzMgbXVsdGlwbHlpbmcgY29vcmRlbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBub3JtYWxpemVJblBsYWNlKCkge1xyXG4gICAgbGV0IGxlbiA9IHRoaXMuX19kYXRhWzBdICogdGhpcy5fX2RhdGFbMF0gKyB0aGlzLl9fZGF0YVsxXSAqIHRoaXMuX19kYXRhWzFdICsgdGhpcy5fX2RhdGFbMl0gKiB0aGlzLl9fZGF0YVsyXVxyXG4gICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgbGVuID0gTWF0aC5zcXJ0KGxlbilcclxuICAgIGNvbnN0IHRtcCA9IDEuMCAvIGxlblxyXG4gICAgdGhpcy5fX2RhdGFbMF0gKj0gdG1wXHJcbiAgICB0aGlzLl9fZGF0YVsxXSAqPSB0bXBcclxuICAgIHRoaXMuX19kYXRhWzJdICo9IHRtcFxyXG5cclxuICAgIHJldHVybiBsZW5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgVmVjMyB3aXRoIHRoZSBuZXcgY29vcmRlbmF0ZXMoY2FsY3VsYXRlZCB3aXRoIHRoaXMgVmVjMyBjb29yZGVuYXRlcyBhbmQgdGhlIHNwZWNpZmllZCBsZW5ndGgpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGggdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlc2l6ZShsZW5ndGgpIHtcclxuICAgIGNvbnN0IGN1cnJsZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl1cclxuICAgIGlmIChjdXJybGVuIDwgTnVtYmVyLkVQU0lMT04pIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBjb25zdCBzY2wgPSBsZW5ndGggLyBNYXRoLnNxcnQoY3VycmxlbilcclxuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLl9fZGF0YVswXSAqIHNjbCwgdGhpcy5fX2RhdGFbMV0gKiBzY2wsIHRoaXMuX19kYXRhWzJdICogc2NsKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW9kaWZpZXMgY3VycmVudCBjb29yZGVuYXRlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoIHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlc2l6ZUluUGxhY2UobGVuZ3RoKSB7XHJcbiAgICBjb25zdCBjdXJybGVuID0gdGhpcy5fX2RhdGFbMF0gKiB0aGlzLl9fZGF0YVswXSArIHRoaXMuX19kYXRhWzFdICogdGhpcy5fX2RhdGFbMV0gKyB0aGlzLl9fZGF0YVsyXSAqIHRoaXMuX19kYXRhWzJdXHJcbiAgICBpZiAoY3VycmxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2NsID0gbGVuZ3RoIC8gTWF0aC5zcXJ0KGN1cnJsZW4pXHJcbiAgICB0aGlzLl9fZGF0YVswXSAqPSBzY2xcclxuICAgIHRoaXMuX19kYXRhWzFdICo9IHNjbFxyXG4gICAgdGhpcy5fX2RhdGFbMl0gKj0gc2NsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzMgYWdhaW5zdCBhbm90aGVyIFZlYzMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdC5cclxuICAgKi9cclxuICBkb3Qob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlYzNzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjYWxjdWxhdGUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3QgYXMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICBjcm9zcyhvdGhlcikge1xyXG4gICAgY29uc3QgYXggPSB0aGlzLnhcclxuICAgIGNvbnN0IGF5ID0gdGhpcy55XHJcbiAgICBjb25zdCBheiA9IHRoaXMuelxyXG4gICAgY29uc3QgYnggPSBvdGhlci54XHJcbiAgICBjb25zdCBieSA9IG90aGVyLnlcclxuICAgIGNvbnN0IGJ6ID0gb3RoZXIuelxyXG5cclxuICAgIHJldHVybiBuZXcgVmVjMyhheSAqIGJ6IC0gYXogKiBieSwgYXogKiBieCAtIGF4ICogYnosIGF4ICogYnkgLSBheSAqIGJ4KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIFZlYzMgYW5kIGIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqL1xyXG4gIGFuZ2xlVG8ob3RoZXIpIHtcclxuICAgIGNvbnN0IGNvc2luZSA9IHRoaXMuZG90KG90aGVyKVxyXG4gICAgaWYgKGNvc2luZSA+IDEuMCkge1xyXG4gICAgICByZXR1cm4gMFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBWZWMzIGFuZCBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICBsZXJwKG90aGVyLCB0KSB7XHJcbiAgICBjb25zdCBheCA9IHRoaXMueFxyXG4gICAgY29uc3QgYXkgPSB0aGlzLnlcclxuICAgIGNvbnN0IGF6ID0gdGhpcy56XHJcbiAgICByZXR1cm4gbmV3IFZlYzMoYXggKyB0ICogKG90aGVyLnggLSBheCksIGF5ICsgdCAqIChvdGhlci55IC0gYXkpLCBheiArIHQgKiAob3RoZXIueiAtIGF6KSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBuZXcgVmVjMyB3aG9zZSBjb21wb25lbnQgdmFsdWVzIGFyZSB0aGUgYWJzIG9mIHRoaXMgVmVjM3MgY29tcG9uZW50IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLlxyXG4gICAqL1xyXG4gIGFicygpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMyhNYXRoLmFicyh0aGlzLngpLCBNYXRoLmFicyh0aGlzLnkpLCBNYXRoLmFicyh0aGlzLnopKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmVjdG9yIGEgcmFuZG9tIHZlY3RvciBvbiB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZSB3aXRoIHRoZSByYWRpdXMgb2YgdGhlIGdpdmVubiBzY2FsZSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSByYWRpdXMgb2YgdGhlIHN1cmZhY2Ugc3BoZXJlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gVGhlIHJhbmRvbSBWZWMzLlxyXG4gICAqL1xyXG4gIHNldFJhbmRvbURpcihzY2FsZSA9IDEuMCkge1xyXG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXHJcbiAgICBjb25zdCB6ID0gTWF0aC5yYW5kb20oKSAqIDIuMCAtIDEuMFxyXG4gICAgY29uc3QgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlXHJcblxyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB6ICogc2NhbGVcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSByYW5kb21lIHZlY3RvciBhbnl3aGVyZSBpbiB0aGUgc3BoZXJlIGRlZmluZWQgYnkgdGhlIHByb3ZpZGVkIHNjYWxlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHJhZGl1cyBvZiB0aGUgYm91bmRpbmcgc3BoZXJlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gVGhlIHJhbmRvbSBWZWMzLlxyXG4gICAqL1xyXG4gIHNldFJhbmRvbShzY2FsZSA9IDEuMCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBzY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBzY2FsZVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBzY2FsZVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIFZlYzMgYW5kIHJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIGFzIGFuIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFJldHVybnMgYXMgYW4gYXJyYXkuXHJcbiAgICovXHJcbiAgYXNBcnJheSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgVmVjMyguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNyZWF0ZUZyb21KU09OIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge29iamVjdH0ganNvbiAtIFRoZSBqc29uIHBhcmFtLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tSlNPTihqc29uKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjMygpXHJcbiAgICByZXN1bHQuZnJvbUpTT04oanNvbilcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlciBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpXHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgVmVjM2AgdXNpbmcgYW4gQXJyYXlCdWZmZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDMpKSAvLyA0IGJ5dGVzIHBlciAzMmJpdCBmbG9hdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNyZWF0ZUZyb21GbG9hdDMyQXJyYXkgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSAtIEEgRmxvYXQzMkFycmF5IHZhbHVlXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIGEgbmV3IFZlYzMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJBcnJheShhcnJheSkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKGFycmF5KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIEZsb2F0MzIgZWxlbWVudHMgdXNlZCBieSB0aGlzIHR5cGUuIFVzZWQgdG8gY2FsY3VsYXRlIHN0b3JhZ2UgcmVxdWlyZW1lbnRzIGZvciBsYXJnZSBhcnJheXMgb2YgdGhpcyB0eXBlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIG51bUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIDNcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIEVuY29kZXMgVmVjMyBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogdGhpcy54LFxyXG4gICAgICB5OiB0aGlzLnksXHJcbiAgICAgIHo6IHRoaXMueixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29kZXMgYSBKU09OIG9iamVjdCB0byBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICBmcm9tSlNPTihqKSB7XHJcbiAgICB0aGlzLnggPSBqLnhcclxuICAgIHRoaXMueSA9IGoueVxyXG4gICAgdGhpcy56ID0gai56XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIpIHtcclxuICAgIHRoaXMueCA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKVxyXG4gICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdWZWMzJywgVmVjMylcclxuXHJcbmV4cG9ydCB7IFZlYzMgfVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXHJcbmltcG9ydCB7IEF0dHJWYWx1ZSB9IGZyb20gJy4vQXR0clZhbHVlLmpzJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgZm91ci1kaW1lbnNpb25hbCBjb29yZGluYXRlLlxyXG4gKiBNYXRoIHR5cGVzIGludGVybmFsbHkgc3RvcmUgdmFsdWVzIGluIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSBhbmRcclxuICogZXhwb3NlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIHRoZSBjb21wb25lbnQgdmFsdWVzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyVmFsdWVcclxuICovXHJcbmNsYXNzIFZlYzQgZXh0ZW5kcyBBdHRyVmFsdWUge1xyXG4gIC8qKlxyXG4gICAvKipcclxuICAgKiBDcmVhdGVzIGEgVmVjNC5cclxuICAgKlxyXG4gICAqIFRoZSB0eXBlIG9mIHZhbHVlcyBvZiB0aGUgYCh4LCB5LCB6LCB0KWAgY29vcmRpbmF0ZXMgY2FuIGJlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSxcclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVWludDMyQXJyYXl8VWludDMyQXJyYXl9LFxyXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnQzMkFycmF5fEludDMyQXJyYXl9IGFuZFxyXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lcy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9BcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlcn0uXHJcbiAgICogPGJyPlxyXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIG9uZSBKU09OIG9iamVjdCBwYXJhbWV0ZXIuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ8RmxvYXQzMkFycmF5fGpzb259IHggLSBUaGUgeCB2YWx1ZS4gRGVmYXVsdCBpcyAwLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgdmFsdWUuIERlZmF1bHQgaXMgMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSB5IHZhbHVlLiBEZWZhdWx0IGlzIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgLSBUaGUgdCB2YWx1ZS4gRGVmYXVsdCBpcyAwLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHQgPSAwKSB7XHJcbiAgICBzdXBlcigpXHJcblxyXG4gICAgaWYgKHggaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgeCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0geFxyXG4gICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG5ldyBWZWM0KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KSlgKVxyXG4gICAgICBjb25zdCBidWZmZXIgPSB4XHJcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5XHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpXHJcbiAgICB9IGVsc2UgaWYgKHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNClcclxuICAgICAgdGhpcy5mcm9tSlNPTih4KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpXHJcbiAgICAgIHRoaXMuX19kYXRhWzBdID0geFxyXG4gICAgICB0aGlzLl9fZGF0YVsxXSA9IHlcclxuICAgICAgdGhpcy5fX2RhdGFbMl0gPSB6XHJcbiAgICAgIHRoaXMuX19kYXRhWzNdID0gdFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgeGAgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeCB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgeCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVswXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBgeGAgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgeCh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzBdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGB5YCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCB5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIGB5YCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB5KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYHpgIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgZ2V0IHooKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYHpgIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHoodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgdGAgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBnZXQgdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVszXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBgdGAgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgdCh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzNdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGB4eWAgc3dpenplbC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB6IHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCB4eXooKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgLSBUaGUgeSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geiAgLSBUaGUgeSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdCAgLSBUaGUgdCB2YWx1ZS5cclxuICAgKi9cclxuICBzZXQoeCwgeSwgeiwgdCkge1xyXG4gICAgdGhpcy54ID0geFxyXG4gICAgdGhpcy55ID0geVxyXG4gICAgdGhpcy56ID0gelxyXG4gICAgdGhpcy50ID0gdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgYSBWZWM0IE9iamVjdCBmcm9tIGFub3RoZXIgVmVjNC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzZXQgZnJvbS5cclxuICAgKi9cclxuICBzZXRGcm9tT3RoZXIob3RoZXIpIHtcclxuICAgIHRoaXMueCA9IG90aGVyLnhcclxuICAgIHRoaXMueSA9IG90aGVyLnlcclxuICAgIHRoaXMueiA9IG90aGVyLnpcclxuICAgIHRoaXMudCA9IG90aGVyLnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBhbm90aGVyIFZlYzQuXHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuXHJcbiAgICovXHJcbiAgZXF1YWwob3RoZXIpIHtcclxuICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNpc0VxdWFsIGluc3RlYWQuJylcclxuICAgIHJldHVybiB0aGlzLmlzRXF1YWwob3RoZXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhpcyBWZWM0IGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgYW5vdGhlciBWZWM0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnogJiYgdGhpcy50ID09IG90aGVyLnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWM0LlxyXG4gICAqXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI25vdEVxdWFsIGluc3RlYWQuJylcclxuICAgIHJldHVybiB0aGlzLm5vdEVxdWFsKG90aGVyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjNCBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIG5vdEVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ICE9IG90aGVyLnggJiYgdGhpcy55ICE9IG90aGVyLnkgJiYgdGhpcy56ICE9IG90aGVyLnogJiYgdGhpcy50ICE9IG90aGVyLnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzQgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueiAtIG90aGVyLnopIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMudCAtIG90aGVyLnQpIDwgcHJlY2lzaW9uXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgVmVjNCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyBhIG5ldyBWZWM0LlxyXG4gICAqL1xyXG4gIGFkZChvdGhlcikge1xyXG4gICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCArIG90aGVyLngsIHRoaXMueSArIG90aGVyLnksIHRoaXMueiArIG90aGVyLnosIHRoaXMudCArIG90aGVyLnQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgVmVjNCBtdXRhdGluZyB0aGUgdmFsdWVzIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBhZGQuXHJcbiAgICovXHJcbiAgYWRkSW5QbGFjZShvdGhlcikge1xyXG4gICAgdGhpcy54ICs9IG90aGVyLnhcclxuICAgIHRoaXMueSArPSBvdGhlci55XHJcbiAgICB0aGlzLnogKz0gb3RoZXIuelxyXG4gICAgdGhpcy50ICs9IG90aGVyLnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjNCBhbmQgcmV0dXJucyB0aGVuIHJlc3VsdCBhcyBhIG5ldyBWZWM0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIHN1YnRyYWN0LlxyXG4gICAqIEByZXR1cm4ge1ZlYzR9IC0gUmV0dXJucyBhIG5ldyBWZWM0LlxyXG4gICAqL1xyXG4gIHN1YnRyYWN0KG90aGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzQodGhpcy54IC0gb3RoZXIueCwgdGhpcy55IC0gb3RoZXIueSwgdGhpcy56IC0gb3RoZXIueiwgdGhpcy50IC0gb3RoZXIudClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjNCBtdXRhdGluZyB0aGUgdmFsdWVzIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzdWJ0cmFjdC5cclxuICAgKi9cclxuICBzdWJ0cmFjdEluUGxhY2Uob3RoZXIpIHtcclxuICAgIHRoaXMueCAtPSBvdGhlci54XHJcbiAgICB0aGlzLnkgLT0gb3RoZXIueVxyXG4gICAgdGhpcy56IC09IG90aGVyLnpcclxuICAgIHRoaXMudCAtPSBvdGhlci50XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gbXVsdGlwbHkgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC5cclxuICAgKi9cclxuICBtdWx0aXBseShvdGhlcikge1xyXG4gICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAqIG90aGVyLngsIHRoaXMueSAqIG90aGVyLnksIHRoaXMueiAqIG90aGVyLnosIHRoaXMudCAqIG90aGVyLnQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBtdXRhdGluZyB0aGUgdmFsdWVzIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBtdWx0aXBseSB3aXRoLlxyXG4gICAqL1xyXG4gIG11bHRpcGx5SW5QbGFjZShvdGhlcikge1xyXG4gICAgdGhpcy54ICo9IG90aGVyLnhcclxuICAgIHRoaXMueSAqPSBvdGhlci55XHJcbiAgICB0aGlzLnogKj0gb3RoZXIuelxyXG4gICAgdGhpcy50ICo9IG90aGVyLnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpdmlkZXMgdHdvIFZlYzRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBkaXZpZGUgYnkuXHJcbiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIGEgbmV3IFZlYzQuXHJcbiAgICovXHJcbiAgZGl2aWRlKG90aGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzQodGhpcy54IC8gb3RoZXIueCwgdGhpcy55IC8gb3RoZXIueSwgdGhpcy56IC8gb3RoZXIueiwgdGhpcy50IC8gb3RoZXIudClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpdmlkZXMgdHdvIFZlYzRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGRpdmlkZSBieS5cclxuICAgKi9cclxuICBkaXZpZGVJblBsYWNlKG90aGVyKSB7XHJcbiAgICB0aGlzLnggLz0gb3RoZXIueFxyXG4gICAgdGhpcy55IC89IG90aGVyLnlcclxuICAgIHRoaXMueiAvPSBvdGhlci56XHJcbiAgICB0aGlzLnQgLz0gb3RoZXIudFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NhbGVzIHRoaXMgVmVjNCBieSBzY2FsYXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjNH0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNjYWxlKHNjYWxhcikge1xyXG4gICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIsIHRoaXMudCAqIHNjYWxhcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjYWxlcyB0aGlzIFZlYzQgYnkgc2NhbGFyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICovXHJcbiAgc2NhbGVJblBsYWNlKHNjYWxhcikge1xyXG4gICAgdGhpcy5zZXQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIsIHRoaXMueiAqIHNjYWxhciwgdGhpcy50ICogc2NhbGFyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgVmVjNC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguXHJcbiAgICovXHJcbiAgbGVuZ3RoKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgdCA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHQgKiB0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyBWZWM0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGxlbmd0aC5cclxuICAgKi9cclxuICBsZW5ndGhTcXVhcmVkKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgdCA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZXMgdGhlIFZlYzQgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgVmVjNC5cclxuICAgKiBNdWx0aXBsaWVzIGNvb3JkZW5hdGVzIHZhbHVlIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIHRoZSBWZWM0IG5vcm1hbGl6ZWQuXHJcbiAgICovXHJcbiAgbm9ybWFsaXplKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgdCA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHRcclxuICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgICByZXR1cm4gbmV3IFZlYzQoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xyXG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXHJcbiAgICByZXR1cm4gbmV3IFZlYzQoeCAqIGxlbiwgeSAqIGxlbiwgeiAqIGxlbilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZXMgdGhpcyBWZWM0IG11bHRpcGx5aW5nIGNvb3JkZW5hdGUgdmFsdWVzIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLlxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZUluUGxhY2UoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF1cclxuICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXVxyXG4gICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCB0ID0gdGhpcy5fX2RhdGFbM11cclxuICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB0ICogdFxyXG4gICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXHJcbiAgICB0aGlzLnNldCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuLCB0ICogbGVuKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyBWZWM0IGFnYWluc3QgYW5vdGhlciBWZWM0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWM0fSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuXHJcbiAgICovXHJcbiAgZG90KG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnkgKyB0aGlzLnogKiBvdGhlci56ICsgdGhpcy50ICogYi50XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzR9IG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY2FsY3VsYXRlIHdpdGguXHJcbiAgICogQHJldHVybiB7VmVjNH0gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IGFzIGEgbmV3IFZlYzQuXHJcbiAgICovXHJcbiAgY3Jvc3Mob3RoZXIpIHtcclxuICAgIGNvbnN0IGF4ID0gdGhpcy54XHJcbiAgICBjb25zdCBheSA9IHRoaXMueVxyXG4gICAgY29uc3QgYXogPSB0aGlzLnpcclxuICAgIGNvbnN0IGF0ID0gdGhpcy50XHJcbiAgICBjb25zdCBieCA9IG90aGVyLnhcclxuICAgIGNvbnN0IGJ5ID0gb3RoZXIueVxyXG4gICAgY29uc3QgYnogPSBvdGhlci56XHJcbiAgICBjb25zdCBidCA9IG90aGVyLnRcclxuXHJcbiAgICByZXR1cm4gbmV3IFZlYzQoYXkgKiBieiAtIGF6ICogYnksIGF6ICogYnQgLSBhdCAqIGJ6LCBhdCAqIGJ4IC0gYXggKiBidCwgYXggKiBieSAtIGF5ICogYngpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjNCBhbmQgYi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICovXHJcbiAgYW5nbGVUbyhvdGhlcikge1xyXG4gICAgY29uc3QgdGVtcEEgPSB0aGlzLm5vcm1hbGl6ZSgpXHJcbiAgICBjb25zdCB0ZW1wQiA9IG90aGVyLm5vcm1hbGl6ZSgpXHJcbiAgICBjb25zdCBjb3NpbmUgPSB0ZW1wQS5kb3QodGVtcEIpXHJcblxyXG4gICAgaWYgKGNvc2luZSA+IDEuMCkge1xyXG4gICAgICByZXR1cm4gMFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBWZWM0IGFuZCBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC5cclxuICAgKi9cclxuICBsZXJwKG90aGVyLCB0KSB7XHJcbiAgICBjb25zdCBheCA9IHRoaXMueFxyXG4gICAgY29uc3QgYXkgPSB0aGlzLnlcclxuICAgIGNvbnN0IGF6ID0gdGhpcy56XHJcbiAgICBhdCA9IHRoaXMudFxyXG4gICAgcmV0dXJuIG5ldyBWZWM0KGF4ICsgdCAqIChvdGhlci54IC0gYXgpLCBheSArIHQgKiAob3RoZXIueSAtIGF5KSwgYXogKyB0ICogKG90aGVyLnogLSBheiksIGF0ICsgdCAqIChvdGhlci50IC0gYXQpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZC5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgcmFuZG9tKHNjYWxlID0gMS4wKSB7XHJcbiAgICBjb25zdCByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJXHJcbiAgICBjb25zdCB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjBcclxuICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZVxyXG5cclxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlXHJcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxyXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXHJcbiAgICByZXR1cm4gb3V0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBWZWM0IGFuZCByZXR1cm5zIGEgbmV3IFZlYzQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdLCB0aGlzLl9fZGF0YVszXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgVmVjNCBpbnRvIGEgVmVjMy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgdmFsdWUgYXMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICB0b1ZlYzMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YXJheX0gLSBSZXR1cm5zIGFzIGFuIGFycmF5LlxyXG4gICAqL1xyXG4gIGFzQXJyYXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFZlYzMuXHJcbiAgICogQHBhcmFtIHsuLi5vYmplY3R9IC4uLmFyZ3MgLSBUaGUgLi4uYXJncyBwYXJhbS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGUoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKC4uLmFyZ3MpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFZlYzQgdG8gd3JhcCBleGlzdGluZyBtZW1vcnkgaW4gYSBidWZmZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpXHJcbiAgICByZXR1cm4gbmV3IFZlYzQobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCAqIDQsIDQpKSAvLyA0IGJ5dGVzIHBlciAzMmJpdCBmbG9hdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGBWZWM0YCB1c2luZyBhbiBBcnJheUJ1ZmZlci5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybnMgYSBuZXcgVmVjNC5cclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIGJ5dGVPZmZzZXQpIHtcclxuICAgIHJldHVybiBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRmxvYXQzMiBlbGVtZW50cyB1c2VkIGJ5IHRoaXMgdHlwZS4gVXNlZCB0byBjYWxjdWxhdGUgc3RvcmFnZSByZXF1aXJlbWVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgbnVtRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gNFxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB0aGlzLngsXHJcbiAgICAgIHk6IHRoaXMueSxcclxuICAgICAgejogdGhpcy56LFxyXG4gICAgICB0OiB0aGlzLnQsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaikge1xyXG4gICAgdGhpcy54ID0gai54XHJcbiAgICB0aGlzLnkgPSBqLnlcclxuICAgIHRoaXMueiA9IGouelxyXG4gICAgdGhpcy50ID0gai50XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIpIHtcclxuICAgIHRoaXMueCA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKVxyXG4gICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICAgIHRoaXMudCA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignVmVjNCcsIFZlYzQpXHJcblxyXG5leHBvcnQgeyBWZWM0IH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYyAqL1xyXG5pbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgY2hhbm5lbCBvZiBhIGNvbG9yLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyVmFsdWVcclxuICovXHJcbmNsYXNzIFJHQkEgZXh0ZW5kcyBBdHRyVmFsdWUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIFJHQkEuXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCBGbG9hdDMyQXJyYXkgfCBBcnJheUJ1ZmZlcn0gciAtIFRoZSByZWQgY2hhbm5lbCBvZiBhIGNvbG9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIC0gVGhlIGdyZWVuIGNoYW5uZWwgb2YgYSBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBibHVlIGNoYW5uZWwgb2YgYSBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBhbHBoYSAodHJhbnNwYXJlbmN5KSBjaGFubmVsIG9mIGEgY29sb3IuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDI1NSkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIGlmIChyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IHJcclxuICAgIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHJcclxuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGdcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBVaW50OEFycmF5KDQpXHJcbiAgICAgIGlmICh0eXBlb2YgciA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChyLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgICAgdGhpcy5zZXRGcm9tSGV4KHIpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuc2V0RnJvbUNTU0NvbG9yTmFtZShyKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHJcclxuICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IGdcclxuICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IGJcclxuICAgICAgICB0aGlzLl9fZGF0YVszXSA9IGFcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByZWQgY2hhbm5lbC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyB0aGUgcmVkIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IHIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgcmVkIGNoYW5uZWwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgcih2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzBdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGdyZWVuIGNoYW5uZWwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgdGhlIGdyZWVuIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IGcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgZ3JlZW4gY2hhbm5lbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBnKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYmx1ZSBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIHRoZSBibHVlIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IGIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYmx1ZSBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IGIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBhbHBoYSBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIHRoZSBhbHBoYSBjaGFubmVsLlxyXG4gICAqL1xyXG4gIGdldCBhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzNdXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYWxwaGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgYSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzNdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHJlZCBjaGFubmVsLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnICAtIFRoZSBncmVlbiBjaGFubmVsLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiICAtIFRoZSBibHVlIGNoYW5uZWwuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGEgIC0gVGhlIGFscGhhIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgc2V0KHIsIGcsIGIsIGEgPSAyNTUpIHtcclxuICAgIHRoaXMuciA9IHJcclxuICAgIHRoaXMuZyA9IGdcclxuICAgIHRoaXMuYiA9IGJcclxuICAgIHRoaXMuYSA9IGFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGFub3RoZXIgUkdCQSBjb2xvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSBUaGUgb3RoZXIgUkdCQSB0byBzZXQgZnJvbS5cclxuICAgKi9cclxuICBzZXRGcm9tT3RoZXIob3RoZXIpIHtcclxuICAgIHRoaXMuciA9IG90aGVyLnJcclxuICAgIHRoaXMuZyA9IG90aGVyLmdcclxuICAgIHRoaXMuYiA9IG90aGVyLmJcclxuICAgIHRoaXMuYSA9IG90aGVyLmFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGEgc2NhbGFyIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthcnJheX0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldEZyb21BcnJheSh2YWxzKSB7XHJcbiAgICB0aGlzLnIgPSB2YWxzWzBdXHJcbiAgICB0aGlzLmcgPSB2YWxzWzFdXHJcbiAgICB0aGlzLmIgPSB2YWxzWzJdXHJcbiAgICB0aGlzLmEgPSB2YWxzLmxlbmd0aCA9PSA0ID8gdmFsc1szXSA6IDEuMFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZyb20gYSBoZXhhZGVjaW1hbCB2YWx1ZS5cclxuICAgKiBFLmcuICNmZjAwMDBcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZXggLSBUaGUgaGV4IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZyb21IZXgoaGV4KSB7XHJcbiAgICBmdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleClcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcclxuICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXHJcbiAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDogbnVsbFxyXG4gICAgfVxyXG4gICAgY29uc3QgcmdiID0gaGV4VG9SZ2IoaGV4KVxyXG4gICAgaWYgKCFyZ2IpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGhleCBjb2RlOicgKyBoZXgpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgdGhpcy5zZXQocmdiLnIsIHJnYi5nLCByZ2IuYilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGEgQ1NTIGNvbG9yIG5hbWUuXHJcbiAgICogRS5nLiBcInJlZFwiXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBDU1MgY29sb3IgbmFtZS5cclxuICAgKi9cclxuICBzZXRGcm9tQ1NTQ29sb3JOYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IGNvbG91ck5hbWVUb0hleCA9IChjb2xvdXIpID0+IHtcclxuICAgICAgY29uc3QgY29sb3JzID0ge1xyXG4gICAgICAgIGFsaWNlYmx1ZTogJyNmMGY4ZmYnLFxyXG4gICAgICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLFxyXG4gICAgICAgIGFxdWE6ICcjMDBmZmZmJyxcclxuICAgICAgICBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsXHJcbiAgICAgICAgYXp1cmU6ICcjZjBmZmZmJyxcclxuICAgICAgICBiZWlnZTogJyNmNWY1ZGMnLFxyXG4gICAgICAgIGJpc3F1ZTogJyNmZmU0YzQnLFxyXG4gICAgICAgIGJsYWNrOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJyxcclxuICAgICAgICBibHVlOiAnIzAwMDBmZicsXHJcbiAgICAgICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLFxyXG4gICAgICAgIGJyb3duOiAnI2E1MmEyYScsXHJcbiAgICAgICAgYnVybHl3b29kOiAnI2RlYjg4NycsXHJcbiAgICAgICAgY2FkZXRibHVlOiAnIzVmOWVhMCcsXHJcbiAgICAgICAgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLFxyXG4gICAgICAgIGNob2NvbGF0ZTogJyNkMjY5MWUnLFxyXG4gICAgICAgIGNvcmFsOiAnI2ZmN2Y1MCcsXHJcbiAgICAgICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcclxuICAgICAgICBjb3Juc2lsazogJyNmZmY4ZGMnLFxyXG4gICAgICAgIGNyaW1zb246ICcjZGMxNDNjJyxcclxuICAgICAgICBjeWFuOiAnIzAwZmZmZicsXHJcbiAgICAgICAgZGFya2JsdWU6ICcjMDAwMDhiJyxcclxuICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxyXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcclxuICAgICAgICBkYXJrZ3JheTogJyNhOWE5YTknLFxyXG4gICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxyXG4gICAgICAgIGRhcmtraGFraTogJyNiZGI3NmInLFxyXG4gICAgICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsXHJcbiAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJyxcclxuICAgICAgICBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsXHJcbiAgICAgICAgZGFya29yY2hpZDogJyM5OTMyY2MnLFxyXG4gICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJyxcclxuICAgICAgICBkYXJrc2FsbW9uOiAnI2U5OTY3YScsXHJcbiAgICAgICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsXHJcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLFxyXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJyxcclxuICAgICAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXHJcbiAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLFxyXG4gICAgICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXHJcbiAgICAgICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcclxuICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsXHJcbiAgICAgICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLFxyXG4gICAgICAgIGZpcmVicmljazogJyNiMjIyMjInLFxyXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsXHJcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJyxcclxuICAgICAgICBmdWNoc2lhOiAnI2ZmMDBmZicsXHJcbiAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsXHJcbiAgICAgICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLFxyXG4gICAgICAgIGdvbGQ6ICcjZmZkNzAwJyxcclxuICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJyxcclxuICAgICAgICBncmF5OiAnIzgwODA4MCcsXHJcbiAgICAgICAgZ3JlZW46ICcjMDA4MDAwJyxcclxuICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLFxyXG4gICAgICAgIGhvbmV5ZGV3OiAnI2YwZmZmMCcsXHJcbiAgICAgICAgaG90cGluazogJyNmZjY5YjQnLFxyXG4gICAgICAgICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLFxyXG4gICAgICAgIGluZGlnbzogJyM0YjAwODInLFxyXG4gICAgICAgIGl2b3J5OiAnI2ZmZmZmMCcsXHJcbiAgICAgICAga2hha2k6ICcjZjBlNjhjJyxcclxuICAgICAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxyXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcclxuICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJyxcclxuICAgICAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcclxuICAgICAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcclxuICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsXHJcbiAgICAgICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXHJcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJyxcclxuICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJyxcclxuICAgICAgICBsaWdodGdyZWVuOiAnIzkwZWU5MCcsXHJcbiAgICAgICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsXHJcbiAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJyxcclxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsXHJcbiAgICAgICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsXHJcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JyxcclxuICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLFxyXG4gICAgICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsXHJcbiAgICAgICAgbGltZTogJyMwMGZmMDAnLFxyXG4gICAgICAgIGxpbWVncmVlbjogJyMzMmNkMzInLFxyXG4gICAgICAgIGxpbmVuOiAnI2ZhZjBlNicsXHJcbiAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLFxyXG4gICAgICAgIG1hcm9vbjogJyM4MDAwMDAnLFxyXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcclxuICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXHJcbiAgICAgICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsXHJcbiAgICAgICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkOCcsXHJcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcclxuICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJyxcclxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxyXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxyXG4gICAgICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLFxyXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxyXG4gICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxyXG4gICAgICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLFxyXG4gICAgICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXHJcbiAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcclxuICAgICAgICBuYXZ5OiAnIzAwMDA4MCcsXHJcbiAgICAgICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxyXG4gICAgICAgIG9saXZlOiAnIzgwODAwMCcsXHJcbiAgICAgICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsXHJcbiAgICAgICAgb3JhbmdlOiAnI2ZmYTUwMCcsXHJcbiAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXHJcbiAgICAgICAgb3JjaGlkOiAnI2RhNzBkNicsXHJcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxyXG4gICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxyXG4gICAgICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJyxcclxuICAgICAgICBwYWxldmlvbGV0cmVkOiAnI2Q4NzA5MycsXHJcbiAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxyXG4gICAgICAgIHBlYWNocHVmZjogJyNmZmRhYjknLFxyXG4gICAgICAgIHBlcnU6ICcjY2Q4NTNmJyxcclxuICAgICAgICBwaW5rOiAnI2ZmYzBjYicsXHJcbiAgICAgICAgcGx1bTogJyNkZGEwZGQnLFxyXG4gICAgICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcclxuICAgICAgICBwdXJwbGU6ICcjODAwMDgwJyxcclxuICAgICAgICByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsXHJcbiAgICAgICAgcmVkOiAnI2ZmMDAwMCcsXHJcbiAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsXHJcbiAgICAgICAgcm95YWxibHVlOiAnIzQxNjllMScsXHJcbiAgICAgICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJyxcclxuICAgICAgICBzYWxtb246ICcjZmE4MDcyJyxcclxuICAgICAgICBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsXHJcbiAgICAgICAgc2VhZ3JlZW46ICcjMmU4YjU3JyxcclxuICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLFxyXG4gICAgICAgIHNpZW5uYTogJyNhMDUyMmQnLFxyXG4gICAgICAgIHNpbHZlcjogJyNjMGMwYzAnLFxyXG4gICAgICAgIHNreWJsdWU6ICcjODdjZWViJyxcclxuICAgICAgICBzbGF0ZWJsdWU6ICcjNmE1YWNkJyxcclxuICAgICAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJyxcclxuICAgICAgICBzbm93OiAnI2ZmZmFmYScsXHJcbiAgICAgICAgc3ByaW5nZ3JlZW46ICcjMDBmZjdmJyxcclxuICAgICAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JyxcclxuICAgICAgICB0YW46ICcjZDJiNDhjJyxcclxuICAgICAgICB0ZWFsOiAnIzAwODA4MCcsXHJcbiAgICAgICAgdGhpc3RsZTogJyNkOGJmZDgnLFxyXG4gICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLFxyXG4gICAgICAgIHR1cnF1b2lzZTogJyM0MGUwZDAnLFxyXG4gICAgICAgIHZpb2xldDogJyNlZTgyZWUnLFxyXG4gICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsXHJcbiAgICAgICAgd2hpdGU6ICcjZmZmZmZmJyxcclxuICAgICAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsXHJcbiAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsXHJcbiAgICAgICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJyxcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBjb2xvcnNbY29sb3VyLnRvTG93ZXJDYXNlKCldICE9ICd1bmRlZmluZWQnKSByZXR1cm4gY29sb3JzW2NvbG91ci50b0xvd2VyQ2FzZSgpXVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgdGhpcy5zZXRGcm9tSGV4KG5hbWUpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNldEZyb21IZXgoY29sb3VyTmFtZVRvSGV4KG5hbWUpKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgb2YgdGhpcyBSR0JBIGNvbG9yLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFJldHVybnMgdGhlIGhleCB2YWx1ZS5cclxuICAgKi9cclxuICB0b0hleCgpIHtcclxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGludCkge1xyXG4gICAgICBjb25zdCBoZXggPSBpbnQudG9TdHJpbmcoMTYpXHJcbiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAnMCcgKyBoZXggOiBoZXhcclxuICAgIH1cclxuICAgIHJldHVybiAnIycgKyBjb21wb25lbnRUb0hleCh0aGlzLnIpICsgY29tcG9uZW50VG9IZXgodGhpcy5nKSArIGNvbXBvbmVudFRvSGV4KHRoaXMuYilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFJHQkEgY29sb3IgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSBUaGUgb3RoZXIgUkdCQSB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuXHJcbiAgICovXHJcbiAgZXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnIgPT0gb3RoZXIuciAmJiB0aGlzLmcgPT0gb3RoZXIuZyAmJiB0aGlzLmIgPT0gb3RoZXIuYiAmJiB0aGlzLmEgPT0gb3RoZXIuYVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUkdCQSBjb2xvciBpcyBOT1QgZXhhY3RseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UkdCQX0gb3RoZXIgLSAgVGhlIG90aGVyIFJHQkEgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuciAhPSBvdGhlci5yICYmIHRoaXMuZyAhPSBvdGhlci5nICYmIHRoaXMuYiAhPSBvdGhlci5iICYmIHRoaXMuYSAhPSBvdGhlci5hXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBSR0JBIGNvbG9yIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JHQkF9IG90aGVyIC0gVGhlIG90aGVyIFJHQkEgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIE1hdGguYWJzKHRoaXMuciAtIG90aGVyLnIpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMuZyAtIG90aGVyLmcpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMuYiAtIG90aGVyLmIpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMuYSAtIG90aGVyLmEpIDwgcHJlY2lzaW9uXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IFJHQkEgY29sb3Igd2hpY2ggaXMgdGhpcyBSR0JBIGNvbG9yIGFkZGVkIHRvIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSR0JBfSBvdGhlciAtIFRoZSBvdGhlciBSR0JBIHRvIGFkZC5cclxuICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS5cclxuICAgKi9cclxuICBhZGQob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgUkdCQSh0aGlzLnIgKyBvdGhlci5yLCB0aGlzLmcgKyBvdGhlci5nLCB0aGlzLmIgKyBvdGhlci5iLCB0aGlzLmEgKyBvdGhlci5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBSR0JBIGNvbG9yIHdoaWNoIGlzIHRoaXMgUkdCQSBjb2xvciBzdWJ0cmFjdGVkIGZyb20gb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JHQkF9IG90aGVyIC0gVGhlIG90aGVyIFJHQkEgdG8gc3VidHJhY3QuXHJcbiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuXHJcbiAgICovXHJcbiAgc3VidHJhY3Qob3RoZXIpIHtcclxuICAgIHJldHVybiBuZXcgUkdCQSh0aGlzLnIgLSBvdGhlci5yLCB0aGlzLmcgLSBvdGhlci5nLCB0aGlzLmIgLSBvdGhlci5iLCB0aGlzLmEgLSBvdGhlci5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBSR0JBIGNvbG9yIHdoaWNoIGlzIHRoaXMgdmVjdG9yIHNjYWxlZCBieSBzY2FsYXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS5cclxuICAgKi9cclxuICBzY2FsZShzY2FsYXIpIHtcclxuICAgIHJldHVybiBuZXcgUkdCQSh0aGlzLnIgKiBzY2FsYXIsIHRoaXMuZyAqIHNjYWxhciwgdGhpcy5iICogc2NhbGFyLCB0aGlzLmEgKiBzY2FsYXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgdGhpcyBSR0JBIGNvbG9yIGJ5IHNjYWxhci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNjYWxlSW5QbGFjZShzY2FsYXIpIHtcclxuICAgIHRoaXMuciAqPSBzY2FsYXJcclxuICAgIHRoaXMuZyAqPSBzY2FsYXJcclxuICAgIHRoaXMuYiAqPSBzY2FsYXJcclxuICAgIHRoaXMuYSAqPSBzY2FsYXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IGdhbW1hIGNvcnJlY3Rpb24gdG8gdGhpcyBSR0JBIGNvbG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLlxyXG4gICAqL1xyXG4gIGFwcGx5R2FtbWEoZ2FtbWEpIHtcclxuICAgIHRoaXMuc2V0KE1hdGgucG93KHRoaXMuciwgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmcsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5iLCBnYW1tYSksIHRoaXMuYSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRvIGxpbmVhciBjb2xvciBzcGFjZSBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBSR0JBLlxyXG4gICAqL1xyXG4gIHRvTGluZWFyKGdhbW1hID0gMi4yKSB7XHJcbiAgICByZXR1cm4gbmV3IFJHQkEoTWF0aC5wb3codGhpcy5yLCBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIGdhbW1hKSwgdGhpcy5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdG8gZ2FtbWEgY29sb3Igc3BhY2UgYW5kIHJldHVybnMgYSBuZXcgUkdCQSBjb2xvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS5cclxuICAgKi9cclxuICB0b0dhbW1hKGdhbW1hID0gMi4yKSB7XHJcbiAgICByZXR1cm4gbmV3IFJHQkEoTWF0aC5wb3codGhpcy5yLCAxLjAgLyBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgMS4wIC8gZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIDEuMCAvIGdhbW1hKSwgdGhpcy5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcmVsYXRpdmUgbHVtaW5hbmNlIG9mIHRoZSBsaW5lYXIgUkdCIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGx1bWluYW5jZSgpIHtcclxuICAgIHJldHVybiAwLjIxMjYgKiB0aGlzLnIgKyAwLjcxNTIgKiB0aGlzLmcgKyAwLjA3MjIgKiB0aGlzLmJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGlzIFJHQkEgY29sb3IgYW5kIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSR0JBfSBvdGhlciAtIFRoZSBvdGhlciBSR0JBIHRvIGludGVycG9sYXRlIGJldHdlZW4uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLlxyXG4gICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyBhIG5ldyBSR0JBLlxyXG4gICAqL1xyXG4gIGxlcnAob3RoZXIsIHQpIHtcclxuICAgIGNvbnN0IGFyID0gdGhpcy5yXHJcbiAgICBjb25zdCBhZyA9IHRoaXMuZ1xyXG4gICAgY29uc3QgYWIgPSB0aGlzLmJcclxuICAgIGNvbnN0IGFhID0gdGhpcy5hXHJcbiAgICByZXR1cm4gbmV3IFJHQkEoYXIgKyB0ICogKG90aGVyLnIgLSBhciksIGFnICsgdCAqIChvdGhlci5nIC0gYWcpLCBhYiArIHQgKiAob3RoZXIuYiAtIGFiKSwgYWEgKyB0ICogKG90aGVyLmEgLSBhYSkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcmFuZG9tIFJHQkEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWFPZmZzZXQgLSBUaGUgZ2FtbWEgb2Zmc2V0LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmFuZG9tQWxwaGEgLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFscGhhIGNoYW5uZWwgaXMgcmFuZG9tLlxyXG4gICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyBhIG5ldyByYW5kb20gUkdCQS5cclxuICAgKi9cclxuICBzdGF0aWMgcmFuZG9tKGdhbW1hT2Zmc2V0ID0gMC4wLCByYW5kb21BbHBoYSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoZ2FtbWFPZmZzZXQgPiAwLjApIHtcclxuICAgICAgcmV0dXJuIG5ldyBSR0JBKFxyXG4gICAgICAgIGdhbW1hT2Zmc2V0ICsgTWF0aC5yYW5kb20oKSAqICgxLjAgLSBnYW1tYU9mZnNldCksXHJcbiAgICAgICAgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSxcclxuICAgICAgICBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLFxyXG4gICAgICAgIHJhbmRvbUFscGhhID8gZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSA6IDEuMFxyXG4gICAgICApXHJcbiAgICB9IGVsc2UgaWYgKGdhbW1hT2Zmc2V0IDwgMC4wKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUkdCQShcclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSxcclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSxcclxuICAgICAgICBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSxcclxuICAgICAgICByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpIDogMS4wXHJcbiAgICAgIClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgUkdCQShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgOiAxLjApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBSR0JBIGNvbG9yIGFuZCByZXR1cm5zIGEgbmV3IFJHQkEgY29sb3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSR0JBfSAtIFJldHVybnMgYSBuZXcgUkdCQS5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgUkdCQSh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdLCB0aGlzLl9fZGF0YVszXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YXJyYXl9IC0gUmV0dXJucyBhcyBhbiBhcnJheS5cclxuICAgKi9cclxuICBhc0FycmF5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIGFzIGEgMyBjb21wb25lbnQgYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YXJyYXl9IC0gUmV0dXJucyBhcyBhIDMgY29tcG9uZW50IGFycmF5LlxyXG4gICAqL1xyXG4gIGFzM0NvbXBvbmVudEFycmF5KCkge1xyXG4gICAgcmV0dXJuIFt0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdXVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgUkdCQSBjb2xvci5cclxuICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLlxyXG4gICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyBhIG5ldyBSR0JBLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IFJHQkEoLi4uYXJncylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlciBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1JHQkF9IC0gUmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpXHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgUkdCQWAgdXNpbmcgYW4gQXJyYXlCdWZmZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7UkdCQX0gLSBSZXR1cm5zIGEgbmV3IFJHQkEuXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gbmV3IFJHQkEobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBGbG9hdDMyIGVsZW1lbnRzIHVzZWQgYnkgdGhpcyB0eXBlLiBVc2VkIHRvIGNhbGN1bGF0ZSBzdG9yYWdlIHJlcXVpcmVtZW50cyBmb3IgbGFyZ2UgYXJyYXlzIG9mIHRoaXMgdHlwZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBudW1FbGVtZW50cygpIHtcclxuICAgIHJldHVybiA0XHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByOiB0aGlzLnIsXHJcbiAgICAgIGc6IHRoaXMuZyxcclxuICAgICAgYjogdGhpcy5iLFxyXG4gICAgICBhOiB0aGlzLmEsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaikge1xyXG4gICAgdGhpcy5yID0gai5yXHJcbiAgICB0aGlzLmcgPSBqLmdcclxuICAgIHRoaXMuYiA9IGouYlxyXG4gICAgdGhpcy5hID0gai5hXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBDU1MgcmdiYSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b0NTU1N0cmluZygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICdyZ2JhKCcgK1xyXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkgK1xyXG4gICAgICAnLCAnICtcclxuICAgICAgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpICtcclxuICAgICAgJywgJyArXHJcbiAgICAgIE1hdGgucm91bmQodGhpcy5iICogMjU1KSArXHJcbiAgICAgICcsICcgK1xyXG4gICAgICB0aGlzLmEgK1xyXG4gICAgICAnKSdcclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdSR0JBJywgUkdCQSlcclxuXHJcbmV4cG9ydCB7IFJHQkEgfVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jICovXHJcbmltcG9ydCB7IEF0dHJWYWx1ZSB9IGZyb20gJy4vQXR0clZhbHVlLmpzJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY29sb3IgYXMgNCBmbG9hdGluZyBwb2ludCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEF0dHJWYWx1ZVxyXG4gKi9cclxuY2xhc3MgQ29sb3IgZXh0ZW5kcyBBdHRyVmFsdWUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBgQ29sb3JgIG9iamVjdCB3aXRoIGFuIFJHQkEgc3RydWN0dXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmcgfCBGbG9hdDMyQXJyYXkgfCBBcnJheUJ1ZmZlcn0gciAtIFRoZSByZWQgY2hhbm5lbCBvZiBhIGNvbG9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIC0gVGhlIGdyZWVuIGNoYW5uZWwgb2YgYSBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIFRoZSBibHVlIGNoYW5uZWwgb2YgYSBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIFRoZSBhbHBoYSAodHJhbnNwYXJlbmN5KSBjaGFubmVsIG9mIGEgY29sb3IuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDEuMCkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIGlmIChyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0gclxyXG4gICAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG5ldyBWZWM0KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KSlgKVxyXG4gICAgICBjb25zdCBidWZmZXIgPSByXHJcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBnXHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNClcclxuICAgICAgaWYgKHR5cGVvZiByID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKHIuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgICB0aGlzLnNldEZyb21IZXgocilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zZXRGcm9tQ1NTQ29sb3JOYW1lKHIpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX19kYXRhWzBdID0gclxyXG4gICAgICAgIHRoaXMuX19kYXRhWzFdID0gZ1xyXG4gICAgICAgIHRoaXMuX19kYXRhWzJdID0gYlxyXG4gICAgICAgIHRoaXMuX19kYXRhWzNdID0gYVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJlZCBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHJlZCBjaGFubmVsLlxyXG4gICAqL1xyXG4gIGdldCByKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJlZCBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBncmVlbiBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGdyZWVuIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IGcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgZ3JlZW4gY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgZyh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzFdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGJsdWUgY2hhbm5lbC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBibHVlIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IGIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYmx1ZSBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IGIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBhbHBoYSBjaGFubmVsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGFscGhhIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgZ2V0IGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbM11cclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBhbHBoYSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBhKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbM10gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBUaGUgcmVkIGNoYW5uZWwuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGcgIC0gVGhlIGdyZWVuIGNoYW5uZWwuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgIC0gVGhlIGJsdWUgY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYSAgLSBUaGUgYWxwaGEgY2hhbm5lbC5cclxuICAgKi9cclxuICBzZXQociwgZywgYiwgYSA9IDEuMCkge1xyXG4gICAgdGhpcy5yID0gclxyXG4gICAgdGhpcy5nID0gZ1xyXG4gICAgdGhpcy5iID0gYlxyXG4gICAgdGhpcy5hID0gYVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBjdXJyZW50IGNvbG9yIHN0YXRlIHdpdGggYW5vdGhlciBgQ29sb3JgIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIHNldCBmcm9tLlxyXG4gICAqL1xyXG4gIHNldEZyb21PdGhlcihvdGhlcikge1xyXG4gICAgdGhpcy5yID0gb3RoZXIuclxyXG4gICAgdGhpcy5nID0gb3RoZXIuZ1xyXG4gICAgdGhpcy5iID0gb3RoZXIuYlxyXG4gICAgdGhpcy5hID0gb3RoZXIuYVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZyb20gYSBzY2FsYXIgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldEZyb21TY2FsYXJBcnJheSh2YWxzKSB7XHJcbiAgICB0aGlzLnIgPSB2YWxzWzBdXHJcbiAgICB0aGlzLmcgPSB2YWxzWzFdXHJcbiAgICB0aGlzLmIgPSB2YWxzWzJdXHJcbiAgICB0aGlzLmEgPSB2YWxzLmxlbmd0aCA9PSA0ID8gdmFsc1szXSA6IDEuMFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZyb20gYW4gUkdCIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRBc1JHQkFycmF5KCkge1xyXG4gICAgcmV0dXJuIFt0aGlzLnIgKiAyNTUsIHRoaXMuZyAqIDI1NSwgdGhpcy5iICogMjU1XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZyb20gYW4gUkdCIGRpY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRBc1JHQkRpY3QoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByOiB0aGlzLnIgKiAyNTUsXHJcbiAgICAgIGc6IHRoaXMuZyAqIDI1NSxcclxuICAgICAgYjogdGhpcy5iICogMjU1LFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZyb20gYSBSR0IgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSByZWQgY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZyAgLSBUaGUgZ3JlZW4gY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiAgLSBUaGUgYmx1ZSBjaGFubmVsLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhICAtIFRoZSBhbHBoYSBjaGFubmVsLlxyXG4gICAqL1xyXG4gIHNldEZyb21SR0IociwgZywgYiwgYSkge1xyXG4gICAgdGhpcy5yID0gciAvIDI1NVxyXG4gICAgdGhpcy5nID0gZyAvIDI1NVxyXG4gICAgdGhpcy5iID0gYiAvIDI1NVxyXG4gICAgdGhpcy5hID0gYSA/IGEgLyAyNTUgOiAxLjBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGFuIFJHQiBhcnJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2YWxzIC0gVGhlIHZhbHMgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0RnJvbVJHQkFycmF5KHZhbHMpIHtcclxuICAgIHRoaXMuciA9IHZhbHNbMF0gLyAyNTVcclxuICAgIHRoaXMuZyA9IHZhbHNbMV0gLyAyNTVcclxuICAgIHRoaXMuYiA9IHZhbHNbMl0gLyAyNTVcclxuICAgIHRoaXMuYSA9IHZhbHMubGVuZ3RoID09IDQgPyB2YWxzWzNdIC8gMjU1IDogMS4wXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZnJvbSBhbiBSR0IgZGljdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2YWxzIC0gVGhlIHZhbHMgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0RnJvbVJHQkRpY3QodmFscykge1xyXG4gICAgdGhpcy5yID0gdmFscy5yIC8gMjU1XHJcbiAgICB0aGlzLmcgPSB2YWxzLmcgLyAyNTVcclxuICAgIHRoaXMuYiA9IHZhbHMuYiAvIDI1NVxyXG4gICAgdGhpcy5hID0gdmFscy5hID09IDQgPyB2YWxzLmEgLyAyNTUgOiAxLjBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGEgaGV4YWRlY2ltYWwgdmFsdWUuXHJcbiAgICogRS5nLiAjZmYwMDAwXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBoZXggdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RnJvbUhleChoZXgpIHtcclxuICAgIGZ1bmN0aW9uIGhleFRvUmdiKGhleCkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxyXG4gICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcclxuICAgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNiksXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiBudWxsXHJcbiAgICB9XHJcbiAgICBjb25zdCByZ2IgPSBoZXhUb1JnYihoZXgpXHJcbiAgICBpZiAoIXJnYikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgaGV4IGNvZGU6JyArIGhleClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB0aGlzLnNldEZyb21SR0IocmdiLnIsIHJnYi5nLCByZ2IuYilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIGEgQ1NTIGNvbG9yIG5hbWUuXHJcbiAgICogRS5nLiBcInJlZFwiXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgQ1NTIGNvbG9yIG5hbWUuXHJcbiAgICovXHJcbiAgc2V0RnJvbUNTU0NvbG9yTmFtZShuYW1lKSB7XHJcbiAgICBjb25zdCBjb2xvdXJOYW1lVG9IZXggPSAoY29sb3VyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbG9ycyA9IHtcclxuICAgICAgICBhbGljZWJsdWU6ICcjZjBmOGZmJyxcclxuICAgICAgICBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JyxcclxuICAgICAgICBhcXVhOiAnIzAwZmZmZicsXHJcbiAgICAgICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxyXG4gICAgICAgIGF6dXJlOiAnI2YwZmZmZicsXHJcbiAgICAgICAgYmVpZ2U6ICcjZjVmNWRjJyxcclxuICAgICAgICBiaXNxdWU6ICcjZmZlNGM0JyxcclxuICAgICAgICBibGFjazogJyMwMDAwMDAnLFxyXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsXHJcbiAgICAgICAgYmx1ZTogJyMwMDAwZmYnLFxyXG4gICAgICAgIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJyxcclxuICAgICAgICBicm93bjogJyNhNTJhMmEnLFxyXG4gICAgICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxyXG4gICAgICAgIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLFxyXG4gICAgICAgIGNoYXJ0cmV1c2U6ICcjN2ZmZjAwJyxcclxuICAgICAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcclxuICAgICAgICBjb3JhbDogJyNmZjdmNTAnLFxyXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsXHJcbiAgICAgICAgY29ybnNpbGs6ICcjZmZmOGRjJyxcclxuICAgICAgICBjcmltc29uOiAnI2RjMTQzYycsXHJcbiAgICAgICAgY3lhbjogJyMwMGZmZmYnLFxyXG4gICAgICAgIGRhcmtibHVlOiAnIzAwMDA4YicsXHJcbiAgICAgICAgZGFya2N5YW46ICcjMDA4YjhiJyxcclxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsXHJcbiAgICAgICAgZGFya2dyYXk6ICcjYTlhOWE5JyxcclxuICAgICAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcclxuICAgICAgICBkYXJra2hha2k6ICcjYmRiNzZiJyxcclxuICAgICAgICBkYXJrbWFnZW50YTogJyM4YjAwOGInLFxyXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsXHJcbiAgICAgICAgZGFya29yYW5nZTogJyNmZjhjMDAnLFxyXG4gICAgICAgIGRhcmtvcmNoaWQ6ICcjOTkzMmNjJyxcclxuICAgICAgICBkYXJrcmVkOiAnIzhiMDAwMCcsXHJcbiAgICAgICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLFxyXG4gICAgICAgIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLFxyXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJyxcclxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsXHJcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJyMwMGNlZDEnLFxyXG4gICAgICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJyxcclxuICAgICAgICBkZWVwcGluazogJyNmZjE0OTMnLFxyXG4gICAgICAgIGRlZXBza3libHVlOiAnIzAwYmZmZicsXHJcbiAgICAgICAgZGltZ3JheTogJyM2OTY5NjknLFxyXG4gICAgICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcclxuICAgICAgICBmaXJlYnJpY2s6ICcjYjIyMjIyJyxcclxuICAgICAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxyXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXHJcbiAgICAgICAgZnVjaHNpYTogJyNmZjAwZmYnLFxyXG4gICAgICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxyXG4gICAgICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcclxuICAgICAgICBnb2xkOiAnI2ZmZDcwMCcsXHJcbiAgICAgICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXHJcbiAgICAgICAgZ3JheTogJyM4MDgwODAnLFxyXG4gICAgICAgIGdyZWVuOiAnIzAwODAwMCcsXHJcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcclxuICAgICAgICBob25leWRldzogJyNmMGZmZjAnLFxyXG4gICAgICAgIGhvdHBpbms6ICcjZmY2OWI0JyxcclxuICAgICAgICAnaW5kaWFucmVkICc6ICcjY2Q1YzVjJyxcclxuICAgICAgICBpbmRpZ286ICcjNGIwMDgyJyxcclxuICAgICAgICBpdm9yeTogJyNmZmZmZjAnLFxyXG4gICAgICAgIGtoYWtpOiAnI2YwZTY4YycsXHJcbiAgICAgICAgbGF2ZW5kZXI6ICcjZTZlNmZhJyxcclxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAnI2ZmZjBmNScsXHJcbiAgICAgICAgbGF3bmdyZWVuOiAnIzdjZmMwMCcsXHJcbiAgICAgICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsXHJcbiAgICAgICAgbGlnaHRibHVlOiAnI2FkZDhlNicsXHJcbiAgICAgICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLFxyXG4gICAgICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLFxyXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI2ZhZmFkMicsXHJcbiAgICAgICAgbGlnaHRncmV5OiAnI2QzZDNkMycsXHJcbiAgICAgICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLFxyXG4gICAgICAgIGxpZ2h0cGluazogJyNmZmI2YzEnLFxyXG4gICAgICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsXHJcbiAgICAgICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLFxyXG4gICAgICAgIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLFxyXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXHJcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcclxuICAgICAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxyXG4gICAgICAgIGxpbWU6ICcjMDBmZjAwJyxcclxuICAgICAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcclxuICAgICAgICBsaW5lbjogJyNmYWYwZTYnLFxyXG4gICAgICAgIG1hZ2VudGE6ICcjZmYwMGZmJyxcclxuICAgICAgICBtYXJvb246ICcjODAwMDAwJyxcclxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsXHJcbiAgICAgICAgbWVkaXVtYmx1ZTogJyMwMDAwY2QnLFxyXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLFxyXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJyM5MzcwZDgnLFxyXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsXHJcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsXHJcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJyxcclxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICcjNDhkMWNjJyxcclxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JyxcclxuICAgICAgICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcclxuICAgICAgICBtaW50Y3JlYW06ICcjZjVmZmZhJyxcclxuICAgICAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJyxcclxuICAgICAgICBtb2NjYXNpbjogJyNmZmU0YjUnLFxyXG4gICAgICAgIG5hdmFqb3doaXRlOiAnI2ZmZGVhZCcsXHJcbiAgICAgICAgbmF2eTogJyMwMDAwODAnLFxyXG4gICAgICAgIG9sZGxhY2U6ICcjZmRmNWU2JyxcclxuICAgICAgICBvbGl2ZTogJyM4MDgwMDAnLFxyXG4gICAgICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLFxyXG4gICAgICAgIG9yYW5nZTogJyNmZmE1MDAnLFxyXG4gICAgICAgIG9yYW5nZXJlZDogJyNmZjQ1MDAnLFxyXG4gICAgICAgIG9yY2hpZDogJyNkYTcwZDYnLFxyXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJyxcclxuICAgICAgICBwYWxlZ3JlZW46ICcjOThmYjk4JyxcclxuICAgICAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsXHJcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJyNkODcwOTMnLFxyXG4gICAgICAgIHBhcGF5YXdoaXA6ICcjZmZlZmQ1JyxcclxuICAgICAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JyxcclxuICAgICAgICBwZXJ1OiAnI2NkODUzZicsXHJcbiAgICAgICAgcGluazogJyNmZmMwY2InLFxyXG4gICAgICAgIHBsdW06ICcjZGRhMGRkJyxcclxuICAgICAgICBwb3dkZXJibHVlOiAnI2IwZTBlNicsXHJcbiAgICAgICAgcHVycGxlOiAnIzgwMDA4MCcsXHJcbiAgICAgICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLFxyXG4gICAgICAgIHJlZDogJyNmZjAwMDAnLFxyXG4gICAgICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxyXG4gICAgICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLFxyXG4gICAgICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXHJcbiAgICAgICAgc2FsbW9uOiAnI2ZhODA3MicsXHJcbiAgICAgICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxyXG4gICAgICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXHJcbiAgICAgICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcclxuICAgICAgICBzaWVubmE6ICcjYTA1MjJkJyxcclxuICAgICAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcclxuICAgICAgICBza3libHVlOiAnIzg3Y2VlYicsXHJcbiAgICAgICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXHJcbiAgICAgICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXHJcbiAgICAgICAgc25vdzogJyNmZmZhZmEnLFxyXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsXHJcbiAgICAgICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXHJcbiAgICAgICAgdGFuOiAnI2QyYjQ4YycsXHJcbiAgICAgICAgdGVhbDogJyMwMDgwODAnLFxyXG4gICAgICAgIHRoaXN0bGU6ICcjZDhiZmQ4JyxcclxuICAgICAgICB0b21hdG86ICcjZmY2MzQ3JyxcclxuICAgICAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJyxcclxuICAgICAgICB2aW9sZXQ6ICcjZWU4MmVlJyxcclxuICAgICAgICB3aGVhdDogJyNmNWRlYjMnLFxyXG4gICAgICAgIHdoaXRlOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgd2hpdGVzbW9rZTogJyNmNWY1ZjUnLFxyXG4gICAgICAgIHllbGxvdzogJyNmZmZmMDAnLFxyXG4gICAgICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMicsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgY29sb3JzW2NvbG91ci50b0xvd2VyQ2FzZSgpXSAhPSAndW5kZWZpbmVkJykgcmV0dXJuIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgIHRoaXMuc2V0RnJvbUhleChuYW1lKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zZXRGcm9tSGV4KGNvbG91ck5hbWVUb0hleChuYW1lKSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGhleGFkZWNpbWFsIHZhbHVlIG9mIHRoaXMgY29sb3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gUmV0dXJucyB0aGUgaGV4IHZhbHVlLlxyXG4gICAqL1xyXG4gIHRvSGV4KCkge1xyXG4gICAgZnVuY3Rpb24gY29tcG9uZW50VG9IZXgoYykge1xyXG4gICAgICBjb25zdCBpbnQgPSBNYXRoLnJvdW5kKGMgKiAyNTUpXHJcbiAgICAgIGNvbnN0IGhleCA9IGludC50b1N0cmluZygxNilcclxuICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/ICcwJyArIGhleCA6IGhleFxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcjJyArIGNvbXBvbmVudFRvSGV4KHRoaXMucikgKyBjb21wb25lbnRUb0hleCh0aGlzLmcpICsgY29tcG9uZW50VG9IZXgodGhpcy5iKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sb3IgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBlcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuciA9PSBvdGhlci5yICYmIHRoaXMuZyA9PSBvdGhlci5nICYmIHRoaXMuYiA9PSBvdGhlci5iICYmIHRoaXMuYSA9PSBvdGhlci5hXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xvciBpcyBOT1QgZXhhY3RseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnIgIT0gb3RoZXIuciAmJiB0aGlzLmcgIT0gb3RoZXIuZyAmJiB0aGlzLmIgIT0gb3RoZXIuYiAmJiB0aGlzLmEgIT0gb3RoZXIuYVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sb3IgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJlY2lzaW9uIC0gVGhlIHByZWNpc2lvbiB0byB3aGljaCB0aGUgdmFsdWVzIG11c3QgbWF0Y2guXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuXHJcbiAgICovXHJcbiAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBNYXRoLmFicyh0aGlzLnIgLSBvdGhlci5yKSA8IHByZWNpc2lvbiAmJlxyXG4gICAgICBNYXRoLmFicyh0aGlzLmcgLSBvdGhlci5nKSA8IHByZWNpc2lvbiAmJlxyXG4gICAgICBNYXRoLmFicyh0aGlzLmIgLSBvdGhlci5iKSA8IHByZWNpc2lvbiAmJlxyXG4gICAgICBNYXRoLmFicyh0aGlzLmEgLSBvdGhlci5hKSA8IHByZWNpc2lvblxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBDb2xvciB3aGljaCBpcyB0aGlzIENvbG9yIGFkZGVkIHRvIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDb2xvcn0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuXHJcbiAgICovXHJcbiAgYWRkKG90aGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciArIG90aGVyLnIsIHRoaXMuZyArIG90aGVyLmcsIHRoaXMuYiArIG90aGVyLmIsIHRoaXMuYSArIG90aGVyLmEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHdoaWNoIGlzIHRoaXMgY29sb3Igc3VidHJhY3RlZCBmcm9tIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDb2xvcn0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gc3VidHJhY3QuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKi9cclxuICBzdWJ0cmFjdChvdGhlcikge1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIgLSBvdGhlci5yLCB0aGlzLmcgLSBvdGhlci5nLCB0aGlzLmIgLSBvdGhlci5iLCB0aGlzLmEgLSBvdGhlci5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NhbGVzIHRoaXMgY29sb3IgYnkgc2NhbGFyIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKi9cclxuICBzY2FsZShzY2FsYXIpIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yICogc2NhbGFyLCB0aGlzLmcgKiBzY2FsYXIsIHRoaXMuYiAqIHNjYWxhciwgdGhpcy5hICogc2NhbGFyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NhbGVzIHRoaXMgY29sb3IgYnkgc2NhbGFyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICovXHJcbiAgc2NhbGVJblBsYWNlKHNjYWxhcikge1xyXG4gICAgdGhpcy5yICo9IHNjYWxhclxyXG4gICAgdGhpcy5nICo9IHNjYWxhclxyXG4gICAgdGhpcy5iICo9IHNjYWxhclxyXG4gICAgdGhpcy5hICo9IHNjYWxhclxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgZ2FtbWEgY29ycmVjdGlvbiB0byB0aGlzIGNvbG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuXHJcbiAgICovXHJcbiAgYXBwbHlHYW1tYShnYW1tYSkge1xyXG4gICAgdGhpcy5zZXQoTWF0aC5wb3codGhpcy5yLCBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIGdhbW1hKSwgdGhpcy5hKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdG8gbGluZWFyIGNvbG9yIHNwYWNlIGFuZCByZXR1cm5zIGEgbmV3IGNvbG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKi9cclxuICB0b0xpbmVhcihnYW1tYSA9IDIuMikge1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcihNYXRoLnBvdyh0aGlzLnIsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5nLCBnYW1tYSksIE1hdGgucG93KHRoaXMuYiwgZ2FtbWEpLCB0aGlzLmEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyB0byBnYW1tYSBjb2xvciBzcGFjZSBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLlxyXG4gICAqL1xyXG4gIHRvR2FtbWEoZ2FtbWEgPSAyLjIpIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IoXHJcbiAgICAgIE1hdGgucG93KHRoaXMuciwgMS4wIC8gZ2FtbWEpLFxyXG4gICAgICBNYXRoLnBvdyh0aGlzLmcsIDEuMCAvIGdhbW1hKSxcclxuICAgICAgTWF0aC5wb3codGhpcy5iLCAxLjAgLyBnYW1tYSksXHJcbiAgICAgIHRoaXMuYVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcmVsYXRpdmUgbHVtaW5hbmNlIG9mIHRoZSBsaW5lYXIgUkdCIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGx1bWluYW5jZSgpIHtcclxuICAgIHJldHVybiAwLjIxMjYgKiB0aGlzLnIgKyAwLjcxNTIgKiB0aGlzLmcgKyAwLjA3MjIgKiB0aGlzLmJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGlzIGNvbG9yIGFuZCBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29sb3J9IG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGludGVycG9sYXRlIGJldHdlZW4uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLlxyXG4gICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuXHJcbiAgICovXHJcbiAgbGVycChvdGhlciwgdCkge1xyXG4gICAgY29uc3QgYXIgPSB0aGlzLnJcclxuICAgIGNvbnN0IGFnID0gdGhpcy5nXHJcbiAgICBjb25zdCBhYiA9IHRoaXMuYlxyXG4gICAgY29uc3QgYWEgPSB0aGlzLmFcclxuICAgIHJldHVybiBuZXcgQ29sb3IoYXIgKyB0ICogKG90aGVyLnIgLSBhciksIGFnICsgdCAqIChvdGhlci5nIC0gYWcpLCBhYiArIHQgKiAob3RoZXIuYiAtIGFiKSwgYWEgKyB0ICogKG90aGVyLmEgLSBhYSkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcmFuZG9tIGNvbG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGdhbW1hT2Zmc2V0IC0gVGhlIGdhbW1hIG9mZnNldC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJhbmRvbUFscGhhIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhbHBoYSBjaGFubmVsIGlzIHJhbmRvbS5cclxuICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgbmV3IHJhbmRvbSBjb2xvci5cclxuICAgKi9cclxuICBzdGF0aWMgcmFuZG9tKGdhbW1hT2Zmc2V0ID0gMC4wLCByYW5kb21BbHBoYSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoZ2FtbWFPZmZzZXQgPiAwLjApIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihcclxuICAgICAgICBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLFxyXG4gICAgICAgIGdhbW1hT2Zmc2V0ICsgTWF0aC5yYW5kb20oKSAqICgxLjAgLSBnYW1tYU9mZnNldCksXHJcbiAgICAgICAgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSxcclxuICAgICAgICByYW5kb21BbHBoYSA/IGdhbW1hT2Zmc2V0ICsgTWF0aC5yYW5kb20oKSAqICgxLjAgLSBnYW1tYU9mZnNldCkgOiAxLjBcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIGlmIChnYW1tYU9mZnNldCA8IDAuMCkge1xyXG4gICAgICByZXR1cm4gbmV3IENvbG9yKFxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLFxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLFxyXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLFxyXG4gICAgICAgIHJhbmRvbUFscGhhID8gTWF0aC5yYW5kb20oKSAqICgxLjAgKyBnYW1tYU9mZnNldCkgOiAxLjBcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgOiAxLjApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBjb2xvciBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0sIHRoaXMuX19kYXRhWzNdKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdHlwZSBhcyBhbiBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBSZXR1cm5zIGFzIGFuIGFycmF5LlxyXG4gICAqL1xyXG4gIGFzQXJyYXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBSZXR1cm5zIGFzIGEgMyBjb21wb25lbnQgYXJyYXkuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBhczNDb21wb25lbnRBcnJheSgpIHtcclxuICAgIHJldHVybiBbdGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXV1cclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbG9yLlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIG5ldyBjb2xvci5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGUoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvciguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBuZXcgY29sb3IuXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihidWZmZXIsIG9mZnNldCA9IDApIHtcclxuICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZCwgdXNlICNjcmVhdGVGcm9tQnVmZmVyIGluc3RlYWQnKVxyXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIG9mZnNldCAqIDQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgYENvbG9yYCB1c2luZyBhbiBBcnJheUJ1ZmZlci5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCkge1xyXG4gICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRmxvYXQzMiBlbGVtZW50cyB1c2VkIGJ5IHRoaXMgdHlwZS4gVXNlZCB0byBjYWxjdWxhdGUgc3RvcmFnZSByZXF1aXJlbWVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgbnVtRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gNFxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByOiB0aGlzLnIsXHJcbiAgICAgIGc6IHRoaXMuZyxcclxuICAgICAgYjogdGhpcy5iLFxyXG4gICAgICBhOiB0aGlzLmEsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaikge1xyXG4gICAgdGhpcy5yID0gai5yXHJcbiAgICB0aGlzLmcgPSBqLmdcclxuICAgIHRoaXMuYiA9IGouYlxyXG4gICAgdGhpcy5hID0gai5hXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIpIHtcclxuICAgIHRoaXMuciA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgICB0aGlzLmcgPSByZWFkZXIubG9hZEZsb2F0MzIoKVxyXG4gICAgdGhpcy5iID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICAgIHRoaXMuYSA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBDU1MgcmdiYSBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b0NTU1N0cmluZygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICdyZ2JhKCcgK1xyXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkgK1xyXG4gICAgICAnLCAnICtcclxuICAgICAgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpICtcclxuICAgICAgJywgJyArXHJcbiAgICAgIE1hdGgucm91bmQodGhpcy5iICogMjU1KSArXHJcbiAgICAgICcsICcgK1xyXG4gICAgICB0aGlzLmEgK1xyXG4gICAgICAnKSdcclxuICAgIClcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdDb2xvcicsIENvbG9yKVxyXG5cclxuZXhwb3J0IHsgQ29sb3IgfVxyXG4iLCJpbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBldWxlciBhbmdsZXMuIEV1bGVyIGFuZ2xlcyBkZXNjcmliZSByb3RhdGluZyBhbiBvYmplY3RcclxuICogYXJvdW5kIGl0cyB2YXJpb3VzIGF4aXMgaW4gYSBzcGVjaWZpZWQgYXhpcyBvcmRlci5cclxuICpcclxuICogQGV4dGVuZHMgQXR0clZhbHVlXHJcbiAqL1xyXG5jbGFzcyBFdWxlckFuZ2xlcyBleHRlbmRzIEF0dHJWYWx1ZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgZXVsZXIgYW5nbGUuIFJlY2VpdmVzIHRoZSB4eXogdmFsdWVzIGluIGRlZ3JlZXMgYW5kIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXHJcbiAgICogPGJyPlxyXG4gICAqIE9yZGVyIHBhcmFtZXRlciB2YWx1ZXM6IGBYWVo6IDBgLCBgWVpYOiAxYCwgYFpYWTogMmAsIGBYWlk6IDNgLCBgWllYOiA0YCwgYFlYWjogNWBcclxuICAgKiA8YnI+XHJcbiAgICogSXQgY291bGQgYmUgZWl0aGVyIHRoZSBgc3RyaW5nYCBvciB0aGUgYG51bWJlcmAgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBhbmdsZSBvZiB0aGUgeCBheGlzIGluIGRlZ3JlZXMuIERlZmF1bHQgaXMgMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBhbmdsZSBvZiB0aGUgeSBheGlzIGluIGRlZ3JlZXMuIERlZmF1bHQgaXMgMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geiAtIFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzIGluIGRlZ3JlZXMuIERlZmF1bHQgaXMgMC5cclxuICAgKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gb3JkZXIgLSBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCBvcmRlciA9IDApIHtcclxuICAgIHN1cGVyKClcclxuXHJcbiAgICBpZiAoIWlzTmFOKG9yZGVyKSkgdGhpcy5vcmRlciA9IG9yZGVyXHJcbiAgICBlbHNlIHtcclxuICAgICAgc3dpdGNoIChvcmRlcikge1xyXG4gICAgICAgIGNhc2UgJ1hZWic6XHJcbiAgICAgICAgICB0aGlzLm9yZGVyID0gMFxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICdZWlgnOlxyXG4gICAgICAgICAgdGhpcy5vcmRlciA9IDFcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnWlhZJzpcclxuICAgICAgICAgIHRoaXMub3JkZXIgPSAyXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ1haWSc6XHJcbiAgICAgICAgICB0aGlzLm9yZGVyID0gM1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICdaWVgnOlxyXG4gICAgICAgICAgdGhpcy5vcmRlciA9IDRcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnWVhaJzpcclxuICAgICAgICAgIHRoaXMub3JkZXIgPSA1XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXVsZXIgQW5nbGVzIE9yZGVyOicgKyBvcmRlcilcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICBjb25zdCBidWZmZXIgPSB4XHJcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5XHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMylcclxuICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4XHJcbiAgICAgIHRoaXMuX19kYXRhWzFdID0geVxyXG4gICAgICB0aGlzLl9fZGF0YVsyXSA9IHpcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgeCBheGlzIHJvdGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHggYXhpcyByb3RhdGlvbi5cclxuICAgKi9cclxuICBnZXQgeCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVswXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciB4IGF4aXMgcm90YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgeCh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzBdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHkgYXhpcyByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IGF4aXMgcm90YXRpb24uXHJcbiAgICovXHJcbiAgZ2V0IHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgeSBheGlzIHJvdGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHkodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB6IGF4aXMgcm90YXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeiBheGlzIHJvdGF0aW9uLlxyXG4gICAqL1xyXG4gIGdldCB6KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHogYXhpcyByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB6KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIEV1bGVyQW5nbGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGF4aXMgcm90YXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgIC0gVGhlIHkgYXhpcyByb3RhdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geiAgLSBUaGUgeiBheGlzIHJvdGF0aW9uLlxyXG4gICAqL1xyXG4gIHNldCh4LCB5LCB6KSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHhcclxuICAgIHRoaXMuX19kYXRhWzFdID0geVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB6XHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignRXVsZXJBbmdsZXMnLCBFdWxlckFuZ2xlcylcclxuXHJcbmV4cG9ydCB7IEV1bGVyQW5nbGVzIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xyXG5pbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4vVmVjMy5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgM3gzIG1hdHJpeC5cclxuICogVGhpcyBtYXRyaXggY2xhc3MgaXMgYmFzZWQgb24gR0xNLCBhbmQgaXMgY29sdW1uIG1ham9yLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyVmFsdWVcclxuICovXHJcbmNsYXNzIE1hdDMgZXh0ZW5kcyBBdHRyVmFsdWUge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoZSBNYXQzIGNsYXNzIHdpdGggZ2l2ZW4gZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgQXJyYXlCdWZmZXJ9IG0wMCAtIFJvdyAwLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTAxIC0gUm93IDAsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMDIgLSBSb3cgMCwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTExIC0gUm93IDEsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMCAtIFJvdyAyLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIxIC0gUm93IDIsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMjIgLSBSb3cgMiwgY29sdW1uIDIuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIGlmIChtMDAgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgbTAwIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSBtMDBcclxuICAgIH0gZWxzZSBpZiAobTAwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBEZXByZWNhdGVkLCBwbGVhc2UgdXNlIG5ldyBWZWMzKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA5KSlgKVxyXG4gICAgICBjb25zdCBidWZmZXIgPSBtMDBcclxuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IG0wMVxyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA5KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDkpXHJcbiAgICAgIHRoaXMuc2V0KG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIHByb3BlcnRpZXNcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDAuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0wMCB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTAwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMDAodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTAxIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMDEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0wMSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzFdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDIgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0wMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTAyKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0xMCB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTEwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzNdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMTAodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVszXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDFcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTEgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0xMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVs0XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTExKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbNF0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0xMiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTEyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzVdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMTIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVs1XSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTIwIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMjAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbNl1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAwLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0yMCh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzZdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMjEgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0yMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVs3XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTIxKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbN10gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDIsIGNvbHVtbiAyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTIyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzhdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMjIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVs4XSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgYHhgIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGB4YCBheGlzIGFzIGEgVmVjMy5cclxuICAgKi9cclxuICBnZXQgeEF4aXMoKSB7XHJcbiAgICByZXR1cm4gVmVjMy5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgMClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgdGhlIGB4YCBheGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0IHhBeGlzKHZlYzMpIHtcclxuICAgIHRoaXMueEF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy5cclxuICAgKiAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgYHlgIGF4aXMgYXMgYSBWZWMzLlxyXG4gICAqL1xyXG4gIGdldCB5QXhpcygpIHtcclxuICAgIHJldHVybiBWZWMzLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCAzICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldCB5QXhpcyh2ZWMzKSB7XHJcbiAgICB0aGlzLnlBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuXHJcbiAgICogKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGB6YCBheGlzIGFzIGEgVmVjMy5cclxuICAgKi9cclxuICBnZXQgekF4aXMoKSB7XHJcbiAgICByZXR1cm4gVmVjMy5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgNiAqIDQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgemAgYXhpcy5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXQgekF4aXModmVjMykge1xyXG4gICAgdGhpcy56QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueilcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gU2V0dGVyc1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgTWF0MyBjbGFzc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMCAtIFJvdyAwLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTAxIC0gUm93IDAsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMDIgLSBSb3cgMCwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTExIC0gUm93IDEsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMCAtIFJvdyAyLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIxIC0gUm93IDIsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMjIgLSBSb3cgMiwgY29sdW1uIDIuXHJcbiAgICovXHJcbiAgc2V0KG0wMCA9IDEsIG0wMSA9IDAsIG0wMiA9IDAsIG0xMCA9IDAsIG0xMSA9IDEsIG0xMiA9IDAsIG0yMCA9IDAsIG0yMSA9IDAsIG0yMiA9IDEpIHtcclxuICAgIHRoaXMuX19kYXRhWzBdID0gbTAwXHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IG0wMVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSBtMDJcclxuICAgIHRoaXMuX19kYXRhWzNdID0gbTEwXHJcbiAgICB0aGlzLl9fZGF0YVs0XSA9IG0xMVxyXG4gICAgdGhpcy5fX2RhdGFbNV0gPSBtMTJcclxuICAgIHRoaXMuX19kYXRhWzZdID0gbTIwXHJcbiAgICB0aGlzLl9fZGF0YVs3XSA9IG0yMVxyXG4gICAgdGhpcy5fX2RhdGFbOF0gPSBtMjJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDMgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeFxyXG4gICAqL1xyXG4gIHNldElkZW50aXR5KCkge1xyXG4gICAgdGhpcy5zZXQoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzdGF0ZSBvZiB0aGUgTWF0MyBmcm9tIGFub3RoZXIgTWF0M1xyXG4gICAqIDxicj5cclxuICAgKiBOb3RlOiB3b3JrcyB3aXRoIGVpdGhlciBNYXQzIG9yIE1hdDQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01hdDN9IG1hdCAtIFRoZSBtYXQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RnJvbU1hdChtYXQpIHtcclxuICAgIHRoaXMuX19kYXRhWzBdID0gbWF0Lm0wMFxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBtYXQubTAxXHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IG1hdC5tMDJcclxuICAgIHRoaXMuX19kYXRhWzNdID0gbWF0Lm0xMFxyXG4gICAgdGhpcy5fX2RhdGFbNF0gPSBtYXQubTExXHJcbiAgICB0aGlzLl9fZGF0YVs1XSA9IG1hdC5tMTJcclxuICAgIHRoaXMuX19kYXRhWzZdID0gbWF0Lm0yMFxyXG4gICAgdGhpcy5fX2RhdGFbN10gPSBtYXQubTIxXHJcbiAgICB0aGlzLl9fZGF0YVs4XSA9IG1hdC5tMjJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjYWxlcyBhbmQgY2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgYFZlYzNgIGFuZCBzZXRzIHRoZSByZXN1bHQgaW4gdGhlIE1hdDNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gZGlyIC0gVGhlIGRpciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IHVwIC0gVGhlIHVwIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3RvcihkaXIsIHVwKSB7XHJcbiAgICBjb25zdCB6QXhpcyA9IGRpclxyXG4gICAgY29uc3QgekxlbiA9IHpBeGlzLmxlbmd0aCgpXHJcbiAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHRoaXMuc2V0SWRlbnRpdHkoKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxIC8gekxlbilcclxuXHJcbiAgICBjb25zdCB4QXhpcyA9IHVwLmNyb3NzKHpBeGlzKVxyXG4gICAgY29uc3QgeExlbiA9IHhBeGlzLmxlbmd0aCgpXHJcbiAgICBpZiAoeExlbiA+IE51bWJlci5FUFNJTE9OKSB4QXhpcy5zY2FsZUluUGxhY2UoMSAvIHhMZW4pXHJcblxyXG4gICAgY29uc3QgeUF4aXMgPSB6QXhpcy5jcm9zcyh4QXhpcylcclxuICAgIGNvbnN0IHlMZW4gPSB5QXhpcy5sZW5ndGgoKVxyXG4gICAgaWYgKHlMZW4gPiBOdW1iZXIuRVBTSUxPTikgeUF4aXMuc2NhbGVJblBsYWNlKDEgLyB5TGVuKVxyXG5cclxuICAgIHRoaXMuc2V0KHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIHlBeGlzLngsIHlBeGlzLnksIHlBeGlzLnosIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZlcnRzIGEgTWF0MyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuXHJcbiAgICovXHJcbiAgaW52ZXJzZSgpIHtcclxuICAgIGNvbnN0IGEwMCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCBhMDEgPSB0aGlzLl9fZGF0YVsxXVxyXG4gICAgY29uc3QgYTAyID0gdGhpcy5fX2RhdGFbMl1cclxuICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs0XVxyXG4gICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNV1cclxuICAgIGNvbnN0IGEyMCA9IHRoaXMuX19kYXRhWzZdXHJcbiAgICBjb25zdCBhMjEgPSB0aGlzLl9fZGF0YVs3XVxyXG4gICAgY29uc3QgYTIyID0gdGhpcy5fX2RhdGFbOF1cclxuICAgIGNvbnN0IGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMVxyXG4gICAgY29uc3QgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMFxyXG4gICAgY29uc3QgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICBjb25zdCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjFcclxuXHJcbiAgICBpZiAoIWRldCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBpbnZlcnQgTWF0MycpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgICBkZXQgPSAxLjAgLyBkZXRcclxuXHJcbiAgICByZXR1cm4gbmV3IE1hdDMoXHJcbiAgICAgIGIwMSAqIGRldCxcclxuICAgICAgKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0LFxyXG4gICAgICAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldCxcclxuICAgICAgYjExICogZGV0LFxyXG4gICAgICAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldCxcclxuICAgICAgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0LFxyXG4gICAgICBiMjEgKiBkZXQsXHJcbiAgICAgICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldCxcclxuICAgICAgKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXRcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludmVydHMgYSBNYXQzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGludmVydEluUGxhY2UoKSB7XHJcbiAgICBjb25zdCBhMDAgPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCBhMTAgPSB0aGlzLl9fZGF0YVszXVxyXG4gICAgY29uc3QgYTExID0gdGhpcy5fX2RhdGFbNF1cclxuICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzVdXHJcbiAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs2XVxyXG4gICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbN11cclxuICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzhdXHJcbiAgICBjb25zdCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjFcclxuICAgIGNvbnN0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjBcclxuICAgIGNvbnN0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMFxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxyXG4gICAgY29uc3QgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxXHJcblxyXG4gICAgaWYgKCFkZXQpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDMnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGRldCA9IDEuMCAvIGRldFxyXG5cclxuICAgIHRoaXMuc2V0KFxyXG4gICAgICBiMDEgKiBkZXQsXHJcbiAgICAgICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldCxcclxuICAgICAgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQsXHJcbiAgICAgIGIxMSAqIGRldCxcclxuICAgICAgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQsXHJcbiAgICAgICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldCxcclxuICAgICAgYjIxICogZGV0LFxyXG4gICAgICAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQsXHJcbiAgICAgIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0XHJcbiAgICApXHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNwb3NlcyAoZXhjaGFuZ2VzIGNvbHVtbnMgd2l0aCByb3dzKSB0aGlzIG1hdHJpeFxyXG4gICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNYXQzfSAtIFJldHVybiBhIG5ldyB0cmFuc3Bvc2VkIE1hdDMuXHJcbiAgICovXHJcbiAgdHJhbnNwb3NlKCkge1xyXG4gICAgcmV0dXJuIE1hdDMoXHJcbiAgICAgIHRoaXMuX19kYXRhWzBdLFxyXG4gICAgICB0aGlzLl9fZGF0YVszXSxcclxuICAgICAgdGhpcy5fX2RhdGFbNl0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzFdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs0XSxcclxuICAgICAgdGhpcy5fX2RhdGFbN10sXHJcbiAgICAgIHRoaXMuX19kYXRhWzJdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs1XSxcclxuICAgICAgdGhpcy5fX2RhdGFbOF1cclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXguXHJcbiAgICovXHJcbiAgdHJhbnNwb3NlSW5QbGFjZSgpIHtcclxuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcclxuICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNV1cclxuXHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IHRoaXMuX19kYXRhWzZdXHJcbiAgICB0aGlzLl9fZGF0YVszXSA9IGEwMVxyXG4gICAgdGhpcy5fX2RhdGFbNV0gPSB0aGlzLl9fZGF0YVs3XVxyXG4gICAgdGhpcy5fX2RhdGFbNl0gPSBhMDJcclxuICAgIHRoaXMuX19kYXRhWzddID0gYTEyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIHRoZSBWZWMzIHdpdGggYSBNYXQzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLlxyXG4gICAqL1xyXG4gIHRyYW5zZm9ybVZlYzModmVjMykge1xyXG4gICAgcmV0dXJuIG5ldyBWZWMzKFxyXG4gICAgICB0aGlzLl9fZGF0YVswXSAqIHZlYzMueCArIHRoaXMuX19kYXRhWzFdICogdmVjMy55ICsgdGhpcy5fX2RhdGFbMl0gKiB2ZWMzLnosXHJcbiAgICAgIHRoaXMuX19kYXRhWzNdICogdmVjMy54ICsgdGhpcy5fX2RhdGFbNF0gKiB2ZWMzLnkgKyB0aGlzLl9fZGF0YVs1XSAqIHZlYzMueixcclxuICAgICAgdGhpcy5fX2RhdGFbNl0gKiB2ZWMzLnggKyB0aGlzLl9fZGF0YVs3XSAqIHZlYzMueSArIHRoaXMuX19kYXRhWzhdICogdmVjMy56XHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBNYXQzIHJldHVybmluZyBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01hdDN9IC0gUmV0dXJucyBhIG5ldyBNYXQzLlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBNYXQzKFxyXG4gICAgICB0aGlzLl9fZGF0YVswXSxcclxuICAgICAgdGhpcy5fX2RhdGFbMV0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzJdLFxyXG4gICAgICB0aGlzLl9fZGF0YVszXSxcclxuICAgICAgdGhpcy5fX2RhdGFbNF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzVdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs2XSxcclxuICAgICAgdGhpcy5fX2RhdGFbN10sXHJcbiAgICAgIHRoaXMuX19kYXRhWzhdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs5XVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBNYXQzLlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgTWF0MyguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBNYXQzIHRvIHdyYXAgZXhpc3RpbmcgbWVtb3J5IGluIGEgYnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtNYXQzfSAtIFJldHVybnMgYSBuZXcgTWF0My5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpXHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgTWF0M2AgdXNpbmcgYW4gQXJyYXlCdWZmZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gbmV3IE1hdDMobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDkpKSAvLyA0IGJ5dGVzIHBlciAzMmJpdCBmbG9hdFxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlYWRCaW5hcnkocmVhZGVyKSB7XHJcbiAgICB0aGlzLl9fZGF0YSA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KDkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUganNvbiBwYXJhbS5cclxuICAgKi9cclxuICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoanNvbilcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIERlYnVnZ2luZ1xyXG5cclxuICAvKipcclxuICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b0pTT04oKS50b1N0cmluZygpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignTWF0MycsIE1hdDMpXHJcblxyXG5leHBvcnQgeyBNYXQzIH1cclxuIiwiaW1wb3J0IHsgQXR0clZhbHVlIH0gZnJvbSAnLi9BdHRyVmFsdWUuanMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCB7IE1hdDMgfSBmcm9tICcuL01hdDMuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIDR4NCBtYXRyaXguXHJcbiAqIFRoaXMgbWF0cml4IGNsYXNzIGlzIGJhc2VkIG9uIEdMTSwgYW5kIGlzIGNvbHVtbiBtYWpvci5cclxuICpcclxuICogQGV4dGVuZHMgQXR0clZhbHVlXHJcbiAqL1xyXG5jbGFzcyBNYXQ0IGV4dGVuZHMgQXR0clZhbHVlIHtcclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyB0aGUgTWF0MyBjbGFzcyB3aXRoIGdpdmVuIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlciB8IEZsb2F0MzJBcnJheSB8IEFycmF5QnVmZmVyfSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMSAtIFJvdyAwLCBjb2x1bW4gMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMDMgLSBSb3cgMCwgY29sdW1uIDMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTExIC0gUm93IDEsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMyAtIFJvdyAxLCBjb2x1bW4gMy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIwIC0gUm93IDIsIGNvbHVtbiAwLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMjEgLSBSb3cgMiwgY29sdW1uIDEuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMiAtIFJvdyAyLCBjb2x1bW4gMi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIzIC0gUm93IDIsIGNvbHVtbiAzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMzAgLSBSb3cgMywgY29sdW1uIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMSAtIFJvdyAzLCBjb2x1bW4gMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTMyIC0gUm93IDMsIGNvbHVtbiAyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMzMgLSBSb3cgMywgY29sdW1uIDMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBtMDAgPSAxLFxyXG4gICAgbTAxID0gMCxcclxuICAgIG0wMiA9IDAsXHJcbiAgICBtMDMgPSAwLFxyXG4gICAgbTEwID0gMCxcclxuICAgIG0xMSA9IDEsXHJcbiAgICBtMTIgPSAwLFxyXG4gICAgbTEzID0gMCxcclxuICAgIG0yMCA9IDAsXHJcbiAgICBtMjEgPSAwLFxyXG4gICAgbTIyID0gMSxcclxuICAgIG0yMyA9IDAsXHJcbiAgICBtMzAgPSAwLFxyXG4gICAgbTMxID0gMCxcclxuICAgIG0zMiA9IDAsXHJcbiAgICBtMzMgPSAxXHJcbiAgKSB7XHJcbiAgICBzdXBlcigpXHJcblxyXG4gICAgaWYgKG0wMCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG0wMFxyXG4gICAgfSBlbHNlIGlmIChtMDAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICBjb25zdCBidWZmZXIgPSBtMDBcclxuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IG0wMVxyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAxNilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxNilcclxuICAgICAgdGhpcy5zZXQobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBwcm9wZXJ0aWVzXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAwLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0wMCB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTAwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMDAodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTAxIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMDEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0wMSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzFdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMDIgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0wMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTAyKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0wMyB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTAzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzNdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMDModmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVszXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTEwIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMTAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbNF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0xMCh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzRdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMTEgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0xMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVs1XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTExKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbNV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0xMiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTEyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzZdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMTIodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVs2XSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTEzIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMTMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbN11cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0xMyh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzddID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMjAgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0yMCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVs4XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTIwKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbOF0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDIsIGNvbHVtbiAxLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0yMSB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTIxKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzldXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0yMSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzldID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMjIgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0yMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsxMF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0yMih2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzEwXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTIzIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMjMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTFdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMjModmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsxMV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDMsIGNvbHVtbiAwXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTMwIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMzAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTJdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMzAodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsxMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3Igcm93IDMsIGNvbHVtbiAxLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG0zMSB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbTMxKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzEzXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciByb3cgMywgY29sdW1uIDEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgbTMxKHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMTNdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBtMzIgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IG0zMigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsxNF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3Igcm93IDMsIGNvbHVtbiAyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IG0zMih2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzE0XSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciByb3cgMywgY29sdW1uIDMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbTMzIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBtMzMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTVdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCBtMzModmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVsxNV0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgdGhlIGB4YCBheGlzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBgeGAgYXhpcyBhcyBhIFZlYzMuXHJcbiAgICovXHJcbiAgZ2V0IHhBeGlzKCkge1xyXG4gICAgcmV0dXJuIFZlYzMuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsIDApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldCB4QXhpcyh2ZWMzKSB7XHJcbiAgICB0aGlzLnhBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgYHlgIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGB5YCBheGlzIGFzIGEgVmVjMy5cclxuICAgKi9cclxuICBnZXQgeUF4aXMoKSB7XHJcbiAgICByZXR1cm4gVmVjMy5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgNCAqIDQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldCB5QXhpcyh2ZWMzKSB7XHJcbiAgICB0aGlzLnlBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIGB6YCBheGlzIGFzIGEgVmVjMy5cclxuICAgKi9cclxuICBnZXQgekF4aXMoKSB7XHJcbiAgICByZXR1cm4gVmVjMy5jcmVhdGVGcm9tQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwgOCAqIDQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgemAgYXhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldCB6QXhpcyh2ZWMzKSB7XHJcbiAgICB0aGlzLnpBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIG1hdHJpeC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICovXHJcbiAgZ2V0IHRyYW5zbGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIFZlYzMuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsIDEyICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzMgLSBUaGUgdHJhbnNsYXRpb24uXHJcbiAgICovXHJcbiAgc2V0IHRyYW5zbGF0aW9uKHZlYzMpIHtcclxuICAgIHRoaXMudHJhbnNsYXRpb24uc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFNldHRlcnNcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0wMSAtIFJvdyAwLCBjb2x1bW4gMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMDMgLSBSb3cgMCwgY29sdW1uIDMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMCAtIFJvdyAxLCBjb2x1bW4gMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTExIC0gUm93IDEsIGNvbHVtbiAxLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0xMyAtIFJvdyAxLCBjb2x1bW4gMy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIwIC0gUm93IDIsIGNvbHVtbiAwLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMjEgLSBSb3cgMiwgY29sdW1uIDEuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0yMiAtIFJvdyAyLCBjb2x1bW4gMi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTIzIC0gUm93IDIsIGNvbHVtbiAzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMzAgLSBSb3cgMywgY29sdW1uIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0zMSAtIFJvdyAzLCBjb2x1bW4gMS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbTMyIC0gUm93IDMsIGNvbHVtbiAyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtMzMgLSBSb3cgMywgY29sdW1uIDMuXHJcbiAgICovXHJcbiAgc2V0KFxyXG4gICAgbTAwID0gMSxcclxuICAgIG0wMSA9IDAsXHJcbiAgICBtMDIgPSAwLFxyXG4gICAgbTAzID0gMCxcclxuICAgIG0xMCA9IDAsXHJcbiAgICBtMTEgPSAxLFxyXG4gICAgbTEyID0gMCxcclxuICAgIG0xMyA9IDAsXHJcbiAgICBtMjAgPSAwLFxyXG4gICAgbTIxID0gMCxcclxuICAgIG0yMiA9IDEsXHJcbiAgICBtMjMgPSAwLFxyXG4gICAgbTMwID0gMCxcclxuICAgIG0zMSA9IDAsXHJcbiAgICBtMzIgPSAwLFxyXG4gICAgbTMzID0gMVxyXG4gICkge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSBtMDBcclxuICAgIHRoaXMuX19kYXRhWzFdID0gbTAxXHJcbiAgICB0aGlzLl9fZGF0YVsyXSA9IG0wMlxyXG4gICAgdGhpcy5fX2RhdGFbM10gPSBtMDNcclxuICAgIHRoaXMuX19kYXRhWzRdID0gbTEwXHJcbiAgICB0aGlzLl9fZGF0YVs1XSA9IG0xMVxyXG4gICAgdGhpcy5fX2RhdGFbNl0gPSBtMTJcclxuICAgIHRoaXMuX19kYXRhWzddID0gbTEzXHJcbiAgICB0aGlzLl9fZGF0YVs4XSA9IG0yMFxyXG4gICAgdGhpcy5fX2RhdGFbOV0gPSBtMjFcclxuICAgIHRoaXMuX19kYXRhWzEwXSA9IG0yMlxyXG4gICAgdGhpcy5fX2RhdGFbMTFdID0gbTIzXHJcbiAgICB0aGlzLl9fZGF0YVsxMl0gPSBtMzBcclxuICAgIHRoaXMuX19kYXRhWzEzXSA9IG0zMVxyXG4gICAgdGhpcy5fX2RhdGFbMTRdID0gbTMyXHJcbiAgICB0aGlzLl9fZGF0YVsxNV0gPSBtMzNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeFxyXG4gICAqL1xyXG4gIHNldElkZW50aXR5KCkge1xyXG4gICAgdGhpcy5zZXQoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgT2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJBcnJheSAtIFRoZSBmbG9hdDMyQXJyYXkgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RGF0YUFycmF5KGZsb2F0MzJBcnJheSkge1xyXG4gICAgdGhpcy5fX2RhdGEgPSBmbG9hdDMyQXJyYXlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgZnJvbSBhbm90aGVyIE1hdDRcclxuICAgKiA8YnI+XHJcbiAgICogTm90ZTogd29ya3Mgd2l0aCBlaXRoZXIgTWF0MyBvciBNYXQ0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNYXQ0fSBtYXQ0IC0gVGhlIG1hdDQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RnJvbU1hdDQobWF0NCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSBtYXQ0Lm0wMFxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBtYXQ0Lm0wMVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSBtYXQ0Lm0wMlxyXG4gICAgdGhpcy5fX2RhdGFbM10gPSBtYXQ0Lm0wM1xyXG4gICAgdGhpcy5fX2RhdGFbNF0gPSBtYXQ0Lm0xMFxyXG4gICAgdGhpcy5fX2RhdGFbNV0gPSBtYXQ0Lm0xMVxyXG4gICAgdGhpcy5fX2RhdGFbNl0gPSBtYXQ0Lm0xMlxyXG4gICAgdGhpcy5fX2RhdGFbN10gPSBtYXQ0Lm0xM1xyXG4gICAgdGhpcy5fX2RhdGFbOF0gPSBtYXQ0Lm0yMFxyXG4gICAgdGhpcy5fX2RhdGFbOV0gPSBtYXQ0Lm0yMVxyXG4gICAgdGhpcy5fX2RhdGFbMTBdID0gbWF0NC5tMjJcclxuICAgIHRoaXMuX19kYXRhWzExXSA9IG1hdDQubTIzXHJcbiAgICB0aGlzLl9fZGF0YVsxMl0gPSBtYXQ0Lm0zMFxyXG4gICAgdGhpcy5fX2RhdGFbMTNdID0gbWF0NC5tMzFcclxuICAgIHRoaXMuX19kYXRhWzE0XSA9IG1hdDQubTMyXHJcbiAgICB0aGlzLl9fZGF0YVsxNV0gPSBtYXQ0Lm0zM1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBNYXQ0IHRvIGEgTWF0My5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBNYXQ0IHZhbHVlIHRvIGNvbnZlcnQuXHJcbiAgICogQHJldHVybiB7TWF0M30gLSBSZXR1cm5zIGEgbmV3IE1hdDMuXHJcbiAgICovXHJcbiAgdG9NYXQzKG1hdDQpIHtcclxuICAgIHJldHVybiBuZXcgTWF0MyhcclxuICAgICAgdGhpcy5fX2RhdGFbMF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzFdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsyXSxcclxuICAgICAgdGhpcy5fX2RhdGFbNF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzVdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs2XSxcclxuICAgICAgdGhpcy5fX2RhdGFbOF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzldLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxMF1cclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXguXHJcbiAgICovXHJcbiAgdHJhbnNwb3NlSW5QbGFjZSgpIHtcclxuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcclxuICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM11cclxuICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzZdXHJcbiAgICBjb25zdCBhMTMgPSB0aGlzLl9fZGF0YVs3XVxyXG4gICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdXHJcblxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSB0aGlzLl9fZGF0YVs0XVxyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB0aGlzLl9fZGF0YVs4XVxyXG4gICAgdGhpcy5fX2RhdGFbM10gPSB0aGlzLl9fZGF0YVsxMl1cclxuICAgIHRoaXMuX19kYXRhWzRdID0gYTAxXHJcbiAgICB0aGlzLl9fZGF0YVs2XSA9IHRoaXMuX19kYXRhWzldXHJcbiAgICB0aGlzLl9fZGF0YVs3XSA9IHRoaXMuX19kYXRhWzEzXVxyXG4gICAgdGhpcy5fX2RhdGFbOF0gPSBhMDJcclxuICAgIHRoaXMuX19kYXRhWzldID0gYTEyXHJcbiAgICB0aGlzLl9fZGF0YVsxMV0gPSB0aGlzLl9fZGF0YVsxNF1cclxuICAgIHRoaXMuX19kYXRhWzEyXSA9IGEwM1xyXG4gICAgdGhpcy5fX2RhdGFbMTNdID0gYTEzXHJcbiAgICB0aGlzLl9fZGF0YVsxNF0gPSBhMjNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXhcclxuICAgKiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm4gYSBuZXcgdHJhbnNwb3NlZCBNYXQ0LlxyXG4gICAqL1xyXG4gIHRyYW5zcG9zZSgpIHtcclxuICAgIHJldHVybiBuZXcgTWF0NChcclxuICAgICAgdGhpcy5fX2RhdGFbMF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzRdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs4XSxcclxuICAgICAgdGhpcy5fX2RhdGFbMTJdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxXSxcclxuICAgICAgdGhpcy5fX2RhdGFbNV0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzldLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxM10sXHJcbiAgICAgIHRoaXMuX19kYXRhWzJdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs2XSxcclxuICAgICAgdGhpcy5fX2RhdGFbMTBdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxNF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzNdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs3XSxcclxuICAgICAgdGhpcy5fX2RhdGFbMTFdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxNV1cclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludmVydHMgYSBNYXQ0IG5vdCB1c2luZyBTSU1EIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC5cclxuICAgKi9cclxuICBpbnZlcnNlKCkge1xyXG4gICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF1cclxuICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM11cclxuICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzRdXHJcbiAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs1XVxyXG4gICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl1cclxuICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddXHJcbiAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs4XVxyXG4gICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbOV1cclxuICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzEwXVxyXG4gICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdXHJcbiAgICBjb25zdCBhMzAgPSB0aGlzLl9fZGF0YVsxMl1cclxuICAgIGNvbnN0IGEzMSA9IHRoaXMuX19kYXRhWzEzXVxyXG4gICAgY29uc3QgYTMyID0gdGhpcy5fX2RhdGFbMTRdXHJcbiAgICBjb25zdCBhMzMgPSB0aGlzLl9fZGF0YVsxNV1cclxuXHJcbiAgICBjb25zdCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTBcclxuICAgIGNvbnN0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMFxyXG4gICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwXHJcbiAgICBjb25zdCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTFcclxuICAgIGNvbnN0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMVxyXG4gICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyXHJcbiAgICBjb25zdCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzBcclxuICAgIGNvbnN0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMFxyXG4gICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwXHJcbiAgICBjb25zdCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzFcclxuICAgIGNvbnN0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMVxyXG4gICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxyXG4gICAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNlxyXG5cclxuICAgIGlmICghZGV0KSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQ0JylcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICAgIGRldCA9IDEuMCAvIGRldFxyXG5cclxuICAgIHJldHVybiBuZXcgTWF0NChcclxuICAgICAgKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQsXHJcbiAgICAgIChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0LFxyXG4gICAgICAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldCxcclxuICAgICAgKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQsXHJcbiAgICAgIChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0LFxyXG4gICAgICAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldCxcclxuICAgICAgKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQsXHJcbiAgICAgIChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0LFxyXG4gICAgICAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldCxcclxuICAgICAgKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQsXHJcbiAgICAgIChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0LFxyXG4gICAgICAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldCxcclxuICAgICAgKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQsXHJcbiAgICAgIChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0LFxyXG4gICAgICAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldCxcclxuICAgICAgKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXRcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludmVydHMgYSBNYXQ0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGludmVydEluUGxhY2UoKSB7XHJcbiAgICBjb25zdCBhMDAgPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCBhMDMgPSB0aGlzLl9fZGF0YVszXVxyXG4gICAgY29uc3QgYTEwID0gdGhpcy5fX2RhdGFbNF1cclxuICAgIGNvbnN0IGExMSA9IHRoaXMuX19kYXRhWzVdXHJcbiAgICBjb25zdCBhMTIgPSB0aGlzLl9fZGF0YVs2XVxyXG4gICAgY29uc3QgYTEzID0gdGhpcy5fX2RhdGFbN11cclxuICAgIGNvbnN0IGEyMCA9IHRoaXMuX19kYXRhWzhdXHJcbiAgICBjb25zdCBhMjEgPSB0aGlzLl9fZGF0YVs5XVxyXG4gICAgY29uc3QgYTIyID0gdGhpcy5fX2RhdGFbMTBdXHJcbiAgICBjb25zdCBhMjMgPSB0aGlzLl9fZGF0YVsxMV1cclxuICAgIGNvbnN0IGEzMCA9IHRoaXMuX19kYXRhWzEyXVxyXG4gICAgY29uc3QgYTMxID0gdGhpcy5fX2RhdGFbMTNdXHJcbiAgICBjb25zdCBhMzIgPSB0aGlzLl9fZGF0YVsxNF1cclxuICAgIGNvbnN0IGEzMyA9IHRoaXMuX19kYXRhWzE1XVxyXG5cclxuICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMFxyXG4gICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwXHJcbiAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTBcclxuICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMVxyXG4gICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExXHJcbiAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTJcclxuICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMFxyXG4gICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwXHJcbiAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzBcclxuICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMVxyXG4gICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxXHJcbiAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzJcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2XHJcblxyXG4gICAgaWYgKCFkZXQpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDQnKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGRldCA9IDEuMCAvIGRldFxyXG5cclxuICAgIHRoaXMuc2V0KFxyXG4gICAgICAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCxcclxuICAgICAgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsXHJcbiAgICAgIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LFxyXG4gICAgICAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCxcclxuICAgICAgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsXHJcbiAgICAgIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LFxyXG4gICAgICAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCxcclxuICAgICAgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsXHJcbiAgICAgIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LFxyXG4gICAgICAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCxcclxuICAgICAgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsXHJcbiAgICAgIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LFxyXG4gICAgICAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCxcclxuICAgICAgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsXHJcbiAgICAgIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LFxyXG4gICAgICAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldFxyXG4gICAgKVxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIE1hdDQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01hdDR9IG1hdDQgLSBUaGUgbWF0NCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtudWxsfSAtIEluIGNhc2UgdGhlIGBkZXRlcm1pbmFudGAgY2FuJ3QgYmUgY2FsY3VsYXRlZCwgYSBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlLCBub3RoaW5nIGlzIHJldHVybmVkXHJcbiAgICovXHJcbiAgc2V0SW52ZXJzZShtYXQ0KSB7XHJcbiAgICBjb25zdCBhMDAgPSBtYXQ0Ll9fZGF0YVswXVxyXG4gICAgY29uc3QgYTAxID0gbWF0NC5fX2RhdGFbMV1cclxuICAgIGNvbnN0IGEwMiA9IG1hdDQuX19kYXRhWzJdXHJcbiAgICBjb25zdCBhMDMgPSBtYXQ0Ll9fZGF0YVszXVxyXG4gICAgY29uc3QgYTEwID0gbWF0NC5fX2RhdGFbNF1cclxuICAgIGNvbnN0IGExMSA9IG1hdDQuX19kYXRhWzVdXHJcbiAgICBjb25zdCBhMTIgPSBtYXQ0Ll9fZGF0YVs2XVxyXG4gICAgY29uc3QgYTEzID0gbWF0NC5fX2RhdGFbN11cclxuICAgIGNvbnN0IGEyMCA9IG1hdDQuX19kYXRhWzhdXHJcbiAgICBjb25zdCBhMjEgPSBtYXQ0Ll9fZGF0YVs5XVxyXG4gICAgY29uc3QgYTIyID0gbWF0NC5fX2RhdGFbMTBdXHJcbiAgICBjb25zdCBhMjMgPSBtYXQ0Ll9fZGF0YVsxMV1cclxuICAgIGNvbnN0IGEzMCA9IG1hdDQuX19kYXRhWzEyXVxyXG4gICAgY29uc3QgYTMxID0gbWF0NC5fX2RhdGFbMTNdXHJcbiAgICBjb25zdCBhMzIgPSBtYXQ0Ll9fZGF0YVsxNF1cclxuICAgIGNvbnN0IGEzMyA9IG1hdDQuX19kYXRhWzE1XVxyXG5cclxuICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMFxyXG4gICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwXHJcbiAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTBcclxuICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMVxyXG4gICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExXHJcbiAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTJcclxuICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMFxyXG4gICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwXHJcbiAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzBcclxuICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMVxyXG4gICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxXHJcbiAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzJcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2XHJcblxyXG4gICAgaWYgKCFkZXQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDQnKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gICAgZGV0ID0gMS4wIC8gZGV0XHJcblxyXG4gICAgdGhpcy5zZXQoXHJcbiAgICAgIChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0LFxyXG4gICAgICAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldCxcclxuICAgICAgKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQsXHJcbiAgICAgIChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0LFxyXG4gICAgICAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldCxcclxuICAgICAgKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQsXHJcbiAgICAgIChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0LFxyXG4gICAgICAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldCxcclxuICAgICAgKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQsXHJcbiAgICAgIChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0LFxyXG4gICAgICAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldCxcclxuICAgICAgKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQsXHJcbiAgICAgIChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0LFxyXG4gICAgICAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldCxcclxuICAgICAgKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQsXHJcbiAgICAgIChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0XHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHR3byBNYXQ0cyBub3QgdXNpbmcgU0lNRCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNYXQ0fSBvdGhlciAtIFRoZSBvdGhlciBNYXQ0IHRvIG11bHRpcGx5IHdpdGguXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuXHJcbiAgICovXHJcbiAgbXVsdGlwbHkob3RoZXIpIHtcclxuICAgIGNvbnN0IGEwMCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCBhMDEgPSB0aGlzLl9fZGF0YVsxXVxyXG4gICAgY29uc3QgYTAyID0gdGhpcy5fX2RhdGFbMl1cclxuICAgIGNvbnN0IGEwMyA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBjb25zdCBhMTAgPSB0aGlzLl9fZGF0YVs0XVxyXG4gICAgY29uc3QgYTExID0gdGhpcy5fX2RhdGFbNV1cclxuICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzZdXHJcbiAgICBjb25zdCBhMTMgPSB0aGlzLl9fZGF0YVs3XVxyXG4gICAgY29uc3QgYTIwID0gdGhpcy5fX2RhdGFbOF1cclxuICAgIGNvbnN0IGEyMSA9IHRoaXMuX19kYXRhWzldXHJcbiAgICBjb25zdCBhMjIgPSB0aGlzLl9fZGF0YVsxMF1cclxuICAgIGNvbnN0IGEyMyA9IHRoaXMuX19kYXRhWzExXVxyXG4gICAgY29uc3QgYTMwID0gdGhpcy5fX2RhdGFbMTJdXHJcbiAgICBjb25zdCBhMzEgPSB0aGlzLl9fZGF0YVsxM11cclxuICAgIGNvbnN0IGEzMiA9IHRoaXMuX19kYXRhWzE0XVxyXG4gICAgY29uc3QgYTMzID0gdGhpcy5fX2RhdGFbMTVdXHJcblxyXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XHJcbiAgICBjb25zdCBiID0gb3RoZXIuYXNBcnJheSgpXHJcbiAgICBsZXQgYjAgPSBiWzBdXHJcbiAgICBsZXQgYjEgPSBiWzFdXHJcbiAgICBsZXQgYjIgPSBiWzJdXHJcbiAgICBsZXQgYjMgPSBiWzNdXHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0NCgpXHJcbiAgICByZXN1bHQubTAwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzBcclxuICAgIHJlc3VsdC5tMDEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgcmVzdWx0Lm0wMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICByZXN1bHQubTAzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzNcclxuXHJcbiAgICBiMCA9IGJbNF1cclxuICAgIGIxID0gYls1XVxyXG4gICAgYjIgPSBiWzZdXHJcbiAgICBiMyA9IGJbN11cclxuICAgIHJlc3VsdC5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMFxyXG4gICAgcmVzdWx0Lm0xMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxXHJcbiAgICByZXN1bHQubTEyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzJcclxuICAgIHJlc3VsdC5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzM1xyXG5cclxuICAgIGIwID0gYls4XVxyXG4gICAgYjEgPSBiWzldXHJcbiAgICBiMiA9IGJbMTBdXHJcbiAgICBiMyA9IGJbMTFdXHJcbiAgICByZXN1bHQubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzBcclxuICAgIHJlc3VsdC5tMjEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgcmVzdWx0Lm0yMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICByZXN1bHQubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzNcclxuXHJcbiAgICBiMCA9IGJbMTJdXHJcbiAgICBiMSA9IGJbMTNdXHJcbiAgICBiMiA9IGJbMTRdXHJcbiAgICBiMyA9IGJbMTVdXHJcbiAgICByZXN1bHQubTMwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzBcclxuICAgIHJlc3VsdC5tMzEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgcmVzdWx0Lm0zMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICByZXN1bHQubTMzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzNcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgdHdvIE1hdDRzIGluIHBsYWNlIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTUQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01hdDR9IG90aGVyIC0gVGhlIG90aGVyIE1hdDQgdG8gbXVsdGlwbHkgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC5cclxuICAgKi9cclxuICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHtcclxuICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKVxyXG4gICAgY29uc3QgYTAwID0gYVswXVxyXG4gICAgY29uc3QgYTAxID0gYVsxXVxyXG4gICAgY29uc3QgYTAyID0gYVsyXVxyXG4gICAgY29uc3QgYTAzID0gYVszXVxyXG4gICAgY29uc3QgYTEwID0gYVs0XVxyXG4gICAgY29uc3QgYTExID0gYVs1XVxyXG4gICAgY29uc3QgYTEyID0gYVs2XVxyXG4gICAgY29uc3QgYTEzID0gYVs3XVxyXG4gICAgY29uc3QgYTIwID0gYVs4XVxyXG4gICAgY29uc3QgYTIxID0gYVs5XVxyXG4gICAgY29uc3QgYTIyID0gYVsxMF1cclxuICAgIGNvbnN0IGEyMyA9IGFbMTFdXHJcbiAgICBjb25zdCBhMzAgPSBhWzEyXVxyXG4gICAgY29uc3QgYTMxID0gYVsxM11cclxuICAgIGNvbnN0IGEzMiA9IGFbMTRdXHJcbiAgICBjb25zdCBhMzMgPSBhWzE1XVxyXG5cclxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxyXG4gICAgY29uc3QgYiA9IG90aGVyLmFzQXJyYXkoKVxyXG4gICAgbGV0IGIwID0gYlswXVxyXG4gICAgbGV0IGIxID0gYlsxXVxyXG4gICAgbGV0IGIyID0gYlsyXVxyXG4gICAgbGV0IGIzID0gYlszXVxyXG4gICAgdGhpcy5tMDAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMFxyXG4gICAgdGhpcy5tMDEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgdGhpcy5tMDIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMlxyXG4gICAgdGhpcy5tMDMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzM1xyXG5cclxuICAgIGIwID0gYls0XVxyXG4gICAgYjEgPSBiWzVdXHJcbiAgICBiMiA9IGJbNl1cclxuICAgIGIzID0gYls3XVxyXG4gICAgdGhpcy5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMFxyXG4gICAgdGhpcy5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgdGhpcy5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMlxyXG4gICAgdGhpcy5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzM1xyXG5cclxuICAgIGIwID0gYls4XVxyXG4gICAgYjEgPSBiWzldXHJcbiAgICBiMiA9IGJbMTBdXHJcbiAgICBiMyA9IGJbMTFdXHJcbiAgICB0aGlzLm0yMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwXHJcbiAgICB0aGlzLm0yMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxXHJcbiAgICB0aGlzLm0yMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICB0aGlzLm0yMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzXHJcblxyXG4gICAgYjAgPSBiWzEyXVxyXG4gICAgYjEgPSBiWzEzXVxyXG4gICAgYjIgPSBiWzE0XVxyXG4gICAgYjMgPSBiWzE1XVxyXG4gICAgdGhpcy5tMzAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMFxyXG4gICAgdGhpcy5tMzEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMVxyXG4gICAgdGhpcy5tMzIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMlxyXG4gICAgdGhpcy5tMzMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzM1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvc3QgbXVsdGlwbGllcyB0d28gTWF0NHMgaW4gcGxhY2UgZXhwbGljaXRseSBub3QgdXNpbmcgU0lNRC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWF0NH0gb3RoZXIgLSBUaGUgb3RoZXIgTWF0NCB0byBtdWx0aXBseSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge01hdDN9IC0gUmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IE1hdDQuXHJcbiAgICovXHJcbiAgcG9zdG11bHRpcGx5SW5QbGFjZShvdGhlcikge1xyXG4gICAgY29uc3QgYSA9IG90aGVyLmFzQXJyYXkoKVxyXG4gICAgY29uc3QgYTAwID0gYVswXVxyXG4gICAgY29uc3QgYTAxID0gYVsxXVxyXG4gICAgY29uc3QgYTAyID0gYVsyXVxyXG4gICAgY29uc3QgYTAzID0gYVszXVxyXG4gICAgY29uc3QgYTEwID0gYVs0XVxyXG4gICAgY29uc3QgYTExID0gYVs1XVxyXG4gICAgY29uc3QgYTEyID0gYVs2XVxyXG4gICAgY29uc3QgYTEzID0gYVs3XVxyXG4gICAgY29uc3QgYTIwID0gYVs4XVxyXG4gICAgY29uc3QgYTIxID0gYVs5XVxyXG4gICAgY29uc3QgYTIyID0gYVsxMF1cclxuICAgIGNvbnN0IGEyMyA9IGFbMTFdXHJcbiAgICBjb25zdCBhMzAgPSBhWzEyXVxyXG4gICAgY29uc3QgYTMxID0gYVsxM11cclxuICAgIGNvbnN0IGEzMiA9IGFbMTRdXHJcbiAgICBjb25zdCBhMzMgPSBhWzE1XVxyXG5cclxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxyXG4gICAgY29uc3QgYiA9IHRoaXMuYXNBcnJheSgpXHJcbiAgICBsZXQgYjAgPSBiWzBdXHJcbiAgICBsZXQgYjEgPSBiWzFdXHJcbiAgICBsZXQgYjIgPSBiWzJdXHJcbiAgICBsZXQgYjMgPSBiWzNdXHJcbiAgICB0aGlzLm0wMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwXHJcbiAgICB0aGlzLm0wMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxXHJcbiAgICB0aGlzLm0wMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICB0aGlzLm0wMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzXHJcblxyXG4gICAgYjAgPSBiWzRdXHJcbiAgICBiMSA9IGJbNV1cclxuICAgIGIyID0gYls2XVxyXG4gICAgYjMgPSBiWzddXHJcbiAgICB0aGlzLm0xMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwXHJcbiAgICB0aGlzLm0xMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxXHJcbiAgICB0aGlzLm0xMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICB0aGlzLm0xMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzXHJcblxyXG4gICAgYjAgPSBiWzhdXHJcbiAgICBiMSA9IGJbOV1cclxuICAgIGIyID0gYlsxMF1cclxuICAgIGIzID0gYlsxMV1cclxuICAgIHRoaXMubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzBcclxuICAgIHRoaXMubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzFcclxuICAgIHRoaXMubTIyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzJcclxuICAgIHRoaXMubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzNcclxuXHJcbiAgICBiMCA9IGJbMTJdXHJcbiAgICBiMSA9IGJbMTNdXHJcbiAgICBiMiA9IGJbMTRdXHJcbiAgICBiMyA9IGJbMTVdXHJcbiAgICB0aGlzLm0zMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwXHJcbiAgICB0aGlzLm0zMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxXHJcbiAgICB0aGlzLm0zMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyXHJcbiAgICB0aGlzLm0zMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNsYXRlIGEgTWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIG5vdCB1c2luZyBTSU1ELlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2MyAtIFRoZSBnaXZlbiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGFsb25nLlxyXG4gICAqIEByZXR1cm4ge01hdDR9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0cmFuc2xhdGVJblBsYWNlKHYzKSB7XHJcbiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGFcclxuICAgIGNvbnN0IHggPSB2My54XHJcbiAgICBjb25zdCB5ID0gdjMueVxyXG4gICAgY29uc3QgeiA9IHYzLnpcclxuICAgIGFbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl1cclxuICAgIGFbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM11cclxuICAgIGFbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdXHJcbiAgICBhWzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHBvcyAtIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXIuXHJcbiAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgLSBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXQuXHJcbiAgICogQHBhcmFtIHtWZWMzfSB1cCAtIFZlYzMgcG9pbnRpbmcgdXAuXHJcbiAgICovXHJcbiAgc2V0TG9va0F0KHBvcywgdGFyZ2V0LCB1cCkge1xyXG4gICAgY29uc3QgekF4aXMgPSBwb3Muc3VidHJhY3QodGFyZ2V0KVxyXG4gICAgY29uc3QgekxlbiA9IHpBeGlzLmxlbmd0aCgpXHJcbiAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHRoaXMuc2V0SWRlbnRpdHkoKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB6TGVuKVxyXG5cclxuICAgIGNvbnN0IHhBeGlzID0gdXAuY3Jvc3MoekF4aXMpXHJcbiAgICBjb25zdCB4TGVuID0geEF4aXMubGVuZ3RoKClcclxuICAgIGlmICh4TGVuID4gTnVtYmVyLkVQU0lMT04pIHhBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB4TGVuKVxyXG5cclxuICAgIGNvbnN0IHlBeGlzID0gekF4aXMuY3Jvc3MoeEF4aXMpXHJcbiAgICBjb25zdCB5TGVuID0geUF4aXMubGVuZ3RoKClcclxuICAgIGlmICh5TGVuID4gTnVtYmVyLkVQU0lMT04pIHlBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB5TGVuKVxyXG5cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICAgIHRoaXMuc2V0KFxyXG4gICAgICB4QXhpcy54LFxyXG4gICAgICB4QXhpcy55LFxyXG4gICAgICB4QXhpcy56LFxyXG4gICAgICAwLFxyXG4gICAgICB5QXhpcy54LFxyXG4gICAgICB5QXhpcy55LFxyXG4gICAgICB5QXhpcy56LFxyXG4gICAgICAwLFxyXG4gICAgICB6QXhpcy54LFxyXG4gICAgICB6QXhpcy55LFxyXG4gICAgICB6QXhpcy56LFxyXG4gICAgICAwLFxyXG4gICAgICBwb3MueCxcclxuICAgICAgcG9zLnksXHJcbiAgICAgIHBvcy56LFxyXG4gICAgICAxXHJcbiAgICApXHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXMuXHJcbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAgICpcclxuICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICAgKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gYXhpcyAtIFRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS5cclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0Um90YXRpb24oYXhpcywgcmFkKSB7XHJcbiAgICBjb25zdCBsZW4gPSBheGlzLmxlbmd0aCgpXHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHggPSBheGlzLnggLyBsZW5cclxuICAgIGNvbnN0IHkgPSBheGlzLnkgLyBsZW5cclxuICAgIGNvbnN0IHogPSBheGlzLnogLyBsZW5cclxuXHJcbiAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKVxyXG4gICAgY29uc3QgYyA9IE1hdGguY29zKHJhZClcclxuICAgIGNvbnN0IHQgPSAxIC0gY1xyXG5cclxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGFcclxuICAgIGFbMF0gPSB4ICogeCAqIHQgKyBjXHJcbiAgICBhWzFdID0geSAqIHggKiB0ICsgeiAqIHNcclxuICAgIGFbMl0gPSB6ICogeCAqIHQgLSB5ICogc1xyXG4gICAgYVszXSA9IDBcclxuICAgIGFbNF0gPSB4ICogeSAqIHQgLSB6ICogc1xyXG4gICAgYVs1XSA9IHkgKiB5ICogdCArIGNcclxuICAgIGFbNl0gPSB6ICogeSAqIHQgKyB4ICogc1xyXG4gICAgYVs3XSA9IDBcclxuICAgIGFbOF0gPSB4ICogeiAqIHQgKyB5ICogc1xyXG4gICAgYVs5XSA9IHkgKiB6ICogdCAtIHggKiBzXHJcbiAgICBhWzEwXSA9IHogKiB6ICogdCArIGNcclxuICAgIGFbMTFdID0gMFxyXG4gICAgYVsxMl0gPSAwXHJcbiAgICBhWzEzXSA9IDBcclxuICAgIGFbMTRdID0gMFxyXG4gICAgYVsxNV0gPSAxXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcy5cclxuICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICAgKlxyXG4gICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gICAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgLSBUaGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnkuXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFhSb3RhdGlvbihyYWQpIHtcclxuICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyYWQpXHJcbiAgICBjb25zdCBjID0gTWF0aC5jb3MocmFkKVxyXG5cclxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YVxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gICAgYVswXSA9IDFcclxuICAgIGFbMV0gPSAwXHJcbiAgICBhWzJdID0gMFxyXG4gICAgYVszXSA9IDBcclxuICAgIGFbNF0gPSAwXHJcbiAgICBhWzVdID0gY1xyXG4gICAgYVs2XSA9IHNcclxuICAgIGFbN10gPSAwXHJcbiAgICBhWzhdID0gMFxyXG4gICAgYVs5XSA9IC1zXHJcbiAgICBhWzEwXSA9IGNcclxuICAgIGFbMTFdID0gMFxyXG4gICAgYVsxMl0gPSAwXHJcbiAgICBhWzEzXSA9IDBcclxuICAgIGFbMTRdID0gMFxyXG4gICAgYVsxNV0gPSAxXHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLlxyXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gICAqXHJcbiAgICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAgICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS5cclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0WVJvdGF0aW9uKHJhZCkge1xyXG4gICAgY29uc3QgcyA9IE1hdGguc2luKHJhZClcclxuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyYWQpXHJcblxyXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAgY29uc3QgYSA9IHRoaXMuX19kYXRhXHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovXHJcbiAgICBhWzBdID0gY1xyXG4gICAgYVsxXSA9IDBcclxuICAgIGFbMl0gPSAtc1xyXG4gICAgYVszXSA9IDBcclxuICAgIGFbNF0gPSAwXHJcbiAgICBhWzVdID0gMVxyXG4gICAgYVs2XSA9IDBcclxuICAgIGFbN10gPSAwXHJcbiAgICBhWzhdID0gc1xyXG4gICAgYVs5XSA9IDBcclxuICAgIGFbMTBdID0gY1xyXG4gICAgYVsxMV0gPSAwXHJcbiAgICBhWzEyXSA9IDBcclxuICAgIGFbMTNdID0gMFxyXG4gICAgYVsxNF0gPSAwXHJcbiAgICBhWzE1XSA9IDFcclxuICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMuXHJcbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAgICpcclxuICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICAgKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5LlxyXG4gICAqIEByZXR1cm4ge01hdDR9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRaUm90YXRpb24ocmFkKSB7XHJcbiAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKVxyXG4gICAgY29uc3QgYyA9IE1hdGguY29zKHJhZClcclxuXHJcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICBjb25zdCBhID0gdGhpcy5fX2RhdGFcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICAgIGFbMF0gPSBjXHJcbiAgICBhWzFdID0gc1xyXG4gICAgYVsyXSA9IDBcclxuICAgIGFbM10gPSAwXHJcbiAgICBhWzRdID0gLXNcclxuICAgIGFbNV0gPSBjXHJcbiAgICBhWzZdID0gMFxyXG4gICAgYVs3XSA9IDBcclxuICAgIGFbOF0gPSAwXHJcbiAgICBhWzldID0gMFxyXG4gICAgYVsxMF0gPSAxXHJcbiAgICBhWzExXSA9IDBcclxuICAgIGFbMTJdID0gMFxyXG4gICAgYVsxM10gPSAwXHJcbiAgICBhWzE0XSA9IDBcclxuICAgIGFbMTVdID0gMVxyXG4gICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyB0aGUgVmVjNCB3aXRoIGEgTWF0NC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjNH0gdmVjIC0gVGhlIHZlYyB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWM0fSAtIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuXHJcbiAgICovXHJcbiAgdHJhbnNmb3JtVmVjNCh2ZWMpIHtcclxuICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YVxyXG4gICAgY29uc3QgeCA9IHZlYy54XHJcbiAgICBjb25zdCB5ID0gdmVjLnlcclxuICAgIGNvbnN0IHogPSB2ZWMuelxyXG4gICAgY29uc3QgdyA9IHZlYy50XHJcbiAgICByZXR1cm4gbmV3IFZlYzQoXHJcbiAgICAgIGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdICogdyxcclxuICAgICAgYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM10gKiB3LFxyXG4gICAgICBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF0gKiB3LFxyXG4gICAgICBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV0gKiB3XHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIHRoZSBWZWMzIHdpdGggYSBNYXQ0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2ZWMgLSBUaGUgdmVjIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICB0cmFuc2Zvcm1WZWMzKHZlYykge1xyXG4gICAgY29uc3QgYSA9IHRoaXMuX19kYXRhXHJcbiAgICBjb25zdCB4ID0gdmVjLnhcclxuICAgIGNvbnN0IHkgPSB2ZWMueVxyXG4gICAgY29uc3QgeiA9IHZlYy56XHJcbiAgICByZXR1cm4gbmV3IFZlYzMoXHJcbiAgICAgIGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdLFxyXG4gICAgICBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXSxcclxuICAgICAgYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSb3RhdGVzIGEgZ2l2ZW4gYFZlYzNgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGEgbmV3IGBWZWMzYFxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjIC0gVGhlIHZlYyB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuXHJcbiAgICovXHJcbiAgcm90YXRlVmVjMyh2ZWMpIHtcclxuICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YVxyXG4gICAgY29uc3QgeCA9IHZlYy54XHJcbiAgICBjb25zdCB5ID0gdmVjLnlcclxuICAgIGNvbnN0IHogPSB2ZWMuelxyXG4gICAgcmV0dXJuIG5ldyBWZWMzKGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiwgYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6LCBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwZXJzcGVjdGl2ZSBmcm9tIGEgTWF0NC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IC0gVGhlIGZvdnkgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCAtIFRoZSBhc3BlY3QgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgLSBUaGUgbmVhciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFyIC0gVGhlIGZhciB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRQZXJzcGVjdGl2ZU1hdHJpeChmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xyXG4gICAgY29uc3QgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmb3Z5KVxyXG4gICAgY29uc3QgcmFuZ2VJbnYgPSAxLjAgLyAobmVhciAtIGZhcilcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICAgIHRoaXMuc2V0KGYgLyBhc3BlY3QsIDAsIDAsIDAsIDAsIGYsIDAsIDAsIDAsIDAsIChuZWFyICsgZmFyKSAqIHJhbmdlSW52LCAtMSwgMCwgMCwgbmVhciAqIGZhciAqIHJhbmdlSW52ICogMiwgMClcclxuICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgb3J0aG9ncmFwaGljIG1hdHJpeCBhbmQgc2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IC0gVGhlIGxlZnQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IC0gVGhlIHJpZ2h0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gLSBUaGUgYm90dG9tIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgdG9wIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIC0gVGhlIG5lYXIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhciAtIFRoZSBmYXIgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0T3J0aG9ncmFwaGljTWF0cml4KGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICBjb25zdCBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KVxyXG4gICAgY29uc3QgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcClcclxuICAgIGNvbnN0IG5mID0gMSAvIChuZWFyIC0gZmFyKVxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gICAgdGhpcy5zZXQoXHJcbiAgICAgIC0yICogbHIsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIC0yICogYnQsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDIgKiBuZixcclxuICAgICAgMCxcclxuICAgICAgKGxlZnQgKyByaWdodCkgKiBscixcclxuICAgICAgKHRvcCArIGJvdHRvbSkgKiBidCxcclxuICAgICAgKGZhciArIG5lYXIpICogbmYsXHJcbiAgICAgIDFcclxuICAgIClcclxuICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NhbGVzIE1hdDQgTWF0cml4XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRTY2FsZSh4LCB5LCB6KSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovXHJcbiAgICBpZiAoeCBpbnN0YW5jZW9mIFZlYzMpIHtcclxuICAgICAgdGhpcy5zZXQoeC54LCAwLCAwLCAwLCAwLCB4LnksIDAsIDAsIDAsIDAsIHgueiwgMCwgMCwgMCwgMCwgMSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2V0KHgsIDAsIDAsIDAsIDAsIHksIDAsIDAsIDAsIDAsIHosIDAsIDAsIDAsIDAsIDEpXHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgYSAzeDQgbWF0cml4IGludG8gYSA0eDQgbWF0cml4IGFuZCBzZXQgdGhlIHJlc3VsdCB0byB0aGUgTWF0aDQgc3RhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBtM3g0IC0gVGhlIG0zeDQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RnJvbU1hdDN4NEFycmF5KG0zeDQpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi9cclxuICAgIHRoaXMuc2V0KFxyXG4gICAgICBtM3g0WzBdLFxyXG4gICAgICBtM3g0WzFdLFxyXG4gICAgICBtM3g0WzJdLFxyXG4gICAgICAwLFxyXG4gICAgICBtM3g0WzNdLFxyXG4gICAgICBtM3g0WzRdLFxyXG4gICAgICBtM3g0WzVdLFxyXG4gICAgICAwLFxyXG4gICAgICBtM3g0WzZdLFxyXG4gICAgICBtM3g0WzddLFxyXG4gICAgICBtM3g0WzhdLFxyXG4gICAgICAwLFxyXG4gICAgICBtM3g0WzldLFxyXG4gICAgICBtM3g0WzEwXSxcclxuICAgICAgbTN4NFsxMV0sXHJcbiAgICAgIDFcclxuICAgIClcclxuICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqL1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBNYXQ0IHRvIHdyYXAgZXhpc3RpbmcgbWVtb3J5IGluIGEgYnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLCB1c2UgI2NyZWF0ZUZyb21CdWZmZXIgaW5zdGVhZCcpXHJcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGcm9tQnVmZmVyKGJ1ZmZlciwgb2Zmc2V0ICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBgTWF0NGAgdXNpbmcgYW4gQXJyYXlCdWZmZXIuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0KSB7XHJcbiAgICByZXR1cm4gbmV3IE1hdDQobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDE2KSkgLy8gNCBieXRlcyBwZXIgMzJiaXQgZmxvYXRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIE1hdDQgcmV0dXJuaW5nIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hdDQoXHJcbiAgICAgIHRoaXMuX19kYXRhWzBdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxXSxcclxuICAgICAgdGhpcy5fX2RhdGFbMl0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzNdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs0XSxcclxuICAgICAgdGhpcy5fX2RhdGFbNV0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzZdLFxyXG4gICAgICB0aGlzLl9fZGF0YVs3XSxcclxuICAgICAgdGhpcy5fX2RhdGFbOF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzldLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxMF0sXHJcbiAgICAgIHRoaXMuX19kYXRhWzExXSxcclxuICAgICAgdGhpcy5fX2RhdGFbMTJdLFxyXG4gICAgICB0aGlzLl9fZGF0YVsxM10sXHJcbiAgICAgIHRoaXMuX19kYXRhWzE0XSxcclxuICAgICAgdGhpcy5fX2RhdGFbMTVdXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gU3RhdGljIE1ldGhvZHNcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBNYXQ0LlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7TWF0NH0gLSBSZXR1cm5zIGEgbmV3IE1hdDQuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgTWF0NCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIGpzb24gcGFyYW0uXHJcbiAgICovXHJcbiAgZnJvbUpTT04oanNvbikge1xyXG4gICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGpzb24pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIpIHtcclxuICAgIHRoaXMuX19kYXRhID0gcmVhZGVyLmxvYWRGbG9hdDMyQXJyYXkoMTYpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignTWF0NCcsIE1hdDQpXHJcblxyXG5leHBvcnQgeyBNYXQ0IH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuaW1wb3J0IHsgQXR0clZhbHVlIH0gZnJvbSAnLi9BdHRyVmFsdWUuanMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCB7IE1hdDMgfSBmcm9tICcuL01hdDMuanMnXHJcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuL01hdDQuanMnXHJcbmltcG9ydCB7IEV1bGVyQW5nbGVzIH0gZnJvbSAnLi9FdWxlckFuZ2xlcy5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHF1YXRlcm5pb24uIFF1YXRlcm5pb25zIGFyZSB1c2VkIHRvIHJlcHJlc2VudCByb3RhdGlvbnNcclxuICogd2l0aG91dCBlbmNvdW50ZXJpbmcgZ2ltYmxlIGxvY2suIEJhc2VkIG9uIGNvbXBsZXggbnVtYmVycyB0aGF0IGFyZSBub3QgZWFzeVxyXG4gKiB0byB1bmRlcnN0YW5kIGludHVpdGl2ZWx5LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyVmFsdWVcclxuICovXHJcbmNsYXNzIFF1YXQgZXh0ZW5kcyBBdHRyVmFsdWUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXIgfCBBcnJheUJ1ZmZlciB8IG9iamVjdH0geCAtIFRoZSBhbmdsZSBvZiB0aGUgeCBheGlzLiBEZWZhdWx0IGlzIDAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgYW5nbGUgb2YgdGhlIHkgYXhpcy4gRGVmYXVsdCBpcyAwLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IC0gVGhlIGFuZ2xlIG9mIHRoZSB6IGF4aXMuIERlZmF1bHQgaXMgMC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB3IHZhbHVlLiBEZWZhdWx0IGlzIDEuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHtcclxuICAgIHN1cGVyKClcclxuXHJcbiAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IHhcclxuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYClcclxuICAgICAgY29uc3QgYnVmZmVyID0geFxyXG4gICAgICBjb25zdCBieXRlT2Zmc2V0ID0geVxyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpXHJcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aGlzLl9fZGF0YVswXSA9IDBcclxuICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IDBcclxuICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IDBcclxuICAgICAgICB0aGlzLl9fZGF0YVszXSA9IDFcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB4KSB7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4W2tleV0pKSB0aGlzW2tleV0uY2FsbCh0aGlzLCAuLi54W2tleV0pXHJcbiAgICAgICAgICBlbHNlIHRoaXNba2V5XS5jYWxsKHRoaXMsIHhba2V5XSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4XHJcbiAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5XHJcbiAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSB6XHJcbiAgICAgICAgdGhpcy5fX2RhdGFbM10gPSB3XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYHhgIGF4aXMgcm90YXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgeCBheGlzIHJvdGF0aW9uLlxyXG4gICAqL1xyXG4gIGdldCB4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZm9yIGB4YCBheGlzIHJvdGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCAtIFRoZSB2YWwgcGFyYW0uXHJcbiAgICovXHJcbiAgc2V0IHgodmFsKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IHZhbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciBgeWAgYXhpcyByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSB5IGF4aXMgcm90YXRpb24uXHJcbiAgICovXHJcbiAgZ2V0IHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYHlgIGF4aXMgcm90YXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIC0gVGhlIHZhbCBwYXJhbS5cclxuICAgKi9cclxuICBzZXQgeSh2YWwpIHtcclxuICAgIHRoaXMuX19kYXRhWzFdID0gdmFsXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXR0ZXIgZm9yIGB6YCBheGlzIHJvdGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHogYXhpcyByb3RhdGlvbi5cclxuICAgKi9cclxuICBnZXQgeigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZvciBgemAgYXhpcyByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB6KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbMl0gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgYHdgIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIHcgdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0IHcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFbM11cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmb3IgYHdgLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBUaGUgdmFsIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldCB3KHZhbCkge1xyXG4gICAgdGhpcy5fX2RhdGFbM10gPSB2YWxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIHJvdGF0aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAtIFRoZSB5IGF4aXMgcm90YXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogIC0gVGhlIHogYXhpcyByb3RhdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdyAgLSBUaGUgdyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXQoeCwgeSwgeiwgdykge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSB4XHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IHlcclxuICAgIHRoaXMuX19kYXRhWzJdID0gelxyXG4gICAgdGhpcy5fX2RhdGFbM10gPSB3XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgUXVhdCBjbGFzcyB1c2luZyBhIEZsb2F0MzJBcnJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyQXJyYXkgLSBUaGUgZmxvYXQzMkFycmF5IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldERhdGFBcnJheShmbG9hdDMyQXJyYXkpIHtcclxuICAgIHRoaXMuX19kYXRhID0gZmxvYXQzMkFycmF5XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXR0ZXIgZnJvbSBhbm90aGVyIHZlY3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgdmVjdG9yIHRvIHNldCBmcm9tLlxyXG4gICAqL1xyXG4gIHNldEZyb21PdGhlcihvdGhlcikge1xyXG4gICAgdGhpcy5fX2RhdGFbMF0gPSBvdGhlci54XHJcbiAgICB0aGlzLl9fZGF0YVsxXSA9IG90aGVyLnlcclxuICAgIHRoaXMuX19kYXRhWzJdID0gb3RoZXIuelxyXG4gICAgdGhpcy5fX2RhdGFbM10gPSBvdGhlci53XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhpcyBxdWF0IGZyb20gYSBldWxlciByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXVsZXJBbmdsZXN9IGV1bGVyQW5nbGVzIC0gVGhlIGV1bGVyIGFuZ2xlcyByb3RhdGlvbi5cclxuICAgKi9cclxuICBzZXRGcm9tRXVsZXJBbmdsZXMoZXVsZXJBbmdsZXMpIHtcclxuICAgIGNvbnN0IG9yZGVyZWQgPSBuZXcgVmVjMygpXHJcblxyXG4gICAgc3dpdGNoIChldWxlckFuZ2xlcy5vcmRlcikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgLyogJ1hZWicgKi9cclxuICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy54LCAtZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueilcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgLyogJ1laWCcgKi9cclxuICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy55LCAtZXVsZXJBbmdsZXMueiwgZXVsZXJBbmdsZXMueClcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgLyogJ1pYWScgKi9cclxuICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy56LCAtZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueSlcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgLyogJ1haWScgKi9cclxuICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy54LCBldWxlckFuZ2xlcy56LCBldWxlckFuZ2xlcy55KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICAvKiAnWllYJyAqL1xyXG4gICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLnosIGV1bGVyQW5nbGVzLnksIGV1bGVyQW5nbGVzLngpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSA1OlxyXG4gICAgICAgIC8qICdZWFonICovXHJcbiAgICAgICAgb3JkZXJlZC5zZXQoZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueilcclxuICAgICAgICBicmVha1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2RydHknKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRpID0gb3JkZXJlZC54ICogMC41XHJcbiAgICBjb25zdCB0aiA9IG9yZGVyZWQueSAqIDAuNVxyXG4gICAgY29uc3QgdGsgPSBvcmRlcmVkLnogKiAwLjVcclxuICAgIGNvbnN0IGNpID0gTWF0aC5jb3ModGkpXHJcbiAgICBjb25zdCBjaiA9IE1hdGguY29zKHRqKVxyXG4gICAgY29uc3QgY2sgPSBNYXRoLmNvcyh0aylcclxuICAgIGNvbnN0IHNpID0gTWF0aC5zaW4odGkpXHJcbiAgICBjb25zdCBzaiA9IE1hdGguc2luKHRqKVxyXG4gICAgY29uc3Qgc2sgPSBNYXRoLnNpbih0aylcclxuICAgIGNvbnN0IGNjID0gY2kgKiBja1xyXG4gICAgY29uc3QgY3MgPSBjaSAqIHNrXHJcbiAgICBjb25zdCBzYyA9IHNpICogY2tcclxuICAgIGNvbnN0IHNzID0gc2kgKiBza1xyXG4gICAgY29uc3QgYWkgPSBjaiAqIHNjIC0gc2ogKiBjc1xyXG4gICAgY29uc3QgYWogPSBjaiAqIHNzICsgc2ogKiBjY1xyXG4gICAgY29uc3QgYWsgPSBjaiAqIGNzIC0gc2ogKiBzY1xyXG5cclxuICAgIHRoaXMudyA9IGNqICogY2MgKyBzaiAqIHNzXHJcblxyXG4gICAgc3dpdGNoIChldWxlckFuZ2xlcy5vcmRlcikge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgLyogJyBYWVonICovXHJcbiAgICAgICAgdGhpcy54ID0gYWlcclxuICAgICAgICB0aGlzLnkgPSAtYWpcclxuICAgICAgICB0aGlzLnogPSBha1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICAvKiAnWVpYJyAqL1xyXG4gICAgICAgIHRoaXMueCA9IGFrXHJcbiAgICAgICAgdGhpcy55ID0gYWlcclxuICAgICAgICB0aGlzLnogPSAtYWpcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgLyogJ1pYWScgKi9cclxuICAgICAgICB0aGlzLnggPSAtYWpcclxuICAgICAgICB0aGlzLnkgPSBha1xyXG4gICAgICAgIHRoaXMueiA9IGFpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIC8qICdYWlknICovXHJcbiAgICAgICAgdGhpcy54ID0gYWlcclxuICAgICAgICB0aGlzLnkgPSBha1xyXG4gICAgICAgIHRoaXMueiA9IGFqXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSA0OlxyXG4gICAgICAgIC8qICdaWVgnICovXHJcbiAgICAgICAgdGhpcy54ID0gYWtcclxuICAgICAgICB0aGlzLnkgPSBhalxyXG4gICAgICAgIHRoaXMueiA9IGFpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSA1OlxyXG4gICAgICAgIC8qICdZWFonICovXHJcbiAgICAgICAgdGhpcy54ID0gYWpcclxuICAgICAgICB0aGlzLnkgPSBhaVxyXG4gICAgICAgIHRoaXMueiA9IGFrXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NkcnR5JylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIFF1YXQgdG8gYW4gRXVsZXJBbmdsZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSByb3RhdGlvbk9yZGVyIC0gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXHJcbiAgICogQHJldHVybiB7RXVsZXJBbmdsZXN9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b0V1bGVyQW5nbGVzKHJvdGF0aW9uT3JkZXIpIHtcclxuICAgIGNvbnN0IG9yZGVyZWQgPSBuZXcgVmVjMygpXHJcbiAgICBzd2l0Y2ggKHJvdGF0aW9uT3JkZXIpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIC8qICcgWFlaJyAqL1xyXG4gICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIC8qICdZWlgnICovXHJcbiAgICAgICAgb3JkZXJlZC5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueilcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgLyogJ1pYWScgKi9cclxuICAgICAgICBvcmRlcmVkLnNldCh0aGlzLnksIHRoaXMueiwgdGhpcy54KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICAvKiAnWFpZJyAqL1xyXG4gICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueSwgLXRoaXMueCwgdGhpcy56KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICAvKiAnWllYJyAqL1xyXG4gICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueCwgLXRoaXMueiwgdGhpcy55KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgNTpcclxuICAgICAgICAvKiAnWVhaJyAqL1xyXG4gICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueiwgLXRoaXMueSwgdGhpcy54KVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvdGF0aW9uIG9yZGVyOicgKyByb3RhdGlvbk9yZGVyKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV1bGVyID0gbmV3IFZlYzMoKVxyXG4gICAgY29uc3QgdGVzdCA9IG9yZGVyZWQueCAqIG9yZGVyZWQueSArIG9yZGVyZWQueiAqIHRoaXMud1xyXG4gICAgaWYgKHRlc3QgPiAwLjQ5OTk5KSB7XHJcbiAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IG5vcnRoIHBvbGVcclxuICAgICAgZXVsZXIueSA9IDIuMCAqIE1hdGguYXRhbjIob3JkZXJlZC54LCB0aGlzLncpXHJcbiAgICAgIGV1bGVyLnogPSBNYXRoLlBJICogMC41XHJcbiAgICAgIGV1bGVyLnggPSAwLjBcclxuICAgIH0gZWxzZSBpZiAodGVzdCA8IC0wLjQ5OTk5KSB7XHJcbiAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGVcclxuICAgICAgZXVsZXIueSA9IC0yLjAgKiBNYXRoLmF0YW4yKG9yZGVyZWQueCwgdGhpcy53KVxyXG4gICAgICBldWxlci56ID0gTWF0aC5QSSAqIC0wLjVcclxuICAgICAgZXVsZXIueCA9IDAuMFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3Qgc3F4ID0gb3JkZXJlZC54ICogb3JkZXJlZC54XHJcbiAgICAgIGNvbnN0IHNxeSA9IG9yZGVyZWQueSAqIG9yZGVyZWQueVxyXG4gICAgICBjb25zdCBzcXogPSBvcmRlcmVkLnogKiBvcmRlcmVkLnpcclxuICAgICAgZXVsZXIueSA9IE1hdGguYXRhbjIoMi4wICogb3JkZXJlZC55ICogdGhpcy53IC0gMi4wICogb3JkZXJlZC54ICogb3JkZXJlZC56LCAxLjAgLSAyLjAgKiBzcXkgLSAyLjAgKiBzcXopXHJcbiAgICAgIGV1bGVyLnogPSBNYXRoLmFzaW4oMi4wICogdGVzdClcclxuICAgICAgZXVsZXIueCA9IE1hdGguYXRhbjIoMi4wICogb3JkZXJlZC54ICogdGhpcy53IC0gMi4wICogb3JkZXJlZC55ICogb3JkZXJlZC56LCAxLjAgLSAyLjAgKiBzcXggLSAyLjAgKiBzcXopXHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChyb3RhdGlvbk9yZGVyKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICAvKiAnIFhZWicgKi9cclxuICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLnksIGV1bGVyLnosIGV1bGVyLngsIHJvdGF0aW9uT3JkZXIpXHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICAvKiAnWVpYJyAqL1xyXG4gICAgICAgIHJldHVybiBuZXcgRXVsZXJBbmdsZXMoZXVsZXIueCwgZXVsZXIueSwgZXVsZXIueiwgcm90YXRpb25PcmRlcilcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIC8qICdaWFknICovXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci56LCBldWxlci54LCBldWxlci55LCByb3RhdGlvbk9yZGVyKVxyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgLyogJ1haWScgKi9cclxuICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKC1ldWxlci55LCBldWxlci54LCBldWxlci56LCByb3RhdGlvbk9yZGVyKVxyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgICAgLyogJ1pZWCcgKi9cclxuICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLngsIGV1bGVyLnosIC1ldWxlci55LCByb3RhdGlvbk9yZGVyKVxyXG4gICAgICBjYXNlIDU6XHJcbiAgICAgICAgLyogJ1lYWicgKi9cclxuICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLnosIC1ldWxlci55LCBldWxlci54LCByb3RhdGlvbk9yZGVyKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoaXMgcXVhdCB0byBhIHJvdGF0aW9uIGRlZmluZWQgYnkgYW4gYXhpcyBhbmQgYW4gYW5nbGUgKGluIHJhZGlhbnMpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBheGlzIC0gVGhlIGF4aXMgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIC0gVGhlIGF4aXMgYW5nbGUuXHJcbiAgICovXHJcbiAgc2V0RnJvbUF4aXNBbmRBbmdsZShheGlzLCBhbmdsZSkge1xyXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLjBcclxuICAgIGNvbnN0IHZlYyA9IGF4aXMubm9ybWFsaXplKCkuc2NhbGUoTWF0aC5zaW4oaGFsZkFuZ2xlKSlcclxuICAgIHRoaXMuc2V0KHZlYy54LCB2ZWMueSwgdmVjLnosIE1hdGguY29zKGhhbGZBbmdsZSkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIGBWZWMzYCBhbmQgc2V0cyB0aGUgcmVzdWx0IGluIHRoZSBNYXQzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGRpciAtIFRoZSBkaXJlY3Rpb24gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtWZWMzfSB1cCAtIFRoZSB1cCBhbmdsZS5cclxuICAgKi9cclxuICBzZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IoZGlyLCB1cCkge1xyXG4gICAgY29uc3QgbWF0MyA9IG5ldyBNYXQzKClcclxuICAgIG1hdDMuc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGRpciwgdXApXHJcbiAgICB0aGlzLnNldEZyb21NYXQzKG1hdDMpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgYFF1YXRgIGZyb20gdHdvIGBWZWMzYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdjAgLSBUaGUgdjAgdW5pdCB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2MSAtIFRoZSB2MSB1bml0IHZlY3Rvci5cclxuICAgKi9cclxuICBzZXRGcm9tMlZlY3RvcnModjAsIHYxKSB7XHJcbiAgICBjb25zdCBjID0gdjAuY3Jvc3ModjEpXHJcbiAgICBjb25zdCBkID0gdjAuZG90KHYxKVxyXG4gICAgY29uc3QgcyA9IE1hdGguc3FydCgoMSArIGQpICogMilcclxuICAgIC8vIHRoaXMuc2V0KCBzLzIsIGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMgKTtcclxuICAgIHRoaXMuc2V0KGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMsIHMgLyAyKVxyXG4gICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcXVhdCBmcm9tIGEgTWF0My5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWF0M30gbWF0MyAtIFRoZSBtYXQzIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZyb21NYXQzKG1hdDMpIHtcclxuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXHJcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cclxuICAgIGNvbnN0IGZUcmFjZSA9IG1hdDMuX19kYXRhWzBdICsgbWF0My5fX2RhdGFbNF0gKyBtYXQzLl9fZGF0YVs4XVxyXG4gICAgbGV0IGZSb290XHJcblxyXG4gICAgaWYgKGZUcmFjZSA+IDAuMCkge1xyXG4gICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXHJcbiAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEpIC8vIDJ3XHJcbiAgICAgIHRoaXMuX19kYXRhWzNdID0gMC41ICogZlJvb3RcclxuICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdCAvLyAxLyg0dylcclxuICAgICAgdGhpcy5fX2RhdGFbMF0gPSAobWF0My5fX2RhdGFbNV0gLSBtYXQzLl9fZGF0YVs3XSkgKiBmUm9vdFxyXG4gICAgICB0aGlzLl9fZGF0YVsxXSA9IChtYXQzLl9fZGF0YVs2XSAtIG1hdDMuX19kYXRhWzJdKSAqIGZSb290XHJcbiAgICAgIHRoaXMuX19kYXRhWzJdID0gKG1hdDMuX19kYXRhWzFdIC0gbWF0My5fX2RhdGFbM10pICogZlJvb3RcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHx3fCA8PSAxLzJcclxuICAgICAgbGV0IGkgPSAwXHJcbiAgICAgIGlmIChtYXQzLl9fZGF0YVs0XSA+IG1hdDMuX19kYXRhWzBdKSBpID0gMVxyXG4gICAgICBpZiAobWF0My5fX2RhdGFbOF0gPiBtYXQzLl9fZGF0YVtpICogMyArIGldKSBpID0gMlxyXG4gICAgICBjb25zdCBqID0gKGkgKyAxKSAlIDNcclxuICAgICAgY29uc3QgayA9IChpICsgMikgJSAzXHJcblxyXG4gICAgICBmUm9vdCA9IE1hdGguc3FydChtYXQzLl9fZGF0YVtpICogMyArIGldIC0gbWF0My5fX2RhdGFbaiAqIDMgKyBqXSAtIG1hdDMuX19kYXRhW2sgKiAzICsga10gKyAxLjApXHJcbiAgICAgIHRoaXMuX19kYXRhW2ldID0gMC41ICogZlJvb3RcclxuICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdFxyXG4gICAgICB0aGlzLl9fZGF0YVszXSA9IChtYXQzLl9fZGF0YVtqICogMyArIGtdIC0gbWF0My5fX2RhdGFbayAqIDMgKyBqXSkgKiBmUm9vdFxyXG4gICAgICB0aGlzLl9fZGF0YVtqXSA9IChtYXQzLl9fZGF0YVtqICogMyArIGldICsgbWF0My5fX2RhdGFbaSAqIDMgKyBqXSkgKiBmUm9vdFxyXG4gICAgICB0aGlzLl9fZGF0YVtrXSA9IChtYXQzLl9fZGF0YVtrICogMyArIGldICsgbWF0My5fX2RhdGFbaSAqIDMgKyBrXSkgKiBmUm9vdFxyXG4gICAgfVxyXG4gICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgcXVhdCBmcm9tIGEgTWF0NC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZyb21NYXQ0KG1hdDQpIHtcclxuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXHJcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cclxuICAgIGNvbnN0IGZUcmFjZSA9IG1hdDQuX19kYXRhWzBdICsgbWF0NC5fX2RhdGFbNV0gKyBtYXQ0Ll9fZGF0YVsxMF1cclxuICAgIGxldCBmUm9vdFxyXG5cclxuICAgIGlmIChmVHJhY2UgPiAwLjApIHtcclxuICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxyXG4gICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxKSAvLyAyd1xyXG4gICAgICB0aGlzLl9fZGF0YVszXSA9IDAuNSAqIGZSb290XHJcbiAgICAgIGZSb290ID0gMC41IC8gZlJvb3QgLy8gMS8oNHcpXHJcbiAgICAgIHRoaXMuX19kYXRhWzBdID0gKG1hdDQuX19kYXRhWzZdIC0gbWF0NC5fX2RhdGFbOV0pICogZlJvb3RcclxuICAgICAgdGhpcy5fX2RhdGFbMV0gPSAobWF0NC5fX2RhdGFbOF0gLSBtYXQ0Ll9fZGF0YVsyXSkgKiBmUm9vdFxyXG4gICAgICB0aGlzLl9fZGF0YVsyXSA9IChtYXQ0Ll9fZGF0YVsxXSAtIG1hdDQuX19kYXRhWzRdKSAqIGZSb290XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB8d3wgPD0gMS8yXHJcbiAgICAgIGxldCBpID0gMFxyXG4gICAgICBpZiAobWF0NC5fX2RhdGFbNV0gPiBtYXQ0Ll9fZGF0YVswXSkgaSA9IDFcclxuICAgICAgaWYgKG1hdDQuX19kYXRhWzEwXSA+IG1hdDQuX19kYXRhW2kgKiA0ICsgaV0pIGkgPSAyXHJcbiAgICAgIGNvbnN0IGogPSAoaSArIDEpICUgM1xyXG4gICAgICBjb25zdCBrID0gKGkgKyAyKSAlIDNcclxuXHJcbiAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1hdDQuX19kYXRhW2kgKiA0ICsgaV0gLSBtYXQ0Ll9fZGF0YVtqICogNCArIGpdIC0gbWF0NC5fX2RhdGFbayAqIDQgKyBrXSArIDEuMClcclxuICAgICAgdGhpcy5fX2RhdGFbaV0gPSAwLjUgKiBmUm9vdFxyXG4gICAgICBmUm9vdCA9IDAuNSAvIGZSb290XHJcbiAgICAgIHRoaXMuX19kYXRhWzNdID0gKG1hdDQuX19kYXRhW2ogKiA0ICsga10gLSBtYXQ0Ll9fZGF0YVtrICogNCArIGpdKSAqIGZSb290XHJcbiAgICAgIHRoaXMuX19kYXRhW2pdID0gKG1hdDQuX19kYXRhW2ogKiA0ICsgaV0gKyBtYXQ0Ll9fZGF0YVtpICogNCArIGpdKSAqIGZSb290XHJcbiAgICAgIHRoaXMuX19kYXRhW2tdID0gKG1hdDQuX19kYXRhW2sgKiA0ICsgaV0gKyBtYXQ0Ll9fZGF0YVtpICogNCArIGtdKSAqIGZSb290XHJcbiAgICB9XHJcbiAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBhbmdsZSBvZiB0aGUgUXVhdCBpcyBsZXNzIHRoYXQgYCBOdW1iZXIuRVBTSUxPTmBcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIGlzSWRlbnRpdHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBbmdsZSgpIDwgTnVtYmVyLkVQU0lMT05cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgYW5nbGUgb2YgdGhlIFF1YXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRBbmdsZSgpIHtcclxuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy53KSAqIDIuMFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUXVhdCBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBlcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMueCA9PSBvdGhlci54ICYmIHRoaXMueSA9PSBvdGhlci55ICYmIHRoaXMueiA9PSBvdGhlci56ICYmIHRoaXMudyA9PSBvdGhlci53XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBRdWF0IGlzIE5PVCBleGFjdGx5IHRoZSBzYW1lIG90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnggIT0gb3RoZXIueCAmJiB0aGlzLnkgIT0gb3RoZXIueSAmJiB0aGlzLnogIT0gb3RoZXIueiAmJiB0aGlzLncgIT0gb3RoZXIud1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUXVhdCBpcyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGFzIG90aGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuICAgKi9cclxuICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMueiAtIG90aGVyLnopIDwgcHJlY2lzaW9uICYmXHJcbiAgICAgIE1hdGguYWJzKHRoaXMudyAtIG90aGVyLncpIDwgcHJlY2lzaW9uXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgUXVhdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBhZGQuXHJcbiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuXHJcbiAgICovXHJcbiAgYWRkKG90aGVyKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueiwgdGhpcy53ICsgb3RoZXIudylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBRdWF0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGFkZC5cclxuICAgKi9cclxuICBhZGRJblBsYWNlKG90aGVyKSB7XHJcbiAgICB0aGlzLnggKz0gb3RoZXIueFxyXG4gICAgdGhpcy55ICs9IG90aGVyLnlcclxuICAgIHRoaXMueiArPSBvdGhlci56XHJcbiAgICB0aGlzLncgKz0gb3RoZXIud1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBRdWF0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBzdWJ0cmFjdC5cclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC5cclxuICAgKi9cclxuICBzdWJ0cmFjdChvdGhlcikge1xyXG4gICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCAtIG90aGVyLngsIHRoaXMueSAtIG90aGVyLnksIHRoaXMueiAtIG90aGVyLnosIHRoaXMudyAtIG90aGVyLncpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgdGhpcyBRdWF0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgVmVjMy5cclxuICAgKi9cclxuICBzY2FsZShzY2FsYXIpIHtcclxuICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyLCB0aGlzLncgKiBzY2FsYXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgdGhpcyBRdWF0IGJ5IHNjYWxhci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNjYWxlSW5QbGFjZShzY2FsYXIpIHtcclxuICAgIHRoaXMueCAqPSBzY2FsYXJcclxuICAgIHRoaXMueSAqPSBzY2FsYXJcclxuICAgIHRoaXMueiAqPSBzY2FsYXJcclxuICAgIHRoaXMudyAqPSBzY2FsYXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFF1YXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbGVuZ3RoLlxyXG4gICAqL1xyXG4gIGxlbmd0aCgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl1cclxuICAgIGNvbnN0IHcgPSB0aGlzLl9fZGF0YVszXVxyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgUXVhdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBSZXR1cm5zIHRoZSBsZW5ndGguXHJcbiAgICovXHJcbiAgbGVuZ3RoU3F1YXJlZCgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXVxyXG4gICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl1cclxuICAgIGNvbnN0IHcgPSB0aGlzLl9fZGF0YVszXVxyXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0IGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFF1YXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgdGhlIFF1YXQgbm9ybWFsaXplZC5cclxuICAgKi9cclxuICBub3JtYWxpemUoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF1cclxuICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXVxyXG4gICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCB3ID0gdGhpcy5fX2RhdGFbM11cclxuICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogd1xyXG4gICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUXVhdCgpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XHJcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcclxuICAgIHJldHVybiBuZXcgUXVhdCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplcyB0aGUgUXVhdCwgbW9kaWZ5aW5nIGl0IGFuZCByZXR1cm5pbmcgaXQgbm9ybWFsaXplZC5cclxuICAgKi9cclxuICBub3JtYWxpemVJblBsYWNlKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV1cclxuICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXVxyXG4gICAgY29uc3QgdyA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHdcclxuICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxyXG4gICAgdGhpcy5zZXQoeCAqIGxlbiwgeSAqIGxlbiwgeiAqIGxlbiwgdyAqIGxlbilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBRdWF0cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LlxyXG4gICAqL1xyXG4gIGRvdChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMueCAqIG90aGVyLnggKyB0aGlzLnkgKiBvdGhlci55ICsgdGhpcy56ICogb3RoZXIueiArIHRoaXMudyAqIG90aGVyLndcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFF1YXRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjYWxjdWxhdGUgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3QgYXMgYSBuZXcgUXVhdC5cclxuICAgKi9cclxuICBjcm9zcyhvdGhlcikge1xyXG4gICAgY29uc3QgYXggPSB0aGlzLnhcclxuICAgIGNvbnN0IGF5ID0gdGhpcy55XHJcbiAgICBjb25zdCBheiA9IHRoaXMuelxyXG4gICAgY29uc3QgYXQgPSB0aGlzLndcclxuICAgIGNvbnN0IGJ4ID0gb3RoZXIueFxyXG4gICAgY29uc3QgYnkgPSBvdGhlci55XHJcbiAgICBjb25zdCBieiA9IG90aGVyLnpcclxuICAgIGNvbnN0IGJ0ID0gb3RoZXIud1xyXG5cclxuICAgIHJldHVybiBuZXcgUXVhdChheSAqIGJ6IC0gYXogKiBieSwgYXogKiBidCAtIGF0ICogYnosIGF0ICogYnggLSBheCAqIGJ0LCBheCAqIGJ5IC0gYXkgKiBieClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJvdGF0aW9uYWwgY29uanVnYXRlIG9mIHRoaXMgUXVhdC5cclxuICAgKiBDb25qdWdhdGlvbiByZXByZXNlbnRzIHRoZSBzYW1lIHJvdGF0aW9uIG9mIHRoZSBRdWF0IGJ1dFxyXG4gICAqIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gYXJvdW5kIHRoZSByb3RhdGlvbmFsIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgY29uanVnYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWF0KC10aGlzLngsIC10aGlzLnksIC10aGlzLnosIHRoaXMudylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgaW52ZXJzZSBvZiB0aGUgYFF1YXRgXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC5cclxuICAgKi9cclxuICBpbnZlcnNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsaWducyB0aGlzIHF1YXRlcm5pb24gd2l0aCBhbm90aGVyIG9uZSBlbnN1cmluZyB0aGF0IHRoZSBkZWx0YSBiZXR3ZWVuXHJcbiAgICogdGhlIFF1YXQgdmFsdWVzIGlzIHRoZSBzaG9ydGVzdCBwYXRoIG92ZXIgdGhlIGh5cGVyc3BoZXJlLlxyXG4gICAqXHJcbiAgICogIEBwYXJhbSB7UXVhdH0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBkaXZpZGUgYnkuXHJcbiAgICovXHJcbiAgYWxpZ25XaXRoKG90aGVyKSB7XHJcbiAgICBpZiAodGhpcy5kb3Qob3RoZXIpIDwgMC4wKSB7XHJcbiAgICAgIHRoaXMuc2V0KC10aGlzLngsIC10aGlzLnksIC10aGlzLnosIC10aGlzLncpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBtdWx0aXBseShxdWF0KSB7XHJcbiAgLy8gICAgIHJldHVybiBuZXcgUXVhdChcclxuICAvLyAgICAgICAgIHRoaXMueCAqIHF1YXQudyArIHRoaXMudyAqIHF1YXQueCArIHRoaXMueSAqIHF1YXQueiAtIHRoaXMueiAqIHF1YXQueSxcclxuICAvLyAgICAgICAgIHRoaXMueSAqIHF1YXQudyArIHRoaXMudyAqIHF1YXQueSArIHRoaXMueiAqIHF1YXQueCAtIHRoaXMueCAqIHF1YXQueixcclxuICAvLyAgICAgICAgIHRoaXMueiAqIHF1YXQudyArIHRoaXMudyAqIHF1YXQueiArIHRoaXMueCAqIHF1YXQueSAtIHRoaXMueSAqIHF1YXQueCxcclxuICAvLyAgICAgICAgIHRoaXMudyAqIHF1YXQudyAtIHRoaXMueCAqIHF1YXQueCAtIHRoaXMueSAqIHF1YXQueSAtIHRoaXMueiAqIHF1YXQuelxyXG4gIC8vICAgICApO1xyXG4gIC8vIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0d28gUXVhdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtRdWF0fSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIG11bHRpcGx5LlxyXG4gICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0LlxyXG4gICAqL1xyXG4gIG11bHRpcGx5KG90aGVyKSB7XHJcbiAgICBjb25zdCBheCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCBheSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCBheiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCBhdyA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBjb25zdCBieCA9IG90aGVyLl9fZGF0YVswXVxyXG4gICAgY29uc3QgYnkgPSBvdGhlci5fX2RhdGFbMV1cclxuICAgIGNvbnN0IGJ6ID0gb3RoZXIuX19kYXRhWzJdXHJcbiAgICBjb25zdCBidyA9IG90aGVyLl9fZGF0YVszXVxyXG5cclxuICAgIHJldHVybiBuZXcgUXVhdChcclxuICAgICAgYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcclxuICAgICAgYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcclxuICAgICAgYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcclxuICAgICAgYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBielxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0d28gUXVhdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gbXVsdGlwbHkuXHJcbiAgICovXHJcbiAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7XHJcbiAgICBjb25zdCBheCA9IHRoaXMuX19kYXRhWzBdXHJcbiAgICBjb25zdCBheSA9IHRoaXMuX19kYXRhWzFdXHJcbiAgICBjb25zdCBheiA9IHRoaXMuX19kYXRhWzJdXHJcbiAgICBjb25zdCBhdyA9IHRoaXMuX19kYXRhWzNdXHJcbiAgICBjb25zdCBieCA9IG90aGVyLl9fZGF0YVswXVxyXG4gICAgY29uc3QgYnkgPSBvdGhlci5fX2RhdGFbMV1cclxuICAgIGNvbnN0IGJ6ID0gb3RoZXIuX19kYXRhWzJdXHJcbiAgICBjb25zdCBidyA9IG90aGVyLl9fZGF0YVszXVxyXG5cclxuICAgIHRoaXMuc2V0KFxyXG4gICAgICBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxyXG4gICAgICBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxyXG4gICAgICBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxyXG4gICAgICBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6XHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IHRoaXMgcXVhdGVyaW9uLlxyXG4gICAqIERvbid0IGZvcmdldCB0byBub3JtYWxpemUgdGhlIHF1YXRlcm5pb24gdW5sZXNzXHJcbiAgICogeW91IHdhbnQgYXhpYWwgdHJhbnNsYXRpb24gYXMgd2VsbCBhcyByb3RhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIG5ldyBWZWMzLlxyXG4gICAqL1xyXG4gIHJvdGF0ZVZlYzModmVjMykge1xyXG4gICAgY29uc3QgdnEgPSBuZXcgUXVhdCh2ZWMzLngsIHZlYzMueSwgdmVjMy56LCAwLjApXHJcbiAgICBjb25zdCBwcSA9IHRoaXMubXVsdGlwbHkodnEpLm11bHRpcGx5KHRoaXMuY29uanVnYXRlKCkpXHJcbiAgICByZXR1cm4gbmV3IFZlYzMocHEueCwgcHEueSwgcHEueilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZCAtIEFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGUuXHJcbiAgICovXHJcbiAgcm90YXRlWChyYWQpIHtcclxuICAgIHJhZCAqPSAwLjVcclxuXHJcbiAgICBjb25zdCBheCA9IHRoaXMueFxyXG4gICAgY29uc3QgYXkgPSB0aGlzLnlcclxuICAgIGNvbnN0IGF6ID0gdGhpcy56XHJcbiAgICBjb25zdCBhdyA9IHRoaXMud1xyXG4gICAgY29uc3QgYnggPSBNYXRoLnNpbihyYWQpXHJcbiAgICBjb25zdCBidyA9IE1hdGguY29zKHJhZClcclxuXHJcbiAgICB0aGlzLnggPSBheCAqIGJ3ICsgYXcgKiBieFxyXG4gICAgdGhpcy55ID0gYXkgKiBidyArIGF6ICogYnhcclxuICAgIHRoaXMueiA9IGF6ICogYncgLSBheSAqIGJ4XHJcbiAgICB0aGlzLncgPSBhdyAqIGJ3IC0gYXggKiBieFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkIC0gQW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZS5cclxuICAgKi9cclxuICByb3RhdGVZKHJhZCkge1xyXG4gICAgcmFkICo9IDAuNVxyXG5cclxuICAgIGNvbnN0IGF4ID0gdGhpcy54XHJcbiAgICBjb25zdCBheSA9IHRoaXMueVxyXG4gICAgY29uc3QgYXogPSB0aGlzLnpcclxuICAgIGNvbnN0IGF3ID0gdGhpcy53XHJcbiAgICBjb25zdCBieSA9IE1hdGguc2luKHJhZClcclxuICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MocmFkKVxyXG5cclxuICAgIHRoaXMueCA9IGF4ICogYncgLSBheiAqIGJ5XHJcbiAgICB0aGlzLnkgPSBheSAqIGJ3ICsgYXcgKiBieVxyXG4gICAgdGhpcy56ID0gYXogKiBidyArIGF4ICogYnlcclxuICAgIHRoaXMudyA9IGF3ICogYncgLSBheSAqIGJ5XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWQgLSBBbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLlxyXG4gICAqL1xyXG4gIHJvdGF0ZVoocmFkKSB7XHJcbiAgICByYWQgKj0gMC41XHJcblxyXG4gICAgY29uc3QgYXggPSB0aGlzLnhcclxuICAgIGNvbnN0IGF5ID0gdGhpcy55XHJcbiAgICBjb25zdCBheiA9IHRoaXMuelxyXG4gICAgY29uc3QgYXcgPSB0aGlzLndcclxuICAgIGNvbnN0IGJ6ID0gTWF0aC5zaW4ocmFkKVxyXG4gICAgY29uc3QgYncgPSBNYXRoLmNvcyhyYWQpXHJcblxyXG4gICAgdGhpcy54ID0gYXggKiBidyArIGF5ICogYnpcclxuICAgIHRoaXMueSA9IGF5ICogYncgLSBheCAqIGJ6XHJcbiAgICB0aGlzLnogPSBheiAqIGJ3ICsgYXcgKiBielxyXG4gICAgdGhpcy53ID0gYXcgKiBidyAtIGF6ICogYnpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgUXVhdCB0byBhIE1hdDMgKGEgM3gzIG1hdHJpeCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNYXQzfSAtIFRSZXR1cm5zIGEgbmV3IE1hdDMuXHJcbiAgICovXHJcbiAgdG9NYXQzKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMueFxyXG4gICAgY29uc3QgeSA9IHRoaXMueVxyXG4gICAgY29uc3QgeiA9IHRoaXMuelxyXG4gICAgY29uc3QgdyA9IHRoaXMud1xyXG4gICAgY29uc3QgeDIgPSB4ICsgeFxyXG4gICAgY29uc3QgeTIgPSB5ICsgeVxyXG4gICAgY29uc3QgejIgPSB6ICsgelxyXG4gICAgY29uc3QgeHggPSB4ICogeDJcclxuICAgIGNvbnN0IHl4ID0geSAqIHgyXHJcbiAgICBjb25zdCB5eSA9IHkgKiB5MlxyXG4gICAgY29uc3QgenggPSB6ICogeDJcclxuICAgIGNvbnN0IHp5ID0geiAqIHkyXHJcbiAgICBjb25zdCB6eiA9IHogKiB6MlxyXG4gICAgY29uc3Qgd3ggPSB3ICogeDJcclxuICAgIGNvbnN0IHd5ID0gdyAqIHkyXHJcbiAgICBjb25zdCB3eiA9IHcgKiB6MlxyXG5cclxuICAgIGNvbnN0IG1hdDMgPSBuZXcgTWF0MygpXHJcbiAgICBtYXQzLl9fZGF0YVswXSA9IDEgLSB5eSAtIHp6XHJcbiAgICBtYXQzLl9fZGF0YVszXSA9IHl4IC0gd3pcclxuICAgIG1hdDMuX19kYXRhWzZdID0genggKyB3eVxyXG5cclxuICAgIG1hdDMuX19kYXRhWzFdID0geXggKyB3elxyXG4gICAgbWF0My5fX2RhdGFbNF0gPSAxIC0geHggLSB6elxyXG4gICAgbWF0My5fX2RhdGFbN10gPSB6eSAtIHd4XHJcblxyXG4gICAgbWF0My5fX2RhdGFbMl0gPSB6eCAtIHd5XHJcbiAgICBtYXQzLl9fZGF0YVs1XSA9IHp5ICsgd3hcclxuICAgIG1hdDMuX19kYXRhWzhdID0gMSAtIHh4IC0geXlcclxuXHJcbiAgICByZXR1cm4gbWF0M1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgWCBheGlzIG9mIHRoaXMgcXVhdGVybmlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyB0aGUgWCBheGlzIGFzIGEgVmVjMy5cclxuICAgKi9cclxuICBnZXRYYXhpcygpIHtcclxuICAgIGNvbnN0IHh5ID0gdGhpcy54ICogdGhpcy55XHJcbiAgICBjb25zdCB4eiA9IHRoaXMueCAqIHRoaXMuelxyXG4gICAgY29uc3QgeXkgPSB0aGlzLnkgKiB0aGlzLnlcclxuICAgIGNvbnN0IHl3ID0gdGhpcy55ICogdGhpcy53XHJcbiAgICBjb25zdCB6eiA9IHRoaXMueiAqIHRoaXMuelxyXG4gICAgY29uc3QgencgPSB0aGlzLnogKiB0aGlzLndcclxuXHJcbiAgICByZXR1cm4gbmV3IFZlYzMoMS4wIC0gMi4wICogKHp6ICsgeXkpLCAyLjAgKiAoeHkgKyB6dyksIDIuMCAqICh4eiAtIHl3KSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIFkgYXhpcyBvZiB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIFkgYXhpcyBhcyBhIFZlYzMuXHJcbiAgICovXHJcbiAgZ2V0WWF4aXMoKSB7XHJcbiAgICBjb25zdCB4eCA9IHRoaXMueCAqIHRoaXMueFxyXG4gICAgY29uc3QgeHkgPSB0aGlzLnggKiB0aGlzLnlcclxuICAgIGNvbnN0IHh3ID0gdGhpcy54ICogdGhpcy53XHJcbiAgICBjb25zdCB5eiA9IHRoaXMueSAqIHRoaXMuelxyXG4gICAgY29uc3QgenogPSB0aGlzLnogKiB0aGlzLnpcclxuICAgIGNvbnN0IHp3ID0gdGhpcy56ICogdGhpcy53XHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWMzKDIuMCAqICh4eSAtIHp3KSwgMS4wIC0gMi4wICogKHp6ICsgeHgpLCAyLjAgKiAoeXogKyB4dykpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBaIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBaIGF4aXMgYXMgYSBWZWMzLlxyXG4gICAqL1xyXG4gIGdldFpheGlzKCkge1xyXG4gICAgY29uc3QgeHggPSB0aGlzLnggKiB0aGlzLnhcclxuICAgIGNvbnN0IHh6ID0gdGhpcy54ICogdGhpcy56XHJcbiAgICBjb25zdCB4dyA9IHRoaXMueCAqIHRoaXMud1xyXG5cclxuICAgIGNvbnN0IHl5ID0gdGhpcy55ICogdGhpcy55XHJcbiAgICBjb25zdCB5eiA9IHRoaXMueSAqIHRoaXMuelxyXG4gICAgY29uc3QgeXcgPSB0aGlzLnkgKiB0aGlzLndcclxuICAgIGNvbnN0IHRlbXAgPSBuZXcgVmVjMygpXHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWMzKDIuMCAqICh5dyArIHh6KSwgMi4wICogKHl6IC0geHcpLCAxLjAgLSAyLjAgKiAoeXkgKyB4eCkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZsZWN0cyB0aGlzIHF1YXRlcm5pb24gYWNjb3JkaW5nIHRvIHRoZSBheGlzIHByb3ZpZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGF4aXNJbmRleCAtIEFuIGludGVnZXIgd2l0aCB2YWx1ZSBvZiAwIGZvciB0aGUgWCBheGlzLCAxIGZvciB0aGUgWSBheGlzLCBhbmQgMiBmb3IgdGhlIFogYXhpcy5cclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC5cclxuICAgKi9cclxuICBtaXJyb3IoYXhpc0luZGV4KSB7XHJcbiAgICBzd2l0Y2ggKGF4aXNJbmRleCkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueiwgdGhpcy53LCB0aGlzLngsIHRoaXMueSlcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHJldHVybiBuZXcgUXVhdCgtdGhpcy53LCB0aGlzLnosIHRoaXMueSwgLXRoaXMueClcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLngsIHRoaXMueSwgdGhpcy56LCAtdGhpcy53KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgdGhpcyBRdWF0IHRvIGEgTWF0NCAoYSA0eDQgbWF0cml4KS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01hdDR9IC0gUmV0dXJucyBhIG5ldyBNYXQ0LlxyXG4gICAqL1xyXG4gIHRvTWF0NCgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLnhcclxuICAgIGNvbnN0IHkgPSB0aGlzLnlcclxuICAgIGNvbnN0IHogPSB0aGlzLnpcclxuICAgIGNvbnN0IHcgPSB0aGlzLndcclxuICAgIGNvbnN0IHgyID0geCArIHhcclxuICAgIGNvbnN0IHkyID0geSArIHlcclxuICAgIGNvbnN0IHoyID0geiArIHpcclxuICAgIGNvbnN0IHh4ID0geCAqIHgyXHJcbiAgICBjb25zdCB5eCA9IHkgKiB4MlxyXG4gICAgY29uc3QgeXkgPSB5ICogeTJcclxuICAgIGNvbnN0IHp4ID0geiAqIHgyXHJcbiAgICBjb25zdCB6eSA9IHogKiB5MlxyXG4gICAgY29uc3QgenogPSB6ICogejJcclxuICAgIGNvbnN0IHd4ID0gdyAqIHgyXHJcbiAgICBjb25zdCB3eSA9IHcgKiB5MlxyXG4gICAgY29uc3Qgd3ogPSB3ICogejJcclxuXHJcbiAgICAvLyBTZXQgdGhlIGNvbHVtbnNcclxuICAgIGNvbnN0IG1hdDQgPSBuZXcgTWF0NCgpXHJcbiAgICBtYXQ0Ll9fZGF0YVswXSA9IDEgLSB5eSAtIHp6XHJcbiAgICBtYXQ0Ll9fZGF0YVs0XSA9IHl4IC0gd3pcclxuICAgIG1hdDQuX19kYXRhWzhdID0genggKyB3eVxyXG5cclxuICAgIG1hdDQuX19kYXRhWzFdID0geXggKyB3elxyXG4gICAgbWF0NC5fX2RhdGFbNV0gPSAxIC0geHggLSB6elxyXG4gICAgbWF0NC5fX2RhdGFbOV0gPSB6eSAtIHd4XHJcblxyXG4gICAgbWF0NC5fX2RhdGFbMl0gPSB6eCAtIHd5XHJcbiAgICBtYXQ0Ll9fZGF0YVs2XSA9IHp5ICsgd3hcclxuICAgIG1hdDQuX19kYXRhWzEwXSA9IDEgLSB4eCAtIHl5XHJcblxyXG4gICAgcmV0dXJuIG1hdDRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gUXVhdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1F1YXR9IG90aGVyICAtIFRoZSBvdGhlciBRdWF0IHRvIGludGVycG9sYXRlIGJldHdlZW4uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLlxyXG4gICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0LlxyXG4gICAqL1xyXG4gIGxlcnAob3RoZXIsIHQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWF0KFxyXG4gICAgICB0aGlzLnggKyB0ICogKG90aGVyLnggLSB0aGlzLngpLFxyXG4gICAgICB0aGlzLnkgKyB0ICogKG90aGVyLnkgLSB0aGlzLnkpLFxyXG4gICAgICB0aGlzLnogKyB0ICogKG90aGVyLnogLSB0aGlzLnopLFxyXG4gICAgICB0aGlzLncgKyB0ICogKG90aGVyLncgLSB0aGlzLncpXHJcbiAgICApXHJcbiAgICByZXN1bHQubm9ybWFsaXplSW5QbGFjZSgpXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvLyAvKipcclxuICAvLyAgKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlLlxyXG4gIC8vICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtICBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgLy8gICogQHJldHVybnMge3ZlYzR9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAvLyAgKi9cclxuICAvLyByYW5kb20oc2NhbGUgPSAxLjApIHtcclxuICAvLyAgICAgY29uc3QgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcclxuICAvLyAgICAgY29uc3QgeiA9IChnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCkgLSAxLjA7XHJcbiAgLy8gICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcclxuXHJcbiAgLy8gICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xyXG4gIC8vICAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcclxuICAvLyAgICAgb3V0WzJdID0geiAqIHNjYWxlO1xyXG4gIC8vICAgICByZXR1cm4gb3V0O1xyXG4gIC8vIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgUXVhdC5cclxuICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLlxyXG4gICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0LlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1YXQoLi4uYXJncylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgUXVhdCB0byB3cmFwIGV4aXN0aW5nIG1lbW9yeSBpbiBhIGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1F1YXR9IC0gUmV0dXJucyBhIG5ldyBRdWF0LlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIoYnVmZmVyLCBvZmZzZXQgPSAwKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQsIHVzZSAjY3JlYXRlRnJvbUJ1ZmZlciBpbnN0ZWFkJylcclxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUZyb21CdWZmZXIoYnVmZmVyLCBvZmZzZXQgKiA0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGBRdWF0YCB1c2luZyBhbiBBcnJheUJ1ZmZlci5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgLSBUaGUgYnVmZmVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIG9mZnNldCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBuZXcgUXVhdC5cclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIsIGJ5dGVPZmZzZXQpIHtcclxuICAgIHJldHVybiBuZXcgUXVhdChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgRmxvYXQzMiBlbGVtZW50cyB1c2VkIGJ5IHRoaXMgdHlwZS4gVXNlZCB0byBjYWxjdWxhdGUgc3RvcmFnZSByZXF1aXJlbWVudHMgZm9yIGxhcmdlIGFycmF5cyBvZiB0aGlzIHR5cGUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgbnVtRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gNFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmVzIHRoaXMgUXVhdCBhbmQgcmV0dXJucyBhIG5ldyBRdWF0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgbmV3IFF1YXQuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1YXQodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbM10pXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBQZXJzaXN0ZW5jZVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHRoaXMueCxcclxuICAgICAgeTogdGhpcy55LFxyXG4gICAgICB6OiB0aGlzLnosXHJcbiAgICAgIHc6IHRoaXMudyxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICBmcm9tSlNPTihqKSB7XHJcbiAgICB0aGlzLl9fZGF0YVswXSA9IGoueFxyXG4gICAgdGhpcy5fX2RhdGFbMV0gPSBqLnlcclxuICAgIHRoaXMuX19kYXRhWzJdID0gai56XHJcbiAgICB0aGlzLl9fZGF0YVszXSA9IGoud1xyXG4gICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS5cclxuICAgKi9cclxuICByZWFkQmluYXJ5KHJlYWRlcikge1xyXG4gICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpXHJcbiAgICB0aGlzLnogPSByZWFkZXIubG9hZEZsb2F0MzIoKVxyXG4gICAgdGhpcy53ID0gcmVhZGVyLmxvYWRGbG9hdDMyKClcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdRdWF0JywgUXVhdClcclxuXHJcbmV4cG9ydCB7IFF1YXQgfVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG5pbXBvcnQgU3RyaW5nRnVuY3Rpb25zIGZyb20gJy4uL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSByYXkgdGhhdCBlbWl0cyBmcm9tIGFuIG9yaWdpbiBpbiBhIHNwZWNpZmllZCBkaXJlY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBSYXkge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gc3RhcnQgLSBUaGUgb3JpZ2luIG9mIHRoZSByYXkuXHJcbiAgICogQHBhcmFtIHtWZWMzfSBkaXIgLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSByYXkuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc3RhcnQgPSB1bmRlZmluZWQsIGRpciA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgVmVjMykge1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgVmVjMygpXHJcbiAgICB9XHJcbiAgICBpZiAoZGlyIGluc3RhbmNlb2YgVmVjMykge1xyXG4gICAgICB0aGlzLmRpciA9IGRpclxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kaXIgPSBuZXcgVmVjMygpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHBvaW50IC0gVGhlIHBvaW50IGluIDNEIHNwYWNlLlxyXG4gICAqIEByZXR1cm4ge1JheX0gLSBSZXR1cm5zIGEgUmF5LlxyXG4gICAqL1xyXG4gIGNsb3Nlc3RQb2ludChwb2ludCkge1xyXG4gICAgY29uc3QgdyA9IHBvaW50LnN1YnRyYWN0KHRoaXMuc3RhcnQpXHJcbiAgICBjb25zdCBjMSA9IHcuZG90KHRoaXMuZGlyKVxyXG4gICAgaWYgKGMxIDwgTnVtYmVyLkVQU0lMT04pIHJldHVybiB0aGlzLnN0YXJ0XHJcbiAgICBjb25zdCBjMiA9IHRoaXMuZGlyLmRvdCh0aGlzLmRpcilcclxuICAgIC8vIGlmIChjMiA8IE51bWJlci5FUFNJTE9OKSByZXR1cm4gdGhpcy5zdGFydFxyXG4gICAgY29uc3QgZnJhY3QgPSBjMSAvIGMyXHJcbiAgICByZXR1cm4gdGhpcy5zdGFydC5hZGQodGhpcy5kaXIuc2NhbGUoZnJhY3QpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjbG9zZXN0IHBvaW50IGF0IGEgZGlzdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGRpc3QgLSBUaGUgZGlzdGFuY2UgdmFsdWUuXHJcbiAgICogQHJldHVybiB7UmF5fSAtIFJldHVybnMgYSBSYXkuXHJcbiAgICovXHJcbiAgcG9pbnRBdERpc3QoZGlzdCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhcnQuYWRkKHRoaXMuZGlyLnNjYWxlKGRpc3QpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdHdvIHJheSBwYXJhbXMgdGhhdCByZXByZXNlbnQgdGhlIGNsb3Nlc3QgcG9pbnQgYmV0d2VlbiB0aGUgdHdvIHJheXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JheX0gcmF5IC0gVGhlIHJheSB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtSYXl9IC0gUmV0dXJucyBhIFJheS5cclxuICAgKi9cclxuICBpbnRlcnNlY3RSYXlWZWN0b3IocmF5KSB7XHJcbiAgICBjb25zdCB1ID0gdGhpcy5kaXJcclxuICAgIGNvbnN0IHYgPSByYXkuZGlyXHJcbiAgICBjb25zdCB3ID0gdGhpcy5zdGFydC5zdWJ0cmFjdChyYXkuc3RhcnQpXHJcbiAgICBjb25zdCBhID0gdS5kb3QodSkgLy8gYWx3YXlzID49IDBcclxuICAgIGNvbnN0IGIgPSB1LmRvdCh2KVxyXG4gICAgY29uc3QgYyA9IHYuZG90KHYpIC8vIGFsd2F5cyA+PSAwXHJcbiAgICBjb25zdCBkID0gdS5kb3QodylcclxuICAgIGNvbnN0IGUgPSB2LmRvdCh3KVxyXG4gICAgaWYgKGEgPT0gMC4wICYmIGMgPT0gMC4wKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8ocmF5LnN0YXJ0KVxyXG4gICAgfVxyXG4gICAgaWYgKGEgPT0gMC4wKSB7XHJcbiAgICAgIHJldHVybiByYXkuY2xvc2VzdFBvaW50KHRoaXMuc3RhcnQpXHJcbiAgICB9XHJcbiAgICBpZiAoYyA9PSAwLjApIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdFBvaW50KHJheS5zdGFydClcclxuICAgIH1cclxuICAgIGNvbnN0IEQgPSBhICogYyAtIGIgKiBiIC8vIGFsd2F5cyA+PSAwXHJcblxyXG4gICAgLy8gY29tcHV0ZSB0aGUgcmF5IHBhcmFtZXRlcnMgb2YgdGhlIHR3byBjbG9zZXN0IHBvaW50c1xyXG4gICAgbGV0IHRoaXNfdFxyXG4gICAgbGV0IHJheV90XHJcbiAgICBpZiAoRCA8IDAuMDAxKSB7XHJcbiAgICAgIC8vIHRoZSBsaW5lcyBhcmUgYWxtb3N0IHBhcmFsbGVsXHJcbiAgICAgIHRoaXNfdCA9IDAuMFxyXG4gICAgICBpZiAoYiA+IGMpIHtcclxuICAgICAgICAvLyB1c2UgdGhlIGxhcmdlc3QgZGVub21pbmF0b3JcclxuICAgICAgICByYXlfdCA9IGQgLyBiXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmF5X3QgPSBlIC8gY1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzX3QgPSAoYiAqIGUgLSBjICogZCkgLyBEXHJcbiAgICAgIHJheV90ID0gKGEgKiBlIC0gYiAqIGQpIC8gRFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFt0aGlzX3QsIHJheV90XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvbmUgcmF5IHBhcmFtIHJlcHJlc2VudGluZyB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICogb2YgdGhpcyByYXkgYWdhaW5zdCB0aGUgcGxhbmUgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gcmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwbGFuZSAtIFRoZSBwbGFuZSB0byBpbnRlcnNlY3Qgd2l0aC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBpbnRlcnNlY3RSYXlQbGFuZShwbGFuZSkge1xyXG4gICAgY29uc3QgdyA9IHRoaXMuc3RhcnQuc3VidHJhY3QocGxhbmUuc3RhcnQpXHJcbiAgICBjb25zdCBEID0gcGxhbmUuZGlyLmRvdCh0aGlzLmRpcilcclxuICAgIGNvbnN0IE4gPSAtcGxhbmUuZGlyLmRvdCh3KVxyXG5cclxuICAgIGlmIChNYXRoLmFicyhEKSA8IE51bWJlci5QUkVDSVNJT04pIHtcclxuICAgICAgLy8gc2VnbWVudCBpcyBwYXJhbGxlbCB0byBwbGFuZVxyXG4gICAgICBpZiAoTiA9PSAwLjApIHJldHVybiAtMS4wXHJcbiAgICAgIC8vIHNlZ21lbnQgbGllcyBpbiBwbGFuZVxyXG4gICAgICBlbHNlIHJldHVybiAtMS4wIC8vIG5vIGludGVyc2VjdGlvblxyXG4gICAgfVxyXG4gICAgLy8gdGhleSBhcmUgbm90IHBhcmFsbGVsXHJcbiAgICAvLyBjb21wdXRlIGludGVyc2VjdCBwYXJhbVxyXG4gICAgY29uc3Qgc0kgPSBOIC8gRFxyXG4gICAgaWYgKHNJIDwgLU51bWJlci5QUkVDSVNJT04pIHtcclxuICAgICAgcmV0dXJuIC0xIC8vIG5vIGludGVyc2VjdGlvblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNJXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBSYXkgYW5kIHJldHVybnMgYSBuZXcgUmF5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UmF5fSAtIFJldHVybnMgYSBuZXcgUmF5LlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBSYXkodGhpcy5zdGFydC5jbG9uZSgpLCB0aGlzLmRpci5jbG9uZSgpKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgUmF5LlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7UmF5fSAtIFJldHVybnMgYSBuZXcgUmF5LlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IFJheSguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcclxuICAgICAgZGlyOiB0aGlzLmRpcixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICBmcm9tSlNPTihqKSB7XHJcbiAgICB0aGlzLnN0YXJ0LmZyb21KU09OKGouc3RhcnQpXHJcbiAgICB0aGlzLmRpci5mcm9tSlNPTihqLmRpcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKVxyXG4gIH1cclxufVxyXG5cclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1JheScsIFJheSlcclxuXHJcbmV4cG9ydCB7IFJheSB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG5pbXBvcnQgU3RyaW5nRnVuY3Rpb25zIGZyb20gJy4uL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuL01hdDQuanMnXHJcbmltcG9ydCB7IFF1YXQgfSBmcm9tICcuL1F1YXQuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuXHJcbmNvbnN0IHNjX2hlbHBlciA9IG5ldyBWZWMzKDEsIDEsIDEpXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIFhmbyB0cmFuc2Zvcm0sIHdoaWNoIGlzIGEgdHJhbnNmb3JtYXRpb24gZGVjb21wb3NlZCBpbnRvIDMgY29tcG9uZW50IHZhbHVlcy4gVHJhbnNsYXRpb24sIE9yaWVudGF0aW9uLCBhbmQgU2NhbGluZy5cclxuICovXHJcbmNsYXNzIFhmbyB7XHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFhmbyBvYmplY3QuXHJcbiAgICogPGJyPlxyXG4gICAqICoqTm90ZToqKiBZb3UgY2FuIGxlYXZlIGl0IGVtcHR5IGFuZCB1c2Ugb3RoZXIgbWV0aG9kcyB0aSBzZXQgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBzZWUgW2BzZXRGcm9tT3RoZXJgXSgjc2V0RnJvbU90aGVyKSBbYGZyb21NYXQ0YF0oI2Zyb21NYXQ0KSBbYHNldEZyb21GbG9hdDMyQXJyYXlgXSgjc2V0RnJvbUZsb2F0MzJBcnJheSkgW2Bmcm9tSlNPTmBdKCNmcm9tSlNPTilcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5IHwgVmVjM30gdHIgLSBUaGUgdHJhbnNsYXRpb24gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtRdWF0fSBvcmkgLSBUaGUgb3JpZW50YXRpb24gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtWZWMzfSBzYyAtIFRoZSBzY2FsaW5nIHZhbHVlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHRyID0gdW5kZWZpbmVkLCBvcmkgPSB1bmRlZmluZWQsIHNjID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy5zZXRGcm9tRmxvYXQzMkFycmF5KHRyKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGlmICh0ciBpbnN0YW5jZW9mIFZlYzMpIHtcclxuICAgICAgdGhpcy50ciA9IHRyXHJcbiAgICB9IGVsc2UgaWYgKHRyIGluc3RhbmNlb2YgUXVhdCAmJiBvcmkgPT0gdW5kZWZpbmVkICYmIHNjID09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRyID0gbmV3IFZlYzMoKVxyXG4gICAgICB0aGlzLm9yaSA9IHRyIC8vIFhmbyBjb25zdHJ1Y3RvciB3aXRoIGp1c3QgYSBRdWF0LlxyXG4gICAgICB0aGlzLnNjID0gbmV3IFZlYzMoMSwgMSwgMSlcclxuICAgICAgcmV0dXJuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyID0gbmV3IFZlYzMoKVxyXG4gICAgfVxyXG4gICAgaWYgKG9yaSBpbnN0YW5jZW9mIFF1YXQpIHtcclxuICAgICAgdGhpcy5vcmkgPSBvcmlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub3JpID0gbmV3IFF1YXQoKVxyXG4gICAgfVxyXG4gICAgaWYgKHNjIGluc3RhbmNlb2YgVmVjMykge1xyXG4gICAgICB0aGlzLnNjID0gc2NcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2MgPSBuZXcgVmVjMygxLCAxLCAxKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIFhmbyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHRyIC0gVGhlIHRyYW5zbGF0aW9uIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7UXVhdH0gb3JpIC0gVGhlIG9yaWVudGF0aW9uIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7VmVjM30gc2MgLSBUaGUgc2NhbGluZyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXQodHIsIG9yaSwgc2MgPSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMudHIgPSB0clxyXG4gICAgdGhpcy5vcmkgPSBvcmlcclxuICAgIGlmIChzYyBpbnN0YW5jZW9mIFZlYzMpIHRoaXMuc2MgPSBzY1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIFhmbyBvYmplY3QgdXNpbmcgYW5vdGhlciBYZm8gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtYZm99IG90aGVyIC0gVGhlIG90aGVyIFhmbyB0byBzZXQgZnJvbS5cclxuICAgKi9cclxuICBzZXRGcm9tT3RoZXIob3RoZXIpIHtcclxuICAgIHRoaXMudHIgPSBvdGhlci50clxyXG4gICAgdGhpcy5vcmkgPSBvdGhlci5vcmlcclxuICAgIHRoaXMuc2MgPSBvdGhlci5zY1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgWGZvIG9iamVjdCBpcyBhbiBgaWRlbnRpdHlgLCBjaGVja2luZyB0aGF0IHRoZSB0cmFuc2xhdGlvbiwgb3JpZW50YXRpb24gYW5kIHNjYWxpbmcgYXR0cmlidXRlcyBhcmUgaW4gdGhlaXIgaW5pdGlhbCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBpc0lkZW50aXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHIuaXNOdWxsKCkgJiYgdGhpcy5vcmkuaXNJZGVudGl0eSgpICYmIHRoaXMuc2MuaXMxMTEoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMyBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGFub3RoZXIgVmVjMy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIGB0cnVlYCBpZiBhcmUgdGhlIHNhbWUgVmVjdG9yLCBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICovXHJcbiAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMudHIuaXNFcXVhbChvdGhlci50cikgJiYgdGhpcy5vcmkuaXNFcXVhbChvdGhlci5vcmkpICYmIHRoaXMuc2MuaXNFcXVhbChvdGhlci5zYylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzIgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLlxyXG4gICAqL1xyXG4gIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKG90aGVyLnRyID8gdGhpcy50ci5hcHByb3hFcXVhbChvdGhlci50ciwgcHJlY2lzaW9uKSA6IHRydWUpICYmXHJcbiAgICAgIChvdGhlci5vcmkgPyB0aGlzLm9yaS5hcHByb3hFcXVhbChvdGhlci5vcmksIHByZWNpc2lvbikgOiB0cnVlKSAmJlxyXG4gICAgICAob3RoZXIuc2MgPyB0aGlzLnNjLmFwcHJveEVxdWFsKG90aGVyLnNjLCBwcmVjaXNpb24pIDogdHJ1ZSlcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzZXRMb29rQXQgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7VmVjM30gcG9zIC0gVGhlIHBvc2l0aW9uIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IC0gVGhlIHRhcmdldCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IHVwIC0gVGhlIHVwIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldExvb2tBdChwb3MsIHRhcmdldCwgdXApIHtcclxuICAgIC8vIE5vdGU6IFdlIGxvb2sgYWxvbmcgdGhlIC16IGF4aXMuIE5lZ2F0ZSB0aGUgZGlyZWN0aW9uLlxyXG4gICAgY29uc3QgZGlyID0gcG9zLnN1YnRyYWN0KHRhcmdldClcclxuICAgIGNvbnN0IGRpckxlbiA9IGRpci5sZW5ndGgoKVxyXG4gICAgaWYgKGRpckxlbiA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaXInKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHRoaXMub3JpLnNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3RvcihkaXIsIHVwKVxyXG4gICAgdGhpcy50ciA9IHBvc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0d28gWGZvIHRyYW5zZm9ybXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1hmb30geGZvIC0gVGhlIHhmbyB0byBtdWx0aXBseSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge1hmb30gLSBSZXR1cm5zIGFuIFhmby5cclxuICAgKi9cclxuICBtdWx0aXBseSh4Zm8pIHtcclxuICAgIGxldCB0aGlzX3NjID0gdGhpcy5zY1xyXG4gICAgaWYgKHRoaXMuc2MueCAhPSB0aGlzLnNjLnkgfHwgdGhpcy5zYy54ICE9IHRoaXMuc2Mueikge1xyXG4gICAgICB0aGlzX3NjID0geGZvLm9yaS5yb3RhdGVWZWMzKHRoaXMuc2MpXHJcbiAgICAgIGlmIChNYXRoLnNpZ24odGhpc19zYy54KSAhPSBNYXRoLnNpZ24odGhpcy5zYy54KSkgdGhpc19zYy54ID0gLXRoaXNfc2MueFxyXG4gICAgICBpZiAoTWF0aC5zaWduKHRoaXNfc2MueSkgIT0gTWF0aC5zaWduKHRoaXMuc2MueSkpIHRoaXNfc2MueSA9IC10aGlzX3NjLnlcclxuICAgICAgaWYgKE1hdGguc2lnbih0aGlzX3NjLnopICE9IE1hdGguc2lnbih0aGlzLnNjLnopKSB0aGlzX3NjLnogPSAtdGhpc19zYy56XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgWGZvKFxyXG4gICAgICB0aGlzLnRyLmFkZCh0aGlzLm9yaS5yb3RhdGVWZWMzKHRoaXNfc2MubXVsdGlwbHkoeGZvLnRyKSkpLFxyXG4gICAgICB0aGlzLm9yaS5tdWx0aXBseSh4Zm8ub3JpKSxcclxuICAgICAgdGhpc19zYy5tdWx0aXBseSh4Zm8uc2MpXHJcbiAgICApXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBYZm8gb2JqZWN0LCBidXQgcmV0dXJucy4gdGhlIHJlc3VsdCBhcyBhIG5ldyBYZm8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtYZm99IC0gUmV0dXJucyBhIG5ldyBYZm8uXHJcbiAgICovXHJcbiAgaW52ZXJzZSgpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBYZm8oKVxyXG4gICAgcmVzdWx0Lm9yaSA9IHRoaXMub3JpLmludmVyc2UoKVxyXG5cclxuICAgIGlmICh0aGlzLnNjLnggIT0gdGhpcy5zYy55IHx8IHRoaXMuc2MueCAhPSB0aGlzLnNjLnopIHtcclxuICAgICAgLy8gTm90ZTogdGhlIGZvbGxvd2luZyBjb2RlIGhhcyBub3QgYmVlbiB0ZXN0ZWQgYW5kXHJcbiAgICAgIC8vIG1heSBub3QgYmUgcXVpdGUgY29ycmVjdC4gV2UgbmVlZCB0byBzZXR1cFxyXG4gICAgICAvLyB1bml0IHRlc3RzIGZvciB0aGlzIGtpbmQgb2Ygc2FtcGxlLlxyXG4gICAgICAvLyBBbiBleGFtcGxlIHdvdWxkIGJlIHRvIGxheSBvdXQgc29tZSBib3hlcyBvbiBkaWZmZXJlbnQgcm90YXRpb25zXHJcbiAgICAgIC8vIGFuZCB3aXRoIG5vbi11bmlmb3JtIHNjYWxlLiBUaGVuIHBhcmVudCB0aGVtIHRvZ2V0aGVyLiBJZiB0aGV5XHJcbiAgICAgIC8vIHJlbWFpbiBzdGF0aW9uYXJ5LCBhZnRlciBwYXJlbnRpbmcsIHRoZW4gdGhpcyBtYXRoIGlzIGNvcnJlY3QuXHJcbiAgICAgIHJlc3VsdC5zYyA9IHJlc3VsdC5vcmkucm90YXRlVmVjMyh0aGlzLnNjKVxyXG4gICAgICBpZiAoTWF0aC5zaWduKHJlc3VsdC5zYy54KSAhPSBNYXRoLnNpZ24odGhpcy5zYy54KSkgcmVzdWx0LnNjLnggPSAtcmVzdWx0LnNjLnhcclxuICAgICAgaWYgKE1hdGguc2lnbihyZXN1bHQuc2MueSkgIT0gTWF0aC5zaWduKHRoaXMuc2MueSkpIHJlc3VsdC5zYy55ID0gLXJlc3VsdC5zYy55XHJcbiAgICAgIGlmIChNYXRoLnNpZ24ocmVzdWx0LnNjLnopICE9IE1hdGguc2lnbih0aGlzLnNjLnopKSByZXN1bHQuc2MueiA9IC1yZXN1bHQuc2MuelxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0LnNjID0gdGhpcy5zYy5pbnZlcnNlKClcclxuICAgIH1cclxuICAgIHJlc3VsdC50ciA9IHJlc3VsdC5vcmkucm90YXRlVmVjMyh0aGlzLnRyLm5lZ2F0ZSgpLm11bHRpcGx5KHJlc3VsdC5zYykpXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIFhmbyBvYmplY3QgdXNpbmcgYSBgVmVjM2Agb2JqZWN0LiBGaXJzdCBzY2FsaW5nIGl0LCB0aGVuIHJvdGF0aW5nIGFuZCBmaW5hbGx5IGFkZGluZyB0aGUgcmVzdWx0IHRvIGN1cnJlbnQgdHJhbnNsYXRpb24gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHRyYW5zZm9ybVZlYzModmVjMykge1xyXG4gICAgcmV0dXJuIHRoaXMudHIuYWRkKHRoaXMub3JpLnJvdGF0ZVZlYzModGhpcy5zYy5tdWx0aXBseSh2ZWMzKSkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyB0aGlzIFhmbyB0byBhIE1hdDQgKGEgNHg0IG1hdHJpeCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC5cclxuICAgKi9cclxuICB0b01hdDQoKSB7XHJcbiAgICBjb25zdCBzY2wgPSBuZXcgTWF0NCh0aGlzLnNjLngsIDAsIDAsIDAsIDAsIHRoaXMuc2MueSwgMCwgMCwgMCwgMCwgdGhpcy5zYy56LCAwLCAwLCAwLCAwLCAxLjApXHJcblxyXG4gICAgY29uc3Qgcm90ID0gdGhpcy5vcmkudG9NYXQ0KClcclxuXHJcbiAgICBjb25zdCB0cm4gPSBuZXcgTWF0NCgpXHJcbiAgICB0cm4udHJhbnNsYXRpb24gPSB0aGlzLnRyXHJcblxyXG4gICAgcmV0dXJuIHRybi5tdWx0aXBseShyb3QpLm11bHRpcGx5KHNjbClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBYZm8gb2JqZWN0IHVzaW5nIE1hdDQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge01hdDR9IG1hdDQgLSBUaGUgbWF0NCB2YWx1ZS5cclxuICAgKi9cclxuICBmcm9tTWF0NChtYXQ0KSB7XHJcbiAgICB0aGlzLnRyID0gbWF0NC50cmFuc2xhdGlvblxyXG4gICAgdGhpcy5vcmkuc2V0RnJvbU1hdDQobWF0NClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBYZm8gb2JqZWN0IHVzaW5nIGFuIGBGbG9hdDMyYXJyYXlgLlxyXG4gICAqIDxicj5cclxuICAgKiAqKk5vdGU6KiogWW91IGNhbiBzZXQgdGhlIGJ5dGVPZmZzZXQgaW4geW91ciBgRmxvYXQzMmFycmF5YCBvYmplY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmbG9hdDMyYXJyYXkgLSBUaGUgZmxvYXQzMmFycmF5IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZyb21GbG9hdDMyQXJyYXkoZmxvYXQzMmFycmF5KSB7XHJcbiAgICBpZiAoZmxvYXQzMmFycmF5Lmxlbmd0aCA9PSA3KSB7XHJcbiAgICAgIHRoaXMudHIgPSBuZXcgVmVjMyhmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldClcclxuICAgICAgdGhpcy5vcmkgPSBuZXcgUXVhdChmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCArIDEyKVxyXG4gICAgICB0aGlzLnNjID0gbmV3IFZlYzMoMSwgMSwgMSlcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBpZiAoZmxvYXQzMmFycmF5Lmxlbmd0aCA9PSA4KSB7XHJcbiAgICAgIHRoaXMudHIgPSBuZXcgVmVjMyhmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldClcclxuICAgICAgdGhpcy5vcmkgPSBuZXcgUXVhdChmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCArIDEyKVxyXG4gICAgICBjb25zdCBzY2wgPSBmbG9hdDMyYXJyYXlbN11cclxuICAgICAgdGhpcy5zYyA9IG5ldyBWZWMzKHNjbCwgc2NsLCBzY2wpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgaWYgKGZsb2F0MzJhcnJheS5sZW5ndGggPT0gMTApIHtcclxuICAgICAgdGhpcy50ciA9IG5ldyBWZWMzKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0KVxyXG4gICAgICB0aGlzLm9yaSA9IG5ldyBRdWF0KGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0ICsgMTIpXHJcbiAgICAgIHRoaXMuc2MgPSBuZXcgVmVjMyhmbG9hdDMyYXJyYXkuYnVmZmVyLCBmbG9hdDMyYXJyYXkuYnl0ZU9mZnNldCArIDIxKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIFhmbyBhbmQgcmV0dXJucyBhIG5ldyBYZm8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtYZm99IC0gUmV0dXJucyBhIG5ldyBYZm8uXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFhmbyh0aGlzLnRyLmNsb25lKCksIHRoaXMub3JpLmNsb25lKCksIHRoaXMuc2MuY2xvbmUoKSlcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFhmby5cclxuICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLlxyXG4gICAqIEByZXR1cm4ge1hmb30gLSBldHVybnMgYSBuZXcgWGZvLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IFhmbyguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIHRvSlNPTigpIHtcclxuICAgIGNvbnN0IGogPSB7XHJcbiAgICAgIHRyOiB0aGlzLnRyLnRvSlNPTigpLFxyXG4gICAgICBvcmk6IHRoaXMub3JpLnRvSlNPTigpLFxyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLnNjLmlzMTExKCkpIGouc2MgPSB0aGlzLnNjLnRvSlNPTigpXHJcbiAgICByZXR1cm4galxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZyb21KU09OKGopIHtcclxuICAgIHRoaXMudHIuZnJvbUpTT04oai50cilcclxuICAgIHRoaXMub3JpLmZyb21KU09OKGoub3JpKVxyXG4gICAgaWYgKGouc2MpIHtcclxuICAgICAgdGhpcy5zYy5mcm9tSlNPTihqLnNjKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlYWRCaW5hcnkocmVhZGVyKSB7XHJcbiAgICB0aGlzLnRyLnJlYWRCaW5hcnkocmVhZGVyKVxyXG4gICAgdGhpcy5vcmkucmVhZEJpbmFyeShyZWFkZXIpXHJcbiAgICB0aGlzLnNjLnJlYWRCaW5hcnkocmVhZGVyKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcclxuICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKVxyXG4gIH1cclxufVxyXG5cclxuUmVnaXN0cnkucmVnaXN0ZXIoJ1hmbycsIFhmbylcclxuXHJcbmV4cG9ydCB7IFhmbyB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG5pbXBvcnQgU3RyaW5nRnVuY3Rpb25zIGZyb20gJy4uL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMnXHJcblxyXG5pbXBvcnQgeyBWZWMyIH0gZnJvbSAnLi9WZWMyJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJveCBpbiAyRCBzcGFjZS4gTmVlZGluZyB0d28gVmVjMiB2ZWN0b3JzIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnNcclxuICovXHJcbmNsYXNzIEJveDIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBCb3gyIG9iamVjdCB1c2luZyBWZWMycy5cclxuICAgKiBJbiBjYXNlIHRoZSBwYXJhbWV0ZXJzIGFyZSBub3QgcGFzc2VkIGJ5LCB0aGVpciB2YWx1ZXMgYXJlIHByZS1kZWZpbmVkOlxyXG4gICAqIDxicj5cclxuICAgKiBwMCBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfVxyXG4gICAqIDxicj5cclxuICAgKiBwMSBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL05FR0FUSVZFX0lORklOSVRZfGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgfVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94LlxyXG4gICAqIEBwYXJhbSB7VmVjMn0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihwMCA9IHVuZGVmaW5lZCwgcDEgPSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChwMCBpbnN0YW5jZW9mIFZlYzIpIHtcclxuICAgICAgdGhpcy5wMCA9IHAwXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnAwID0gbmV3IFZlYzIoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXHJcbiAgICB9XHJcbiAgICBpZiAocDEgaW5zdGFuY2VvZiBWZWMyKSB7XHJcbiAgICAgIHRoaXMucDEgPSBwMVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wMSA9IG5ldyBWZWMyKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBib3RoIFZlY3QyIHBvaW50c1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94LlxyXG4gICAqIEBwYXJhbSB7VmVjMn0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC5cclxuICAgKi9cclxuICBzZXQocDAsIHAxKSB7XHJcbiAgICB0aGlzLnAwID0gcDBcclxuICAgIHRoaXMucDEgPSBwMVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBib3gyIGJhY2sgdG8gYW4gdW5pbml0aWFsaXplZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9QT1NJVElWRV9JTkZJTklUWXxgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYH1cclxuICAgKiBhbmQge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9ORUdBVElWRV9JTkZJTklUWXxgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZYH1cclxuICAgKi9cclxuICByZXNldCgpIHtcclxuICAgIHRoaXMucDAueCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gICAgdGhpcy5wMS54ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICB0aGlzLnAwLnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcclxuICAgIHRoaXMucDEueSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJveCBoYXMgYmVlbiBleHBhbmRlZCB0byBjb250YWluIGEgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgaXNWYWxpZCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMucDAueCAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiZcclxuICAgICAgdGhpcy5wMS54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAmJlxyXG4gICAgICB0aGlzLnAwLnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmXHJcbiAgICAgIHRoaXMucDEueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4cGFuZHMgdGhlIEJveDIgdG8gY29udGFpbiB0aGUgbmV3IHBvaW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMyfSBwb2ludCAtIEEgcG9pbnQgcmVwcmVzZW50cyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC5cclxuICAgKi9cclxuICBhZGRQb2ludChwb2ludCkge1xyXG4gICAgaWYgKHRoaXMucDAueCA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueCA8IHRoaXMucDAueCkgdGhpcy5wMC54ID0gcG9pbnQueFxyXG4gICAgaWYgKHRoaXMucDAueSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueSA8IHRoaXMucDAueSkgdGhpcy5wMC55ID0gcG9pbnQueVxyXG5cclxuICAgIGlmICh0aGlzLnAxLnkgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHBvaW50LnggPiB0aGlzLnAxLngpIHRoaXMucDEueCA9IHBvaW50LnhcclxuICAgIGlmICh0aGlzLnAxLnkgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHBvaW50LnkgPiB0aGlzLnAxLnkpIHRoaXMucDEueSA9IHBvaW50LnlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBCb3gyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm94Mn0gLSBSZXR1cm5zIGEgQm94Mi5cclxuICAgKi9cclxuICBzaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBCb3gyIC0gdGhlIHNhbWUgYXMgc2l6ZSgpLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm94Mn0gLSBSZXR1cm5zIGEgQm94Mi5cclxuICAgKi9cclxuICBkaWFnb25hbCgpIHtcclxuICAgIHJldHVybiB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgYSBCb3gyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgVmVjMi5cclxuICAgKi9cclxuICBjZW50ZXIoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApXHJcbiAgICByZXN1bHQuc2NhbGVJblBsYWNlKDAuNSlcclxuICAgIHJlc3VsdC5hZGRJblBsYWNlKHRoaXMucDApXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gU3RhdGljIE1ldGhvZHNcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBCb3gyLlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7Qm94Mn0gLSBSZXR1cm5zIGEgbmV3IEJveDIuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgQm94MiguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIEVuY29kZXMgYEJveDJgIENsYXNzIGFzIGEgSlNPTiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwMDogdGhpcy5wMC50b0pTT04oKSxcclxuICAgICAgcDE6IHRoaXMucDEudG9KU09OKCksXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxyXG4gICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignQm94MicsIEJveDIpXHJcblxyXG5leHBvcnQgeyBCb3gyIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuaW1wb3J0IFN0cmluZ0Z1bmN0aW9ucyBmcm9tICcuLi9VdGlsaXRpZXMvU3RyaW5nRnVuY3Rpb25zJ1xyXG5pbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5pbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi9WZWMzLmpzJ1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNwaGVyZS5cclxuICpcclxuICogQGV4dGVuZHMgQXR0clZhbHVlXHJcbiAqL1xyXG5jbGFzcyBTcGhlcmVUeXBlIGV4dGVuZHMgQXR0clZhbHVlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBzcGhlcmUuXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwb3MgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHNwaGVyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBvcywgcmFkaXVzID0gMCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgaWYgKHBvcyBpbnN0YW5jZW9mIFZlYzMpIHtcclxuICAgICAgdGhpcy5wb3MgPSBwb3NcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucG9zID0gbmV3IFZlYzMoKVxyXG4gICAgfVxyXG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIHNwaGVyZSBhbmQgcmV0dXJucyBhIG5ldyBzcGhlcmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGhlcmV9IC0gUmV0dXJucyBhIG5ldyBzcGhlcmUuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFNwaGVyZSh0aGlzLnBvcy5jbG9uZSgpLCB0aGlzLnJhZGl1cylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIHNwaGVyZSBpbnRlcnNlY3RzIGEgYm94LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCb3gzfSBib3ggLSBUaGUgYm94IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBpbnRlcnNlY3RzQm94KGJveCkge1xyXG4gICAgcmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKHRoaXMpXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBQZXJzaXN0ZW5jZVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcG9zOiB0aGlzLnBvcy50b0pTT04oKSxcclxuICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgc3BoZXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi5vYmplY3R9IC4uLmFyZ3MgLSBUaGUgLi4uYXJncyBwYXJhbS5cclxuICAgKiBAcmV0dXJuIHtTcGhlcmV9IC0gUmV0dXJucyBhIG5ldyBzcGhlcmUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgU3BoZXJlKC4uLmFyZ3MpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignU3BoZXJlVHlwZScsIFNwaGVyZVR5cGUpXHJcblxyXG5leHBvcnQgeyBTcGhlcmVUeXBlIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXHJcbmltcG9ydCBTdHJpbmdGdW5jdGlvbnMgZnJvbSAnLi4vVXRpbGl0aWVzL1N0cmluZ0Z1bmN0aW9ucydcclxuaW1wb3J0IE1hdGhGdW5jdGlvbnMgZnJvbSAnLi4vVXRpbGl0aWVzL01hdGhGdW5jdGlvbnMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuL01hdDQuanMnXHJcbmltcG9ydCB7IFNwaGVyZVR5cGUgfSBmcm9tICcuL1NwaGVyZVR5cGUuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBib3ggaW4gM0Qgc3BhY2UuXHJcbiAqIFJlcHJlc2VudHMgYSBib3ggaW4gM0Qgc3BhY2UgZGVmaW5lZCBieSB0d28gVmVjMyB2YWx1ZXMgd2hpY2ggZGVmaW5lIG9wcG9zaW5nIGNvcm5lcnMgb2YgdGhlIGJveC5cclxuICovXHJcbmNsYXNzIEJveDMge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBCb3gzIG9iamVjdCB1c2luZyBWZWMzcy5cclxuICAgKiBJbiBjYXNlIHRoZSBwYXJhbWV0ZXJzIGFyZSBub3QgcGFzc2VkIGJ5LCB0aGVpciB2YWx1ZXMgYXJlIHByZS1kZWZpbmVkOlxyXG4gICAqIDxicj5cclxuICAgKiBwMCBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfVxyXG4gICAqIDxicj5cclxuICAgKiBwMSBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL05FR0FUSVZFX0lORklOSVRZfGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgfVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94LlxyXG4gICAqIEBwYXJhbSB7VmVjM30gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihwMCA9IHVuZGVmaW5lZCwgcDEgPSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChwMCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLnNldEZyb21GbG9hdDMyQXJyYXkocDApXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgaWYgKHAwIGluc3RhbmNlb2YgVmVjMykge1xyXG4gICAgICB0aGlzLnAwID0gcDBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucDAgPSBuZXcgVmVjMyhOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxyXG4gICAgfVxyXG4gICAgaWYgKHAxIGluc3RhbmNlb2YgVmVjMykge1xyXG4gICAgICB0aGlzLnAxID0gcDFcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucDEgPSBuZXcgVmVjMyhOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0dGVyIGZvciB0aGUgbG93ZXIgKHgsIHksIHopIGJvdW5kYXJ5IG9mIHRoZSBib3guXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgdGhlIG1pbnVtdW0gVmVjMy5cclxuICAgKi9cclxuICBnZXQgbWluKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucDBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHRlciBmb3IgdGhlIHVwcGVyICh4LCB5LCB6KSBib3VuZGFyeSBvZiB0aGUgYm94LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBSZXR1cm5zIHRoZSBtaW51bXVtIFZlYzMuXHJcbiAgICovXHJcbiAgZ2V0IG1heCgpIHtcclxuICAgIHJldHVybiB0aGlzLnAxXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGJvdGggVmVjdDMgcG9pbnRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHAwIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guXHJcbiAgICogQHBhcmFtIHtWZWMzfSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94LlxyXG4gICAqL1xyXG4gIHNldChwMCwgcDEpIHtcclxuICAgIHRoaXMucDAgPSBwMFxyXG4gICAgdGhpcy5wMSA9IHAxXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgdGhlIGJveDMgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLlxyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG4gICAgdGhpcy5wMC54ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXHJcbiAgICB0aGlzLnAxLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgIHRoaXMucDAueSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gICAgdGhpcy5wMS55ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICB0aGlzLnAwLnogPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcclxuICAgIHRoaXMucDEueiA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJveCBoYXMgYmVlbiBleHBhbmRlZCB0byBjb250YWluIGEgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgaXNWYWxpZCgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMucDAueCAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiZcclxuICAgICAgdGhpcy5wMS54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAmJlxyXG4gICAgICB0aGlzLnAwLnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmXHJcbiAgICAgIHRoaXMucDEueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgJiZcclxuICAgICAgdGhpcy5wMC56ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJlxyXG4gICAgICB0aGlzLnAxLnogIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHBhbmRzIHRoZSBCb3gzIHRvIGNvbnRhaW4gdGhlIG5ldyBwb2ludC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VmVjM30gcG9pbnQgLSBBIHBvaW50IHJlcHJlc2VudHMgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guXHJcbiAgICovXHJcbiAgYWRkUG9pbnQocG9pbnQpIHtcclxuICAgIGlmIChwb2ludC54ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBwb2ludC54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xyXG4gICAgICBpZiAocG9pbnQueCA8IHRoaXMucDAueCkgdGhpcy5wMC54ID0gcG9pbnQueFxyXG4gICAgICBpZiAocG9pbnQueCA+IHRoaXMucDEueCkgdGhpcy5wMS54ID0gcG9pbnQueFxyXG4gICAgfVxyXG4gICAgaWYgKHBvaW50LnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIHBvaW50LnkgIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XHJcbiAgICAgIGlmIChwb2ludC55IDwgdGhpcy5wMC55KSB0aGlzLnAwLnkgPSBwb2ludC55XHJcbiAgICAgIGlmIChwb2ludC55ID4gdGhpcy5wMS55KSB0aGlzLnAxLnkgPSBwb2ludC55XHJcbiAgICB9XHJcbiAgICBpZiAocG9pbnQueiAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYgcG9pbnQueiAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgaWYgKHBvaW50LnogPCB0aGlzLnAwLnopIHRoaXMucDAueiA9IHBvaW50LnpcclxuICAgICAgaWYgKHBvaW50LnogPiB0aGlzLnAxLnopIHRoaXMucDEueiA9IHBvaW50LnpcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYEJveDNgIHRvIHRoaXMgYEJveDNgLCBvZiB0aGUgWGZvIGluc3RhbmNlIGlzIHBhc3NlZCBpbiB0aGUgcGFyYW1ldGVyc1xyXG4gICAqIGl0IHByb2NlZWRzIHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gZm9yIHRoZSBWZWMzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCb3gzfSBib3gzIC0gQSAzRCBib3guXHJcbiAgICogQHBhcmFtIHtYZm99IHhmbyAtIEEgM0QgdHJhbnNmb3JtLlxyXG4gICAqL1xyXG4gIGFkZEJveDMoYm94MywgeGZvID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoeGZvKSB7XHJcbiAgICAgIC8vIFRyYW5zZm9ybSBlYWNoIGNvcm5lciBvZiB0aGUgQm94MyBpbnRvIHRoZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMoYm94My5wMCkpXHJcbiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMoYm94My5wMC54LCBib3gzLnAwLnksIGJveDMucDEueikpKVxyXG4gICAgICB0aGlzLmFkZFBvaW50KHhmby50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzKGJveDMucDAueCwgYm94My5wMS55LCBib3gzLnAwLnopKSlcclxuICAgICAgdGhpcy5hZGRQb2ludCh4Zm8udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDAueSwgYm94My5wMC56KSkpXHJcbiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMoYm94My5wMC54LCBib3gzLnAxLnksIGJveDMucDEueikpKVxyXG4gICAgICB0aGlzLmFkZFBvaW50KHhmby50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzKGJveDMucDEueCwgYm94My5wMC55LCBib3gzLnAxLnopKSlcclxuICAgICAgdGhpcy5hZGRQb2ludCh4Zm8udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDEueSwgYm94My5wMC56KSkpXHJcbiAgICAgIHRoaXMuYWRkUG9pbnQoeGZvLnRyYW5zZm9ybVZlYzMoYm94My5wMSkpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZFBvaW50KGJveDMucDApXHJcbiAgICAgIHRoaXMuYWRkUG9pbnQoYm94My5wMSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIEJveDMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtCb3gzfSAtIFJldHVybnMgYSBCb3gzLlxyXG4gICAqL1xyXG4gIHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wMS5zdWJ0cmFjdCh0aGlzLnAwKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiBhIEJveDMgLSB0aGUgc2FtZSBhcyBzaXplKCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtCb3gzfSAtIFJldHVybnMgYSBCb3gzLlxyXG4gICAqL1xyXG4gIGRpYWdvbmFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiBhIEJveDMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBWZWMzLlxyXG4gICAqL1xyXG4gIGNlbnRlcigpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucDEuc3VidHJhY3QodGhpcy5wMClcclxuICAgIHJlc3VsdC5zY2FsZUluUGxhY2UoMC41KVxyXG4gICAgcmVzdWx0LmFkZEluUGxhY2UodGhpcy5wMClcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoaXMgQm94MyB0byBhIE1hdDQgKGEgNHg0IG1hdHJpeCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNYXQ0fSAtIFJldHVybnMgYSBuZXcgTWF0NC5cclxuICAgKi9cclxuICB0b01hdDQoKSB7XHJcbiAgICBjb25zdCBzY3ggPSB0aGlzLnAxLnggLSB0aGlzLnAwLnhcclxuICAgIGNvbnN0IHNjeSA9IHRoaXMucDEueSAtIHRoaXMucDAueVxyXG4gICAgY29uc3Qgc2N6ID0gdGhpcy5wMS56IC0gdGhpcy5wMC56XHJcbiAgICByZXR1cm4gbmV3IE1hdDQoc2N4LCAwLCAwLCAwLCAwLCBzY3ksIDAsIDAsIDAsIDAsIHNjeiwgMCwgdGhpcy5wMC54LCB0aGlzLnAwLnksIHRoaXMucDAueiwgMS4wKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgYm91bmRpbmcgU3BoZXJlIG9mIHRoZSBCb3gzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGhlcmVUeXBlfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0Qm91bmRpbmdTcGhlcmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFNwaGVyZVR5cGUodGhpcy5jZW50ZXIoKSwgdGhpcy5kaWFnb25hbCgpLmxlbmd0aCgpICogMC41KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEJveDMgaW50ZXJzZWN0cyBhIHBsYW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCb3gzfSBib3ggLSBUaGUgYm94IHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gYWdhaW5zdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgaW50ZXJzZWN0c0JveChib3gpIHtcclxuICAgIC8vIFVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG4gICAgcmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHxcclxuICAgICAgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG4gICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8XHJcbiAgICAgIGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcclxuICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fFxyXG4gICAgICBib3gubWluLnogPiB0aGlzLm1heC56XHJcbiAgICAgID8gZmFsc2VcclxuICAgICAgOiB0cnVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgQm94MyBpbnRlcnNlY3RzIGEgc3BoZXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xyXG4gICAgLy8gdmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cclxuICAgIC8vIHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7XHJcblxyXG4gICAgLy8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXHJcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHNwaGVyZS5jZW50ZXIpIDw9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgQm94MyBpbnRlcnNlY3RzIGEgcGxhbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSAtIFRoZSBwbGFuZSB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIGFnYWluc3QuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGludGVyc2VjdHNQbGFuZShwbGFuZSkge1xyXG4gICAgLy8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xyXG4gICAgLy8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXHJcblxyXG4gICAgbGV0IG1pblxyXG4gICAgbGV0IG1heFxyXG5cclxuICAgIGlmIChwbGFuZS5ub3JtYWwueCA+IDApIHtcclxuICAgICAgbWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54XHJcbiAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54XHJcbiAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueFxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwbGFuZS5ub3JtYWwueSA+IDApIHtcclxuICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueVxyXG4gICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55XHJcbiAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnlcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGxhbmUubm9ybWFsLnogPiAwKSB7XHJcbiAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLnpcclxuICAgICAgbWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguelxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguelxyXG4gICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbiA8PSAtcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IC1wbGFuZS5jb25zdGFudFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmVzIHRoaXMgQm94MyBhbmQgcmV0dXJucyBhIG5ldyBCb3gzLlxyXG4gICAqIEByZXR1cm4ge0JveDN9IC0gUmV0dXJucyBhIG5ldyBCb3gzLlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBCb3gzKHRoaXMucDAuY2xvbmUoKSwgdGhpcy5wMS5jbG9uZSgpKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFN0YXRpYyBNZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgQm94My5cclxuICAgKiBAcGFyYW0gey4uLm9iamVjdH0gLi4uYXJncyAtIFRoZSAuLi5hcmdzIHBhcmFtLlxyXG4gICAqIEByZXR1cm4ge0JveDN9IC0gUmV0dXJucyBhIG5ldyBCb3gzLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IEJveDMoLi4uYXJncylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzaXplSW5CeXRlcyBtZXRob2QuXHJcbiAgICogQHJldHVybiB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgc2l6ZUluQnl0ZXMoKSB7XHJcbiAgICByZXR1cm4gMjRcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBQZXJzaXN0ZW5jZVxyXG5cclxuICAvKipcclxuICAgKiBFbmNvZGVzIGBCb3gzYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksXHJcbiAgICAgIHAxOiB0aGlzLnAxLnRvSlNPTigpLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb2RlcyBhIEpTT04gb2JqZWN0IHRvIHNldCB0aGUgc3RhdGUgb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZyb21KU09OKGopIHtcclxuICAgIC8vIFdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgcDAgYW5kIHAxIGF4ZXMgYXJlIG51bWVyaWMsIHNvIGluIGNhc2UgdGhleSBhcmUgbm90LCB3ZSByZXN0b3JlIHRoZW0gdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICAvLyBUaGlzLCBiZWNhdXNlICdJbmZpbml0eScgYW5kICctSW5maW5pdHknIGFyZSBzdHJpbmdpZmllZCBhcyAnbnVsbCcuXHJcbiAgICBjb25zdCBwMCA9IHtcclxuICAgICAgeDogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC54KSA/IGoucDAueCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgeTogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC55KSA/IGoucDAueSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgejogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC56KSA/IGoucDAueiA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgIH1cclxuICAgIGNvbnN0IHAxID0ge1xyXG4gICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLngpID8gai5wMS54IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgICB5OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLnkpID8gai5wMS55IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgICB6OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLnopID8gai5wMS56IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgfVxyXG4gICAgdGhpcy5wMC5mcm9tSlNPTihwMClcclxuICAgIHRoaXMucDEuZnJvbUpTT04ocDEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbG9hZEJpbiBtZXRob2QuXHJcbiAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge2FueX0gYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IHZhbHVlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgbG9hZEJpbihkYXRhLCBieXRlT2Zmc2V0KSB7XHJcbiAgICB0aGlzLnAwLmxvYWRCaW4oZGF0YSwgYnl0ZU9mZnNldClcclxuICAgIHRoaXMucDAubG9hZEJpbihkYXRhLCBieXRlT2Zmc2V0ICsgMTIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2V0RnJvbUZsb2F0MzJBcnJheSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZsb2F0MzJhcnJheSAtIFRoZSBmbG9hdDMyYXJyYXkgdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzZXRGcm9tRmxvYXQzMkFycmF5KGZsb2F0MzJhcnJheSkge1xyXG4gICAgdGhpcy5wMCA9IG5ldyBWZWMzKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0KVxyXG4gICAgdGhpcy5wMSA9IG5ldyBWZWMzKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0ICsgMTIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxyXG4gICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpXHJcbiAgfVxyXG59XHJcblxyXG5SZWdpc3RyeS5yZWdpc3RlcignQm94MycsIEJveDMpXHJcblxyXG5leHBvcnQgeyBCb3gzIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuaW1wb3J0IFN0cmluZ0Z1bmN0aW9ucyBmcm9tICcuLi9VdGlsaXRpZXMvU3RyaW5nRnVuY3Rpb25zJ1xyXG5pbXBvcnQgeyBBdHRyVmFsdWUgfSBmcm9tICcuL0F0dHJWYWx1ZS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xyXG5pbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi9WZWMzLmpzJ1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBsYW5lLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyVmFsdWVcclxuICovXHJcbmNsYXNzIFBsYW5lVHlwZSBleHRlbmRzIEF0dHJWYWx1ZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgcGxhbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbCAtIFRoZSBub3JtYWwgb2YgdGhlIHBsYW5lLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3IC0gVGhlIHcgdmFsdWUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iobm9ybWFsLCB3ID0gMCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgaWYgKG5vcm1hbCBpbnN0YW5jZW9mIFZlYzMpIHtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWxcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IFZlYzMoKVxyXG4gICAgfVxyXG4gICAgdGhpcy53ID0gd1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dGVyIGZyb20gc2NhbGFyIGNvbXBvbmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdyAtIFRoZSB3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldCh4LCB5LCB6LCB3KSB7XHJcbiAgICB0aGlzLm5vcm1hbC5zZXQoeCwgeSwgeilcclxuICAgIHRoaXMudyA9IHdcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZXQgZGl2aWRlU2NhbGFyIG1ldGhvZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLlxyXG4gICAqL1xyXG4gIGRpdmlkZVNjYWxhcih2YWx1ZSkge1xyXG4gICAgdGhpcy5ub3JtYWwuc2NhbGVJblBsYWNlKDEgLyB2YWx1ZSlcclxuICAgIHRoaXMudyAvPSB2YWx1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIHRoaXMgcGxhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZlYzN9IHBvaW50IC0gVGhlIHBvaW50IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcnJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcclxuICAgIHJldHVybiBwb2ludC5kb3QodGhpcy5ub3JtYWwpICsgdGhpcy53XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemUgdGhpcyBwbGFuZSBpbiBwbGFjZSBtb2RpZnlpbmcgaXRzIHZhbHVlcy5cclxuICAgKi9cclxuICBub3JtYWxpemVJblBsYWNlKCkge1xyXG4gICAgY29uc3QgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpXHJcbiAgICB0aGlzLm5vcm1hbC5zY2FsZUluUGxhY2UoaW52ZXJzZU5vcm1hbExlbmd0aClcclxuICAgIHRoaXMudyAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBwbGFuZSBhbmQgcmV0dXJucyBhIG5ldyBwbGFuZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1BsYW5lfSAtIFJldHVybnMgYSBuZXcgcGxhbmUuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFBsYW5lKHRoaXMubm9ybWFsLmNsb25lKCksIHRoaXMudylcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IHBsYW5lLlxyXG4gICAqIEBwYXJhbSB7Li4ub2JqZWN0fSAuLi5hcmdzIC0gVGhlIC4uLmFyZ3MgcGFyYW0uXHJcbiAgICogQHJldHVybiB7UGxhbmV9IC0gUmV0dXJucyBhIG5ldyBwbGFuZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGUoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIG5ldyBQbGFuZSguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBub3JtYWw6IHRoaXMubm9ybWFsLnRvSlNPTigpLFxyXG4gICAgICB3OiB0aGlzLncsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSlcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdQbGFuZVR5cGUnLCBQbGFuZVR5cGUpXHJcblxyXG5leHBvcnQgeyBQbGFuZVR5cGUgfVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG5pbXBvcnQgU3RyaW5nRnVuY3Rpb25zIGZyb20gJy4uL1V0aWxpdGllcy9TdHJpbmdGdW5jdGlvbnMnXHJcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuL1ZlYzMuanMnXHJcbmltcG9ydCB7IFBsYW5lVHlwZSB9IGZyb20gJy4vUGxhbmVUeXBlLmpzJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRnJ1c3R1bS4gRnJ1c3R1bXMgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXRcclxuICogaXMgaW5zaWRlIHRoZSBjYW1lcmEncyBmaWVsZCBvZiB2aWV3LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiAqL1xyXG5jbGFzcyBGcnVzdHVtIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBGcnVzdHVtXHJcbiAgICogQHBhcmFtIHtQbGFuZVR5cGV9IHAwIC0gdGhlIHAwIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7UGxhbmVUeXBlfSBwMSAtIHRoZSBwMSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge1BsYW5lVHlwZX0gcDIgLSB0aGUgcDIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtQbGFuZVR5cGV9IHAzIC0gdGhlIHAzIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7UGxhbmVUeXBlfSBwNCAtIHRoZSBwNCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge1BsYW5lVHlwZX0gcDUgLSB0aGUgcDUgdmFsdWUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xyXG4gICAgdGhpcy5wbGFuZXMgPSBbXHJcbiAgICAgIHAwIHx8IG5ldyBQbGFuZVR5cGUoKSxcclxuICAgICAgcDEgfHwgbmV3IFBsYW5lVHlwZSgpLFxyXG4gICAgICBwMiB8fCBuZXcgUGxhbmVUeXBlKCksXHJcbiAgICAgIHAzIHx8IG5ldyBQbGFuZVR5cGUoKSxcclxuICAgICAgcDQgfHwgbmV3IFBsYW5lVHlwZSgpLFxyXG4gICAgICBwNSB8fCBuZXcgUGxhbmVUeXBlKCksXHJcbiAgICBdXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2V0RnJvbU1hdHJpeCBjb25maWd1cmVzIGEgRnJ1c3R1bSBvYmplY3QgdXNpbmcgYSBtYXRyaXguXHJcbiAgICogVHlwaWNhbGx5IHRoZSBtYXRyaXggaXMgYSBtb2RlbCB2aWV3IHByb2plY3Rpb24gbWF0cml4LlxyXG4gICAqIEBwYXJhbSB7TWF0NH0gbWF0NCAtIFRoZSBtYXRyaXggdG8gdXNlLlxyXG4gICAqL1xyXG4gIHNldEZyb21NYXRyaXgobWF0NCkge1xyXG4gICAgY29uc3QgbSA9IG1hdDRcclxuICAgIGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzXHJcbiAgICBwbGFuZXNbMF0uc2V0KG0ubTAzIC0gbS5tMDAsIG0ubTEzIC0gbS5tMTAsIG0ubTIzIC0gbS5tMjAsIG0ubTMzIC0gbS5tMzApXHJcbiAgICBwbGFuZXNbMV0uc2V0KG0ubTAzICsgbS5tMDAsIG0ubTEzICsgbS5tMTAsIG0ubTIzICsgbS5tMjAsIG0ubTMzICsgbS5tMzApXHJcbiAgICBwbGFuZXNbMl0uc2V0KG0ubTAzICsgbS5tMDEsIG0ubTEzICsgbS5tMTEsIG0ubTIzICsgbS5tMjEsIG0ubTMzICsgbS5tMzEpXHJcbiAgICBwbGFuZXNbM10uc2V0KG0ubTAzIC0gbS5tMDEsIG0ubTEzIC0gbS5tMTEsIG0ubTIzIC0gbS5tMjEsIG0ubTMzIC0gbS5tMzEpXHJcbiAgICBwbGFuZXNbNF0uc2V0KG0ubTAzIC0gbS5tMDIsIG0ubTEzIC0gbS5tMTIsIG0ubTIzIC0gbS5tMjIsIG0ubTMzIC0gbS5tMzIpXHJcbiAgICBwbGFuZXNbNV0uc2V0KG0ubTAzICsgbS5tMDIsIG0ubTEzICsgbS5tMTIsIG0ubTIzICsgbS5tMjIsIG0ubTMzICsgbS5tMzIpXHJcblxyXG4gICAgcGxhbmVzLmZvckVhY2goKHBsYW5lKSA9PiBwbGFuZS5ub3JtYWxpemVJblBsYWNlKCkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXN0cyBhIGJveCB0byBzZWUgaWYgaXQgaXMgZW50aXJlbHkgd2l0aGluIHRoZSBmcnVzdHVtLlxyXG4gICAqIEBwYXJhbSB7Qm94M30gYm94MyAtIFRoZSBib3ggdG8gdGVzdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGZydXN0dW0gaW50ZXJzZWN0cyB0aGUgYm94LlxyXG4gICAqL1xyXG4gIGludGVyc2VjdHNCb3goYm94Mykge1xyXG4gICAgY29uc3QgcCA9IG5ldyBWZWMzKClcclxuICAgIGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzXHJcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBib3gzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgY29uc3QgcGxhbmUgPSBwbGFuZXNbaV1cclxuXHJcbiAgICAgIC8vIGNvcm5lciBhdCBtYXggZGlzdGFuY2VcclxuICAgICAgcC54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gbWF4LnggOiBtaW4ueFxyXG4gICAgICBwLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBtYXgueSA6IG1pbi55XHJcbiAgICAgIHAueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IG1heC56IDogbWluLnpcclxuXHJcbiAgICAgIGlmIChwbGFuZS5kaXN0YW5jZVRvUG9pbnQocCkgPCAwKSByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUGVyc2lzdGVuY2VcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwMDogdGhpcy5wMC50b0pTT04oKSxcclxuICAgICAgcDE6IHRoaXMucDEudG9KU09OKCksXHJcbiAgICAgIHAyOiB0aGlzLnAyLnRvSlNPTigpLFxyXG4gICAgICBwMzogdGhpcy5wMy50b0pTT04oKSxcclxuICAgICAgcDQ6IHRoaXMucDQudG9KU09OKCksXHJcbiAgICAgIHA1OiB0aGlzLnA1LnRvSlNPTigpLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZyb21KU09OKGopIHtcclxuICAgIHRoaXMucDAuZnJvbUpTT04oai5wMClcclxuICAgIHRoaXMucDEuZnJvbUpTT04oai5wMSlcclxuICAgIHRoaXMucDIuZnJvbUpTT04oai5wMilcclxuICAgIHRoaXMucDMuZnJvbUpTT04oai5wMylcclxuICAgIHRoaXMucDQuZnJvbUpTT04oai5wNClcclxuICAgIHRoaXMucDUuZnJvbUpTT04oai5wNSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKVxyXG4gIH1cclxufVxyXG5cclxuUmVnaXN0cnkucmVnaXN0ZXIoJ0ZydXN0dW0nLCBGcnVzdHVtKVxyXG5cclxuZXhwb3J0IHsgRnJ1c3R1bSB9XHJcbiIsIi8qKlxyXG4gKiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVtaXR0aW5nIGV2ZW50cyB1bmRlciBnaXZlbiBuYW1lcywgYW5kIHJlZ2lzdGVyaW5nIGxpc3RlbmVycyB0byB0aG9zZSBldmVudHMuXHJcbiAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBtb3N0IGNsYXNzZXMgaW4gdGhlIFNjZW5lIFRyZWUgYW5kIFJlbmRlcmVyLCBlbmFibGluZyBvYnNlcnZlcnMgdG8gbGlzdGVuIHRvIGNoYW5nZXMgdGhyb3VnaG91dCB0aGUgc3lzdGVtLlxyXG4gKiBUaGUgaW50ZXJmYWNlIGV4cG9zZWQgaXMgc2ltaWxhciB0byBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpIGluIE5vZGUuXHJcbiAqXHJcbiAqIFNpbWlsYXIgdG8gaG93IHRoZSBET00gZXZlbnQgc3lzdGVtIGluIHRoZSBicm93c2VyIHdvcmtzLCBldmVudHMgYXJlIHJlZ2lzdGVyZWQgYnkgbmFtZS5cclxuICogRXhhbXBsZTogUmVnaXN0ZXJpbmcgYSBsaXN0ZW5lciBmb3IgYSBjdXN0b20gZXZlbnQsIGFuZCB0aGVuIGVtaXR0aW5nIHRoYXQgZXZlbnQuXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogIGNvbnN0IGVlID0gbmV3IEV2ZW50RW1pdHRlcigpXHJcbiAqXHJcbiAqICBlZS5vbignbXlFdmVudCcsIChldmVudCkgPT4ge1xyXG4gKiAgICBjb25zb2xlLmxvZygnTXkgRXZlbnQgd2FzIGVtaXR0ZWQ6JywgZXZlbnQpXHJcbiAqICB9KVxyXG4gKlxyXG4gKiAgZWUuZW1pdCgnbXlFdmVudCcsIHsgZGF0YTogNDIgfSlcclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGFuIGVtcHR5IGBsaXN0ZW5lcnNgIG1hcCB0aGF0IHdpbGwgaG9zdCBhbGwgdGhlIGV2ZW50cyxcclxuICAgKiB3aGljaCBpbXBsaWVzIHRoYXQgaXQgZG9lc24ndCBhbGxvdyBtdWx0aXBsZSBldmVudHMgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG4gICAqIDxicj5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMubGlzdGVuZXJzID0ge31cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgYSBnaXZlbiBldmVudCBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbihjYWxsYmFjaykuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIElkIHRvIHJlZmVyZW5jZSB0aGUgbGlzdGVuZXIuXHJcbiAgICovXHJcbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKCFsaXN0ZW5lcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2sgZnVuY3Rpb24gKGxpc3RlbmVyKS4nKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW11cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdXHJcblxyXG4gICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSAhPSAtMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExpc3RlbmVyIFwiJHtsaXN0ZW5lci5uYW1lfVwiIGFscmVhZHkgY29ubmVjdGVkIHRvIGV2ZW50IFwiJHtldmVudE5hbWV9XCIuYClcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgYWxvbmdzaWRlICNhZGRMaXN0ZW5lci5cclxuICAgIGNvbnN0IGlkID0gbGlzdGVuZXJzLmxlbmd0aFxyXG4gICAgbGlzdGVuZXJzW2lkXSA9IGxpc3RlbmVyXHJcblxyXG4gICAgcmV0dXJuIGlkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaW1pbGFyIHRvIHRoZSBgb25gIG1ldGhvZCB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLFxyXG4gICAqIGl0IGlzIGF1dG9tYXRpY2FsbHkgdW5yZWdpc3RlcmVkIG1lYW5pbmcgdGhhdCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmUgdGltZS5cclxuICAgKlxyXG4gICAqIFVzZWZ1bCBmb3IgZXZlbnRzIHRoYXQgd2UgZXhwZWN0IHRvIHRyaWdnZXIgb25lIHRpbWUsIHN1Y2ggYXMgd2hlbiBhc3NldHMgbG9hZC5cclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogY29uc3QgYXNzZXQgPSBuZXcgQXNzZXQoKTtcclxuICAgKiBhc3NldC5vbmNlKCdsb2FkZWQnLCAoKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyhcIllheSEgdGhlIGFzc2V0IGlzIGxvYWRlZFwiKVxyXG4gICAqIH0pXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKi9cclxuICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgIGNvbnN0IGNiID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGxpc3RlbmVyKGV2ZW50KVxyXG4gICAgICB0aGlzLm9mZihldmVudE5hbWUsIGNiKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub24oZXZlbnROYW1lLCBjYilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHVzaW5nIGVpdGhlciB0aGUgZnVuY3Rpb24gb3IgdGhlIGluZGV4IGlkLiBEZXBlbmRzIG9uIHdoYXQgaXMgcGFzc2VkIGluLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bWJlcn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgdGhlIGlkIG51bWJlci5cclxuICAgKi9cclxuICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKCFsaXN0ZW5lcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2sgZnVuY3Rpb24gKGxpc3RlbmVyKS4nKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT0gJ251bWJlcicpIHtcclxuICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVbi1yZWdpc3RlciB1c2luZyB0aGUgb3JpZ2luYWwgbGlzdGVuZXIgaW5zdGVhZC4nKVxyXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyQnlJZChldmVudE5hbWUsIGxpc3RlbmVyKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdXHJcblxyXG4gICAgY29uc3QgaWRzID0gW11cclxuXHJcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZSwgaSkgPT4ge1xyXG4gICAgICBpZiAoZSA9PT0gbGlzdGVuZXIpIHtcclxuICAgICAgICBpZHMucHVzaChpKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChpZHMubGVuZ3RoID09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaXN0ZW5lciBcIiR7bGlzdGVuZXIubmFtZX1cIiBpcyBub3QgY29ubmVjdGVkIHRvIFwiJHtldmVudE5hbWV9XCIgZXZlbnRgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcclxuICAgICAgICBsaXN0ZW5lcnNbaWRdID0gdW5kZWZpbmVkXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSAjb24gaW5zdGVhZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24oY2FsbGJhY2spLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBJZCB0byByZWZlcmVuY2UgdGhlIGxpc3RlbmVyLlxyXG4gICAqL1xyXG4gIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNvbiBpbnN0ZWFkLicpXHJcblxyXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSAjb2ZmIGluc3RlYWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRlZC4gVXNlICNvZmYgaW5zdGVhZC4nKVxyXG5cclxuICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgI29mZiwgcGFzc2luZyB0aGUgbGlzdGVuZXIgaXRzZWxmIGluc3RlYWQgb2YgdGhlIGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgaWQgcmV0dXJuZWQgYnkgYWRkTGlzdGVuZXJcclxuICAgKi9cclxuICByZW1vdmVMaXN0ZW5lckJ5SWQoZXZlbnROYW1lLCBpZCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI29mZiwgcGFzc2luZyB0aGUgbGlzdGVuZXIgaXRzZWxmIGluc3RlYWQgb2YgdGhlIGlkLicpXHJcblxyXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxyXG5cclxuICAgIGlmICghbGlzdGVuZXJzKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignY2FsbGJhY2sgOicgKyBpZCArICcgd2FzIG5vdCBjb25uZWN0ZWQgdG8gdGhpcyBzaWduYWw6JyArIGV2ZW50TmFtZSlcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFsaXN0ZW5lcnNbaWRdKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSUQnKVxyXG5cclxuICAgIGxpc3RlbmVyc1tpZF0gPSB1bmRlZmluZWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgaW4gYW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ3xhbnl9IGV2ZW50IC0gVGhlIGRhdGEgeW91IHdhbnQgdG8gcGFzcyBkb3duIHRvIGFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgYXMgcGFyYW1ldGVyLlxyXG4gICAqL1xyXG4gIGVtaXQoZXZlbnROYW1lLCBldmVudCkge1xyXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXVxyXG5cclxuICAgIGxpc3RlbmVycy5mb3JFYWNoKChmbikgPT4ge1xyXG4gICAgICAvLyBTa2lwIGRpc2Nvbm5lY3RlZCBsaXN0ZW5lcnMuXHJcbiAgICAgIGlmIChmbikge1xyXG4gICAgICAgIGZuKGV2ZW50KVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL1V0aWxpdGllcy9FdmVudEVtaXR0ZXInXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi9SZWdpc3RyeSdcclxuXHJcbi8vIEV4cGxpY2l0IGltcG9ydCBvZiBmaWxlcyB0byBhdm9pZCBpbXBvcnRpbmcgYWxsIHRoZSBwYXJhbWV0ZXIgdHlwZXMuXHJcbi8vIE5vdGU6IFNvb24gdGhlc2UgaW1wb3J0cyBzaG91bGQgYmUgcmVtb3ZlZCwgb25jZSBhbGwgY29kZSBhdm9pZHMgY2FsbGluZ1xyXG4vLyAnYWRkUGFyYW1ldGVyJyB3aXRob3V0IHRoZSBwYXJhbWV0ZXIgaW5zdGFuY2UuXHJcblxyXG5sZXQgY291bnRlciA9IDBcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGFsbG93cyBvdGhlciBjbGFzc2VzIHRvIGJlIHBhcmFtZXRlcml6ZWQgYnkgYFBhcmFtZXRlcmAgdHlwZSBvZiBvYmplY3RzLlxyXG4gKiBOb3Qgb25seSBob3N0aW5nIHBhcmFtZXRlcnMsIGJ1dCB0aGVpciBldmVudHMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9XHJcbiAqL1xyXG5jbGFzcyBQYXJhbWV0ZXJPd25lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBQYXJhbWV0ZXJPd25lciBieSBpbml0aWFsaXppbmcgcGFyYW1ldGVyIGhvc3RpbmcgbWFwcGluZ3MgYW5kIGV2ZW50cy5cclxuICAgKiA8YnI+XHJcbiAgICogRXZlcnkgT2JqZWN0IGhhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIHdoaWNoIGlzIGJhc2VkIG9uIGEgY291bnRlciB0aGF0IGlzIGluY3JlbWVudGVkLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5fX2lkID0gKytjb3VudGVyXHJcblxyXG4gICAgdGhpcy5fX3BhcmFtcyA9IFtdXHJcbiAgICB0aGlzLl9fcGFyYW1NYXBwaW5nID0ge31cclxuICAgIHRoaXMuX19wYXJhbUV2ZW50SGFuZGxlcnMgPSB7fVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkIG9mIHRoZSBvYmplY3QuXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIElkIG9mIHRoZSBQYXJhbWV0ZXJPd25lciBvYmplY3QuXHJcbiAgICovXHJcbiAgZ2V0SWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2lkXHJcbiAgfVxyXG5cclxuICAvLyAtLS0gUGFyYW1zIC0tLVxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGN1cnJlbnQgb2JqZWN0IGhhcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBBbW91bnQgb2YgcGFyYW1ldGVycyBpbiBjdXJyZW50IG9iamVjdC5cclxuICAgKi9cclxuICBudW1QYXJhbWV0ZXJzKCkge1xyXG4gICAgY29uc29sZS53YXJuKCdEZXByZWNhdGVkLiBVc2UgI2dldE51bVBhcmFtZXRlcnMgaW5zdGVhZC4nKVxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0TnVtUGFyYW1ldGVycygpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBjdXJyZW50IG9iamVjdCBoYXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQW1vdW50IG9mIHBhcmFtZXRlcnMgaW4gY3VycmVudCBvYmplY3QuXHJcbiAgICovXHJcbiAgZ2V0TnVtUGFyYW1ldGVycygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGFyYW1zLmxlbmd0aFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFBhcmFtZXRlciBMaXN0XHJcbiAgICovXHJcbiAgZ2V0UGFyYW1ldGVycygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGFyYW1zXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIHBhcmFtZXRlciBpbiBwYXJhbWV0ZXIgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFBvc2l0aW9uIGluIHRoZSBhcnJheVxyXG4gICAqL1xyXG4gIGdldFBhcmFtZXRlckluZGV4KHBhcmFtTmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wYXJhbU1hcHBpbmdbcGFyYW1OYW1lXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBgUGFyYW1ldGVyYCBvYmplY3QgaW4gYSBnaXZlbiBpbmRleFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gUG9zaXRpb24gb2YgdGhlIHBhcmFtZXRlciBpbiB0aGUgYXJyYXlcclxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gUGFyYW1ldGVyIG9iamVjdCB2YWx1ZVxyXG4gICAqL1xyXG4gIGdldFBhcmFtZXRlckJ5SW5kZXgoaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGFyYW1zW2luZGV4XVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIGV4aXN0cyBpbiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgaGFzUGFyYW1ldGVyKHBhcmFtTmFtZSkge1xyXG4gICAgcmV0dXJuIHBhcmFtTmFtZSBpbiB0aGlzLl9fcGFyYW1NYXBwaW5nXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGBQYXJhbWV0ZXJgIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS5cclxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gUGFyYW1ldGVyIG9iamVjdCB2YWx1ZVxyXG4gICAqL1xyXG4gIGdldFBhcmFtZXRlcihwYXJhbU5hbWUpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX3BhcmFtTWFwcGluZ1twYXJhbU5hbWVdXHJcbiAgICBpZiAoaW5kZXggPT0gLTEpIHJldHVybiBudWxsXHJcbiAgICByZXR1cm4gdGhpcy5fX3BhcmFtc1tpbmRleF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3Nlc1xyXG4gICAqIHRvIHBlcmZvcm0gZ2VuZXJhbCB1cGRhdGVzIChzZWUgR0xQYXNzIG9yIEJhc2VJdGVtKS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgdGhlIHBhcmFtZXRlci5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fcGFyYW1ldGVyVmFsdWVDaGFuZ2VkKGV2ZW50KSB7XHJcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlclZhbHVlQ2hhbmdlZCcsIGV2ZW50KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBgUGFyYW1ldGVyYCBvYmplY3QgdG8gdGhlIG93bmVyJ3MgcGFyYW1ldGVyIGxpc3QuXHJcbiAgICpcclxuICAgKiBAZW1pdHMgYHBhcmFtZXRlckFkZGVkYCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJhbS5cclxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcn0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIGFkZC5cclxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJ9IC0gV2l0aCBgb3duZXJgIGFuZCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuXHJcbiAgICovXHJcbiAgYWRkUGFyYW1ldGVyKHBhcmFtKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRQYXJhbWV0ZXIocGFyYW0sIHRoaXMuX19wYXJhbXMubGVuZ3RoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBgUGFyYW1ldGVyYCBvYmplY3QgdG8gdGhlIG93bmVyJ3MgcGFyYW1ldGVyIGxpc3QgdXNpbmcgdGhlIGluZGV4LlxyXG4gICAqIEl0IHJlcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAqXHJcbiAgICpcclxuICAgKiBAZW1pdHMgYHBhcmFtZXRlckFkZGVkYCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJhbS5cclxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcn0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIGluc2VydC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuXHJcbiAgICogQHJldHVybiB7UGFyYW1ldGVyfSAtIFdpdGggYG93bmVyYCBhbmQgYHZhbHVlQ2hhbmdlZGAgZXZlbnQgc2V0LlxyXG4gICAqL1xyXG4gIGluc2VydFBhcmFtZXRlcihwYXJhbSwgaW5kZXgpIHtcclxuICAgIGNvbnN0IG5hbWUgPSBwYXJhbS5nZXROYW1lKClcclxuICAgIGlmICh0aGlzLl9fcGFyYW1NYXBwaW5nW25hbWVdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1JlcGxhY2luZyBQYXJhbWV0ZXI6JyArIG5hbWUpXHJcbiAgICAgIHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpXHJcbiAgICB9XHJcbiAgICBwYXJhbS5zZXRPd25lcih0aGlzKVxyXG4gICAgY29uc3QgcGFyYW1DaGFuZ2VkSGFuZGxlciA9IChldmVudCkgPT4gdGhpcy5fX3BhcmFtZXRlclZhbHVlQ2hhbmdlZCh7IC4uLmV2ZW50LCBwYXJhbSB9KVxyXG4gICAgcGFyYW0ub24oJ3ZhbHVlQ2hhbmdlZCcsIHBhcmFtQ2hhbmdlZEhhbmRsZXIpXHJcbiAgICB0aGlzLl9fcGFyYW1FdmVudEhhbmRsZXJzW25hbWVdID0gcGFyYW1DaGFuZ2VkSGFuZGxlclxyXG4gICAgdGhpcy5fX3BhcmFtcy5zcGxpY2UoaW5kZXgsIDAsIHBhcmFtKVxyXG5cclxuICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuX19wYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5fX3BhcmFtTWFwcGluZ1t0aGlzLl9fcGFyYW1zW2ldLmdldE5hbWUoKV0gPSBpXHJcbiAgICB9XHJcbiAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlckFkZGVkJywgeyBuYW1lIH0pXHJcbiAgICByZXR1cm4gcGFyYW1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYFBhcmFtZXRlcmAgZnJvbSBvd25lciwgYnkgdXNpbmcgcGFyYW1ldGVyJ3MgbmFtZS5cclxuICAgKiBAZW1pdHMgYHBhcmFtZXRlclJlbW92ZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLlxyXG4gICAqL1xyXG4gIHJlbW92ZVBhcmFtZXRlcihuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVtb3ZlIFBhcmFtZXRlcjonICsgbmFtZSlcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXVxyXG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLl9fcGFyYW1zW3RoaXMuX19wYXJhbU1hcHBpbmdbbmFtZV1dXHJcblxyXG4gICAgcGFyYW0ub2ZmKCd2YWx1ZUNoYW5nZWQnLCB0aGlzLl9fcGFyYW1FdmVudEhhbmRsZXJzW25hbWVdKVxyXG4gICAgdGhpcy5fX3BhcmFtcy5zcGxpY2UoaW5kZXgsIDEpXHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX19wYXJhbU1hcHBpbmdbbmFtZV1cclxuICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuX19wYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5fX3BhcmFtTWFwcGluZ1t0aGlzLl9fcGFyYW1zW2ldLmdldE5hbWUoKV0gPSBpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJSZW1vdmVkJywgeyBuYW1lIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXBsYWNlcyBvbGQgYFBhcmFtZXRlcmAgYnkgcGFzc2luZyBhIG5ldyBvbmUgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJ9IHBhcmFtIC0gVGhlIHBhcmFtZXRlciB0byByZXBsYWNlLlxyXG4gICAqIEByZXR1cm4ge1BhcmFtZXRlcn0gLSBgUGFyYW1ldGVyYCB3aXRoIGB2YWx1ZUNoYW5nZWRgIGV2ZW50IHNldC5cclxuICAgKi9cclxuICByZXBsYWNlUGFyYW1ldGVyKHBhcmFtKSB7XHJcbiAgICBjb25zdCBuYW1lID0gcGFyYW0uZ2V0TmFtZSgpXHJcbiAgICBpZiAodGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVwbGFjZSBQYXJhbWV0ZXI6JyArIHBhcmFtTmFtZSlcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX3BhcmFtTWFwcGluZ1tuYW1lXVxyXG4gICAgdGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSlcclxuICAgIHRoaXMuaW5zZXJ0UGFyYW1ldGVyKHBhcmFtLCBpbmRleClcclxuICAgIHJldHVybiBwYXJhbVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGpzb24gPSB7fVxyXG4gICAgY29uc3QgcGFyYW1zSlNPTiA9IHt9XHJcbiAgICBsZXQgc2F2ZWRQYXJhbXMgPSAwXHJcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuX19wYXJhbXMpIHtcclxuICAgICAgY29uc3QgcGFyYW1KU09OID0gcGFyYW0udG9KU09OKGNvbnRleHQpXHJcbiAgICAgIGlmIChwYXJhbUpTT04pIHtcclxuICAgICAgICBwYXJhbXNKU09OW3BhcmFtLmdldE5hbWUoKV0gPSBwYXJhbUpTT05cclxuICAgICAgICBzYXZlZFBhcmFtcysrXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzYXZlZFBhcmFtcyA+IDApIGpzb24ucGFyYW1zID0gcGFyYW1zSlNPTlxyXG4gICAgcmV0dXJuIGpzb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS5cclxuICAgKi9cclxuICBmcm9tSlNPTihqLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoai5wYXJhbXMpIHtcclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gai5wYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBwaiA9IGoucGFyYW1zW2tleV1cclxuICAgICAgICBjb25zdCBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKGtleSlcclxuICAgICAgICBpZiAoIXBhcmFtKSBjb25zb2xlLndhcm4oJ1BhcmFtIG5vdCBmb3VuZDonICsga2V5KVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHBqLnBhcmFtUGF0aCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc29sdmVQYXRoKFxyXG4gICAgICAgICAgICAgIHBqLnBhcmFtUGF0aCxcclxuICAgICAgICAgICAgICAocGFyYW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVBhcmFtZXRlcihwYXJhbSlcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHJlc29sdmUgc2hhcmVkIHBhcmFtZXRlcjonICsgcGoucGFyYW1QYXRoKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW0uZnJvbUpTT04ocGosIGNvbnRleHQpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VzIHBhc3NlZCBpbiBCaW5SZWFkZXIgb2JqZWN0KGNvbnRhaW5pbmcgYW4gSW50MzIgYXJyYXkgd2l0aCBhbGwgdGhlIHBhcmFtZXRlcnMpIHRvIHJlY29uc3RydWN0IGFsbCBwYXJhbWV0ZXJzIHN0YXRlLlxyXG4gICAqIDxicj5cclxuICAgKiBJbiBlYWNoIGl0ZXJhdGlvbiBvZiB0aGUgYXJyYXksIHByb3BUeXBlIGFuZCBwcm9wTmFtZSBhcmUgZXh0cmFjdGVkIGFuZFxyXG4gICAqIHVzZWQgdG8gYnVpbGQgdGhlIHJpZ2h0IGBQYXJhbWV0ZXJgIGNsYXNzLiBUaGVuIGFsbCBvZiB0aGVtIGFyZSBhZGRlZCB0byB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGVtaXRzIGBwYXJhbWV0ZXJBZGRlZGAgd2l0aCB0aGUgbmFtZSBvZiB0aGUgcGFyYW0uXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS5cclxuICAgKi9cclxuICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkge1xyXG4gICAgLy8gVE9ETzogbWFrZSB0aGlzIHdvcmtcclxuXHJcbiAgICBpZiAoY29udGV4dC52ZXJzaW9uc1snemVhLWVuZ2luZSddLmNvbXBhcmUoWzAsIDAsIDNdKSA+PSAwKSB7XHJcbiAgICAgIGNvbnN0IG51bVByb3BzID0gcmVhZGVyLmxvYWRVSW50MzIoKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVByb3BzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHJlYWRlci5sb2FkU3RyKClcclxuICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHJlYWRlci5sb2FkU3RyKClcclxuICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLmdldFBhcmFtZXRlcihwcm9wTmFtZSlcclxuICAgICAgICBpZiAoIXBhcmFtKSB7XHJcbiAgICAgICAgICBwYXJhbSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKHByb3BUeXBlLCBwcm9wTmFtZSlcclxuICAgICAgICAgIGlmICghcGFyYW0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbnN0cnVjdCBwcm9wOicgKyBwcm9wTmFtZSArICcgb2YgdHlwZTonICsgcHJvcFR5cGUpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmFkZFBhcmFtZXRlcihwYXJhbSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW0ucmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIG9iamVjdCdzIEpTT04gdmFsdWUgYW5kIGNvbnZlcnRzIGl0IHRvIGEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFN0cmluZyBvZiBvYmplY3QncyBwYXJhbWV0ZXIgbGlzdCBzdGF0ZS5cclxuICAgKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAyKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIENsb25lIGFuZCBEZXN0cm95XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcGllcyBQYXJhbWV0ZXJzIGZyb20gYW5vdGhlciBgUGFyYW1ldGVyT3duZXJgIHRvIGN1cnJlbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJPd25lcn0gc3JjIC0gVGhlIFBhcmFtZXRlck93bmVyIGNvcHkgZnJvbS5cclxuICAgKi9cclxuICBjb3B5RnJvbShzcmMpIHtcclxuICAgIC8vIE5vdGU6IExvb3Agb3ZlciB0aGUgcGFyYW1ldGVycyBpbiByZXZlcnNlIG9yZGVyLFxyXG4gICAgLy8gdGhpcyBpcyBiZWNhdXNlIG9mdGVuLCBwYXJhbWV0ZXIgZGVwZW5kZW5jaWVzXHJcbiAgICAvLyBhcmUgYm90dG9tIHRvIHRvcCAoYm90dG9tIHBhcmFtcyBkZXBlbmRlbnQgb24gaGlnaGVyIHBhcmFtcykuXHJcbiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgYXMgYSBwYXJhbWV0ZXIgaXMgc2V0IHdpdGggYSBuZXcgdmFsdWVcclxuICAgIC8vIGl0IHdpbGwgZGlydHkgdGhlIHBhcmFtcyBiZWxvdyBpdC5cclxuICAgIGxldCBpID0gc3JjLmdldE51bVBhcmFtZXRlcnMoKVxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBjb25zdCBzcmNQYXJhbSA9IHNyYy5nZXRQYXJhbWV0ZXJCeUluZGV4KGkpXHJcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoc3JjUGFyYW0uZ2V0TmFtZSgpKVxyXG4gICAgICBpZiAocGFyYW0pIHtcclxuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGNsb25pbmcgdGhlIHZhbHVlcy5cclxuICAgICAgICBwYXJhbS5sb2FkVmFsdWUoc3JjUGFyYW0uZ2V0VmFsdWUoKSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFkZFBhcmFtZXRlcihzcmNQYXJhbS5jbG9uZSgpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBQYXJhbWV0ZXJPd25lciB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi9cclxuaW1wb3J0IHsgRmxvYXQzMiwgVUludDMyLCBTSW50MzIgfSBmcm9tICcuLi8uLi9VdGlsaXRpZXMvTWF0aEZ1bmN0aW9ucydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uLy4uL1JlZ2lzdHJ5J1xyXG5cclxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iaikge1xyXG4gIHJldHVybiAhIW9iaiAmJiBvYmouYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gYXR0cmlidXRlLlxyXG4gKi9cclxuY2xhc3MgQXR0cmlidXRlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7QXR0clZhbHVlfG51bWJlcn0gZGF0YVR5cGUgLSBUaGUgZGF0YVR5cGUgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8VHlwZWRBcnJheX0gZXhwZWN0ZWRTaXplIC0gVGhlIGV4cGVjdGVkU2l6ZSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHRWYWx1ZSB2YWx1ZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkYXRhVHlwZSwgZXhwZWN0ZWRTaXplLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMuX19kYXRhVHlwZSA9IGRhdGFUeXBlXHJcbiAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZVxyXG4gICAgaWYgKGRhdGFUeXBlLm51bUVsZW1lbnRzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9fZGltZW5zaW9uID0gdGhpcy5fX2RhdGFUeXBlLm51bUVsZW1lbnRzKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcclxuICAgICAgICBjYXNlIEZsb2F0MzI6XHJcbiAgICAgICAgY2FzZSBVSW50MzI6XHJcbiAgICAgICAgY2FzZSBTSW50MzI6XHJcbiAgICAgICAgICB0aGlzLl9fZGltZW5zaW9uID0gMVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZSBmb3IgYXR0cmlidXRlOicgKyBkYXRhVHlwZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fX2RlZmF1bHRFbGVtZW50VmFsdWUgPSBkZWZhdWx0VmFsdWUgIT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogTnVtYmVyLk1BWF9WQUxVRVxyXG4gICAgaWYgKGlzVHlwZWRBcnJheShleHBlY3RlZFNpemUpKSB7XHJcbiAgICAgIHRoaXMuX19kYXRhID0gZXhwZWN0ZWRTaXplXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZXhwZWN0ZWRTaXplICogdGhpcy5fX2RpbWVuc2lvbilcclxuICAgICAgdGhpcy5pbml0UmFuZ2UoMClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2l6ZXMgY3VycmVudCBkYXRhIGFycmF5IHRvIHRvIGEgbmV3IHNpemUuXHJcbiAgICogSW4gY2FzZSB0aGUgbmV3IHNpemUgaXMgYmlnZ2VyIHRoYW4gY3VycmVudCBzaXplLCB0aGUgbmV3IHZhbHVlcyBhcmUgZmlsbGVkIHVwIHdpdGggZGVmYXVsdCBvbmVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZSB2YWx1ZS5cclxuICAgKi9cclxuICByZXNpemUoc2l6ZSkge1xyXG4gICAgY29uc3QgcHJldkxlbmd0aCA9IHRoaXMuX19kYXRhLmxlbmd0aFxyXG4gICAgY29uc3QgbmV3TGVuZ3RoID0gc2l6ZSAqIHRoaXMuX19kaW1lbnNpb25cclxuXHJcbiAgICBpZiAobmV3TGVuZ3RoID4gcHJldkxlbmd0aCkge1xyXG4gICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShuZXdMZW5ndGgpXHJcbiAgICAgIGRhdGEuc2V0KHRoaXMuX19kYXRhKVxyXG4gICAgICB0aGlzLl9fZGF0YSA9IGRhdGFcclxuICAgICAgdGhpcy5pbml0UmFuZ2UocHJldkxlbmd0aClcclxuICAgIH0gZWxzZSBpZiAobmV3TGVuZ3RoIDwgcHJldkxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLnNsaWNlKDAsIG5ld0xlbmd0aClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE5vIGNoYW5nZSBpbiBzaXplLiAodGhpcyBjYW4gaGFwcGVuIHdoZW4gYW4gYXR0cmlidXRlIHdhcyBhbHJlYWR5IGxvYWRlZCB3aXRoIGRhdGEuKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlsbHMgdXAgZGF0YSB2YWx1ZXMgd2l0aCBkZWZhdWx0IG9uZXMgc3RhcnRpbmcgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IHZhbHVlLlxyXG4gICAqL1xyXG4gIGluaXRSYW5nZShzdGFydCkge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFsdWVzIHRvIGludmFsaWQgdmFsdWVzLlxyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgdGhpcy5fX2RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5fX2RhdGFbaV0gPSB0aGlzLl9fZGVmYXVsdEVsZW1lbnRWYWx1ZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgYXR0cmlidXRlIHZhbHVlcyBpbiB0aGUgZGF0YS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldENvdW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhLmxlbmd0aCAvIHRoaXMuX19kaW1lbnNpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gdGhlIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhLmxlbmd0aCAvIHRoaXMuX19kaW1lbnNpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgYXR0cmlidXRlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXR0clZhbHVlfG51bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBkYXRhVHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVR5cGVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBkYXRhIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VHlwZWRBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGRhdGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB2YWx1ZS5cclxuICAgKi9cclxuICBzZXQgZGF0YShkYXRhKSB7XHJcbiAgICB0aGlzLl9fZGF0YSA9IGRhdGFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgaW4gZWFjaCBgQXR0clZhbHVlYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBudW1FbGVtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGltZW5zaW9uXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBpbmRleC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRGbG9hdDMyVmFsdWUoaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZGF0YVtpbmRleF1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgZGF0YSB2YWx1ZSBpbiB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSBwYXJhbS5cclxuICAgKi9cclxuICBzZXRGbG9hdDMyVmFsdWUoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICB0aGlzLl9fZGF0YVtpbmRleF0gPSB2YWx1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYEF0dHJWYWx1ZWAgb2JqZWN0IHBsYWNlZCBpbiB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge0F0dHJWYWx1ZX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlUmVmKGluZGV4KSB7XHJcbiAgICBjb25zdCBudW1FbGVtcyA9IHRoaXMuX19kaW1lbnNpb25cclxuICAgIGlmIChpbmRleCA+PSB0aGlzLl9fZGF0YS5sZW5ndGggLyBudW1FbGVtcylcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuX19kYXRhLmxlbmd0aCAvIDMpXHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFUeXBlLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCBpbmRleCAqIG51bUVsZW1zICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYEF0dHJWYWx1ZWAgb2JqZWN0IGluIHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuXHJcbiAgICogQHBhcmFtIHtBdHRyVmFsdWV9IHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLlxyXG4gICAqL1xyXG4gIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgY29uc3QgbnVtRWxlbXMgPSB0aGlzLl9fZGltZW5zaW9uXHJcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5fX2RhdGEubGVuZ3RoIC8gbnVtRWxlbXMpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLl9fZGF0YS5sZW5ndGggLyAzKVxyXG4gICAgdGhpcy5fX2RhdGFUeXBlLmNyZWF0ZUZyb21CdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLCBpbmRleCAqIG51bUVsZW1zICogNCkuc2V0RnJvbU90aGVyKHZhbHVlKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogQXJyYXkuZnJvbSh0aGlzLl9fZGF0YSksXHJcbiAgICAgIGRhdGFUeXBlOiBSZWdpc3RyeS5nZXRCbHVlcHJpbnROYW1lKHRoaXMuX19kYXRhVHlwZSksXHJcbiAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5fX2RlZmF1bHRFbGVtZW50VmFsdWUsXHJcbiAgICAgIGxlbmd0aDogdGhpcy5fX2RhdGEubGVuZ3RoIC8gdGhpcy5fX2RpbWVuc2lvbixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaikge1xyXG4gICAgdGhpcy5fX2RhdGEgPSBGbG9hdDMyQXJyYXkuZnJvbShqLmRhdGEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCdzIHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgMilcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7IEF0dHJpYnV0ZSB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi9cclxuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG5pbXBvcnQgeyBWZWMyLCBWZWMzLCBCb3gyLCBCb3gzIH0gZnJvbSAnLi4vLi4vTWF0aC9pbmRleCdcclxuaW1wb3J0IHsgUGFyYW1ldGVyT3duZXIgfSBmcm9tICcuLi9QYXJhbWV0ZXJPd25lci5qcydcclxuaW1wb3J0IHsgQXR0cmlidXRlIH0gZnJvbSAnLi9BdHRyaWJ1dGUuanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi8uLi9SZWdpc3RyeSdcclxuXHJcbi8vIERlZmluZXMgdXNlZCB0byBleHBsaWNpdHkgc3BlY2lmeSB0eXBlcyBmb3IgV2ViR0wuXHJcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShvYmopIHtcclxuICByZXR1cm4gISFvYmogJiYgb2JqLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZFxyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJhc2UgY2xhc3MgZm9yIDNEIGdlb21ldHJ5IGl0ZW1zLlxyXG4gKlxyXG4gKiAqKkV2ZW50cyoqXHJcbiAqICogKipib3VuZGluZ0JveENoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBQYXJhbWV0ZXJPd25lclxyXG4gKi9cclxuY2xhc3MgQmFzZUdlb20gZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgYmFzZSBnZW9tLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5fX251bVZlcnRpY2VzID0gMFxyXG4gICAgdGhpcy5fX2JvdW5kaW5nQm94ID0gbmV3IEJveDMoKVxyXG4gICAgdGhpcy5fX2JvdW5kaW5nQm94RGlydHkgPSB0cnVlXHJcbiAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcyA9IG5ldyBNYXAoKVxyXG4gICAgdGhpcy5fX21ldGFEYXRhID0gbmV3IE1hcCgpXHJcbiAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJywgVmVjMywgMC4wKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXN0YWJsaXNoZXMgYSBuYW1lIGZvciB0aGUgZ2VvbWV0cnkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBkZWJ1ZyBuYW1lIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldERlYnVnTmFtZShuYW1lKSB7XHJcbiAgICB0aGlzLl9fbmFtZSA9IG5hbWVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuZXcgdmVydGV4IGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7QXR0clZhbHVlfG51bWJlcn0gZGF0YVR5cGUgLSBUaGUgZGF0YVR5cGUgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRTY2FsYXJWYWx1ZSAtIFRoZSBkZWZhdWx0IHNjYWxhciB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IC0gUmV0dXJucyBhbiBhdHRyaWJ1dGUuXHJcbiAgICovXHJcbiAgYWRkVmVydGV4QXR0cmlidXRlKG5hbWUsIGRhdGFUeXBlLCBkZWZhdWx0U2NhbGFyVmFsdWUgPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKVxyXG4gICAgbGV0IGF0dHJcclxuICAgIGlmIChpc1R5cGVkQXJyYXkoZGVmYXVsdFNjYWxhclZhbHVlKSkge1xyXG4gICAgICBhdHRyID0gbmV3IEF0dHJpYnV0ZShkYXRhVHlwZSwgZGVmYXVsdFNjYWxhclZhbHVlKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXR0ciA9IG5ldyBBdHRyaWJ1dGUoZGF0YVR5cGUsIHBvc2l0aW9ucyAhPSB1bmRlZmluZWQgPyBwb3NpdGlvbnMubGVuZ3RoIDogMCwgZGVmYXVsdFNjYWxhclZhbHVlKVxyXG4gICAgfVxyXG4gICAgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpXHJcbiAgICByZXR1cm4gYXR0clxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSB0aGUgZ2VvbWV0cnkgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGhhc1ZlcnRleEF0dHJpYnV0ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuaGFzKG5hbWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHZlcnRleCBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxyXG4gICAqIEByZXR1cm4ge0F0dHJpYnV0ZX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFZlcnRleEF0dHJpYnV0ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KG5hbWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCB2ZXJ0ZXggYXR0cmlidXRlcyBpbiBhbiBvYmplY3Qgd2l0aCB0aGVpciBuYW1lcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFZlcnRleEF0dHJpYnV0ZXMoKSB7XHJcbiAgICBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGVzID0ge31cclxuICAgIGZvciAoY29uc3QgW2tleSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKSB2ZXJ0ZXhBdHRyaWJ1dGVzW2tleV0gPSBhdHRyXHJcbiAgICByZXR1cm4gdmVydGV4QXR0cmlidXRlc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyAncG9zaXRpb25zJyB2ZXJ0ZXggYXR0cmlidXRlLlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXHJcbiAgZ2V0IHZlcnRpY2VzKCkge1xyXG4gICAgY29uc29sZS53YXJuKFwiZGVwcmVjYXRlZCB1c2UgI2dldFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJylcIilcclxuICAgIHJldHVybiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5nZXQoJ3Bvc2l0aW9ucycpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGV4IGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBudW1WZXJ0aWNlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fbnVtVmVydGljZXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2ZXJ0ZXggYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldE51bVZlcnRpY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19udW1WZXJ0aWNlc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoZSBnZW9tZXRyeSBoYXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgY291bnQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0TnVtVmVydGljZXMoY291bnQpIHtcclxuICAgIHRoaXMuX19udW1WZXJ0aWNlcyA9IGNvdW50XHJcbiAgICAvLyBSZXNpemVzIGVhY2ggb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGVzIHRvIG1hdGNoIHRoZSBuZXcgY291bnQuXHJcbiAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiBhdHRyLnJlc2l6ZSh0aGlzLl9fbnVtVmVydGljZXMpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiB2ZXJ0ZXhcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBWZWMzLlxyXG4gICAqL1xyXG4gIGdldFZlcnRleChpbmRleCkge1xyXG4gICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIHVzZSAjZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKS5nZXRWYWx1ZVJlZigpYClcclxuICAgIHJldHVybiBWZWMzLmNyZWF0ZUZyb21CdWZmZXIodGhpcy52ZXJ0aWNlcy5kYXRhLmJ1ZmZlciwgaW5kZXggKiAzICogNClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gdmVydGV4XHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcGFyYW0ge2luZGV4fSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge1ZlYzN9IHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIFZlYzMuXHJcbiAgICovXHJcbiAgc2V0VmVydGV4KGluZGV4LCB2YWx1ZSkge1xyXG4gICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIHVzZSAjZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKS5nZXRWYWx1ZVJlZigpLnNldEZyb21PdGhlcih2YWx1ZSlgKVxyXG4gICAgcmV0dXJuIFZlYzMuY3JlYXRlRnJvbUJ1ZmZlcih0aGlzLnZlcnRpY2VzLmRhdGEuYnVmZmVyLCBpbmRleCAqIDMgKiA0KS5zZXRGcm9tT3RoZXIodmFsdWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIGFuIG9mZnNldCB0byBlYWNoIG9mIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgZ2VvbWV0cnkuXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKiBAcGFyYW0ge1ZlYzN9IGRlbHRhIC0gVGhlIGRlbHRhIHZhbHVlLlxyXG4gICAqL1xyXG4gIG1vdmVWZXJ0aWNlcyhkZWx0YSkge1xyXG4gICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkIHVzZSAjZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKS5nZXRWYWx1ZVJlZigpYClcclxuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykgdmVydGljZXMuZ2V0VmFsdWVSZWYoaSkuYWRkSW5QbGFjZShkZWx0YSlcclxuICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdHJhbnNmb3JtVmVydGljZXMgbWV0aG9kLlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICogQHBhcmFtIHtYZm99IHhmbyAtIFRoZSB4Zm8gdHJhbmZvcm0uXHJcbiAgICovXHJcbiAgdHJhbnNmb3JtVmVydGljZXMoeGZvKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQsIHBsZWFzZSB0cmFuc2Zvcm0gdGhlIHZlcnRpY2VzIG1hbnVhbGx5YClcclxuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB2ID0gdmVydGljZXMuZ2V0VmFsdWVSZWYoaSlcclxuICAgICAgY29uc3QgdjIgPSB4Zm8udHJhbnNmb3JtVmVjMyh2KVxyXG4gICAgICB2LnNldCh2Mi54LCB2Mi55LCB2Mi56KVxyXG4gICAgfVxyXG4gICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KClcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBCb3VuZGluZ0JveFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIGdlb21ldHJ5LlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICogQHJldHVybiB7VmVjM30gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBib3VuZGluZ0JveCgpIHtcclxuICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAjZ2V0Qm91bmRpbmdCb3goKWApXHJcbiAgICBpZiAodGhpcy5fX2JvdW5kaW5nQm94RGlydHkpIHRoaXMudXBkYXRlQm91bmRpbmdCb3goKVxyXG4gICAgcmV0dXJuIHRoaXMuX19ib3VuZGluZ0JveFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBnZW9tZXRyeS5cclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0Qm91bmRpbmdCb3goKSB7XHJcbiAgICBpZiAodGhpcy5fX2JvdW5kaW5nQm94RGlydHkpIHRoaXMudXBkYXRlQm91bmRpbmdCb3goKVxyXG4gICAgcmV0dXJuIHRoaXMuX19ib3VuZGluZ0JveFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNldEJvdW5kaW5nQm94RGlydHkgbWV0aG9kLlxyXG4gICAqL1xyXG4gIHNldEJvdW5kaW5nQm94RGlydHkoKSB7XHJcbiAgICB0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eSA9IHRydWVcclxuICAgIHRoaXMuZW1pdCgnYm91bmRpbmdCb3hDaGFuZ2VkJywge30pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdXBkYXRlQm91bmRpbmdCb3ggbWV0aG9kLlxyXG4gICAqL1xyXG4gIHVwZGF0ZUJvdW5kaW5nQm94KCkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcbiAgICBjb25zdCBiYm94ID0gbmV3IEJveDMoKVxyXG4gICAgY29uc3QgbnVtVmVydHMgPSBwb3NpdGlvbnMubGVuZ3RoXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRzOyBpKyspIGJib3guYWRkUG9pbnQocG9zaXRpb25zLmdldFZhbHVlUmVmKGkpKVxyXG4gICAgdGhpcy5fX2JvdW5kaW5nQm94ID0gYmJveFxyXG4gICAgdGhpcy5fX2JvdW5kaW5nQm94RGlydHkgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIE1ldGFkYXRhXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbWV0YWRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdmFsdWUuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0TWV0YWRhdGEoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX21ldGFEYXRhLmdldChrZXkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWZXJpZmllcyBpZiBnZW9tZXRyeSdzIG1ldGFkYXRhIGNvbnRhaW5zIGEgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBoYXNNZXRhZGF0YShrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGEuaGFzKGtleSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbWV0YWRhdGEgdmFsdWUgdG8gdGhlIGdlb21ldHJ5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFEYXRhIC0gVGhlIG1ldGFEYXRhIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldE1ldGFkYXRhKGtleSwgbWV0YURhdGEpIHtcclxuICAgIHRoaXMuX19tZXRhRGF0YS5zZXQoa2V5LCBtZXRhRGF0YSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbWV0YWRhdGEgdmFsdWUgZnJvbSB0aGUgZ2VvbWV0cnkgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHZhbHVlLlxyXG4gICAqL1xyXG4gIGRlbGV0ZU1ldGFkYXRhKGtleSkge1xyXG4gICAgdGhpcy5fX21ldGFEYXRhLmRlbGV0ZShrZXkpXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gTWVtb3J5XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdmVydGV4IGF0dHJpYnV0ZXMgYnVmZmVycyBhbmQgaXRzIGNvdW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgb3B0cyB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZW5CdWZmZXJzKG9wdHMpIHtcclxuICAgIGNvbnN0IGF0dHJCdWZmZXJzID0ge31cclxuICAgIGZvciAoY29uc3QgW2F0dHJOYW1lLCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykge1xyXG4gICAgICBhdHRyQnVmZmVyc1thdHRyTmFtZV0gPSB7XHJcbiAgICAgICAgdmFsdWVzOiBhdHRyLmRhdGEsXHJcbiAgICAgICAgY291bnQ6IGF0dHIubGVuZ3RoLFxyXG4gICAgICAgIGRhdGFUeXBlOiBhdHRyLmRhdGFUeXBlLFxyXG4gICAgICAgIG5vcm1hbGl6ZWQ6IGF0dHIubm9ybWFsaXplZCxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbnVtVmVydGljZXM6IHRoaXMubnVtVmVydGljZXMoKSxcclxuICAgICAgYXR0ckJ1ZmZlcnMsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJlZUJ1ZmZlcnMgbWV0aG9kLlxyXG4gICAqL1xyXG4gIGZyZWVCdWZmZXJzKCkge1xyXG4gICAgLy8gQmVmb3JlIGRlc3Ryb3lpbmcgYWxsIG91ciBkYXRhLFxyXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBiYm94IGlzIHVwIHRvIGRhdGUuXHJcbiAgICAvLyBpZiAodGhpcy5fX2JvdW5kaW5nQm94RGlydHkpXHJcbiAgICAvLyAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpO1xyXG4gICAgLy8gLy8gVE9ETzogcHVzaCB0aGUgZGF0YSB0byBhIHdvcmtlciB0aHJlYWQgYW5kIHRlcm1pbmF0ZSBsaWtlIGluIE1lc2hQcm94eS5cclxuICAgIC8vIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IEdlb21ldHJ5KEluY2x1ZGluZyBWZXJ0aWNlcyBhbmQgQm91bmRpbmcgQm94KSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCaW5SZWFkZXJ9IHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZEJhc2VHZW9tQmluYXJ5KHJlYWRlcikge1xyXG4gICAgdGhpcy5uYW1lID0gcmVhZGVyLmxvYWRTdHIoKVxyXG4gICAgY29uc3QgZmxhZ3MgPSByZWFkZXIubG9hZFVJbnQ4KClcclxuICAgIHRoaXMuZGVidWdDb2xvciA9IHJlYWRlci5sb2FkUkdCRmxvYXQzMkNvbG9yKClcclxuICAgIGNvbnN0IG51bVZlcnRzID0gcmVhZGVyLmxvYWRVSW50MzIoKVxyXG4gICAgdGhpcy5fX2JvdW5kaW5nQm94LnNldChyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSlcclxuXHJcbiAgICB0aGlzLnNldE51bVZlcnRpY2VzKG51bVZlcnRzKVxyXG4gICAgY29uc3QgcG9zaXRpb25zQXR0ciA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKVxyXG5cclxuICAgIGxldCBub3JtYWxzQXR0clxyXG4gICAgbGV0IHRleENvb3Jkc0F0dHJcclxuICAgIGlmIChmbGFncyAmICgxIDw8IDEpKSB7XHJcbiAgICAgIG5vcm1hbHNBdHRyID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKVxyXG4gICAgICBpZiAoIW5vcm1hbHNBdHRyKSBub3JtYWxzQXR0ciA9IHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCdub3JtYWxzJywgVmVjMywgMC4wKVxyXG4gICAgfVxyXG4gICAgaWYgKGZsYWdzICYgKDEgPDwgMikpIHtcclxuICAgICAgdGV4Q29vcmRzQXR0ciA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCd0ZXhDb29yZHMnKVxyXG4gICAgICBpZiAoIXRleENvb3Jkc0F0dHIpIHRleENvb3Jkc0F0dHIgPSB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgndGV4Q29vcmRzJywgVmVjMiwgMC4wKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgcG9zaXRpb25zXzhiaXQpID0+IHtcclxuICAgICAgZm9yIChsZXQgaSA9IHJhbmdlWzBdOyBpIDwgcmFuZ2VbMV07IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IG5ldyBWZWMzKFxyXG4gICAgICAgICAgcG9zaXRpb25zXzhiaXRbaSAqIDMgKyAwXSAvIDI1NS4wLFxyXG4gICAgICAgICAgcG9zaXRpb25zXzhiaXRbaSAqIDMgKyAxXSAvIDI1NS4wLFxyXG4gICAgICAgICAgcG9zaXRpb25zXzhiaXRbaSAqIDMgKyAyXSAvIDI1NS4wXHJcbiAgICAgICAgKVxyXG4gICAgICAgIHBvcy5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKVxyXG4gICAgICAgIHBvcy5hZGRJblBsYWNlKG9mZnNldClcclxuICAgICAgICBwb3NpdGlvbnNBdHRyLnNldFZhbHVlKGksIHBvcylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhcnNlOEJpdE5vcm1hbHNBcnJheSA9IChyYW5nZSwgb2Zmc2V0LCBzY2xWZWMsIG5vcm1hbHNfOGJpdCkgPT4ge1xyXG4gICAgICBpZiAoc2NsVmVjLmlzTnVsbCgpKSBzY2xWZWMuc2V0KDEsIDEsIDEpXHJcbiAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjMyhcclxuICAgICAgICAgIG5vcm1hbHNfOGJpdFtpICogMyArIDBdIC8gMjU1LjAsXHJcbiAgICAgICAgICBub3JtYWxzXzhiaXRbaSAqIDMgKyAxXSAvIDI1NS4wLFxyXG4gICAgICAgICAgbm9ybWFsc184Yml0W2kgKiAzICsgMl0gLyAyNTUuMFxyXG4gICAgICAgIClcclxuICAgICAgICBub3JtYWwubXVsdGlwbHlJblBsYWNlKHNjbFZlYylcclxuICAgICAgICBub3JtYWwuYWRkSW5QbGFjZShvZmZzZXQpXHJcbiAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZUluUGxhY2UoKVxyXG4gICAgICAgIG5vcm1hbHNBdHRyLnNldFZhbHVlKGksIG5vcm1hbClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2U4Qml0VGV4dHVyZUNvb3Jkc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgdGV4Q29vcmRzXzhiaXQpID0+IHtcclxuICAgICAgLy8gaWYgKHNjbFZlYy5pc051bGwoKSlcclxuICAgICAgLy8gICAgIHNjbFZlYy5zZXQoMSwgMSwgMSk7XHJcbiAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmQgPSBuZXcgVmVjMih0ZXhDb29yZHNfOGJpdFtpICogMiArIDBdIC8gMjU1LjAsIHRleENvb3Jkc184Yml0W2kgKiAyICsgMV0gLyAyNTUuMClcclxuICAgICAgICB0ZXh0dXJlQ29vcmQubXVsdGlwbHlJblBsYWNlKHNjbFZlYylcclxuICAgICAgICB0ZXh0dXJlQ29vcmQuYWRkSW5QbGFjZShvZmZzZXQpXHJcbiAgICAgICAgdGV4Q29vcmRzQXR0ci5zZXRWYWx1ZShpLCB0ZXh0dXJlQ29vcmQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBudW1DbHVzdGVycyA9IHJlYWRlci5sb2FkVUludDMyKClcclxuICAgIGlmIChudW1DbHVzdGVycyA9PSAxKSB7XHJcbiAgICAgIHtcclxuICAgICAgICBjb25zdCBib3gzID0gdGhpcy5fX2JvdW5kaW5nQm94XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25zXzhiaXQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKVxyXG4gICAgICAgIHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgcG9zaXRpb25zXzhiaXQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChub3JtYWxzQXR0cikge1xyXG4gICAgICAgIGNvbnN0IGJveDMgPSBuZXcgQm94MyhyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSlcclxuICAgICAgICBjb25zdCBub3JtYWxzXzhiaXQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKVxyXG4gICAgICAgIHBhcnNlOEJpdE5vcm1hbHNBcnJheShbMCwgbnVtVmVydHNdLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIG5vcm1hbHNfOGJpdClcclxuXHJcbiAgICAgICAgbm9ybWFsc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcilcclxuICAgICAgfVxyXG4gICAgICBpZiAodGV4Q29vcmRzQXR0cikge1xyXG4gICAgICAgIGNvbnN0IGJveDIgPSBuZXcgQm94MihyZWFkZXIubG9hZEZsb2F0MzJWZWMyKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzIoKSlcclxuICAgICAgICBjb25zdCB0ZXhDb29yZHNfOGJpdCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDIpXHJcbiAgICAgICAgcGFyc2U4Qml0VGV4dHVyZUNvb3Jkc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzXzhiaXQpXHJcblxyXG4gICAgICAgIHRleENvb3Jkc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcilcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXVxyXG4gICAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsdXN0ZXJzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHJlYWRlci5sb2FkVUludDMyKClcclxuICAgICAgICBjb25zdCBib3gzID0gbmV3IEJveDMocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpXHJcbiAgICAgICAgY29uc3QgY2x1c3RlckRhdGEgPSB7XHJcbiAgICAgICAgICByYW5nZTogW29mZnNldCwgb2Zmc2V0ICsgY291bnRdLFxyXG4gICAgICAgICAgYmJveDogYm94MyxcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7XHJcbiAgICAgICAgICBjbHVzdGVyRGF0YS5ub3JtYWxzUmFuZ2UgPSBuZXcgQm94MyhyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleENvb3Jkc0F0dHIpIHtcclxuICAgICAgICAgIGNsdXN0ZXJEYXRhLnRleENvb3Jkc1JhbmdlID0gbmV3IEJveDIocmVhZGVyLmxvYWRGbG9hdDMyVmVjMigpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMyKCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXJEYXRhKVxyXG4gICAgICAgIG9mZnNldCArPSBjb3VudFxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMylcclxuICAgICAgbGV0IG5vcm1hbHNfOGJpdFxyXG4gICAgICBsZXQgdGV4Q29vcmRzXzhiaXRcclxuICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7XHJcbiAgICAgICAgbm9ybWFsc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMylcclxuICAgICAgfVxyXG4gICAgICBpZiAodGV4Q29vcmRzQXR0cikge1xyXG4gICAgICAgIHRleENvb3Jkc184Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMilcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbHVzdGVyczsgaSsrKSB7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY29uc3QgYm94MyA9IGNsdXN0ZXJzW2ldLmJib3hcclxuICAgICAgICAgIHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5KGNsdXN0ZXJzW2ldLnJhbmdlLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIHBvc2l0aW9uc184Yml0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7XHJcbiAgICAgICAgICBjb25zdCBib3gzID0gY2x1c3RlcnNbaV0ubm9ybWFsc1JhbmdlXHJcbiAgICAgICAgICBwYXJzZThCaXROb3JtYWxzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc184Yml0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4Q29vcmRzQXR0cikge1xyXG4gICAgICAgICAgY29uc3QgYm94MiA9IGNsdXN0ZXJzW2ldLnRleENvb3Jkc1JhbmdlXHJcbiAgICAgICAgICBwYXJzZThCaXRUZXh0dXJlQ29vcmRzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzXzhiaXQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChub3JtYWxzQXR0cikge1xyXG4gICAgICAgIG5vcm1hbHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRleENvb3Jkc0F0dHIpIHtcclxuICAgICAgICB0ZXhDb29yZHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdG9KU09OKGNvbnRleHQpIHtcclxuICAgIGxldCBqc29uID0gc3VwZXIudG9KU09OKGNvbnRleHQpXHJcbiAgICBpZiAoIWpzb24pIGpzb24gPSB7fVxyXG4gICAganNvbi50eXBlID0gUmVnaXN0cnkuZ2V0Qmx1ZXByaW50TmFtZSh0aGlzKVxyXG4gICAganNvbi5udW1WZXJ0aWNlcyA9IHRoaXMuX19udW1WZXJ0aWNlc1xyXG5cclxuICAgIGNvbnN0IHZlcnRleEF0dHJpYnV0ZXMgPSB7fVxyXG4gICAgZm9yIChjb25zdCBba2V5LCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgLy8gaWYgKCFvcHRzIHx8ICEoJ2F0dHJMaXN0JyBpbiBvcHRzKSB8fCBvcHRzLmF0dHJMaXN0LmluZGV4T2Yoa2V5KSAhPSAtMSlcclxuICAgICAgdmVydGV4QXR0cmlidXRlc1trZXldID0gYXR0ci50b0pTT04oY29udGV4dClcclxuICAgIH1cclxuICAgIGpzb24udmVydGV4QXR0cmlidXRlcyA9IHZlcnRleEF0dHJpYnV0ZXNcclxuXHJcbiAgICByZXR1cm4ganNvblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqc29uIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLlxyXG4gICAqL1xyXG4gIGZyb21KU09OKGpzb24sIGNvbnRleHQpIHtcclxuICAgIHN1cGVyLmZyb21KU09OKGpzb24sIGNvbnRleHQpXHJcbiAgICB0aGlzLnNldE51bVZlcnRpY2VzKGpzb24ubnVtVmVydGljZXMpXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4ganNvbi52ZXJ0ZXhBdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGxldCBhdHRyID0gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KG5hbWUpXHJcbiAgICAgIGNvbnN0IGF0dHJKU09OID0ganNvbi52ZXJ0ZXhBdHRyaWJ1dGVzW25hbWVdXHJcbiAgICAgIGlmICghYXR0cikge1xyXG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gUmVnaXN0cnkuZ2V0Qmx1ZXByaW50KGF0dHJKU09OLmRhdGFUeXBlKVxyXG4gICAgICAgIGF0dHIgPSBuZXcgVmVydGV4QXR0cmlidXRlKHRoaXMsIGRhdGFUeXBlLCAwLCBhdHRySlNPTi5kZWZhdWx0U2NhbGFyVmFsdWUpXHJcbiAgICAgICAgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpXHJcbiAgICAgIH1cclxuICAgICAgYXR0ci5mcm9tSlNPTihhdHRySlNPTilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZ2VvbWV0cnkgZGF0YSB2YWx1ZSBpbiBqc29uIGZvcm1hdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIDIpXHJcbiAgfVxyXG59XHJcbmV4cG9ydCB7IEJhc2VHZW9tIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXHJcbmltcG9ydCB7IEJhc2VHZW9tIH0gZnJvbSAnLi9CYXNlR2VvbS5qcydcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uLy4uL1JlZ2lzdHJ5J1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBvaW50IHByaW1pdGl2ZSBkcmF3aW5nIHR5cGUsIGV2ZXJ5IHZlcnRleCBzcGVjaWZpZWQgaXMgYSBwb2ludC5cclxuICpcclxuICogYGBgXHJcbiAqIGNvbnN0IHBvaW50cyA9IG5ldyBQb2ludHMoKVxyXG4gKiBgYGBcclxuICpcclxuICogKiAqKkV2ZW50cyoqXHJcbiAqICogKipib3VuZGluZ0JveENoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCYXNlR2VvbVxyXG4gKi9cclxuY2xhc3MgUG9pbnRzIGV4dGVuZHMgQmFzZUdlb20ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBwb2ludHMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhbmQgcG9wdWxhdGVzIGBQb2ludHNgIG9iamVjdCBmcm9tIGEgYmluYXJ5IHJlYWRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRCaW4ocmVhZGVyKSB7XHJcbiAgICB0aGlzLm5hbWUgPSByZWFkZXIubG9hZFN0cigpXHJcbiAgICBjb25zdCBudW1WZXJ0cyA9IHJlYWRlci5sb2FkVUludDMyKClcclxuICAgIHRoaXMuX19ib3VuZGluZ0JveC5zZXQocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpXHJcbiAgICB0aGlzLnNldE51bVZlcnRpY2VzKG51bVZlcnRzKVxyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcblxyXG4gICAgaWYgKG51bVZlcnRzIDwgMjU2KSB7XHJcbiAgICAgIGNvbnN0IGJib3hNYXQgPSB0aGlzLl9fYm91bmRpbmdCb3gudG9NYXQ0KClcclxuICAgICAgY29uc3QgcG9zQXR0cl84Yml0ID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMylcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WZXJ0czsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gbmV3IFZlYzMoXHJcbiAgICAgICAgICBwb3NBdHRyXzhiaXRbaSAqIDMgKyAwXSAvIDI1NS4wLFxyXG4gICAgICAgICAgcG9zQXR0cl84Yml0W2kgKiAzICsgMV0gLyAyNTUuMCxcclxuICAgICAgICAgIHBvc0F0dHJfOGJpdFtpICogMyArIDJdIC8gMjU1LjBcclxuICAgICAgICApXHJcbiAgICAgICAgcG9zaXRpb25zLnNldFZhbHVlKGksIGJib3hNYXQudHJhbnNmb3JtVmVjMyhwb3MpKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBudW1DbHVzdGVycyA9IHJlYWRlci5sb2FkVUludDMyKClcclxuICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsdXN0ZXJzOyBpKyspIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHJlYWRlci5sb2FkVUludDMyVmVjMigpXHJcbiAgICAgICAgY29uc3QgcDAgPSByZWFkZXIubG9hZEZsb2F0MzJWZWMzKClcclxuICAgICAgICBjb25zdCBwMSA9IHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKVxyXG4gICAgICAgIGNsdXN0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgYmJveDogbmV3IEJveDMocDAsIHAxKSxcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHBvc0F0dHJfOGJpdCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMpXHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsdXN0ZXJzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiYm94TWF0ID0gY2x1c3RlcnNbaV1bJ2Jib3gnXS50b01hdDQoKVxyXG4gICAgICAgIGZvciAobGV0IGogPSBjbHVzdGVyc1tpXVsncmFuZ2UnXS54OyBqIDwgY2x1c3RlcnNbaV1bJ3JhbmdlJ10ueTsgaisrKSB7XHJcbiAgICAgICAgICBjb25zdCBwb3MgPSBuZXcgVmVjMyhcclxuICAgICAgICAgICAgcG9zQXR0cl84Yml0W2ogKiAzICsgMF0gLyAyNTUuMCxcclxuICAgICAgICAgICAgcG9zQXR0cl84Yml0W2ogKiAzICsgMV0gLyAyNTUuMCxcclxuICAgICAgICAgICAgcG9zQXR0cl84Yml0W2ogKiAzICsgMl0gLyAyNTUuMFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgcG9zaXRpb25zLnNldFZhbHVlKGosIGJib3hNYXQudHJhbnNmb3JtVmVjMyhwb3MpKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBnZW9tZXRyeShJbmNsdWRpbmcgbGluZSBzZWdtZW50cykgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHtcclxuICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIpXHJcblxyXG4gICAgLy8gdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnLCB7fSlcclxuICB9XHJcbn1cclxuXHJcblJlZ2lzdHJ5LnJlZ2lzdGVyKCdQb2ludHMnLCBQb2ludHMpXHJcblxyXG5leHBvcnQgeyBQb2ludHMgfVxyXG4iLCJpbXBvcnQgeyBCYXNlR2VvbSB9IGZyb20gJy4vQmFzZUdlb20uanMnXHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tICcuLi8uLi9SZWdpc3RyeSdcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgbGluZXMgcHJpbWl0aXZlIGRyYXdpbmcgdHlwZSwgY29ubmVjdGluZyB2ZXJ0aWNlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGluZGljZXMuXHJcbiAqIGkuZS4gV2UgaGF2ZSA0IHBvaW50cyh2ZXJ0aWNlcykgYnV0IHdlIGRvbid0IGtub3cgaG93IHRoZXkgY29ubmVjdCB0byBlYWNoIG90aGVyLFxyXG4gKiBhbmQgdGhhdCdzIHdoeSB3ZSBuZWVkIGluZGljZXMoTnVtYmVycyBpbmRpY2F0aW5nIHdoaWNoIHZlcnRleCBjb25uZWN0cyB0byB3aGljaCkuXHJcbiAqIEluIHRoaXMgY2FzZSBpZiB3ZSBzYXkgdGhhdCBgaW5kaWNlc2AgaXMgYFswLDEsMiwzXWAsIGl0IHdvdWxkIGNvbm5lY3QgdGhlIGZpcnN0IHZlcnRleCB0byB0aGUgc2Vjb25kLFxyXG4gKiBhbmQgdGhlIHRoaXJkIHRvIHRoZSBmb3VydGguXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBsaW5lcyA9IG5ldyBMaW5lcygpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAqKkV2ZW50cyoqXHJcbiAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGdlb21ldHJ5IGlzIHNldChUaGlzIGluY2x1ZGVzIHJlYWRpbmcgYmluYXJ5KVxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCYXNlR2VvbVxyXG4gKi9cclxuY2xhc3MgTGluZXMgZXh0ZW5kcyBCYXNlR2VvbSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGxpbmVzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgdGhpcy5fX2luZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKVxyXG4gICAgdGhpcy5saW5lVGhpY2tuZXNzID0gMC4wXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgaW5kaWNlcyhWZXJ0ZXggY29ubmVjdG9ycylcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1VpbnQzMkFycmF5fSAtIFRoZSBpbmRpY2VzIGluZGV4IGFycmF5LlxyXG4gICAqL1xyXG4gIGdldEluZGljZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2luZGljZXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cy5cclxuICAgKi9cclxuICBnZXROdW1TZWdtZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgbGluZSBzZWdtZW50cyBpbiB0aGUgZ2VvbWV0cnkuPGJyPlxyXG4gICAqICoqSW1wb3J0YW50OioqIEl0IHJlc2V0cyBpbmRpY2VzIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PZlNlZ21lbnRzIC0gVGhlIGNvdW50IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldE51bVNlZ21lbnRzKG51bU9mU2VnbWVudHMpIHtcclxuICAgIGlmIChudW1PZlNlZ21lbnRzID4gdGhpcy5nZXROdW1TZWdtZW50cygpKSB7XHJcbiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobnVtT2ZTZWdtZW50cyAqIDIpXHJcbiAgICAgIGluZGljZXMuc2V0KHRoaXMuX19pbmRpY2VzKVxyXG4gICAgICB0aGlzLl9faW5kaWNlcyA9IGluZGljZXNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19pbmRpY2VzID0gdGhpcy5fX2luZGljZXMuc2xpY2UoMCwgbnVtT2ZTZWdtZW50cyAqIDIpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHNlZ21lbnQgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAwIC0gVGhlIHAwIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwMSAtIFRoZSBwMSB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRTZWdtZW50VmVydGV4SW5kaWNlcyhpbmRleCwgcDAsIHAxKSB7XHJcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5fX2luZGljZXMubGVuZ3RoIC8gMilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpbmUgaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFNlZ21lbnRzOicgKyB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyKVxyXG4gICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMF0gPSBwMFxyXG4gICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMV0gPSBwMVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzZWdtZW50IHZhbHVlcyBpbiB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwMCAtIFRoZSBwMCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcDEgLSBUaGUgcDEgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0U2VnbWVudChpbmRleCwgcDAsIHAxKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQgdXNlICNzZXRTZWdtZW50VmVydGV4SW5kaWNlc2ApXHJcbiAgICB0aGlzLnNldFNlZ21lbnRWZXJ0ZXhJbmRpY2VzKGluZGV4LCBwMCwgcDEpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2V0U2VnbWVudFZlcnRleEluZGV4IG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIC0gVGhlIGxpbmUgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVWZXJ0ZXggLSBUaGUgbGluZVZlcnRleCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGdldFNlZ21lbnRWZXJ0ZXhJbmRleChsaW5lLCBsaW5lVmVydGV4KSB7XHJcbiAgICBjb25zdCBudW1TZWdtZW50cyA9IHRoaXMuZ2V0TnVtU2VnbWVudHMoKVxyXG4gICAgaWYgKGxpbmUgPCBudW1TZWdtZW50cykgcmV0dXJuIHRoaXMuX19pbmRpY2VzW2xpbmUgKiAyICsgbGluZVZlcnRleF1cclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBNZW1vcnlcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlcyBidWZmZXJzIGFuZCBpdHMgY291bnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZW5CdWZmZXJzKCkge1xyXG4gICAgY29uc3QgYnVmZmVycyA9IHN1cGVyLmdlbkJ1ZmZlcnMoKVxyXG5cclxuICAgIGxldCBpbmRpY2VzXHJcbiAgICBpZiAoYnVmZmVycy5udW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDgpKSB7XHJcbiAgICAgIGluZGljZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9faW5kaWNlcy5sZW5ndGgpXHJcbiAgICAgIHRoaXMuX19pbmRpY2VzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhdID0gdmFsdWVcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSBpZiAoYnVmZmVycy5udW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkge1xyXG4gICAgICBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19pbmRpY2VzLmxlbmd0aClcclxuICAgICAgdGhpcy5fX2luZGljZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleF0gPSB2YWx1ZVxyXG4gICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5kaWNlcyA9IHRoaXMuX19pbmRpY2VzXHJcbiAgICB9XHJcbiAgICBidWZmZXJzLmluZGljZXMgPSBpbmRpY2VzXHJcbiAgICByZXR1cm4gYnVmZmVyc1xyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBnZW9tZXRyeShJbmNsdWRpbmcgbGluZSBzZWdtZW50cykgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHtcclxuICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIpXHJcblxyXG4gICAgdGhpcy5zZXROdW1TZWdtZW50cyhyZWFkZXIubG9hZFVJbnQzMigpKVxyXG5cclxuICAgIGNvbnN0IGJ5dGVzID0gcmVhZGVyLmxvYWRVSW50OCgpXHJcbiAgICBpZiAoYnl0ZXMgPT0gMSkgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKVxyXG4gICAgZWxzZSBpZiAoYnl0ZXMgPT0gMikgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KClcclxuICAgIGVsc2UgaWYgKGJ5dGVzID09IDQpIHRoaXMuX19pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MzJBcnJheSgpXHJcblxyXG4gICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnLCB7fSlcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC5cclxuICAgKi9cclxuICB0b0pTT04oY29udGV4dCkge1xyXG4gICAgY29uc3QgaiA9IHN1cGVyLnRvSlNPTihjb250ZXh0KVxyXG4gICAgai5pbmRpY2VzID0gQXJyYXkuZnJvbSh0aGlzLl9faW5kaWNlcylcclxuXHJcbiAgICByZXR1cm4galxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLlxyXG4gICAqL1xyXG4gIGZyb21KU09OKGosIGNvbnRleHQpIHtcclxuICAgIHN1cGVyLmZyb21KU09OKGosIGNvbnRleHQpXHJcbiAgICB0aGlzLl9faW5kaWNlcyA9IFVpbnQzMkFycmF5LmZyb20oai5pbmRpY2VzKVxyXG4gIH1cclxufVxyXG5cclxuUmVnaXN0cnkucmVnaXN0ZXIoJ0xpbmVzJywgTGluZXMpXHJcblxyXG5leHBvcnQgeyBMaW5lcyB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cclxuaW1wb3J0IHsgQXR0cmlidXRlIH0gZnJvbSAnLi9BdHRyaWJ1dGUuanMnXHJcbmltcG9ydCB7IEZsb2F0MzIgfSBmcm9tICcuLi8uLi9VdGlsaXRpZXMvTWF0aEZ1bmN0aW9ucydcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdmVydGV4IGF0dHJpYnV0ZXMuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGUgPSBuZXcgVmVydGV4QXR0cmlidXRlKHRoaXMsIEZsb2F0MzIsIDApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdHRyaWJ1dGVcclxuICovXHJcbmNsYXNzIFZlcnRleEF0dHJpYnV0ZSBleHRlbmRzIEF0dHJpYnV0ZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHZlcnRleCBhdHRyaWJ1dGVzXHJcbiAgICogQHBhcmFtIHtNZXNofSBnZW9tIC0gVGhlIGdlb20gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtBdHRyVmFsdWV8bnVtYmVyfSBkYXRhVHlwZSAtIFRoZSBkYXRhVHlwZSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcnxUeXBlZEFycmF5fSBleHBlY3RlZFNpemUgLSBUaGUgZXhwZWN0ZWRTaXplIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0U2NhbGFyVmFsdWUgLSBUaGUgZGVmYXVsdCBzY2FsYXIgdmFsdWUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZ2VvbSwgZGF0YVR5cGUsIGV4cGVjdGVkU2l6ZSwgZGVmYXVsdFNjYWxhclZhbHVlKSB7XHJcbiAgICBzdXBlcihkYXRhVHlwZSwgZXhwZWN0ZWRTaXplLCBkZWZhdWx0U2NhbGFyVmFsdWUpXHJcbiAgICB0aGlzLl9fZ2VvbSA9IGdlb20gLy8gVE9ETzogV2Vha1JlZj8/XHJcblxyXG4gICAgdGhpcy5fX3NwbGl0cyA9IHt9XHJcbiAgICB0aGlzLl9fc3BsaXRWYWx1ZXMgPSBbXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdldEZhY2VWZXJ0ZXhWYWx1ZVJlZiBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY2UgLSBUaGUgZmFjZSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZXZlcnRleCAtIFRoZSBmYWNlIHZlcnRleCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtBdHRyVmFsdWV9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRGYWNlVmVydGV4VmFsdWVSZWYoZmFjZSwgZmFjZXZlcnRleCkge1xyXG4gICAgY29uc3QgdmVydGV4ID0gdGhpcy5fX2dlb20uZ2V0RmFjZVZlcnRleEluZGV4KGZhY2UsIGZhY2V2ZXJ0ZXgpXHJcbiAgICBpZiAodmVydGV4IGluIHRoaXMuX19zcGxpdHMgJiYgZmFjZSBpbiB0aGlzLl9fc3BsaXRzW3ZlcnRleF0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX19zcGxpdFZhbHVlc1t0aGlzLl9fc3BsaXRzW3ZlcnRleF1bZmFjZV1dXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZVJlZih2ZXJ0ZXgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2V0RmFjZVZlcnRleFZhbHVlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZSAtIFRoZSBmYWNlIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNldmVydGV4IC0gVGhlIGZhY2V2ZXJ0ZXggdmFsdWUuXHJcbiAgICogQHBhcmFtIHtBdHRyVmFsdWV9IHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNldmVydGV4LCB2YWx1ZSkge1xyXG4gICAgY29uc3QgdmVydGV4ID0gdGhpcy5fX2dlb20uZ2V0RmFjZVZlcnRleEluZGV4KGZhY2UsIGZhY2V2ZXJ0ZXgpXHJcbiAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2V0RmFjZVZlcnRleFZhbHVlX0J5VmVydGV4SW5kZXggbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlIC0gVGhlIGZhY2UgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuXHJcbiAgICogQHBhcmFtIHtBdHRyVmFsdWV9IHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpIHtcclxuICAgIGNvbnN0IHZhbHVlUmVmID0gdGhpcy5nZXRWYWx1ZVJlZih2ZXJ0ZXgpXHJcbiAgICBpZiAoIXZhbHVlUmVmLmlzVmFsaWQoKSkge1xyXG4gICAgICAvLyB0aGUgdmFsdWUgaXMgdW5pbml0aWFsaXplZC4gSW5pdGlhbGl6ZSBpdC5cclxuICAgICAgdmFsdWVSZWYuc2V0RnJvbU90aGVyKHZhbHVlKVxyXG4gICAgfSBlbHNlIGlmICh2YWx1ZVJlZi5hcHByb3hFcXVhbCh2YWx1ZSkpIHtcclxuICAgICAgLy8gUmV1c2luZyB2ZXJ0ZXggdmFsdWUuIERvIG5vdGhpbmdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHZhbHVlXHJcblxyXG4gICAgICBpZiAodmVydGV4IGluIHRoaXMuX19zcGxpdHMpIHtcclxuICAgICAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGV4aXN0aW5nIHNwbGl0cyBmb3IgdGhpcyB2ZXJ0ZXggbWF0Y2ggdGhlIHZhbHVlIGJlaW5nIHNldC5cclxuICAgICAgICAvLyBpLmUuIGZvciBmYWNlcyBhcm91bmQgYSB2ZXJ0ZXgsIHRoZXJlIHdpbGwgb2Z0ZW4gYmUgYSBzZWFtIGFsb25nIDIgZWRnZXNcclxuICAgICAgICAvLyB3aGVyZSB0aGUgdmFsdWVzIGRpZmZlci4gT24gZWFjaCBzaWRlIG9mIHRoZSBzZWFtLCBhbGwgZmFjZXMgY2FuIHVzZSB0aGUgc2FtZVxyXG4gICAgICAgIC8vIHZhbHVlLiBXZSBzaG91bGQgc2VlIHRoZW4gb25seSBvbmUgc3BsaXQgdmFsdWUgZm9yIHRoZSB2ZXJ0ZXguXHJcbiAgICAgICAgY29uc3QgdmVydGV4U3BsaXRJZHMgPSB0aGlzLl9fc3BsaXRzW3ZlcnRleF1cclxuICAgICAgICBmb3IgKGNvbnN0IGZpZCBpbiB2ZXJ0ZXhTcGxpdElkcykge1xyXG4gICAgICAgICAgY29uc3Qgc3BsaXRJZCA9IHZlcnRleFNwbGl0SWRzW2ZpZF1cclxuICAgICAgICAgIGlmICh0aGlzLl9fc3BsaXRWYWx1ZXNbc3BsaXRJZF0uYXBwcm94RXF1YWwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlLXVzZSB0aGlzIHNwbGl0IHZhbHVlXHJcbiAgICAgICAgICAgIHZlcnRleFNwbGl0SWRzW2ZhY2VdID0gc3BsaXRJZFxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGEgc3BsaXQgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgZmFjZSwgcmUtdXNlIGl0LlxyXG4gICAgICAgIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWVSZWYgPSB0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXVxyXG4gICAgICAgICAgdmFsdWVSZWYuc2V0RnJvbU90aGVyKHZhbHVlKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX19zcGxpdHNbdmVydGV4XSA9IHt9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdID0gdGhpcy5fX3NwbGl0VmFsdWVzLmxlbmd0aFxyXG4gICAgICB0aGlzLl9fc3BsaXRWYWx1ZXMucHVzaCh2YWx1ZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzZXRTcGxpdFZlcnRleFZhbHVlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmVydGV4IC0gVGhlIHZlcnRleCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZSAtIFRoZSBmYWNlIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7QXR0clZhbHVlfSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRTcGxpdFZlcnRleFZhbHVlKHZlcnRleCwgZmFjZSwgdmFsdWUpIHtcclxuICAgIGlmICghKHZlcnRleCBpbiB0aGlzLl9fc3BsaXRzKSkgdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdID0ge31cclxuICAgIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkge1xyXG4gICAgICBjb25zdCBjdXJyVmFsdWUgPSB0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXVxyXG4gICAgICBpZiAoY3VyclZhbHVlLmFwcHJveEVxdWFsKHZhbHVlKSkgcmV0dXJuXHJcbiAgICAgIGNvbnNvbGUud2FybignRmFjZSBWZXJ0ZXggQWxyZWFkeSBTcGxpdCB3aXRoIGRpZmZlcmVudCB2YWx1ZScpXHJcbiAgICB9XHJcbiAgICB0aGlzLl9fc3BsaXRzW3ZlcnRleF1bZmFjZV0gPSB0aGlzLl9fc3BsaXRWYWx1ZXMubGVuZ3RoXHJcbiAgICB0aGlzLl9fc3BsaXRWYWx1ZXMucHVzaCh2YWx1ZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzZXRTcGxpdFZlcnRleFZhbHVlcyBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuXHJcbiAgICogQHBhcmFtIHthcnJheX0gZmFjZUdyb3VwIC0gVGhlIGZhY2VHcm91cCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge0F0dHJWYWx1ZX0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZXModmVydGV4LCBmYWNlR3JvdXAsIHZhbHVlKSB7XHJcbiAgICBpZiAoISh2ZXJ0ZXggaW4gdGhpcy5fX3NwbGl0cykpIHRoaXMuX19zcGxpdHNbdmVydGV4XSA9IHt9XHJcbiAgICBjb25zdCBzcGxpdEluZGV4ID0gdGhpcy5fX3NwbGl0VmFsdWVzLmxlbmd0aFxyXG4gICAgdGhpcy5fX3NwbGl0VmFsdWVzLnB1c2godmFsdWUpXHJcbiAgICBmb3IgKGNvbnN0IGZhY2Ugb2YgZmFjZUdyb3VwKSB7XHJcbiAgICAgIC8vIGlmIChmYWNlIGluIHRoaXMuX19zcGxpdHNbdmVydGV4XSkge1xyXG4gICAgICAvLyAgICAgbGV0IGN1cnJWYWx1ZSA9IHRoaXMuX19zcGxpdFZhbHVlc1t0aGlzLl9fc3BsaXRzW3ZlcnRleF1bZmFjZV1dO1xyXG4gICAgICAvLyAgICAgaWYgKGN1cnJWYWx1ZS5hcHByb3hFcXVhbCh2YWx1ZSkpXHJcbiAgICAgIC8vICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAvLyAgICAgY29uc29sZS53YXJuKFwiRmFjZSBWZXJ0ZXggQWxyZWFkeSBTcGxpdCB3aXRoIGRpZmZlcmVudCB2YWx1ZVwiKTtcclxuICAgICAgLy8gfVxyXG4gICAgICB0aGlzLl9fc3BsaXRzW3ZlcnRleF1bZmFjZV0gPSBzcGxpdEluZGV4XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2V0U3BsaXRzIG1ldGhvZC5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldFNwbGl0cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fc3BsaXRzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2V0U3BsaXRDb3VudCBtZXRob2QuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0U3BsaXRDb3VudCgpIHtcclxuICAgIGxldCBzcGxpdENvdW50ID0gMFxyXG4gICAgZm9yIChjb25zdCB2ZXJ0ZXggaW4gdGhpcy5fX3NwbGl0cykgc3BsaXRDb3VudCArPSBPYmplY3Qua2V5cyh0aGlzLl9fc3BsaXRzW3ZlcnRleF0pLmxlbmd0aFxyXG4gICAgcmV0dXJuIHNwbGl0Q291bnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBnZW5lcmF0ZVNwbGl0VmFsdWVzIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge2FycmF5fSBzcGxpdEluZGljZXMgLSBUaGUgc3BsaXRJbmRpY2VzIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGxpdENvdW50IC0gVGhlIHNwbGl0Q291bnQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2VuZXJhdGVTcGxpdFZhbHVlcyhzcGxpdEluZGljZXMsIHNwbGl0Q291bnQpIHtcclxuICAgIGlmIChzcGxpdENvdW50ID09IDApIHJldHVybiB0aGlzLl9fZGF0YVxyXG5cclxuICAgIGNvbnN0IG51bVVuU3BsaXRWYWx1ZXMgPSB0aGlzLmxlbmd0aFxyXG4gICAgY29uc3QgY291bnQgPSB0aGlzLmxlbmd0aCArIHNwbGl0Q291bnRcclxuICAgIGNvbnN0IG51bUVsZW1zID0gdGhpcy5fX2RhdGFUeXBlLm51bUVsZW1lbnRzID8gdGhpcy5fX2RhdGFUeXBlLm51bUVsZW1lbnRzKCkgOiAxXHJcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIG51bUVsZW1zKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9fZGF0YS5sZW5ndGg7IGkrKykgZGF0YVtpXSA9IHRoaXMuX19kYXRhW2ldXHJcblxyXG4gICAgLy8gTm93IGR1cGxpY2F0ZSB0aGUgc3BsaXQgdmFsdWVzIHRvIGdlbmVyYXRlIGFuIGF0dHJpYnV0ZXMgYXJyYXlcclxuICAgIC8vIHVzaWcgdGhlIHNoYXJlZCBzcGxpdHMgYWNjcm9zcyBhbGwgYXR0cmlidXRlcy5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgIGZvciAoY29uc3QgdmVydGV4IGluIHNwbGl0SW5kaWNlcykge1xyXG4gICAgICBjb25zdCBmYWNlcyA9IHNwbGl0SW5kaWNlc1t2ZXJ0ZXhdXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgICAgZm9yIChjb25zdCBmYWNlIGluIGZhY2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGd0ID0gbnVtVW5TcGxpdFZhbHVlcyArIGZhY2VzW2ZhY2VdXHJcbiAgICAgICAgaWYgKHZlcnRleCBpbiB0aGlzLl9fc3BsaXRzICYmIGZhY2UgaW4gdGhpcy5fX3NwbGl0c1t2ZXJ0ZXhdKSB7XHJcbiAgICAgICAgICAvLyB0aGlzIGF0dHJpYnVlIGhhcyBhIHNwbGl0IHZhbHVlIGluIGl0cyBhcnJheS5cclxuICAgICAgICAgIC8vIHdlIG11c3QgdXNlIHRoYXQgdmFsdWUuLi5cclxuICAgICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuX19zcGxpdHNbdmVydGV4XVtmYWNlXVxyXG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhVHlwZSA9PSBGbG9hdDMyKSBkYXRhW3RndCAqIG51bUVsZW1zXSA9IHRoaXMuX19zcGxpdFZhbHVlc1tzcmNdXHJcbiAgICAgICAgICBlbHNlIHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tQnVmZmVyKGRhdGEuYnVmZmVyLCB0Z3QgKiBudW1FbGVtcyAqIDQpLnNldEZyb21PdGhlcih0aGlzLl9fc3BsaXRWYWx1ZXNbc3JjXSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ29weSBlYWNoIHNjYWxhciB2YWx1ZSB0byB0aGUgbmV3IHBsYWNlIGluIHRoZSBhcnJheS5cclxuICAgICAgICAgIGNvbnN0IHNyYyA9IHBhcnNlSW50KHZlcnRleClcclxuICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbnVtRWxlbXM7IGUrKykge1xyXG4gICAgICAgICAgICBpZiAoc3JjICogbnVtRWxlbXMgKyBlID4gdGhpcy5fX2RhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHJlbWFwcGluZyBzcmM6JyArIHNyYyAqIG51bUVsZW1zICsgZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGd0ICogbnVtRWxlbXMgKyBlID4gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcmVtYXBwaW5nIHRndDonICsgdGd0ICogbnVtRWxlbXMgKyBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFbdGd0ICogbnVtRWxlbXMgKyBlXSA9IHRoaXMuX19kYXRhW3NyYyAqIG51bUVsZW1zICsgZV1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIHRvSlNPTihjb250ZXh0KSB7XHJcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKGNvbnRleHQpXHJcbiAgICBqc29uLnNwbGl0cyA9IHRoaXMuX19zcGxpdHNcclxuICAgIGpzb24uc3BsaXRWYWx1ZXMgPSB0aGlzLl9fc3BsaXRWYWx1ZXNcclxuICAgIHJldHVybiBqc29uXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGpzb24gLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oanNvbiwgY29udGV4dCkge1xyXG4gICAgc3VwZXIuZnJvbUpTT04oanNvbiwgY29udGV4dClcclxuICAgIHRoaXMuX19zcGxpdHMgPSBqc29uLnNwbGl0c1xyXG4gICAgdGhpcy5fX3NwbGl0VmFsdWVzID0gW11cclxuICAgIGZvciAoY29uc3QgdmFsanNvbiBvZiBqc29uLnNwbGl0VmFsdWVzKSB0aGlzLl9fc3BsaXRWYWx1ZXMucHVzaCh0aGlzLl9fZGF0YVR5cGUuY3JlYXRlRnJvbUpTT04odmFsanNvbikpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbG9hZFNwbGl0VmFsdWVzIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkU3BsaXRWYWx1ZXMocmVhZGVyKSB7XHJcbiAgICBjb25zdCBzcGxpdEluZGljZXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KClcclxuICAgIGlmIChzcGxpdEluZGljZXMubGVuZ3RoID09IDApIHJldHVyblxyXG4gICAgbGV0IG9mZnNldCA9IDBcclxuICAgIGxldCBudW1TcGxpdFZhbHVlcyA9IDBcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGNvbnN0IHZlcnRleElkID0gc3BsaXRJbmRpY2VzW29mZnNldCsrXVxyXG4gICAgICBjb25zdCBudW1TcGxpdHMgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdXHJcblxyXG4gICAgICBjb25zdCBzcGxpdHMgPSB7fVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNwbGl0czsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZmFjZUlkID0gc3BsaXRJbmRpY2VzW29mZnNldCsrXVxyXG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdXHJcbiAgICAgICAgc3BsaXRzW2ZhY2VJZF0gPSBzcGxpdElkXHJcbiAgICAgICAgaWYgKHNwbGl0SWQgPj0gbnVtU3BsaXRWYWx1ZXMpIG51bVNwbGl0VmFsdWVzID0gc3BsaXRJZCArIDFcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9fc3BsaXRzW3ZlcnRleElkXSA9IHNwbGl0c1xyXG4gICAgICBpZiAob2Zmc2V0ID49IHNwbGl0SW5kaWNlcy5sZW5ndGgpIGJyZWFrXHJcbiAgICB9XHJcbiAgICBjb25zdCBkaW0gPSB0aGlzLl9fbnVtRmxvYXQzMkVsZW1lbnRzXHJcbiAgICBjb25zdCBzcGxpdFZhbHVlcyA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KG51bVNwbGl0VmFsdWVzICogZGltKVxyXG4gICAgdGhpcy5fX3NwbGl0VmFsdWVzID0gW11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3BsaXRWYWx1ZXM7IGkrKykge1xyXG4gICAgICBjb25zdCB2YWwgPSB0aGlzLl9fZGF0YVR5cGUuY3JlYXRlRnJvbUZsb2F0MzJBcnJheShzcGxpdFZhbHVlcy5zbGljZShpICogZGltLCBpICogZGltICsgZGltKSlcclxuICAgICAgdGhpcy5fX3NwbGl0VmFsdWVzLnB1c2godmFsKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHsgVmVydGV4QXR0cmlidXRlIH1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4uLy4uL01hdGgvVmVjMydcclxuaW1wb3J0IHsgQmFzZUdlb20gfSBmcm9tICcuL0Jhc2VHZW9tLmpzJ1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGUgfSBmcm9tICcuL0F0dHJpYnV0ZS5qcydcclxuXHJcbmltcG9ydCB7IFZlcnRleEF0dHJpYnV0ZSB9IGZyb20gJy4vVmVydGV4QXR0cmlidXRlLmpzJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vLi4vUmVnaXN0cnknXHJcblxyXG4vKipcclxuICogVGhlIE1lc2ggY2xhc3MgcHJvdmlkZXMgYSBmbGV4aWJsZSBhbmQgZmFzdCBwb2x5Z29uIG1lc2ggcmVwcmVzZW50YXRpb24uIEl0IHN1cHBvcnRzIHBvbHlnb25zIG9mIGFyYml0cmFyeSBjb21wbGV4aXR5LFxyXG4gKiBmcm9tIGJhc2ljIHRyaWFuZ2xlcyBhbmQgcXVhZHMgdG8gcGVudGFnb25zIG1vcmUuXHJcbiAqIEl0IHN1cHBvcnRzIHN0b3JpbmcgcGVyIGZhY2UgYXR0cmlidXRlcywgYW5kIHBlciBlZGdlIGF0dHJpYnV0ZXMuXHJcbiAqIFRoZSBNZXNoIGNsYXNzIGhhbmRsZXMgY29udmVydGluZyBpdHMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgcG9seWdvbnMgaW50byBhIHNpbXBsZXIgdHJpYW5nbGVzIHJlcHJlc2VudGF0aW9uIGZvciByZW5kZXJpbmcuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goKVxyXG4gKiBgYGBcclxuICpcclxuICogKipFdmVudHMqKlxyXG4gKiAqICoqZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIHRvcG9sb2d5IG9mIHRoZSBtZXNoIGhhcyBiZWVuIGNoYW5nZWQuXHJcbiAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoIGhhdmUgY2hhbmdlZCwgYnV0IG5vdCBuZWNlc3NhcmlseSB0aGUgdG9wb2xvZ3kuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEJhc2VHZW9tXHJcbiAqL1xyXG5jbGFzcyBNZXNoIGV4dGVuZHMgQmFzZUdlb20ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWVzaC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMuaW5pdCgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW5pdCBtZXRob2QuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBpbml0KCkge1xyXG4gICAgdGhpcy5fX2ZhY2VDb3VudHMgPSBbXVxyXG4gICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KClcclxuXHJcbiAgICB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcclxuICAgIHRoaXMuX19lZGdlQXR0cmlidXRlcyA9IG5ldyBNYXAoKVxyXG5cclxuICAgIHRoaXMuX19sb2dUb3BvbG9neVdhcm5pbmdzID0gZmFsc2VcclxuXHJcbiAgICB0aGlzLmVkZ2VWZXJ0cyA9IHVuZGVmaW5lZFxyXG4gICAgdGhpcy52ZXJ0ZXhFZGdlcyA9IHVuZGVmaW5lZFxyXG4gICAgdGhpcy5udW1FZGdlcyA9IDBcclxuICAgIHRoaXMuZWRnZUFuZ2xlcyA9IG5ldyBGbG9hdDMyQXJyYXkoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdldEZhY2VDb3VudHMgbWV0aG9kLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgZ2V0RmFjZUNvdW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZmFjZUNvdW50c1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdldE51bUZhY2VzIG1ldGhvZC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXROdW1GYWNlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZmFjZUNvdW50cy5sZW5ndGggPT0gMCA/IDAgOiB0aGlzLl9fZmFjZUNvdW50cy5yZWR1Y2UoKG51bUZhY2VzLCBmYykgPT4gKG51bUZhY2VzICs9IGZjKSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjbGVhciBtZXRob2QuXHJcbiAgICovXHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXMgPSB1bmRlZmluZWRcclxuICAgIHRoaXMuX19mYWNlQ291bnRzID0gW11cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIG51bWJlciBvZiBmYWNlcyBvbiB0aGUgbWVzaCB1c2luZyBhbiBhcnJheSBzcGVjaWZ5aW5nIHRoZSBjb3VudHMgcGVyIHBvbHlnb24gc2l6ZS5cclxuICAgKiBUaGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLCB0aGUgc2Vjb25kLCB0aGUgbnVtYmVyIG9mIHF1YWRzLCB0aGUgM3JkLCB0aGUgbnVtYmVyIG8gZjUgc2lkZWQgcG9seWdvbnMgZXRjLi5cclxuICAgKiBlLmcuIHRvIHNwZWNpZnkgMiB0cmlhbmdsZXMsIGFuZCA3IHF1YWRzLCB3ZSB3b3VsZCBwYXNzIFsyLCA3XVxyXG4gICAqIEBwYXJhbSB7YXJyYXl9IGZhY2VDb3VudHMgLSBUaGUgZmFjZUNvdW50cyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRGYWNlQ291bnRzKGZhY2VDb3VudHMpIHtcclxuICAgIGxldCBudW1GYWNlcyA9IDBcclxuICAgIGxldCBudW1GYWNlc1ZlcnRpY2VzID0gMFxyXG4gICAgbGV0IG51bVZlcnRzUGVyRmFjZSA9IDNcclxuICAgIGZvciAoY29uc3QgZmMgb2YgZmFjZUNvdW50cykge1xyXG4gICAgICBudW1GYWNlcyArPSBmY1xyXG4gICAgICBudW1GYWNlc1ZlcnRpY2VzICs9IGZjICogbnVtVmVydHNQZXJGYWNlXHJcbiAgICAgIG51bVZlcnRzUGVyRmFjZSsrXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJldk51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpXHJcbiAgICBpZiAocHJldk51bUZhY2VzID09IDApIHtcclxuICAgICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG51bUZhY2VzVmVydGljZXMpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBmYWNlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShudW1GYWNlc1ZlcnRpY2VzKVxyXG5cclxuICAgICAgLy8gTm93IHdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBpbmRpY2VzIGlmIHRoZXkgZml0IHdpdGhpbiB0aGUgbmV3IGZhY2VWZXJ0ZXhJbmRpY2VzIGFycmF5LlxyXG4gICAgICBsZXQgc3RhcnRTcmMgPSAwXHJcbiAgICAgIGxldCBzdGFydFRndCA9IDBcclxuICAgICAgbnVtRmFjZXNWZXJ0aWNlcyA9IDBcclxuICAgICAgbnVtVmVydHNQZXJGYWNlID0gM1xyXG4gICAgICBmYWNlQ291bnRzLmZvckVhY2goKGZjLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVuZFNyYyA9IHN0YXJ0U3JjICsgTWF0aC5taW4oZmMsIHRoaXMuX19mYWNlQ291bnRzW2luZGV4XSkgKiBudW1WZXJ0c1BlckZhY2VcclxuICAgICAgICBmYWNlVmVydGV4SW5kaWNlcy5zZXQodGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzLnNsaWNlKHN0YXJ0U3JjLCBlbmRTcmMpLCBzdGFydFRndClcclxuICAgICAgICBzdGFydFNyYyArPSB0aGlzLl9fZmFjZUNvdW50c1tpbmRleF0gKiBudW1WZXJ0c1BlckZhY2VcclxuICAgICAgICBzdGFydFRndCArPSBmYyAqIG51bVZlcnRzUGVyRmFjZVxyXG4gICAgICAgIG51bVZlcnRzUGVyRmFjZSsrXHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcyA9IGZhY2VWZXJ0ZXhJbmRpY2VzXHJcbiAgICB9XHJcbiAgICB0aGlzLl9fZmFjZUNvdW50cyA9IGZhY2VDb3VudHNcclxuXHJcbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgdGhpcy5fX2ZhY2VBdHRyaWJ1dGVzKSBhdHRyLnJlc2l6ZShudW1GYWNlcylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbmRleGVkIGJ5IHRoaXMgZmFjZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpIHtcclxuICAgIGxldCBpZHggPSAwXHJcbiAgICBsZXQgY291bnQgPSAwXHJcbiAgICB0aGlzLl9fZmFjZUNvdW50cy5zb21lKChmYywgaW5kZXgpID0+IHtcclxuICAgICAgaWR4ICs9IGZjXHJcbiAgICAgIGlmIChpZHggPiBmYWNlSW5kZXgpIHtcclxuICAgICAgICBjb3VudCA9IGluZGV4ICsgM1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gY291bnRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgZmFjZSBpbmRpY2VzIHdpdGhpbiB0aGUgZW50aXJlIGluZGV4IGFycmF5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KSB7XHJcbiAgICBsZXQgaWR4ID0gMFxyXG4gICAgbGV0IG9mZnNldCA9IDBcclxuICAgIHRoaXMuX19mYWNlQ291bnRzLnNvbWUoKGZjLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoaWR4ICsgZmMgPiBmYWNlSW5kZXgpIHtcclxuICAgICAgICBvZmZzZXQgKz0gKGZhY2VJbmRleCAtIGlkeCkgKiAoaW5kZXggKyAzKVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgIH1cclxuICAgICAgaWR4ICs9IGZjXHJcbiAgICAgIG9mZnNldCArPSBmYyAqIChpbmRleCArIDMpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIG9mZnNldFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNldEZhY2VWZXJ0ZXhJbmRpY2VzIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjZUluZGV4IC0gVGhlIGZhY2VJbmRleCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge2FycmF5fSB2ZXJ0ZXhJbmRpY2VzIC0gVGhlIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGZvciB0aGlzIGZhY2UgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRpY2VzKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCBpbnRlcmZhY2UuIFBsZWFzZSBwYXNzIHZlcnRleEluZGljZXMgYXMgYW4gYXJyYXlgKVxyXG4gICAgICB2ZXJ0ZXhJbmRpY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgfVxyXG4gICAgY29uc3QgZmFjZVZlcnRleENvdW50ID0gdGhpcy5nZXRGYWNlVmVydGV4Q291bnQoZmFjZUluZGV4KVxyXG4gICAgaWYgKHZlcnRleEluZGljZXMubGVuZ3RoICE9IGZhY2VWZXJ0ZXhDb3VudCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYEludmFsaWQgaW5kaWNlcyBmb3IgZmFjZToke2ZhY2VJbmRleH0gdmVydGV4SW5kaWNlczoke3ZlcnRleEluZGljZXN9LiBFeHBlY3RlZCAke2ZhY2VWZXJ0ZXhDb3VudH0gaW5kaWNlc2BcclxuICAgICAgKVxyXG4gICAgfVxyXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5nZXRGYWNlVmVydGV4T2Zmc2V0KGZhY2VJbmRleClcclxuICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcy5zZXQodmVydGV4SW5kaWNlcywgb2Zmc2V0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5ldyBmYWNlIHRvIHRoZSBtZXNoXHJcbiAgICogQHBhcmFtIHthcnJheX0gdmVydGV4SW5kaWNlcyAtIFRoZSB2ZXJ0ZXggaW5kaWNlcyBvZiB0aGUgZmFjZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBmYWNlIGluIHRoZSBtZXNoLlxyXG4gICAqL1xyXG4gIGFkZEZhY2UodmVydGV4SW5kaWNlcykge1xyXG4gICAgY29uc3QgZmFjZUNvdW50cyA9IFsuLi50aGlzLl9fZmFjZUNvdW50c11cclxuICAgIGlmIChmYWNlQ291bnRzLmxlbmd0aCA8PSB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCAtIDMpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IGZhY2VDb3VudHMubGVuZ3RoOyBpIDwgdmVydGV4SW5kaWNlcy5sZW5ndGggLSAzOyBpKyspIGZhY2VDb3VudHNbaV0gPSAwXHJcbiAgICAgIGZhY2VDb3VudHNbdmVydGV4SW5kaWNlcy5sZW5ndGggLSAzXSA9IDFcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZhY2VDb3VudHNbdmVydGV4SW5kaWNlcy5sZW5ndGggLSAzXSsrXHJcbiAgICB9XHJcbiAgICB0aGlzLnNldEZhY2VDb3VudHMoZmFjZUNvdW50cylcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCBpbiB0aGUgZmFjZVZlcnRleEluZGljZXMgb2YgdGhpcyBuZXcgZmFjZS5cclxuICAgIGxldCBmYWNlSW5kZXggPSAwXHJcbiAgICBsZXQgb2Zmc2V0ID0gMFxyXG4gICAgdGhpcy5fX2ZhY2VDb3VudHMuc29tZSgoZmMsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmIChpbmRleCArIDMgPT0gdmVydGV4SW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICBmYWNlSW5kZXggKz0gZmMgLSAxXHJcbiAgICAgICAgb2Zmc2V0ICs9IChmYyAtIDEpICogKGluZGV4ICsgMylcclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICAgIGZhY2VJbmRleCArPSBmY1xyXG4gICAgICBvZmZzZXQgKz0gZmMgKiAoaW5kZXggKyAzKVxyXG4gICAgfSlcclxuICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcy5zZXQodmVydGV4SW5kaWNlcywgb2Zmc2V0KVxyXG4gICAgcmV0dXJuIGZhY2VJbmRleFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdmVydGV4IGluZGljZXMgb2YgdGhlIHNwZWNpZmllZCBmYWNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBmYWNlXHJcbiAgICogQHJldHVybiB7YXJyYXl9IC0gQW4gYXJyYXkgb2YgaW5kaWNlcyBpbnRvIHRoZSB2ZXJ0ZXggYXR0cmlidXRlc1xyXG4gICAqL1xyXG4gIGdldEZhY2VWZXJ0ZXhJbmRpY2VzKGZhY2VJbmRleCkge1xyXG4gICAgY29uc3QgdmVydGV4SW5kaWNlcyA9IFtdXHJcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KVxyXG4gICAgY29uc3QgY291bnQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgdmVydGV4SW5kaWNlcy5wdXNoKHRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1tvZmZzZXQgKyBpXSlcclxuICAgIH1cclxuICAgIHJldHVybiB2ZXJ0ZXhJbmRpY2VzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc2luZ2xlIHZlcnRleCBpbmRleCBmb3IgYSBnaXZlbiBmYWNlIGFuZCBmYWNldmVydGV4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWNldmVydGV4IC0gVGhlIGZhY2UgdmVydGV4IGlzIHRoZSBpbmRleCB3aXRoaW4gdGhlIGZhY2UuIFNvIHRoZSBmaXJzdCB2ZXJ0ZXggaW5kZXggaXMgMC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHZlcnRleCBpbmRleFxyXG4gICAqL1xyXG4gIGdldEZhY2VWZXJ0ZXhJbmRleChmYWNlSW5kZXgsIGZhY2V2ZXJ0ZXgpIHtcclxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0RmFjZVZlcnRleE9mZnNldChmYWNlSW5kZXgpXHJcbiAgICByZXR1cm4gdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW29mZnNldCArIGZhY2V2ZXJ0ZXhdXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBWZXJ0ZXggQXR0cmlidXRlc1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgYFZlcnRleEF0dHJpYnV0ZWAgdG8gdGhlIGdlb21ldHJ5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZSB0byBhZGQuXHJcbiAgICogQHBhcmFtIHtBdHRyVmFsdWV8bnVtYmVyfSBkYXRhVHlwZSAtIFRoZSBkYXRhVHlwZSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFNjYWxhclZhbHVlIC0gVGhlIGRlZmF1bHQgc2NhbGFyIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge1ZlcnRleEF0dHJpYnV0ZX0gLSBSZXR1cm5zIGEgdmVydGV4IGF0dHJpYnV0ZS5cclxuICAgKi9cclxuICBhZGRWZXJ0ZXhBdHRyaWJ1dGUobmFtZSwgZGF0YVR5cGUsIGRlZmF1bHRTY2FsYXJWYWx1ZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcbiAgICBjb25zdCBhdHRyID0gbmV3IFZlcnRleEF0dHJpYnV0ZSh0aGlzLCBkYXRhVHlwZSwgcG9zaXRpb25zICE9IHVuZGVmaW5lZCA/IHBvc2l0aW9ucy5sZW5ndGggOiAwLCBkZWZhdWx0U2NhbGFyVmFsdWUpXHJcbiAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cilcclxuICAgIHJldHVybiBhdHRyXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBGYWNlIEF0dHJpYnV0ZXNcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFkZEZhY2VBdHRyaWJ1dGUgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZhY2UgYXR0cmlidXRlIHRvIGFkZC5cclxuICAgKiBAcGFyYW0ge0F0dHJWYWx1ZXxudW1iZXJ9IGRhdGFUeXBlIC0gVGhlIGRhdGEgdHlwZS5cclxuICAgKiBAcGFyYW0ge251bWJlcnxUeXBlZEFycmF5fSBjb3VudCAtIFRoZSBjb3VudCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IC0gUmV0dXJucyBhIGZhY2UgYXR0cmlidXRlLlxyXG4gICAqL1xyXG4gIGFkZEZhY2VBdHRyaWJ1dGUobmFtZSwgZGF0YVR5cGUsIGNvdW50ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBhdHRyID0gbmV3IEF0dHJpYnV0ZShkYXRhVHlwZSwgY291bnQgIT0gdW5kZWZpbmVkID8gY291bnQgOiB0aGlzLmdldE51bUZhY2VzKCkpXHJcbiAgICB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpXHJcbiAgICByZXR1cm4gYXR0clxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGhhc0ZhY2VBdHRyaWJ1dGUgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZhY2UgYXR0cmlidXRlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBoYXNGYWNlQXR0cmlidXRlKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuaGFzKG5hbWUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2V0RmFjZUF0dHJpYnV0ZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZSBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldEZhY2VBdHRyaWJ1dGUobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19mYWNlQXR0cmlidXRlcy5nZXQobmFtZSlcclxuICB9XHJcblxyXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBFZGdlIEF0dHJpYnV0ZXNcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFkZEVkZ2VBdHRyaWJ1dGUgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVkZ2UgYXR0cmlidXRlIHQgb2FkZC5cclxuICAgKiBAcGFyYW0ge0F0dHJWYWx1ZXxudW1iZXJ9IGRhdGFUeXBlIC0gVGhlIGRhdGEgdHlwZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgZGVmYXVsdCBzY2FsYXIgdmFsdWUuXHJcbiAgICogQHJldHVybiB7QXR0cmlidXRlfSAtIFJldHVybnMgYW4gZWRnZSBhdHRyaWJ1dGUuXHJcbiAgICovXHJcbiAgYWRkRWRnZUF0dHJpYnV0ZShuYW1lLCBkYXRhVHlwZSwgY291bnQgPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IGF0dHIgPSBuZXcgQXR0cmlidXRlKGRhdGFUeXBlLCBjb3VudCAhPSB1bmRlZmluZWQgPyBjb3VudCA6IHRoaXMuZ2V0TnVtRWRnZXMoKSlcclxuICAgIHRoaXMuX19lZGdlQXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cilcclxuICAgIHJldHVybiBhdHRyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaGFzRWRnZUF0dHJpYnV0ZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGhhc0VkZ2VBdHRyaWJ1dGUobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5oYXMobmFtZSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBnZXRFZGdlQXR0cmlidXRlIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlZGdlIGF0dHJpYnV0ZS5cclxuICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZXRFZGdlQXR0cmlidXRlKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMuZ2V0KG5hbWUpXHJcbiAgfVxyXG5cclxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdlblRvcG9sb2d5SW5mbyBtZXRob2QuXHJcbiAgICovXHJcbiAgZ2VuVG9wb2xvZ3lJbmZvKCkge1xyXG4gICAgY29uc3QgY29ubmVjdGVkVmVydGljZXMgPSB7fSAvLyBhY2NlbGVyYXRpb24gc3RydWN0dXJlLlxyXG4gICAgdGhpcy52ZXJ0ZXhFZGdlcyA9IFtdIC8vIDJkIGFycmF5IG9mIHZlcnRleCB0byBlZGdlcy5cclxuICAgIC8vIHRoaXMudmVydGV4RmFjZXMgPSBbXTsgLy8gMmQgYXJyYXkgb2YgdmVydGV4IHRvIGZhY2VzLlxyXG4gICAgdGhpcy5lZGdlRmFjZXMgPSBbXSAvLyBmbGF0IGFycmF5IG9mIDIgZmFjZSBpbmRpY2VzIHBlciBlZGdlXHJcbiAgICB0aGlzLmVkZ2VWZXJ0cyA9IFtdIC8vIGZsYXQgYXJyYXkgb2YgMiB2ZXJ0IGluZGljZXMgcGVyIGVkZ2VcclxuICAgIHRoaXMuZmFjZUVkZ2VzID0gW10gLy8gdGhlIGVkZ2VzIGJvcmRlcmluZyBlYWNoIGZhY2UuXHJcbiAgICB0aGlzLm51bUVkZ2VzID0gMFxyXG5cclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnKVxyXG4gICAgY29uc3QgZ2V0RWRnZUluZGV4ID0gKHYwLCB2MSkgPT4ge1xyXG4gICAgICBsZXQgdG1wMCA9IHYwXHJcbiAgICAgIGxldCB0bXAxID0gdjFcclxuICAgICAgaWYgKHRtcDEgPCB0bXAwKSB7XHJcbiAgICAgICAgY29uc3QgdG1wID0gdG1wMFxyXG4gICAgICAgIHRtcDAgPSB0bXAxXHJcbiAgICAgICAgdG1wMSA9IHRtcFxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGtleSA9IHRtcDAgKyAnPicgKyB0bXAxXHJcbiAgICAgIGlmIChrZXkgaW4gY29ubmVjdGVkVmVydGljZXMpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhrZXkgKyAnOicgKyBjb25uZWN0ZWRWZXJ0aWNlc1trZXldICsgXCIgZmFjZTpcIiArICggdjAgPCB2MSA/IDAgOiAxKSApO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0ZWRWZXJ0aWNlc1trZXldXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHAwID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKHRtcDApXHJcbiAgICAgIGNvbnN0IHAxID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKHRtcDEpXHJcbiAgICAgIGNvbnN0IGVkZ2VWZWMgPSBwMS5zdWJ0cmFjdChwMClcclxuXHJcbiAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IHRoaXMuZWRnZUZhY2VzLmxlbmd0aCAvIDJcclxuICAgICAgY29uc3QgZWRnZURhdGEgPSB7XHJcbiAgICAgICAgZWRnZUluZGV4OiBlZGdlSW5kZXgsXHJcbiAgICAgICAgZWRnZVZlYzogZWRnZVZlYyxcclxuICAgICAgfVxyXG4gICAgICBjb25uZWN0ZWRWZXJ0aWNlc1trZXldID0gZWRnZURhdGFcclxuXHJcbiAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpXHJcbiAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpXHJcbiAgICAgIHRoaXMuZWRnZVZlcnRzLnB1c2godG1wMClcclxuICAgICAgdGhpcy5lZGdlVmVydHMucHVzaCh0bXAxKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhrZXkgKyAnOicgKyBjb25uZWN0ZWRWZXJ0aWNlc1trZXldICsgXCIgZmFjZTpcIiArICggdjAgPCB2MSA/IDAgOiAxKSk7XHJcblxyXG4gICAgICB0aGlzLm51bUVkZ2VzKytcclxuICAgICAgcmV0dXJuIGVkZ2VEYXRhXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkRWRnZSA9ICh2MCwgdjEsIGZhY2VJbmRleCkgPT4ge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZygnYWRkRWRnZTonICsgdjAgKyBcIiA6XCIgKyB2MSArIFwiIGZhY2VJbmRleDpcIiArIGZhY2VJbmRleCApO1xyXG4gICAgICBjb25zdCBlZGdlRGF0YSA9IGdldEVkZ2VJbmRleCh2MCwgdjEpXHJcbiAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IGVkZ2VEYXRhLmVkZ2VJbmRleFxyXG4gICAgICBpZiAodjEgPCB2MCkge1xyXG4gICAgICAgIGNvbnN0IGVkZ2VGYWNlSW5kZXggPSBlZGdlSW5kZXggKiAyICsgMFxyXG4gICAgICAgIGlmICh0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyAmJiB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSAhPSAtMSlcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRWRnZSBwb2x5IDAgYWxyZWFkeSBzZXQuIE1lc2ggaXMgbm9uLW1hbmlmb2xkLicpXHJcbiAgICAgICAgdGhpcy5lZGdlRmFjZXNbZWRnZUZhY2VJbmRleF0gPSBmYWNlSW5kZXhcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBlZGdlRmFjZUluZGV4ID0gZWRnZUluZGV4ICogMiArIDFcclxuICAgICAgICBpZiAodGhpcy5fX2xvZ1RvcG9sb2d5V2FybmluZ3MgJiYgdGhpcy5lZGdlRmFjZXNbZWRnZUZhY2VJbmRleF0gIT0gLTEpXHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0VkZ2UgcG9seSAxIGFscmVhZHkgc2V0LiBNZXNoIGlzIG5vbi1tYW5pZm9sZC4nKVxyXG4gICAgICAgIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdID0gZmFjZUluZGV4XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGZhY2VJbmRleCBpbiB0aGlzLmZhY2VFZGdlcykpIHRoaXMuZmFjZUVkZ2VzW2ZhY2VJbmRleF0gPSBbXVxyXG4gICAgICB0aGlzLmZhY2VFZGdlc1tmYWNlSW5kZXhdLnB1c2goZWRnZUluZGV4KVxyXG5cclxuICAgICAgLy8gUHVzaCB0aGUgZWRnZSBpbmRleCBvbnRvIGJvdGggdmVydGV4IGVkZ2UgbGlzdHMuXHJcbiAgICAgIC8vIFdlIHVzZSBTZXRzIHRvIGF2b2lkIGFkZGluZyB0aGUgc2FtZSBlZGdlIDJ4IHRvIHRoZSBzYW1lIHZlcnRleC5cclxuICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbdjBdID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4RWRnZXNbdjBdID0gbmV3IFNldCgpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbdjFdID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4RWRnZXNbdjFdID0gbmV3IFNldCgpXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MF0uYWRkKGVkZ2VJbmRleClcclxuICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MV0uYWRkKGVkZ2VJbmRleClcclxuXHJcbiAgICAgIC8vIGlmICh0aGlzLnZlcnRleEZhY2VzW3YwXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gICAgIHRoaXMudmVydGV4RmFjZXNbdjBdID0gW107XHJcbiAgICAgIC8vIH1cclxuICAgICAgLy8gdGhpcy52ZXJ0ZXhGYWNlc1t2MF0ucHVzaChmYWNlSW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpXHJcbiAgICBmb3IgKGxldCBmYWNlSW5kZXggPSAwOyBmYWNlSW5kZXggPCBudW1GYWNlczsgZmFjZUluZGV4KyspIHtcclxuICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpXHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgdjAgPSBmYWNlVmVydHNbal1cclxuICAgICAgICBjb25zdCB2MSA9IGZhY2VWZXJ0c1soaiArIDEpICUgZmFjZVZlcnRzLmxlbmd0aF1cclxuICAgICAgICBhZGRFZGdlKHYwLCB2MSwgZmFjZUluZGV4KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlcyBhIG5vcm1hbCB2YWx1ZSBwZXIgZmFjZSBieSBhdmVyYWdpbmcgdGhlIHRyaWFuZ2xlIG5vcm1hbHMgb2YgdGhlIGZhY2UuXHJcbiAgICovXHJcbiAgY29tcHV0ZUZhY2VOb3JtYWxzKCkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcbiAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuYWRkRmFjZUF0dHJpYnV0ZSgnbm9ybWFscycsIFZlYzMpXHJcbiAgICBjb25zdCBudW1GYWNlcyA9IHRoaXMuZ2V0TnVtRmFjZXMoKVxyXG4gICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGZhY2VWZXJ0cyA9IHRoaXMuZ2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4KVxyXG4gICAgICBjb25zdCBwMCA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZihmYWNlVmVydHNbMF0pXHJcbiAgICAgIGNvbnN0IHAxID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKGZhY2VWZXJ0c1sxXSlcclxuICAgICAgbGV0IHByZXYgPSBwMVxyXG4gICAgICBjb25zdCBmYWNlTm9ybWFsID0gbmV3IFZlYzMoKVxyXG4gICAgICBmb3IgKGxldCBqID0gMjsgaiA8IGZhY2VWZXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGNvbnN0IHBuID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKGZhY2VWZXJ0c1tqXSlcclxuICAgICAgICBjb25zdCB2MCA9IHByZXYuc3VidHJhY3QocDApXHJcbiAgICAgICAgY29uc3QgdjEgPSBwbi5zdWJ0cmFjdChwMClcclxuICAgICAgICBmYWNlTm9ybWFsLmFkZEluUGxhY2UodjAuY3Jvc3ModjEpLm5vcm1hbGl6ZSgpKVxyXG4gICAgICAgIHByZXYgPSBwblxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmYWNlTm9ybWFsLmxlbmd0aFNxdWFyZWQoKSA8IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIGdldHRpbmcgbWFueSBmYWNlcyB3aXRoIG5vIHN1cmZhY2UgYXJlYS5cclxuICAgICAgICAvLyBUaGlzIGlzIHNpbXBseSBhbiBhdXRob3JpbmcgaXNzdWUuXHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiSW52YWxpZCBNZXNoIHRvcG9sb2d5XCIpO1xyXG4gICAgICAgIC8vIGlmKGRlYnVnTWVzaCl7XHJcbiAgICAgICAgLy8gICAgIHByaW50ZihcIkZhY2UgcG9zaXRpb25zIGFyZSBjb2luY2lkZW50IGZhY2U6JWlcIiwgaSk7XHJcbiAgICAgICAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKVxyXG4gICAgICAgIC8vICAgICAgICAgcHJpbnRmKFwidjolaVwiLCB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbIG51bUZhY2VzVmVydGljZXMgKyAoaSpmYWNlVmVydHMubGVuZ3RoKSArIGogXSk7XHJcbiAgICAgICAgLy8gICAgIHByaW50ZihcIlxcblwiKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFjZU5vcm1hbHMuc2V0VmFsdWUoZmFjZUluZGV4LCBmYWNlTm9ybWFsLm5vcm1hbGl6ZSgpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBhbmdsZXMgYXQgZWFjaCBlZGdlIGJldHdlZW4gdGhlIGFkam9pbmluZyBmYWNlc1xyXG4gICAqL1xyXG4gIGNhbGN1bGF0ZUVkZ2VBbmdsZXMoKSB7XHJcbiAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlcyA9PSB1bmRlZmluZWQpIHRoaXMuZ2VuVG9wb2xvZ3lJbmZvKClcclxuXHJcbiAgICBpZiAoIXRoaXMuaGFzRmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpKSB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpXHJcblxyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcbiAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpXHJcbiAgICB0aGlzLmVkZ2VWZWNzID0gW11cclxuICAgIHRoaXMuZWRnZUFuZ2xlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1FZGdlcylcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlRmFjZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgY29uc3QgdjAgPSB0aGlzLmVkZ2VWZXJ0c1tpXVxyXG4gICAgICBjb25zdCB2MSA9IHRoaXMuZWRnZVZlcnRzW2kgKyAxXVxyXG4gICAgICBjb25zdCBlX3ZlYyA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZih2MSkuc3VidHJhY3QocG9zaXRpb25zLmdldFZhbHVlUmVmKHYwKSlcclxuICAgICAgZV92ZWMubm9ybWFsaXplSW5QbGFjZSgpXHJcbiAgICAgIHRoaXMuZWRnZVZlY3MucHVzaChlX3ZlYylcclxuXHJcbiAgICAgIGNvbnN0IHAwID0gdGhpcy5lZGdlRmFjZXNbaV1cclxuICAgICAgY29uc3QgcDEgPSB0aGlzLmVkZ2VGYWNlc1tpICsgMV1cclxuICAgICAgaWYgKHAwID09IC0xIHx8IHAxID09IC0xKSB7XHJcbiAgICAgICAgLy8gRmxhZyB0aGUgZWRnZSBhcyBhIGJvcmRlciBlZGdlLi4uLlxyXG4gICAgICAgIHRoaXMuZWRnZUFuZ2xlc1tpIC8gMl0gPSBNYXRoLlBJICogMi4wXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbjAgPSBmYWNlTm9ybWFscy5nZXRWYWx1ZVJlZihwMClcclxuICAgICAgY29uc3QgbjEgPSBmYWNlTm9ybWFscy5nZXRWYWx1ZVJlZihwMSlcclxuICAgICAgdGhpcy5lZGdlQW5nbGVzW2kgLyAyXSA9IG4wLmFuZ2xlVG8objEpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIHZlcnRleCBub3JtYWxzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYXJkQW5nbGUgLSBUaGUgaGFyZEFuZ2xlIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICogQHJldHVybiB7VmVydGV4QXR0cmlidXRlfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgY29tcHV0ZVZlcnRleE5vcm1hbHMoaGFyZEFuZ2xlID0gMS4wIC8qIHJhZGlhbnMgKi8pIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiY29tcHV0ZVZlcnRleE5vcm1hbHNcIik7XHJcblxyXG4gICAgdGhpcy5jYWxjdWxhdGVFZGdlQW5nbGVzKClcclxuXHJcbiAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpXHJcbiAgICBjb25zdCBub3JtYWxzQXR0ciA9IHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCdub3JtYWxzJywgVmVjMylcclxuXHJcbiAgICAvLyB0aGVzZSBtZXRob2RzIGFyZSBmYXN0ZXIgdmVyc2lvbnMgdGhhbiB1c2luZyB0aGUgbWV0aG9kc1xyXG4gICAgLy8gcHJvdmlkZWQgb24gdGhlIGF0dHJpYnV0ZXMuIFdlIGNhY2hlIHZhbHVlcyBhbmQgdXNlIGhhcmQgY29kZWQgY29uc3RhbnRzLlxyXG4gICAgY29uc3QgZmFjZU5vcm1hbHNCdWZmZXIgPSBmYWNlTm9ybWFscy5kYXRhLmJ1ZmZlclxyXG4gICAgY29uc3QgZ2V0RmFjZU5vcm1hbCA9IChpbmRleCkgPT4ge1xyXG4gICAgICByZXR1cm4gVmVjMy5jcmVhdGVGcm9tQnVmZmVyKGZhY2VOb3JtYWxzQnVmZmVyLCBpbmRleCAqIDMgKiA0KSAvLyAzIGNvbXBvbmVudHMgYXQgNCBieXRlcyBlYWNoLlxyXG4gICAgfVxyXG4gICAgY29uc3QgdmVydGV4Tm9ybWFsc0FycmF5ID0gbm9ybWFsc0F0dHIuZGF0YVxyXG4gICAgY29uc3Qgc2V0VmVydGV4Tm9ybWFsID0gKGluZGV4LCB2YWx1ZSkgPT4ge1xyXG4gICAgICB2ZXJ0ZXhOb3JtYWxzQXJyYXlbaW5kZXggKiAzICsgMF0gPSB2YWx1ZS54XHJcbiAgICAgIHZlcnRleE5vcm1hbHNBcnJheVtpbmRleCAqIDMgKyAxXSA9IHZhbHVlLnlcclxuICAgICAgdmVydGV4Tm9ybWFsc0FycmF5W2luZGV4ICogMyArIDJdID0gdmFsdWUuelxyXG4gICAgfVxyXG4gICAgY29uc3QgZ2V0Q29ubmVjdGVkRWRnZVZlY3MgPSAoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRleCkgPT4ge1xyXG4gICAgICBsZXQgZTBcclxuICAgICAgbGV0IGUxXHJcbiAgICAgIGNvbnN0IGZhY2VFZGdlcyA9IHRoaXMuZmFjZUVkZ2VzW2ZhY2VJbmRleF1cclxuICAgICAgZm9yIChjb25zdCBlIG9mIGZhY2VFZGdlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmVkZ2VWZXJ0c1tlICogMl0gPT0gdmVydGV4SW5kZXgpIHtcclxuICAgICAgICAgIGlmICghZTApIGUwID0gdGhpcy5lZGdlVmVjc1tlXVxyXG4gICAgICAgICAgZWxzZSBlMSA9IHRoaXMuZWRnZVZlY3NbZV1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWRnZVZlcnRzW2UgKiAyICsgMV0gPT0gdmVydGV4SW5kZXgpIHtcclxuICAgICAgICAgIGlmICghZTApIGUwID0gdGhpcy5lZGdlVmVjc1tlXVxyXG4gICAgICAgICAgZWxzZSBlMSA9IHRoaXMuZWRnZVZlY3NbZV1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtlMCwgZTFdXHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIC8vIElmIHRoaXMgZmFjZSBpbmRleGluZyBkb2Vzbid0IHN0YXJ0IGF0IDAsIHRoZW4gdGhlIHZlcnRleEVkZ2VzIGRvbid0IGVpdGhlci5cclxuICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbaV0gPT0gdW5kZWZpbmVkKSBjb250aW51ZVxyXG5cclxuICAgICAgY29uc3QgZWRnZXMgPSB0aGlzLnZlcnRleEVkZ2VzW2ldXHJcblxyXG4gICAgICAvLyBHcm91cHMgb2YgZmFjZXMgaGF2aW5nIGEgc21vb3RoIG5vcm1hbCBhdCB0aGUgY3VycmVudCB2ZXJ0ZXguXHJcbiAgICAgIGNvbnN0IGZhY2VHcm91cHMgPSBbXVxyXG4gICAgICBjb25zdCBhZGRGYWNlVG9Hcm91cCA9IChmYWNlKSA9PiB7XHJcbiAgICAgICAgbGV0IGluR3JvdXAgPSBmYWxzZVxyXG4gICAgICAgIGZvciAoY29uc3QgZmFjZUdyb3VwIG9mIGZhY2VHcm91cHMpIHtcclxuICAgICAgICAgIGluR3JvdXAgPSBmYWNlR3JvdXAuaW5kZXhPZihmYWNlKSAhPSAtMVxyXG4gICAgICAgICAgaWYgKGluR3JvdXApIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW5Hcm91cCkgZmFjZUdyb3Vwcy5wdXNoKFtmYWNlXSlcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGUgb2YgZWRnZXMpIHtcclxuICAgICAgICBjb25zdCBmMCA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyXVxyXG4gICAgICAgIGNvbnN0IGYxID0gdGhpcy5lZGdlRmFjZXNbZSAqIDIgKyAxXVxyXG4gICAgICAgIGlmIChmMCAhPSAtMSAmJiBmMSA9PSAtMSAmJiB0aGlzLmVkZ2VBbmdsZXNbZV0gPCBoYXJkQW5nbGUpIHtcclxuICAgICAgICAgIGxldCBmMGdyb3VwSW5kZXggPSAtMVxyXG4gICAgICAgICAgbGV0IGYxZ3JvdXBJbmRleCA9IC0xXHJcbiAgICAgICAgICBmb3IgKGxldCBncm91cEluZGV4ID0gMDsgZ3JvdXBJbmRleCA8IGZhY2VHcm91cHMubGVuZ3RoOyBncm91cEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSAmJiBmYWNlR3JvdXBzW2dyb3VwSW5kZXhdLmluZGV4T2YoZjApICE9IC0xKSBmMGdyb3VwSW5kZXggPSBncm91cEluZGV4XHJcbiAgICAgICAgICAgIGlmIChmMWdyb3VwSW5kZXggPT0gLTEgJiYgZmFjZUdyb3Vwc1tncm91cEluZGV4XS5pbmRleE9mKGYxKSAhPSAtMSkgZjFncm91cEluZGV4ID0gZ3JvdXBJbmRleFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSAmJiBmMWdyb3VwSW5kZXggPT0gLTEpIHtcclxuICAgICAgICAgICAgZmFjZUdyb3Vwcy5wdXNoKFtmMCwgZjFdKVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChmMGdyb3VwSW5kZXggIT0gLTEgJiYgZjFncm91cEluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggIT0gZjFncm91cEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIDIgZ3JvdXBzIHRoYXQgdGhlIHNtb290aCBlZGdlIGpvaW5zLlxyXG4gICAgICAgICAgICAgIGZhY2VHcm91cHNbZjBncm91cEluZGV4XSA9IGZhY2VHcm91cHNbZjBncm91cEluZGV4XS5jb25jYXQoZmFjZUdyb3Vwc1tmMWdyb3VwSW5kZXhdKVxyXG4gICAgICAgICAgICAgIGZhY2VHcm91cHMuc3BsaWNlKGYxZ3JvdXBJbmRleCwgMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgIGZhY2VHcm91cHNbZjFncm91cEluZGV4XS5wdXNoKGYwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmMWdyb3VwSW5kZXggPT0gLTEpIHtcclxuICAgICAgICAgICAgICBmYWNlR3JvdXBzW2YwZ3JvdXBJbmRleF0ucHVzaChmMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyBpcyBhIGhhcmQgZWRnZSBvciBhIGJvcmRlciBlZGdlLi4uIEFkZCBmYWNlcyBzZXBhcmF0ZWx5IGdyb3VwLlxyXG4gICAgICAgIGlmIChmMCAhPSAtMSkgYWRkRmFjZVRvR3JvdXAoZjApXHJcbiAgICAgICAgaWYgKGYxICE9IC0xKSBhZGRGYWNlVG9Hcm91cChmMSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU29ydCB0aGUgZ3JvdXBzIHRvIGhhdmUgdGhlIGJpZ2dlc3QgZ3JvdXAgZmlyc3QuXHJcbiAgICAgIGZhY2VHcm91cHMuc29ydCgoYSwgYikgPT4gKGEubGVuZ3RoIDwgYi5sZW5ndGggPyAxIDogYS5sZW5ndGggPiBiLmxlbmd0aCA/IC0xIDogMCkpXHJcblxyXG4gICAgICBsZXQgZmlyc3RWaXJ0ZXggPSB0cnVlXHJcbiAgICAgIGZvciAoY29uc3QgZmFjZUdyb3VwIG9mIGZhY2VHcm91cHMpIHtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjMygpXHJcbiAgICAgICAgZm9yIChjb25zdCBmYWNlSW5kZXggb2YgZmFjZUdyb3VwKSB7XHJcbiAgICAgICAgICBjb25zdCBmYWNlX2VkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZVZlY3MoZmFjZUluZGV4LCBpKVxyXG4gICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZmFjZV9lZGdlc1swXS5hbmdsZVRvKGZhY2VfZWRnZXNbMV0pXHJcbiAgICAgICAgICAvLyBpZiAoaSA9PSAxKVxyXG4gICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiRmFjZU5vcm1hbDpcIiArIGZhY2VJbmRleCArIFwiOlwiICsgZ2V0RmFjZU5vcm1hbChmYWNlSW5kZXgpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgbm9ybWFsLmFkZEluUGxhY2UoZ2V0RmFjZU5vcm1hbChmYWNlSW5kZXgpLnNjYWxlKHdlaWdodCkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemVJblBsYWNlKClcclxuICAgICAgICBpZiAoZmlyc3RWaXJ0ZXgpIHtcclxuICAgICAgICAgIHNldFZlcnRleE5vcm1hbChpLCBub3JtYWwpXHJcbiAgICAgICAgICBmaXJzdFZpcnRleCA9IGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5vcm1hbHNBdHRyLnNldFNwbGl0VmVydGV4VmFsdWVzKGksIGZhY2VHcm91cCwgbm9ybWFsKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxzQXR0clxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvbXB1dGVIYXJkRWRnZXNJbmRpY2VzIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFyZEFuZ2xlIC0gVGhlIGhhcmRBbmdsZSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgY29tcHV0ZUhhcmRFZGdlc0luZGljZXMoaGFyZEFuZ2xlID0gMS4wKSB7XHJcbiAgICBpZiAoIXRoaXMuZWRnZVZlcnRzKSB0aGlzLmNhbGN1bGF0ZUVkZ2VBbmdsZXMoKVxyXG5cclxuICAgIGNvbnN0IGhhcmRFZGdlcyA9IFtdXHJcbiAgICBjb25zdCBhZGRFZGdlID0gKGluZGV4KSA9PiB7XHJcbiAgICAgIGhhcmRFZGdlcy5wdXNoKHRoaXMuZWRnZVZlcnRzW2luZGV4XSlcclxuICAgICAgaGFyZEVkZ2VzLnB1c2godGhpcy5lZGdlVmVydHNbaW5kZXggKyAxXSlcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGdlQW5nbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLmVkZ2VBbmdsZXNbaV0gPiBoYXJkQW5nbGUpIHtcclxuICAgICAgICBhZGRFZGdlKGkgKiAyKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVWludDMyQXJyYXkuZnJvbShoYXJkRWRnZXMpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2V0V2lyZWZyYW1lSW5kaWNlcyBtZXRob2QuXHJcbiAgICogQHJldHVybiB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBnZXRXaXJlZnJhbWVJbmRpY2VzKCkge1xyXG4gICAgY29uc29sZS53YXJuKCdAdG9kby1yZXZpZXcgLSBUaGlzIHJldHVybnMgbm90aGluZycpXHJcbiAgICByZXR1cm4gaW5kaWNlc1xyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFJlbmRlcmluZ1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2VuQnVmZmVycyBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBUaGUgb3B0cyB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBnZW5CdWZmZXJzKG9wdHMpIHtcclxuICAgIC8vIENvbXB1dGUgdGhlIG5vcm1hbHMgb24gZGVtYW5kLlxyXG4gICAgLy8gaWYgKCEoJ25vcm1hbHMnIGluIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSkge1xyXG4gICAgLy8gICAgIC8vIHRoaXMuX19nZW9tLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcbiAgICAvLyAgICAgdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoXCJub3JtYWxzXCIsIFZlYzMsIDAuMCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgY29uc3Qgc3BsaXRJbmRpY2VzID0ge31cclxuICAgIGxldCBzcGxpdENvdW50ID0gMFxyXG4gICAgZm9yIChjb25zdCBbLCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykge1xyXG4gICAgICBjb25zdCBhdHRyU3BsaXRzID0gYXR0ci5nZXRTcGxpdHMoKVxyXG4gICAgICBmb3IgKGNvbnN0IHBvbHlnb24gaW4gYXR0clNwbGl0cykge1xyXG4gICAgICAgIGlmICghKHBvbHlnb24gaW4gc3BsaXRJbmRpY2VzKSkgc3BsaXRJbmRpY2VzW3BvbHlnb25dID0ge31cclxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGF0dHJTcGxpdHNbcG9seWdvbl1cclxuICAgICAgICBmb3IgKGNvbnN0IHYgaW4gdmVydGljZXMpIHtcclxuICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHBhcnNlSW50KHYpXHJcbiAgICAgICAgICBpZiAoISh2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzW3BvbHlnb25dKSkge1xyXG4gICAgICAgICAgICBzcGxpdEluZGljZXNbcG9seWdvbl1bdmVydGV4XSA9IHNwbGl0Q291bnRcclxuICAgICAgICAgICAgc3BsaXRDb3VudCsrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycpXHJcbiAgICBjb25zdCBudW1VblNwbGl0VmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoXHJcbiAgICBjb25zdCB0b3RhbE51bVZlcnRpY2VzID0gbnVtVW5TcGxpdFZlcnRpY2VzICsgc3BsaXRDb3VudFxyXG5cclxuICAgIGxldCBpbmRpY2VzXHJcbiAgICBpZiAoIW9wdHMgfHwgb3B0cy5pbmNsdWRlSW5kaWNlcyAhPSBmYWxzZSkge1xyXG4gICAgICBpbmRpY2VzID0gdGhpcy5nZW5lcmF0ZVRyaWFuZ3VsYXRlZEluZGljZXModG90YWxOdW1WZXJ0aWNlcywgbnVtVW5TcGxpdFZlcnRpY2VzLCBzcGxpdEluZGljZXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gbGV0IG1heEluZGV4O1xyXG4gICAgLy8gaWYgKGRlYnVnQXR0clZhbHVlcylcclxuICAgIC8vICAgICBtYXhJbmRleCA9IE1hdGgubWF4KC4uLmluZGljZXMpO1xyXG4gICAgY29uc3QgYXR0ckJ1ZmZlcnMgPSB7fVxyXG4gICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIGF0dHJdIG9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGxldCB2YWx1ZXNcclxuICAgICAgaWYgKHNwbGl0Q291bnQgPT0gMCkgdmFsdWVzID0gYXR0ci5kYXRhXHJcbiAgICAgIGVsc2UgdmFsdWVzID0gYXR0ci5nZW5lcmF0ZVNwbGl0VmFsdWVzKHNwbGl0SW5kaWNlcywgc3BsaXRDb3VudClcclxuXHJcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGF0dHIubnVtRWxlbWVudHNcclxuICAgICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoIC8gZGltZW5zaW9uXHJcblxyXG4gICAgICAvLyBpZiAoZGVidWdBdHRyVmFsdWVzKSB7XHJcbiAgICAgIC8vICAgICBpZiAoY291bnQgPD0gbWF4SW5kZXgpXHJcbiAgICAgIC8vICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBpbmRleGluZy4gQXR0ciB2YWx1ZSBpcyBpbnN1ZmZpY2llbnQgZm9yIGluZGV4aW5nOlwiICsgYXR0ck5hbWUgKyBcIi4gTWF4IEluZGV4OlwiICsgbWF4SW5kZXggKyBcIiBBdHRyIFNpemU6XCIgKyBjb3VudCk7XHJcbiAgICAgIC8vIH1cclxuXHJcbiAgICAgIGF0dHJCdWZmZXJzW2F0dHJOYW1lXSA9IHtcclxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcclxuICAgICAgICBjb3VudDogY291bnQsXHJcbiAgICAgICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXHJcbiAgICAgICAgbm9ybWFsaXplZDogYXR0ck5hbWUgPT0gJ25vcm1hbHMnLFxyXG4gICAgICAgIGRhdGFUeXBlOiBhdHRyLmRhdGFUeXBlLFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICBudW1WZXJ0aWNlczogdGhpcy5udW1WZXJ0aWNlcygpLFxyXG4gICAgICBudW1SZW5kZXJWZXJ0czogdG90YWxOdW1WZXJ0aWNlcyxcclxuICAgICAgaW5kaWNlcyxcclxuICAgICAgYXR0ckJ1ZmZlcnMsXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5pbmNsdWRlVmVydGV4TmVpZ2hib3JzKSB7XHJcbiAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzID09IHVuZGVmaW5lZCkgdGhpcy5nZW5Ub3BvbG9neUluZm8oKVxyXG5cclxuICAgICAgbGV0IGNvdW50ID0gMFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBJZiB0aGlzIGZhY2UgaW5kZXhpbmcgZG9lc24ndCBzdGFydCBhdCAwLCB0aGVuIHRoZSB2ZXJ0ZXhFZGdlcyBkb24ndCBlaXRoZXIuXHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbaV0pIGNvdW50ICs9IHRoaXMudmVydGV4RWRnZXNbaV0uc2l6ZVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFRoZSBhcnJheSB3aWxsIGJlIHN0cnVjdHVyZWQgYXMgYSBzdGFydCtvZmZzZXQgZm9yIGVhY2ggdmVydGV4LCBmb2xsb3dlZFxyXG4gICAgICAvLyBieSBhIDJkIGFycmF5IG9mIG5laWdoYm9yIGluZGljZXMuXHJcbiAgICAgIGNvbnN0IHZlcnRleE5laWdoYm9ycyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aCAqIDIgKyBjb3VudClcclxuXHJcbiAgICAgIGNvbnN0IHNvcnRGYW5FZGdlcyA9IChmYW5FZGdlcykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFuRWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IGZlQSA9IGZhbkVkZ2VzW2ldXHJcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBmZUIgPSBmYW5FZGdlc1tqXVxyXG4gICAgICAgICAgICBpZiAoZmVBWzBdICE9IC0xICYmIGZlQVswXSA9PSBmZUJbMV0pIHtcclxuICAgICAgICAgICAgICAvLyAgbW92ZSBmZUEgYWZ0ZXIgZmVCO1xyXG4gICAgICAgICAgICAgIGlmIChpICE9IGogKyAxKSB7XHJcbiAgICAgICAgICAgICAgICBmYW5FZGdlcy5zcGxpY2UoaSwgMSlcclxuICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqICsgMSwgMCwgZmVBKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmZUFbMV0gIT0gLTEgJiYgZmVBWzFdID09IGZlQlswXSkge1xyXG4gICAgICAgICAgICAgIC8vICBtb3ZlIGZlQSBiZWZvcmUgZmVCO1xyXG4gICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShpLCAxKVxyXG4gICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqLCAwLCBmZUEpXHJcbiAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2hlY2tGYW5FZGdlcyA9IChmYW5FZGdlcykgPT4ge1xyXG4gICAgICAgIC8vIG5vdyBjaGVjayB0aGF0IHRoZSBmYWNlcyBhbGwgYnVpbGQgYSBmYW4uIE1heWJlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgd2l0aCAtMVxyXG4gICAgICAgIGlmIChmYW5FZGdlc1swXVswXSA9PSAtMSB8fCBmYW5FZGdlc1tmYW5FZGdlcy5sZW5ndGggLSAxXVsxXSA9PSAtMSkge1xyXG4gICAgICAgICAgaWYgKGZhbkVkZ2VzWzBdWzBdICE9IC0xIHx8IGZhbkVkZ2VzW2ZhbkVkZ2VzLmxlbmd0aCAtIDFdWzFdICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgZmFuIHN0YXJ0cyB3aXRoIC0xLCBpdCBtdXN0IGFsc28gZW5kIHdpdGggLTEnKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhbkVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBmZSA9IGZhbkVkZ2VzW2ldXHJcbiAgICAgICAgICBpZiAoZmVbMF0gPT0gLTEgfHwgZmVbMV0gPT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKGkgIT0gMCAmJiBpICE9IGZhbkVkZ2VzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy0xIG9ubHkgYWxsb3dlZCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBmYW4uJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGZlWzBdICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2ID0gaSAtIDFcclxuICAgICAgICAgICAgaWYgKHByZXYgPCAwKSBwcmV2ICs9IGZhbkVkZ2VzLmxlbmd0aFxyXG4gICAgICAgICAgICBpZiAoZmVbMF0gIT0gZmFuRWRnZXNbcHJldl1bMV0pIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhY2VzIGFyZSBub3Qgc2VxdWVudGlhbCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChmZVsxXSAhPSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIGZhbkVkZ2VzLmxlbmd0aFxyXG4gICAgICAgICAgICBpZiAoZmVbMV0gIT0gZmFuRWRnZXNbbmV4dF1bMF0pIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhY2VzIGFyZSBub3Qgc2VxdWVudGlhbCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBvcHVsYXRlIHRoZSBzdGFydCBhbmQgb2Zmc2V0IHZhbHVlcy5cclxuICAgICAgbGV0IG9mZnNldCA9IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoICogMlxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1tpXSA9PSB1bmRlZmluZWQpIGNvbnRpbnVlXHJcbiAgICAgICAgY29uc3QgZWRnZXMgPSB0aGlzLnZlcnRleEVkZ2VzW2ldXHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIGEgc29ydGVkIGxpc3Qgb2YgZmFjZXMgYmFzZWQgb24gYSBmYW4gYXJvdW5kXHJcbiAgICAgICAgLy8gdGhlIHZlcnRleC5cclxuICAgICAgICBjb25zdCBmYW5FZGdlcyA9IFtdXHJcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVkZ2VzKSB7XHJcbiAgICAgICAgICBjb25zdCB2MCA9IHRoaXMuZWRnZVZlcnRzW2UgKiAyXVxyXG4gICAgICAgICAgY29uc3QgdjEgPSB0aGlzLmVkZ2VWZXJ0c1tlICogMiArIDFdXHJcbiAgICAgICAgICBsZXQgZjAgPSB0aGlzLmVkZ2VGYWNlc1tlICogMl1cclxuICAgICAgICAgIGxldCBmMSA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyICsgMV1cclxuICAgICAgICAgIGxldCBuZWlnVmVydFxyXG4gICAgICAgICAgaWYgKHYwID09IGkpIHtcclxuICAgICAgICAgICAgbmVpZ1ZlcnQgPSB2MVxyXG4gICAgICAgICAgfSBlbHNlIGlmICh2MSA9PSBpKSB7XHJcbiAgICAgICAgICAgIG5laWdWZXJ0ID0gdjBcclxuICAgICAgICAgICAgLy8gc3dhcCB0aGUgZmFjZXNcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gZjBcclxuICAgICAgICAgICAgZjAgPSBmMVxyXG4gICAgICAgICAgICBmMSA9IHRtcFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcG9sb2d5JylcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZhbkVkZ2VzLnB1c2goW2YwLCBmMSwgbmVpZ1ZlcnRdKVxyXG4gICAgICAgIH1cclxuICAgICAgICBzb3J0RmFuRWRnZXMoZmFuRWRnZXMpXHJcbiAgICAgICAgY2hlY2tGYW5FZGdlcyhmYW5FZGdlcylcclxuICAgICAgICBjb25zdCBjbG9zZWQgPSBmYW5FZGdlc1swXVswXSAhPSAtMSB8fCBmYW5FZGdlc1tmYW5FZGdlcy5sZW5ndGggLSAxXVsxXSAhPSAtMVxyXG4gICAgICAgIGxldCBmbGFncyA9IDBcclxuICAgICAgICBpZiAoY2xvc2VkKSBmbGFncyArPSAxXHJcbiAgICAgICAgdmVydGV4TmVpZ2hib3JzW2kgKiAyXSA9IG9mZnNldFxyXG4gICAgICAgIHZlcnRleE5laWdoYm9yc1tpICogMiArIDFdID0gZWRnZXMuc2l6ZSArIChmbGFncyA8PCA4KVxyXG4gICAgICAgIGZvciAoY29uc3QgZmUgb2YgZmFuRWRnZXMpIHtcclxuICAgICAgICAgIHZlcnRleE5laWdoYm9yc1tvZmZzZXRdID0gZmVbMl1cclxuICAgICAgICAgIG9mZnNldCsrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHQudmVydGV4TmVpZ2hib3JzID0gdmVydGV4TmVpZ2hib3JzXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy4gRm9yIGhpZ2hlciBkZWdyZWUgcG9seWdvbnMsIHRoZXkgYXJlIGRpdmlkZWQgaW50byBtdWx0aXBsZSB0cmlhbmdsZXMgZm9yIHJlbmRlcmluZy5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cclxuICAgKi9cclxuICBjb21wdXRlTnVtVHJpYW5nbGVzKCkge1xyXG4gICAgbGV0IG51bVZlcnRzUGVyRmFjZSA9IDNcclxuICAgIGxldCB0cmlzQ291bnQgPSAwXHJcbiAgICBmb3IgKGNvbnN0IGZjIG9mIHRoaXMuX19mYWNlQ291bnRzKSB7XHJcbiAgICAgIHRyaXNDb3VudCArPSBmYyAqIChudW1WZXJ0c1BlckZhY2UgLSAyKVxyXG4gICAgICBudW1WZXJ0c1BlckZhY2UrK1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyaXNDb3VudFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG8gcHJlcGFyZSBkYXRhIGZvciByZW5kZXJpbmcsIHRoZSBpbmRpY2VzIGZvciB0aGUgcG9seWdvbnMgaXMgdXNlZCB0byBjb21wdXRlIGEgbmV3IGluZGV4IGJ1ZmZlciBiYXNlZCBvblxyXG4gICAqIG9ubHkgdHJpYW5nbGVzLiBUaGlzIGlzIHVzZWQgZHVyaW5nIHJlbmRlcmluZyBhbmQgdGhlIHJlc3VsdGluZyBpbmRpY2VzIHVwbG9hZGVkIG90IHRoZSBHUFUgIGJ5IEdMTWVzaCBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbE51bVZlcnRpY2VzIC0gVGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtVW5TcGxpdFZlcnRpY2VzIC0gVGhlIHRvdGFsIG51bWJlciBvZiB1bnNwbGl0IHZlcnRpY2VzLlxyXG4gICAqIEBwYXJhbSB7YXJyYXl9IHNwbGl0SW5kaWNlcyAtIFRoZSBzcGxpdEluZGljZXMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7VHlwZWRBcnJheX0gLSBSZXR1cmVzIGEgdHlwZWQgYXJyYXkgY29udGFpbmluZyB0aGUgdHJpYW5ndWxhdGVkIGluZGljZXMuXHJcbiAgICovXHJcbiAgZ2VuZXJhdGVUcmlhbmd1bGF0ZWRJbmRpY2VzKHRvdGFsTnVtVmVydGljZXMsIG51bVVuU3BsaXRWZXJ0aWNlcywgc3BsaXRJbmRpY2VzKSB7XHJcbiAgICBjb25zdCB0cmlzQ291bnQgPSB0aGlzLmNvbXB1dGVOdW1UcmlhbmdsZXMoKVxyXG5cclxuICAgIGxldCB0cmlhbmdsdWxhdGVkSW5kaWNlc1xyXG4gICAgaWYgKHRvdGFsTnVtVmVydGljZXMgPCBNYXRoLnBvdygyLCA4KSkgdHJpYW5nbHVsYXRlZEluZGljZXMgPSBuZXcgVWludDhBcnJheSh0cmlzQ291bnQgKiAzKVxyXG4gICAgZWxzZSBpZiAodG90YWxOdW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkgdHJpYW5nbHVsYXRlZEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodHJpc0NvdW50ICogMylcclxuICAgIGVsc2UgdHJpYW5nbHVsYXRlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkodHJpc0NvdW50ICogMylcclxuXHJcbiAgICBsZXQgdHJpYW5nbGVWZXJ0ZXggPSAwXHJcbiAgICBjb25zdCBhZGRUcmlhbmdsZVZlcnRleEluZGV4ID0gZnVuY3Rpb24gKHZlcnRleCwgZmFjZUluZGV4KSB7XHJcbiAgICAgIGlmICh2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzICYmIGZhY2VJbmRleCBpbiBzcGxpdEluZGljZXNbdmVydGV4XSlcclxuICAgICAgICB2ZXJ0ZXggPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdEluZGljZXNbdmVydGV4XVtmYWNlSW5kZXhdXHJcbiAgICAgIHRyaWFuZ2x1bGF0ZWRJbmRpY2VzW3RyaWFuZ2xlVmVydGV4XSA9IHZlcnRleFxyXG4gICAgICB0cmlhbmdsZVZlcnRleCsrXHJcbiAgICB9XHJcbiAgICBjb25zdCBudW1GYWNlcyA9IHRoaXMuZ2V0TnVtRmFjZXMoKVxyXG4gICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGZhY2VWZXJ0cyA9IHRoaXMuZ2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4KVxyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VWZXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChqID49IDMpIHtcclxuICAgICAgICAgIC8vIEZvciBlYWNoIGFkaXRpb25hbCB0cmlhbmdsZSwgd2UgaGF2ZSB0byBhZGQgMiBpbmRpY2VzLlxyXG4gICAgICAgICAgYWRkVHJpYW5nbGVWZXJ0ZXhJbmRleChmYWNlVmVydHNbMF0sIGZhY2VJbmRleClcclxuICAgICAgICAgIGFkZFRyaWFuZ2xlVmVydGV4SW5kZXgoZmFjZVZlcnRzW2ogLSAxXSwgZmFjZUluZGV4KVxyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRUcmlhbmdsZVZlcnRleEluZGV4KGZhY2VWZXJ0c1tqXSwgZmFjZUluZGV4KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJpYW5nbHVsYXRlZEluZGljZXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBmcmVlQnVmZmVycyBtZXRob2QuXHJcbiAgICovXHJcbiAgZnJlZUJ1ZmZlcnMoKSB7XHJcbiAgICBzdXBlci5mcmVlQnVmZmVycygpXHJcbiAgICB0aGlzLmluaXQoKVxyXG4gIH1cclxuXHJcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBlcnNpc3RlbmNlXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3RvcmVzIG1lc2ggcHJvcGVydGllcyBmcm9tIGEgYmluYXJ5IHJlYWRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHtcclxuICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIpXHJcbiAgICB0aGlzLnNldEZhY2VDb3VudHMocmVhZGVyLmxvYWRVSW50MzJBcnJheSgpKVxyXG5cclxuICAgIC8vIE5vdGU6IHdlIGNhbiByZW1vdmUgdGhpcy4gV2UgY2FuIGluZmVyIHRoaXMgZnJvbSB0aGUgYWJvdmUgZmFjZUNvdW50cyBhcnJheS5cclxuICAgIGNvbnN0IGZhY2VWZXJ0ZXhDb3VudHMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkodGhpcy5nZXROdW1GYWNlcygpKVxyXG4gICAgY29uc3Qgb2Zmc2V0UmFuZ2UgPSByZWFkZXIubG9hZFNJbnQzMlZlYzIoKVxyXG4gICAgY29uc3QgYnl0ZXMgPSByZWFkZXIubG9hZFVJbnQ4KClcclxuICAgIGxldCBmYWNlVmVydGV4SW5kZXhEZWx0YXNcclxuICAgIGlmIChieXRlcyA9PSAxKSBmYWNlVmVydGV4SW5kZXhEZWx0YXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKVxyXG4gICAgZWxzZSBpZiAoYnl0ZXMgPT0gMikgZmFjZVZlcnRleEluZGV4RGVsdGFzID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheSgpXHJcbiAgICBlbHNlIGlmIChieXRlcyA9PSA0KSBmYWNlVmVydGV4SW5kZXhEZWx0YXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KClcclxuXHJcbiAgICBjb25zdCBudW1GYWNlcyA9IHRoaXMuZ2V0TnVtRmFjZXMoKVxyXG4gICAgbGV0IG9mZnNldCA9IDBcclxuICAgIGxldCBwcmV2Q291bnQgPSAwXHJcbiAgICBsZXQgZmFjZU9mZnNldHMgPSBbXVxyXG4gICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRGYWNlVmVydGV4Q291bnQoZmFjZUluZGV4KVxyXG4gICAgICBmYWNlT2Zmc2V0c1tmYWNlSW5kZXhdID0gb2Zmc2V0XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykge1xyXG4gICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXggPSBvZmZzZXQgKyBqXHJcbiAgICAgICAgY29uc3QgZGVsdGEgPSBmYWNlVmVydGV4SW5kZXhEZWx0YXNbZmFjZVZlcnRleF0gKyBvZmZzZXRSYW5nZS54XHJcbiAgICAgICAgaWYgKGZhY2VJbmRleCA9PSAwKSB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbZmFjZVZlcnRleF0gPSBkZWx0YVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbGV0IHByZXZGYWNlVmVydGV4ID0gZmFjZU9mZnNldHNbZmFjZUluZGV4IC0gMV1cclxuICAgICAgICAgIHByZXZGYWNlVmVydGV4ICs9IGogPCBwcmV2Q291bnQgPyBqIDogcHJldkNvdW50IC0gMVxyXG4gICAgICAgICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW2ZhY2VWZXJ0ZXhdID0gdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW3ByZXZGYWNlVmVydGV4XSArIGRlbHRhXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG9mZnNldCArPSBjb3VudFxyXG4gICAgICBwcmV2Q291bnQgPSBjb3VudFxyXG4gICAgfVxyXG4gICAgdGhpcy5fX251bVBvcHVsYXRlZEZhY2VWZXJ0ZXhJbmRpY2VzID0gb2Zmc2V0XHJcblxyXG4gICAgaWYgKCF0aGlzLmhhc1ZlcnRleEF0dHJpYnV0ZSgnbm9ybWFscycpKSB7XHJcbiAgICAgIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFDaGFuZ2VkJywge30pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIHRvSlNPTihjb250ZXh0KSB7XHJcbiAgICBjb25zdCBqID0gc3VwZXIudG9KU09OKGNvbnRleHQpXHJcbiAgICBqLmZhY2VDb3VudHMgPSBBcnJheS5mcm9tKHRoaXMuX19mYWNlQ291bnRzKVxyXG4gICAgai5mYWNlVmVydGV4SW5kaWNlcyA9IEFycmF5LmZyb20odGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzKVxyXG5cclxuICAgIHJldHVybiBqXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuXHJcbiAgICovXHJcbiAgZnJvbUpTT04oaiwgY29udGV4dCkge1xyXG4gICAgc3VwZXIuZnJvbUpTT04oaiwgY29udGV4dClcclxuICAgIGlmIChqLmZhY2VDb3VudHMpIHRoaXMuX19mYWNlQ291bnRzID0gai5mYWNlQ291bnRzXHJcbiAgICBpZiAoai5mYWNlVmVydGV4SW5kaWNlcykgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gVWludDMyQXJyYXkuZnJvbShqLmZhY2VWZXJ0ZXhJbmRpY2VzKVxyXG4gIH1cclxufVxyXG5cclxuUmVnaXN0cnkucmVnaXN0ZXIoJ01lc2gnLCBNZXNoKVxyXG5cclxuZXhwb3J0IHsgTWVzaCB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbmltcG9ydCB7IFZlYzIsIFZlYzMsIFF1YXQsIENvbG9yLCBCb3gyLCBCb3gzIH0gZnJvbSAnLi4vTWF0aC9pbmRleCdcclxuaW1wb3J0IE1hdGhGdW5jdGlvbnMgZnJvbSAnLi4vVXRpbGl0aWVzL01hdGhGdW5jdGlvbnMnXHJcblxyXG4vKipcclxuICogUmVhZHMgYmluYXJ5IGRhdGEgaW4gYSBzcGVjaWZpYyBlbmNvZGluZy4gVXNlZCBpbiBsb2FkaW5nIGJpbmFyeSBkYXRhIHN1Y2ggYXMgemNhZCBmaWxlcy5cclxuICovXHJcbmNsYXNzIEJpblJlYWRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgYmluIHJlYWRlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIC0gVGhlIGRhdGEgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IHZhbHVlIHRvIHN0YXJ0IHJlYWRpbmcgdGhlIGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTW9iaWxlRGV2aWNlIC0gVGhlIGlzTW9iaWxlRGV2aWNlIHZhbHVlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGJ5dGVPZmZzZXQgPSAwLCBpc01vYmlsZURldmljZSA9IHRydWUpIHtcclxuICAgIHRoaXMuX19kYXRhID0gZGF0YVxyXG4gICAgdGhpcy5fX2J5dGVPZmZzZXQgPSBieXRlT2Zmc2V0XHJcbiAgICB0aGlzLl9fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5fX2RhdGEpXHJcbiAgICB0aGlzLl9faXNNb2JpbGVEZXZpY2UgPSBpc01vYmlsZURldmljZVxyXG4gICAgdGhpcy51dGY4ZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHN0YXRlIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBgQmluUmVhZGVyYCBvYmplY3Qgd2FzIGluc3RhbmNpYXRlZCBmcm9tIGEgbW9iaWxlIGRldmljZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlzIGEgbW9iaWxlIGRldmljZSBpcyBkZXRlY3RlZC5cclxuICAgKi9cclxuICBnZXQgaXNNb2JpbGVEZXZpY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2lzTW9iaWxlRGV2aWNlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGJ1ZmZlciB3ZSdyZSByZWFkaW5nIGZyb20uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IC0gVGhlIGRhdGEgYnVmZmVyIHdlIGFyZSByZWFkaW5nIGZyb20sXHJcbiAgICovXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGJ1ZmZlclxyXG4gICAqL1xyXG4gIGdldCBieXRlTGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhVmlldy5ieXRlTGVuZ3RoXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHJlbWFpbmluZyBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byByZWFkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZWVtYWluaW5nIGxlbmd0aCBvZiB0aGUgYnVmZmVyIHRvIHJlYWQuXHJcbiAgICovXHJcbiAgZ2V0IHJlbWFpbmluZ0J5dGVMZW5ndGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2RhdGFWaWV3LmJ5dGVMZW5ndGggLSB0aGlzLl9fYnl0ZU9mZnNldFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGJ5dGUgb2Zmc2V0IGluIHRoZSBidWZmZXIuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgYmluYXJ5IGJ1ZmZlclxyXG4gICAqL1xyXG4gIHBvcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fYnl0ZU9mZnNldFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgYnl0ZSBvZmZzZXQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZU9mZnNldCBwYXJhbS5cclxuICAgKi9cclxuICBzZWVrKGJ5dGVPZmZzZXQpIHtcclxuICAgIHRoaXMuX19ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvZmZzZXQgYnl0ZXMgdG8gY3VycmVudCBvZmZzZXQgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIE9mZnNldCBhbW91bnQuXHJcbiAgICovXHJcbiAgYWR2YW5jZShieXRlT2Zmc2V0KSB7XHJcbiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBieXRlT2Zmc2V0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB1bnNpZ25lZCBVaW50OCB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLFxyXG4gICAqIGFuZCBhZGRzIG9uZSBieXRlIHRvIHRoZSBvZmZzZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkVUludDgoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fX2J5dGVPZmZzZXQpXHJcbiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAxXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB1bnNpZ25lZCBVaW50MTYgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbixcclxuICAgKiBhbmQgYWRkcyB0d28gYnl0ZXMgdG8gdGhlIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRVSW50MTYoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKVxyXG4gICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gMlxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdW5zaWduZWQgVWludDMyIHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sXHJcbiAgICogYW5kIGFkZHMgZm91ciBieXRlcyB0byB0aGUgb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZFVJbnQzMigpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpXHJcbiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzaWduZWQgSW50MzIgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbixcclxuICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkU0ludDMyKCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldEludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKVxyXG4gICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNFxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLFxyXG4gICAqIGFuZCBhZGRzIGZvdXIgYnl0ZXMgdG8gdGhlIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRGbG9hdDE2KCkge1xyXG4gICAgY29uc3QgdWludDE2ID0gdGhpcy5sb2FkVUludDE2KClcclxuICAgIHJldHVybiBNYXRoRnVuY3Rpb25zLmRlY29kZTE2Qml0RmxvYXQodWludDE2KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLFxyXG4gICAqIGFuZCBhZGRzIHR3byBieXRlcyB0byB0aGUgb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZFVGbG9hdDE2KCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5sb2FkRmxvYXQxNigpXHJcbiAgICBpZiAocmVzdWx0IDwgMC4wKSB7XHJcbiAgICAgIHJldHVybiAyMDQ4LjAgLSByZXN1bHQgLy8gTm90ZTogc3VidHJhY3QgYSBuZWdhdGl2ZSBudW1iZXIgdG8gYWRkIGl0LlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHNpbmdsZSBzaWduZWQgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uIGZyb20gMiB1bnNpZ25lZCBJbnQ4IHZhbHVlcyxcclxuICAgKiBhbmQgYWRkcyB0d28gYnl0ZXMgdG8gdGhlIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRGbG9hdDE2RnJvbTJ4VUludDgoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQxNih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSlcclxuICAgIC8vIGNvbnN0IHVpbnQ4cyA9IHRoaXMubG9hZFVJbnQ4QXJyYXkoMik7XHJcbiAgICAvLyByZXR1cm4gTWF0aC5kZWNvZGUxNkJpdEZsb2F0KHVpbnQ4cyk7XHJcbiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAyXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhbmQgcmV0dXJucyBhIHNpbmdsZSBTaWduZWQgaW50ZWdlciB2YWx1ZSBmcm9tIDIgVW5zaWduZWQgRmxvYXQxNiB2YWx1ZXMuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZFVJbnQzMkZyb20yeFVGbG9hdDE2KCkge1xyXG4gICAgY29uc3QgcGFydEEgPSB0aGlzLmxvYWRVRmxvYXQxNigpXHJcbiAgICBjb25zdCBwYXJ0QiA9IHRoaXMubG9hZFVGbG9hdDE2KClcclxuICAgIHJldHVybiBwYXJ0QSArIHBhcnRCICogNDA5NlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIHNpZ25lZCBGbG9hdDE2IHZhbHVlcy5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpIHtcclxuICAgIGNvbnN0IHBhcnRBID0gdGhpcy5sb2FkRmxvYXQxNigpXHJcbiAgICBjb25zdCBwYXJ0QiA9IHRoaXMubG9hZEZsb2F0MTYoKVxyXG4gICAgcmV0dXJuIHBhcnRBICsgcGFydEIgKiAyMDQ4XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBGbG9hdDMyIHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sXHJcbiAgICogYW5kIGFkZHMgZm91ciBieXRlcyB0byB0aGUgb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZEZsb2F0MzIoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSlcclxuICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDRcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGFuIHVuc2luZ2VkIEludDggYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUsXHJcbiAgICogc3RhcnRpbmcgZnJvbSBjdXJyZW50IGJ5dGUgb2Zmc2V0Ljxicj5cclxuICAgKiBCeXRlIG9mZnNldCBpcyBpbmNyZWFzZWQgYnkgdGhlIHNwZWNpZmllZCBieXRlIHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uXHJcbiAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRVSW50OEFycmF5KHNpemUgPSB1bmRlZmluZWQsIGNsb25lID0gZmFsc2UpIHtcclxuICAgIGlmIChzaXplID09IHVuZGVmaW5lZCkgc2l6ZSA9IHRoaXMubG9hZFVJbnQzMigpXHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIHNpemUpXHJcbiAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplXHJcbiAgICBjb25zdCBwYWRkID0gdGhpcy5fX2J5dGVPZmZzZXQgJSA0XHJcbiAgICAvLyB0aGlzLnJlYWRQYWRkKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhbiB1bnNpbmdlZCBJbnQxNiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSxcclxuICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuPGJyPlxyXG4gICAqIEJ5dGUgb2Zmc2V0IGlzIGluY3JlYXNlZCBieSB0aGUgc3BlY2lmaWVkIGJ5dGUgc2l6ZSB4IDIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uXHJcbiAgICogQHJldHVybiB7VWludDE2QXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkVUludDE2QXJyYXkoc2l6ZSA9IHVuZGVmaW5lZCwgY2xvbmUgPSBmYWxzZSkge1xyXG4gICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKSBzaXplID0gdGhpcy5sb2FkVUludDMyKClcclxuICAgIGlmIChzaXplID09IDApIHJldHVybiBuZXcgVWludDE2QXJyYXkoKVxyXG4gICAgdGhpcy5yZWFkUGFkZCgyKVxyXG4gICAgbGV0IHJlc3VsdFxyXG4gICAgaWYgKHRoaXMuX19pc01vYmlsZURldmljZSkge1xyXG4gICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSlcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKVxyXG4gICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDJcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19kYXRhLCB0aGlzLl9fYnl0ZU9mZnNldCwgc2l6ZSlcclxuICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZSAqIDJcclxuICAgIH1cclxuICAgIC8vIHRoaXMucmVhZFBhZGQoKTtcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGFuIHVuc2luZ2VkIEludDMyIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLFxyXG4gICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC48YnI+XHJcbiAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplIHggNC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgcGFyYW0uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS5cclxuICAgKiBAcmV0dXJuIHtVaW50MzJBcnJheX0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGxvYWRVSW50MzJBcnJheShzaXplID0gdW5kZWZpbmVkLCBjbG9uZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKVxyXG4gICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgpXHJcbiAgICB0aGlzLnJlYWRQYWRkKDQpXHJcbiAgICBsZXQgcmVzdWx0XHJcbiAgICBpZiAodGhpcy5fX2lzTW9iaWxlRGV2aWNlKSB7XHJcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheShzaXplKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpXHJcbiAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKVxyXG4gICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplICogNFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVhZHMgYnVmZmVyIGFuZCByZXR1cm4gYSBGbG9hdDMyIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLFxyXG4gICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC48YnI+XHJcbiAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplIHggNC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIHNpemUgcGFyYW0uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS5cclxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkRmxvYXQzMkFycmF5KHNpemUgPSB1bmRlZmluZWQsIGNsb25lID0gZmFsc2UpIHtcclxuICAgIGlmIChzaXplID09IHVuZGVmaW5lZCkgc2l6ZSA9IHRoaXMubG9hZFVJbnQzMigpXHJcbiAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgpXHJcbiAgICB0aGlzLnJlYWRQYWRkKDQpXHJcbiAgICBsZXQgcmVzdWx0XHJcbiAgICBpZiAodGhpcy5fX2lzTW9iaWxlRGV2aWNlKSB7XHJcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSlcclxuICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKVxyXG4gICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplICogNFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBuZXh0IHN0cmluZy5cclxuICAgKiBGaXJzdCBsb29rcyBmb3IgdGhlIHN0cmluZyBsZW5ndGggZGVzY3JpcHRpb24gaW4gdGhlIG5leHQgZm91ciBieXRlcyBpbiB0aGUgYnVmZmVyKFN0YXJ0aW5nIGZyb20gYnl0ZSBvZmZzZXQpLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICovXHJcbiAgbG9hZFN0cigpIHtcclxuICAgIGNvbnN0IG51bUNoYXJzID0gdGhpcy5sb2FkVUludDMyKClcclxuICAgIGNvbnN0IGNoYXJzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBudW1DaGFycylcclxuICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IG51bUNoYXJzXHJcbiAgICByZXR1cm4gdGhpcy51dGY4ZGVjb2Rlci5kZWNvZGUoY2hhcnMpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAgICogRmlyc3QgcmVhZGluZyB0aGUgc2l6ZSBvZiB0aGUgYXJyYXkgdGhlbiByZWFkaW5nIGVhY2ggc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXl9IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsb2FkU3RyQXJyYXkoKSB7XHJcbiAgICBjb25zdCBzaXplID0gdGhpcy5sb2FkVUludDMyKClcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICByZXN1bHRbaV0gPSB0aGlzLmxvYWRTdHIoKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gc2lnbmVkIEludDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgVmVjMi5cclxuICAgKi9cclxuICBsb2FkU0ludDMyVmVjMigpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLmxvYWRTSW50MzIoKVxyXG4gICAgY29uc3QgeSA9IHRoaXMubG9hZFNJbnQzMigpXHJcbiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjMmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdHdvIHVuc2lnbmVkIEludDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLlxyXG4gICAqIEByZXR1cm4ge1ZlYzJ9IC0gUmV0dXJucyBhIFZlYzIuXHJcbiAgICovXHJcbiAgbG9hZFVJbnQzMlZlYzIoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5sb2FkVUludDMyKClcclxuICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRVSW50MzIoKVxyXG4gICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBGbG9hdDE2IHZhbHVlcyBpbiB0aGUgYnVmZmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgVmVjMi5cclxuICAgKi9cclxuICBsb2FkRmxvYXQxNlZlYzIoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQxNigpXHJcbiAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQxNigpXHJcbiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjMmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdHdvIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICogQHJldHVybiB7VmVjMn0gLSBSZXR1cm5zIGEgVmVjMi5cclxuICAgKi9cclxuICBsb2FkRmxvYXQzMlZlYzIoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjM2Agb2JqZWN0IHdpdGggdGhlIG5leHQgdGhyZWUgRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZlYzN9IC0gUmV0dXJucyBhIFZlYzMuXHJcbiAgICovXHJcbiAgbG9hZEZsb2F0MTZWZWMzKCkge1xyXG4gICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MTYoKVxyXG4gICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MTYoKVxyXG4gICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MTYoKVxyXG4gICAgcmV0dXJuIG5ldyBWZWMzKHgsIHksIHopXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzNgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtWZWMzfSAtIFJldHVybnMgYSBWZWMzLlxyXG4gICAqL1xyXG4gIGxvYWRGbG9hdDMyVmVjMygpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBRdWF0YCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MTYgdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtRdWF0fSAtIFJldHVybnMgYSBRdWF0LlxyXG4gICAqL1xyXG4gIGxvYWRGbG9hdDE2UXVhdCgpIHtcclxuICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KClcclxuICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KClcclxuICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDE2KClcclxuICAgIGNvbnN0IHcgPSB0aGlzLmxvYWRGbG9hdDE2KClcclxuICAgIHJldHVybiBuZXcgUXVhdCh4LCB5LCB6LCB3KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBRdWF0YCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICogQHJldHVybiB7UXVhdH0gLSBSZXR1cm5zIGEgUXVhdC5cclxuICAgKi9cclxuICBsb2FkRmxvYXQzMlF1YXQoKSB7XHJcbiAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICBjb25zdCB6ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICBjb25zdCB3ID0gdGhpcy5sb2FkRmxvYXQzMigpXHJcbiAgICByZXR1cm4gbmV3IFF1YXQoeCwgeSwgeiwgdylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgQ29sb3JgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDb2xvcn0gLSBSZXR1cm5zIGEgQ29sb3IuXHJcbiAgICovXHJcbiAgbG9hZFJHQkZsb2F0MzJDb2xvcigpIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBSR0JBIGBDb2xvcmAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLlxyXG4gICAqIEByZXR1cm4ge0NvbG9yfSAtIFJldHVybnMgYSBDb2xvci5cclxuICAgKi9cclxuICBsb2FkUkdCQUZsb2F0MzJDb2xvcigpIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIGNvbnN0IGEgPSB0aGlzLmxvYWRGbG9hdDMyKClcclxuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgQ29sb3JgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIHVuc2lnbmVkIEludDggdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIENvbG9yLlxyXG4gICAqL1xyXG4gIGxvYWRSR0JVSW50OENvbG9yKCkge1xyXG4gICAgY29uc3QgciA9IHRoaXMubG9hZFVJbnQ4KClcclxuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRVSW50OCgpXHJcbiAgICBjb25zdCBiID0gdGhpcy5sb2FkVUludDgoKVxyXG4gICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFJHQkEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIHVuc2lnbmVkIEludDggdmFsdWVzIGluIHRoZSBidWZmZXIuXHJcbiAgICogQHJldHVybiB7Q29sb3J9IC0gUmV0dXJucyBhIENvbG9yLlxyXG4gICAqL1xyXG4gIGxvYWRSR0JBVUludDhDb2xvcigpIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRVSW50OCgpXHJcbiAgICBjb25zdCBnID0gdGhpcy5sb2FkVUludDgoKVxyXG4gICAgY29uc3QgYiA9IHRoaXMubG9hZFVJbnQ4KClcclxuICAgIGNvbnN0IGEgPSB0aGlzLmxvYWRVSW50OCgpXHJcbiAgICByZXR1cm4gbmV3IENvbG9yKHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGEgLyAyNTUpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYEJveDJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci5cclxuICAgKiBOZXh0IGZvdXIgYmVjYXVzZSBpdCBjcmVhdGVzIHR3byBWZWMyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm94Mn0gLSBSZXR1cm5zIGEgQm94Mi5cclxuICAgKi9cclxuICBsb2FkQm94MigpIHtcclxuICAgIHJldHVybiBuZXcgQm94Mih0aGlzLmxvYWRGbG9hdDMyVmVjMigpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMigpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBCb3gyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBzaXggRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci5cclxuICAgKiBOZXh0IGZvdXIgYmVjYXVzZSBpdCBjcmVhdGVzIHR3byBWZWMzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm94M30gLSBSZXR1cm5zIGEgQm94My5cclxuICAgKi9cclxuICBsb2FkQm94MygpIHtcclxuICAgIHJldHVybiBuZXcgQm94Myh0aGlzLmxvYWRGbG9hdDMyVmVjMygpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMygpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlYWRQYWRkIG1ldGhvZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gVGhlIHN0cmlkZSBwYXJhbS5cclxuICAgKi9cclxuICByZWFkUGFkZChzdHJpZGUpIHtcclxuICAgIGNvbnN0IHBhZGQgPSB0aGlzLl9fYnl0ZU9mZnNldCAlIHN0cmlkZVxyXG4gICAgaWYgKHBhZGQgIT0gMCkgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc3RyaWRlIC0gcGFkZFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHsgQmluUmVhZGVyIH1cclxuIiwiLyoqXHJcbiAqIENsYXNzIGRlc2lnbmVkIHRvIHN0b3JlIHZlcnNpb24gZGF0YS4gV2lkZWx5IHVzZWQgaW4gdGhlIHplYSBlbmdpbmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gKi9cclxuY2xhc3MgVmVyc2lvbiB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHZlcnNpb24uXHJcbiAgICogVGhlIHZlcnNpb24gc3RyaW5nIHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOiA8YnI+XHJcbiAgICogbWFqb3IsIG1pbm9yIGFuZCBwYXRjaCBzZXBhcmF0ZWQgYnkgYSBkb3QoYC5gKSBhbmQgcGFydHMgc2VwYXJhdGVkIGJ5IGEgZGFzaChgLWApLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJ9IHZlcnNpb25TdHIgLSBUaGUgdmVyc2lvbiBzdHJpbmcgdmFsdWUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodmVyc2lvblN0cikge1xyXG4gICAgaWYgKHZlcnNpb25TdHIpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSB2ZXJzaW9uU3RyLnNwbGl0KCctJylcclxuICAgICAgY29uc3QgbnVtYmVycyA9IHBhcnRzWzBdLnNwbGl0KCcuJylcclxuICAgICAgdGhpcy5tYWpvciA9IHBhcnNlSW50KG51bWJlcnNbMF0pXHJcbiAgICAgIHRoaXMubWlub3IgPSBwYXJzZUludChudW1iZXJzWzFdKVxyXG4gICAgICB0aGlzLnBhdGNoID0gcGFyc2VJbnQobnVtYmVyc1syXSlcclxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAyKSB0aGlzLmJyYW5jaCA9IHBhcnRzWzFdXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1ham9yID0gMFxyXG4gICAgICB0aGlzLm1pbm9yID0gMFxyXG4gICAgICB0aGlzLnBhdGNoID0gMFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBudW1iZXJzIC0gQW4gYXJyYXkgY29udGFpbmluZyAzIHZlcnNpb24gbnVtYmVycy4gW01ham9yLCBNaW5vciwgUGF0Y2hdXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIHJldHVybiBwb3NpdGl2ZTogdjEgPiB2MiwgemVybzp2MSA9PSB2MiwgbmVnYXRpdmU6IHYxIDwgdjJcclxuICAgKi9cclxuICBjb21wYXJlKG51bWJlcnMpIHtcclxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY4MzI1OTYvaG93LXRvLWNvbXBhcmUtc29mdHdhcmUtdmVyc2lvbi1udW1iZXItdXNpbmctanMtb25seS1udW1iZXJcclxuICAgIC8vIDJuZCBhbnN3ZXIuXHJcbiAgICBjb25zdCB2MSA9IFt0aGlzLm1ham9yLCB0aGlzLm1pbm9yLCB0aGlzLnBhdGNoXVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgaWYgKHYxW2ldICE9PSBudW1iZXJzW2ldKSByZXR1cm4gdjFbaV0gLSBudW1iZXJzW2ldXHJcbiAgICB9XHJcbiAgICByZXR1cm4gMFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBudW1iZXJzIC0gVGhlIG51bWJlcnMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGVxdWFscyhudW1iZXJzKSB7XHJcbiAgICByZXR1cm4gISh0aGlzLnBhdGNoID09IG51bWJlcnNbMl0gJiYgdGhpcy5taW5vciA9PSBudW1iZXJzWzFdICYmIHRoaXMubWFqb3IgPT0gbnVtYmVyc1swXSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSB2ZXJzaW9uIG9iamVjdCBhZ2FpbnN0IGEgdmVyc2lvbiBudW1iZXJzIGFycmF5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthcnJheX0gbnVtYmVycyAtIFRoZSBudW1iZXJzIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJldHVybiB2YWx1ZS5cclxuICAgKi9cclxuICBsZXNzVGhhbihudW1iZXJzKSB7XHJcbiAgICByZXR1cm4gISh0aGlzLm1ham9yID49IG51bWJlcnNbMF0gfHwgdGhpcy5taW5vciA+PSBudW1iZXJzWzFdIHx8IHRoaXMucGF0Y2ggPj0gbnVtYmVyc1syXSlcclxuICAgIC8vIGlmICh0aGlzLm1ham9yID49IG51bWJlcnNbMF0pIHJldHVybiBmYWxzZVxyXG4gICAgLy8gaWYgKHRoaXMubWlub3IgPj0gbnVtYmVyc1sxXSkgcmV0dXJuIGZhbHNlXHJcbiAgICAvLyBpZiAodGhpcy5wYXRjaCA+PSBudW1iZXJzWzJdKSByZXR1cm4gZmFsc2VcclxuICAgIC8vIHJldHVybiB0cnVlXHJcbiAgICAvLyByZXR1cm4gKFxyXG4gICAgLy8gICB0aGlzLm1ham9yIDwgbnVtYmVyc1swXSB8fFxyXG4gICAgLy8gICB0aGlzLm1pbm9yIDwgbnVtYmVyc1sxXSB8fFxyXG4gICAgLy8gICB0aGlzLnBhdGNoIDwgbnVtYmVyc1syXVxyXG4gICAgLy8gKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBudW1iZXJzIC0gVGhlIG51bWJlcnMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdyZWF0ZXJUaGFuKG51bWJlcnMpIHtcclxuICAgIHJldHVybiB0aGlzLm1ham9yID4gbnVtYmVyc1swXSB8fCB0aGlzLm1pbm9yID4gbnVtYmVyc1sxXSB8fCB0aGlzLnBhdGNoID4gbnVtYmVyc1syXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHZlcnNpb24gb2JqZWN0IGFnYWluc3QgYSB2ZXJzaW9uIG51bWJlcnMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBudW1iZXJzIC0gVGhlIG51bWJlcnMgdmFsdWUuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgcmV0dXJuIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdyZWF0ZXJPckVxdWFsVGhhbihudW1iZXJzKSB7XHJcbiAgICBpZiAodGhpcy5tYWpvciA8IG51bWJlcnNbMF0pIHJldHVybiBmYWxzZVxyXG4gICAgaWYgKHRoaXMubWFqb3IgPiBudW1iZXJzWzBdKSByZXR1cm4gdHJ1ZVxyXG5cclxuICAgIGlmICh0aGlzLm1pbm9yIDwgbnVtYmVyc1sxXSkgcmV0dXJuIGZhbHNlXHJcbiAgICBpZiAodGhpcy5taW5vciA+IG51bWJlcnNbMV0pIHJldHVybiB0cnVlXHJcblxyXG4gICAgaWYgKHRoaXMucGF0Y2ggPCBudW1iZXJzWzJdKSByZXR1cm4gZmFsc2VcclxuICAgIHJldHVybiB0cnVlXHJcbiAgICAvLyByZXR1cm4gKFxyXG4gICAgLy8gICB0aGlzLm1ham9yID49IG51bWJlcnNbMF0gJiZcclxuICAgIC8vICAgdGhpcy5taW5vciA+PSBudW1iZXJzWzFdICYmXHJcbiAgICAvLyAgIHRoaXMucGF0Y2ggPj0gbnVtYmVyc1syXVxyXG4gICAgLy8gKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHsgVmVyc2lvbiB9XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xyXG5pbXBvcnQgeyBQb2ludHMgfSBmcm9tICcuL1BvaW50cy5qcydcclxuaW1wb3J0IHsgTGluZXMgfSBmcm9tICcuL0xpbmVzLmpzJ1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi9NZXNoLmpzJ1xyXG5pbXBvcnQgeyBCaW5SZWFkZXIgfSBmcm9tICcuLi9CaW5SZWFkZXIuanMnXHJcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuLi9WZXJzaW9uLmpzJ1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vLi4vUmVnaXN0cnknXHJcblxyXG4vLyBrZXksIHRvYywgZ2VvbUluZGV4T2Zmc2V0LCBnZW9tc1JhbmdlLCBpc01vYmlsZURldmljZSwgYnVmZmVyU2xpY2UsIGdlbkJ1ZmZlcnNPcHRzLCBjb250ZXh0XHJcbmNvbnN0IHBhcnNlR2VvbXNCaW5hcnkgPSAoZGF0YSwgY2FsbGJhY2spID0+IHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gZGF0YS5jb250ZXh0LnZlcnNpb25zKSB7XHJcbiAgICBjb25zdCB2ID0gZGF0YS5jb250ZXh0LnZlcnNpb25zW2tleV1cclxuICAgIGNvbnN0IHZlcnNpb24gPSBuZXcgVmVyc2lvbigpXHJcbiAgICB2ZXJzaW9uLm1ham9yID0gdi5tYWpvclxyXG4gICAgdmVyc2lvbi5taW5vciA9IHYubWlub3JcclxuICAgIHZlcnNpb24ucGF0Y2ggPSB2LnBhdGNoXHJcbiAgICB2ZXJzaW9uLmJyYW5jaCA9IHYuYnJhbmNoXHJcbiAgICBkYXRhLmNvbnRleHQudmVyc2lvbnNba2V5XSA9IHZlcnNpb25cclxuICB9XHJcbiAgY29uc3QgZ2VvbURhdGFzID0gW11cclxuICBjb25zdCBvZmZzZXQgPSBkYXRhLnRvY1tkYXRhLmdlb21zUmFuZ2VbMF1dXHJcbiAgLy8gY29uc29sZS5sb2coXCJvZmZzZXQ6XCIgKyAgb2Zmc2V0KTtcclxuICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW11cclxuICBmb3IgKGxldCBpID0gZGF0YS5nZW9tc1JhbmdlWzBdOyBpIDwgZGF0YS5nZW9tc1JhbmdlWzFdOyBpKyspIHtcclxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCaW5SZWFkZXIoZGF0YS5idWZmZXJTbGljZSwgZGF0YS50b2NbaV0gLSBvZmZzZXQsIGRhdGEuaXNNb2JpbGVEZXZpY2UpXHJcbiAgICBjb25zdCBjbGFzc05hbWUgPSByZWFkZXIubG9hZFN0cigpXHJcbiAgICBjb25zdCBwb3MgPSByZWFkZXIucG9zKClcclxuICAgIC8vIGNvbnN0IG5hbWUgPSByZWFkZXIubG9hZFN0cigpXHJcbiAgICAvLyBjb25zb2xlLmxvZyhpICsgXCI6XCIgKyBvZmZzZXQgKyBcIiBjbGFzc05hbWU6XCIgKyAgY2xhc3NOYW1lICArIFwiIG5hbWU6XCIgKyAgbmFtZS8qICsgXCIgcG9zOlwiICsgKGRhdGEudG9jW2ldIC0gb2Zmc2V0KSArIFwiIGJ1ZmZlclNsaWNlLmJ5dGVMZW5ndGg6XCIgKyAgYnVmZmVyU2xpY2UuYnl0ZUxlbmd0aCovKTtcclxuICAgIGxldCBnZW9tXHJcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xyXG4gICAgICBjYXNlICdQb2ludHMnOlxyXG4gICAgICAgIGdlb20gPSBuZXcgUG9pbnRzKClcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdMaW5lcyc6XHJcbiAgICAgICAgZ2VvbSA9IG5ldyBMaW5lcygpXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAnTWVzaCc6XHJcbiAgICAgICAgZ2VvbSA9IG5ldyBNZXNoKClcclxuICAgICAgICBicmVha1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgR2VvbSB0eXBlOicgKyBjbGFzc05hbWUpXHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICByZWFkZXIuc2Vlayhwb3MpIC8vIFJlc2V0IHRoZSBwb2ludGVyIHRvIHRoZSBzdGFydCBvZiB0aGUgaXRlbSBkYXRhLlxyXG4gICAgICBnZW9tLnJlYWRCaW5hcnkocmVhZGVyLCBkYXRhLmNvbnRleHQpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9hZGluZzonICsgZ2VvbS5uYW1lICsgJ1xcbjonICsgZSlcclxuICAgICAgZ2VvbURhdGFzLnB1c2goe30pXHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2VvbUJ1ZmZlcnMgPSBnZW9tLmdlbkJ1ZmZlcnMoZGF0YS5nZW5CdWZmZXJzT3B0cylcclxuICAgIGlmIChnZW9tQnVmZmVycy5pbmRpY2VzKSB0cmFuc2ZlcmFibGVzLnB1c2goZ2VvbUJ1ZmZlcnMuaW5kaWNlcy5idWZmZXIpXHJcbiAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGdlb21CdWZmZXJzLmF0dHJCdWZmZXJzKSB7XHJcbiAgICAgIC8vIE5vdGU6IFRoZSB0eXBlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBhdHRyaWJ1dGUgY2FuXHJcbiAgICAgIC8vIG5vdCBiZSB0cmFuc2ZlcmVkIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLiBDb252ZXJ0IHRvXHJcbiAgICAgIC8vIHRoZSB0eXBlIG5hbWUgaGVyZSBhbmQgc2VuZCBiYWNrIGFzIGEgc3RyaW5nLlxyXG4gICAgICBjb25zdCBhdHRyRGF0YSA9IGdlb21CdWZmZXJzLmF0dHJCdWZmZXJzW2F0dHJOYW1lXVxyXG4gICAgICBjb25zdCB0eXBlTmFtZSA9IFJlZ2lzdHJ5LmdldEJsdWVwcmludE5hbWUoYXR0ckRhdGEuZGF0YVR5cGUpXHJcbiAgICAgIGF0dHJEYXRhLmRhdGFUeXBlID0gdHlwZU5hbWVcclxuXHJcbiAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChhdHRyRGF0YS52YWx1ZXMuYnVmZmVyKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChnZW9tQnVmZmVycy52ZXJ0ZXhOZWlnaGJvcnMpIHtcclxuICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGdlb21CdWZmZXJzLnZlcnRleE5laWdoYm9ycy5idWZmZXIpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJhbnNmZXIgdGhlIGJib3ggcG9pbnQgYnVmZmVycy5cclxuICAgIGNvbnN0IGJib3ggPSBnZW9tLmdldEJvdW5kaW5nQm94KClcclxuICAgIHRyYW5zZmVyYWJsZXMucHVzaChiYm94LnAwLl9fZGF0YS5idWZmZXIpXHJcbiAgICB0cmFuc2ZlcmFibGVzLnB1c2goYmJveC5wMS5fX2RhdGEuYnVmZmVyKVxyXG5cclxuICAgIGdlb21EYXRhcy5wdXNoKHtcclxuICAgICAgbmFtZTogZ2VvbS5uYW1lLFxyXG4gICAgICB0eXBlOiBjbGFzc05hbWUsXHJcbiAgICAgIGdlb21CdWZmZXJzLFxyXG4gICAgICBiYm94LFxyXG4gICAgfSlcclxuICB9XHJcbiAgY2FsbGJhY2soXHJcbiAgICB7XHJcbiAgICAgIGtleTogZGF0YS5rZXksXHJcbiAgICAgIGdlb21JbmRleE9mZnNldDogZGF0YS5nZW9tSW5kZXhPZmZzZXQsXHJcbiAgICAgIGdlb21zUmFuZ2U6IGRhdGEuZ2VvbXNSYW5nZSxcclxuICAgICAgZ2VvbURhdGFzLFxyXG4gICAgfSxcclxuICAgIHRyYW5zZmVyYWJsZXNcclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCB7IHBhcnNlR2VvbXNCaW5hcnkgfVxyXG4iLCJpbXBvcnQgeyBwYXJzZUdlb21zQmluYXJ5IH0gZnJvbSAnLi9wYXJzZUdlb21zQmluYXJ5LmpzJ1xyXG5cclxuc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBwYXJzZUdlb21zQmluYXJ5KGV2ZW50LmRhdGEsIChkYXRhLCB0cmFuc2ZlcmFibGVzKSA9PiB7XHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyYWJsZXMpXHJcbiAgfSlcclxufVxyXG4iXSwibmFtZXMiOlsiVmVjMyIsIlZlYzQiLCJCb3gzIiwiaXNUeXBlZEFycmF5IiwiVmVydGV4QXR0cmlidXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZUFBZSxDQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxVQUFVLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUU7QUFDL0MsSUFBSSxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxFQUFFLFdBQVcsQ0FBQztBQUM3RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sK0JBQStCLENBQUMsR0FBRyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLENBQUMsRUFBRTtBQUN4RSxJQUFJLE9BQU8sSUFBSSxDQUFDLFNBQVM7QUFDekIsTUFBTSxHQUFHO0FBQ1QsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUs7QUFDcEIsUUFBUSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0UsT0FBTztBQUNQLE1BQU0sS0FBSztBQUNYLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJRCxNQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVB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SUMsTUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMzRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUU7QUFDbEIsSUFBSSxPQUFPLElBQUlBLE1BQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZSxDQUFDLEtBQUssRUFBRTtBQUN6QixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ2xCLElBQUksT0FBTyxJQUFJQSxNQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQzNGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGVBQWUsQ0FBQyxLQUFLLEVBQUU7QUFDekIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRTtBQUNoQixJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMzRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhLENBQUMsS0FBSyxFQUFFO0FBQ3ZCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUU7QUFDaEIsSUFBSSxPQUFPLElBQUlBLE1BQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN2RixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFO0FBQ3ZCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBQztBQUNoRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLEdBQUc7QUFDWCxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsYUFBYSxHQUFHO0FBQ2xCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxHQUFHO0FBQ2QsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDO0FBQzNDLElBQUksSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUM5QixNQUFNLE9BQU8sSUFBSUEsTUFBSSxFQUFFO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDO0FBQzVCLElBQUksT0FBTyxJQUFJQSxNQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDOUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0IsR0FBRztBQUNyQixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDM0MsSUFBSSxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFO0FBQzlCLE1BQU0sTUFBTTtBQUNaLEtBQUs7QUFDTCxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUM7QUFDNUIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUM7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxHQUFHLENBQUMsS0FBSyxFQUFFO0FBQ2IsSUFBSSxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDaEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQ2YsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFDO0FBQ3RCLElBQUksTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUM7QUFDdEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBQztBQUN0QixJQUFJLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFDO0FBQ3RCO0FBQ0EsSUFBSSxPQUFPLElBQUlBLE1BQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDL0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPLENBQUMsS0FB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RSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7QUFDYixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFO0FBQ2IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUc7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUU7QUFDeEIsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDZCxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUNkLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFDO0FBQ2QsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDZCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZLENBQUMsS0FBSyxFQUFFO0FBQ3RCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBQztBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEVBQUM7QUFDcEIsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFDO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBQztBQUNwQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZLENBQUMsSUFBSSxFQUFFO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDbEIsSUFBSSxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDM0IsTUFBTSxNQUFNLE1BQU0sR0FBRywyQ0FBMkMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDO0FBQzFFLE1BQU0s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QyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFdBQVcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUU7QUFDakQsSUFBSTtBQUNKLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTO0FBQzVDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTO0FBQzVDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTO0FBQzVDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTO0FBQzVDLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUU7QUFDYixJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQzNGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsUUFBUSxDQUFDLEtBQUssRUFBRTtBQUNsQixJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQzNGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUNoQixJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7QUFDdkYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUN2QixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTTtBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTTtBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTTtBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTTtBQUNwQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFO0FBQ3BCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFDO0FBQy9GLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFO0FBQ3hCLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3RHLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxDQUFDLEtBQUssR0FBRyxHQUFHLEVBQUU7QUFDdkIsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDeEgsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxHQUFHO0FBQ2QsSUFBSSxPQUFPLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQztBQUM5RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUU7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VyxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUNqRCxJQUFJO0FBQ0osTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRTtBQUNiLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDNUYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ2xCLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxH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QU0sRUFBRSxJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUM7QUFDM0MsUUFBUSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksR0FBRyxHQUFHLFdBQVcsQ0FBQztBQUMzQyxRQUFRLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksR0FBRyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEdBQUc7QUFDL0QsT0FBTztBQUNQLEtBQUssTUFBTTtBQUNYLE1BQU0sT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQztBQUN0RyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaUJBQWlCLEdBQUc7QUFDdEIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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V0FBVyxFQUFFO0FBQ2xDLE1BQU0sTUFBTSxNQUFNLEdBQUcsRUFBQztBQUN0QixNQUFNLE1BQU0sVUFBVSxHQUFHLEVBQUM7QUFDMUIsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFDO0FBQzNELEtBQUssTUFBTTtBQUNYLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUM7QUFDdkMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDeEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDeEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDeEIsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNiLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNiLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssR0FBRztBQUNkLElBQUksT0FBT0QsTUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUN2RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUU7QUFDbEIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxLQUFLLEdBQUc7QUFDZCxJQUFJLE9BQU9BLE1BQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUU7QUFDbEIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxLQUFLLEdBQUc7QUFDZCxJQUFJLE9BQU9BLE1BQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUU7QUFDbEIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFO0FBQ3ZGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsV0FBVyxHQUFHO0FBQ2hCLElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRTtBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ2xCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBRztBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUc7QUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFHO0FBQzVCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBRztBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUc7QUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFHO0FBQzVCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBRztBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUc7QUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFHO0FBQzVCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkJBQTJCLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRTtBQUN2QyxJQUFJLE1BQU0sS0FBSyxHQUFHLElBQUc7QUFDckIsSUFBSSxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFFO0FBQy9CLElBQUksSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUMvQixNQUFNLElBQUksQ0FBQyxXQUFXLEdBQUU7QUFDeEIsTUFBTSxNQUFNO0FBQ1osS0FBSztBQUNMLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFDO0FBQ2hDO0FBQ0EsSUFBSSxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBQztBQUNqQyxJQUFJLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUU7QUFDL0IsSUFBSSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBQztBQUMzRDtBQUNBLElBQUksTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUM7QUFDcEMsSUFBSSxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFFO0FBQy9CLElBQUksSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUM7QUFDM0Q7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUM7QUFDN0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxHQUFHO0FBQ1osSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3RDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQztBQUNBLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ2pEO0FBQ0EsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO0FBQ2QsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFDO0FBQzNDLE1BQU0sT0FBTyxJQUFJO0FBQ2pCLEtBQUs7QUFDTCxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNuQjtBQUNBLElBQUksT0FBTyxJQUFJLElBQUk7QUFDbkIsTUFBTSxHQUFHLEdBQUcsR0FBRztBQUNmLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQ3BDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRztBQUNuQyxNQUFNLEdBQUcsR0FBRyxHQUFHO0FBQ2YsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQ25DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQ3BDLE1BQU0sR0FBRyxHQUFHLEdBQUc7QUFDZixNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRztBQUNwQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDbkMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWEsR0FBRztBQUNsQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7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LENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUk7QUFDSixJQUFJLEtBQUssR0FBRTtBQUNYO0FBQ0EsSUFBSSxJQUFJLEdBQUcsWUFBWSxZQUFZLEVBQUU7QUFDckMsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUc7QUFDdkIsS0FBSyxNQUFNLElBQUksR0FBRyxZQUFZLFdBQVcsRUFBRTtBQUMzQyxNQUFNLE1BQU0sTUFBTSxHQUFHLElBQUc7QUFDeEIsTUFBTSxNQUFNLFVBQVUsR0FBRyxJQUFHO0FBQzVCLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBQztBQUM1RCxLQUFLLE1BQU07QUFDWCxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxFQUFDO0FBQ3hDLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUM7QUFDOUYsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHO0FBQ1osSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRTtBQUNmLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFHO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksS0FBSyxHQUFHO0FBQ2QsSUFBSSxPQUFPQSxNQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtBQUNsQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFDO0FBQzFDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksS0FBSyxHQUFHO0FBQ2QsSUFBSSxPQUFPQSxNQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMzRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUU7QUFDbEIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssR0FBRztBQUNkLElBQUksT0FBT0EsTUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDM0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFO0FBQ2xCLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUM7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxXQUFXLEdBQUc7QUFDcEIsSUFBSSxPQUFPQSxNQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUM1RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUU7QUFDeEIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBQztBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxHQUFHO0FBQ0wsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUksR0FBRyxHQUFHLENBQUM7QUFDWCxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ1gsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUNYLElBQUk7QUFDSixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFdBQVcsR0FBRztBQUNoQixJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUU7QUFDZCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZLENBQUMsWUFBWSxFQUFFO0FBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxhQUFZO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFO0FBQ3BCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUc7QUFDN0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFHO0FBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUc7QUFDN0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFHO0FBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUc7QUFDN0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFHO0FBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUc7QUFDOUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFHO0FBQzlCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM5QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUc7QUFDOUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFHO0FBQzlCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBRztBQUM5QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFDZixJQUFJLE9BQU8sSUFBSSxJQUFJO0FBQ25CLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3JCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQixHQUFHO0FBQ3JCO0FBQ0EsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0I7QUFDQSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDbkMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQ25DLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUNwQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBRztBQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDbkMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQ3BDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUNyQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBRztBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFNBQVMsR0FBRztBQUNkLElBQUksT0FBTyxJQUFJLElBQUk7QUFDbkIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNyQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3JCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3JCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDckIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDckIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNyQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxHQUFHO0FBQ1osSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQjtBQUNBLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNuRjtBQUNBLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNkLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBQztBQUMzQyxNQUFNLE9BQU8sSUFBSTtBQUNqQixLQUFLO0FBQ0wsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDbkI7QUFDQSxJQUFJLE9BQU8sSUFBSSxJQUFJO0FBQ25CLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhLEdBQUc7QUFDbEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQjtBQUNBLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNuRjtBQUNBLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNkLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBQztBQUMzQyxNQUFNLE9BQU8sS0FBSztBQUNsQixLQUFLO0FBQ0wsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDbkI7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHO0FBQ1osTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUc7QUFDL0MsTUFBSztBQUNMLElBQUksT0FBTyxJQUFJO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQ25CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0I7QUFDQSxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDckMsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ3JDLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNyQztBQUNBO0FBQ0EsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUc7QUFDbkY7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDZCxNQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUM7QUFFOUMsS0FBSztBQUNMLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFHO0FBQ25CO0FBQ0EsSUFBSSxJQUFJLENBQUMsR0FBRztBQUNaLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHO0FBQy9DLE1BQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUU7QUFDbEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQixJQUFJLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFDO0FBQy9CLElBQUksTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUM7QUFDL0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUMvQjtBQUNBO0FBQ0EsSUFBSSxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFFO0FBQzdCLElBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNqQixJQUFJLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDakIsSUFBSSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2pCLElBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNqQixJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksSUFBSSxHQUFFO0FBQzdCLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUMxRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDMUQsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQzFELElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUMxRDtBQUNBLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDYixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNiLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDYixJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDMUQsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQzFELElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUMxRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDMUQ7QUFDQSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNiLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQzFELElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUMxRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDMUQsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQzFEO0FBQ0EsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNkLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNkLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUMxRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDMUQsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJ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QUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2IsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hEO0FBQ0EsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNiLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDYixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNkLElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RDtBQUNBLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNkLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxPQUFPLElBQUk7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1CQUFtQixDQUFDLEtBQUssRUFBRTtBQUM3QixJQUFJLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUU7QUFDN0IsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNwQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNwQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNwQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNyQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDckIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ3JCLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNyQixJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDckIsSUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUU7QUFDNUIsSUFBSSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2pCLElBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNqQixJQUFJLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDakIsSUFBSSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2pCLElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RDtBQUNBLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDYixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNiLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDYixJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQ7QUFDQSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNiLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hELElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBRztBQUN4RCxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLElBQUc7QUFDeEQsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFHO0FBQ3hEO0FBQ0EsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBQztBQUNkLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUM7QUFDZCxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFDO0FBQ2QsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVB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QUlBLE1BQUk7QUFDbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQzVDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUM1QyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDN0MsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDbEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTTtBQUN6QixJQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFDO0FBQ25CLElBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUM7QUFDbkIsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBQztBQUNuQixJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9CQUFvQixDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRTtBQUNoRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBQztBQUNsRCxJQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUcsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFDO0FBQ3ZDO0FBQ0EsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksR0FBRyxHQUFHLEdBQUcsUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUM7QUFDcEg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUJBQXFCLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDN0QsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLEtBQUssRUFBQztBQUNqQyxJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxNQUFNLEdBQUcsR0FBRyxFQUFDO0FBQ2pDLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxHQUFHLEVBQUM7QUFDL0I7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHO0FBQ1osTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFO0FBQ2IsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFO0FBQ2IsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDO0FBQ1AsTUFBTSxDQUFDLEdBQUcsRUFBRTtBQUNaLE1BQU0sQ0FBQztBQUNQLE1BQU0sQ0FBQyxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUU7QUFDekIsTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLElBQUksRUFBRTtBQUN6QixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksSUFBSSxFQUFFO0FBQ3ZCLE1BQU0sQ0FBQztBQUNQLE1BQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDcEI7QUFDQSxJQUFJLElBQUksQ0FBQyxZQUFZQSxNQUFJLEVBQUU7QUFDM0IsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQztBQUNwRSxLQUFLLE1BQU07QUFDWCxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDO0FBQzlELEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtCQUFrQixDQUFDLElBQUksRUFBRTtBQUMzQjtBQUNBLElBQUksSUFBSSxDQUFDLEdBQUc7QUFDWixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLENBQUM7QUFDUCxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLENBQUM7QUFDUCxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLENBQUM7QUFDUCxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDYixNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDZCxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDZCxNQUFNLENBQUM7QUFDUCxNQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sdUJBQXVCLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDckQsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLDJDQUEyQyxFQUFDO0FBQzdELElBQUksT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFO0FBQzlDLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzdELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQUssR0FBRztBQUNWLElBQUksT0FBTyxJQUFJLElBQUk7QUFDbkIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3JCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDckIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNyQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3JCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDckIsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNyQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPLE1BQU0sQ0FBQyxHQUFHLElBQUksRUFBRTtBQUN6QixJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDNUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxHQUFHO0FBQ1gsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFDakIsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLElBQUksRUFBQztBQUN4QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLENBQUMsTUFBTSxFQUFFO0FBQ3JCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFDO0FBQzdDLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJOztBQ243QzlCO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSSxTQUFTLFNBQVMsQ0FBQztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUMxQyxJQUFJLEtBQUssR0FBRTtBQUNYO0FBQ0EsSUFBSSxJQUFJLENBQUMsWUFBWSxZQUFZLEVBQUU7QUFDbkMsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUM7QUFDckIsS0FBSyxNQUFNLElBQUksQ0FBQyxZQUFZLFdBQVcsRUFBRTtBQUN6QyxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyx3RUFBd0UsQ0FBQyxFQUFDO0FBQzlGLE1BQU0sTUFBTSxNQUFNLEdBQUcsRUFBQztBQUN0QixNQUFNLE1BQU0sVUFBVSxHQUFHLEVBQUM7QUFDMUIsTUFBTSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFDO0FBQzNELEtBQUssTUFBTTtBQUNYLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLEVBQUM7QUFDdkMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsRUFBRTtBQUNqQyxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLEtBQUssTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFO0FBQzdCLFVBQVUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFDO0FBQ3BFLGVBQWUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFDO0FBQzNDLFNBQVM7QUFDVCxPQUFPLE1BQU07QUFDYixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUMxQixPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNiLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNiLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtBQUNiLElBQUksSUFBSSxDQUFDLE1BQU0s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RUFBQztBQUNoRSxRQUFRLEtBQUs7QUFDYixNQUFNLEtBQUssQ0FBQztBQUNaO0FBQ0EsUUFBUSxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxFQUFDO0FBQ2hFLFFBQVEsS0FBSztBQUNiLE1BQU07QUFDTixRQUFRLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBLElBQUksTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFHO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUM7QUFDM0IsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBQztBQUMzQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFDO0FBQzNCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUM7QUFDM0IsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBQztBQUMzQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFDO0FBQzNCLElBQUksTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDdEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUN0QixJQUFJLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQ3RCLElBQUksTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDdEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxFQUFF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LE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBQztBQUMzRCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBQztBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJCQUEyQixDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUU7QUFDdkMsSUFBSSxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksR0FBRTtBQUMzQixJQUFJLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFDO0FBQzdDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUM7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxlQUFlLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMxQixJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFDO0FBQzFCLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUM7QUFDeEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7QUFDcEM7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztBQUM5QyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsR0FBRTtBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUNuRSxJQUFJLElBQUksTUFBSztBQUNiO0FBQ0EsSUFBSSxJQUFJLE1BQU0sR0FBRyxHQUFHLEVBQUU7QUFDdEI7QUFDQSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7QUFDbkMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ2xDLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ3pCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLEtBQUssTUFBTTtBQUNYO0FBQ0EsTUFBTSxJQUFJLENBQUMsR0FBRyxFQUFDO0FBQ2YsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBQztBQUNoRCxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUM7QUFDeEQsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksRUFBQztBQUMzQixNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFDO0FBQzNCO0FBQ0EsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUM7QUFDdkcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ2xDLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ3pCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBSztBQUNoRixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQUs7QUFDaEYsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hGLEtBQUs7QUFDTCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsR0FBRTtBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBQztBQUNwRSxJQUFJLElBQUksTUFBSztBQUNiO0FBQ0EsSUFBSSxJQUFJLE1BQU0sR0FBRyxHQUFHLEVBQUU7QUFDdEI7QUFDQSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7QUFDbkMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ2xDLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ3pCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hFLEtBQUssTUFBTTtBQUNYO0FBQ0EsTUFBTSxJQUFJLENBQUMsR0FBRyxFQUFDO0FBQ2YsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBQztBQUNoRCxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUM7QUFDekQsTUFBTSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksRUFBQztBQUMzQixNQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFDO0FBQzNCO0FBQ0EsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUM7QUFDdkcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ2xDLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxNQUFLO0FBQ3pCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBSztBQUNoRixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQUs7QUFDaEYsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFLO0FBQ2hGLEtBQUs7QUFDTCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsR0FBRTtBQUMzQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVLEdBQUc7QUFDZixJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLE1BQU0sQ0FBQyxPQUFPO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsR0FBRztBQUNiLElBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRTtBQUNmLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDO0FBQzNGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUNuQixJQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMzRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsV0FBVyxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUNqRCxJQUFJO0FBQ0osTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVM7QUFDNUMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRTtBQUNiLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRTtBQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFDO0FBQ3JCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBQztBQUNyQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUM7QUFDckIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ2xCLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQ2hCLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN2RixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFO0FBQ3ZCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFNO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFNO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFNO0FBQ3BCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFNO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sR0FBRztBQUNYLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhLEdBQUc7QUFDbEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxHQUFHO0FBQ2QsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDO0FBQzNDLElBQUksSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUM5QixNQUFNLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUM7QUFDNUIsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQzlDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCLEdBQUc7QUFDckIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzVCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDNUIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM1QixJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFDO0FBQzNDLElBQUksSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTtBQUM5QixNQUFNLE1BQU07QUFDWixLQUFLO0FBQ0wsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFDO0FBQzVCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFDO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRTtBQUNiLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ3BGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRTtBQUNmLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBQztBQUN0QixJQUFJLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFDO0FBQ3RCLElBQUksTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUM7QUFDdEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBQztBQUN0QjtBQUNBLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDL0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFNBQVMsR0FBRztBQUNkLElBQUksT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sR0FBRztBQUNaLElBQUksT0FBTyxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQzNCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUNuQixJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEVBQUU7QUFDL0IsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQztBQUNsRCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ2xCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDN0IsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM3QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzdCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDN0IsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QjtBQUNBLElBQUksT0FBTyxJQUFJLElBQUk7QUFDbkIsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUMzQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzNDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDM0MsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUMzQyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZSxDQUFDLEtBQUssRUFBRTtBQUN6QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzdCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDN0IsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM3QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzdCLElBQUksTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUM7QUFDOUI7QUFDQSxJQUFJLElBQUksQ0FBQyxHQUFHO0FBQ1osTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUMzQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzNDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDM0MsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUMzQyxNQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRTtBQUNuQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBQztBQUNwRCxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBQztBQUMzRCxJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLEdBQUcsSUFBSSxJQUFHO0FBQ2Q7QUFDQSxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDNUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBQztBQUM1QjtBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLEdBQUcsSUFBSSxJQUFHO0FBQ2Q7QUFDQSxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDNUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBQztBQUM1QjtBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixJQUFJLEdBQUcsSUFBSSxJQUFHO0FBQ2Q7QUFDQSxJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDNUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBQztBQUM1QjtBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzlCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sR0FBRztBQUNYLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNwQixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBQztBQUNwQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFDO0FBQ3BCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckI7QUFDQSxJQUFJLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxHQUFFO0FBQzNCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDaEMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzVCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUM1QjtBQUNBLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQ2hDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUM1QjtBQUNBLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUNoQztBQUNBLElBQUksT0FBTyxJQUFJO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsUUFBUSxHQUFHO0FBQ2IsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUI7QUFDQSxJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUM1RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLEdBQUc7QUFDYixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QjtBQUNBLElBQUksT0FBTyxJQUFJQSxNQUFJLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQzVFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsR0FBRztBQUNiLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCO0FBQ0EsSUFBSSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQzlCLElBQUksTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDOUIsSUFBSSxNQUFNLElBQUksR0FBRyxJQUFJQSxNQUFJLEdBQUU7QUFDM0I7QUFDQSxJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUM1RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sQ0FBQyxTQUFTLEVBQUU7QUFDcEIsSUFBSSxRQUFRLFNBQVM7QUFDckIsTUFBTSxLQUFLLENBQUM7QUFDWixRQUFRLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN2RCxNQUFNLEtBQUssQ0FBQztBQUNaLFFBQVEsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN6RCxNQUFNLEtBQUssQ0FBQztBQUNaLFFBQVEsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDeEQsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sR0FBRztBQUNYLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBQztBQUNwQixJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFDO0FBQ3BCLElBQUksTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBQztBQUNwQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFDO0FBQ3BCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUM7QUFDcEIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckIsSUFBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRTtBQUNyQixJQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFFO0FBQ3JCLElBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUU7QUFDckI7QUFDQTtBQUNBLElBQUksTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLEdBQUU7QUFDM0IsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUNoQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzVCO0FBQ0EsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzVCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUU7QUFDaEMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzVCO0FBQ0EsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQzVCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRTtBQUM1QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFFO0FBQ2pDO0FBQ0EsSUFBSSxPQUFPLElBQUk7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUU7QUFDakIsSUFBSSxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUk7QUFDM0IsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckMsTUFBSztBQUNMLElBQUksTUFBTSxDQUFDLGdCQUFnQixHQUFFO0FBQzdCLElBQUksT0FBTyxNQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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SSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUM7QUFDaEQsTUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUM7QUFDcEYsTUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUM7QUFDcEYsTUFBTSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUM7QUFDcEYsS0FBSyxNQUFNO0FBQ1gsTUFBTSxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxHQUFFO0FBQ25DLEtBQUs7QUFDTCxJQUFJLE1BQU0sQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVB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RUFBRTtBQUNiO0FBQ0EsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFDO0FBQy9DLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUlBLE1BQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDakYsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSUEsTUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNqRixNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJQSxNQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDO0FBQ2pGLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUlBLE1BQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDakYsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSUEsTUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMs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TSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDO0FBQ3ZDLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQztBQUN2QyxLQUFLO0FBQ0w7QUFDQSxJQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQzVCLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQztBQUN4QyxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUM7QUFDeEMsS0FBSyxNQUFNO0FBQ1gsTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDO0FBQ3hDLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQztBQUN4QyxLQUFLO0FBQ0w7QUFDQSxJQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQzVCLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQztBQUN4QyxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUM7QUFDeEMsS0FBSyxNQUFNO0FBQ1gsTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDO0FBQ3hDLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBQztBQUN4QyxLQUFLO0FBQ0w7QUFDQSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUTtBQUMzRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxHQUFHO0FBQ1YsSUFBSSxPQUFPLElBQUlFLE1BQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPLE1BQU0sQ0FBQyxHQUFHLElBQUksRUFBRTtBQUN6QixJQUFJLE9BQU8sSUFBSUEsTUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQzVCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU8sV0FBVyxHQUFHO0FBQ3ZCLElBQUksT0FBTyxFQUFFO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxHQUFHO0FBQ1gsSUFBSSxPQUFPO0FBQ1gsTUFBTSxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsTUFBTSxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFDZDtBQUNBO0FBQ0EsSUFBSSxNQUFNLEVBQUUsR0FBRztBQUNmLE1BQU0sQ0FBQyxFQUFFLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsaUJBQWlCO0FBQzVFLE1BQU0sQ0FBQyxFQUFFLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsaUJBQWlCO0FBQzVFLE1BQU0sQ0FBQyxFQUFFLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsaUJBQWlCO0FBQzVFLE1BQUs7QUFDTCxJQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ2YsTUFBTSxDQUFDLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUI7QUFDNUUsTUFBTSxDQUFDLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUI7QUFDNUUsTUFBTSxDQUFDLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUI7QUFDNUUsTUFBSztBQUNMLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDO0FBQ3hCLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUU7QUFDNUIsSUFBSSxJ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O0FBQzNCLE1BQU0sRUFBRSxJQUFJLElBQUksU0FBUyxFQUFFO0FBQzNCLE1BQU0sRUFBRSxJQUFJLElBQUksU0FBUyxFQUFFO0FBQzNCLE1BQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhLENBQUMsSUFBSSxFQUFFO0FBQ3RCLElBQUksTUFBTSxDQUFDLEdBQUcsS0FBSTtBQUNsQixJQUFJLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFNO0FBQzlCLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDN0UsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUM3RSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFDO0FBQzdFLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUM7QUFDN0UsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBQztBQUM3RSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFDO0FBQzdFO0FBQ0EsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxFQUFDO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWEsQ0FBQyxJQUFJLEVBQUU7QUFDdEIsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJQSxNQUFJLEdBQUU7QUFDeEIsSUFBSSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTTtBQUM5QixJQUFJLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSTtBQUM3QjtBQUNBLElBQUksS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFH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', false);
/* eslint-enable */

// import {
//     parseGeomsBinary
// } from './Geometry/parseGeomsBinary.js';

/** Class representing a geometry library.
 * @private
 */
class GeomLibrary extends EventEmitter {
  /**
   * Create a geom library.
   */
  constructor() {
    super();
    this.__streamInfos = {};
    this.__genBuffersOpts = {};

    this.__workers = [];
    this.__nextWorker = 0;

    {
      for (let i = 0; i < 3; i++) {
        this.__workers.push(this.__constructWorker());
      }
    }

    this.clear();
  }

  /**
   * The clear method.
   */
  clear() {
    this.__loaded = 0;
    this.__numGeoms = 0;
    this.geoms = [];
  }

  /**
   * The __constructWorker method.
   * @return {GeomParserWorker} - Returns a GeomParserWorker.
   * @private
   */
  __constructWorker() {
    const worker = new WorkerFactory$1();
    worker.onmessage = (event) => {
      this.__recieveGeomDatas(event.data.key, event.data.geomDatas, event.data.geomIndexOffset, event.data.geomsRange);
    };
    return worker
  }

  /**
   * The __terminateWorkers method.
   * @private
   */
  __terminateWorkers() {
    for (const worker of this.__workers) worker.terminate();
    this.__workers = [];
  }

  /**
   * The setGenBufferOption method.
   * @param {any} key - The key value.
   * @param {any} value - The value param.
   */
  setGenBufferOption(key, value) {
    this.__genBuffersOpts[key] = value;
  }

  /**
   * The setNumGeoms method.
   * @param {any} expectedNumGeoms - The expectedNumGeoms value.
   */
  setNumGeoms(expectedNumGeoms) {
    this.__numGeoms = expectedNumGeoms;
  }

  /**
   * The getGeom method.
   * @param {number} index - The index value.
   * @return {any} - The return value.
   */
  getGeom(index) {
    if (index >= this.geoms.length) {
      // console.warn("Geom index invalid:" + index);
      return null
    }
    return this.geoms[index]
  }

  /**
   * The loadUrl method.
   * @param {any} fileUrl - The fileUrl value.
   */
  loadUrl(fileUrl) {
    loadBinfile(
      fileUrl,
      (data) => {
        this.loadBin(data);
      },
      (statusText) => {
        console.warn(statusText);
      }
    );
  }

  /**
   * The readBinaryBuffer method.
   * @param {any} key - The key value.
   * @param {ArrayBuffer} buffer - The buffer value.
   * @param {object} context - The context value.
   * @return {any} - The return value.
   */
  readBinaryBuffer(key, buffer, context) {
    const isMobile = SystemDesc.isMobileDevice;
    const reader = new BinReader(buffer, 0, isMobile);
    const numGeoms = reader.loadUInt32();
    const geomIndexOffset = reader.loadUInt32();
    this.__streamInfos[key] = {
      total: numGeoms,
      done: 0,
    };

    if (numGeoms == 0) {
      this.emit('streamFileParsed', {});
      return numGeoms
    }
    if (this.__numGeoms == 0) {
      // Note: for loading geom streams, we need to know the total number
      // ahead of time to be able to generate accurate progress reports.
      this.__numGeoms = numGeoms;
      // throw("Loading cannot start will we know how many geomms.");
    }

    const toc = reader.loadUInt32Array(numGeoms);

    let numCores = window.navigator.hardwareConcurrency;
    if (!numCores) {
      if (isMobile) numCores = 2;
      else numCores = 4;
    }
    const numGeomsPerWorkload = Math.max(1, Math.floor(numGeoms / numCores + 1));

    // TODO: Use SharedArrayBuffer once available.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer

    let offset = 0;
    while (offset < numGeoms) {
      const bufferSlice_start = toc[offset];
      let bufferSlice_end;
      let geomsRange;
      if (offset + numGeomsPerWorkload >= numGeoms) {
        geomsRange = [offset, numGeoms];
        bufferSlice_end = buffer.byteLength;
      } else {
        geomsRange = [offset, offset + numGeomsPerWorkload];
        bufferSlice_end = toc[geomsRange[1]];
      }
      const bufferSlice = buffer.slice(bufferSlice_start, bufferSlice_end);
      offset += numGeomsPerWorkload;

      // ////////////////////////////////////////////
      // Multi Threaded Parsing
      {
        this.__workers[this.__nextWorker].postMessage(
          {
            key,
            toc,
            geomIndexOffset,
            geomsRange,
            isMobileDevice: reader.isMobileDevice,
            bufferSlice,
            genBuffersOpts: this.__genBuffersOpts,
            context: {
              versions: context.versions,
            },
          },
          [bufferSlice]
        );
        this.__nextWorker = (this.__nextWorker + 1) % this.__workers.length;
      }
    }
    return numGeoms
  }

  /**
   * The __recieveGeomDatas method.
   * @param {any} key - The key value.
   * @param {any} geomDatas - The geomDatas value.
   * @param {any} geomIndexOffset - The offset of the file geoms in the asset.
   * @param {any} geomsRange - The range of geoms in the bin file.
   * @private
   */
  __recieveGeomDatas(key, geomDatas, geomIndexOffset, geomsRange) {
    // We are storing a subset of the geoms from a binary file
    // which is a subset of the geoms in an asset.
    // geomIndexOffset: the offset of the file geoms in the asset.
    // geomsRange: the range of geoms in the bin file.
    const offset = geomIndexOffset + geomsRange[0];
    const storedRange = [offset, geomIndexOffset + geomsRange[1]];

    for (let i = 0; i < geomDatas.length; i++) {
      const geomData = geomDatas[i];
      if (!geomData.type) continue
      let proxy;
      switch (geomData.type) {
        case 'Points':
          proxy = new PointsProxy(geomData);
          break
        case 'Lines':
          proxy = new LinesProxy(geomData);
          break
        case 'Mesh':
        case 'Plane': // TODO: Support procedural shape params
        case 'Sphere':
        case 'Cone':
          proxy = new MeshProxy(geomData);
          break
        default:
          throw new Error('Unsupported Geom type:' + className)
      }
      this.geoms[offset + i] = proxy;
    }
    this.emit('rangeLoaded', { range: storedRange });

    const loaded = storedRange[1] - storedRange[0];
    // console.log("GeomLibrary Loaded:" + loaded);

    // Each file in the stream has its own counter for the number of
    // geoms, and once each stream file finishes parsing, we fire a signal.
    const streamInfo = this.__streamInfos[key];
    streamInfo.done += loaded;
    // console.log(key + " Loaded:" + streamInfo.done + " of :" + streamInfo.total);
    if (streamInfo.done == streamInfo.total) {
      this.emit('streamFileParsed', { count: 1 });
    }

    // Once all the geoms from all the files are loaded and parsed
    // fire the loaded signal.
    this.__loaded += loaded;
    // console.log("this.__loaded:" + this.__loaded +" this.__numGeoms:" + this.__numGeoms);
    if (this.__loaded == this.__numGeoms) {
      // console.log("GeomLibrary Loaded:" + this.__name + " count:" + geomDatas.length + " loaded:" + this.__loaded);
      this.__terminateWorkers();
      this.emit('loaded');
    }
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistences.
   * @return {object} - Returns the json object.
   */
  toJSON() {
    return {
      numGeoms: this.geoms.length(),
    }
  }

  /**
   * The toString method.
   * @return {any} - The return value.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }
}

/** Class representing a material library in a scene tree.
 * @private
 */
class MaterialLibrary extends EventEmitter {
  /**
   * Create a material library.
   * @param {string} name - The name of the material library.
   */
  constructor(name = 'MaterialLibrary') {
    super();
    this.__name = name;

    this.lod = 0;
    if (SystemDesc.isMobileDevice) this.lod = 1;
    this.clear();
  }

  /**
   * The clear method.
   */
  clear() {
    this.__images = {};
    this.__materials = {
      Default: new Material('Default', 'SimpleSurfaceShader'),
    };
  }

  /**
   * The getPath method.
   * @return {any} - The return value.
   */
  getPath() {
    return [this.__name]
  }

  /**
   * The getNumMaterials method.
   * @return {any} - The return value.
   */
  getNumMaterials() {
    return Object.keys(this.__materials).length
  }

  /**
   * The getMaterials method.
   * @return {any} - The return value.
   */
  getMaterials() {
    return Object.values(this.__materials)
  }

  /**
   * The getMaterialNames method.
   * @return {any} - The return value.
   */
  getMaterialNames() {
    const names = [];
    for (const name in this.__materials) {
      names.push(name);
    }
    return names
  }

  /**
   * The hasMaterial method.
   * @param {string} name - The name value.
   * @return {any} - The return value.
   */
  hasMaterial(name) {
    return name in this.__materials
  }

  /**
   * Add a material.
   * @param {Material} material - The material value.
   */
  addMaterial(material) {
    material.setOwner(this);
    this.__materials[material.getName()] = material;
  }

  /**
   * The getMaterial method.
   * @param {string} name - The material name.
   * @param {Boolean} assert - The assert value.
   * @return {any} - The return value.
   */
  getMaterial(name, assert = true) {
    const res = this.__materials[name];
    if (!res && assert) {
      throw new Error('Material:' + name + ' not found in library:' + this.getMaterialNames())
    }
    return res
  }

  /**
   * The hasImage method.
   * @param {string} name - The material name.
   * @return {any} - The return value.
   */
  hasImage(name) {
    return name in this.__images
  }

  /**
   * The addImage method.
   * @param {any} image - The image value.
   */
  addImage(image) {
    image.setOwner(this);
    this.__images[image.getName()] = image;
  }

  /**
   * The getImage method.
   * @param {string} name - The material name.
   * @param {boolean} assert - The assert value.
   * @return {any} - The return value.
   */
  getImage(name, assert = true) {
    const res = this.__images[name];
    if (!res && assert) {
      throw new Error('Image:' + name + ' not found in library:' + this.getImageNames())
    }
    return res
  }

  /**
   * The getImageNames method.
   * @return {any} - The return value.
   */
  getImageNames() {
    const names = [];
    for (const name in this.__images) {
      names.push(name);
    }
    return names
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The load method.
   * @param {any} filePath - The file path.
   */
  load(filePath) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', filePath, true);
    xhr.ontimeout = () => {
      throw new Error('The request for ' + filePath + ' timed out.')
    };
    xhr.onload = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          this.fromJSON(JSON.parse(xhr.responseText));
        } else {
          console.warn(xhr.statusText);
        }
      }
    };
    xhr.send(null);
  }

  /**
   * The toJSON method encodes the current object as a json object.
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context = {}) {
    return {
      numMaterials: this.geoms.length(),
    }
  }

  /**
   * The fromJSON method decodes a json object for this type.
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(j, context = {}) {
    context.lod = this.lod;
    for (const name in j.textures) {
      const image = new FileImage$1(name);
      image.fromJSON(j.textures[name]);
      this.__images[name] = texture;
    }
    for (const name in j.materials) {
      const material = new Material(name);
      material.fromJSON(j.materials[name]);
      this.addMaterial(material);
    }
  }

  /**
   * The readBinary method.
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context = {}) {
    // if (context.version == undefined) context.version = 0

    this.name = reader.loadStr();

    // Specify the Lod to load the images in this library.
    context.lod = this.lod;
    context.materialLibrary = this;

    const numTextures = reader.loadUInt32();
    for (let i = 0; i < numTextures; i++) {
      const type = reader.loadStr();
      const texture = Registry.constructClass(type, undefined);
      texture.readBinary(reader, context);
      this.__images[texture.getName()] = texture;
    }
    const numMaterials = reader.loadUInt32();
    if (numMaterials > 0) {
      const toc = reader.loadUInt32Array(numMaterials);
      for (let i = 0; i < numMaterials; i++) {
        const material = new Material('');
        reader.seek(toc[i]); // Reset the pointer to the start of the item data.
        material.readBinary(reader, context, this.__images);
        this.addMaterial(material);
      }
    }

    this.emit('loaded', {});
  }

  /**
   * The toString method.
   * @return {any} - The return value.
   */
  toString() {
    return JSON.stringify(this.toJSON(), null, 2)
  }
}

/**
 * Represents a TreeItem with rendering and material capabilities.
 *
 * @extends TreeItem
 */
class AssetItem extends TreeItem {
  /**
   * Create an asset item.
   * @param {string} name - The name of the asset item.
   */
  constructor(name) {
    super(name);

    this.__geomLibrary = new GeomLibrary();
    this.__materials = new MaterialLibrary();
    this.loaded = false;
  }

  /**
   * Returns the loaded status of current item.
   *
   * @return {boolean} - Returns true if the asset has already loaded its data.
   */
  isLoaded() {
    return this.loaded
  }

  /**
   * Returns the zea engine version as an array with major, minor, patch order.
   *
   * @return {array} - The return value.
   */
  getEngineDataVersion() {
    return this.__engineDataVersion
  }

  /**
   * Returns asset `GeomLibrary` that is in charge of rendering geometry data using workers.
   *
   * @return {GeomLibrary} - The return value.
   */
  getGeometryLibrary() {
    return this.__geomLibrary
  }

  /**
   * Returns `MaterialLibrary` that is in charge of storing all materials of current Item.
   *
   * @return {MaterialLibrary} - The return value.
   */
  getMaterialLibrary() {
    return this.__materials
  }

  /**
   * Returns the scale factor of current item.
   * @return {number} - The return value.
   */
  getUnitsConversion() {
    return this.__unitsScale
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * The readBinary method.
   * @param {object} reader - The reader value.
   * @param {object} context - The context value.
   */
  readBinary(reader, context = {}) {
    context.assetItem = this;
    context.numTreeItems = 0;
    context.numGeomItems = 0;

    if (!context.versions['zea-engine']) {
      context.versions['zea-engine'] = new Version(reader.loadStr());
    }
    this.__engineDataVersion = context.versions['zea-engine'];
    console.log('Loading Engine File version:', context.versions['zea-engine']);

    let layerRoot;
    const layers = {};
    context.addGeomToLayer = (geomItem, layer) => {
      if (!layers[layer]) {
        if (!layerRoot) {
          layerRoot = new TreeItem('Layers');
          this.addChild(layerRoot, false);
        }
        const group = new Group(layer);
        group.propagateXfoToItems = false;
        layerRoot.addChild(group, false);
        layers[layer] = group;
      }
      layers[layer].addItem(geomItem);
    };
    const loadUnits = () => {
      this.__units = reader.loadStr();
      // Calculate a scale factor to convert
      // the asset units to meters(the scene units)
      let scaleFactor = 1.0;
      switch (this.__units) {
        case 'Millimeters':
          scaleFactor = 0.001;
          break
        case 'Centimeters':
          scaleFactor = 0.01;
          break
        case 'Meters':
          scaleFactor = 1.0;
          break
        case 'Kilometers':
          scaleFactor = 1000.0;
          break
        case 'Inches':
          scaleFactor = 0.0254;
          break
        case 'Feet':
          scaleFactor = 0.3048;
          break
        case 'Miles':
          scaleFactor = 1609.34;
          break
      }
      this.__unitsScale = scaleFactor;

      // Apply units change to existing Xfo (avoid changing tr).
      const localXfoParam = this.getParameter('LocalXfo');
      const xfo = localXfoParam.getValue();
      xfo.sc.scaleInPlace(scaleFactor);
      localXfoParam.setValue(xfo);
    };

    if (context.versions['zea-engine'].greaterThan([0, 0, 6])) {
      // Loading units modifies our Xfo, which then propagates up
      // the tree forcing a re-computation. Better just do it at
      // the start.
      loadUnits();
    }

    this.__materials.readBinary(reader, context);

    super.readBinary(reader, context);

    if (
      context.versions['zea-engine'].greaterOrEqualThan([0, 0, 5]) &&
      context.versions['zea-engine'].lessThan([0, 0, 7])
    ) {
      loadUnits();
    }

    // console.log("numTreeItems:", context.numTreeItems, " numGeomItems:", context.numGeomItems)
  }

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context = {}) {
    context.makeRelative = (path) => {
      const assetPath = this.getPath();
      const start = path.slice(0, assetPath.length);
      for (let i = 0; i < start.length - 1; i++) {
        if (start[i] != assetPath[i]) {
          console.warn('Param Path is not relative to the asset. May not be able to be resolved at load time:' + path);
          return path
        }
      }
      // Relative paths start with a symbol for the root element.
      const relativePath = path.slice(assetPath.length - 1);
      relativePath[0] = '.';
      return relativePath
    };
    context.assetItem = this;
    const j = super.toJSON(context);
    return j
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   * @param {function} onDone - Callback function executed when everything is done.
   */
  fromJSON(j, context = {}, onDone) {
    if (!context) context = {};

    context.assetItem = this;
    context.numTreeItems = 0;
    context.numGeomItems = 0;
    if (context.version == undefined) context.version = 0;

    context.assetItem = this;

    const plcbs = []; // Post load callbacks.
    context.resolvePath = (path, cb) => {
      // Note: Why not return a Promise here?
      // Promise evaluation is always async, so
      // all promisses will be resolved after the current call stack
      // has terminated. In our case, we want all paths
      // to be resolved before the end of the function, which
      // we can handle easily with callback functions.
      if (!path) throw new Error('Path not spcecified')
      const item = this.resolvePath(path);
      if (item) {
        cb(item);
      } else {
        // Some paths resolve to items generated during load,
        // so push a callback to re-try after the load is complete.
        plcbs.push(() => {
          const param = this.resolvePath(path);
          if (param) cb(param);
          else {
            console.warn('Path unable to be resolved:' + path);
          }
        });
      }
    };
    context.addPLCB = (plcb) => plcbs.push(plcb);

    // Avoid loading the FilePath as we are already loading json data.
    // if (j.params && j.params.FilePath) {
    //   delete j.params.FilePath
    // }

    super.fromJSON(j, context);

    // Invoke all the post-load callbacks to resolve any
    // remaning references.
    for (const cb of plcbs) cb();

    if (onDone) onDone();
  }
}

Registry.register('AssetItem', AssetItem);

/**
 * A special type of TreeItem(Item with hierarchical abilities) class that represents a banner in a 2D dimension.
 * Can own any type of `BaseImage`.
 * <br>
 * <br>
 * **Parameters**
 * * **Image(`ImageParameter`):** Is the BaseImage you want to display on the board.
 * * **PixelsPerMeter(`NumberParameter`):** Quality and Size of the board. The bigger the number, the smaller the board.
 * * **Alpha(`NumberParameter`):** Transparency of the board, from 0 to 1.
 * * **AlignedToCamera(`BooleanParameter`):** Faces or not the board to the camera at all time(Moves with camera movement).
 * * **DrawOnTop(`BooleanParameter`):** _todo_
 *
 * @extends TreeItem
 */
class BillboardItem extends TreeItem {
  /**
   * Creates a billboard item.
   *
   * @param {string} name - The name of the billboard item.
   * @param {BaseImage} image - The image value.
   */
  constructor(name, image) {
    super(name);
    const imageParam = this.addParameter(new ImageParameter('Image'));
    if (image) imageParam.setValue(image); // Note: this dirties the param and will ensure it is saved to JSON
    this.addParameter(new NumberParameter('PixelsPerMeter', 1000.0));
    this.addParameter(new NumberParameter('Alpha', 1.0));
    this.addParameter(new ColorParameter('Color', new Color(1.0, 1.0, 1.0)));
    this.addParameter(new BooleanParameter('AlignedToCamera', false));
    this.addParameter(new BooleanParameter('DrawOnTop', false));
  }
}

Registry.register('BillboardItem', BillboardItem);

/* eslint-disable no-unused-vars */

/**
 * Represents a view of the scene vertex coordinates. Since it is a `TreeItem`,
 * translation modifiers are supported, so you can move the camera around.
 *
 * **Parameters**
 * * **isOrthographic(`BooleanParameter`):** Special type of view that represents 3D objects in two dimensions; `true` to enable.
 * * **fov(`NumberParameter`):** _todo_
 * * **near(`NumberParameter`):** _todo_
 * * **far(`NumberParameter`):** _todo_
 * * **focalDistance(`NumberParameter`):** _todo_
 *
 * **Events**
 * * **projectionParamChanged:** _todo_
 * * **movementFinished:** Triggered when framing all the objects.
 * @extends TreeItem
 */
class Camera extends TreeItem {
  /**
   * Instantiates a camera object, setting default configuration like zoom, target and positioning.
   *
   * @param {string} name - The name of the camera.
   */
  constructor(name = undefined) {
    if (name == undefined) name = 'Camera';
    super(name);

    this.__isOrthographicParam = this.addParameter(new BooleanParameter('isOrthographic', false));
    this.__fovParam = this.addParameter(new NumberParameter('fov', 1.0));
    this.__nearParam = this.addParameter(new NumberParameter('near', 0.1));
    this.__farParam = this.addParameter(new NumberParameter('far', 1000.0));
    this.__focalDistanceParam = this.addParameter(new NumberParameter('focalDistance', 5.0));

    // this.__viewMatParam = this.addParameter(new Parameter('viewMat', new Mat4()));
    // const _cleanViewMat = (xfo)=>{
    //     return this.__globalXfoParam.getValue().inverse().toMat4();
    // }
    // this.__globalXfoParam.on('valueChanged', (changeType)=>{
    //     this.__viewMatParam.setDirty(_cleanViewMat);
    // });

    const emitProjChanged = (event) => {
      this.emit('projectionParamChanged', event);
    };
    this.__isOrthographicParam.on('valueChanged', emitProjChanged);
    this.__fovParam.on('valueChanged', emitProjChanged);
    this.__nearParam.on('valueChanged', emitProjChanged);
    this.__farParam.on('valueChanged', emitProjChanged);

    // Initial viewing coords of a person standing 3 meters away from the
    // center of the stage looking at something 1 meter off the ground.
    this.setPositionAndTarget(new Vec3$1(3, 3, 1.75), new Vec3$1(0, 0, 1));
    this.setLensFocalLength('28mm');
  }

  // ////////////////////////////////////////////
  // Getters/setters.

  /**
   * Returns `near` parameter value.
   *
   * @return {number} - Returns the near value.
   */
  getNear() {
    return this.__nearParam.getValue()
  }

  /**
   * Sets `near` parameter value
   *
   * @param {number} value - The near value.
   */
  setNear(value) {
    this.__nearParam.setValue(value);
  }

  /**
   * Returns `far` parameter value.
   *
   * @return {number} - Returns the far value.
   */
  getFar() {
    return this.__farParam.getValue()
  }

  /**
   * Sets `far` parameter value
   *
   * @param {number} value - The far value.
   */
  setFar(value) {
    this.__farParam.setValue(value);
  }

  /**
   * Getter for the camera field of view (FOV).
   * The FOV is how much of the scene the camera can see at once.
   *
   * @return {number} - Returns the FOV value.
   */
  getFov() {
    return this.__fovParam.getValue()
  }

  /**
   * Setter for the camera field of view (FOV).
   * The FOV is how much of the scene the camera can see at once.
   *
   * @param {number} value - The FOV value.
   */
  setFov(value) {
    this.__fovParam.setValue(value);
  }

  /**
   * Setter for the camera lens focal length. Updates `fov` parameter value after a small math procedure.
   *
   * **Focal Lenth accepted values:** 10mm, 11mm, 12mm, 14mm, 15mm, 17mm, 18mm,
   * 19mm, 20mm, 24mm, 28mm, 30mm, 35mm, 45mm, 50mm, 55mm, 60mm, 70mm, 75mm, 80mm,
   * 85mm, 90mm, 100mm, 105mm, 120mm, 125mm, 135mm, 150mm, 170mm, 180mm, 210mm, 300mm,
   * 400mm, 500mm, 600mm, 800mm
   *
   * @param {string} value - The lens focal length value.
   */
  setLensFocalLength(value) {
    // https://www.nikonians.org/reviews/fov-tables
    const mapping = {
      '10mm': 100.4,
      '11mm': 95.0,
      '12mm': 90.0,
      '14mm': 81.2,
      '15mm': 77.3,
      '17mm': 70.4,
      '18mm': 67.4,
      '19mm': 64.6,
      '20mm': 61.9,
      '24mm': 53.1,
      '28mm': 46.4,
      '30mm': 43.6,
      '35mm': 37.8,
      '45mm': 29.9,
      '50mm': 27.0,
      '55mm': 24.6,
      '60mm': 22.6,
      '70mm': 19.5,
      '75mm': 18.2,
      '80mm': 17.1,
      '85mm': 16.1,
      '90mm': 15.2,
      '100mm': 13.7,
      '105mm': 13.0,
      '120mm': 11.4,
      '125mm': 11.0,
      '135mm': 10.2,
      '150mm': 9.1,
      '170mm': 8.1,
      '180mm': 7.6,
      '210mm': 6.5,
      '300mm': 4.6,
      '400mm': 3.4,
      '500mm': 2.7,
      '600mm': 2.3,
      '800mm': 1.7,
    };
    if (!value in mapping) {
      console.warn('Camera lense focal length not suported:' + value);
      return
    }
    this.__fovParam.setValue(MathFunctions.degToRad(mapping[value]));
  }

  /**
   * Returns `focalDistance` parameter value.
   *
   * @return {number} - Returns the lens focal length value..
   */
  getFocalDistance() {
    return this.__focalDistanceParam.getValue()
  }

  /**
   * Sets `focalDistance` parameter value.
   *
   * @errors on dist value lower or less than zero.
   * @param {number} dist - The focal distance value.
   */
  setFocalDistance(dist) {
    if (dist < 0.0001) console.error('Never set focal distance to zero');
    this.__focalDistanceParam.setValue(dist);
    this.__nearParam.setValue(dist * 0.01);
    this.__farParam.setValue(dist * 200.0);
  }

  /**
   * Returns `isOrthographic` parameter value.
   * @return {boolean} - The return value.
   */
  getIsOrthographic() {
    return this.__isOrthographicParam.getValue()
  }

  /**
   * Sets `focalDistance` parameter value.
   *
   * @param {boolean} value - The value param.
   */
  setIsOrthographic(value) {
    this.__isOrthographicParam.setValue(value);
  }

  /**
   * Setter for the camera postion and target.
   * As described at the start of the class, this is a `TreeItem`,
   * which means we can move it around using translation modifiers.
   * You can do it this way or using the changing `TreeItem` parameters,
   * although we recommend this one because it also changes focal distance.
   *
   * @param {Vec3} position - The position of the camera.
   * @param {Vec3} target - The target of the camera.
   */
  setPositionAndTarget(position, target) {
    this.setFocalDistance(position.distanceTo(target));
    const xfo = new Xfo();
    xfo.setLookAt(position, target, new Vec3$1(0.0, 0.0, 1.0));
    this.getParameter('GlobalXfo').setValue(xfo);
  }

  /**
   * Getter for the target position.
   * @return {Vec3} - Returns the target position.
   */
  getTargetPostion() {
    const focalDistance = this.__focalDistanceParam.getValue();
    const xfo = this.getParameter('GlobalXfo').getValue();
    const target = xfo.ori.getZaxis();
    target.scaleInPlace(-focalDistance);
    target.addInPlace(xfo.tr);
    return target
  }

  // ///////////////////////////

  /**
   * Calculates a new bounding box for all the items passed in `treeItems` array
   * and moves the camera to a point where we can see all of them, preserving parameters configurations.
   *
   * @param {GLBaseViewport} viewport - The viewport value.
   * @param {array} treeItems - The treeItems value.
   */
  frameView(viewport, treeItems) {
    const boundingBox = new Box3$1();
    for (const treeItem of treeItems) {
      boundingBox.addBox3(treeItem.getParameter('BoundingBox').getValue());
    }

    if (!boundingBox.isValid()) {
      console.warn('Bounding box not valid.');
      return
    }
    const focalDistance = this.__focalDistanceParam.getValue();
    const fovY = this.__fovParam.getValue();

    const globalXfo = this.getParameter('GlobalXfo').getValue().clone();
    const cameraViewVec = globalXfo.ori.getZaxis();
    const targetOffset = cameraViewVec.scale(-focalDistance);
    const currTarget = globalXfo.tr.add(targetOffset);
    const newTarget = boundingBox.center();

    const pan = newTarget.subtract(currTarget);
    globalXfo.tr.addInPlace(pan);

    // Transform the bounding box into camera space.
    const transformedBBox = new Box3$1();
    transformedBBox.addBox3(boundingBox, globalXfo.inverse());
    const camSpaceTarget = transformedBBox.center();

    const fovX = fovY * (viewport.getWidth() / viewport.getHeight());

    // p1 is the closest corner of the transformed bbox.
    const p = transformedBBox.p1;
    const newFocalDistanceX = (Math.abs(p.x) / Math.tan(0.5 * fovX)) * 1.2;
    const newFocalDistanceY = (Math.abs(p.y) / Math.tan(0.5 * fovY)) * 1.2;

    const camSpaceBBoxDepth = (transformedBBox.p0.z - transformedBBox.p1.z) * -0.5;
    const newFocalDistance = Math.max(newFocalDistanceX, newFocalDistanceY) + camSpaceBBoxDepth;

    const dollyDist = newFocalDistance - focalDistance;
    globalXfo.tr.addInPlace(cameraViewVec.scale(dollyDist));

    this.setFocalDistance(newFocalDistance);
    this.getParameter('GlobalXfo').setValue(globalXfo);
    this.emit('movementFinished');
  }

  /**
   * Sets camera perspective from a Mat4 object.
   *
   * @param {Mat4} mat - The mat value.
   * @param {number} aspect - The aspect value.
   */
  updateProjectionMatrix(mat, aspect) {
    const isOrthographic = this.__isOrthographicParam.getValue();
    const fov = this.__fovParam.getValue();
    const near = this.__nearParam.getValue();
    const far = this.__farParam.getValue();
    mat.setPerspectiveMatrix(fov, aspect, near, far);
  }
}

Registry.register('Camera', Camera);

/**
 * Class in charge of loading file resources, holding a reference to all of them.
 * Manages workers, callbacks, resource tree and entities.
 *
 * @private
 */
class DriveAdapter {
  /**
   * Create a resource loader.
   */
  constructor(resources) {
    this.__resources = {};
    this.__resourcesTreeEntities = {};
    this.__resourcesTree = {
      children: {},
    };
    this.__resourceRegisterCallbacks = {};

    let baseUrl;
    if (globalThis.navigator) {
      const scripts = document.getElementsByTagName('script');
      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];
        if (script.src.includes('zea-engine')) {
          const parts = script.src.split('/');
          parts.pop();
          parts.pop();
          baseUrl = parts.join('/');
          break
        }
      }
      if (!baseUrl) {
        baseUrl = 'https://unpkg.com/@zeainc/zea-engine@0.1.3';
      }
      this.addResourceURL('ZeaEngine/Vive.vla', baseUrl + '/public-resources/Vive.vla');
      this.addResourceURL('ZeaEngine/Oculus.vla', baseUrl + '/public-resources/Oculus.vla');
    }

    if (!baseUrl) {
      baseUrl = 'https://unpkg.com/@zeainc/zea-engine@0.1.3';
    }
    this.addResourceURL('ZeaEngine/Vive.vla', baseUrl + '/public-resources/Vive.vla');
    this.addResourceURL('ZeaEngine/Oculus.vla', baseUrl + '/public-resources/Oculus.vla');

    if (resources) {
      this.setResources(resources);
    }
  }

  /**
   * Returns the resources tree object.
   *
   * @return {object} - The return value.
   */
  getRootFolder() {
    return this.__resourcesTree
  }

  /**
   * The registerResourceCallback method.
   * @param {string} filter - The filter value.
   * @param {function} fn - The fn value.
   */
  registerResourceCallback(filter, fn) {
    this.__resourceRegisterCallbacks[filter] = fn;
    // eslint-disable-next-line guard-for-in
    for (const key in this.__resources) {
      const file = this.__resources[key];
      if (file.name.includes(filter)) fn(file);
    }
  }

  /**
   * The __applyCallbacks method.
   * @param {object} resourcesDict - The resourcesDict value.
   * @private
   */
  __applyCallbacks(resourcesDict) {
    const applyCallbacks = (resource) => {
      for (const filter in this.__resourceRegisterCallbacks) {
        if (resource.name.includes(filter)) this.__resourceRegisterCallbacks[filter](resource);
      }
    };
    for (const key in resourcesDict) {
      const resource = resourcesDict[key];
      if (resource.url) applyCallbacks(resource);
    }
  }

  /**
   * The __buildTree method.
   * @param {object} resources - The resources param.
   * @private
   */
  __buildTree(resources) {
    const buildEntity = (resourceId) => {
      if (this.__resourcesTreeEntities[resourceId]) return

      const resource = resources[resourceId];
      resource.id = resourceId;
      if (resource.type === 'folder' || resource.type === 'dependency') {
        resource.children = {};
      }
      if (resource.parent) {
        if (!this.__resourcesTreeEntities[resource.parent]) {
          buildEntity(resource.parent);
        }
      }
      const parent = resource.parent ? this.__resourcesTreeEntities[resource.parent] : this.__resourcesTree;
      // console.log((parent.name ? parent.name + '/' : '') + resource.name)
      parent.children[resource.name] = resource;
      this.__resourcesTreeEntities[resourceId] = resource;
    };

    // eslint-disable-next-line guard-for-in
    for (const key in resources) {
      buildEntity(key);
    }
  }

  /**
   * The setResources method.
   * @param {object} resources - The resources value.
   */
  setResources(resources) {
    this.__resources = Object.assign(this.__resources, resources);
    this.__buildTree(resources);
    this.__applyCallbacks(resources);
  }

  /**
   * The addResourceURL method.
   * @param {string} resourcePath - The resourcePath value.
   * @param {string} url - The url value.
   */
  addResourceURL(resourcePath, url) {
    const parts = resourcePath.split('/');
    const filename = parts.pop();
    if (!url) {
      let rootURL = window.location.href.split('#')[0];
      rootURL = rootURL.split('?')[0];
      if (rootURL.endsWith('.html') || rootURL.endsWith('.html')) {
        rootURL = rootURL.substring(0, rootURL.lastIndexOf('/')) + '/';
      }
      const base = rootURL;
      if (parts[0] == '.') parts.shift();
      else if (parts[0] == '..') {
        item = item.substring(3);
        const baseparts = base.split('/');
        baseparts.pop();
        baseparts.pop();
        base = baseparts.join('/') + '/';
      }
      url = base + resourcePath;
    }
    let parentId;
    const tmp = {};
    for (const part of parts) {
      const key = StringFunctions.hashStr(part);
      if (!(key in this.__resources)) {
        this.__resources[key] = {
          name: part,
          type: 'folder',
          parent: parentId,
        };
        tmp[key] = this.__resources[key];
      }
      parentId = key;
    }

    const key = StringFunctions.hashStr(filename);
    const resource = {
      name: filename,
      url,
      parent: parentId,
      id: key,
    };
    this.__resources[key] = resource;

    tmp[key] = resource;

    this.__buildTree(tmp);
    this.__applyCallbacks(tmp);
  }

  /**
   * The updateFile method.
   * @param {object} file - The file value.
   */
  updateFile(file) {
    const newFile = !(file.id in this.__resources);
    this.__resources[file.id] = file;
    if (newFile) {
      console.log('New file added');
      const resources = {};
      resources[file.id] = file;
      this.__buildTree(resources);
    }
    this.emit('fileUpdated', { fileId: file.id });
  }

  /**
   * Returns complete file path.
   *
   * @param {string} resourceId - The resourceId value.
   * @return {string} - The return value.
   */
  getFilepath(resourceId) {
    let curr = this.__resources[resourceId];
    const path = [curr.name];
    while (curr.parent) {
      curr = this.__resources[curr.parent];
      path.splice(0, 0, curr.name);
    }
    return path.join('/')
  }

  /**
   * The resourceAvailable method.
   *
   * @param {string} resourceId - The resourceId value.
   * @return {boolean} - The return value.
   */
  resourceAvailable(resourceId) {
    if (resourceId.indexOf('.') > 0) {
      console.warn('Deprecation warning for resourceAvailable. Value should be a file id, not a path.');
      return this.resolveFilepath(resourceId) != undefined
    }
    return resourceId in this.__resources
  }

  /**
   * The getFile method.
   * @param {string} resourceId - The resourceId value.
   * @return {object} - The return value.
   */
  getFile(resourceId) {
    return this.__resources[resourceId]
  }

  /**
   * The resolveFilepath method.
   * @param {string} filePath - The filePath value.
   * @return {object} - The return value.
   */
  resolveFileId(value) {
    const parts = value.split('/');
    if (parts[0] == '.' || parts[0] == '') parts.shift();
    let curr = this.__resourcesTree;
    for (const part of parts) {
      if (part in curr.children) curr = curr.children[part];
      else {
        throw new Error('Unable to resolve key:' + part + ' of path:' + value)
      }
    }
    return curr.id
  }

  /**
   * The resolveFilename method.
   * @deprecated
   * @param {string} value - The file value.
   * @return {string} - The resolved URL if an adapter is installed, else the original value.
   */
  resolveFilename(value) {
    return this.__resources[value].name
  }

  /**
   * The resolveURL method.
   * @deprecated
   * @param {string} value - The file value.
   * @return {string} - The resolved URL if an adapter is installed, else the original value.
   */
  resolveURL(value) {
    return this.__resources[value].url
  }

  /**
   * The traverse method.
   * @param {function} callback - The callback value.
   */
  traverse(callback) {
    const __c = (fsItem) => {
      // eslint-disable-next-line guard-for-in
      for (const childItemName in fsItem.children) {
        __t(fsItem.children[childItemName]);
      }
    };
    const __t = (fsItem) => {
      if (callback(fsItem) == false) return false
      if (fsItem.children) __c(fsItem);
    };
    __c(this.__resourcesTree);
  }
}

/**
 * `BaseItem` type of class
 *
 * **Parameters**
 * * **BackgroundColor(`ColorParameter`):** Changes background color of the scene
 * * **EnvMap(`ImageParameter`):** _todo_
 * * **Display(`BooleanParameter`):** _todo_
 * * **EnvMapLOD(`NumberParameter`):** _todo_
 * @extends BaseItem
 */
class SceneSettings extends BaseItem {
  /**
   * Create scene settings.
   * @param {string} name - The name of the scene settings item.
   */
  constructor(name) {
    super(name);
    this.addParameter(new ColorParameter('BackgroundColor', new Color('#808080')));
    this.addParameter(new ImageParameter('EnvMap'));
    this.addParameter(new BooleanParameter('Display EnvMap', false));
    this.addParameter(new NumberParameter('EnvMapLOD', 0));
  }
}

/**
 * Class designed to load and handle `.vla` files.
 * Which facilitates the migration of geometries from third party applications to the Digistar planetarium dome projection.
 *
 * **Parameters**
 * * **DataFilePath(`FilePathParameter`):** Used to specify the path to the file.
 *
 * **Events**
 * * **loaded:** Triggered once everything is loaded.
 * * **geomsLoaded:** Triggered once all geometries are loaded.
 *
 * @extends AssetItem
 */
class VLAAsset$1 extends AssetItem {
  /**
   * Create a VLA asset.
   * @param {string} name - The name value.
   */
  constructor(name) {
    super(name);
    this.loaded = false;

    // A signal that is emitted once all the geoms are loaded.
    // Often the state machine will activate the first state
    // when this signal emits.
    this.geomsLoaded = false;
    this.loaded = false;
    this.__geomLibrary.on('loaded', () => {
      this.emit('geomsLoaded', {});
    });

    this.__datafileParam = this.addParameter(new FilePathParameter('DataFilePath'));
    this.__datafileParam.on('valueChanged', () => {
      this.geomsLoaded = false;
      this.loadDataFile(
        () => {
          if (!this.loaded) this.emit('loaded', {});
        },
        () => {
          // if(!this.loaded){
          //   this.emit('loaded', {});
          // }
          // this.emit('geomsLoaded', {})
        }
      );
    });
  }

  // ////////////////////////////////////////
  // Persistence

  /**
   * Sets state of current asset using a binary reader object.
   *
   * @param {BinReader} reader - The reader value.
   * @param {object} context - The context value.
   * @return {number} - The return value.
   */
  readBinary(reader, context) {
    if (context.versions['zea-engine']) ; else {
      const v = reader.loadUInt8();
      reader.seek(0);
      // Note: previous non-semver only reached 7
      if (v > 7) {
        const version = new Version();
        version.patch = reader.loadUInt32();
        context.versions['zea-engine'] = version;
      } else {
        // Now we split the mesh out from the engine version.
        context.versions['zea-engine'] = new Version(reader.loadStr());
      }
    }
    context.meshSdk = 'FBX';
    this.meshfileversion = context.versions['zea-mesh'];
    this.meshSdk = context.meshSdk;
    console.log('Loading CAD File version:', context.versions['zea-mesh'], ' exported using SDK:', context.meshSdk);

    const numGeomsFiles = reader.loadUInt32();

    super.readBinary(reader, context);

    // Strangely, reading the latest HMD files gives us 12 bytes
    // at the end and the next 4 == 0. Not sure why.
    // setNumGeoms sets 0, but this doesn't bother the loading
    // so simply leaving for now.
    // if (reader.remainingByteLength != 4) {
    //   throw new Error(
    //     'File needs to be re-exported:' +
    //       this.getParameter('FilePath').getValue()
    //   )
    // }

    // Perpare the geom library for loading
    // This helps with progress bars, so we know how many geoms are coming in total.
    // Note: the geom library encodes in its binary buffer the number of geoms.
    // No need to set it here. (and the number is now incorrect for a reason I do not understand.)

    // if (context.version < 5) {
    if (context.versions['zea-engine'].compare([0, 0, 5]) < 0) {
      // Some data is no longer being read at the end of the buffer
      // so we skip to the end here.
      reader.seek(reader.byteLength - 4);
    }
    this.__geomLibrary.setNumGeoms(reader.loadUInt32());

    return numGeomsFiles
  }

  /**
   * Loads all the geometries and metadata from the `.vla` file.
   *
   * @private
   * @param {function} onDone - The onDone value.
   * @param {function} onGeomsDone - The onGeomsDone value.
   */
  loadDataFile(onDone, onGeomsDone) {
    const fileId = this.__datafileParam.getValue();
    const url = this.__datafileParam.getUrl();
    const folder = url.lastIndexOf('/') > -1 ? url.substring(0, url.lastIndexOf('/')) + '/' : '';
    const filename = url.lastIndexOf('/') > -1 ? url.substring(url.lastIndexOf('/') + 1) : '';
    const stem = filename.substring(0, filename.lastIndexOf('.'));
    let numGeomsFiles = 0;

    const context = {
      assetItem: this,
      versions: {},
    };

    const loadBinary = (entries) => {
      // Load the tree file. This file contains
      // the scene tree of the asset, and also
      // tells us how many geom files will need to be loaded.

      let treeReader;
      if (entries.tree2) {
        treeReader = new BinReader(entries.tree2.buffer, 0, SystemDesc.isMobileDevice);
      } else {
        const entry = entries.tree ? entries.tree : entries[Object.keys(entries)[0]];
        treeReader = new BinReader(entry.buffer, 0, SystemDesc.isMobileDevice);
        context.versions['zea-engine'] = new Version();
      }

      // Necessary for the smart lok
      numGeomsFiles = this.readBinary(treeReader, context);

      onDone();

      if (numGeomsFiles == 0 && entries.geoms0) {
        resourceLoader.addWork(fileId, 1); // (load + parse + extra)
        this.__geomLibrary.readBinaryBuffer(fileId, entries.geoms0.buffer, context);
        onGeomsDone();
      } else {
        // add the work for the the geom files....
        resourceLoader.addWork(fileId, 4 * numGeomsFiles); // (load + parse + extra)

        // Note: Lets just load all the goem files in parallel.
        loadAllGeomFiles();
      }
    };

    const loadAllGeomFiles = () => {
      const promises = [];
      for (let geomFileID = 0; geomFileID < numGeomsFiles; geomFileID++) {
        // console.log('LoadingGeom File:', geomFileID)
        const geomFileUrl = folder + stem + geomFileID + '.vlageoms';
        promises.push(loadGeomsfile(geomFileID, geomFileUrl));
      }
      Promise.all(promises).then(() => {
        if (onGeomsDone) onGeomsDone();
      });
    };

    const loadGeomsfile = (index, geomFileUrl) => {
      return new Promise((resolve) => {
        resourceLoader.loadUrl(
          fileId + index,
          geomFileUrl,
          (entries) => {
            const geomsData = entries[Object.keys(entries)[0]];
            this.__geomLibrary.readBinaryBuffer(fileId, geomsData.buffer, context);
            resolve();
          },
          false
        ); // <----
        // Note: Don't add load work as we already pre-added it at the beginning
        // and after the Tree file was loaded...
      })
    };

    resourceLoader.loadUrl(fileId, url, loadBinary);

    // To ensure that the resource loader knows when
    // parsing is done, we listen to the GeomLibrary streamFileLoaded
    // signal. This is fired every time a file in the stream is finshed parsing.
    this.__geomLibrary.on('streamFileParsed', (event) => {
      // A chunk of geoms are now parsed, so update the resource loader.
      resourceLoader.addWorkDone(fileId, event.fraction);
    });
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} j - The json object this item must decode.
   * @param {object} context - The context value.
   * @param {function} onDone - The onDone value.
   */
  fromJSON(j, context, onDone) {
    if (!context) context = {};
    context.assetItem = this;

    const loadAssetJSON = () => {
      super.fromJSON(j, context, onDone);
      if (onDone) onDone();
    };

    if (j.params && j.params.DataFilePath) {
      // Save the callback function for later.
      this.__datafileLoaded = loadAssetJSON;
      const filePathJSON = j.params.DataFilePath;
      delete j.params.DataFilePath;
      this.__datafileParam.fromJSON(filePathJSON, context);
    } else {
      loadAssetJSON();
    }
  }
}

Registry.register('VLAAsset', VLAAsset$1);

/**
 * The GridTreeItem displays a grid of a given size and resolution. The Grid is oriented on the XY plane
 * and highlights the X and Y axes with Red and Green lines. Grids are useful in displaying scene scale and coordinate system.
 * The Grid geometry does not return a bounding box and so does not effect the bounding of the scene.
 *
 * @extends {TreeItem}
 */
class GridTreeItem extends TreeItem {
  /**
   * Creates an instance of GridTree.
   *
   * @param {number} [gridSize=5]
   * @param {number} [resolution=50]
   * @param {string} [gridColor=new Color('#DCDCDC')]
   */
  constructor(gridSize = 5, resolution = 50, gridColor = new Color('#DCDCDC')) {
    super('GridTree');

    const gridMaterial = new Material('gridMaterial', 'LinesShader');
    gridMaterial.getParameter('BaseColor').setValue(gridColor);
    const grid = new Grid(gridSize, gridSize, resolution, resolution, true);
    this.addChild(new GeomItem('GridItem', grid, gridMaterial), false);
    const axisLine = new Lines();
    axisLine.setNumVertices(2);
    axisLine.setNumSegments(1);
    axisLine.setSegmentVertexIndices(0, 0, 1);
    const positions = axisLine.getVertexAttribute('positions');
    positions.getValueRef(0).set(gridSize * -0.5, 0.0, 0.0);
    positions.getValueRef(1).set(gridSize * 0.5, 0.0, 0.0);
    const gridXAxisMaterial = new Material('gridXAxisMaterial', 'LinesShader');
    gridXAxisMaterial.getParameter('BaseColor').setValue(new Color(gridColor.luminance(), 0, 0));
    this.addChild(new GeomItem('xAxisLine', axisLine, gridXAxisMaterial), false);
    const gridZAxisMaterial = new Material('gridZAxisMaterial', 'LinesShader');
    gridZAxisMaterial.getParameter('BaseColor').setValue(new Color(0, gridColor.luminance(), 0));
    const geomOffset = new Xfo();
    geomOffset.ori.setFromAxisAndAngle(new Vec3$1(0, 0, 1), Math.PI * 0.5);
    const zAxisLineItem = new GeomItem('yAxisLine', axisLine, gridZAxisMaterial);
    zAxisLineItem.setGeomOffsetXfo(geomOffset);
    this.addChild(zAxisLineItem, false);
    this.setSelectable(false, true);
    const bBox = this._cleanBoundingBox(this.__boundingBoxParam.getValue());
    this.__boundingBoxParam.setValue(bBox);
  }

  /**
   *
   * @private
   * @param {Box3} bBox
   * @return {Box3} - Reset Bounding Box
   */
  _cleanBoundingBox(bBox) {
    bBox.reset();
    return bBox
  }
}

Registry.register('GridTreeItem', GridTreeItem);

const defaultGridColor = new Color('#DCDCDC');

/**
 * Class representing the environment where all the displayed assets live.
 */
class Scene {
  /**
   * Create a scene.
   * @param {object} resources - The resources value.
   */
  constructor(resources) {
    if (resources) {
      resourceLoader.setAdapter(new DriveAdapter(resources));
    }
    this.settings = new SceneSettings('Scene Settings');
    this.root = new TreeItem('root');
    this.root.addChild(this.settings);
  }

  /**
   * The getRoot method.
   * @return {BaseItem} - The return value.
   */
  getSettings() {
    return this.settings
  }

  /**
   * Returns the scene's root item(`TreeItem`) that owns every item in the scene.
   *
   * @return {TreeItem} - The return value.
   */
  getRoot() {
    return this.root
  }

  /**
   * Returns resourceLoader object set on class initialization.
   *
   * @return {ResourceLoader} - The return value.
   */
  getResourceLoader() {
    return resourceLoader
  }

  /**
   * Sets Environment Map with the BaseImage you'd like to display in your scene background.
   *
   * @deprecated
   * @param {EnvMap} envMap - The envMap value.
   */
  setEnvMap(envMap) {
    console.warn('Deprecated Function. Please access the Scene Settings object.');
    this.settings.getParameter('EnvMap').setValue(envMap);
  }

  /**
   * Adds a child item to the scene root item.
   *
   * @deprecated
   * @param {AssetItem} asset - The asset value.
   */
  addAsset(asset) {
    console.warn('Deprecated Function. Please access the Scene Root object.');
    this.root.addChild(asset, false);
  }

  /**
   * Sets up and displays the scene grid of a given size and resolution. The Grid is oriented on the XY plane
   * and highlights the X and Y axes with Red and Green lines. Grids are useful in displaying scene scale and coordinate system.
   * The Grid geometry does not return a bounding box and so does not effect the bounding of the scene.
   * The GridTreeItem display a grid of a given size and resolution. The Grid is oriented on the XY plane
   * and highlights the X and Y axes with Red and Green lines.
   *
   * @param {number} gridSize - The size of the grid.
   * @param {number} resolution - The resolution of the grid.
   * @param {Color} gridColor - The color of the grid.
   * @return {GridTreeItem} - The return value.
   */
  setupGrid(gridSize = 5, resolution = 50, gridColor = defaultGridColor) {
    const gridTreeItem = new GridTreeItem(gridSize, resolution, gridColor);
    this.root.addChild(gridTreeItem, false);
    return gridTreeItem
  }

  // /////////////////////////////////////
  // Persistence

  /**
   * The toJSON method encodes this type as a json object for persistence.
   *
   * @param {object} context - The context value.
   * @return {object} - Returns the json object.
   */
  toJSON(context = {}) {
    context.makeRelative = (path) => path;
    const json = {
      root: this.root.toJSON(context),
    };
    return json
  }

  /**
   * The fromJSON method decodes a json object for this type.
   *
   * @param {object} json - The json object this item must decode.
   * @param {object} context - The context value.
   */
  fromJSON(json, context = {}) {
    const plcbs = []; // Post load callbacks.
    context.resolvePath = (path, cb) => {
      // Note: Why not return a Promise here?
      // Promise evaluation is always async, so
      // all promisses will be resolved after the current call stack
      // has terminated. In our case, we want all paths
      // to be resolved before the end of the function, which
      // we can handle easily with callback functions.
      if (!path) throw new Error('Path not spcecified')
      const item = this.root.resolvePath(path);
      if (item) {
        cb(item);
      } else {
        // Some paths resolve to items generated during load,
        // so push a callback to re-try after the load is complete.
        plcbs.push(() => {
          const param = this.resolvePath(path);
          if (param) cb(param);
          else {
            console.warn('Path unable to be resolved:' + path);
          }
        });
      }
    };
    context.addPLCB = (plcb) => plcbs.push(plcb);
    context.settings = this.settings;

    if (json.root) {
      this.root.fromJSON(json.root, context);
    }

    // Invoke all the post-load callbacks to resolve any
    // remaning references.
    for (const cb of plcbs) cb();
  }
}

/* eslint-disable guard-for-in */

// AssetItem.registerDataLoader('.obj', ObjDataLoader);

/**
 * Class designed to load and handle `.obj` files.
 * Which define the grometry and other properties for objects.
 *
 * **Parameters**
 * * **splitObjects(`BooleanParameter`):** _todo_
 * * **splitGroupsIntoObjects(`BooleanParameter`):** _todo_
 * * **loadMtlFile(`BooleanParameter`):** _todo_
 * * **unitsConversion(`NumberParameter`):** _todo_
 * * **defaultShader(`StringParameter`):** _todo_
 * * **ObjFilePath(`FilePathParameter`):** Used to specify the path to the file.
 *
 * **Events**
 * * **loaded:** Triggered once everything is loaded.
 * * **geomsLoaded:** Triggered once all geometries are loaded.
 *
 * @extends AssetItem
 */
class ObjAsset extends AssetItem {
  /**
   * Create an obj asset.
   * @param {string} name - The name of the object asset.
   */
  constructor(name) {
    super(name);

    // A signal that is emitted once all the geoms are loaded.
    // Often the state machine will activate the first state
    // when this signal emits.
    this.geomsLoaded = false;
    this.loaded = false;

    this.addParameter(new BooleanParameter('splitObjects', false));
    this.addParameter(new BooleanParameter('splitGroupsIntoObjects', false));
    this.addParameter(new BooleanParameter('loadMtlFile', true));
    this.addParameter(new NumberParameter('unitsConversion', 1.0));
    this.addParameter(new StringParameter('defaultShader', ''));

    this.objfileParam = this.addParameter(new FilePathParameter('FilePath'));
    this.objfileParam.on('valueChanged', () => {
      this.loaded = false;
      this.__loadObj(
        () => {
          this.emit('loaded', {});
        },
        () => {
          this.emit('geomsLoaded', {});
        }
      );
    });
    this.geomLibrary = new GeomLibrary();
    this.materials = new MaterialLibrary();
  }

  /**
   * Returns `GeomLibrary` object which hosts workers, buffers, streams and geometry objects.
   *
   * @return {GeomLibrary} - The return value.
   */
  getGeometryLibrary() {
    return this.geomLibrary
  }

  /**
   * Returns `MaterialLibrary` object wich hosts images and `Material` objects.
   *
   * @return {MaterialLibrary} - The return value.
   */
  getMaterialLibrary() {
    return this.materials
  }

  /**
   * The __loadObj method.
   * @param {function} onDone - The onDone value.
   * @param {function} onGeomsLoaded - The onGeomsLoaded value.
   * @private
   */
  __loadObj(onDone, onGeomsLoaded) {
    const url = this.objfileParam.getUrl();
    const fileFolder = url.substring(0, url.lastIndexOf('/')) + '/';
    const filename = url.substring(url.lastIndexOf('/') + 1);

    const parseMtlData = (mtlFileData) => {
      const lines = mtlFileData.split('\n');
      const WHITESPACE_RE = /\s+/;
      let material;

      const parseColor = function (elements) {
        if (elements.length == 3)
          return new Color(parseFloat(elements[0]), parseFloat(elements[1]), parseFloat(elements[2]))
        else throw new Error('Unable to parse a color from the following parts:' + elements.join('_'))
      };

      const parseMap = (elements) => {
        return new FileImage(elements[0], fileFolder + elements[0])
      };

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        if (line.startsWith('#')) continue
        if (line.indexOf('#') != -1) line = line.substring(0, line.indexOf('#')).trim();
        const elements = line.split(WHITESPACE_RE);
        const key = elements.shift();
        const value = elements.join(' ');
        switch (key) {
          case 'newmtl':
            material = new Material(value);
            material.setShaderName('StandardSurfaceShader');
            this.materials.addMaterial(material);
            break
          case 'Kd':
            material.getParameter('BaseColor').setValue(parseColor(elements));
            break
          case 'map_Kd':
            material.getParameter('BaseColor').setValue(parseMap(elements));
            break
          case 'Ks':
            const specular = (parseFloat(elements[0]) + parseFloat(elements[1]) + parseFloat(elements[2])) / 3.0;
            material.roughness = 1.0 - specular;
            material.getParameter('Roughness').setValue(1.0 - specular);
            material.getParameter('Reflectance').setValue(specular);
            break
          case 'map_Ks':
            material.getParameter('Roughness').setValue(parseMap(elements /* flags=TEXTURE_INVERT */));
            material.getParameter('Reflectance').setValue(0.2);
            break
          case 'd':
            const d = parseFloat(value);
            if (d < 1.0) {
              material.setShaderName('TransparentSurfaceShader');
              material.getParameter('Opacity').setValue(d);
            }
            break
          case 'map_d':
            material.getParameter('alpha').setValue(parseFloat(elements));
            break
          case 'map_bump':
            material.getParameter('normal').setValue(parseMap(elements /* flags=BUMP_TO_NORMAL */));
            break
          // console.warn("Unhandled material parameter: '" + key +"' in:" + filePath);
        }
      }
    };

    const async = new Async();
    async.incAsyncCount();
    async.on('ready', () => {
      buildChildItems();
    });

    const loadMtlFile = (mtlFile) => {
      return new Promise((resolve) => {
        loadTextfile(mtlFile.url, (fileData) => {
          resourceLoader.addWorkDone(fileId, 1);
          parseMtlData(fileData);
          async.decAsyncCount();
          resourceLoader.addWorkDone(fileId, 1);
          resolve();
        });
      })
    };

    const vertices = new Array();
    const normals = new Array();
    const texCoords = new Array();

    const geomDatas = {};

    const parseObjData = async (fileData) => {
      // performance.mark("parseObjData");

      // array of lines separated by the newline
      const lines = fileData.split('\n');
      const WHITESPACE_RE = /\s+/;

      let currGeom = undefined;
      let currMtl = undefined;
      const newGeom = (name) => {
        let suffix = 0;
        while (name in geomDatas) {
          suffix++;
          name = name + String(suffix);
        }
        currGeom = {
          verticesRemapping: {},
          texCoordsRemapping: {},
          normalsRemapping: {},
          vertexIndices: [],
          texCoordIndices: [],
          normalIndices: [],
          numVertices: 0,
          numTexCoords: 0,
          numNormals: 0,
          faceCounts: [],
          material: currMtl,
        };
        geomDatas[name] = currGeom;
      };
      newGeom(filename);

      const splitGroupsIntoObjects = this.getParameter('splitGroupsIntoObjects').getValue();

      const stop = false;
      // let numPolys = 0;
      for (let i = 0; i < lines.length && !stop; i++) {
        let line = lines[i].trim();
        if (line.startsWith('#')) continue
        if (line.indexOf('#') != -1) line = line.substring(0, line.indexOf('#')).trim();
        const elements = line.split(WHITESPACE_RE);
        const key = elements.shift();
        const value = elements.join(' ');
        switch (key) {
          case '':
          case 's':
            // ignore shading groups
            continue
          case 'mtllib':
            if (!this.getParameter('loadMtlFile').getValue()) continue
            // Load and parse the mat lib.
            async.incAsyncCount();
            resourceLoader.addWork(stem, 2);
            const mtlFile = resourceLoader.resolveFilepath(fileFolder + value);
            if (mtlFile) {
              await loadMtlFile(mtlFile);
            }
            break
          case 'o':
            newGeom(value);
            break
          case 'usemtl':
            currMtl = value;
            newGeom(value + Object.keys(geomDatas).length);
            break
          case 'g':
            if (splitGroupsIntoObjects) newGeom(elements.join('_'));
            break
          case 'v':
            vertices.push(elements.map((i) => parseFloat(i)));
            break
          case 'vt':
            texCoords.push(elements.map((i) => parseFloat(i)));
            break
          case 'vn':
            normals.push(elements.map((i) => parseFloat(i)));
            break
          case 'f': {
            const v_poly = [];
            const vt_poly = [];
            const vn_poly = [];
            for (let j = 0, eleLen = elements.length; j < eleLen; j++) {
              // v/vt/vn
              const indices = elements[j].split('/').map((i) => parseInt(i) - 1);
              const v = indices[0];

              // v_poly.push(v);
              let v_index = currGeom.verticesRemapping[v];
              if (v_index == undefined) {
                v_index = currGeom.numVertices;
                currGeom.verticesRemapping[v] = v_index;
                currGeom.numVertices++;
              }
              v_poly.push(v_index);

              if (indices.length > 1 && !isNaN(indices[1])) {
                const vt = indices[1];
                vt_poly.push(vt);
              }
              if (indices.length > 2 && !isNaN(indices[2])) {
                const vn = indices[2];
                vn_poly.push(vn);
              }
            }
            currGeom.vertexIndices.push(v_poly);
            if (vn_poly.length > 0) currGeom.normalIndices.push(vn_poly);
            if (vt_poly.length > 0) currGeom.texCoordIndices.push(vt_poly);

            if (currGeom.faceCounts[v_poly.length - 3] == undefined) {
              currGeom.faceCounts[v_poly.length - 3] = [];
            }
            currGeom.faceCounts[v_poly.length - 3]++;
            // numPolys++;
            // if(numPolys == 16000)
            //     stop = true;
            break
          }
          default: {
            console.warn('Unhandled line:' + line);
          }
        }
      }

      async.decAsyncCount();
    };

    const buildChildItems = () => {
      // performance.mark("parseObjDataDone");
      // performance.mark("buildObjTree");
      for (const geomName in geomDatas) {
        if (geomDatas[geomName].numVertices == 0) continue
        buildChildItem(geomName, geomDatas[geomName]);
      }

      // Done.
      onDone();
      onGeomsLoaded();
    };

    const buildChildItem = (geomName, geomData) => {
      const numVertices = geomData.numVertices;
      const mesh = new Mesh(geomName);
      mesh.setFaceCounts(geomData.faceCounts);
      mesh.setNumVertices(numVertices);
      const positionsAttr = mesh.getVertexAttribute('positions');
      const unitsConversion = this.getParameter('unitsConversion').getValue();

      for (const vsrc in geomData.verticesRemapping) {
        const vtgt = geomData.verticesRemapping[vsrc];
        positionsAttr
          .getValueRef(vtgt)
          .set(
            vertices[vsrc][0] * unitsConversion,
            vertices[vsrc][1] * unitsConversion,
            vertices[vsrc][2] * unitsConversion
          );
      }

      let normalsAttr;
      let texCoordsAttr;
      if (geomData.normalIndices.length > 0) normalsAttr = mesh.addVertexAttribute('normals', Vec3$1);
      if (geomData.texCoordIndices.length > 0) texCoordsAttr = mesh.addVertexAttribute('texCoords', Vec2);

      const loadedFaces = Array(geomData.faceCounts.length).fill(0);
      for (let i = 0; i < geomData.vertexIndices.length; i++) {
        const v_poly = geomData.vertexIndices[i];
        let faceId = 0;
        for (let j = 0; j < v_poly.length - 3; ++j) {
          faceId += geomData.faceCounts[j];
        }
        faceId += loadedFaces[v_poly.length - 3];
        loadedFaces[v_poly.length - 3]++;
        mesh.setFaceVertexIndices(faceId, v_poly);

        // Set the texCoords and normals...
        if (normalsAttr) {
          const vn_poly = geomData.normalIndices[i];
          for (let j = 0; j < vn_poly.length; j++) {
            const value = new Vec3$1(normals[vn_poly[j]][0], normals[vn_poly[j]][1], normals[vn_poly[j]][2]);
            normalsAttr.setFaceVertexValue(faceId, j, value);
          }
        }
        if (texCoordsAttr && geomData.texCoordIndices.length == geomData.vertexIndices.length) {
          const vt_poly = geomData.texCoordIndices[i];
          for (let j = 0; j < vt_poly.length; j++) {
            const value = new Vec2(texCoords[vt_poly[j]][0], texCoords[vt_poly[j]][1]);
            texCoordsAttr.setFaceVertexValue(faceId, j, value);
          }
        }
      }

      const geomItem = new GeomItem(geomName, mesh);
      geomItem.selectable = true;

      // Move the transform of the geom item to the center of the geom.
      // This is so that transparent objects can render correctly, and the
      // transform gizmo becomes centered on each geom(for testing)
      const delta = mesh.getBoundingBox().center();
      {
        const offset = delta.negate();
        const positions = mesh.getVertexAttribute('positions');
        for (let i = 0; i < positions.length; i++) positions.getValueRef(i).addInPlace(offset);
        mesh.setBoundingBoxDirty();
      }
      geomItem.getParameter('LocalXfo').setValue(new Xfo(delta));

      if (geomData.material != undefined && this.materials.hasMaterial(geomData.material)) {
        geomItem.getParameter('Material').setValue(this.materials.getMaterial(geomData.material));
      } else {
        const defaultShader = this.getParameter('defaultShader').getValue();
        const material = new Material(geomName + 'mat');
        material.setShaderName(defaultShader != '' ? defaultShader : 'StandardSurfaceShader');
        this.materials.addMaterial(material);
        geomItem.getParameter('Material').setValue(material);
      }

      this.addChild(geomItem, false);
    };

    const loadObjData = () => {
      const fileId = this.objfileParam.getValue();
      resourceLoader.addWork(fileId, 2);
      loadTextfile(url, (fileData) => {
        resourceLoader.addWorkDone(fileId, 1);
        parseObjData(fileData);
        resourceLoader.addWorkDone(fileId, 1);
      });
    };

    loadObjData();
  }
}

/** Class representing a router operator.
 * @extends Operator
 * @private
 */
class RouterOperator extends Operator {
  /**
   * Create a router operator.
   * @param {string} name - The name value.
   */
  constructor(name) {
    super(name);
    this.__input = this.addInput(new OperatorInput('Input'));
  }

  /**
   * The addRoute method.
   * @return {OperatorOutput} - The added output.
   */
  addRoute() {
    return this.addOutput(new OperatorOutput('Output' + this.__outputs.size))
  }

  /**
   * The evaluate method.
   */
  evaluate() {
    if (this.__input.isConnected()) {
      const inputValue = this.__input.getValue();
      let i = this.__outputs.size;
      while (i--) {
        const output = this.getOutputByIndex(i);
        output.setClean(inputValue);
      }
    } else {
      let i = this.__outputs.size;
      while (i--) {
        const output = this.getOutputByIndex(i);
        output.setClean(0.0);
      }
    }
  }
}

Registry.register('RouterOperator', RouterOperator);

/* eslint-disable require-jsdoc */

/**
 * Class representing the viewport manipulator with camera, mouse and keyboard events.
 *
 * ```
 * const manipulator = new CameraMouseAndKeyboard()
 * ```
 *
 * **Parameters**
 * * **orbitRate(`NumberParameter`):** _todo_
 * * **dollySpeed(`NumberParameter`):** _todo_
 * * **mouseWheelDollySpeed(`NumberParameter`):** _todo_
 *
 * **Events**
 * * **movementFinished:** Triggered when the camera moves
 *
 * @extends ParameterOwner
 */
class CameraMouseAndKeyboard extends ParameterOwner {
  /**
   * Create a camera, mouse and keyboard
   * @param {string} name - The name value.
   */
  constructor(name = undefined) {
    if (name == undefined) name = 'Camera';
    super(name);

    this.__defaultManipulationState = 'orbit';
    this.__manipulationState = this.__defaultManipulationState;
    this.__mouseDown = false;
    this.__dragging = false;
    this.__mouseDragDelta = new Vec2();
    this.__keyboardMovement = false;
    this.__keysPressed = [];
    this.__maxVel = 0.002;
    this.__velocity = new Vec3$1();

    this.__ongoingTouches = {};

    this.__globalXfoChangedDuringDrag = this.__globalXfoChangedDuringDrag.bind(this);

    this.__orbitRateParam = this.addParameter(new NumberParameter('orbitRate', SystemDesc.isMobileDevice ? -0.3 : 1));
    this.__dollySpeedParam = this.addParameter(new NumberParameter('dollySpeed', 0.02));
    this.__mouseWheelDollySpeedParam = this.addParameter(new NumberParameter('mouseWheelDollySpeed', 0.0005));
  }

  /**
   * Sets default manipulation mode.
   *
   * @param {string} manipulationMode - The manipulation mode value. Can be 'orbit', or 'look'
   */
  setDefaultManipulationMode(manipulationMode) {
    this.__defaultManipulationState = manipulationMode;
  }

  /**
   * The look method.
   * @param {MouseEvent} event - The event value.
   * @param {Vec2} dragVec - The drag vector value.
   */
  look(event, dragVec) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    const focalDistance = camera.getFocalDistance();
    const orbitRate = this.__orbitRateParam.getValue();

    if (this.__keyboardMovement) {
      const globalXfo = camera.getParameter('GlobalXfo').getValue();
      this.__mouseDownCameraXfo = globalXfo.clone();
      this.__mouseDownZaxis = globalXfo.ori.getZaxis();
      const targetOffset = this.__mouseDownZaxis.scale(-focalDistance);
      this.__mouseDownCameraTarget = globalXfo.tr.add(targetOffset);
    }

    const globalXfo = this.__mouseDownCameraXfo.clone();

    // Orbit
    const orbit = new Quat();
    orbit.rotateZ((dragVec.x / viewport.getWidth()) * Math.PI * orbitRate);
    globalXfo.ori = orbit.multiply(globalXfo.ori);

    // Pitch
    const pitch = new Quat();
    pitch.rotateX((dragVec.y / viewport.getHeight()) * Math.PI * orbitRate);
    globalXfo.ori.multiplyInPlace(pitch);

    if (this.__keyboardMovement) {
      // TODO: debug this potential regression. we now use the generic method which emits a signal.
      // Avoid generating a signal because we have an animation frame occurring.
      // see: onKeyPressed
      camera.getParameter('GlobalXfo').setValue(globalXfo);
    } else {
      camera.getParameter('GlobalXfo').setValue(globalXfo);
    }
  }

  /**
   * Rotates viewport camera about the target.
   *
   * @param {MouseEvent} event - The event value.
   * @param {Vec2} dragVec - The drag vector value.
   */
  orbit(event, dragVec) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    const focalDistance = camera.getFocalDistance();
    const orbitRate = this.__orbitRateParam.getValue();

    if (this.__keyboardMovement) {
      const globalXfo = camera.getParameter('GlobalXfo').getValue();
      this.__mouseDownCameraXfo = globalXfo.clone();
      this.__mouseDownZaxis = globalXfo.ori.getZaxis();
      const targetOffset = this.__mouseDownZaxis.scale(-focalDistance);
      this.__mouseDownCameraTarget = globalXfo.tr.add(targetOffset);
    }

    const globalXfo = this.__mouseDownCameraXfo.clone();

    // Orbit
    const orbit = new Quat();
    orbit.rotateZ((dragVec.x / viewport.getWidth()) * 2 * Math.PI * -orbitRate);
    globalXfo.ori = orbit.multiply(globalXfo.ori);

    // Pitch
    const pitch = new Quat();
    pitch.rotateX((dragVec.y / viewport.getHeight()) * Math.PI * -orbitRate);
    globalXfo.ori.multiplyInPlace(pitch);

    globalXfo.tr = this.__mouseDownCameraTarget.add(globalXfo.ori.getZaxis().scale(focalDistance));

    if (this.__keyboardMovement) {
      // TODO: debug this potential regression. we now use the generic method which emits a signal.
      // Avoid generating a signal because we have an animation frame occurring.
      // see: onKeyPressed
      camera.getParameter('GlobalXfo').setValue(globalXfo);
    } else {
      camera.getParameter('GlobalXfo').setValue(globalXfo);
    }
  }

  /**
   * Rotates the camera around its own `X`,`Y` axes.
   *
   * @param {MouseEvent} event - The event value.
   * @param {Vec2} dragVec - The drag vector value.
   */
  pan(event, dragVec) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    const focalDistance = camera.getFocalDistance();
    const fovY = camera.getFov();
    const xAxis = new Vec3$1(1, 0, 0);
    const yAxis = new Vec3$1(0, 1, 0);

    const cameraPlaneHeight = 2.0 * focalDistance * Math.tan(0.5 * fovY);
    const cameraPlaneWidth = cameraPlaneHeight * (viewport.getWidth() / viewport.getHeight());
    const delta = new Xfo();
    delta.tr = xAxis.scale(-(dragVec.x / viewport.getWidth()) * cameraPlaneWidth);
    delta.tr.addInPlace(yAxis.scale((dragVec.y / viewport.getHeight()) * cameraPlaneHeight));

    camera.getParameter('GlobalXfo').setValue(this.__mouseDownCameraXfo.multiply(delta));
  }

  /**
   * The dolly method.
   * @param {MouseEvent} event - The event value.
   * @param {Vec2} dragVec - The drag vector value.
   */
  dolly(event, dragVec) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    const dollyDist = dragVec.x * this.__dollySpeedParam.getValue();
    const delta = new Xfo();
    delta.tr.set(0, 0, dollyDist);
    camera.getParameter('GlobalXfo').setValue(this.__mouseDownCameraXfo.multiply(delta));
  }

  /**
   * Rotates the camera around its own `X`,`Y` axes and applies a zoom.
   *
   * @param {MouseEvent} event - The event value.
   * @param {Vec2} panDelta - The pan delta value.
   * @param {number} dragDist - The drag distance value.
   */
  panAndZoom(event, panDelta, dragDist) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    const focalDistance = camera.getFocalDistance();
    const fovY = camera.getFov();

    const xAxis = new Vec3$1(1, 0, 0);
    const yAxis = new Vec3$1(0, 1, 0);

    const cameraPlaneHeight = 2.0 * focalDistance * Math.tan(0.5 * fovY);
    const cameraPlaneWidth = cameraPlaneHeight * (viewport.getWidth() / viewport.getHeight());
    const delta = new Xfo();
    delta.tr = xAxis.scale(-(panDelta.x / viewport.getWidth()) * cameraPlaneWidth);
    delta.tr.addInPlace(yAxis.scale((panDelta.y / viewport.getHeight()) * cameraPlaneHeight));

    const zoomDist = dragDist * focalDistance;
    camera.setFocalDistance(this.__mouseDownFocalDist + zoomDist);
    delta.tr.z += zoomDist;
    camera.getParameter('GlobalXfo').setValue(this.__mouseDownCameraXfo.multiply(delta));
  }

  /**
   * The initDrag method.
   *
   * @private
   * @param {MouseEvent} event - The event value.
   */
  initDrag(event) {
    const { viewport } = event;
    const camera = viewport.getCamera();
    const focalDistance = camera.getFocalDistance();

    this.__mouseDown = true;
    this.__calculatingDragAction = false;
    this.__mouseDownPos = event.mousePos;
    this.__mouseDownViewport = viewport;
    this.__mouseDragDelta.set(0, 0);
    this.__mouseDownCameraXfo = camera.getParameter('GlobalXfo').getValue().clone();
    this.__mouseDownZaxis = this.__mouseDownCameraXfo.ori.getZaxis();
    const targetOffset = this.__mouseDownZaxis.scale(-focalDistance);
    this.__mouseDownCameraTarget = camera.getParameter('GlobalXfo').getValue().tr.add(targetOffset);
    this.__mouseDownFocalDist = focalDistance;

    camera.getParameter('GlobalXfo').on('valueChanged', this.__globalXfoChangedDuringDrag);

    this.__dragging = true;
  }

  /**
   * @private
   */
  __globalXfoChangedDuringDrag() {
    if (!this.__calculatingDragAction) {
      if (this.__dragging) {
        const camera = this.__mouseDownViewport.getCamera();
        camera.getParameter('GlobalXfo').off('valueChanged', this.__globalXfoChangedDuringDrag);
        this.__dragging = false;
      }
      this.initDrag({ viewport: this.__mouseDownViewport, mousePos: this.__mouseDownPos });
    }
  }

  /**
   * The initDrag method.
   *
   * @private
   * @param {MouseEvent} event - The event value.
   */
  endDrag(event) {
    if (this.__dragging) {
      const { viewport } = event;
      const camera = viewport.getCamera();
      camera.getParameter('GlobalXfo').off('valueChanged', this.__globalXfoChangedDuringDrag);
      this.__dragging = false;
    }
    this.__mouseDown = false;
  }

  /**
   * The aimFocus method.
   *
   * @private
   * @param {MouseEvent} event - The event value.
   * @param {Vec3} pos - The position value.
   */
  aimFocus(event, pos) {
    const { viewport } = event;
    const camera = viewport.getCamera();

    if (this.__focusIntervalId) clearInterval(this.__focusIntervalId);

    const count = 20;
    let i = 0;
    const applyMovement = () => {
      const initlalGlobalXfo = camera.getParameter('GlobalXfo').getValue();
      const initlalDist = camera.getFocalDistance();
      const dir = pos.subtract(initlalGlobalXfo.tr);
      const dist = dir.normalizeInPlace();

      const orbit = new Quat();
      const pitch = new Quat();

      // Orbit
      {
        const currDir = initlalGlobalXfo.ori.getZaxis().clone();
        currDir.z = 0;
        const newDir = dir.negate();
        newDir.z = 0;

        orbit.setFrom2Vectors(currDir, newDir);
      }

      // Pitch
      {
        const currDir = initlalGlobalXfo.ori.getZaxis().clone();
        const newDir = dir.negate();
        currDir.x = newDir.x;
        currDir.y = newDir.y;
        currDir.normalizeInPlace();

        if (currDir.cross(newDir).dot(initlalGlobalXfo.ori.getXaxis()) > 0.0) pitch.rotateX(currDir.angleTo(newDir));
        else pitch.rotateX(-currDir.angleTo(newDir));
      }

      const targetGlobalXfo = initlalGlobalXfo.clone();
      targetGlobalXfo.ori = orbit.multiply(targetGlobalXfo.ori);
      targetGlobalXfo.ori.multiplyInPlace(pitch);

      // With each iteration we get closer to our goal
      // and on the final iteration we should aim perfectly at
      // the target.
      const t = Math.pow(i / count, 2);
      const globalXfo = initlalGlobalXfo.clone();
      globalXfo.ori = initlalGlobalXfo.ori.lerp(targetGlobalXfo.ori, t);

      camera.setFocalDistance(initlalDist + (dist - initlalDist) * t);
      camera.getParameter('GlobalXfo').setValue(globalXfo);

      i++;
      if (i <= count) {
        this.__focusIntervalId = setTimeout(applyMovement, 20);
      } else {
        this.__focusIntervalId = undefined;
        this.emit('movementFinished', {});
        camera.emit('movementFinished', {});
      }
    };
    applyMovement();

    this.__manipulationState = 'focussing';
  }

  /**
   * Causes an event to occur when the mouse pointer is moving while over an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseMove(event) {}

  /**
   * Causes an event to occur when a user double clicks a mouse button over an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onDoubleClick(event) {
    if (event.intersectionData) {
      const camera = event.viewport.getCamera();
      const cameraGlobalXfo = camera.getParameter('GlobalXfo').getValue();
      const pos = cameraGlobalXfo.tr.add(event.mouseRay.dir.scale(event.intersectionData.dist));
      this.aimFocus(event, pos);
    }
  }

  /**
   * Causes an event to occur when the user starts to drag an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseDown(event) {
    // this.initDrag(event)
    if (this.__dragging) {
      const camera = this.__mouseDownViewport.getCamera();
      camera.getParameter('GlobalXfo').off('valueChanged', this.__globalXfoChangedDuringDrag);
      this.__dragging = false;
    }
    this.initDrag(event);

    if (event.button == 2) {
      this.__manipulationState = 'pan';
    } else if (event.ctrlKey && event.altKey) {
      this.__manipulationState = 'dolly';
    } else if (event.ctrlKey || event.button == 2) {
      this.__manipulationState = 'look';
    } else {
      this.__manipulationState = this.__defaultManipulationState;
    }
    event.stopPropagation();
    event.preventDefault();
  }

  /**
   * Causes an event to occur when an element is being dragged.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseMove(event) {
    if (!this.__mouseDown) return
    const mousePos = event.mousePos;
    this.__calculatingDragAction = true;
    if (this.__keyboardMovement) {
      this.__mouseDragDelta = mousePos;
    } else {
      this.__mouseDragDelta = mousePos.subtract(this.__mouseDownPos);
    }
    switch (this.__manipulationState) {
      case 'orbit':
        this.orbit(event, this.__mouseDragDelta);
        break
      case 'look':
        this.look(event, this.__mouseDragDelta);
        break
      case 'pan':
        this.pan(event, this.__mouseDragDelta);
        break
      case 'dolly':
        this.dolly(event, this.__mouseDragDelta);
        break
    }
    this.__dragging = true;
    this.__calculatingDragAction = false;
    event.stopPropagation();
    event.preventDefault();
  }

  /**
   * Causes an event to occur when the user has finished dragging an element.
   *
   * @param {MouseEvent} event - The mouse event that occurs.
   */
  onMouseUp(event) {
    if (this.__dragging) {
      this.endDrag(event);
      this.emit('movementFinished', {});
      event.viewport.getCamera().emit('movementFinished', {});
      event.stopPropagation();
    }
  }

  /**
   * Causes an event to occur when the mouse wheel is rolled up or down over an element.
   *
   * @param {WheelEvent} event - The wheel event that occurs.
   */
  onWheel(event) {
    const { viewport } = event;
    const camera = viewport.getCamera();
    const mouseWheelDollySpeed = this.__mouseWheelDollySpeedParam.getValue();
    const modulator = event.shiftKey ? 0.1 : 0.5;
    const xfo = camera.getParameter('GlobalXfo').getValue();
    const movementVec = xfo.ori.getZaxis();
    if (this.__mouseWheelZoomIntervalId) clearInterval(this.__mouseWheelZoomIntervalId);
    let count = 0;
    const applyMovement = () => {
      const focalDistance = camera.getFocalDistance();
      const zoomDist = event.deltaY * mouseWheelDollySpeed * focalDistance * modulator;
      xfo.tr.addInPlace(movementVec.scale(zoomDist));
      if (this.__defaultManipulationState == 'orbit') camera.setFocalDistance(camera.getFocalDistance() + zoomDist);
      camera.getParameter('GlobalXfo').setValue(xfo);

      count++;
      if (count < 10) {
        this.__mouseWheelZoomIntervalId = setTimeout(applyMovement, 10);
      } else {
        this.__mouseWheelZoomIntervalId = undefined;
        this.emit('movementFinished', {});
        camera.emit('movementFinished', {});
      }
    };
    applyMovement();

    event.preventDefault();
    event.stopPropagation();
  }

  /**
   * The __integrateVelocityChange method.
   * @param {MouseEvent} event - The event value.
   * @private
   */
  __integrateVelocityChange(event) {
    const { viewport } = event;
    const camera = viewport.getCamera();
    const delta = new Xfo();
    delta.tr = this.__velocity.normalize().scale(this.__maxVel);
    camera.getParameter('GlobalXfo').setValue(camera.getParameter('GlobalXfo').getValue().multiply(delta));
  }

  /**
   * Causes an event to occurs when the user presses a key on the keyboard.
   *
   * @param {string} key - The key the user presses.
   * @param {KeyboardEvent} event - The keyboard event that occurs.
   * @return {boolean} - The return value.
   * @private
   */
  onKeyPressed(key, event) {
    // Note: onKeyPressed is called initially only once, and then we
    // get a series of calls. Here we ignore subsequent events.
    // (TODO: move this logic to a special controller)
    /*
    switch (key) {
      case 'w':
        if (this.__keysPressed.indexOf(key) != -1)
          return false;
        this.__velocity.z -= 1.0;
        break;
      case 's':
        if (this.__keysPressed.indexOf(key) != -1)
          return false;
        this.__velocity.z += 1.0;
        break;
      case 'a':
        if (this.__keysPressed.indexOf(key) != -1)
          return false;
        this.__velocity.x -= 1.0;
        break;
      case 'd':
        if (this.__keysPressed.indexOf(key) != -1)
          return false;
        this.__velocity.x += 1.0;
        break;
      default:
        return false;
    }
    this.__keysPressed.push(key);
    if (!this.__keyboardMovement) {
      this.__keyboardMovement = true;
      let animationFrame = ()=>{
        this.__integrateVelocityChange(event)
        if (this.__keyboardMovement)
          window.requestAnimationFrame(animationFrame);
      }
      window.requestAnimationFrame(animationFrame);
    }
    */
    return false // no keys handled
  }

  /**
   * Causes an event to occur when the user is pressing a key on the keyboard.
   *
   * @param {string} key - The key the user is pressing.
   * @param {KeyboardEvent} event - The keyboard event that occurs.
   * @private
   */
  onKeyDown(key, event) {}

  /**
   * Causes an event to occur when the user releases a key on the keyboard.
   *
   * @param {string} key - The key the user releases.
   * @param {KeyboardEvent} event - The event that occurs.
   * @private
   */
  onKeyUp(key, event) {
    // (TODO: move this logic to a special controller)
    /*
    switch (key) {
      case 'w':
        this.__velocity.z += 1.0;
        break;
      case 's':
        this.__velocity.z -= 1.0;
        break;
      case 'a':
        this.__velocity.x += 1.0;
        break;
      case 'd':
        this.__velocity.x -= 1.0;
        break;
      default:
        return false;
    }
    let keyIndex = this.__keysPressed.indexOf(key);
    this.__keysPressed.splice(keyIndex, 1);
    if (this.__keysPressed.length == 0)
      this.__keyboardMovement = false;
    */
  }

  // ///////////////////////////////////
  // Touch controls

  /**
   * The __startTouch method.
   * @param {TouchEvent} touch - The touch value.
   * @private
   */
  __startTouch(touch) {
    this.__ongoingTouches[touch.identifier] = {
      identifier: touch.identifier,
      pos: new Vec2(touch.pageX, touch.pageY),
    };
  }

  /**
   * The __endTouch method.
   * @param {TouchEvent} touch - The touch value.
   * @private
   */
  __endTouch(touch) {
    // let idx = this.__ongoingTouchIndexById(touch.identifier);
    // this.__ongoingTouches.splice(idx, 1); // remove it; we're done
    delete this.__ongoingTouches[touch.identifier];
  }

  // Touch events

  /**
   * Causes an event to occur when the user touches an element on a touch screen.
   *
   * @param {TouchEvent} event - The touch event that occurs.
   */
  onTouchStart(event) {
    console.log('onTouchStart');
    event.preventDefault();
    event.stopPropagation();

    if (Object.keys(this.__ongoingTouches).length == 0) this.__manipMode = undefined;

    const touches = event.changedTouches;
    for (let i = 0; i < touches.length; i++) {
      this.__startTouch(touches[i]);
    }

    if (Object.keys(this.__ongoingTouches).length == 1) {
      this.initDrag(event);
    }
  }

  /**
   * The event that occurs when the user moves his/her finger across a touch screen.
   *
   * @param {TouchEvent} event - The touch event that occurs.
   */
  onTouchMove(event) {
    event.preventDefault();
    event.stopPropagation();
    // console.log("this.__manipMode:" + this.__manipMode);

    this.__calculatingDragAction = true;

    const touches = event.touches;
    if (touches.length == 1 && this.__manipMode != 'panAndZoom') {
      const touch = touches[0];
      const touchPos = new Vec2(touch.pageX, touch.pageY);
      const touchData = this.__ongoingTouches[touch.identifier];
      const dragVec = touchData.pos.subtract(touchPos);
      if (this.__defaultManipulationState == 'look') {
        // TODO: scale panning here.
        dragVec.scaleInPlace(6.0);
        this.look(event, dragVec);
      } else {
        this.orbit(event, dragVec);
      }
    } else if (touches.length == 2) {
      const touch0 = touches[0];
      const touchData0 = this.__ongoingTouches[touch0.identifier];
      const touch1 = touches[1];
      const touchData1 = this.__ongoingTouches[touch1.identifier];

      const touch0Pos = new Vec2(touch0.pageX, touch0.pageY);
      const touch1Pos = new Vec2(touch1.pageX, touch1.pageY);
      const startSeparation = touchData1.pos.subtract(touchData0.pos).length();
      const dragSeparation = touch1Pos.subtract(touch0Pos).length();
      const separationDist = startSeparation - dragSeparation;

      const touch0Drag = touch0Pos.subtract(touchData0.pos);
      const touch1Drag = touch1Pos.subtract(touchData1.pos);
      const dragVec = touch0Drag.add(touch1Drag);
      // TODO: scale panning here.
      dragVec.scaleInPlace(0.5);
      this.panAndZoom(event, dragVec, separationDist * 0.002);
      this.__manipMode = 'panAndZoom';
    }

    this.__calculatingDragAction = false;
  }

  /**
   * Causes an event to occur when the user removes his/her finger from an element.
   *
   * @param {TouchEvent} event - The touch event that occurs.
   */
  onTouchEnd(event) {
    event.preventDefault();
    event.stopPropagation();
    const touches = event.changedTouches;
    // switch (this.__manipMode) {
    // case 'camera-manipulation':
    //     let touch = touches[0];
    //     let releasePos = new Vec2(touch.pageX, touch.pageY);
    //     viewport.getCamera().onDragEnd(event, releasePos);
    //     break;
    // }
    for (let i = 0; i < touches.length; i++) {
      this.__endTouch(touches[i]);
    }

    if (Object.keys(this.__ongoingTouches).length == 0) this.endDrag(event);
  }

  /**
   * Causes an event to occur when the touch event gets interrupted.
   *
   * @param {TouchEvent} event - The touch event that occurs.
   */
  onTouchCancel(event) {
    event.preventDefault();
    const touches = event.touches;
    for (let i = 0; i < touches.length; i++) {
      this.__endTouch(touches[i]);
    }
    if (Object.keys(this.__ongoingTouches).length == 0) this.endDrag(event);
  }

  /**
   * Causes an event to occur when the user double taps an element on a touch screen.
   *
   * @param {TouchEvent} event - The touch event that occurs.
   */
  onDoubleTap(event) {
    if (event.intersectionData) {
      const { viewport } = event;
      const camera = viewport.getCamera();
      const pos = camera
        .getParameter('GlobalXfo')
        .getValue()
        .tr.add(event.touchRay.dir.scale(event.intersectionData.dist));
      this.aimFocus(event, pos);
    }
    event.preventDefault();
  }
}

/**
 * @private
 */
const sgFactory = {
  registerClass: (blueprintName, blueprint) => {
    console.warn(`'sgFactory' is deprecated, Please use 'Registry.register'`);
    Registry.register(blueprintName, blueprint);
  },
  constructClass: (blueprintName, ...args) => {
    console.warn(`'sgFactory' is deprecated, Please use 'Registry.constructClass'`);
    Registry.constructClass(blueprintName, ...args);
  },
};

var SceneTree = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RefCounted: RefCounted,
  ParameterOwner: ParameterOwner,
  BaseItem: BaseItem,
  getFileFolder: getFileFolder,
  loadTextfile: loadTextfile,
  loadJSONfile: loadJSONfile,
  loadXMLfile: loadXMLfile,
  loadBinfile: loadBinfile,
  resourceLoader: resourceLoader,
  Version: Version,
  BinReader: BinReader,
  BinWriter: BinWriter,
  OperatorOutputMode: OperatorOutputMode,
  Parameter: Parameter,
  MultiChoiceParameter: MultiChoiceParameter,
  BooleanParameter: BooleanParameter,
  NumberParameter: NumberParameter,
  Vec2Parameter: Vec2Parameter,
  Vec3Parameter: Vec3Parameter,
  Vec4Parameter: Vec4Parameter,
  ColorParameter: ColorParameter,
  Mat3Parameter: Mat3Parameter,
  Mat4Parameter: Mat4Parameter,
  XfoParameter: XfoParameter,
  ImageParameter: ImageParameter,
  StringParameter: StringParameter,
  CodeParameter: CodeParameter,
  ListParameter: ListParameter,
  StructParameter: StructParameter,
  TreeItemParameter: TreeItemParameter,
  ItemSetParameter: ItemSetParameter,
  ProxyParameter: ProxyParameter,
  GeometryParameter: GeometryParameter,
  FilePathParameter: FilePathParameter,
  MaterialParameter: MaterialParameter,
  MaterialFloatParam: MaterialFloatParam,
  MaterialColorParam: MaterialColorParam,
  Attribute: Attribute,
  BaseGeom: BaseGeom,
  VertexAttribute: VertexAttribute$1,
  Points: Points,
  Lines: Lines,
  Mesh: Mesh,
  PointsProxy: PointsProxy,
  LinesProxy: LinesProxy,
  MeshProxy: MeshProxy,
  PointGrid: PointGrid,
  Rect: Rect,
  Circle: Circle,
  Cross: Cross,
  LinesCuboid: LinesCuboid,
  Grid: Grid,
  Cone: Cone,
  Cuboid: Cuboid,
  Cylinder: Cylinder,
  Disc: Disc,
  Plane: Plane$1,
  Sphere: Sphere$1,
  Torus: Torus,
  DataImage: DataImage,
  FileImage: FileImage$1,
  FileImage2D: FileImage2D,
  LDRImage: LDRImage,
  LDRVideo: LDRVideo,
  GIFImage: GIFImage,
  EnvMap: EnvMap,
  Label: Label,
  VideoStreamImage2D: VideoStreamImage2D,
  labelManager: labelManager,
  TreeItem: TreeItem,
  InstanceItem: InstanceItem,
  AudioItem: AudioItem,
  FileAudioItem: FileAudioItem,
  BaseGeomItem: BaseGeomItem,
  GeomItem: GeomItem,
  AssetItem: AssetItem,
  BillboardItem: BillboardItem,
  Camera: Camera,
  Group: Group,
  GeomLibrary: GeomLibrary,
  Material: Material,
  BaseImage: BaseImage,
  MaterialLibrary: MaterialLibrary,
  Scene: Scene,
  VLAAsset: VLAAsset$1,
  ObjAsset: ObjAsset,
  Operator: Operator,
  OperatorInput: OperatorInput,
  OperatorOutput: OperatorOutput,
  RouterOperator: RouterOperator,
  CameraMouseAndKeyboard: CameraMouseAndKeyboard,
  sgFactory: sgFactory
});

const create3DContext = function (canvas, opt_attribs) {
  let context = null;
  if (opt_attribs.webglContextType != undefined) {
    try {
      context = canvas.getContext(opt_attribs.webglContextType, opt_attribs);
      context.name = opt_attribs.webglContextType;
    } catch (e) {}
  } else {
    const names = ['webgl2', 'webgl'];
    names.some((name) => {
      try {
        context = canvas.getContext(name, opt_attribs);
        context.name = name;
      } catch (e) {}
      if (context) {
        return true
      }
    });
  }
  if (!context) {
    return
  }

  // context.setupInstancedQuad = setupInstancedQuad;
  // context.bindInstancedQuad = bindInstancedQuad;
  context.sizeInBytes = function (type) {
    switch (type) {
      case this.BYTE:
      case this.UNSIGNED_BYTE:
        return 1
      case this.SHORT:
      case this.UNSIGNED_SHORT:
        return 2
      case this.INT:
      case this.UNSIGNED_INT:
      case this.FLOAT:
        return 4
      default:
        throw new Error('unknown type')
    }
  };

  if (context.name == 'webgl2') {
    context.floatTexturesSupported = true;

    context.__ext_float_linear = context.getExtension('OES_texture_float_linear');
    context.__ext_texture_half_float_linear = context.getExtension('OES_texture_half_float_linear');

    // Needed for rendering to float textures in an Fbo
    context.__ext_color_buffer_float = context.getExtension('EXT_color_buffer_float');

    // Safari does not support uploading HALF_FLOAT data into the GPU.
  } else {
    context.__ext_float = context.getExtension('OES_texture_float');
    if (context.__ext_float) {
      context.floatTexturesSupported = true;
      context.__ext_float_linear = context.getExtension('OES_texture_float_linear');
    } else {
      console.warn('OES_texture_float is not available');
    }

    context.__ext_half_float = context.getExtension('OES_texture_half_float');
    if (context.__ext_half_float) {
      context.HALF_FLOAT = context.__ext_half_float.HALF_FLOAT_OES;
      context.floatTexturesSupported = true;
      context.__ext_texture_half_float_linear = context.getExtension('OES_texture_half_float_linear');
    }

    // Needed for rendering to flat textures in an Fbo
    context.__ext_color_buffer_float = context.getExtension('EXT_color_buffer_float');

    context.__ext_std_derivatives = context.getExtension('OES_standard_derivatives');
    // context.__ext_sRGB = context.getExtension("EXT_sRGB");
    // context.__ext_draw_buffers = context.getExtension("WEBGL_draw_buffers");

    context.__ext_Inst = context.getExtension('ANGLE_instanced_arrays');
    if (context.__ext_Inst) {
      context.vertexAttribDivisor = context.__ext_Inst.vertexAttribDivisorANGLE.bind(context.__ext_Inst);
      context.drawArraysInstanced = context.__ext_Inst.drawArraysInstancedANGLE.bind(context.__ext_Inst);
      context.drawElementsInstanced = context.__ext_Inst.drawElementsInstancedANGLE.bind(context.__ext_Inst);
    }

    {
      // Note: OES_vertex_array_object is now supported on Safari.
      context.__ext_VAO = context.getExtension('OES_vertex_array_object');
      if (context.__ext_VAO) {
        context.createVertexArray = context.__ext_VAO.createVertexArrayOES.bind(context.__ext_VAO);
        context.deleteVertexArray = context.__ext_VAO.deleteVertexArrayOES.bind(context.__ext_VAO);
        context.bindVertexArray = context.__ext_VAO.bindVertexArrayOES.bind(context.__ext_VAO);
      }
    }
    context.__ext_element_index_uint = context.getExtension('OES_element_index_uint');
    context.__ext_WEBGL_depth_texture = context.getExtension('WEBGL_depth_texture'); // Or browser-appropriate prefix
    if (context.__ext_WEBGL_depth_texture) {
      context.UNSIGNED_INT_24_8 = context.__ext_WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL;
    }

    context.DRAW_FRAMEBUFFER = context.FRAMEBUFFER;
  }

  context.__ext_frag_depth = context.getExtension('EXT_frag_depth');

  context.setupInstancedQuad = function () {
    // ////////////////////////////
    // Generate a buffer for drawing a full screen quad.
    const vertexIDs = new Float32Array([0.0, 1.0, 2.0, 3.0]);
    const indices = new Uint16Array([0, 1, 2, 2, 1, 3]);

    this.__quadVertexIdsBuffer = this.createBuffer();
    this.bindBuffer(this.ARRAY_BUFFER, this.__quadVertexIdsBuffer);
    this.bufferData(this.ARRAY_BUFFER, vertexIDs, this.STATIC_DRAW);

    this.__quadIndexBuffer = this.createBuffer();
    this.bindBuffer(this.ELEMENT_ARRAY_BUFFER, this.__quadIndexBuffer);
    this.bufferData(this.ELEMENT_ARRAY_BUFFER, indices, this.STATIC_DRAW);

    this.__quadattrbuffers = {
      vertexIDs: {
        buffer: this.__quadVertexIdsBuffer,
        dataType: Float32,
        dimension: 1,
        count: vertexIDs.length,
        shared: true /*This buffer is shared between geoms. do not destroy */,
      },
    };
  };
  context.drawQuad = function () {
    this.drawElements(this.TRIANGLES, 6, this.UNSIGNED_SHORT, 0);
  };

  context.setupLineSegAttrBuffers = function () {
    // ////////////////////////////
    // Generate a buffer for drawing an instanced 2 point line
    const vertexIDs = new Float32Array([0.0, 1.0]);
    const vertexIdsBuffer = context.createBuffer();
    context.bindBuffer(context.ARRAY_BUFFER, vertexIdsBuffer);
    context.bufferData(context.ARRAY_BUFFER, vertexIDs, context.STATIC_DRAW);

    context.__linesegattrbuffers = {
      vertexIDs: {
        buffer: vertexIdsBuffer,
        dimension: 1,
        count: vertexIDs.length,
        shared: true /*This buffer is shared between geoms. do not destroy */,
      },
    };
  };

  return context
};

/**
 * Represents a texture that contains 2-dimensional images.
 * <br>
 * Images have width and height, but no depth.
 *
 * @extends RefCounted
 */
class GLTexture2D extends RefCounted {
  /**
   * Create a GL texture 2D.
   *
   * @param {WebGLRenderingContext | WebGL2RenderingContext | undefined} gl - The gl value.
   * @param {BaseImage | object} params - The params value.
   */
  constructor(gl, params) {
    super();
    this.__gl = gl;

    this.ready = false;

    this.width = 0;
    this.height = 0;
    this.textureType = 1; // Default 2d 8 bit texture image texture.
    this.textureDesc = [0, 0, 0, 0]; // To be populated by derived classes.
    this.__loaded = false;
    this.__bound = false;
    if (params != undefined) {
      if (params instanceof BaseImage) {
        this.__texture = params;
        this.__texture.setMetadata('gltexture', this);
        const imageUpdated = () => {
          // this.bufferData(data);
          const params = this.__texture.getParams();
          const width = params.width;
          const height = params.height;
          const data = params.data;
          this.bufferData(data, width, height);
        };
        this.__texture.on('updated', imageUpdated);
        if (this.__texture.isLoaded()) {
          this.configure(this.__texture.getParams());
        } else {
          this.__texture.on('loaded', () => {
            this.configure(this.__texture.getParams());
          });
        }
      } else {
        this.configure(params);
      }
    }
  }

  /**
   * Returns the loaded status of the 2D Texture
   *
   * @return {boolean} - The return value.
   */
  isLoaded() {
    return this.__loaded
  }

  /**
   * Returns the `BaseImage` of the GL Texture
   *
   * @return {BaseImage} - The return value.
   */
  getTexture() {
    return this.__texture
  }

  /**
   * Returns the specified value of the color components in the texture.
   *
   * @return {GLenum | enum} - The return value.
   */
  getInternalFormat() {
    return this.__internalFormat
  }

  /**
   * Returns the value of the specified data type of the texel data.
   *
   * @return {GLenum | enum} - The return value.
   */
  getType() {
    return this.__typeParam
  }

  /**
   * Returns the value of the specified data type of the texel data.
   *
   * @return {GLenum | enum} - The return value.
   */
  getTypeID() {
    return this.__type
  }

  /**
   * Returns the value of the specified texel data. It must be the same as the `internalFormat`
   *
   * @return {GLenum | enum} - The return value.
   */
  getFormat() {
    return this.__formatParam
  }

  /**
   * Returns the value of the specified texel data. It must be the same as the `internalFormat`
   *
   * @return {GLenum | enum} - The return value.
   */
  getFormatID() {
    return this.__format
  }

  /**
   * The getFilter method.
   * @return {any} - The return value.
   */
  getFilter() {
    return this.__filterParam
  }

  /**
   * Returns the value of the specified wrapping function for texture coordinate
   *
   * @return {GLenum | enum} - The return value.
   */
  getWrap() {
    return this.__wrapParam
  }

  /**
   * Returns the value of the specified binding point.
   *
   * @return {GLenum | enum} - The return value.
   */
  getMipMapped() {
    return this.__mipMapped
  }

  /**
   * Builds the GLTexture2D using the specified parameters object.
   * Parameters must have the `BaseImage` properties structure.
   *
   * @param {object} params - The params value.
   *
   * @param {boolean} emit - The emit value.
   */
  configure(params, emit = true) {
    if (!('type' in params) || !('format' in params) || !('width' in params) || !('height' in params))
      throw new Error('Invalid texture params')

    const gl = this.__gl;
    const width = params.width;
    const height = params.height;
    const data = params.data;

    const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    if (width <= 0 || width > maxSize || height <= 0 || height > maxSize) {
      throw new Error(
        'gl-texture2d: Invalid texture size. width:' + width + ' height:' + height + ' maxSize:' + maxSize
      )
    }

    const format = params.format;
    const type = params.type;
    let minFilter = 'minFilter' in params ? params.minFilter : 'filter' in params ? params.filter : 'LINEAR';
    let magFilter = 'magFilter' in params ? params.magFilter : 'filter' in params ? params.filter : 'LINEAR';
    const wrap = 'wrap' in params ? params.wrap : 'CLAMP_TO_EDGE';

    // if(format == 'ALPHA')
    //     throw("ALPHA textures are now deprecated. Please use RED instead.")

    // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    if (type == 'FLOAT') {
      this.textureType = 3; // Indicating an Float HDR image.

      if (gl.name == 'webgl2') {
        if (minFilter == 'LINEAR' && !gl.__ext_float_linear) {
          console.warn('Floating point texture filtering not supported on this device');
          minFilter = 'NEAREST';
        }
        if (magFilter == 'LINEAR' && !gl.__ext_float_linear) {
          console.warn('Floating point texture filtering not supported on this device');
          magFilter = 'NEAREST';
        }
      } else {
        if (gl.__ext_float) {
          if (minFilter == 'LINEAR' && !gl.__ext_float_linear) {
            console.warn('Floating point texture filtering not supported on this device');
            minFilter = 'NEAREST';
          }
          if (magFilter == 'LINEAR' && !gl.__ext_float_linear) {
            console.warn('Floating point texture filtering not supported on this device');
            magFilter = 'NEAREST';
          }
        } else {
          if (gl.__ext_half_float) {
            type = 'HALF_FLOAT';
            if (minFilter == 'LINEAR' && !gl.__ext_texture_half_float_linear) {
              console.warn('Half Float texture filtering not supported on this device');
              minFilter = 'NEAREST';
            }
            if (magFilter == 'LINEAR' && !gl.__ext_texture_half_float_linear) {
              console.warn('Half Float texture filtering not supported on this device');
              magFilter = 'NEAREST';
            }
          } else {
            throw new Error('OES_texture_half_float is not available')
          }
        }
      }
    } else if (type == 'HALF_FLOAT') {
      if (gl.name == 'webgl2') ; else {
        if (!gl.supportUploadingHalfFloat && data != undefined) {
          throw new Error('Safari does not support uploading HALF_FLOAT texture data.')
        }
        if (gl.__ext_half_float) {
          if (minFilter == 'LINEAR' && !gl.__ext_texture_half_float_linear) {
            console.warn('Half Float texture filtering not supported on this device');
            minFilter = 'NEAREST';
          }
          if (magFilter == 'LINEAR' && !gl.__ext_texture_half_float_linear) {
            console.warn('Half Float texture filtering not supported on this device');
            magFilter = 'NEAREST';
          }
        } else {
          throw new Error('OES_texture_half_float is not available')
        }
        if (format == 'RGB') {
          throw new Error('OES_texture_half_float onlysupports RGBA textures')
        }
      }
    } else if (type == 'sRGB') {
      if (!gl.__ext_sRGB) throw new Error('EXT_sRGB is not available')
    }

    this.__formatParam = format;
    this.__typeParam = type;
    this.__minFilterParam = minFilter;
    this.__magFilterParam = magFilter;
    this.__wrapParam = wrap;

    this.__format = gl[format];
    this.__internalFormat = 'internalFormat' in params ? gl[params.internalFormat] : this.__format;
    this.__type = gl[type];

    if (gl.name == 'webgl2') {
      if (!('internalFormat' in params)) {
        if (this.__type == gl.FLOAT) {
          if (this.__format == gl.RED) {
            this.__internalFormat = gl.R32F;
          } else if (this.__format == gl.RG) {
            this.__internalFormat = gl.RG32F;
          } else if (this.__format == gl.RGB) {
            this.__internalFormat = gl.RGB32F;
          } else if (this.__format == gl.RGBA) {
            this.__internalFormat = gl.RGBA32F;
          }
        } else if (this.__type == gl.HALF_FLOAT) {
          if (this.__format == gl.RED) {
            this.__internalFormat = gl.R16F;
          } else if (this.__format == gl.RG) {
            this.__internalFormat = gl.RG16F;
          } else if (this.__format == gl.RGB) {
            this.__internalFormat = gl.RGB16F;
          } else if (this.__format == gl.RGBA) {
            this.__internalFormat = gl.RGBA16F;
          }
        } else if (this.__type == gl.UNSIGNED_BYTE) {
          if (this.__format == gl.RED) {
            this.__internalFormat = gl.R8;
          }
          if (this.__format == gl.RG) {
            this.__internalFormat = gl.RG8;
          }
          if (this.__format == gl.RGB) {
            this.__internalFormat = gl.RGB8;
          } else if (this.__format == gl.RGBA) {
            this.__internalFormat = gl.RGBA8;
          }
        }
      }
    }
    this.__minFilter = gl[minFilter];
    this.__magFilter = gl[magFilter];
    this.__wrap = gl[wrap];
    this.__flipY = 'flipY' in params ? params.flipY : false;
    this.__mipMapped = 'mipMapped' in params ? params.mipMapped : false;
    this.invert = 'invert' in params ? params.invert : false;
    this.alphaFromLuminance = 'alphaFromLuminance' in params ? params.alphaFromLuminance : false;
    this.textureDesc = [width, height, 0, 0];

    if (this.__gltex) {
      gl.deleteTexture(this.__gltex);
    }

    this.__gltex = gl.createTexture();
    this.__updateGLTexParams();
    if (data) {
      this.bufferData(data, width, height, false, false);
    } else {
      this.resize(width, height, false, false);
    }
    if (!this.__loaded) {
      this.emit('ready', {});
      this.__loaded = true;
    }
  }

  /**
   * The __updateGLTexParams method.
   * @private
   */
  __updateGLTexParams() {
    const gl = this.__gl;

    // Load the image into the GPU for rendering.
    gl.bindTexture(gl.TEXTURE_2D, this.__gltex);

    // This parameter caused all images to be blank. Flipping in the pixel shader instead(by default)
    // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.__minFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.__magFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.__wrap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.__wrap);
  }

  /**
   * Initializes and creates the buffer of the object's data store.
   *
   * @param {Image | ImageData | HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | object} data - The data value.
   * @param {number} width - The width value.
   * @param {number} height - The height value.
   * @param {boolean} bind - The bind value.
   * @param {boolean} emit - The emit value.
   */
  bufferData(data, width = -1, height = -1, bind = true, emit = true) {
    const gl = this.__gl;
    if (bind) {
      gl.bindTexture(gl.TEXTURE_2D, this.__gltex);
    }
    if (data != undefined) {
      if (
        data instanceof Image ||
        data instanceof ImageData ||
        data instanceof HTMLCanvasElement ||
        data instanceof HTMLImageElement ||
        data instanceof HTMLVideoElement
      ) {
        gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, this.__format, this.__type, data);
        this.width = data.width;
        this.height = data.height;
      } else {
        // if wieght and height not specified, assume they stay the same.
        if (width == -1) {
          width = this.width;
        }
        if (height == -1) {
          height = this.height;
        }
        // Note: data images must have an even size width/height to load correctly.
        // this doesn't mean they must be pot textures...
        const numPixels = width * height;
        let numChannels;
        switch (this.__format) {
          case gl.RED:
          case gl.RED_INTEGER:
          case gl.ALPHA:
          case gl.LUMINANCE:
          case gl.LUMINANCE_ALPHA:
            numChannels = 1;
            break
          case gl.RG:
            numChannels = 2;
            break
          case gl.RGB:
            numChannels = 3;
            break
          case gl.RGBA:
            numChannels = 4;
            break
        }
        if (data.length != numPixels * numChannels) {
          console.warn(
            'Invalid data for Image width:' +
              width +
              ' height:' +
              height +
              ' format:' +
              this.__formatParam +
              ' type:' +
              this.__typeParam +
              ' Data Length:' +
              data.length +
              ' Expected:' +
              numPixels * numChannels
          );
        }
        if (this.__type == gl.HALF_FLOAT && data instanceof Float32Array) {
          data = MathFunctions.convertFloat32ArrayToUInt16Array(data);
        }
        if (gl.name == 'webgl2') {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, data, 0);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, data);
        }
        // These values may not have changed....
        this.width = width;
        this.height = height;
      }

      if (this.__mipMapped) {
        gl.generateMipmap(gl.TEXTURE_2D);
      }
    } else {
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        this.__internalFormat,
        this.width,
        this.height,
        0,
        this.__format,
        this.__type,
        null
      );

      // simply resize the buffer.
      this.width = width;
      this.height = height;
    }

    if (emit) {
      this.emit('updated', {});
    }
  }

  /**
   * Clears the buffers to preset values
   */
  clear() {
    const gl = this.__gl;
    const numPixels = this.width * this.height;
    let numChannels;
    switch (this.__format) {
      case gl.RED:
      case gl.RED_INTEGER:
      case gl.ALPHA:
      case gl.LUMINANCE:
      case gl.LUMINANCE_ALPHA:
        numChannels = 1;
        break
      case gl.RG:
        numChannels = 2;
        break
      case gl.RGB:
        numChannels = 3;
        break
      case gl.RGBA:
        numChannels = 4;
        break
      default:
        throw new Error('Invalid Format')
    }
    let data;
    switch (this.__type) {
      case gl.UNSIGNED_BYTE:
        data = new UInt8Array(numPixels * numChannels);
        break
      case gl.HALF_FLOAT:
        data = new UInt16Array(numPixels * numChannels);
        break
      case gl.FLOAT:
        data = new Float32Array(numPixels * numChannels);
        break
      default:
        throw new Error('Invalid Type')
    }

    if (gl.name == 'webgl2') {
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        this.__internalFormat,
        this.width,
        this.height,
        0,
        this.__format,
        this.__type,
        data,
        0
      );
    } else {
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        this.__internalFormat,
        this.width,
        this.height,
        0,
        this.__format,
        this.__type,
        data
      );
    }
  }

  /**
   * The resize method.
   * @param {number} width - The width value.
   * @param {number} height - The height value.
   * @param {boolean} preserveData - The preserveData value.
   * @param {boolean} emit - The emit value.
   */
  resize(width, height, preserveData = false, emit = true) {
    const gl = this.__gl;
    const sizeChanged = this.width != width || this.height != height;
    if (sizeChanged) {
      const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      if (width < 0 || width > maxSize || height < 0 || height > maxSize) {
        throw new Error(
          'gl-texture2d: Invalid texture size. width:' + width + ' height:' + height + ' maxSize:' + maxSize
        )
      }

      if (preserveData) {
        const gltex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, gltex);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, null);
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__gltex, 0);

        gl.bindTexture(gl.TEXTURE_2D, gltex); // Do we need this line?
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, 0, 0, this.width, this.height, 0);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        gl.deleteFramebuffer(fbo);

        this.__gl.deleteTexture(this.__gltex);
        this.__gltex = gltex;
        this.__updateGLTexParams();
      } else {
        gl.bindTexture(gl.TEXTURE_2D, this.__gltex);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, null);
      }

      this.width = width;
      this.height = height;

      if (emit) {
        this.emit('resized', { width, height });
      }
    }
  }

  /**
   * Upload data for the image to the GPU.
   *
   * @param {Uint16Array} dataArray - The dataArray value.
   * @param {number} width - The width value
   * @param {number} height - The height value
   * @param {number} offsetX - The offsetX value
   * @param {number} offsetY - The offsetY value
   * @param {boolean} bind - The bind value
   */
  populate(dataArray, width, height, offsetX = 0, offsetY = 0, bind = true) {
    const gl = this.__gl;
    if (bind) gl.bindTexture(gl.TEXTURE_2D, this.__gltex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, offsetX, offsetY, width, height, this.__format, this.__type, dataArray);
  }

  /**
   * Returns the `width`(Index 0) and the `height`(Index 1) of the GL Texture.
   *
   * @return {array} - The return value.
   */
  getSize() {
    return [this.width, this.height]
  }

  /**
   * Returns the value of the WebGLTexture value
   *
   * @return {WebGLTexture} - The return value.
   */
  get glTex() {
    return this.__gltex
  }

  /**
   * Returns the value of the WebGLTexture value
   *
   * @return {WebGLTexture} - The return value.
   */
  getTexHdl() {
    return this.__gltex
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @return {any} - The return value.
   * @deprecated
   */
  bind(renderstate, unif) {
    console.warn("'bind' is deprecated. Please use 'bindToUniform'");
    return this.bindToUniform(renderstate, unif)
  }

  /**
   * The preBind method.
   * @param {object} unif - The unif value.
   * @param {object} unifs - The unifs value.
   * @return {object} - The return value.
   */
  preBind(unif, unifs) {
    return {
      textureTypeUnif: unifs[unif.name + 'Type'],
      textureDescUnif: unifs[unif.name + 'Desc'],
    }
  }

  /**
   * Binds Texture to the Uniform attribute.
   *
   * @param {object} renderstate - The renderstate value.
   * @param {object} unif - The unif value.
   * @param {object} bindings - The bindings value.
   * @return {boolean} - The return value.
   */
  bindToUniform(renderstate, unif, bindings) {
    if (!this.__loaded) {
      return false
    }
    if (!this.__gltex) {
      throw new Error('Unable to bind non-initialized or deleted texture.')
    }

    const unit = renderstate.boundTextures++;
    const texId = this.__gl.TEXTURE0 + unit;
    const gl = this.__gl;
    gl.activeTexture(texId);
    gl.bindTexture(gl.TEXTURE_2D, this.__gltex);
    gl.uniform1i(unif.location, unit);

    if (bindings) {
      if (bindings.textureTypeUnif) {
        gl.uniform1i(bindings.textureTypeUnif.location, this.textureType);
      }

      if (bindings.textureDescUnif) {
        this.__gl.uniform4fv(bindings.textureDescUnif.location, this.textureDesc);
      }
    }

    return true
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    if (this.__texture) {
      this.__texture.setMetadata('gltexture', undefined);
    }
    this.__gl.deleteTexture(this.__gltex);
    this.__gltex = undefined;
  }
}

/** Class representing a geom shader binding.
 * @private
 */
class GeomShaderBinding {
  /**
   * Create a geom shader binding.
   * @param {any} gl - The gl value.
   * @param {any} shaderAttrs - The shader attributes.
   * @param {any} glattrbuffers - The glattrbuffers value.
   * @param {any} indexBuffer - The index buffer.
   */
  constructor(gl, shaderAttrs, glattrbuffers, indexBuffer) {
    this.__gl = gl;
    this.__shaderAttrs = shaderAttrs;
    this.__glattrbuffers = glattrbuffers;
    this.__indexBuffer = indexBuffer;
  }

  /**
   * The bind method.
   * @param {any} renderstate - The render state.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    const gl = this.__gl;

    for (const attrName in this.__shaderAttrs) {
      if (attrName == 'instancedIds') continue
      const attrDesc = this.__shaderAttrs[attrName];
      const location = attrDesc.location;
      if (location == -1) continue
      const glattrbuffer = this.__glattrbuffers[attrName];
      if (!glattrbuffer) {
        gl.disableVertexAttribArray(location);
        continue
      }

      let dimension;
      let elementSize;
      let dataType;
      switch (glattrbuffer.dataType) {
        case UInt8:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_BYTE;
          break
        case SInt8:
          dimension = 1;
          elementSize = 4;
          dataType = gl.BYTE;
          break
        case UInt16:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_SHORT;
          break
        case SInt16:
          dimension = 1;
          elementSize = 4;
          dataType = gl.SHORT;
          break
        case UInt32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_INT;
          break
        case SInt32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.INT;
          break
        case Float32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec2:
          dimension = 2;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec3$1:
          dimension = 3;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec4$1:
        case Color:
          dimension = 4;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case RGBA:
          dimension = 4;
          elementSize = 1;
          dataType = gl.UNSIGNED_BYTE;
          break
        default:
          throw 'Unhandled Type'
      }

      const stride = dimension * elementSize;
      const offset = glattrbuffer.offset != undefined ? glattrbuffer.offset * dimension * elementSize : 0;
      const normalized = glattrbuffer.normalized == true;
      const instanced = attrDesc.instanced;

      gl.enableVertexAttribArray(location);
      gl.bindBuffer(gl.ARRAY_BUFFER, glattrbuffer.buffer);
      gl.vertexAttribPointer(location, dimension, dataType, normalized, stride, offset);

      if (gl.vertexAttribDivisor) {
        if (instanced == true) {
          gl.vertexAttribDivisor(location, 1); // This makes it instanced
        } else {
          gl.vertexAttribDivisor(location, 0); // This makes it not-instanced
        }
      }

      // console.log("Binding :" + attrName + " to attr:" + location + " count:" + glattrbuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.__indexBuffer);

    return true
  }

  /**
   * The unbind method.
   */
  unbind() {
    const gl = this.__gl;
    for (const attrName in this.__shaderAttrs) {
      const attrDesc = this.__shaderAttrs[attrName];
      const location = attrDesc.location;
      if (location == -1) continue
      gl.disableVertexAttribArray(location);
      gl.vertexAttribDivisor(location, 0); // This makes it not-instanced

      // console.log("Binding :" + attrName + " to attr:" + location + " count:" + glattrbuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {}
}

/** Class representing vertex array objects (VAO) geom shader binding.
 * @private
 */
class VAOGeomShaderBinding {
  /**
   * Create VAO geom shader binding.
   * @param {any} gl - The gl value.
   * @param {any} shaderAttrs - The shaderAttrs value.
   * @param {any} glattrbuffers - The glattrbuffers value.
   * @param {any} indexBuffer - The indexBuffer value.
   */
  constructor(gl, shaderAttrs, glattrbuffers, indexBuffer) {
    this.__gl = gl;
    this.__vao = gl.createVertexArray();
    gl.bindVertexArray(this.__vao);

    for (const attrName in shaderAttrs) {
      if (attrName == 'instancedIds') continue

      const attrDesc = shaderAttrs[attrName];
      const location = attrDesc.location;
      if (location == -1) continue
      const glattrbuffer = glattrbuffers[attrName];
      if (!glattrbuffer) {
        // console.warn("glattrbuffer missing:" + attrName + " location:" + location);
        gl.disableVertexAttribArray(location);
        continue
      }

      let dimension;
      let elementSize;
      let dataType;
      switch (glattrbuffer.dataType) {
        case UInt8:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_BYTE;
          break
        case SInt8:
          dimension = 1;
          elementSize = 4;
          dataType = gl.BYTE;
          break
        case UInt16:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_SHORT;
          break
        case SInt16:
          dimension = 1;
          elementSize = 4;
          dataType = gl.SHORT;
          break
        case UInt32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.UNSIGNED_INT;
          break
        case SInt32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.INT;
          break
        case Float32:
          dimension = 1;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec2:
          dimension = 2;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec3$1:
          dimension = 3;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case Vec4$1:
        case Color:
          dimension = 4;
          elementSize = 4;
          dataType = gl.FLOAT;
          break
        case RGBA:
          dimension = 4;
          elementSize = 1;
          dataType = gl.UNSIGNED_BYTE;
          break
        default:
          throw 'Unhandled Type'
      }

      const stride = dimension * elementSize;
      const offset = glattrbuffer.offset != undefined ? glattrbuffer.offset * dimension * elementSize : 0;
      const normalized = glattrbuffer.normalized == true;
      const instanced = attrDesc.instanced;

      gl.enableVertexAttribArray(location);
      gl.bindBuffer(gl.ARRAY_BUFFER, glattrbuffer.buffer);
      gl.vertexAttribPointer(location, dimension, dataType, normalized, stride, offset);
      if (instanced) {
        gl.vertexAttribDivisor(location, 1); // This makes it instanced
      } else {
        gl.vertexAttribDivisor(location, 0); // This makes it not-instanced
      }

      // console.log("Binding :" + attrName + " to attr:" + location + " count:" + glattrbuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
    }

    this.__indexBuffer = indexBuffer;
  }

  /**
   * The bind method.
   * @param {any} renderstate - The render state.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    this.__gl.bindVertexArray(this.__vao);
    if (this.__indexBuffer) this.__gl.bindBuffer(this.__gl.ELEMENT_ARRAY_BUFFER, this.__indexBuffer);
    return true
  }

  /**
   * The unbind method.
   */
  unbind() {
    const gl = this.__gl;
    for (const attrName in this.__shaderAttrs) {
      const attrDesc = this.__shaderAttrs[attrName];
      const location = attrDesc.location;
      if (location == -1) continue
      gl.disableVertexAttribArray(location);
      gl.vertexAttribDivisor(location, 0); // This makes it not-instanced

      // console.log("Unbinding :" + attrName + " to attr:" + location + " count:" + glattrbuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
    }

    this.__gl.bindVertexArray(null);
    if (this.__indexBuffer) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.__gl.deleteVertexArray(this.__vao);
  }
}

function generateShaderGeomBinding(gl, shaderAttrs, glattrbuffers, indexBuffer) {
  if (gl.createVertexArray == null) {
    return new GeomShaderBinding(gl, shaderAttrs, glattrbuffers, indexBuffer)
  } else {
    return new VAOGeomShaderBinding(gl, shaderAttrs, glattrbuffers, indexBuffer)
  }
}

/** Class representing a GL geom.
 * @private
 */
class GLGeom extends RefCounted {
  /**
   * Create a GL geom.
   * @param {any} gl - The gl value.
   * @param {any} geom - The geom value.
   */
  constructor(gl, geom) {
    super();
    this.__gl = gl;
    this.__geom = geom;
    this.__glattrs = {};

    this.__glattrbuffers = {};
    this.__shaderBindings = {};

    const updateBuffers = (opts) => {
      this.updateBuffers(opts);
      this.emit('updated', {});
    };
    this.__geom.on('geomDataChanged', updateBuffers);

    const regenBuffers = (opts) => {
      this.clearShaderBindings();
      this.updateBuffers(opts);
      this.emit('updated', {});
    };
    this.__geom.on('geomDataTopologyChanged', regenBuffers);
  }

  /**
   * The getGeom method.
   * @return {any} - The return value.
   */
  getGeom() {
    return this.__geom
  }

  // /////////////////////////////////////
  // Buffers

  /**
   * The genBuffers method.
   */
  genBuffers() {}

  /**
   * The updateBuffers method.
   * @param {any} opts - The opts value.
   */
  updateBuffers(opts) {}

  // /////////////////////////////////////
  // Binding

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    if (this.__destroyed) throw new Error('Error binding a destroyed geom')

    let shaderBinding = this.__shaderBindings[renderstate.shaderkey];
    if (!shaderBinding) {
      const gl = this.__gl;
      shaderBinding = generateShaderGeomBinding(gl, renderstate.attrs, this.__glattrbuffers, this.__indexBuffer);
      this.__shaderBindings[renderstate.shaderkey] = shaderBinding;
    }
    shaderBinding.bind(renderstate);
    return true
  }

  /**
   * The unbind method.
   * @param {any} renderstate - The renderstate value.
   */
  unbind(renderstate) {
    // Unbinding a geom is important as it puts back some important
    // GL state. (vertexAttribDivisor)
    const shaderBinding = this.__shaderBindings[renderstate.shaderkey];
    if (shaderBinding) {
      shaderBinding.unbind(renderstate);
    }
  }

  // /////////////////////////////////////
  // Drawing
  // Draw an item to screen.

  /**
   * The draw method.
   */
  draw() {
    throw new Error('Not implemented. Implement this method in a derived class.')
  }

  /**
   * The drawInstanced method.
   * @param {any} instanceCount - The instanceCount param.
   */
  drawInstanced(instanceCount) {
    throw new Error('Not implemented. Implement this method in a derived class.')
  }

  /**
   * The bindAndDraw method.
   * @param {any} renderstate - The renderstate value.
   */
  bindAndDraw(renderstate) {
    this.bind(renderstate);
    this.draw(renderstate);
  }

  /**
   * The clearShaderBindings method.
   */
  clearShaderBindings() {
    for (const shaderkey in this.__shaderBindings) {
      const shaderBinding = this.__shaderBindings[shaderkey];
      shaderBinding.destroy();
    }
    this.__shaderBindings = {};
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.__geom.deleteMetadata('glgeom');

    this.clearShaderBindings();

    const gl = this.__gl;
    // eslint-disable-next-line guard-for-in
    for (const attrName in this.__glattrbuffers) {
      const glbuffer = this.__glattrbuffers[attrName];
      if (glbuffer.shared) continue /* This buffer is shared between geoms. do not destroy */
      gl.deleteBuffer(glbuffer.buffer);
    }
    this.__glattrs = {};

    this.__shaderBindings = {};
    this.__destroyed = true;

    //  Note: PoTree listens to this event. If moved up into RefCounted, make sure it is still emitted.
    this.emit('destructing', {});
  }
}

/** Class representing a GL mesh.
 * @extends GLGeom
 * @private
 */
class GLMesh extends GLGeom {
  /**
   * Create a GL mesh.
   * @param {any} gl - The gl value.
   * @param {any} mesh - The mesh value.
   */
  constructor(gl, mesh) {
    super(gl, mesh);
    this.genBuffers();
  }

  /**
   * The getNumTriangles method.
   * @return {any} - The return value.
   */
  getNumTriangles() {
    return this.__numTriangles
  }

  // /////////////////////////////////////
  // Buffers

  /**
   * The genBuffers method.
   */
  genBuffers() {
    super.genBuffers();

    const gl = this.__gl;

    const geomBuffers = this.__geom.genBuffers();
    const indices = geomBuffers.indices;
    this.__numTriIndices = geomBuffers.indices.length;
    if (indices instanceof Uint8Array) this.__indexDataType = this.__gl.UNSIGNED_BYTE;
    if (indices instanceof Uint16Array) this.__indexDataType = this.__gl.UNSIGNED_SHORT;
    if (indices instanceof Uint32Array) this.__indexDataType = this.__gl.UNSIGNED_INT;

    this.__numTriangles = indices.length / 3;
    this.__numRenderVerts = geomBuffers.numRenderVerts;

    this.__indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.__indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geomBuffers.indices, gl.STATIC_DRAW);

    // Create some vertex attribute buffers
    // const debugAttrValues = false;
    // let maxIndex;
    // if (debugAttrValues)
    //   maxIndex = Math.max(...indices);
    for (const attrName in geomBuffers.attrBuffers) {
      const attrData = geomBuffers.attrBuffers[attrName];

      const attrBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, attrBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);

      this.__glattrbuffers[attrName] = {
        buffer: attrBuffer,
        dataType: attrData.dataType,
        normalized: attrData.normalized,
      };

      if (attrName == 'textureCoords') this.__glattrbuffers['texCoords'] = this.__glattrbuffers['textureCoords'];
    }
  }

  /**
   * The updateBuffers method.
   * @param {any} opts - The opts value.
   */
  updateBuffers(opts) {
    const gl = this.__gl;

    const geomBuffers = this.__geom.genBuffers({ includeIndices: false });
    for (const attrName in geomBuffers.attrBuffers) {
      const attrData = geomBuffers.attrBuffers[attrName];
      const glattr = this.__glattrbuffers[attrName];
      gl.bindBuffer(gl.ARRAY_BUFFER, glattr.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);
    }
  }

  /**
   * The getNumUnSplitVerts method.
   * @return {any} - The return value.
   */
  getNumUnSplitVerts() {
    return this.__geom.getNumVertices()
  }

  /**
   * The getNumSplitVerts method.
   * @return {any} - The return value.
   */
  getNumSplitVerts() {
    return this.__numRenderVerts
  }

  // ////////////////////////////////
  // Wireframes

  /**
   * The generateWireframesVAO method.
   * @return {any} - The return value.
   */
  generateWireframesVAO() {
    if (!this.__vao) return false

    if (!this.__geom.edgeVerts) this.__geom.genTopologyInfo();

    // Generate the wireframes VAO.
    // It can share buffers with the regular VAO, but provide a different index buffer.
    if (this.__wireframesVao) this.__ext.deleteVertexArrayOES(this.__wireframesVao);
    this.__wireframesVao = this.__ext.createVertexArrayOES();
    this.__ext.bindVertexArrayOES(this.__wireframesVao);

    const gl = this.__gl;
    const wireframeIndexBuffer = gl.createBuffer();
    const wireframeIndices = Uint32Array.from(this.__geom.edgeVerts);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wireframeIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, wireframeIndices, gl.STATIC_DRAW);

    const positionsBuffer = this.__glattrbuffers['positions'].buffer;
    gl.enableVertexAttribArray(0);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionsBuffer);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 3 * 4, 0);

    this.__numWireIndices = wireframeIndices.length;
    this.__ext.bindVertexArrayOES(null); // Note: is this necessary?
  }

  /**
   * The bindWireframeVAO method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bindWireframeVAO(renderstate) {
    if (this.__wireframesVao == undefined) return false
    this.__ext.bindVertexArrayOES(this.__wireframesVao);
    return true
  }

  /**
   * The unbindWireframeVAO method.
   */
  unbindWireframeVAO() {
    this.__ext.bindVertexArrayOES(null); // Note: is this necessary?
  }

  /**
   * Draw an item to screen.
   */
  drawWireframe() {
    if (this.__wireframesVao) this.__gl.drawElements(this.__gl.LINES, this.__numWireIndices, this.__gl.UNSIGNED_INT, 0);
  }

  // ////////////////////////////////
  // Hard Edges

  /**
   * The generateHardEdgesVAO method.
   * @return {any} - The return value.
   */
  generateHardEdgesVAO() {
    if (!this.__vao) return false

    // generate the wireframes VAO.
    // It can share buffers with the regular VAO, but provide a different index buffer.
    if (this.__hardEdgesVao) this.__ext.deleteVertexArrayOES(this.__hardEdgesVao);
    this.__hardEdgesVao = this.__ext.createVertexArrayOES();
    this.__ext.bindVertexArrayOES(this.__hardEdgesVao);

    const gl = this.__gl;
    const hardEdgeIndexBuffer = gl.createBuffer();
    const hardEdgeIndices = this.__geom.computeHardEdgesIndices();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hardEdgeIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, hardEdgeIndices, gl.STATIC_DRAW);

    const positionsBuffer = this.__glattrbuffers['positions'].buffer;
    gl.enableVertexAttribArray(0);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionsBuffer);
    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 3 * 4, 0);

    this.__numEdgeIndices = hardEdgeIndices.length;
    this.__ext.bindVertexArrayOES(null); // Note: is this necessary?
  }

  /**
   * The bindHardEdgesVAO method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bindHardEdgesVAO(renderstate) {
    if (this.__hardEdgesVao == undefined) return false
    this.__ext.bindVertexArrayOES(this.__hardEdgesVao);
    return true
  }

  /**
   * The unbindHardEdgesVAO method.
   */
  unbindHardEdgesVAO() {
    this.__ext.bindVertexArrayOES(null); // Note: is this necessary?
  }

  /**
   * Draw an item to screen.
   */
  drawHardEdges() {
    if (this.__hardEdgesVao) this.__gl.drawElements(this.__gl.LINES, this.__numEdgeIndices, this.__gl.UNSIGNED_INT, 0);
  }

  // ////////////////////////////////
  // Drawing Mesh Points.

  /**
   * The drawPoints method.
   */
  drawPoints() {
    this.__gl.drawArrays(this.__gl.POINTS, 0, this.__geom.numVertices());
  }

  // ////////////////////////////////
  // Regular Drawing.

  /**
   * Draw an item to screen.
   */
  draw() {
    this.__gl.drawElements(this.__gl.TRIANGLES, this.__numTriIndices, this.__indexDataType, 0);
  }

  /**
   * The drawInstanced method.
   * @param {any} instanceCount - The instanceCount value.
   */
  drawInstanced(instanceCount) {
    this.__gl.drawElementsInstanced(this.__gl.TRIANGLES, this.__numTriIndices, this.__indexDataType, 0, instanceCount);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    const gl = this.__gl;
    gl.deleteBuffer(this.__indexBuffer);
    this.__indexBuffer = undefined;
    // if (this.__wireframesVao)
    //     gl.deleteVertexArray(this.__wireframesVao);
    // if (this.__hardEdgesVao)
    //     gl.deleteVertexArray(this.__hardEdgesVao);
  }
}

/** Class representing GL lines.
 * @extends GLGeom
 * @private
 */
class GLLines extends GLGeom {
  /**
   * Create a GL line.
   * @param {any} gl - The gl value.
   * @param {any} lines - The geom value.
   */
  constructor(gl, lines) {
    super(gl, lines);

    this.genBuffers();
  }

  /**
   * The genBuffers method.
   */
  genBuffers() {
    super.genBuffers();

    const gl = this.__gl;
    const geomBuffers = this.__geom.genBuffers();
    const indices = geomBuffers.indices;

    this.fatLines =
      (this.__geom.lineThickness > 0 || geomBuffers.attrBuffers.lineThickness) && gl.floatTexturesSupported;

    if (this.fatLines) {
      if (!gl.__quadVertexIdsBuffer) {
        gl.setupInstancedQuad();
      }
      this.__glattrbuffers.vertexIDs = gl.__quadattrbuffers.vertexIDs;

      this.__drawCount = indices.length / 2;

      const vertexAttributes = this.__geom.getVertexAttributes();
      const positions = vertexAttributes.positions;
      const lineThicknessAttr = vertexAttributes.lineThickness;

      const stride = 4; // The number of floats per draw item.
      const dataArray = new Float32Array(positions.length * stride);
      for (let i = 0; i < positions.length; i++) {
        const pos = Vec3$1.createFromBuffer(dataArray.buffer, i * stride * 4);
        pos.setFromOther(positions.getValueRef(i));

        // The thickness of the line.
        if (lineThicknessAttr) dataArray[i * 4 + 3] = lineThicknessAttr.getFloat32Value(i);
        else dataArray[i * 4 + 3] = this.__geom.lineThickness;
      }
      this.__positionsTexture = new GLTexture2D(gl, {
        format: 'RGBA',
        type: 'FLOAT',
        width: positions.length,
        /* each pixel has 4 floats*/
        height: 1,
        filter: 'NEAREST',
        wrap: 'CLAMP_TO_EDGE',
        data: dataArray,
        mipMapped: false,
      });

      const indexArray = new Float32Array(indices.length);
      for (let i = 0; i < indices.length; i++) {
        let seqentialIndex;
        if (i % 2 == 0) {
          seqentialIndex = i > 0 ? indices[i] == indices[i - 1] : indices[i] == indices[indices.length - 1];
        } else {
          seqentialIndex = i < indices.length - 1 ? indices[i] == indices[i + 1] : indices[i] == indices[0];
        }
        // encode the flag into the indices values.
        // this flag is decoded in GLSL.
        indexArray[i] = (seqentialIndex ? 1 : 0) + indices[i] * 2;
      }
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);

      this.__glattrbuffers.segmentIndices = {
        buffer: indexBuffer,
        dimension: 2,
      };
    } else {
      this.__indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.__indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      for (const attrName in geomBuffers.attrBuffers) {
        const attrData = geomBuffers.attrBuffers[attrName];

        const attrBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, attrBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);

        this.__glattrbuffers[attrName] = {
          buffer: attrBuffer,
          dataType: attrData.dataType,
          normalized: attrData.normalized,
        };
      }

      // Cache the size so we know later if it changed (see below)
      this.__numSegIndices = indices.length;
      this.__numVertices = geomBuffers.numVertices;
    }

    if (indices instanceof Uint8Array) this.__indexDataType = this.__gl.UNSIGNED_BYTE;
    if (indices instanceof Uint16Array) this.__indexDataType = this.__gl.UNSIGNED_SHORT;
    if (indices instanceof Uint32Array) this.__indexDataType = this.__gl.UNSIGNED_INT;
  }

  /**
   * The updateBuffers method.
   * @param {any} opts - The opts value.
   */
  updateBuffers(opts) {
    const gl = this.__gl;
    const geomBuffers = this.__geom.genBuffers();
    const indices = geomBuffers.indices;

    if (this.fatLines) {
      this.__drawCount = indices.length / 2; // every pair of verts draws a quad.

      const vertexAttributes = this.__geom.getVertexAttributes();

      const positions = vertexAttributes.positions;
      const lineThicknessAttr = vertexAttributes.lineThickness;

      const stride = 4; // The number of floats per draw item.
      const dataArray = new Float32Array(positions.length * stride);
      for (let i = 0; i < positions.length; i++) {
        const pos = Vec3$1.createFromBuffer(dataArray.buffer, i * stride * 4);
        pos.setFromOther(positions.getValueRef(i));

        // The thickness of the line.
        if (lineThicknessAttr) dataArray[i * 4 + 3] = lineThicknessAttr.getFloat32Value(i);
        else dataArray[i * 4 + 3] = this.__geom.lineThickness;
      }

      this.__positionsTexture.bufferData(dataArray, positions.length, 1);

      const indexArray = new Float32Array(indices.length);
      for (let i = 0; i < indices.length; i++) {
        let seqentialIndex;
        if (i % 2 == 0) seqentialIndex = i > 0 && indices[i] == indices[i - 1];
        else seqentialIndex = i < indices.length - 1 && indices[i] == indices[i + 1];
        indexArray[i] = (seqentialIndex ? 1 : 0) + indices[i] * 2;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this.__glattrbuffers.segmentIndices.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, indexArray, gl.STATIC_DRAW);
    } else {
      const vertexAttributes = this.__geom.getVertexAttributes();

      if (opts && opts.indicesChanged) {
        const indices = this.__geom.getIndices();
        if (this.__numSegIndices != indices.length) {
          gl.deleteBuffer(this.__indexBuffer);
          this.__indexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.__indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        this.__numSegIndices = indices.length;
      }

      // Update the vertex attribute buffers
      const numVertsChanged = geomBuffers.numVertices != this.__numVertices;
      for (const attrName in geomBuffers.attrBuffers) {
        const attrData = geomBuffers.attrBuffers[attrName];
        const glattr = this.__glattrbuffers[attrName];
        if (numVertsChanged) {
          gl.deleteBuffer(glattr.buffer);
          glattr.buffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, glattr.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);
      }

      // Cache the size so we know later if it changed (see below)
      this.__numVertices = geomBuffers.numVertices;
      this.__numSegIndices = indices.length;
    }

    if (indices instanceof Uint8Array) this.__indexDataType = this.__gl.UNSIGNED_BYTE;
    if (indices instanceof Uint16Array) this.__indexDataType = this.__gl.UNSIGNED_SHORT;
    if (indices instanceof Uint32Array) this.__indexDataType = this.__gl.UNSIGNED_INT;
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    if (this.fatLines && 'LineThickness' in renderstate.unifs) {
      // TODO: Provide a geomdata shader for thick lines.

      const gl = this.__gl;

      let shaderBinding = this.__shaderBindings[renderstate.shaderkey];
      if (!shaderBinding) {
        shaderBinding = generateShaderGeomBinding(gl, renderstate.attrs, this.__glattrbuffers, gl.__quadIndexBuffer);
        this.__shaderBindings[renderstate.shaderkey] = shaderBinding;
      }
      shaderBinding.bind(renderstate);
      {
        const unifs = renderstate.unifs;
        if (unifs.positionsTexture) {
          this.__positionsTexture.bindToUniform(renderstate, unifs.positionsTexture);
          gl.uniform1i(unifs.positionsTextureSize.location, this.__positionsTexture.width);
        }
      }

      const unifs = renderstate.unifs;
      gl.uniform1f(
        unifs.LineThickness.location,
        (this.__geom.lineThickness ? this.__geom.lineThickness : 1.0) * renderstate.viewScale
      );
      return true
    } else {
      return super.bind(renderstate)
    }
  }

  // ////////////////////////////////
  // Drawing Lines Points.

  /**
   * The drawPoints method.
   */
  drawPoints() {
    this.__gl.drawArrays(this.__gl.POINTS, 0, this.__geom.numVertices());
  }

  // ////////////////////////////////
  // Regular Drawing.

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    const gl = this.__gl;
    if (this.fatLines) {
      if (renderstate.unifs.LineThickness)
        gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, this.__drawCount);

      // Note: We don't have a solution for drawing fat lines to the geom data buffer.
    } else {
      gl.drawElements(this.__gl.LINES, this.__numSegIndices, this.__indexDataType, 0);
    }
  }

  /**
   * The drawInstanced method.
   * @param {any} instanceCount - The instanceCount value.
   */
  drawInstanced(instanceCount) {
    this.__gl.drawElementsInstanced(this.__gl.LINES, this.__numSegIndices, this.__indexDataType, 0, instanceCount);
  }
}

/** Class representing GL points.
 * @extends GLGeom
 * @private
 */
class GLPoints extends GLGeom {
  /**
   * Create a GL point.
   * @param {any} gl - The gl value.
   * @param {any} points - The points value.
   */
  constructor(gl, points) {
    super(gl, points);
    this.genBuffers();
  }

  /**
   * The genBuffers method.
   */
  genBuffers() {
    super.genBuffers();

    const gl = this.__gl;

    const geomBuffers = this.__geom.genBuffers();

    for (const attrName in geomBuffers.attrBuffers) {
      const attrData = geomBuffers.attrBuffers[attrName];

      const attrBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, attrBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);

      this.__glattrbuffers[attrName] = {
        buffer: attrBuffer,
        dataType: attrData.dataType,
        normalized: attrData.normalized,
      };
    }

    this.__numVertices = geomBuffers.numVertices;
    this.__vboState = 2;
  }

  /**
   * The updateBuffers method.
   * @param {any} opts - The opts value.
   */
  updateBuffers(opts) {
    const gl = this.__gl;
    const geomBuffers = this.__geom.genBuffers();

    // Update the vertex attribute buffers
    const numVertsChanged = geomBuffers.numVertices != this.__numVertices;
    for (const attrName in geomBuffers.attrBuffers) {
      const attrData = geomBuffers.attrBuffers[attrName];
      const glattr = this.__glattrbuffers[attrName];
      if (numVertsChanged) {
        gl.deleteBuffer(glattr.buffer);
        glattr.buffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, glattr.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);
    }

    // Cache the size so we know later if it changed (see below)
    this.__numVertices = geomBuffers.numVertices;
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    if (renderstate.unifs.PointSize) {
      const gl = this.__gl;
      let shaderBinding = this.__shaderBindings[renderstate.shaderkey];
      if (!shaderBinding) {
        if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();

        // Merge the points attrs with the quad attrs.
        const attrbuffers = Object.assign(this.__glattrbuffers, gl.__quadattrbuffers);

        shaderBinding = generateShaderGeomBinding(gl, renderstate.attrs, attrbuffers, gl.__quadIndexBuffer);
        this.__shaderBindings[renderstate.shaderkey] = shaderBinding;
      }
      shaderBinding.bind(renderstate);
      return true
    } else {
      return super.bind(renderstate)
    }
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    const gl = this.__gl;
    if (renderstate.unifs.PointSize) {
      gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, this.__numVertices);
    } else {
      gl.drawArrays(gl.POINTS, 0, this.__numVertices);
    }
  }

  /**
   * The drawInstanced method.
   * @param {any} instanceCount - The instanceCount value.
   */
  drawInstanced(instanceCount) {
    this.__gl.drawArraysInstanced(this.__gl.POINTS, 0, this.__numVertices, instanceCount);
  }
}
// GLPoints;

const glslTypes = {
  bool: Boolean,
  int: SInt32,
  uint: UInt32,
  float: Float32,
  ivec2: Vec2,
  ivec3: Vec3$1,
  ivec4: Vec4$1,
  vec2: Vec2,
  vec3: Vec3$1,
  vec4: Vec4$1,
  color: Color,
  mat3: Mat3$1,
  mat4: Mat4,
  sampler2D: BaseImage,
};

/** Class representing a shader library.
 * @private
 */
class ShaderLibrary {
  /**
   * Create a shader library.
   */
  constructor() {
    this.__shaderModules = {};
  }

  /**
   * The hasShaderModule method.
   * @param {string} shaderName - The shader name.
   * @return {any} - The return value.
   */
  hasShaderModule(shaderName) {
    return shaderName in this.__shaderModules
  }

  /**
   * The setShaderModule method.
   * @param {string} shaderName - The shader name.
   * @param {any} shader - The shader value.
   * @return {any} - The return value.
   */
  setShaderModule(shaderName, shader) {
    // console.log("setShaderModule:" + shaderName);
    return this.parseShader(shaderName, shader)
  }

  /**
   * The getShaderModule method.
   * @param {string} shaderName - The shader name.
   * @return {any} - The return value.
   */
  getShaderModule(shaderName) {
    return this.__shaderModules[shaderName]
  }

  /**
   * The getShaderModuleNames method.
   * @return {any} - The return value.
   */
  getShaderModuleNames() {
    const shaderNames = [];
    for (const shaderName in this.__shaderModules) shaderNames.push(shaderName);
    return shaderNames
  }

  /**
   * The parseShader method.
   * @param {string} shaderName - The shader name.
   * @param {any} glsl - The glsl param.
   * @return {any} - The return value.
   */
  parseShader(shaderName, glsl) {
    const parsePath = (path) => {
      // An absolute path
      if (path.startsWith('..')) {
        const parentFolder = fileFolder.substring(0, fileFolder.lastIndexOf('/'));
        return parentFolder + path.substring(2)
      } else if (path.startsWith('.')) return fileFolder + path.substring(1)
      else if (path.startsWith('/')) return path.substring(1)
      else return path
    };

    // console.log("parseShader:" + shaderName);
    const shaderNameHash = StringFunctions.hashStr(shaderName);
    const fileFolder = shaderName.substring(0, shaderName.lastIndexOf('/'));
    const lines = glsl.split('\n');

    const result = {
      glsl: ' //starting:' + shaderName + '\n',
      lines: lines,
      numLines: 0,
      includeMetaData: [],
      uniforms: {},
      attributes: {},
    };

    const WHITESPACE_RE = /\s+/;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      let trimmedline = line.trim();
      if (trimmedline.startsWith('//') || trimmedline.startsWith('*')) {
        result.glsl = result.glsl + line + '\n';
        result.numLines++;
        continue
      }
      if (trimmedline.indexOf('//') != -1) {
        trimmedline = trimmedline.slice(0, trimmedline.indexOf('//')).trim();
      }

      if (trimmedline.startsWith('<%') || trimmedline.startsWith('</%')) {
        const parseTag = function (line) {
          if (line.startsWith('</%')) line = line.slice(3);
          else line = line.slice(2);
          if (line.endsWith('/>')) line = line.slice(0, line.length - 2);
          else line = line.slice(0, line.length - 1);
          const parts = line.split(WHITESPACE_RE);
          const tag = parts.shift();
          const result = {
            tag: tag,
            attributes: {},
          };
          for (const attr of parts) {
            const pairs = attr.split('=');
            result.attributes[pairs[0]] = pairs[1].replace(/['"]+/g, '');
          }
          return result
        };

        const elements = parseTag(lines[i].trim());
        switch (elements.tag) {
          case 'include': {
            const includeFile = parsePath(elements.attributes.file);
            if (!this.hasShaderModule(includeFile)) {
              throw new Error(
                'Error while parsing :' +
                  shaderName +
                  ' \nShader module not found:' +
                  includeFile +
                  '\n in:' +
                  this.getShaderModuleNames()
              )
            }

            const shaderModule = this.getShaderModule(includeFile);

            const includedModuleHash = StringFunctions.hashStr(elements.attributes.file);
            let includedGLSL = shaderModule.glsl;

            // Remove the first line of GLSL, and replace it with the line tag.
            includedGLSL = includedGLSL.substring(includedGLSL.indexOf('\n') + 1);
            result.glsl = result.glsl + ' //including:' + elements.attributes.file + '\n';

            const repl = {};
            for (const key in elements.attributes) {
              if (key == 'file') continue
              const value = elements.attributes[key];
              includedGLSL = StringFunctions.replaceAll(includedGLSL, key, value);
              repl[key] = value;
            }

            result.glsl = result.glsl + includedGLSL;
            result.includeMetaData.push({
              src: result.numLines,
              tgt: i,
              length: shaderModule.numLines,
              key: includeFile,
            });

            // Add line number tag to GLSL so that the GLSL error messages have the correct file name and line number.
            result.glsl = result.glsl + ' //continuing:' + shaderName + '\n';
            result.numLines += shaderModule.numLines + 1;

            for (const name in shaderModule.attributes) {
              let newname = name;
              for (const key in repl) newname = StringFunctions.replaceAll(newname, key, repl[key]);
              result.attributes[newname] = shaderModule.attributes[name];
            }
            for (const name in shaderModule.uniforms) {
              let newname = name;
              for (const key in repl) newname = StringFunctions.replaceAll(newname, key, repl[key]);
              result.uniforms[newname] = shaderModule.uniforms[name];
            }

            break
          }
          default: {
            console.warn('Error while parsing :' + shaderName + ' \nUnhandled line:' + line);
            continue
          }
        }
      } else {
        const parseAttr = (parts, instanced) => {
          if (!(parts[1] in glslTypes))
            throw new Error('Error while parsing :' + shaderName + ' \nType not recognized:' + parts[1])
          const name = parts[2].slice(0, parts[2].length - 1);
          result.attributes[name] = {
            type: glslTypes[parts[1]],
            instanced: instanced,
          };
          // console.log('attributes:' + name + ":" + parts[1]);

          if (parts[1] == 'color') {
            parts[1] = 'vec4';
            line = parts.join(' ');
          }
        };
        if (trimmedline.startsWith('struct')) {
          let membersStr = '';
          if (trimmedline.indexOf('}') != -1) {
            membersStr = trimmedline.substring(trimmedline.indexOf('{') + 1, trimmedline.indexOf('}') - 1);
          } else {
            i++;
            while (true) {
              line += lines[i] + '\n';
              membersStr += line.trim();
              i++;
              if (membersStr.indexOf('}') != -1) break
            }
          }
          const structMembers = membersStr.substring(membersStr.indexOf('{') + 1, membersStr.indexOf('}') - 1);
          const members = structMembers.split(';');
          const structDesc = [];
          for (const member of members) {
            if (member.length == 0) continue
            const memberparts = member.trim().split(WHITESPACE_RE);
            structDesc.push({
              name: memberparts[1],
              type: glslTypes[memberparts[0]],
            });
          }
          const parts = trimmedline.split(WHITESPACE_RE);
          glslTypes[parts[1]] = structDesc;
        }
        if (trimmedline.startsWith('attribute')) {
          const parts = trimmedline.split(WHITESPACE_RE);
          parseAttr(parts, false);
        }
        if (trimmedline.startsWith('instancedattribute')) {
          const parts = trimmedline.split(WHITESPACE_RE);
          parseAttr(parts, true);
          parts[0] = 'attribute';
          line = parts.join(' ');
        } else if (trimmedline.startsWith('uniform')) {
          const parts = trimmedline.split(WHITESPACE_RE);

          // When a precision qualifier exists in the uniform definition.
          // e.g. uniform highp int instancesTextureSize;
          let typeIndex = 1;
          if (parts.length == 4) typeIndex = 2;
          const typeName = parts[typeIndex];
          if (!(typeName in glslTypes))
            throw new Error('Error while parsing :' + shaderName + ' \nType not recognized:' + parts[1])
          const name = parts[typeIndex + 1].slice(0, parts[typeIndex + 1].length - 1);
          result.uniforms[name] = glslTypes[typeName];
          // console.log('uniform:', name, ":", typeName);

          if (result.uniforms[name] == 'struct') {
            console.log(parts);
          }
          if (parts[1] == 'color') {
            parts[1] = 'vec4';
            line = parts.join(' ');
          }
        }

        result.glsl = result.glsl + line + '\n';
        result.numLines++;
      }
    }

    this.__shaderModules[shaderName] = result;

    return result
  }
}
const shaderLibrary = new ShaderLibrary();

// Every instance of every shader should have a unique id.
// This is so that we can uniquely identify the bound shader during
// rendering. Materials and geometries cache bindings to shaders.
// And need the id to be unique. (Note: we used to use the constructor.name
// which was only unique if the same shader was constructed once, and
// never unique in release mode after the port to Rollup)
let shaderInstanceId = 0;

/** Class representing a GL shader.
 * @extends BaseItem
 * @private
 */
class GLShader extends BaseItem {
  /**
   * Create a GL shader.
   * @param {any} gl - The gl value.
   */
  constructor(gl, name) {
    super(name);
    if (!gl) {
      throw new Error('gl context must be passed to shader constructor')
    }
    this.__gl = gl;
    this.__shaderStages = {
      VERTEX_SHADER: {
        glsl: '',
        lines: 0,
        uniforms: {},
        attributes: {},
      },
      FRAGMENT_SHADER: {
        glsl: '',
        lines: 0,
        uniforms: {},
        attributes: {},
      },
    };

    this.__shaderProgramHdls = {};
    this.__gltextures = {};

    this.__id = shaderInstanceId++;

    this.invisibleToGeomBuffer = false;
  }

  /**
   * The isTransparent method.
   * @return {boolean} - The return value.
   */
  static isTransparent() {
    return false
  }

  /**
   * The isOverlay method.
   * @return {boolean} - The return value.
   */
  static isOverlay() {
    return false
  }

  // /////////////////////////////////
  // Compilation

  /**
   * The __compileShaderStage method.
   * @param {any} glsl - The glsl value.
   * @param {any} stageID - The stageID value.
   * @param {string} name - The name value.
   * @param {any} shaderopts - The shaderopts value.
   * @return {any} - The return value.
   * @private
   */
  __compileShaderStage(glsl, stageID, name, shaderopts) {
    const gl = this.__gl;
    // console.log("__compileShaderStage:" + this.name+"."+name + " glsl:\n" + glsl);
    if (!shaderopts) shaderopts = gl.shaderopts;
    if (shaderopts) {
      if (shaderopts.repl) {
        for (const key in shaderopts.repl) glsl = StringFunctions.replaceAll(glsl, key, shaderopts.repl[key]);
      }
      if (shaderopts.defines) glsl = shaderopts.defines + glsl;
    }

    let prefix;
    if (gl.name == 'webgl2') {
      glsl = StringFunctions.replaceAll(glsl, 'attribute', 'in');
      if (name == 'vertexShader') glsl = StringFunctions.replaceAll(glsl, 'varying', 'out');
      else glsl = StringFunctions.replaceAll(glsl, 'varying', 'in');
      glsl = StringFunctions.replaceAll(glsl, 'texture2D', 'texture');

      prefix = '#version 300 es\n';
      glsl = prefix + glsl;
    }

    const shaderHdl = gl.createShader(stageID);
    gl.shaderSource(shaderHdl, glsl);

    // Compile the shader program.
    gl.compileShader(shaderHdl);

    // See if it compiled successfully
    if (!gl.getShaderParameter(shaderHdl, gl.COMPILE_STATUS)) {
      console.log('Errors in :' + this.constructor.name);
      const errors = gl.getShaderInfoLog(shaderHdl).split('\n');
      const errorLines = {};
      for (let i in errors) {
        if (errors[i].startsWith("'")) {
          errors[i - 1] = errors[i - 1] + errors[i];
          delete errors[i];
          i--;
          continue
        }
        const parts = errors[i].split(':');
        if (parts.length >= 2) {
          const lineNum = parseInt(parts[2]); // TODO check against ATI and intel cards
          if (!isNaN(lineNum)) {
            if (errorLines[lineNum]) errorLines[lineNum].push(errors[i]);
            else errorLines[lineNum] = [errors[i]];
          }
        }
      }
      const numberedLinesWithErrors = [];
      const lines = glsl.split('\n');
      for (let i = 0; i < lines.length; i++) {
        numberedLinesWithErrors.push((i + 1 + ':').padStart(' ', 3) + lines[i]);
        if (i + 1 in errorLines) {
          const errors = errorLines[i + 1];
          for (const error of errors) {
            numberedLinesWithErrors.push(error);
            numberedLinesWithErrors.push('-'.padStart('-', error.length));
          }
        }
      }
      // throw("An error occurred compiling the shader \n\n" + numberedLinesWithErrors.join('\n') + "\n\n=================\n" + this.constructor.name + "." + name + ": \n\n" + errors.join('\n'));
      throw new Error(
        'An error occurred compiling the shader \n=================\n' +
          this.constructor.name +
          '.' +
          name +
          ': \n\n' +
          errors.join('\n') +
          '\n' +
          numberedLinesWithErrors.join('\n')
      )
    }
    return shaderHdl
  }

  /**
   * The __createProgram method.
   * @param {any} shaderopts - The shaderopts value.
   * @return {any} - The return value.
   * @private
   */
  __createProgram(shaderopts) {
    const gl = this.__gl;
    this.__shaderCompilationAttempted = true;
    const shaderProgramHdl = gl.createProgram();
    const vertexShaderGLSL = this.__shaderStages['VERTEX_SHADER'].glsl;
    const shaderHdls = {};
    if (vertexShaderGLSL != undefined) {
      const vertexShader = this.__compileShaderStage(vertexShaderGLSL, gl.VERTEX_SHADER, 'vertexShader', shaderopts);
      if (!vertexShader) {
        return false
      }
      gl.attachShader(shaderProgramHdl, vertexShader);
      shaderHdls[gl.VERTEX_SHADER] = vertexShader;
    }
    const fragmentShaderGLSL = this.__shaderStages['FRAGMENT_SHADER'].glsl;
    if (fragmentShaderGLSL != undefined) {
      const fragshaderopts = Object.assign({}, gl.shaderopts, shaderopts);
      if (fragshaderopts.frag) fragshaderopts.defines = fragshaderopts.frag.defines + fragshaderopts.defines;
      const fragmentShader = this.__compileShaderStage(
        fragmentShaderGLSL,
        gl.FRAGMENT_SHADER,
        'fragmentShader',
        fragshaderopts
      );
      if (!fragmentShader) {
        return false
      }
      gl.attachShader(shaderProgramHdl, fragmentShader);
      shaderHdls[gl.FRAGMENT_SHADER] = fragmentShader;
    }
    gl.linkProgram(shaderProgramHdl);

    if (!gl.getProgramParameter(shaderProgramHdl, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(shaderProgramHdl);

      if (info.includes('D3D shader compilation failed')) {
        // Usefull for debugging very nasty compiler errors generated only in the ANGL layer.
        const debug_ext = gl.getExtension('WEBGL_debug_shaders');
        if (debug_ext) {
          const hlsl = debug_ext.getTranslatedShaderSource(shaderHdls[gl.VERTEX_SHADER]);
          console.log(hlsl);
        }
      }

      console.log('vertexShaderGLSL:' + vertexShaderGLSL);
      console.log('fragmentShaderGLSL:' + fragmentShaderGLSL);
      throw new Error('Unable to link the shader program:' + this.constructor.name + '\n==================\n' + info)
    }

    const result = this.__extractAttributeAndUniformLocations(shaderProgramHdl, shaderopts);
    result.shaderProgramHdl = shaderProgramHdl;
    return result
  }

  /**
   * The __extractAttributeAndUniformLocations method.
   * @param {any} shaderProgramHdl - The shaderProgramHdl value.
   * @param {any} shaderopts - The shaderopts value.
   * @return {any} - The return value.
   * @private
   */
  __extractAttributeAndUniformLocations(shaderProgramHdl, shaderopts) {
    const gl = this.__gl;
    const attrs = this.getAttributes();
    const result = {
      attrs: {},
      unifs: {},
    };
    for (const attrName in attrs) {
      const location = gl.getAttribLocation(shaderProgramHdl, attrName);
      if (location == undefined) {
        console.warn('Shader attribute not found:' + attrName);
        continue
      }
      const attrDesc = attrs[attrName];
      result.attrs[attrName] = {
        name: attrName,
        location: location,
        type: attrDesc.type,
        instanced: attrDesc.instanced,
      };
    }
    const unifs = this.getUniforms();
    for (let uniformName in unifs) {
      const unifType = unifs[uniformName];
      if (unifType instanceof Array) {
        for (const member of unifType) {
          const structMemberName = uniformName + '.' + member.name;
          const location = gl.getUniformLocation(shaderProgramHdl, structMemberName);
          if (location == undefined) {
            // console.warn(this.constructor.name + " uniform found in shader code but not in compiled program:" + uniformName);
            continue
          }
          result.unifs[structMemberName] = {
            name: structMemberName,
            location: location,
            type: member.type,
          };
        }
      }
      if (shaderopts) {
        if (shaderopts.repl) {
          for (const key in shaderopts.repl) uniformName = uniformName.replace(key, shaderopts.repl[key]);
        }
      }

      const location = gl.getUniformLocation(shaderProgramHdl, uniformName);
      if (location == undefined) {
        // console.warn(this.constructor.name + " uniform found in shader code but not in compiled program:" + uniformName);
        continue
      }
      result.unifs[uniformName] = {
        name: uniformName,
        location: location,
        type: unifType,
      };
    }
    return result
  }

  /**
   * The getAttributes method.
   * @return {any} - The return value.
   */
  getAttributes() {
    const attributes = {};
    for (const stageName in this.__shaderStages) {
      const shaderStageBlock = this.__shaderStages[stageName];
      for (const attrName in shaderStageBlock['attributes'])
        attributes[attrName] = shaderStageBlock['attributes'][attrName];
    }
    return attributes
  }

  /**
   * The getUniforms method.
   * @return {any} - The return value.
   */
  getUniforms() {
    const uniforms = {};
    for (const stageName in this.__shaderStages) {
      const shaderStageBlock = this.__shaderStages[stageName];
      for (const unifName in shaderStageBlock['uniforms']) uniforms[unifName] = shaderStageBlock['uniforms'][unifName];
    }
    return uniforms
  }

  /**
   * The finalize method.
   */
  finalize() {}

  /**
   * The compileForTarget method.
   * @param {any} key - The key value.
   * @param {any} shaderopts - The shaderopts value.
   * @return {any} - The return value.
   */
  compileForTarget(key, shaderopts) {
    const shaderkey = key ? this.__id + key : this.__id;
    let shaderCompilationResult = this.__shaderProgramHdls[shaderkey];
    if (!shaderCompilationResult) {
      if (shaderCompilationResult !== false) {
        shaderCompilationResult = this.__createProgram(shaderopts);
        shaderCompilationResult.shaderkey = shaderkey;
        this.__shaderProgramHdls[shaderkey] = shaderCompilationResult;
      }
    }
    return shaderCompilationResult
  }

  /**
   * The compile method.
   */
  compile() {
    this.compileForTarget();
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} key - The key value.
   * @return {any} - The return value.
   */
  bind(renderstate, key) {
    const gl = this.__gl;

    if (renderstate.glshader != this) {
      const shaderCompilationResult = this.compileForTarget(key, renderstate.shaderopts);
      if (shaderCompilationResult === false) {
        console.warn(this.constructor.name + ' is not compiled for ' + key);
        return false
      }

      const shaderProgramHdl = shaderCompilationResult.shaderProgramHdl;

      gl.useProgram(shaderProgramHdl);
      renderstate.glshader = this;
      renderstate.shaderkey = shaderCompilationResult.shaderkey;
      renderstate.unifs = shaderCompilationResult.unifs;
      renderstate.attrs = shaderCompilationResult.attrs;

      renderstate.boundTextures = 0;
      // Make sure we clear the binding cached.
      renderstate.glgeom = undefined;

      // Once the shader has been bound, we allow the renderer to bind any
      // of its global uniform values. (e.g. env map values etc...)
      if (renderstate.bindRendererUnifs) renderstate.bindRendererUnifs(shaderCompilationResult.unifs);
    }

    renderstate.supportsInstancing = true;

    return true
  }

  /**
   * The unbind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  unbind(renderstate) {
    return true
  }

  // /////////////////////////////
  // Parameters

  /**
   * The getParamDeclarations method.
   * @return {any} - The return value.
   */
  static getParamDeclarations() {
    return []
  }

  /**
   * The getGeomDataShaderName method.
   */
  static getGeomDataShaderName() {}

  /**
   * The getSelectedShaderName method.
   */
  static getSelectedShaderName() {}

  // /////////////////////////////////
  // Destroy

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    const gl = this.__gl;
    for (const key in this.__shaderProgramHdls) {
      const shaderCompilationResult = this.__shaderProgramHdls[key];
      gl.deleteProgram(shaderCompilationResult.shaderProgramHdl);
    }
    this.__shaderProgramHdls = {};
  }
}

shaderLibrary.setShaderModule(
  'utils/quadVertexFromID.glsl',
  `

attribute float vertexIDs;

vec2 getQuadVertexPositionFromID(){
    int vertexID = int(vertexIDs);
    if(vertexID == 0)
        return vec2(-0.5, -0.5);
    else if(vertexID == 1)
        return vec2(0.5, -0.5);
    else if(vertexID == 2)
        return vec2(-0.5, 0.5);
    else if(vertexID == 3)
        return vec2(0.5, 0.5);
    return vec2(0,0);
}
`
);

shaderLibrary.setShaderModule(
  'utils/unpackHDR.glsl',
  `

vec3 decodeHDR(const in vec3 ldrPixel, const in float cdmAlpha) {
    float avg = (cdmAlpha * 16.0 - 8.0);
    float scl = 1.0;
    vec3 color;
    color.x = (tan((ldrPixel.x-0.5)*1.5)/scl)+avg;
    color.y = (tan((ldrPixel.y-0.5)*1.5)/scl)+avg;
    color.z = (tan((ldrPixel.z-0.5)*1.5)/scl)+avg;

    // convert from logarithmic curve to linear curve.
    // subtract the epsilon that was added during encoding.
    const float eps = 0.001;
    color.x = pow(10.0, color.x) - eps;
    color.y = pow(10.0, color.y) - eps;
    color.z = pow(10.0, color.z) - eps;
    return color;
}

vec3 decodeHDR(sampler2D ldrSampler, sampler2D cdmSampler, vec2 texCoord) {
#ifdef ENABLE_ES3
    float cdm = texture2D(cdmSampler, texCoord).r;
#else
    float cdm = texture2D(cdmSampler, texCoord).a;
#endif
    return decodeHDR(texture2D(ldrSampler, texCoord).rgb, cdm);
}

`
);

class UnpackHDRShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'UnpackHDRShader.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
    vec2 position = getQuadVertexPositionFromID();
    v_texCoord = position+0.5;
    gl_Position = vec4(position*2.0, 0.0, 1.0);
}
`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'UnpackHDRShader.fragmentShader',
      `
precision highp float;

varying vec2 v_texCoord;
uniform sampler2D ldrSampler;
uniform sampler2D cdmSampler;
uniform float exposure;
uniform vec4 tint;

<%include file="utils/unpackHDR.glsl"/>

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif

    fragColor = vec4(decodeHDR(ldrSampler, cdmSampler, v_texCoord) * tint.rgb * exposure, 1.0);

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}

`
    );
  }
}

/**
 * This class abstracts the rendering of a collection of geometries to screen.
 */
class GLFbo {
  /**
   * Creates a GL Framebuffer Object
   *
   * @param {WebGLRenderingContext | WebGL2RenderingContext | undefined} gl - The Canvas 3D Context.
   * @param {GLTexture2D} colorTexture - Represents 2D Texture in GL.
   * @param {boolean} createDepthTexture - The createDepthTexture value.
   */
  constructor(gl, colorTexture, createDepthTexture = false) {
    if (SystemDesc.isIOSDevice && (colorTexture.getType() == 'FLOAT' || colorTexture.getType() == 'HALF_FLOAT')) {
      // So iOS simply refuses to bind anything to a render target except a UNSIGNED_BYTE texture.
      // See the subtle error message here: "floating-point render targets not supported -- this is legal"
      // https://www.khronos.org/registry/webgl/conformance-suites/1.0.2/conformance/extensions/oes-texture-float.html
      console.error('IOS devices are unable to render to float textures.');
    }

    this.__gl = gl;
    this.__colorTexture = colorTexture;
    this.__createDepthTexture = createDepthTexture;
    this.__clearColor = [0, 0, 0, 0];
    this.__depthTexture = undefined;

    this.setup = this.setup.bind(this);
    this.resize = this.resize.bind(this);

    if (this.__colorTexture) {
      this.__colorTexture.on('resized', this.resize);
    }

    this.setup();
  }

  /**
   * Sets FBO clear color using RGBA array structure.
   *
   * @param {array} clearColor - The clearColor value.
   */
  setClearColor(clearColor) {
    this.__clearColor = clearColor;
  }

  /**
   * Returns the `width` of the GL Texture
   *
   * @return {number} - The return value.
   */
  getWidth() {
    return this.__colorTexture.width
  }

  /**
   * Returns the `height` of the GL Texture
   *
   * @return {number} - The return value.
   */
  getHeight() {
    return this.__colorTexture.height
  }

  /**
   * Returns the `width`(Index 0) and the `height`(Index 1) of the GL Texture.
   *
   * @return {array} - The return value.
   */
  getSize() {
    return [this.__colorTexture.width, this.__colorTexture.height]
  }

  /**
   * Returns the ColorTexture of the Fbo
   *
   * @return {GLTexture2D} - The return value.
   */
  getColorTexture() {
    return this.__colorTexture
  }

  /**
   * Returns the value of the deptTexture property.
   *
   * @return {boolean} - The return value.
   */
  getDepthTextureGL() {
    return this.__depthTexture
  }

  /**
   * Returns the `width` of the GL Texture
   */
  get width() {
    return this.__colorTexture.width
  }

  /**
   * Returns the `height` of the GL Texture
   */
  get height() {
    return this.__colorTexture.height
  }

  /**
   * Returns the `width`(Index 0) and the `height`(Index 1) of the GL Texture.
   */
  get size() {
    return [this.__colorTexture.width, this.__colorTexture.height]
  }

  /**
   * Returns the ColorTexture of the Fbo
   */
  get colorTexture() {
    return this.__colorTexture
  }

  /**
   * Sets ColorTexture of the Fbo.
   *
   * @param {GLTexture2D} colorTexture - The colorTexture value.
   */
  setColorTexture(colorTexture) {
    this.__colorTexture = colorTexture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
  }

  /**
   * Returns the value of the deptTexture property.
   */
  get depthTextureGL() {
    return this.__depthTexture
  }

  /**
   * The setup method.
   */
  setup() {
    const gl = this.__gl;

    this.__fbo = gl.createFramebuffer();
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);

    // TODO: Migrate to using GLRenderTarget... This system is a mess.
    // if(gl.name == 'webgl2'){
    //     if (this.__colorTexture && this.__colorTexture.getType() == 'FLOAT' && this.__colorTexture.getFilter() == 'LINEAR') {
    //         if (!gl.__ext_float_linear)
    //             throw ("Unable to use filtering on floating point textures");
    //     }
    // }
    // else {
    //     if (this.__colorTexture.getType() == 'FLOAT') {
    //         if(gl.__ext_float){
    //             if (this.__colorTexture.getFilter() == 'LINEAR') {
    //                 if (!gl.__ext_float_linear)
    //                     throw ("Unable to use filtering on floating point textures");
    //             }
    //         }
    //         else if(gl.__ext_half_float){
    //             if (this.__colorTexture.getFilter() == 'LINEAR') {
    //                 if (!gl.__ext_texture_half_float_linear)
    //                     throw ("Unable to use filtering on half-floating point textures");
    //             }
    //         }
    //         else{
    //             throw("floating point textures unsupported.");
    //         }
    //     }
    // }

    if (this.__colorTexture) {
      if (gl.name == 'webgl2')
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
      else gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
    }

    // Create the depth texture
    if (this.__createDepthTexture) {
      if (gl.name != 'webgl2' && !gl.__ext_WEBGL_depth_texture) {
        // Create the depth buffer
        const depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
      } else {
        gl.activeTexture(gl.TEXTURE0);
        this.__depthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.__depthTexture);
        // TODO: Copy params from the color image.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (gl.name == 'webgl2') {
          // the proper texture format combination can be found here
          // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
          // https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/fbo_rtt_depth_texture.html
          // gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT16, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.DEPTH_COMPONENT24,
            this.width,
            this.height,
            0,
            gl.DEPTH_COMPONENT,
            gl.UNSIGNED_INT,
            null
          );
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.__depthTexture, 0);
        } else {
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.DEPTH_COMPONENT,
            this.width,
            this.height,
            0,
            gl.DEPTH_COMPONENT,
            gl.UNSIGNED_INT,
            null
          );
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.__depthTexture, 0);
        }
      }
    }

    this.__checkFramebuffer();

    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  /**
   * Triggered Automatically when the texture resizes.
   *
   * @todo: Fbos should manage the textures assigned to them.
   * E.g. resizing and preserving data.
   */
  resize() {
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);

    // The color texture is destoryed and re-created when it is resized,
    // so we must re-bind it here.
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
    if (this.__depthTexture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.__depthTexture);
      if (gl.name == 'webgl2') {
        // the proper texture format combination can be found here
        // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.DEPTH_COMPONENT24,
          this.width,
          this.height,
          0,
          gl.DEPTH_COMPONENT,
          gl.UNSIGNED_INT,
          null
        );
      } else
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.DEPTH_COMPONENT,
          this.width,
          this.height,
          0,
          gl.DEPTH_COMPONENT,
          gl.UNSIGNED_INT,
          null
        );
    }
    this.__checkFramebuffer();
  }

  /**
   * The __checkFramebuffer method.
   * @private
   */
  __checkFramebuffer() {
    const gl = this.__gl;

    let check;
    if (gl.name == 'webgl2') check = gl.checkFramebufferStatus(gl.DRAW_FRAMEBUFFER);
    else check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (check !== gl.FRAMEBUFFER_COMPLETE) {
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      console.warn(
        'Error creating Fbo width:',
        this.width,
        ', height:',
        this.height,
        ' Texture Type:',
        this.__colorTexture.getType()
      );
      switch (check) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error(
            'The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.'
          )
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error('There is no attachment.')
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error('Height and width of the attachment are not the same.')
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(
            'The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.'
          )
        case 36061: // gl.GL_FRAMEBUFFER_UNSUPPORTED:
          throw new Error('The framebuffer is unsupported')
        default:
          throw new Error('Incomplete Frambuffer')
      }
    }
  }

  /**
   * Binds the Fbo to the canvas context, meaning that all WRITE operations will affect the current Fbo.
   *
   * @param {object} renderstate - The renderstate value.
   */
  bindForWriting(renderstate) {
    if (renderstate) {
      this.__prevBoundFbo = renderstate.boundRendertarget;
      renderstate.boundRendertarget = this.__fbo;
    }
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
    gl.viewport(0, 0, this.width, this.height); // Match the viewport to the texture size
  }

  /**
   * Unbinds the Fbo to the canvas context for WRITE operations.
   *
   * @param {object} renderstate - The renderstate value.
   */
  unbindForWriting(renderstate) {
    if (renderstate) renderstate.boundRendertarget = this.__prevBoundFbo;
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__prevBoundFbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__prevBoundFbo);
  }

  /**
   * Binds the Fbo to the canvas context, meaning that all WRITE operations will affect the current Fbo.
   *
   * @param {object} renderstate - The renderstate value.
   */
  bind(renderstate) {
    this.bindForWriting(renderstate);
  }

  /**
   * Unbinds the Fbo to the canvas context for WRITE operations.
   *
   * @param {object} renderstate - The renderstate value.
   */
  unbind(renderstate) {
    this.unbindForWriting(renderstate);
  }

  /**
   * Binds the Fbo to the canvas context, meaning that all READ operations will affect the current Fbo.
   *
   * @param {object} renderstate - The renderstate value.
   */
  bindForReading() {
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.__fbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
  }

  /**
   * Unbinds the Fbo to the canvas context for READ operations.
   *
   * @param {object} renderstate - The renderstate value.
   */
  unbindForReading() {
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  /**
   * Enables all color components of the rendering context of the Fbo,
   * specifying the default color values when clearing color buffers and clears the buffers to preset values.
   */
  clear() {
    const gl = this.__gl;
    gl.colorMask(true, true, true, true); // Don't write to the color channels at all
    gl.clearColor(...this.__clearColor);
    if (this.__createDepthTexture) {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    } else {
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
  }

  /**
   * Runs [`bind`](#bind) then [`clear`](#clear) methods.
   * @param {object} renderstate - The renderstate value.
   */
  bindAndClear(renderstate) {
    this.bind(renderstate);
    this.clear(renderstate);
  }

  /**
   * Unbinds the Fbo to the canvas context.
   */
  unbind() {
    const gl = this.__gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    const gl = this.__gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(this.__fbo);
    this.__fbo = null;
    this.__colorTexture.off('resized', this.resize);
  }
}

/** Class representing a GL high dynamic range (HDR) image.
 * @extends GLTexture2D
 * @private
 */
class GLHDRImage extends GLTexture2D {
  /**
   * Create a GL HDR image.
   * @param {any} gl - The gl value.
   * @param {any} hdrImage - The HDR image.
   */
  constructor(gl, hdrImage) {
    super(gl);

    this.__hdrImage = hdrImage;
    this.__hdrImage.setMetadata('gltexture', this);
    const loadImage = () => {
      this.__unpackHDRImage(this.__hdrImage.getParams());
    };
    this.__hdrImage.on('updated', loadImage);
    if (this.__hdrImage.isLoaded()) {
      loadImage();
    } else {
      this.__hdrImage.on('loaded', loadImage);
    }
  }

  /**
   * The __unpackHDRImage method.
   * @param {any} hdrImageParams - The HDR image parameters.
   * @private
   */
  __unpackHDRImage(hdrImageParams) {
    const gl = this.__gl;

    const ldr = hdrImageParams.data.ldr;
    const cdm = hdrImageParams.data.cdm;

    if (!this.__fbo) {
      // Note: iOS devices create FLOAT Fbox.
      // If we want better quality, we could unpack the texture in JavaScript.
      this.configure({
        format: 'RGBA',
        type: 'FLOAT',
        width: ldr.width,
        height: ldr.height,
        filter: 'LINEAR',
        wrap: 'CLAMP_TO_EDGE',
      });
      this.__fbo = new GLFbo(gl, this);
      this.__fbo.setClearColor([0, 0, 0, 0]);

      this.__srcLDRTex = new GLTexture2D(gl, {
        format: 'RGB',
        type: 'UNSIGNED_BYTE',
        width: ldr.width,
        height: ldr.height,
        filter: 'NEAREST',
        mipMapped: false,
        wrap: 'CLAMP_TO_EDGE',
        data: ldr,
      });
      this.__srcCDMTex = new GLTexture2D(gl, {
        format: gl.name == 'webgl2' ? 'RED' : 'ALPHA',
        type: 'UNSIGNED_BYTE',
        width: ldr.width /* 8*/,
        height: ldr.height /* 8*/,
        filter: 'NEAREST',
        mipMapped: false,
        wrap: 'CLAMP_TO_EDGE',
        data: cdm,
      });

      this.__unpackHDRShader = new UnpackHDRShader(gl);
      const shaderComp = this.__unpackHDRShader.compileForTarget('GLHDRImage');
      this.__shaderBinding = generateShaderGeomBinding(gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
    } else {
      this.__srcLDRTex.bufferData(ldr);
      this.__srcCDMTex.bufferData(cdm);
    }

    this.__fbo.bindAndClear();

    const renderstate = {};
    this.__unpackHDRShader.bind(renderstate, 'GLHDRImage');
    this.__shaderBinding.bind(renderstate);

    const unifs = renderstate.unifs;
    this.__srcLDRTex.bindToUniform(renderstate, unifs.ldrSampler);
    this.__srcCDMTex.bindToUniform(renderstate, unifs.cdmSampler);

    gl.uniform1f(unifs.exposure.location, 1);
    gl.uniform4fv(unifs.tint.location, this.__hdrImage.getHDRTint().asArray());
    gl.drawQuad();

    // // Debug a block of pixels.
    // console.log(this.__hdrImage.getName());
    // gl.finish();
    // let numPixels = 4;
    // let pixels = new Float32Array(4 * numPixels);
    // gl.readPixels(ldr.width / 4, ldr.height/4, numPixels, 1, gl.RGBA, gl.FLOAT, pixels);
    // console.log(pixels);
    // gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this.__fbo.unbind();

    // if (!this.__hdrImage.isStream()) {
    //     this.__fbo.destroy();
    //     this.__srcLDRTex.destroy();
    //     this.__srcCDMTex.destroy();
    //     this.__fbo = null;
    //     this.__srcLDRTex = null;
    //     this.__srcCDMTex = null;
    // }

    this.emit('updated', {});
  }

  /**
   * The bindToUniform method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @param {any} bindings - The bindings value.
   * @return {any} - The return value.
   */
  bindToUniform(renderstate, unif, bindings) {
    return super.bindToUniform(renderstate, unif, bindings)
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    if (this.__fbo) {
      this.__fbo.destroy();
      this.__srcLDRTex.destroy();
      this.__srcCDMTex.destroy();
    }
    if (this.__unpackHDRShader) this.__unpackHDRShader.destroy();
    if (this.__shaderBinding) this.__shaderBinding.destroy();

    this.__hdrImage.loaded.disconnectScope(this);
    this.__hdrImage.updated.disconnectScope(this);
  }
}

shaderLibrary.setShaderModule(
  'GLSLUtils.glsl',
  `


int ftoi(float val){
    return int(floor(val + 0.5));
}
ivec2 ftoi(vec2 v2) {
    return ivec2(ftoi(v2.x), ftoi(v2.y));
}
ivec3 ftoi(vec3 v4) {
    return ivec3(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z));
}
ivec4 ftoi(vec4 v4) {
    return ivec4(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z), ftoi(v4.w));
}

#ifdef ENABLE_ES3

int imod(int x, int y) {
    return x % y;
}

void setFlag(inout int flags, int flag) {
    flags |= flag;
}

void clearFlag(inout int flags, int flag) {
    flags &= ~flag;
}

bool testFlag(int flags, int flag) {
    return (flags & flag) != 0;
}

// private function: Mangle me...
ivec2 _pixelIndexToUV(int index, int textureWidth){
    return ivec2(index % textureWidth, index / textureWidth);
}

vec4 fetchTexel(sampler2D texture, int textureWidth, int index) {
    return texelFetch(texture, _pixelIndexToUV(index, textureWidth), 0);
}

vec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {
    return texelFetch(texture, texCoord, 0);
}

#else

// TODO: integrate: https://gist.github.com/mattatz/70b96f8c57d4ba1ad2cd

int max(int a, int b) {
    return a > b ? a : b;
}
int min(int a, int b) {
    return a < b ? a : b;
}


float round(float val){
    return floor(val + 0.4);
}

int imod(int x, int y) {
    return x-y*(x/y);
}

void setFlag(inout int flags, int flag) {
    flags += flag;
}
void clearFlag(inout int flags, int flag) {
    flags -= flag;
}

bool testFlag(int flags, int flag) {
    return imod(flags / flag, 2) != 0;
}

// private function: Mangle me...
vec2 _pixelIndexToUV(int index, int textureSize){
    float flTexSize = float(textureSize);
    float x = (float(imod(index, textureSize))+0.5)/flTexSize;
    float y = (floor(float(index / textureSize))+0.5)/flTexSize;
    return vec2(x, y);
}

vec4 fetchTexel(sampler2D texture, int textureSize, int index) {
    vec2 texCoord = _pixelIndexToUV(index, textureSize);
    return texture2D(texture, texCoord);
}

vec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {
    vec2 ftextureSize = vec2(textureSize);
    return texture2D(texture, (vec2(texCoord) + 0.5) / ftextureSize);
}


#endif // ENABLE_ES3

int uvToPixelIndex(vec2 uv, int textureSize){
    return int(uv.x * float(textureSize)) + (int(floor(uv.y * float(textureSize))) * textureSize);
}



`
);

shaderLibrary.setShaderModule(
  'utils/ImageStream.glsl',
  `

// Stream Desc looks like the following
// x : atlas Width in images
// y : atlas height in images
// z : image Width
// w : image Height

vec2 calcFrameImageTexCoords(vec2 texCoord, int index, in vec4 streamDesc){
	float index_x = floor(mod(float(index), streamDesc.x));
	float index_y = floor(float(index) / streamDesc.x);
    return vec2( 
    	(index_x + texCoord.x) / streamDesc.x, 
    	(index_y + texCoord.y) / streamDesc.y
    	);
}

vec4 sampleStreamFrame(vec2 texCoord, int index, in sampler2D streamImage, in vec4 streamDesc){
    return texture2D(streamImage, calcFrameImageTexCoords(texCoord, index, streamDesc));
}

`
);

/** Class representing a GL image stream.
 * @private
 */
class GLImageStream$1 extends RefCounted {
  /**
   * Create a GL image stream.
   * @param {any} gl - The gl value.
   * @param {any} streamImage - The streamImage value.
   */
  constructor(gl, streamImage) {
    super();
    this.__gl = gl;
    this.__streamImage = streamImage;
    this.__descParam = this.__streamImage.getParameter('StreamAtlasDesc');
    this.__indexParam = this.__streamImage.getParameter('StreamAtlasIndex');
    this.__indexParam.on('valueChanged', () => {
      this.emit('updated', {});
    });

    // To support playing back the same image atlas through many different streams.
    // (e.g. the same Gif progress bar in many places)
    // The GLImageStream should own an instance of GLTexture2D instead of extending it.
    // this would enable multiple streams to share a reference.
    const configure = () => {
      const params = this.__streamImage.getParams();
      if (!params.data.__atlasTexture) {
        params.data.__atlasTexture = new GLTexture2D(gl, params);
      }
      this.__atlasTexture = params.data.__atlasTexture;
      this.__atlasTexture.textureType = 2;
      this.__atlasTexture.textureDesc = this.__descParam.getValue().asArray();
    };

    if (this.__streamImage.isLoaded()) {
      configure();
    } else {
      this.__indexParam.on('loaded', () => {
        configure();
      });
    }
  }

  /**
   * The preBind method.
   * @param {any} unif - The unif value.
   * @param {any} unifs - The unifs value.
   * @return {any} - The return value.
   */
  preBind(unif, unifs) {
    const res = this.__atlasTexture.preBind(unif, unifs);
    res.textureDescUnif = unifs[unif.name + 'Desc'];
    res.textureIndexUnif = unifs[unif.name + 'Index'];
    return res
  }

  /**
   * The bindToUniform method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @param {any} bindings - The bindings value.
   * @return {boolean} - The return value.
   */
  bindToUniform(renderstate, unif, bindings) {
    if (!this.__atlasTexture.bindToUniform(renderstate, unif, bindings)) {
      return false
    }

    if (bindings) {
      if (bindings.textureIndexUnif) {
        this.__gl.uniform1i(bindings.textureIndexUnif.location, this.__indexParam.getValue());
      }
    }

    return true
  }
}

/** Class representing simple uniform binding.
 * @private
 */
class SimpleUniformBinding {
  /**
   * Create simple uniform binding.
   * @param {any} gl - The gl value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} param - The param value.
   * @param {any} unif - The unif value.
   */
  constructor(gl, glmaterial, param, unif) {
    this.param = param;
    this.unif = unif;

    switch (unif.type) {
      case Boolean:
        // gl.uniform1ui(unif.location, value);// WebGL 2
        this.uniformXX = gl.uniform1i.bind(gl);
        break
      case UInt32:
        if (gl.name == 'webgl2') this.uniformXX = gl.uniform1ui.bind(gl);
        else this.uniformXX = gl.uniform1i.bind(gl);
        break
      case SInt32:
        this.uniformXX = gl.uniform1i.bind(gl);
        break
      case Float32:
        this.uniformXX = gl.uniform1f.bind(gl);
        break
    }
    this.dirty = true;
    param.on('valueChanged', () => {
      this.dirty = true;
      glmaterial.emit('updated', {});
    });
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   */
  bind(renderstate) {
    if (this.dirty) {
      this.val = this.param.getValue();
      this.dirty = false;
    }
    this.uniformXX(this.unif.location, this.val);
  }

  /**
   * The unbind method.
   */
  unbind() {}

  /**
   * The destroy method.
   */
  destroy() {}
}

/** Class representing complex uniform binding.
 * @private
 */
class ComplexUniformBinding {
  /**
   * Create complex uniform binding.
   * @param {any} gl - The gl value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} param - The param value.
   * @param {any} unif - The unif value.
   */
  constructor(gl, glmaterial, param, unif) {
    this.param = param;
    this.unif = unif;

    switch (unif.type) {
      case Vec2:
        this.uniformXX = gl.uniform2fv.bind(gl);
        break
      case Vec3$1:
        this.uniformXX = gl.uniform3fv.bind(gl);
        break
      case Vec4$1:
        this.uniformXX = gl.uniform4fv.bind(gl);
        break
    }
    this.dirty = true;
    param.on('valueChanged', () => {
      this.dirty = true;
      glmaterial.emit('updated', {});
    });
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   */
  bind(renderstate) {
    if (this.dirty) {
      this.vals = this.param.getValue().asArray();
      this.dirty = false;
    }
    this.uniformXX(this.unif.location, this.vals);
  }

  /**
   * The unbind method.
   */
  unbind() {}

  /**
   * The destroy method.
   */
  destroy() {}
}

/** Class representing material uniform binding.
 * @private
 */
class MatrixUniformBinding {
  /**
   * Create material uniform binding.
   * @param {any} gl - The gl value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} param - The param value.
   * @param {any} unif - The unif value.
   */
  constructor(gl, glmaterial, param, unif) {
    this.param = param;
    this.unif = unif;

    switch (unif.type) {
      case Mat3:
        this.uniformMatrixXXX = gl.uniformMatrix3fv.bind(gl);
        break
      case Mat4:
        this.uniformMatrixXXX = gl.uniformMatrix4fv.bind(gl);
        break
    }

    this.dirty = true;
    param.on('valueChanged', () => {
      this.dirty = true;
      glmaterial.emit('updated', {});
    });
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   */
  bind(renderstate) {
    if (this.dirty) {
      this.vals = this.param.getValue().asArray();
      this.dirty = false;
    }
    this.uniformMatrixXXX(this.unif.location, false, this.val);
  }

  /**
   * The unbind method.
   */
  unbind() {}

  /**
   * The destroy method.
   */
  destroy() {}
}

/** Class representing color uniform binding.
 * @private
 */
class ColorUniformBinding {
  /**
   * Create color uniform binding.
   * @param {any} gl - The gl value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} param - The param value.
   * @param {any} unif - The unif value.
   * @param {any} unifs - The unifs value.
   */
  constructor(gl, glmaterial, param, unif, unifs) {
    this.gl = gl;
    this.param = param;
    this.unif = unif;
    this.textureUnif = unifs[unif.name + 'Tex'];
    this.textureTypeUnif = unifs[unif.name + 'TexType'];

    this.vals = [0, 0, 0, 0];
    this.bind = this.bindValue;

    const genGLTex = (image) => {
      let gltexture = image.getMetadata('gltexture');
      const textureType = 1;
      if (!gltexture) {
        if (image.type === 'FLOAT') {
          gltexture = new GLHDRImage(this.gl, image);
        } else if (image.isStreamAtlas()) {
          gltexture = new GLImageStream$1(this.gl, image);
        }
        // else if (image.hasAlpha()){
        //     gltexture = new GLLDRAlphaImage(this.gl, image);
        // }
        else {
          gltexture = new GLTexture2D(this.gl, image);
        }
      }
      this.texBinding = gltexture.preBind(this.textureUnif, unifs);
      gltexture.on('updated', () => {
        glmaterial.emit('updated', {});
      });
      this.gltexture = gltexture;
      this.gltexture.addRef(this);
      this.textureType = textureType;
      this.bind = this.bindTexture;
      glmaterial.emit('updated', {});
    };

    let boundImage;
    let imageLoaded;
    const connectImage = (image) => {
      if (!image.isLoaded()) {
        imageLoaded = () => {
          genGLTex(boundImage);
        };
        image.on('loaded', imageLoaded);
      } else {
        genGLTex(image);
      }
      boundImage = image;
    };

    const disconnectImage = () => {
      const gltexture = boundImage.getMetadata('gltexture');
      gltexture.removeRef(this);
      this.texBinding = null;
      this.gltexture = null;
      this.textureType = null;
      this.bind = this.bindValue;

      if (imageLoaded) {
        boundImage.off('loaded', imageLoaded);
      }
      boundImage = null;
      imageLoaded = null;
      glmaterial.emit('updated', {});
    };

    this.update = () => {
      // Sometimes the value of a color param is an image.
      const value = param.getValue();
      this.vals = value.asArray();

      if (this.textureUnif) {
        let image;
        if (param.getImage) {
          image = param.getImage();
        }
        if (image && image != boundImage) {
          connectImage(image);
        } else if (!image && boundImage) {
          disconnectImage();
        }
      }
      glmaterial.emit('updated');
    };

    /**
     * The update method.
     */
    this.update();
    param.on('textureConnected', () => {
      connectImage(param.getImage());
    });
    this.dirty = true;
    param.on('valueChanged', () => {
      this.dirty = true;
    });

    this.uniform1i = gl.uniform1i.bind(gl);
    this.uniform4fv = gl.uniform4fv.bind(gl);
  }

  /**
   * The bindValue method.
   * @param {any} renderstate - The renderstate value.
   */
  bindValue(renderstate) {
    if (this.dirty) {
      this.update();
      this.dirty = false;
    }
    this.uniform4fv(this.unif.location, this.vals);
    if (this.textureTypeUnif) this.uniform1i(this.textureTypeUnif.location, 0);
  }

  /**
   * The bindTexture method.
   * @param {any} renderstate - The renderstate value.
   */
  bindTexture(renderstate) {
    if (this.dirty) {
      this.update();
      this.dirty = false;
    }
    this.gltexture.bindToUniform(renderstate, this.textureUnif, this.texBinding);
  }
}

const logged = {};

/** Class representing material shader binding.
 * @private
 */
class MaterialShaderBinding {
  /**
   * Create material shader binding.
   * @param {any} gl - The gl value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} unifs - The unifs value.
   * @param {any} warnMissingUnifs - The warnMissingUnifs value.
   */
  constructor(gl, glmaterial, unifs, warnMissingUnifs) {
    this.uniformBindings = [];

    const bindParam = (param) => {
      const name = param.getName();
      const unif = unifs[name];
      if (unif == undefined) {
        // Note: we now bind the Material even for rendering geom datas,
        // which can mean many params have no uniform in the shader, which is fine.
        if (warnMissingUnifs) {
          // Note: this silent error caused me a lot of searching. make it noisy.
          const shaderName = glmaterial.getMaterial().getShaderName();
          if (!logged[shaderName]) {
            logged[shaderName] = {};
          }
          if (!logged[shaderName][name]) {
            // TODO: Many of these warnings are because when we change shaders
            // we do not remove obsolete params, but we probably should.
            console.warn(
              'Material:' + glmaterial.getMaterial().getName(),
              'with Shader ',
              shaderName,
              'Param has no unif',
              name
            );
            logged[shaderName][name] = true;
          }
        }
        return
      }
      switch (unif.type) {
        case Boolean:
        case UInt32:
        case SInt32:
        case Float32:
          this.uniformBindings.push(new SimpleUniformBinding(gl, glmaterial, param, unif));
          break
        case Vec2:
        case Vec3$1:
        case Vec4$1:
          this.uniformBindings.push(new ComplexUniformBinding(gl, glmaterial, param, unif));
          break
        case Color:
          this.uniformBindings.push(new ColorUniformBinding(gl, glmaterial, param, unif, unifs));
          break
        case Mat4:
          this.uniformBindings.push(new MatrixUniformBinding(gl, glmaterial, param, unif));
          break
        default:
          console.warn('Param :' + name + ' has unhandled data type:' + unif.type);
          return
      }
      return
    };
    const params = glmaterial.getMaterial().getParameters();
    for (const param of params) {
      bindParam(param);
    }
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    for (const uniformBinding of this.uniformBindings) {
      uniformBinding.bind(renderstate);
    }
    return true
  }

  /**
   * The unbind method.
   */
  unbind() {
    for (const uniformBinding of this.uniformBindings) {
      uniformBinding.unbind(renderstate);
    }
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    for (const uniformBinding of this.uniformBindings) {
      uniformBinding.destroy(renderstate);
    }
  }
}

/** Class representing a GL material.
 * @extends EventEmitter
 * @private
 */
class GLMaterial extends EventEmitter {
  /**
   * Create a GL material.
   * @param {any} gl - The gl value.
   * @param {any} material - The material value.
   * @param {any} glshader - The glshader value.
   */
  constructor(gl, material, glshader) {
    super();
    this.__gl = gl;
    this.__material = material;
    this.__glshader = glshader;

    this.__shaderBindings = {};

    material.on('parameterValueChanged', () => this.emit('updated'));
  }

  /**
   * The getMaterial method.
   * @return {any} - The return value.
   */
  getMaterial() {
    return this.__material
  }

  /**
   * The getGLShader method.
   * @return {any} - The return value.
   */
  getGLShader() {
    return this.__glshader
  }

  /**
   * The generateShaderBinding method.
   */
  generateShaderBinding() {
    const params = this.__material.getParameters();
    for (const param of params) {
      bindParam(gl, param);
    }
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} warnMissingUnifs - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate, warnMissingUnifs) {
    this.__boundTexturesBeforeMaterial = renderstate.boundTextures;

    let shaderBinding = this.__shaderBindings[renderstate.shaderkey];
    if (!shaderBinding) {
      const gl = this.__gl;
      shaderBinding = new MaterialShaderBinding(gl, this, renderstate.unifs, warnMissingUnifs);
      this.__shaderBindings[renderstate.shaderkey] = shaderBinding;
    }
    return shaderBinding.bind(renderstate)
  }

  /**
   * The unbind method.
   * @param {any} renderstate - The renderstate value.
   */
  unbind(renderstate) {
    // Enable texture units to be re-used by resetting the count back
    // to what it was.
    renderstate.boundTextures = this.__boundTexturesBeforeMaterial;
  }
}

const processTextureParams = function (gl, params) {
  if (!params.width || !params.height) throw new Error('Invalid texture params')

  const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  if (params.width <= 0 || params.width > maxSize || params.height <= 0 || params.height > maxSize) {
    throw new Error(
      'GLTextureParams: Invalid texture size. width:' +
        params.width +
        ' height:' +
        params.height +
        ' maxSize:' +
        maxSize
    )
  }

  const result = {
    width: params.width,
    height: params.height,
  };
  const processParam = (name, defaultValue) => {
    if (name in params) result[name] = isNaN(params[name]) ? gl[params[name]] : params[name];
    else if (defaultValue) result[name] = defaultValue;
  };
  processParam('format');
  processParam('internalFormat', result.format);
  processParam('type', gl.UNSIGNED_BYTE);
  processParam('minFilter', gl.LINEAR);
  processParam('magFilter', gl.LINEAR);
  processParam('wrapS', gl.CLAMP_TO_EDGE);
  processParam('wrapT', gl.CLAMP_TO_EDGE);
  processParam('flipY', false);
  processParam('mipMapped', false);

  processParam('depthFormat');
  processParam('depthType');

  // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
  if (result.format == gl.FLOAT) {
    if (gl.name == 'webgl2') {
      if (result.filter == gl.LINEAR && !gl.__ext_float_linear) {
        console.warn('Floating point texture filtering not supported on result device');
        result.filter = gl.NEAREST;
      }
    } else {
      if (gl.__ext_float) {
        if (result.filter == gl.LINEAR && !gl.__ext_float_linear) {
          console.warn('Floating point texture filtering not supported on result device');
          result.filter = gl.NEAREST;
        }
      } else {
        if (gl.__ext_half_float) {
          result.format = gl.HALF_FLOAT;
          if (result.filter == gl.LINEAR && !gl.__ext_texture_half_float_linear) {
            console.warn('Half Float texture filtering not supported on result device');
            result.filter = gl.NEAREST;
          }
        } else {
          throw new Error('OES_texture_half_float is not available')
        }
      }
    }
  } else if (result.format == gl.HALF_FLOAT) {
    if (gl.name == 'webgl2') ; else {
      if (gl.__ext_half_float) {
        if (result.filter == gl.LINEAR && !gl.__ext_texture_half_float_linear) {
          console.warn('Half Float texture filtering not supported on result device');
          result.filter = gl.NEAREST;
        }
      } else throw new Error('OES_texture_half_float is not available')
      if (result.channels == gl.RGB) {
        throw new Error('OES_texture_half_float onlysupports RGBA textures')
      }
    }
  } else if (result.format == 'sRGB') {
    if (!gl.__ext_sRGB) throw new Error('EXT_sRGB is not available')
  }

  // ////////////////////////////////////////////////////
  // Format ... InternalFormat combos.
  // Setup the correct combos.
  // the proper texture format combination can be found here
  // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
  // Determine the internal format from mthe format and type.
  if (result.format != undefined && gl.name == 'webgl2' && result.internalFormat == result.format) {
    if (result.type == gl.FLOAT) {
      if (result.format == gl.RED) {
        result.internalFormat = gl.R32F;
      } else if (result.format == gl.RED) {
        result.internalFormat = gl.R32F;
      } else if (result.format == gl.RG) {
        result.internalFormat = gl.RG32F;
      } else if (result.format == gl.RGBA) {
        result.internalFormat = gl.RGBA32F;
      }
    } else if (result.type == gl.HALF_FLOAT) {
      if (result.format == gl.RED) {
        result.internalFormat = gl.R16F;
      } else if (result.format == gl.RGB) {
        result.internalFormat = gl.RGB16F;
      } else if (result.format == gl.RGBA) {
        result.internalFormat = gl.RGBA16F;
      }
    } else if (result.type == gl.UNSIGNED_BYTE) {
      if (result.format == gl.RED) {
        result.internalFormat = gl.R8;
      }
      if (result.format == gl.RGB) {
        result.internalFormat = gl.RGB8;
      } else if (result.format == gl.RGBA) {
        result.internalFormat = gl.RGBA8;
      }
    }
  }

  if (result.depthFormat != undefined) {
    if (gl.name == 'webgl2') {
      if (result.depthType == gl.UNSIGNED_SHORT) {
        result.depthInternalFormat = gl.DEPTH_COMPONENT16;
      } else if (result.depthType == gl.UNSIGNED_INT) {
        result.depthInternalFormat = gl.UNSIGNED_INT;
      }
    } else {
      result.depthInternalFormat = result.depthFormat;
    }
  }

  return result
};

/** Class representing a GL render target. */
class GLRenderTarget extends EventEmitter {
  /**
   * Create a GL render target.
   * @param {any} gl - The gl value.
   * @param {any} params - The params value.
   */
  constructor(gl, params) {
    super();
    this.__gl = gl;
    this.textureTargets = [];
    this.depthTexture = null;

    if (params) {
      this.configure(params);
    }
  }

  /**
   * The configure method.
   * @param {any} params - The params param.
   */
  configure(params) {
    const gl = this.__gl;

    const p = processTextureParams(gl, params);

    this.textureTargets.forEach((colorTexture) => {
      gl.deleteTexture(colorTexture);
    });
    this.textureTargets = [];
    if (this.depthTexture) {
      gl.deleteTexture(this.depthTexture);
      this.depthTexture = null;
    }
    if (this.frameBuffer) {
      gl.deleteFramebuffer(this.frameBuffer);
    }

    this.type = p.type;
    this.format = p.format;
    this.internalFormat = p.internalFormat;
    this.filter = p.filter;
    this.wrap = p.wrap;
    this.flipY = p.flipY;
    this.width = p.width;
    this.height = p.height;
    this.clearColor = new Color(0, 0, 0, 0);
    this.colorMask = [true, true, true, true];

    this.textureType = 1; // Default 2d 8 bit texture image texture.
    this.textureDesc = [this.width, this.height, 0, 0];

    // -- Initialize texture targets
    const numColorChannels =
      params.numColorChannels != undefined ? params.numColorChannels : p.format != undefined ? 1 : 0;
    for (let i = 0; i < numColorChannels; i++) {
      gl.activeTexture(gl.TEXTURE0 + 1);
      const colorTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, colorTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, p.width, p.height, 0, this.format, this.type, null);
      this.textureTargets.push(colorTexture);
    }

    if (p.depthFormat) {
      if (gl.name == 'webgl' && !gl.__ext_WEBGL_depth_texture)
        throw new Error('Depth textures not support on this device')
      // -- Initialize depth texture
      gl.activeTexture(gl.TEXTURE0);
      this.depthTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);

      // the proper texture format combination can be found here
      // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
      gl.texImage2D(gl.TEXTURE_2D, 0, p.depthInternalFormat, p.width, p.height, 0, p.depthFormat, p.depthType, null);
    }

    // -- Initialize frame buffer
    this.frameBuffer = gl.createFramebuffer();
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    if (this.textureTargets.length > 0) {
      if (this.textureTargets.length > 1) {
        if (gl.name == 'webgl' && !gl.drawBuffers) {
          gl.__ext_draw_buffers = gl.getExtension('WEBGL_draw_buffers');
          gl.drawBuffers = gl.__ext_draw_buffers.drawBuffersWEBGL.bind(gl.__ext_draw_buffers);
          for (let i = 1; i < 14; i++) {
            gl['COLOR_ATTACHMENT' + i] = gl.__ext_draw_buffers['COLOR_ATTACHMENT' + i + '_WEBGL'];
          }
          gl.MAX_COLOR_ATTACHMENTS = gl.__ext_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL;
          gl.MAX_DRAW_BUFFERS = gl.__ext_draw_buffers.MAX_DRAW_BUFFERS_WEBGL;
        }
      }

      const bufferIds = [];
      for (let i = 0; i < this.textureTargets.length; i++) {
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this.textureTargets[i], 0);
        bufferIds.push(gl.COLOR_ATTACHMENT0 + i);
      }
      if (this.textureTargets.length > 1) {
        gl.drawBuffers(bufferIds);
      }
    }

    if (this.depthTexture) {
      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture, 0);
    }

    const status = gl.checkFramebufferStatus(gl.DRAW_FRAMEBUFFER);
    if (status != gl.FRAMEBUFFER_COMPLETE) {
      switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error(
            'The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.'
          )
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error('There is no attachment.')
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error('Height and width of the attachment are not the same.')
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error(
            'The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.'
          )
        case 36061: // gl.GL_FRAMEBUFFER_UNSUPPORTED:
          throw new Error('The framebuffer is unsupported')
        default:
          throw new Error('Incomplete Frambuffer')
      }
    }
    this.unbind();
  }

  /**
   * The bindForWriting method.
   * @param {any} renderstate - The renderstate value.
   * @param {boolean} clear - The clear value.
   */
  bindForWriting(renderstate, clear = false) {
    if (renderstate) {
      this.__prevBoundFbo = renderstate.boundRendertarget;
      renderstate.boundRendertarget = this.frameBuffer;
    }
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
    gl.viewport(0, 0, this.width, this.height); // Match the viewport to the texture size
    if (clear) this.clear();
  }

  /**
   * The unbindForWriting method.
   * @param {any} renderstate - The renderstate value.
   */
  unbindForWriting(renderstate) {
    if (renderstate) renderstate.boundRendertarget = this.__prevBoundFbo;
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__prevBoundFbo);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.__prevBoundFbo);
  }

  /**
   * The clear method.
   * @param {boolean} clearDepth - The clearDepth value.
   */
  clear(clearDepth = true) {
    const gl = this.__gl;
    gl.colorMask(...this.colorMask);
    gl.clearColor(...this.clearColor.asArray());
    let flags = 0;
    if (this.textureTargets.length > 0) flags |= gl.COLOR_BUFFER_BIT;
    if (this.depthTexture) flags |= gl.DEPTH_BUFFER_BIT;
    gl.clear(flags);
  }

  /**
   * The bindForReading method.
   */
  bindForReading() {
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
  }

  /**
   * The unbindForReading method.
   */
  unbindForReading() {
    const gl = this.__gl;
    if (gl.name == 'webgl2') gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  /**
   * The bindColorTexture method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @param {number} channelId - The channelId value.
   * @return {boolean} - The return value.
   */
  bindColorTexture(renderstate, unif, channelId = 0) {
    const gl = this.__gl;
    const unit = renderstate.boundTextures++;
    gl.uniform1i(unif.location, unit);
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, this.textureTargets[channelId]);
    return true
  }

  /**
   * The bindDepthTexture method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @return {boolean} - The return value.
   */
  bindDepthTexture(renderstate, unif) {
    const gl = this.__gl;
    const unit = renderstate.boundTextures++;
    gl.uniform1i(unif.location, unit);
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
    return true
  }

  /**
   * The unbind method.
   */
  unbind() {
    const gl = this.__gl;
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
  }

  /**
   * The resize method.
   * @param {any} width - The width value.
   * @param {any} height - The height value.
   * @param {boolean} preserveData - The preserveData value.
   */
  resize(width, height, preserveData = false) {
    /*
    const gl = this.__gl;
    const sizeChanged = this.width != width || this.height != height;
    if (sizeChanged) {
      const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
      if (width < 0 || width > maxSize || height < 0 || height > maxSize) {
          throw new Error("gl-texture2d: Invalid texture size. width:" + width + " height:" + height + " maxSize:" + maxSize);
      }
      const gltex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, gltex);
      gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__channels, this.__format, null);

      if (preserveData) {
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__gltex, 0);

        gl.bindTexture(gl.TEXTURE_2D, gltex); // Do we need this line?
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, 0, 0, this.width, this.height, 0);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        gl.deleteFramebuffer(fbo)
      }

      this.width = width;
      this.height = height;

      this.__gl.deleteTexture(this.__gltex);
      this.__gltex = gltex;
      this.__updateGLTexParams();
      if (emit) {
        this.emit('resized' { width, height });
      }
    }

    if (gl.name == 'webgl2')
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
    else
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

    // The color texture is destoryed and re-created when it is resized,
    // so we must re-bind it here..
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
    if (this.depthChannel) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.__depthTexture);
      if (gl.name == 'webgl2'){
        // the proper texture format combination can be found here
        // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
      }
      else
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
    }
    this.__checkFramebuffer();
    //gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    */
  }

  /**
   * The bindToUniform method.
   * @param {any} renderstate - The renderstate param.
   * @param {any} unif - The unif param.
   * @param {any} bindings - The bindings param.
   * @return {any} - The return value.
   */
  bindToUniform(renderstate, unif, bindings) {
    // if (!this.__loaded) {
    //   return false
    // }
    // if (!this.__gltex) {
    //   throw new Error('Unable to bind non-initialized or deleted texture.')
    // }

    const unit = renderstate.boundTextures++;
    const texId = this.__gl.TEXTURE0 + unit;
    const gl = this.__gl;
    gl.activeTexture(texId);
    gl.bindTexture(gl.TEXTURE_2D, this.textureTargets[0]);
    gl.uniform1i(unif.location, unit);

    if (bindings) {
      if (bindings.textureTypeUnif) {
        gl.uniform1i(bindings.textureTypeUnif.location, this.textureType);
      }

      if (bindings.textureDescUnif) {
        this.__gl.uniform4fv(bindings.textureDescUnif.location, this.textureDesc);
      }
    }

    return true
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    const gl = this.__gl;
    this.textureTargets.forEach((colorTexture) => {
      gl.deleteTexture(colorTexture);
    });
    this.textureTargets = [];
    if (this.depthTexture) {
      gl.deleteTexture(this.depthTexture);
      this.depthTexture = null;
    }
    if (this.frameBuffer) {
      gl.deleteFramebuffer(this.frameBuffer);
    }
  }
}

//based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
const bits = new Uint32Array(1);

function radicalInverse_VdC(i) {
  bits[0] = i;
  bits[0] = ((bits[0] << 16) | (bits[0] >> 16)) >>> 0;
  bits[0] = ((bits[0] & 0x55555555) << 1) | (((bits[0] & 0xaaaaaaaa) >>> 1) >>> 0);
  bits[0] = ((bits[0] & 0x33333333) << 2) | (((bits[0] & 0xcccccccc) >>> 2) >>> 0);
  bits[0] = ((bits[0] & 0x0f0f0f0f) << 4) | (((bits[0] & 0xf0f0f0f0) >>> 4) >>> 0);
  bits[0] = ((bits[0] & 0x00ff00ff) << 8) | (((bits[0] & 0xff00ff00) >>> 8) >>> 0);
  return bits[0] * 2.3283064365386963e-10 // / 0x100000000 or / 4294967296
}

function hammersley(i, n) {
  return [i / n, radicalInverse_VdC(i)]
}

shaderLibrary.setShaderModule(
  'utils/imageAtlas.glsl',
  `

// Note: On mobile, I can't seem to pass around a stuct containing sampler2D.
// I have to unpack the struct and pass its members. :(
// struct ImageAtlas {
//     sampler2D layout;
//     sampler2D image;
//     vec4 desc;
// };



vec4 getSubImageLayout(int index, in sampler2D atlasLayout, in vec4 atlasDesc){
    return fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);
}

vec2 calcSubImageTexCoords(vec2 texCoord, int index, in sampler2D atlasLayout, in vec4 atlasDesc){
    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);
    // The following line is a hack to fix artifacts in our PBR lighting
    // We were seeing loads of lighting garbage on some sufaces that were orthogonal
    // to the world. The UV coordinates would have been landing right on the edges
    // of our subimages and were often sampling outside the image. This couuld
    // have been because of filtering, or an error in the uv coords. 
    texCoord = clamp(texCoord, vec2(0.01, 0.01), vec2(0.99, 0.99));
    vec2 subimageTexel = texCoord * layoutData.zw;
    // subimageTexel = clamp(subimageTexel, vec2(0.0, 0.0), vec2(1.0, 1.0));
    return subimageTexel + layoutData.xy;
}

vec4 sampleSubImage(vec2 texCoord, int index, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){
    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);
    vec2 atlasCoords = calcSubImageTexCoords(texCoord, index, atlasLayout, atlasDesc);
    return texture2D(atlasImage, atlasCoords);
}

`
);

// eslint-disable-next-line require-jsdoc
class AtlasLayoutShader extends GLShader {
  /**
   * Create an atlas layout shader.
   * @param {any} gl - The gl value.
   */
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'AtlasLayoutShader.vertexShader',
      `

precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

uniform vec2 pos;
uniform vec2 size;
uniform vec2 srctextureDim;
const int border = 2;

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
  vec2 position = getQuadVertexPositionFromID();
  v_texCoord = position+0.5;
  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * size * 2.0), 0.0, 1.0);

  vec2 borderVec2 = vec2(float(border), float(border));
  v_texCoord *= (srctextureDim + (borderVec2 * 2.0)) / srctextureDim;
  v_texCoord -= borderVec2 / srctextureDim;
}

`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'AtlasLayoutShader.fragmentShader',
      `
precision highp float;

uniform sampler2D srctexture;
uniform vec2 srctextureDim;
uniform bool alphaFromLuminance;
uniform bool invert;

/* VS Outputs */
varying vec2 v_texCoord;

float luminanceFromRGB(vec3 rgb) {
  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;
}

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
  vec2 pixelCoord = v_texCoord*srctextureDim;
  vec2 uv = v_texCoord;

  // Wrap X coords
  if(pixelCoord.x < 0.0){
    uv.x += 1.0/srctextureDim.x;
    uv.y = 1.0 - uv.y;
  }
  else if(pixelCoord.x > srctextureDim.x){
    uv.x -= 1.0/srctextureDim.x;
    uv.y = 1.0 - uv.y;
  }

  // Wrap Y coords
  if(pixelCoord.y < 0.0){
    uv.y += 1.0/srctextureDim.y;
    uv.x = 1.0 - uv.x;
  }
  else if(pixelCoord.y > srctextureDim.y){
    uv.y -= 1.0/srctextureDim.y;
    uv.x = 1.0 - uv.x;
  }

  vec4 texel = texture2D(srctexture, uv);

#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  // TODO: check why we pre-multiply alphas here.
  // fragColor = vec4(texel.rgb/texel.a, texel.a);

  if(alphaFromLuminance) {
    fragColor = vec4(texel.rgb, luminanceFromRGB(texel.rgb));
  }
  else {
    fragColor = texel;
  }
  
  if(invert) {
    fragColor = vec4(1.0) - fragColor;
  }

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}

`
    );
  }
}

// eslint-disable-next-line require-jsdoc
class GLImageAtlas extends GLRenderTarget {
  /**
   * Create an image atlas..
   * @param {any} gl - The gl value.
   * @param {string} name - The name value.
   * @param {any} format - The format value.
   * @param {any} type - The type value.
   * @param {any} clearColor - The clearColor value.
   */
  constructor(gl, name, format = 'RGBA', type = 'FLOAT') {
    super(gl);
    this.__name = name;
    this.__formatParam = format;
    this.__typeParam = type;
    this.clearColor = new Color(0, 0, 0, 0);
    this.__subImages = [];
    this.__layoutNeedsRegeneration = false;
    this.__async = new Async();
    this.loaded = false;
    this.__async.on('ready', () => {
      this.loaded = true;
      this.emit('loaded', {});
    });
  }

  /**
   * The isLoaded method.
   * @return {any} - The return value.
   */
  isLoaded() {
    return this.__async.count == 0
  }

  /**
   * The getMainImage method.
   * @return {any} - The return value.
   */
  getMainImage() {
    return this.super
  }

  /**
   * The addSubImage method.
   * @param {any} subImage - The subImage value.
   * @return {any} - The return value.
   */
  addSubImage(subImage) {
    if (subImage instanceof BaseImage) {
      const gltexture = new GLTexture2D(this.__gl, subImage);
      if (!subImage.isLoaded()) {
        this.__async.incAsyncCount();
        subImage.on('loaded', () => {
          this.__async.decAsyncCount();
        });
      }
      subImage.setMetadata('ImageAtlas_gltex', gltexture);
      gltexture.addRef(this);

      const updated = () => {
        // TODO: Check to see if the new dimensions
        // do not match the previous. If not, then we
        // need to relayout. wE could also avlid a complete
        // relaout by reremoving and re-adding this image.
        this.__layoutNeedsRegeneration = true;
        this.renderAtlas();
      };
      subImage.on('updated', updated);
      this.__subImages.push(gltexture);
    } else {
      subImage.addRef(this); // subImage is a GLTexture2D
      this.__subImages.push(subImage);
    }

    this.__layoutNeedsRegeneration = true;
    return this.__subImages.length - 1
  }

  /**
   * The removeSubImage method.
   * @param {any} subImage - The subImage value.
   */
  removeSubImage(subImage) {
    let index;
    if (subImage instanceof BaseImage) {
      const gltext = subImage.getMetadata('ImageAtlas_gltex');
      index = this.__subImages.indexOf(gltext);
      subImage.deleteMetadata('ImageAtlas_gltex');
    } else {
      index = this.__subImages.indexOf(subImage);
    }
    const gltexture = this.__subImages[index];
    gltexture.removeRef(this);

    this.__subImages.splice(index, 1);

    this.__layoutNeedsRegeneration = true;
  }

  /**
   * The getSubImage method.
   * @param {number} index - The index value.
   * @return {any} - The return value.
   */
  getSubImage(index) {
    return this.__subImages[index]
  }

  /**
   * The numSubImages method.
   * @return {any} - The return value.
   */
  numSubImages() {
    if (this.__layout) return this.__layout.length
    return this.__subImages.length
  }

  /**
   * The generateAtlasLayout method.
   */
  generateAtlasLayout() {
    if (this.__subImages.length == 0) {
      this.__layoutNeedsRegeneration = false;
      return
    }
    const border = 2;

    // We must lay out the sub images in order of size.
    // else the paker might have trouble.
    const blocks = [];
    this.__subImages.forEach((subImage, index) => {
      blocks.push({
        w: subImage.width + border * 2,
        h: subImage.height + border * 2,
        area: subImage.width * subImage.height,
        index,
      });
    });

    blocks.sort((a, b) => (a.area > b.area ? -1 : a.area < b.area ? 1 : 0));

    const packer = new GrowingPacker();
    packer.fit(blocks);

    this.__layout = [];
    blocks.forEach((block, index) => {
      const subImage = this.__subImages[block.index];
      if (block.fit) {
        this.__layout[block.index] = {
          pos: new Vec2(block.fit.x + border, block.fit.y + border),
          size: new Vec2(block.w, block.h),
        };
      } else {
        console.warn('Unable to fit image');
      }
    });

    const width = packer.root.w;
    const height = packer.root.h;

    // console.log(this.__name + " Atlas Texture size:" + width.toFixed() + ", " + height.toFixed());

    // Note: only RGBA Float textures can be rendered to on Firefox.(Not RGB)
    this.configure({
      width,
      height,
      format: this.__typeParam == 'FLOAT' && this.__formatParam == 'RGB' ? 'RGBA' : this.__formatParam,
      type: this.__typeParam,
      filter: 'LINEAR',
    });

    const gl = this.__gl;
    // this.__fbo = new GLFbo(gl, this)
    // this.__fbo.setClearColor(this.__clearColor)

    if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();

    if (!gl.__atlasLayoutShader) {
      gl.__atlasLayoutShader = new AtlasLayoutShader(gl);
      const shaderComp = gl.__atlasLayoutShader.compileForTarget('GLImageAtlas');
      gl.__atlasLayoutShaderBinding = generateShaderGeomBinding(
        gl,
        shaderComp.attrs,
        gl.__quadattrbuffers,
        gl.__quadIndexBuffer
      );
    }

    const pixelsPerItem = 1;
    let size = Math.round(Math.sqrt(this.__layout.length * pixelsPerItem) + 0.5);
    // Only support power 2 textures. Else we get strange corruption on some GPUs
    // in some scenes.
    size = MathFunctions.nextPow2(size);
    // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
    // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
    if (size % pixelsPerItem != 0) size += pixelsPerItem - (size % pixelsPerItem);

    if (!gl.floatTexturesSupported) {
      this.__layoutVec4s = [];
      this.__layout.forEach((layoutItem, index) => {
        this.__layoutVec4s[index] = [
          layoutItem.pos.x / width,
          layoutItem.pos.y / height,
          layoutItem.size.x / width,
          layoutItem.size.y / height,
        ];
      });
    } else {
      const dataArray = new Float32Array(size * size * 4); /* each pixel has 4 floats*/
      for (let i = 0; i < this.__layout.length; i++) {
        const layoutItem = this.__layout[i];
        const vec4 = Vec4$1.createFromBuffer(dataArray.buffer, i * 4 * 4);
        vec4.set(
          layoutItem.pos.x / width,
          layoutItem.pos.y / height,
          layoutItem.size.x / width,
          layoutItem.size.y / height
        );
      }
      if (
        !this.__atlasLayoutTexture ||
        this.__atlasLayoutTexture.width != size ||
        this.__atlasLayoutTexture.height != size
      ) {
        if (this.__atlasLayoutTexture) this.__atlasLayoutTexture.destroy();
        this.__atlasLayoutTexture = new GLTexture2D(gl, {
          format: 'RGBA',
          type: 'FLOAT',
          filter: 'NEAREST',
          wrap: 'CLAMP_TO_EDGE',
          mipMapped: false,
          width: size,
          height: size,
          data: dataArray,
        });
      } else {
        this.__atlasLayoutTexture.bufferData(dataArray, size, size);
      }
    }

    this.__layoutNeedsRegeneration = false;
  }

  /**
   * The getLayoutData method.
   * @param {number} index - The index value.
   * @return {any} - The return value.
   */
  getLayoutData(index) {
    return this.__layoutVec4s[index]
  }

  /**
   * The renderAtlas method.
   * @param {boolean} cleanup - The cleanup value.
   * @param {number} off - The off value.
   */
  renderAtlas(cleanup = false, off = 0) {
    if (this.__subImages.length == 0) {
      return
    }
    if (this.__layoutNeedsRegeneration) {
      this.generateAtlasLayout();
    }
    const gl = this.__gl;
    const renderstate = {};
    this.bindForWriting(renderstate, true);

    gl.__atlasLayoutShader.bind(renderstate, 'GLImageAtlas');
    gl.__atlasLayoutShaderBinding.bind(renderstate);
    const scl = new Vec2(1.0 / this.width, 1.0 / this.height);

    const unifs = renderstate.unifs;
    for (let j = off; j < this.__subImages.length; j++) {
      const glimage = this.__subImages[j];

      const layoutItem = this.__layout[j];
      glimage.bindToUniform(renderstate, unifs.srctexture);
      gl.uniform2fv(unifs.pos.location, layoutItem.pos.multiply(scl).asArray());
      gl.uniform2fv(unifs.size.location, layoutItem.size.multiply(scl).asArray());
      gl.uniform2f(unifs.srctextureDim.location, glimage.width, glimage.height);
      gl.uniform1i(unifs.alphaFromLuminance.location, glimage.alphaFromLuminance);
      gl.uniform1i(unifs.invert.location, glimage.invert);
      gl.drawQuad();

      // After rendering the texture, we can reuse the texture unit.
      renderstate.boundTextures--;
    }

    if (cleanup) {
      this.cleanup();
    }

    this.unbind(renderstate);
    // this.__fbo.unbind()
    this.emit('updated', {});
  }

  /**
   * The isReady method.
   * @return {any} - The return value.
   */
  isReady() {
    return this.__atlasLayoutTexture != undefined
  }

  /**
   * The bindToUniform method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @return {any} - The return value.
   */
  bindToUniform(renderstate, unif) {
    if (!this.__atlasLayoutTexture) return false

    super.bindToUniform(renderstate, unif);

    const unifs = renderstate.unifs;
    const atlasLayoutUnif = unifs[unif.name + '_layout'];
    if (atlasLayoutUnif) this.__atlasLayoutTexture.bindToUniform(renderstate, atlasLayoutUnif);

    const atlasDescUnif = unifs[unif.name + '_desc'];
    if (atlasDescUnif)
      this.__gl.uniform4f(atlasDescUnif.location, this.width, this.height, this.__atlasLayoutTexture.width, 0.0);

    return true
  }

  /**
   * The cleanup method.
   */
  cleanup() {
    for (const glimage of this.__subImages) {
      glimage.removeRef(this);
    }
    this.__subImages = [];
    this.destroy();
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.cleanup();
    super.destroy();
  }
}

class ConvolverShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'ConvolverShader.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
  vec2 position = getQuadVertexPositionFromID();
  v_texCoord = position+0.5;
  gl_Position = vec4(position*2.0, 0.0, 1.0);
}
`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'ConvolverShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="utils/imagePyramid.glsl"/>
<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>

uniform float roughness;
varying vec2 v_texCoord;

uniform sampler2D hammersleyMap;
vec2 Hammersley(int i, int N) {
  vec4 rgba =  texture2D(hammersleyMap, vec2((float(i) + 0.5)/float(N)), 0.5);
  return rgba.rg;
}

mat3 matrixFromVector(vec3 n) { // frisvad
  float a = 1.0 / (1.0 + n.z);
  float b = -n.x * n.y * a;
  vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
  vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
  return mat3(b1, b2, n);
}

vec3 ImportanceSampleGGX(vec2 Xi, float a) {
  float phi = 2.0 * PI * Xi.x;
  float cos_theta = sqrt((1.0 - Xi.y)/(1.0 + (a*a - 1.0) * Xi.y));
  float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

  // float phi = Xi.y * 2.0 * PI;
  // float cos_theta = sqrt(1.0 - Xi.x);
  // float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

  vec3 H;
  H.x = sin_theta * cos(phi);
  H.y = sin_theta * sin(phi);
  H.z = cos_theta;
  return H;
}

// TODO: use tobias's code. The guy clearly knows what he's doing...
// https://github.com/thefranke/dirtchamber/blob/master/shader/importance.hlsl
// Compute a LOD level for filtered importance sampling.
// From GPU Gems 3: GPU-Based Importance Sampling.


#define M_PI       3.14159265358979323846   // pi
#define M_HALF_PI  1.57079632679489661923   // pi/2
float sqr(float val){ return val*val; }
float saturate(float val) { return clamp(val, 0.0, 1.0); }
vec3 saturate(vec3 val) { return clamp(val, 0.0, 1.0); }

// Microfacet Models for Refraction through Rough Surfaces
// Walter et al.
// http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html
// aka Towbridge-Reitz
float D_ggx(in float alpha, in float NoH)
{
  float a2 = alpha*alpha;
  float cos2 = NoH*NoH;

  return (1.0/M_PI) * sqr(alpha/(cos2 * (a2 - 1.0) + 1.0));

  /*
  // version from the paper, eq 33
  float CosSquared = NoH*NoH;
  float TanSquared = (1.0 - CosSquared)/CosSquared;
  return (1.0/M_PI) * sqr(alpha/(CosSquared * (alpha*alpha + TanSquared)));
  */
}
float compute_lod(in vec3 H, in float pdf, in int num_samples, in int ww, in int hh)
{
  return max(0.0, 0.5*log2(float(ww*hh)/float(num_samples)) - 0.5*log2(pdf));
}

uniform sampler2D   envMapPyramid;
uniform sampler2D   envMapPyramid_layout;
uniform vec4        envMapPyramid_desc;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec3 N = sphOctUvToDir(v_texCoord);

  if(false){
    vec2 uv = dirToSphOctUv(N);
    // fragColor = vec4(uv.x, uv.y, 0.0, 1.0);
    fragColor = sampleImagePyramid(uv, 0.5, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc);
    // fragColor = sampleSubImage(uv, 0, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc);
    // fragColor = texture2D(envMapPyramid, uv);
  }
  else{
    const int numSamples = NUM_SAMPLES;
    int w = int(floor(envMapPyramid_desc.x + 0.5));
    int h = int(floor(envMapPyramid_desc.y + 0.5));

    vec4 color = vec4(0.0,0.0,0.0,0.0);
    float weight = 0.0;
    mat3 vecSpace = matrixFromVector(N);
    float a = roughness*roughness;
    for(int i=0; i<numSamples; i++) {
      vec2 Xi = Hammersley(i, numSamples);
      vec3 H = ImportanceSampleGGX(Xi, a);
      vec3 V = normalize(vecSpace * H);
      float VdotN = dot(V, N);
      float NoH = saturate( dot( N, H ) );
      float VoH = saturate( dot( V, H ) );

      vec2 uv = dirToSphOctUv(V);
      // float pdf = D_ggx(a, NoH) * NoH / (4.0 * VoH);
      // float lod = compute_lod(H, pdf, numSamples, w, h);

      color += sampleImagePyramid(uv, a, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc) * VdotN;
      weight += VdotN;
    }
    color /= float(weight);
    fragColor = vec4(color.rgb, 1.0);
  }
  
#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}

`
    );
  }
}

shaderLibrary.setShaderModule(
  'utils/imagePyramid.glsl',
  `

<%include file="utils/imageAtlas.glsl"/>

vec4 sampleImagePyramid(vec2 uv, float lod, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){
  if (lod < 0.00001 || lod > 0.9999) {
    float imageIndex = lod * (atlasDesc.z-1.0);
    int imageId0 = int(imageIndex);
    return sampleSubImage(uv, imageId0, atlasLayout, atlasImage, atlasDesc);
  } else {
    float imageIndex = lod * (atlasDesc.z-1.0);
    int imageId0 = int(floor(imageIndex));
    int imageId1 = imageId0+1;
    float blend = fract(imageIndex);
    vec4 c0 = sampleSubImage(uv, imageId0, atlasLayout, atlasImage, atlasDesc);
    vec4 c1 = sampleSubImage(uv, imageId1, atlasLayout, atlasImage, atlasDesc);
    return mix(c0, c1, blend);
  } 
}


`
);

const Math_log2 = function (value) {
  // IE11 doesn't support Math.log2.
  return Math.log2(value)
  // return Math.log( value ) / Math.log( 2 ) - 2;
};

// class PyramidShader extends GLShader {

//     constructor(gl) {
//         super(gl);
//         this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader('PyramidShader.vertexShader', `

// <%include file="utils/quadVertexFromID.glsl"/>

// uniform vec2 pos;
// uniform vec2 size;

// /* VS Outputs */
// varying vec2 v_texCoord;

// void main()
// {
//     vec2 position = getQuadVertexPositionFromID();
//     v_texCoord = position+0.5;
//     gl_Position = vec4(vec2(-1.0,-1.0)+(pos*2.0)+(v_texCoord*size*2.0), 0.0, 1.0);
// }

// `);
//         this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader('PyramidShader.fragmentShader', `

// precision highp float;

// uniform sampler2D texture;
// uniform vec2 textureDim;

// varying vec2 v_texCoord;

// void main(void) {
//     vec2 pixelCoord = v_texCoord*textureDim;

//     vec2 acoord = abs(pixelCoord-textureDim*0.5);
//     float limit = textureDim.x*0.5-1.0;
//     vec2 sourceCoord = clamp(pixelCoord-1.0, 0.5, textureDim.x-2.5);
//     vec2 uv = sourceCoord/(textureDim-2.0);

//     if(acoord.x > limit && acoord.y > limit){
//         uv = 1.0 - uv;
//     }
//     else if(acoord.x > limit){
//         uv.y = 1.0 - uv.y;
//     }
//     else if(acoord.y > limit){
//         uv.x = 1.0 - uv.x;
//     }
//     vec4 texel = texture2D(texture, uv);
//     gl_FragColor = vec4(texel.rgb/texel.a, 1);
// }

// `);
//     }
// };

/** Class representing an image pyramid.
 * @extends GLImageAtlas
 * @private
 */
class ImagePyramid extends GLImageAtlas {
  /**
   * Create an image pyramid.
   * @param {any} gl - The gl value.
   * @param {string} name - The name value.
   * @param {any} srcGLTex - The srcGLTex value.
   * @param {boolean} destroySrcImage - The destroySrcImage value.
   * @param {number} minTileSize - The minTileSize value.
   */
  constructor(gl, name, srcGLTex, destroySrcImage = true, minTileSize = 16) {
    super(gl, name);

    this.__srcGLTex = srcGLTex;
    this.__fbos = [];

    srcGLTex.on('updated', () => {
      this.renderAtlas(destroySrcImage);
    });
    if (this.__srcGLTex.isLoaded()) {
      this.generateAtlasLayout(minTileSize);
      this.renderAtlas(destroySrcImage);
    } else {
      this.__srcGLTex.on('updated', () => {
        this.generateAtlasLayout(minTileSize);
        this.renderAtlas(destroySrcImage);
      });
    }
    srcGLTex.on('destructing', () => {
      console.log(this.__srcGLTex.getName() + ' ImagePyramid destructing');
      this.destroy();
    });
  }

  /**
   * The generateAtlasLayout method.
   * @param {any} minTileSize - The minTileSize value.
   */
  generateAtlasLayout(minTileSize) {
    const gl = this.__gl;

    this.size = this.__srcGLTex.height;
    const aspectRatio = this.__srcGLTex.width / this.__srcGLTex.height;

    this.addSubImage(this.__srcGLTex);
    const numLevels = Math.round(Math_log2(this.size)) - 1; // compute numLevels-1 levels(because we use the source image as the base level);
    for (let i = numLevels; i >= 0; --i) {
      const size = Math.pow(2, i);
      if (size < minTileSize) break
      // Create a target texture for this level of the pyramid.
      // and then render to it using the base level as a source image.
      const level = new GLTexture2D(gl, {
        format: this.__srcGLTex.getFormat(),
        type: this.__srcGLTex.getType(),
        width: size * aspectRatio,
        height: size,
        filter: 'LINEAR',
        wrap: 'CLAMP_TO_EDGE',
      });
      this.addSubImage(level);
      this.__fbos.push(new GLFbo(gl, level));
    }

    super.generateAtlasLayout();
  }

  /**
   * The renderAtlas method.
   * @param {boolean} cleanup - The cleanup value.
   */
  renderAtlas(cleanup = true) {
    const gl = this.__gl;
    const renderstate = {};
    gl.screenQuad.bindShader(renderstate);

    for (let i = 0; i < this.__fbos.length; i++) {
      this.__fbos[i].bindAndClear();
      gl.screenQuad.draw(renderstate, this.getSubImage(i)); // Note: we are binding the previous image. (we have 1 more images than fbos.)
    }

    super.renderAtlas(cleanup);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    for (const fbo of this.__fbos) {
      fbo.destroy();
    }
  }
}

/** Class representing a GL probe.
 * @extends GLImageAtlas
 * @private
 */
class GLProbe extends GLImageAtlas {
  /**
   * Create a GL probe.
   * @param {any} gl - The gl value.
   * @param {string} name - The name value.
   */
  constructor(gl, name) {
    super(gl, name);
    this.__gl = gl;

    if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();

    this.__convolved = false;
    this.__fbos = [];
  }

  /**
   * The generateHammersleySamples method.
   * @param {any} numSamples - The numSamples value.
   * @return {any} - The return value.
   */
  generateHammersleySamples(numSamples) {
    const gl = this.__gl;
    if (!gl['Hammersley' + numSamples]) {
      const dataArray = new Float32Array(numSamples * 3);
      for (let i = 0; i < numSamples; i++) {
        const Xi = hammersley(i, numSamples);
        const offset = i * 3;
        dataArray[offset + 0] = Xi[0];
        dataArray[offset + 1] = Xi[1];
      }
      gl['Hammersley' + numSamples] = new GLTexture2D(gl, {
        format: 'RGB',
        type: 'FLOAT',
        filter: 'NEAREST',
        wrap: 'CLAMP_TO_EDGE',
        width: numSamples,
        height: 1,
        data: dataArray,
        mipMapped: false,
      });
    }
    return gl['Hammersley' + numSamples]
  }

  /**
   * The convolveProbe method.
   * @param {any} srcGLTex - The srcGLTex value.
   */
  convolveProbe(srcGLTex) {
    const gl = this.__gl;

    // Compile and bind the convolver shader.
    const numSamples = 1024;
    // const numSamples = 64;
    const hammersleyTexture = this.generateHammersleySamples(numSamples);

    if (!this.__convolved) {
      if (!this.__lodPyramid) {
        this.__lodPyramid = new ImagePyramid(gl, 'Probe Lods', srcGLTex, false);
        this.__lodPyramid.on('updated', () => {
          // If the image pyramid updates, we need to re-convolve.
          this.convolveProbe(srcGLTex);
        });
      }

      this.addSubImage(srcGLTex);

      let currRez = [srcGLTex.width / 2, srcGLTex.height / 2];

      const levels = 6; // this.__lodPyramid.numSubImages();
      for (let i = 0; i < levels; i++) {
        const level = new GLTexture2D(gl, {
          format: 'RGBA',
          type: 'FLOAT',
          filter: 'LINEAR',
          wrap: 'CLAMP_TO_EDGE',
          width: currRez[0],
          height: currRez[1],
        });
        this.addSubImage(level);

        const fbo = new GLFbo(gl, level);
        fbo.setClearColor([0, 1, 0, 0]);
        this.__fbos.push(fbo);

        currRez = [currRez[0] / 2, currRez[1] / 2];
      }

      this.generateAtlasLayout();

      this.__convolverShader = new ConvolverShader(gl);
      const covolverShaderComp = this.__convolverShader.compileForTarget(
        'GLProbe',
        Object.assign(
          {
            repl: {
              NUM_SAMPLES: numSamples,
            },
          },
          gl.shaderopts
        )
      );
      this.__covolverShaderBinding = generateShaderGeomBinding(
        gl,
        covolverShaderComp.attrs,
        gl.__quadattrbuffers,
        gl.__quadIndexBuffer
      );
    }

    // TODO: Refactor this code.
    // We only need one target image for the probe. (not all these Fbos.)
    // Instead we can simply move the viewport around the target image atlas.
    const renderstate = {};
    this.__convolverShader.bind(renderstate, 'GLProbe');
    this.__covolverShaderBinding.bind(renderstate);
    const unifs = renderstate.unifs;
    for (let i = 0; i < this.__fbos.length; i++) {
      this.__fbos[i].bindAndClear();

      // Note: we should not need to bind the texture every iteration.
      this.__lodPyramid.bindToUniform(renderstate, unifs.envMapPyramid);
      if ('hammersleyMap' in unifs) {
        hammersleyTexture.bindToUniform(renderstate, unifs.hammersleyMap);
      }

      // Set the roughness.
      if ('roughness' in unifs) {
        const roughness = (i + 1) / this.__fbos.length;
        gl.uniform1f(unifs.roughness.location, roughness);
      }

      gl.drawQuad();
    }

    this.__convolved = true;

    this.renderAtlas(false);
  }

  /**
   * The bindProbeToUniform method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   */
  bindProbeToUniform(renderstate, unif) {
    // this.__lodPyramid.getSubImage(3).bind(renderstate, unif);
    if (this.__convolved) super.bindToUniform(renderstate, unif);
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    this.__convolverShader.destroy();

    for (const fbo of this.__fbos) {
      fbo.destroy();
    }
  }
}

shaderLibrary.setShaderModule(
  'stack-gl/inverse.glsl',
  `


#ifndef ENABLE_ES3

float inverse(float m) {
  return 1.0 / m;
}

mat2 inverse(mat2 m) {
  return mat2(m[1][1],-m[0][1],
             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
}

mat3 inverse(mat3 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22 * a11 - a12 * a21;
  float b11 = -a22 * a10 + a12 * a20;
  float b21 = a21 * a10 - a11 * a20;

  float det = a00 * b01 + a01 * b11 + a02 * b21;

  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
}

mat4 inverse(mat4 m) {
  float
      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

      b00 = a00 * a11 - a01 * a10,
      b01 = a00 * a12 - a02 * a10,
      b02 = a00 * a13 - a03 * a10,
      b03 = a01 * a12 - a02 * a11,
      b04 = a01 * a13 - a03 * a11,
      b05 = a02 * a13 - a03 * a12,
      b06 = a20 * a31 - a21 * a30,
      b07 = a20 * a32 - a22 * a30,
      b08 = a20 * a33 - a23 * a30,
      b09 = a21 * a32 - a22 * a31,
      b10 = a21 * a33 - a23 * a31,
      b11 = a22 * a33 - a23 * a32,

      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  return mat4(
      a11 * b11 - a12 * b10 + a13 * b09,
      a02 * b10 - a01 * b11 - a03 * b09,
      a31 * b05 - a32 * b04 + a33 * b03,
      a22 * b04 - a21 * b05 - a23 * b03,
      a12 * b08 - a10 * b11 - a13 * b07,
      a00 * b11 - a02 * b08 + a03 * b07,
      a32 * b02 - a30 * b05 - a33 * b01,
      a20 * b05 - a22 * b02 + a23 * b01,
      a10 * b10 - a11 * b08 + a13 * b06,
      a01 * b08 - a00 * b10 - a03 * b06,
      a30 * b04 - a31 * b02 + a33 * b00,
      a21 * b02 - a20 * b04 - a23 * b00,
      a11 * b07 - a10 * b09 - a12 * b06,
      a00 * b09 - a01 * b07 + a02 * b06,
      a31 * b01 - a30 * b03 - a32 * b00,
      a20 * b03 - a21 * b01 + a22 * b00) / det;
}

#endif

`
);

shaderLibrary.setShaderModule(
  'stack-gl/transpose.glsl',
  `


#ifndef ENABLE_ES3

float transpose(float m) {
  return m;
}

mat2 transpose(mat2 m) {
  return mat2(m[0][0], m[1][0],
              m[0][1], m[1][1]);
}

mat3 transpose(mat3 m) {
  return mat3(m[0][0], m[1][0], m[2][0],
              m[0][1], m[1][1], m[2][1],
              m[0][2], m[1][2], m[2][2]);
}

mat4 transpose(mat4 m) {
  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],
              m[0][1], m[1][1], m[2][1], m[3][1],
              m[0][2], m[1][2], m[2][2], m[3][2],
              m[0][3], m[1][3], m[2][3], m[3][3]);
}

#endif

`
);

// https://gist.github.com/pyalot/cc7c3e5f144fb825d626
shaderLibrary.setShaderModule(
  'pragmatic-pbr/envmap-octahedral.glsl',
  `

#define sectorize(value) step(0.0, (value))*2.0-1.0
#define sum(value) dot(clamp((value), 1.0, 1.0), (value))


vec2 dirToSphOctUv(vec3 normal){
    normal = normalize(normal);
    vec3 aNorm = abs(normal);
    vec3 sNorm = sectorize(normal);

    vec2 dir = max(aNorm.xy, 1e-20);
    float orient = atan(dir.x, dir.y)/HalfPI;

    dir = max(vec2(aNorm.z, length(aNorm.xy)), 1e-20);
    float pitch = atan(dir.y, dir.x)/HalfPI;

    vec2 uv = vec2(sNorm.x*orient, sNorm.y*(1.0-orient))*pitch;

    if(normal.z < 0.0){
        uv = sNorm.xy - abs(uv.ts)*sNorm.xy;
    }
    return uv*0.5+0.5;
}


vec3 sphOctUvToDir(vec2 uv){
    uv = uv*2.0-1.0;
    vec2 suv = sectorize(uv);
    float sabsuv =  sum(abs(uv));
    float pitch = sabsuv*HalfPI;

    if (pitch <= 0.0) {
        return vec3(0.0, 0.0, 1.0);
    }
    if (abs(pitch - PI) < 0.000001) {
        return vec3(0.0, 0.0, -1.0);
    }
    if(sabsuv > 1.0){
        uv = (1.0-abs(uv.ts))*suv;
    }

    float orient = (abs(uv.s)/sabsuv)*HalfPI;
    float sOrient = sin(orient);
    float cOrient = cos(orient);
    float sPitch = sin(pitch);
    float cPitch = cos(pitch);

    return vec3(
        sOrient*suv.s*sPitch,
        cOrient*suv.t*sPitch,
        cPitch
    );
}

`
);

shaderLibrary.setShaderModule(
  'pragmatic-pbr/envmap-equirect.glsl',
  `


vec2 latLongUVsFromDir(vec3 dir) {
  // Math function taken from...
  // http://gl.ict.usc.edu/Data/HighResProbes/
  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]
  float phi = acos(dir.z);
  float theta = atan(dir.x, dir.y);
  return vec2((1.0 + theta / PI) / 2.0, phi / PI);
}

// Note: when u == 0.5 z = 1.0
vec3 dirFromLatLongUVs(float u, float v) {
    // http://gl.ict.usc.edu/Data/HighResProbes/
    float theta = PI*((u * 2.0) - 1.0);
    float phi = PI*v;
    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));
}

vec3 dirFromPolar(vec2 polar) {
    float u = polar.x / (PI * 2.0);
    float v = polar.y / PI;
    return dirFromLatLongUVs(u, v);
}

`
);

shaderLibrary.setShaderModule(
  'pragmatic-pbr/envmap-dualfisheye.glsl',
  `



vec2 dualfisheyeUVsFromDir(vec3 dir) {
  vec2 result;
  float angle = 0.465;
    if(dir.x < 0.0) {
        result = vec2(((dir.z * -angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);
    }
    else {
        result = vec2( 0.5 + ((dir.z * angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);
    }
    return result;
}


`
);

/* eslint-disable require-jsdoc */

class EnvMapShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'EnvMapShader.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;

<%include file="stack-gl/inverse.glsl"/>
<%include file="stack-gl/transpose.glsl"/>

/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;
 
void main()
{
  vec2 position = getQuadVertexPositionFromID() * 2.0;
  v_texCoord = position * 0.5 + 0.5;

  mat4 inverseProjection = inverse(projectionMatrix);
  mat3 inverseModelview = transpose(mat3(viewMatrix));

  // transform from the normalized device coordinates back to the view space
  vec3 unprojected = (inverseProjection * vec4(position, 0, 1)).xyz;

  // transfrom from the view space back to the world space
  // and use it as a sampling vector
  v_worldDir = inverseModelview * unprojected;

  gl_Position = vec4(position, 0, 1);
}

`
    );
  }
}

class BackgroundImageShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'LatLongEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-equirect.glsl"/>

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
uniform float exposure;
#endif

uniform sampler2D backgroundImage;


/* VS Outputs */
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec4 texel = texture2D(backgroundImage, v_texCoord);
  fragColor = vec4(texel.rgb/texel.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  //fragColor.rgb = toGamma(fragColor.rgb * exposure);

  // Assuming a simple RGB image in gamma space for now.
  fragColor.rgb = fragColor.rgb * exposure;
#endif


#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

class OctahedralEnvMapShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'OctahedralEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>
<%include file="utils/imagePyramid.glsl"/>
<%include file="stack-gl/gamma.glsl"/>

uniform float focus;

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
uniform float exposure;
#endif

// uniform ImageAtlas envMap;
uniform sampler2D   envMapPyramid;
uniform sampler2D   envMapPyramid_layout;
uniform vec4        envMapPyramid_desc;


/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 uv = dirToSphOctUv(normalize(v_worldDir));
  if(false){
    // Use these lines to debug the src GL image.
    vec4 texel = texture2D(envMapPyramid, uv);
    fragColor = vec4(texel.rgb/texel.a, 1.0);
  }
  else{
    fragColor = vec4(sampleImagePyramid(uv, focus, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc).rgb, 1.0);
  }

#ifdef ENABLE_INLINE_GAMMACORRECTION
  fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

class LatLongEnvMapShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'LatLongEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-equirect.glsl"/>

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
uniform float exposure;
#endif

uniform sampler2D backgroundImage;


/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));

  vec4 texel = texture2D(backgroundImage, uv);
  fragColor = vec4(texel.rgb/texel.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif
#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    return paramDescs
  }
}

class SterioLatLongEnvMapShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'SterioLatLongEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-equirect.glsl"/>

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
uniform float exposure;
#endif

uniform int eye;// L = 0, R = 1;

uniform sampler2D backgroundImage;

/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));
  uv.y *= 0.5;
  if(eye == 1){
    uv.y += 0.5;
  }

  vec4 texel = texture2D(backgroundImage, uv);
  fragColor = vec4(texel.rgb/texel.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  //fragColor.rgb = toGamma(fragColor.rgb * exposure);

  // Assuming a simple RGB image in gamma space for now.
  fragColor.rgb = fragColor.rgb * exposure;
#endif

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

class DualFishEyeEnvMapShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'DualFishEyeEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-dualfisheye.glsl"/>

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
uniform float exposure;
#endif

uniform sampler2D backgroundImage;

/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 uv = dualfisheyeUVsFromDir(normalize(v_worldDir));

  vec4 texel = texture2D(backgroundImage, uv);
  fragColor = vec4(texel.rgb/texel.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  //fragColor.rgb = toGamma(fragColor.rgb * exposure);

  // Assuming a simple RGB image in gamma space for now.
  fragColor.rgb = fragColor.rgb * exposure;
#endif

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

class DualFishEyeToLatLongBackgroundShader extends EnvMapShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'DualFishEyeEnvMapShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-equirect.glsl"/>
<%include file="pragmatic-pbr/envmap-dualfisheye.glsl"/>

#define ENABLE_INLINE_GAMMACORRECTION
#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
uniform float exposure;
#endif

uniform sampler2D backgroundImage;

/* VS Outputs */
varying vec3 v_worldDir;
varying vec2 v_texCoord;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 uv = dualfisheyeUVsFromDir(dirFromLatLongUVs(v_texCoord.x, v_texCoord.y));
  vec4 texel = texture2D(backgroundImage, uv);
  fragColor = vec4(texel.rgb/texel.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  //fragColor.rgb = toGamma(fragColor.rgb * exposure);

  // Assuming a simple RGB image in gamma space for now.
  // fragColor.rgb = fragColor.rgb * exposure;
#endif

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

/** Class representing a GL environment map.
 * @extends GLProbe
 * @private
 */
class GLEnvMap extends GLProbe {
  /**
   * Create a GL env map.
   * @param {any} renderer - The renderer value.
   * @param {any} envMap - The environment map.
   * @param {any} preproc - The preproc value.
   */
  constructor(renderer, envMap, preproc) {
    super(renderer.gl, 'EnvMap');
    this.__renderer = renderer;
    this.__envMap = envMap;
    this.__backgroundFocus = 0.0;

    const gl = renderer.gl;
    if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();

    let srcGLTex = this.__envMap.getMetadata('gltexture');
    if (!srcGLTex) {
      srcGLTex = new GLHDRImage(gl, this.__envMap);
    }
    this.__srcGLTex = srcGLTex; // for debugging

    this.__envMapShader = new OctahedralEnvMapShader(gl);
    const envMapShaderComp = this.__envMapShader.compileForTarget('GLEnvMap', preproc);
    this.__envMapShaderBinding = generateShaderGeomBinding(
      gl,
      envMapShaderComp.attrs,
      gl.__quadattrbuffers,
      gl.__quadIndexBuffer
    );

    if (this.__envMap.isLoaded()) {
      this.convolveProbe(srcGLTex);
    } else {
      const loaded = () => {
        // console.log(this.__envMap.getName() + " loaded");
        this.convolveProbe(srcGLTex);
        this.emit('loaded', {});
      };
      this.__envMap.on('loaded', loaded);
    }
  }

  /**
   * The getEnvMap method.
   * @return {any} - The return value.
   */
  getEnvMap() {
    return this.__envMap
  }

  /**
   * The getBackgroundFocus method.
   * @return {any} - The return value.
   */
  getBackgroundFocus() {
    return this.__backgroundFocus
  }

  /**
   * The setBackgroundFocus method.
   * @param {any} val - The val param.
   */
  setBackgroundFocus(val) {
    this.__backgroundFocus = val;
    this.__renderer.requestRedraw();
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.__envMap.isLoaded()) {
      const gl = this.__gl;
      {
        // /////////////////
        this.__envMapShader.bind(renderstate, 'GLEnvMap');
        const unifs = renderstate.unifs;
        // this.__srcGLTex.bind(renderstate, renderstate.unifs.envMap.location);
        // this.__lodPyramid.bind(renderstate, renderstate.unifs.envMap.location);
        this.bindProbeToUniform(renderstate, unifs.envMapPyramid);
        // this.bindToUniform(renderstate, unifs.envMapPyramid);

        {
          const unif = unifs.focus;
          if (unif) gl.uniform1f(unif.location, this.__backgroundFocus);
        }
        {
          const unif = unifs.exposure;
          if (unif) gl.uniform1f(unif.location, renderstate.exposure);
        }

        this.__envMapShaderBinding.bind(renderstate);
        gl.depthMask(false);

        renderstate.bindViewports(unifs, () => {
          gl.drawQuad();
        });
      }
    }
  }

  /**
   * The bindToUniform method.
   * An EnvMap can be bound as a regular texture, but we want the
   * original source data, not the atlas of convolved images.
   * @param {any} renderstate - The renderstate value.
   * @param {any} unif - The unif value.
   * @param {any} bindings - The bindings value.
   * @return {any} - The return value.
   */
  bindToUniform(renderstate, unif, bindings) {
    return this.__srcGLTex.bindToUniform(renderstate, unif, bindings)
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    super.destroy();
    this.__srcGLTex.loaded.disconnectScope(this);
    this.__srcGLTex.updated.disconnectScope(this);
    this.__srcGLTex.destroy();
  }
}

function onResize(element, callback) {
  if (!onResize.watchedElementData) {
    // First time we are called, create a list of watched elements
    // and hook up the event listeners.
    onResize.watchedElementData = [];

    const checkForChanges = function() {
      onResize.watchedElementData.forEach(function(data) {
        if (data.element.offsetWidth !== data.offsetWidth ||
            data.element.offsetHeight !== data.offsetHeight) {
          data.offsetWidth = data.element.offsetWidth;
          data.offsetHeight = data.element.offsetHeight;
          data.callback();
        }
      });
    };

    // Listen to the window's size changes
    window.addEventListener('resize', checkForChanges);

    // Listen to changes on the elements in the page that affect layout 
    const observer = new MutationObserver(checkForChanges);
    observer.observe(document.body, { 
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true 
    });
  }

  // Save the element we are watching
  onResize.watchedElementData.push({
    element: element,
    offsetWidth: element.offsetWidth,
    offsetHeight: element.offsetHeight,
    callback: callback
  });
}

class ScreenQuadShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'ScreenQuadShader.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

uniform vec2 pos;
uniform vec2 size;

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
    vec2 position = getQuadVertexPositionFromID();
    v_texCoord = position+0.5;
    gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * abs(size) * 2.0), 0.0, 1.0);
    if(size.x < 0.0)
        v_texCoord.x = 1.0 - v_texCoord.x;
    if(size.y < 0.0)
        v_texCoord.y = 1.0 - v_texCoord.y;
}
`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'ScreenQuadShader.fragmentShader',
      `
precision highp float;

uniform sampler2D image;

varying vec2 v_texCoord;


#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    fragColor = texture2D(image, v_texCoord);
    fragColor = vec4(fragColor.rgb/fragColor.a, 1.0);

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}
//export default ScreenQuadShader;

/** Class representing a GL screen quad.
 * @private
 */
class GLScreenQuad {
  /**
   * Create a GL screen quad.
   * @param {any} gl - The gl value.
   * @param {any} preproc - The preproc value.
   */
  constructor(gl, preproc) {
    this.__gl = gl;

    this.__pos = [0.0, 0.0];
    this.__size = [1.0, 1.0];
    this.flipY = true;
    this.__glshader = new ScreenQuadShader(gl);

    if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();

    const shaderComp = this.__glshader.compileForTarget('GLScreenQuad', preproc);
    this.__quadBinding = generateShaderGeomBinding(gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);

    this.ready = true;
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} texture - The texture pavalueram.
   * @param {any} pos - The pos value.
   * @param {any} size - The size value.
   */
  bind(renderstate, texture, pos = undefined, size = undefined) {
    const unifs = renderstate.unifs;
    texture.bindToUniform(renderstate, renderstate.unifs.image);

    const gl = this.__gl;
    {
      const unif = unifs.pos;
      if (unif) {
        gl.uniform2fv(unif.location, pos ? (pos instanceof AttrValue ? pos.asArray() : pos) : this.__pos);
      }
    }
    {
      const unif = unifs.size;
      if (unif) {
        gl.uniform2fv(unif.location, size ? (size instanceof AttrValue ? size.asArray() : size) : this.__size);
      }
    }
    // if ('flipY' in unifs)
    //     gl.uniform1i(unifs.flipY.location, this.flipY ? 1 : 0);

    // if ('textureDim' in unifs)
    //     gl.uniform2fv(unifs.textureDim.location, [texture.width, texture.height]);

    this.__quadBinding.bind(renderstate);
  }

  /**
   * The bindShader method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bindShader(renderstate) {
    return this.__glshader.bind(renderstate, 'GLScreenQuad')
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} texture - The texture value.
   * @param {any} pos - The pos value.
   * @param {any} size - The size value.
   */
  draw(renderstate, texture, pos = undefined, size = undefined) {
    this.bind(renderstate, texture, pos, size);

    this.__gl.drawQuad();
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {}
}

/** Class representing a GL base viewport.
 * @extends ParameterOwner
 * @private
 */
class GLBaseViewport extends ParameterOwner {
  /**
   * Create a GL base viewport.
   * @param {any} renderer - The renderer value.
   */
  constructor(renderer) {
    super();
    this.__renderer = renderer;
    this.__doubleClickTimeMSParam = this.addParameter(new NumberParameter('DoubleClickTimeMS', 200));
    this.__fbo = undefined;

    const sceneSet = () => {
      const settings = renderer.getScene().settings;
      const bgColorParam = settings.getParameter('BackgroundColor');
      const processBGValue = () => {
        const value = bgColorParam.getValue();
        const gl = this.__renderer.gl;
        if (value instanceof BaseImage) {
          if (value.type === 'FLOAT') {
            this.__backgroundTexture = value;
            this.__backgroundGLTexture = new GLHDRImage(gl, value);
          } else {
            this.__backgroundTexture = value;
            this.__backgroundGLTexture = new GLTexture2D(gl, value);
          }
        } else if (value instanceof Color) {
          if (this.__backgroundGLTexture) {
            this.__backgroundGLTexture.destroy();
            this.__backgroundGLTexture = undefined;
            this.__backgroundTexture = undefined;
          }
          this.__backgroundColor = value;
        } else {
          console.warn('Invalid background:' + value);
        }
        this.emit('updated', {});
      };
      processBGValue();
      bgColorParam.on('valueChanged', processBGValue);
    };

    this.__renderer.on('sceneSet', sceneSet);
  }

  /**
   * The getRenderer method.
   * @return {any} - The return value.
   */
  getRenderer() {
    return this.__renderer
  }

  /**
   * The getBl method.
   * @return {any} - The return value.
   */
  getBl() {
    return this.__bl
  }

  /**
   * The setBl method.
   * @param {any} bl - The bl value.
   */
  setBl(bl) {
    this.__bl = bl;
    this.resize(this.__canvasWidth, this.__canvasHeight);
  }

  /**
   * The getTr method.
   * @return {any} - The return value.
   */
  getTr() {
    return this.__tr
  }

  /**
   * The setTr method.
   * @param {any} tr - The tr value.
   */
  setTr(tr) {
    this.__tr = tr;
    this.resize(this.__canvasWidth, this.__canvasHeight);
  }

  /**
   * The getPosX method.
   * @return {any} - The return value.
   */
  getPosX() {
    return this.__x
  }

  /**
   * The getPosY method.
   * @return {any} - The return value.
   */
  getPosY() {
    return this.__y
  }

  /**
   * The getWidth method.
   * @return {any} - The return value.
   */
  getWidth() {
    return this.__width
  }

  /**
   * The getHeight method.
   * @return {any} - The return value.
   */
  getHeight() {
    return this.__height
  }

  /**
   * The getBackground method.
   * @return {any} - The return value.
   */
  getBackground() {
    console.warn('Deprecated Function. Please access the Scene Settings object.');
    const settings = this.__renderer.getScene().settings;
    const bgColorParam = settings.getParameter('BackgroundColor');
    return bgColorParam.getValue()
  }

  /**
   * The setBackground method.
   * @param {any} background - The background value.
   */
  setBackground(background) {
    console.warn('Deprecated Function. Please access the Scene Settings object.');
    const settings = this.__renderer.getScene().settings;
    const bgColorParam = settings.getParameter('BackgroundColor');
    bgColorParam.setValue(background);
    this.emit('updated', {});
  }

  /**
   * The resize method.
   * @param {any} canvasWidth - The canvasWidth value.
   * @param {any} canvasHeight - The canvasHeight value.
   */
  resize(canvasWidth, canvasHeight) {
    this.__canvasWidth = canvasWidth;
    this.__canvasHeight = canvasHeight;
    this.__width = canvasWidth;
    this.__height = canvasHeight;
    this.emit('resized', { width: this.__width, height: this.__height });
  }

  // ///////////////////////////
  // Events

  /**
   * Causes an event to occur when a user presses a mouse button over an element.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onMouseDown(event) {
    return false
  }

  /**
   * Causes an event to occur when a user releases a mouse button over a element.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onMouseUp(event) {
    return false
  }

  /**
   * Causes an event to occur when the mouse pointer is moving while over an element.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onMouseMove(event) {
    return false
  }

  /**
   * Causes an event to occur when the mouse pointer is moved out of an element.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onMouseLeave(event) {
    return false
  }

  /**
   * Causes an event to occurs when the user presses a key on the keyboard.
   * @param {any} key - The key the user presses.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onKeyPressed(key, event) {
    return false
  }

  /**
   * Causes an event to occur when the user is pressing a key on the keyboard.
   * @param {any} key - The key the user is pressing.
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onKeyDown(key, event) {
    return false
  }

  /**
   * Causes an event to occur  when the user releases a key on the keyboard.
   * @param {any} key - The key the user releases
   * @param {any} event - The event that occurs.
   * @return {boolean} - The return value.
   */
  onKeyUp(key, event) {
    return false
  }
}

/** Class representing a GL viewport.
 *
 * @extends GLBaseViewport
 */
class GLViewport extends GLBaseViewport {
  /**
   * Create a GL viewport.
   * @param {any} renderer - The renderer value.
   * @param {string} name - The name value.
   * @param {any} width - The width of the viewport
   * @param {any} height - The height of the viewport
   */
  constructor(renderer, name, width, height) {
    super(renderer);
    this.__name = name;
    this.__projectionMatrix = new Mat4();
    this.__frustumDim = new Vec2();

    // Layout coords, x:[0..1], y:[0..1]
    this.__bl = new Vec2(0, 0);
    this.__tr = new Vec2(1, 1);

    this.__exposure = 0.0;
    this.__exposureRange = [-5, 10];
    this.__tonemap = true;
    this.__gamma = 2.2;
    this.__prevDownTime = 0;

    this.__geomDataBuffer = undefined;
    this.__geomDataBufferFbo = undefined;

    // this.renderGeomDataFbo = this.renderGeomDataFbo.bind(this);

    // Each user has a separate camera, and so the default
    //  camera cannot be part of the scene.
    this.setCamera(new Camera('Default'));
    this.setManipulator(new CameraMouseAndKeyboard());

    this.resize(width, height);
  }

  /**
   * The resize method.
   * @param {number} width - The width value.
   * @param {number} height - The height value.
   */
  resize(width, height) {
    this.__canvasWidth = width;
    this.__canvasHeight = height;
    this.__x = width * this.__bl.x;
    this.__y = width * this.__bl.y;
    this.__width = width * this.__tr.x - width * this.__bl.x;
    this.__height = height * this.__tr.y - height * this.__bl.y;
    this.region = [this.__x, this.__y, this.__width, this.__height];

    if (this.__camera) this.__updateProjectionMatrix();

    if (this.__geomDataBufferFbo) {
      this.__geomDataBuffer.resize(this.__width, this.__height);
      this.__geomDataBufferFbo.resize();
    }
    this.emit('resized', { width, height });
  }

  /**
   * The getCamera method.
   * @return {any} - The return value.
   */
  getCamera() {
    return this.__camera
  }

  /**
   * The setCamera method.
   * @param {any} camera - The camera value.
   */
  setCamera(camera) {
    this.__camera = camera;
    const globalXfoParam = camera.getParameter('GlobalXfo');
    const getCameraParams = () => {
      this.__cameraXfo = globalXfoParam.getValue();
      this.__cameraMat = this.__cameraXfo.toMat4();
      this.__viewMat = this.__cameraMat.inverse();
    };
    getCameraParams();
    globalXfoParam.on('valueChanged', () => {
      getCameraParams();
      this.invalidateGeomDataBuffer();
      this.emit('updated', {});
      this.emit('viewChanged', {
        interfaceType: 'CameraAndPointer',
        viewXfo: this.__cameraXfo,
        focalDistance: this.__camera.getFocalDistance(),
      });
    });
    this.__camera.on('projectionParamChanged', () => {
      this.__updateProjectionMatrix();
      this.emit('updated', {});
    });

    this.__updateProjectionMatrix();
  }

  /**
   * The getManipulator method.
   * @return {any} - The return value.
   */
  getManipulator() {
    return this.__cameraManipulator
  }

  /**
   * The setManipulator method.
   * @param {any} manipulator - The manipulator value.
   */
  setManipulator(manipulator) {
    this.__cameraManipulator = manipulator;
  }

  // eslint-disable-next-line require-jsdoc
  __updateProjectionMatrix() {
    const aspect = this.__width / this.__height;
    this.__camera.updateProjectionMatrix(this.__projectionMatrix, aspect);

    const frustumH = Math.tan(this.__camera.getFov() / 2.0) * this.__camera.getNear() * 2.0;
    const frustumW = frustumH * aspect;
    this.__frustumDim.set(frustumW, frustumH);
  }

  /**
   * The getProjectionMatrix method.
   * @return {Mat4} - The return projection matrix for the viewport.
   */
  getProjectionMatrix() {
    return this.__projectionMatrix
  }

  /**
   * The getProjectionMatrix method.
   * @return {Mat4} - The return projection matrix for the viewport.
   */
  getViewMatrix() {
    return this.__viewMat
  }

  /**
   * The setActive method.
   * @param {boolean} state - The state value.
   */
  setActive(state) {
    if (state) activeViewport = this;
    else activeViewport = undefined;
  }

  /**
   * The frameView method.
   * @param {array} treeItems - The treeItems value.
   */
  frameView(treeItems) {
    if (this.__width > 0 && this.__height > 0) this.__camera.frameView(this, treeItems);
    else {
      console.warn('Unable to frameView while Viewport with and height are 0.');
    }
  }

  /**
   * Compute a ray into the scene based on a mouse coordinate.
   * @param {Vec2} screenPos - The screen position.
   * @return {Ray} - The return value.
   */
  calcRayFromScreenPos(screenPos) {
    // Convert the raster coordinates to screen space ([0,{w|h}] -> [-1,1]
    // - Note: The raster vertical is inverted wrt OGL screenspace Y

    const topy = this.__canvasHeight * (1.0 - this.__tr.y);
    let sx = (screenPos.x - this.__x) / this.__width;
    let sy = (screenPos.y - topy) / this.__height;

    sx = sx * 2.0 - 1.0;
    sy = sy * 2.0 - 1.0;

    // Transform the origin from camera local to world space
    const cameraMat = this.__cameraMat;

    const projInv = this.__projectionMatrix.inverse();
    if (projInv == null)
      // Sometimes this happens, not sure why...
      return null

    let rayStart;
    let rayDirection;
    if (this.__camera.getIsOrthographic()) {
      // Orthographic projections.
      rayStart = cameraMat.transformVec3(projInv.transformVec3(new Vec3$1(sx, -sy, -1.0)));
      rayDirection = new Vec3$1(0.0, 0.0, -1.0);
    } else {
      rayStart = cameraMat.translation;
      // Get the projected window coordinate on the near plane
      // See http://www.songho.ca/opengl/gl_projectionmatrix.html
      // for details.
      rayDirection = projInv.transformVec3(new Vec3$1(sx, -sy, -1.0));
    }
    // And from projection space to camera local.
    // - We nuke the translation part since we're transforming a vector.
    rayDirection = cameraMat.rotateVec3(rayDirection).normalize();
    return new Ray(rayStart, rayDirection)
  }

  // //////////////////////////
  // GeomData

  /**
   * The createGeomDataFbo method.
   * @param {boolean} floatGeomBuffer - true if the GPU supports rendering
   * to floating point textures.
   */
  createGeomDataFbo(floatGeomBuffer) {
    const gl = this.__renderer.gl;
    this.__floatGeomBuffer = floatGeomBuffer;
    if (this.__floatGeomBuffer) {
      this.__geomDataBuffer = new GLTexture2D(gl, {
        type: 'FLOAT',
        format: 'RGBA',
        filter: 'NEAREST',
        width: this.__width <= 1 ? 1 : this.__width,
        height: this.__height <= 1 ? 1 : this.__height,
      });
    } else {
      this.__geomDataBuffer = new GLTexture2D(gl, {
        type: 'UNSIGNED_BYTE',
        format: 'RGBA',
        filter: 'NEAREST',
        width: this.__width <= 1 ? 1 : this.__width,
        height: this.__height <= 1 ? 1 : this.__height,
      });
    }
    this.__geomDataBufferFbo = new GLFbo(gl, this.__geomDataBuffer, true);
    this.__geomDataBufferFbo.setClearColor([0, 0, 0, 0]);
  }

  /**
   * The getGeomDataFbo method.
   * @return {GLFbo} - The return value.
   */
  getGeomDataFbo() {
    return this.__geomDataBufferFbo
  }

  /**
   * Renders the scene geometry to the viewports geom data buffer
   * in preparation for mouse picking.
   */
  renderGeomDataFbo() {
    if (this.__geomDataBufferFbo) {
      this.__geomDataBufferFbo.bindAndClear();

      const renderstate = {};
      this.__initRenderState(renderstate);
      this.__renderer.drawSceneGeomData(renderstate);
      this.__geomDataBufferInvalid = false;
    }
  }

  /**
   * The invalidateGeomDataBuffer method.
   */
  invalidateGeomDataBuffer() {
    this.__geomDataBufferInvalid = true;
  }

  /**
   * The getGeomDataAtPos method.
   * @param {Vec2} screenPos - The screen position.
   * @param {Ray} mouseRay - The mouseRay value.
   * @return {object} - The return value.
   */
  getGeomDataAtPos(screenPos, mouseRay) {
    if (this.__geomDataBufferFbo) {
      if (this.__geomDataBufferInvalid) {
        this.renderGeomDataFbo();
        this.__screenPos = null;
      }

      // Cache the intersection tests result so subsequent queries will return the same value.
      // Note: every new mouse event will generate a new mousePos value, so the cache
      // is only valid for a given event propagation, and for that exact mousePos value.
      if (screenPos === this.__screenPos) {
        return this.__intersectionData
      }
      this.__screenPos = screenPos;
      this.__intersectionData = null;

      const gl = this.__renderer.gl;
      gl.finish();

      this.__geomDataBufferFbo.bindForReading();

      // const logGeomData = ()=>{
      //     console.log("logGeomData :[" + this.__geomDataBuffer.width +","+ this.__geomDataBuffer.height + "]")
      //     const pixels = new Float32Array(this.__geomDataBuffer.width * 4);
      //     for(let i=0; i<this.__geomDataBuffer.height; i++){
      //       gl.readPixels(0, i, this.__geomDataBuffer.width, 1, gl.RGBA, gl.FLOAT, pixels);
      //         for(let j=0; j<this.__geomDataBuffer.width; j++){
      //             const geomData = pixels.subarray(j*4, (j+1)*4);
      //             if (geomData[0] != 0 || geomData[1] != 0){
      //                 console.log(j, i)
      //                 break; // Only log the left border pixels.
      //             }
      //         }
      //       // console.log(pixels);
      //     }
      // }
      // logGeomData();
      // console.log("getGeomDataAtPos:", screenPos.toString(), screenPos.x,this.__width)

      // Allocate a 1 pixel block and read grom the GeomData buffer.
      let passId;
      let geomData;
      if (gl.floatGeomBuffer) {
        geomData = new Float32Array(4);
        gl.readPixels(screenPos.x, this.__height - screenPos.y, 1, 1, gl.RGBA, gl.FLOAT, geomData);
        if (geomData[3] == 0) return undefined
        // Mask the pass id to be only the first 6 bits of the integer.
        passId = Math.round(geomData[0]) & (64 - 1);
      } else {
        geomData = new Uint8Array(4);
        gl.readPixels(screenPos.x, this.__height - screenPos.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, geomData);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        if (geomData[0] == 0 && geomData[1] == 0) return undefined
        passId = 0;
      }
      this.__geomDataBufferFbo.unbind();
      const pass = this.__renderer.getPass(passId);
      if (!pass) {
        console.warn('Geom data buffer returns invalid pass id:', passId);
        return
      }
      const geomItemAndDist = pass.getGeomItemAndDist(geomData);

      if (geomItemAndDist) {
        if (!mouseRay) mouseRay = this.calcRayFromScreenPos(screenPos);
        const intersectionPos = mouseRay.start.add(mouseRay.dir.scale(geomItemAndDist.dist));
        this.__intersectionData = {
          screenPos,
          mouseRay,
          intersectionPos,
          geomItem: geomItemAndDist.geomItem,
          dist: geomItemAndDist.dist,
          geomData,
        };
      }
      return this.__intersectionData
    }
  }

  /**
   * getGeomItemsInRect
   * Gathers all the geoms renders in a given rectangle of the viewport.
   * @param {Vec2} tl - The top left value of the rectangle.
   * @param {Vec2} br - The bottom right corner of the rectangle.
   * @return {Set} - The return value.
   */
  getGeomItemsInRect(tl, br) {
    // TODO: Use a Math.Rect instead
    if (this.__geomDataBufferFbo) {
      const gl = this.__renderer.gl;
      gl.finish();
      // Allocate a pixel block.
      const rectBottom = Math.round(this.__height - br.y);
      const rectLeft = Math.round(tl.x);
      const rectWidth = Math.round(br.x - tl.x);
      const rectHeight = Math.round(br.y - tl.y);
      const numPixels = rectWidth * rectHeight;

      this.__geomDataBufferFbo.bindForReading();

      let geomDatas;
      if (gl.floatGeomBuffer) {
        geomDatas = new Float32Array(4 * numPixels);
        gl.readPixels(rectLeft, rectBottom, rectWidth, rectHeight, gl.RGBA, gl.FLOAT, geomDatas);
      } else {
        geomDatas = new Uint8Array(4 * numPixels);
        gl.readPixels(rectLeft, rectBottom, rectWidth, rectHeight, gl.RGBA, gl.UNSIGNED_BYTE, geomDatas);
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      const geomItems = new Set();
      for (let i = 0; i < numPixels; i++) {
        let passId;
        const geomData = geomDatas.subarray(i * 4, (i + 1) * 4);
        if (gl.floatGeomBuffer) {
          passId = Math.round(geomData[0]);
        } else {
          passId = 0;
        }

        const geomItemAndDist = this.__renderer.getPass(passId).getGeomItemAndDist(geomData);
        if (geomItemAndDist) {
          geomItems.add(geomItemAndDist.geomItem);
        }
      }
      return geomItems
    }
  }

  // ///////////////////////////
  // Events

  /**
   * The __eventMousePos method calculates the event coordinates relative to the viewprot.
   * There could be multiple viewports connected to the current renderer.
   * @param {any} event - The event that occurs.
   * @return {Vec2} - Returns a new Vec2.
   * @private
   */
  __eventMousePos(event) {
    return new Vec2(event.rendererX - this.getPosX(), event.rendererY - this.getPosY())
  }

  /**
   * The __prepareEvent method.
   * @param {any} event - The event that occurs.
   * @private
   */
  __prepareEvent(event) {
    event.viewport = this;
    event.propagating = true;
    event.stopPropagation = () => {
      event.propagating = false;
    };
    event.setCapture = (item) => {
      this.capturedItem = item;
    };
    event.getCapture = (item) => {
      return this.capturedItem
    };
    event.releaseCapture = () => {
      this.capturedItem = null;
      // TODO: This should be a request, wbihch is fulfilled next time
      // a frame is dranw.
      this.renderGeomDataFbo();
    };

    if (event instanceof MouseEvent) {
      const mousePos = this.__eventMousePos(event);
      event.mousePos = mousePos;
      event.mouseRay = this.calcRayFromScreenPos(mousePos);

      const intersectionData = this.getGeomDataAtPos(event.mousePos, event.mouseRay);
      if (intersectionData != undefined) {
        // console.log("onMouseDown on Geom"); // + " Material:" + geomItem.getParameter('Material').getValue().getName());
        // console.log(intersectionData.geomItem.getPath()); // + " Material:" + geomItem.getParameter('Material').getValue().getName());
        event.intersectionData = intersectionData;
      }
    }
  }

  /**
   * The setCapture method.
   * @param {any} target - The target value.
   * @private
   */
  setCapture(target) {
    this.capturedItem = target;
  }

  /**
   * The getCapture method.
   * @return {any} - The return value.
   */
  getCapture() {
    return this.capturedItem
  }

  /**
   * The releaseCapture method.
   */
  releaseCapture() {
    this.capturedItem = null;
    // TODO: This should be a request, wbihch is fulfilled next time
    // a frame is dranw.
    this.renderGeomDataFbo();
  }

  /**
   * Causes an event to occur when a user presses a mouse button over an element.
   * @param {any} event - The event that occurs.
   * @return {any} - The return value.
   */
  onMouseDown(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      this.capturedItem.onMouseDown(event);
      return
    }

    if (event.intersectionData != undefined) {
      event.intersectionData.geomItem.onMouseDown(event);
      if (!event.propagating || this.capturedItem) return

      this.emit('mouseDownOnGeom', event);
      if (!event.propagating) return
    }

    const downTime = Date.now();
    if (downTime - this.__prevDownTime < this.__doubleClickTimeMSParam.getValue()) {
      if (this.__cameraManipulator) {
        this.__cameraManipulator.onDoubleClick(event);
        if (!event.propagating) return
      }

      this.emit('mouseDoubleClicked', event);
    } else {
      this.__prevDownTime = downTime;
      if (this.__cameraManipulator) {
        this.__cameraManipulator.onMouseDown(event);
        if (!event.propagating) return
      }

      this.emit('mouseDown', event);
    }

    return false
  }

  /**
   * Causes an event to occur when the mouse pointer is moving while over an element.
   * @param {MouseEvent} event - The event that occurs.
   */
  onMouseMove(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      this.capturedItem.onMouseMove(event);
      return
    }

    if (event.intersectionData != undefined) {
      if (event.intersectionData.geomItem != this.mouseOverItem) {
        if (this.mouseOverItem) {
          const leaveEvent = { ...event, geomItem: this.mouseOverItem };
          this.emit('mouseLeaveGeom', leaveEvent);
          if (leaveEvent.propagating) this.mouseOverItem.onMouseLeave(leaveEvent);
        }
        this.mouseOverItem = event.intersectionData.geomItem;
        this.emit('mouseOverGeom', event);
        if (event.propagating) this.mouseOverItem.onMouseEnter(event);
      }

      event.intersectionData.geomItem.onMouseMove(event);
      if (!event.propagating || this.capturedItem) return
    } else if (this.mouseOverItem) {
      const leaveEvent = { ...event, geomItem: this.mouseOverItem };
      this.emit('mouseLeaveGeom', leaveEvent);
      if (leaveEvent.propagating) this.mouseOverItem.onMouseLeave(leaveEvent);
      this.mouseOverItem = null;
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onMouseMove(event);
      if (!event.propagating) return
    }
    this.emit('mouseMove', event);
  }

  /**
   * Causes an event to occur when a user releases a mouse button over a element.
   * @param {MouseEvent} event - The event that occurs.
   */
  onMouseUp(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      this.capturedItem.onMouseUp(event);
      return
    }

    if (event.intersectionData != undefined) {
      event.intersectionData.geomItem.onMouseUp(event);
      if (!event.propagating) return
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onMouseUp(event);
      if (!event.propagating) return
    }

    this.emit('mouseUp', event);
  }

  /**
   * Causes an event to occur when the mouse pointer is moved out of an element.
   * @param {MouseEvent} event - The event that occurs.
   */
  onMouseLeave(event) {
    this.__prepareEvent(event);
    this.emit('mouseLeave', event);
  }

  /**
   * Causes an event to occurs when the user presses a key on the keyboard.
   * @param {string} key - The key the user presses.
   * @param {KeyboardEvent} event - The event that occurs.
   */
  onKeyPressed(key, event) {
    this.__prepareEvent(event);
    if (this.__cameraManipulator) {
      if (this.__cameraManipulator.onKeyPressed(key, event)) return
    }
    this.emit('keyPressed', event);
  }

  /**
   * Causes an event to occur when the user is pressing a key on the keyboard.
   * @param {string} key - The key the user is pressing.
   * @param {KeyboardEvent} event - The event that occurs.
   */
  onKeyDown(key, event) {
    this.__prepareEvent(event);
    if (this.__cameraManipulator) {
      if (this.__cameraManipulator.onKeyDown(key, event)) return
    }
    this.emit('keyDown', event);
  }

  /**
   * Causes an event to occur  when the user releases a key on the keyboard.
   * @param {string} key - The key the user releases
   * @param {KeyboardEvent} event - The event that occurs.
   */
  onKeyUp(key, event) {
    this.__prepareEvent(event);
    if (this.__cameraManipulator) {
      if (this.__cameraManipulator.onKeyUp(key, event)) return
    }
    this.emit('keyUp', event);
  }

  /**
   * Causes an event to occur when the mouse wheel is rolled up or down over an element.
   * @param {MouoseWheelEvent} event - The event that occurs.
   */
  onWheel(event) {
    this.__prepareEvent(event);
    if (event.intersectionData != undefined) {
      event.intersectionData.geomItem.onWheel(event);
      if (!event.propagating) return
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onWheel(event);
      return
    }
    this.emit('mouseWheel', event);
  }

  // Touch events

  /**
   * The __eventTouchPos method.
   * @param {any} touch - The touch value.
   * @return {Vec2} - The return value.
   * @private
   */
  __eventTouchPos(touch) {
    return new Vec2(touch.rendererX - this.getPosX(), touch.rendererY - this.getPosY())
  }

  /**
   * Causes an event to occur when the user touches an element on a touch screen.
   * @param {TouchEvent} event - The event that occurs.
   */
  onTouchStart(event) {
    this.__prepareEvent(event);

    if (event.touches.length == 1) {
      const touch = event.touches[0];
      const touchPos = this.__eventTouchPos(touch);
      event.touchPos = touchPos;
      event.touchRay = this.calcRayFromScreenPos(touchPos);

      const intersectionData = this.getGeomDataAtPos(touchPos, event.touchRay);
      if (intersectionData != undefined) {
        // console.log("onMouseDown on Geom"); // + " Material:" + geomItem.getParameter('Material').getValue().getName());
        // console.log(intersectionData.geomItem.getPath()); // + " Material:" + geomItem.getParameter('Material').getValue().getName());
        event.intersectionData = intersectionData;
        intersectionData.geomItem.onMouseDown(event, intersectionData);
        if (!event.propagating) return
        if (this.capturedItem) return

        this.emit('mouseDownOnGeom', event);
        if (!event.propagating) return
      }

      const downTime = Date.now();
      if (downTime - this.__prevDownTime < this.__doubleClickTimeMSParam.getValue()) {
        if (this.__cameraManipulator) {
          this.__cameraManipulator.onDoubleTap(event);
          if (!event.propagating) return
        }
        this.emit('doubleTapped', event);
        return
      } else {
        this.__prevDownTime = downTime;
      }
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onTouchStart(event);
      return
    }
    this.emit('touchStart', event);
  }

  /**
   * The event that occurs when the user moves his/her finger across a touch screen.
   * @param {TouchEvent} event - The event that occurs.
   */
  onTouchMove(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      event.touchPos = [];
      event.touchRay = [];
      for (let index = 0; index < event.touches.length; index++) {
        const touch = event.touches[index];
        const touchPos = this.__eventTouchPos(touch);
        event.touchPos[index] = touchPos;
        event.touchRay[index] = this.calcRayFromScreenPos(touchPos);
      }
      event.mousePos = event.touchPos[0];
      event.mouseRay = event.touchRay[0];
      this.capturedItem.onMouseMove(event);
      return
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onTouchMove(event);
      return
    }
    this.emit('touchMove', event);
  }

  /**
   * Causes an event to occur when the user removes his/her finger from an element.
   * @param {TouchEvent} event - The event that occurs.
   */
  onTouchEnd(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      this.capturedItem.onMouseUp(event);
      return
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onTouchEnd(event);
      return
    }
    this.emit('touchEnd', event);
  }

  /**
   * Causes an event to occur when the touch event gets interrupted.
   * @param {TouchEvent} event - The event that occurs.
   */
  onTouchCancel(event) {
    this.__prepareEvent(event);

    if (this.capturedItem) {
      this.capturedItem.onTouchCancel(event);
      return
    }

    if (this.__cameraManipulator) {
      this.__cameraManipulator.onTouchCancel(event);
      return
    }
    this.emit('touchCancel', event);
  }

  // //////////////////////////
  // Rendering

  /**
   * The __initRenderState method.
   * @param {any} renderstate - The renderstate value.
   * @private
   */
  __initRenderState(renderstate) {
    // console.log(this.__viewMat.toString())
    renderstate.viewXfo = this.__cameraXfo;
    renderstate.viewScale = 1.0;
    renderstate.region = this.region;
    renderstate.cameraMatrix = this.__cameraMat;
    renderstate.viewports = [
      {
        region: this.region,
        viewMatrix: this.__viewMat,
        projectionMatrix: this.__projectionMatrix,
        viewportFrustumSize: this.__frustumDim,
        isOrthographic: this.__camera.getIsOrthographic(),
        fovY: this.__camera.getFov(),
      },
    ];
  }

  /**
   * The draw method.
   */
  draw() {
    const gl = this.__renderer.gl;

    // Make sure the default fbo is bound
    // Note: Sometimes an Fbo is left bound
    // from anohter op(like resizing, populating etc..)
    // We need to unbind here to ensure rendering is to the
    // right target.
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    gl.viewport(...this.region);

    if (this.__backgroundColor) gl.clearColor(...this.__backgroundColor.asArray());
    gl.colorMask(true, true, true, true);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const renderstate = {};
    this.__initRenderState(renderstate);
    this.__renderer.drawScene(renderstate);

    // Turn this on to debug the geom data buffer.
    // {
    //     gl.screenQuad.bindShader(renderstate);
    //     gl.screenQuad.draw(renderstate, this.__geomDataBuffer);
    // }
  }
}

/** Class representing a VR head.
 * @private
 */
class VRHead {
  /**
   * Create a VR head.
   * @param {any} vrviewport - The VR viewport.
   * @param {any} stageTreeItem - The stageTreeItem value.
   */
  constructor(vrviewport, stageTreeItem) {
    this.__vrviewport = vrviewport;
    this.__treeItem = new TreeItem('VRHead');
    stageTreeItem.addChild(this.__treeItem);

    this.__mat4 = new Mat4();
    this.__localXfo = new Xfo();
  }

  /**
   * The update method.
   * @param {any} pose - The pose value.
   */
  update(pose) {
    // Old
    // this.__mat4.setDataArray(pose.poseModelMatrix);

    // New
    this.__mat4.setDataArray(pose.transform.matrix);

    this.__localXfo.fromMat4(this.__mat4);

    // const pos = pose.transform.position;
    // this.__localXfo.tr.set(pos.x, pos.y,pos.z);
    // const ori = pose.transform.orientation;
    // this.__localXfo.ori.set(ori.x, ori.y, ori.z, ori.x);

    this.__treeItem.getParameter('LocalXfo').setValue(this.__localXfo);
  }

  /**
   * The getTreeItem method.
   * @return {any} - The return value.
   */
  getTreeItem() {
    return this.__treeItem
  }

  /**
   * The getXfo method.
   * @return {Xfo} - The return value.
   */
  getXfo() {
    return this.__localXfo
  }
}

/** Class representing a VR controller. */
class VRController {
  /**
   * Create a VR controller.
   * @param {any} vrviewport - The Vr viewport.
   * @param {any} inputSource - The input source.
   * @param {any} id - The id value.
   */
  constructor(vrviewport, inputSource, id) {
    this.__vrviewport = vrviewport;
    this.__inputSource = inputSource;
    this.__id = id;
    this.__isDaydramController = SystemDesc.isMobileDevice;

    this.__pressedButtons = [];

    // /////////////////////////////////
    // Xfo

    this.__mat4 = new Mat4();
    this.__xfo = new Xfo();

    // this.setVisible(true);

    this.__treeItem = new TreeItem('VRController:' + inputSource.handedness + id);
    // Controller coordinate system
    // X = Horizontal.
    // Y = Up.
    // Z = Towards handle base.

    if (!this.__isDaydramController) {
      // A Vive or Occulus Touch Controller
      this.__tip = new TreeItem('Tip');
      // Note: the tip of the controller need to be off
      // the end of the controller. getGeomItemAtTip
      // now searches a grid in that area and so we need to
      // ensure that the grid does not touch the controller,
      // else it will return the controller geom from
      // the getGeomItemAtTip function
      const tipXfo = new Xfo();
      tipXfo.tr.set(0.0, -0.05, -0.13);
      // Flip the tip around so +z is forwards.
      // tipXfo.ori.setFromAxisAndAngle(new Vec3(0, 1, 0), Math.PI)
      this.__tip.getParameter('LocalXfo').setValue(tipXfo);
      this.__treeItem.addChild(this.__tip, false);
      vrviewport.getTreeItem().addChild(this.__treeItem);

      this.__activeVolumeSize = 0.04;

      vrviewport.loadHMDResources().then((asset) => {
        asset.on('loaded', () => {
          let srcControllerTree;
          if (id == 0) srcControllerTree = asset.getChildByName('LeftController');
          else if (id == 1) srcControllerTree = asset.getChildByName('RightController');
          if (!srcControllerTree) srcControllerTree = asset.getChildByName('Controller');
          const controllerTree = srcControllerTree.clone();

          controllerTree.getParameter('LocalXfo').setValue(
            new Xfo(
              new Vec3$1(0, -0.035, -0.085),
              new Quat({ setFromAxisAndAngle: [new Vec3$1(0, 1, 0), Math.PI] }),
              new Vec3$1(0.001, 0.001, 0.001) // VRAsset units are in mm.
            )
          );
          this.__treeItem.addChild(controllerTree, false);
        });
      });
    }
  }

  /**
   * The getHandedness method.
   * @return {any} - The return value.
   */
  getHandedness() {
    return this.__inputSource.handedness
  }

  /**
   * The getId method.
   * @return {any} - The return value.
   */
  getId() {
    return this.__id
  }

  /**
   * The getTreeItem method.
   * @return {any} - The return value.
   */
  getTreeItem() {
    return this.__treeItem
  }

  /**
   * The getTipItem method.
   * @return {any} - The return value.
   */
  getTipItem() {
    return this.__tip
  }

  /**
   * The getTipXfo method.
   * @return {any} - The return value.
   */
  getTipXfo() {
    return this.__tip.getParameter('GlobalXfo').getValue()
  }

  /**
   * The getTouchPadValue method.
   * @return {any} - The return value.
   */
  getTouchPadValue() {
    return this.__touchpadValue
  }

  /**
   * The isButtonPressed method.
   * @return {boolean} - The return value.
   */
  isButtonPressed() {
    return this.__buttonPressed
  }

  /**
   * The getControllerStageLocalXfo method.
   * @return {any} - The return value.
   */
  getControllerStageLocalXfo() {
    return this.__xfo
  }

  /**
   * The getControllerTipStageLocalXfo method.
   * @return {any} - The return value.
   */
  getControllerTipStageLocalXfo() {
    return this.__xfo.multiply(this.__tip.getParameter('LocalXfo').getValue())
  }

  // ////////////////////////////////

  /**
   * The updatePose method.
   * @param {any} refSpace - The refSpace value.
   * @param {any} xrFrame - The xrFrame value.
   * @param {any} inputSource - The inputSource value.
   */
  updatePose(refSpace, xrFrame, inputSource) {
    const inputPose = xrFrame.getPose(inputSource.gripSpace, refSpace);

    // We may not get a inputPose back in cases where the input source has lost
    // tracking or does not know where it is relative to the given frame
    // of reference.
    if (!inputPose || !inputPose.transform) {
      return
    }

    this.__mat4.setDataArray(inputPose.transform.matrix);
    this.__xfo.fromMat4(this.__mat4);

    // const pos = inputPose.transform.position;
    // this.__xfo.tr.set(pos.x, pos.y,pos.z);
    // const ori = inputPose.transform.orientation;
    // this.__xfo.ori.set(ori.x, ori.y, ori.z, ori.x);
    // //////////////////////////////

    this.__treeItem.getParameter('LocalXfo').setValue(this.__xfo);

    // Reset the geom at tip so it will be recomuted if necessary
    this.__geomAtTip = undefined;
    this.__hitTested = false;

    // /////////////////////////////////
    // Simulate Mouse Events.
    // const intersectionData = this.getGeomItemAtTip()
    // if (intersectionData != undefined) {
    //   if (intersectionData.geomItem != this.mouseOverItem) {
    //     if (this.mouseOverItem) {
    //       const event = {
    //         viewport: this.__vrviewport,
    //         geomItem: this.mouseOverItem,
    //       }
    //       this.mouseOverItem.onMouseLeave(event)
    //     }
    //     this.mouseOverItem = intersectionData.geomItem
    //     const event = {
    //       viewport: this.__vrviewport,
    //       geomItem: intersectionData.geomItem,
    //       intersectionData,
    //     }
    //     this.mouseOverItem.onMouseEnter(event)
    //   }

    //   const event = {
    //     viewport: this.__vrviewport,
    //     geomItem: intersectionData.geomItem,
    //     intersectionData,
    //   }
    //   intersectionData.geomItem.onMouseMove(event)
    // } else if (this.mouseOverItem) {
    //   const event = {
    //     viewport: this.__vrviewport,
    //     geomItem: this.mouseOverItem,
    //     intersectionData,
    //   }
    //   this.mouseOverItem.onMouseLeave(event)
    //   this.mouseOverItem = null
    // }
  }

  // ////////////////////////////////

  /**
   * The getGeomItemAtTip method.
   * @return {any} - The return value.
   */
  getGeomItemAtTip() {
    if (this.__hitTested) return this.__intersectionData
    this.__hitTested = true;

    const renderer = this.__vrviewport.getRenderer();
    const xfo = this.__tip.getParameter('GlobalXfo').getValue();
    const vol = this.__activeVolumeSize;
    this.__intersectionData = renderer.raycastWithXfo(xfo, vol, vol);
    return this.__intersectionData
  }
}

/** Class representing a VR viewport.
 * @extends GLBaseViewport
 */
class VRViewport extends GLBaseViewport {
  /**
   * Create a VR viewport.
   * @param {any} renderer - The renderer value.
   */
  constructor(renderer) {
    super(renderer);
    this.getParameter('DoubleClickTimeMS').setValue(300);

    // ////////////////////////////////////////////
    // Viewport params
    this.__projectionMatriciesUpdated = false;

    // These values are in meters.
    this.__far = 1024.0;
    this.__near = 0.1;
    // ////////////////////////////////////////////
    // Tree

    this.__stageTreeItem = new TreeItem('VRStage');
    this.__stageTreeItem.setSelectable(false);
    this.__stageTreeItem.setVisible(false);
    this.__renderer.addTreeItem(this.__stageTreeItem);

    this.__vrhead = new VRHead(this.__renderer.gl, this.__stageTreeItem);

    this.__vrControllersMap = {};
    this.__vrControllers = [];

    // ////////////////////////////////////////////
    // Xfos
    const xfo = new Xfo();
    // Convert Y-Up to Z-Up.
    xfo.ori.setFromAxisAndAngle(new Vec3$1(1, 0, 0), Math.PI * 0.5);
    this.setXfo(xfo); // Reset the stage Xfo.

    this.__leftViewMatrix = new Mat4();
    this.__leftProjectionMatrix = new Mat4();
    this.__rightViewMatrix = new Mat4();
    this.__rightProjectionMatrix = new Mat4();
  }

  /**
   * The getVRDisplay method.
   * @return {any} - The return value.
   */
  getVRDisplay() {
    return this.__vrDisplay
  }

  /**
   * The getAsset method.
   * @return {any} - The return value.
   */
  getAsset() {
    return this.__vrAsset
  }

  /**
   * The getTreeItem method.
   * @return {any} - The return value.
   */
  getTreeItem() {
    return this.__stageTreeItem
  }

  /**
   * The getVRHead method.
   * @return {any} - The return value.
   */
  getVRHead() {
    return this.__vrhead
  }

  /**
   * The getXfo method.
   * @return {Xfo} - The return value.
   */
  getXfo() {
    return this.__stageXfo
  }

  /**
   * The setXfo method.
   * @param {Xfo} xfo - The xfo value.
   */
  setXfo(xfo) {
    this.__stageXfo = xfo;
    this.__stageTreeItem.getParameter('GlobalXfo').setValue(xfo);
    this.__stageMatrix = xfo.inverse().toMat4();
    // this.__stageMatrix.multiplyInPlace(this.__sittingToStandingMatrix);
    this.__stageScale = xfo.sc.x;
  }

  /**
   * The getControllers method.
   * @return {any} - The return value.
   */
  getControllers() {
    return this.__vrControllers
  }

  // //////////////////////////
  // Presenting

  /**
   * The canPresent method.
   * @return {any} - The return value.
   */
  canPresent() {
    return this.__canPresent
  }

  /**
   * The isPresenting method.
   * @return {boolean} - The return value.
   */
  isPresenting() {
    return this.__session
  }

  /**
   * The __startSession method.
   * @private
   */
  __startSession() {
    const onAnimationFrame = (t, frame) => {
      if (this.__session) {
        this.__session.requestAnimationFrame(onAnimationFrame);
        this.draw(frame);
        // console.log(frame)
        // let pose = frame.getViewerPose(this.__refSpace);
        // if(pose) {
        //     console.log(pose)
        //     this.__session.end();
        // }
        // else {
        //     this.__session.requestAnimationFrame(onAnimationFrame);
        // }
      }
    };
    this.__session.requestAnimationFrame(onAnimationFrame);
  }

  /**
   * The loadHMDResources method.
   * @return {any} - The return value.
   */
  loadHMDResources() {
    // If the HMD has changed, reset it.
    const hmd = localStorage.getItem('hmd');
    if (this.__hmd != hmd) {
      this.__hmdAssetPromise = undefined;
    }

    if (this.__hmdAssetPromise) return this.__hmdAssetPromise

    this.__hmd = hmd;
    this.__hmdAssetPromise = new Promise((resolve, reject) => {
      // ////////////////////////////////////////////
      // Resources

      // Note: when the VRViewport is setup
      const sceneSet = (event) => {
        const scene = event.scene;

        let assetPath;
        switch (hmd) {
          case 'Vive':
            assetPath = 'ZeaEngine/Vive.vla';
            break
          case 'Oculus':
            assetPath = 'ZeaEngine/Oculus.vla';
            break
          default:
            assetPath = 'ZeaEngine/Oculus.vla';
            break
        }

        const hmdAssetId = resourceLoader.resolveFilePathToId(assetPath);
        if (hmdAssetId && !SystemDesc.isMobileDevice) {
          this.__vrAsset = resourceLoader.loadCommonAssetResource(hmdAssetId);
          this.__vrAsset.on('loaded', () => {
            const materialLibrary = this.__vrAsset.getMaterialLibrary();
            const materialNames = materialLibrary.getMaterialNames();
            for (const name of materialNames) {
              const material = materialLibrary.getMaterial(name, false);
              if (material) {
                material.visibleInGeomDataBuffer = false;
                material.setShaderName('SimpleSurfaceShader');
              }
            }
            resolve(this.__vrAsset);
          });
        } else reject();
      };
      this.__renderer.on('sceneSet', sceneSet);
    });
    return this.__hmdAssetPromise
  }

  /**
   * The startPresenting method.
   */
  startPresenting() {
    return new Promise((resolve, reject) => {
      // https://github.com/immersive-web/webxr/blob/master/explainer.md

      const gl = this.__renderer.gl;

      const __startPresenting = () => {
        navigator.xr
          .requestSession('immersive-vr', {
            requiredFeatures: ['local-floor'],
            optionalFeatures: ['bounded-floor'],
          })
          .then((session) => {
            this.__renderer.__xrViewportPresenting = true;

            let mirrorCanvas;
            if (!SystemDesc.isMobileDevice) {
              // Add an output canvas that will allow XR to also send a view
              // back the monitor.
              mirrorCanvas = document.createElement('canvas');
              mirrorCanvas.style.position = 'relative';
              mirrorCanvas.style.left = '0px';
              mirrorCanvas.style.top = '0px';
              mirrorCanvas.style.width = '100%';
              mirrorCanvas.style.height = '100%';

              this.__renderer.getDiv().replaceChild(mirrorCanvas, this.__renderer.getGLCanvas());

              session.on('end', (event) => {
                this.__renderer.getDiv().replaceChild(this.__renderer.getGLCanvas(), mirrorCanvas);
              });
            }

            session.on('end', (event) => {
              this.__stageTreeItem.setVisible(false);
              this.__session = null;
              this.emit('presentingChanged', { state: false });
            });

            const onSelectStart = (ev) => {
              const controller = this.__vrControllersMap[ev.inputSource.handedness];
              if (controller) {
                const downTime = Date.now();
                console.log('controller:', ev.inputSource.handedness, ' down', downTime - controller.__prevDownTime);
                if (downTime - controller.__prevDownTime < this.__doubleClickTimeMSParam.getValue()) {
                  this.emit(
                    'controllerDoubleClicked',
                    {
                      button: 1,
                      controller,
                      vleStopPropagation: false,
                      vrviewport: this,
                    },
                    this
                  );
                } else {
                  controller.__prevDownTime = downTime;

                  this.emit(
                    'controllerButtonDown',
                    {
                      button: 1,
                      controller,
                      vleStopPropagation: false,
                      vrviewport: this,
                    },
                    this
                  );
                }
              }
            };
            const onSelectEnd = (ev) => {
              const controller = this.__vrControllersMap[ev.inputSource.handedness];
              if (controller) {
                console.log('controller:', ev.inputSource.handedness, ' up');
                this.emit(
                  'controllerButtonUp',
                  {
                    button: 1,
                    controller,
                    vleStopPropagation: false,
                    vrviewport: this,
                  },
                  this
                );
              }
            };
            session.on('selectstart', onSelectStart);
            session.on('selectend', onSelectEnd);

            this.__session = session;

            // ////////////////////////////
            // Old code
            // this.__session.baseLayer = new XRWebGLLayer(session, gl);

            // New code
            session.updateRenderState({
              baseLayer: new XRWebGLLayer(session, gl, {
                compositionDisabled: session.mode == 'inline',
              }),
              outputContext: mirrorCanvas ? mirrorCanvas.getContext('xrpresent') : null,
            });
            // ////////////////////////////

            // Get a stage frame of reference, which will align the user's physical
            // floor with Y=0 and can provide boundaries that indicate where the
            // user can safely walk. If the system can't natively provide stage
            // coordinates (for example, with a 3DoF device) then it will return an
            // emulated stage, where the view is translated up by a static height so
            // that the scene still renders in approximately the right place.

            // If a bounded reference space isn't supported, fall back to a
            // stationary/floor-level reference space. This still provides a
            // floor-relative space and will always be supported for
            // immersive sessions. It will not, however, provide boundaries
            // and generally expects the user to stand in one place.
            // If the device doesn't have a way of determining the floor
            // level (for example, with a 3DoF device) then it will return
            // an emulated floor-level space, where the view is translated
            // up by a static height so that the scene still renders in
            // approximately the right place.
            //   console.log('Falling back to floor-level reference space');
            session
              .requestReferenceSpace(SystemDesc.isMobileDevice ? 'local' : 'local-floor')
              .catch((e) => {
                // if (!session.mode.startsWith('immersive')) {
                // If we're in inline mode, our underlying platform may not support
                // the stationary reference space, but an identity space is guaranteed.
                console.log('Falling back to identity reference space');
                return session.requestReferenceSpace('viewer').then((refSpace) => {
                  // If we use an identity reference space we need to scoot the
                  // origin down a bit to put the camera at approximately the
                  // right level. (Here we're moving it 1.6 meters, which should
                  // *very* roughly align us with the eye height of an "average"
                  // adult human.)
                  return refSpace.getOffsetReferenceSpace(new XRRigidTransform({ y: -1.6 }))
                })
                // } else {
                //   throw e
                // }
              })
              .then((refSpace) => {
                this.__refSpace = refSpace;
                this.__stageTreeItem.setVisible(true);
                this.emit('presentingChanged', { state: true });
                this.__startSession();

                resolve();
              })
              .catch((e) => {
                console.warn(e.message);
                reject('Unable to start XR Session:' + e.message);
              });
          })
          .catch((e) => {
            console.warn(e.message);
          });
      };

      if (SystemDesc.isMobileDevice) {
        __startPresenting();
      } else {
        // Note: we should not need to load the resources here
        // They could be loaded only once the controllers are
        // being created. However, I can't see the controllers if
        // the loading is defered
        this.loadHMDResources().then(__startPresenting);
      }
    })
  }

  /**
   * The stopPresenting method.
   */
  stopPresenting() {
    if (!this.__session) return

    this.__session.end();
  }

  /**
   * The togglePresenting method.
   */
  togglePresenting() {
    if (this.__session) this.stopPresenting();
    else this.startPresenting();
  }

  /**
   * The getHMDCanvasSize method.
   * @return {any} - The return value.
   */
  getHMDCanvasSize() {
    return this.__hmdCanvasSize
  }

  // //////////////////////////
  // Controllers

  /**
   * The __createController method.
   * @param {any} id - The id value.
   * @param {any} inputSource - The inputSource value.
   * @return {any} - The return value.
   * @private
   */
  __createController(id, inputSource) {
    console.log('creating controller:', inputSource.handedness);
    const controller = new VRController(this, inputSource, id);
    this.__vrControllersMap[inputSource.handedness] = controller;
    this.__vrControllers[id] = controller;
    this.emit('controllerAdded', { controller });
    return vrController
  }

  /**
   * The updateControllers method.
   * @param {any} xrFrame - The xrFrame value.
   */
  updateControllers(xrFrame) {
    const inputSources = this.__session.inputSources;
    for (let i = 0; i < inputSources.length; i++) {
      const inputSource = inputSources[i];

      // Note: This is to avoid a bug/feature in WebXR where initially the
      // controllers have no handedness specified, then suddenly
      // get handedness. We need the handedness before we can setup the controller.
      if (inputSource.handedness == '' || inputSource.handedness == 'none') return

      if (!this.__vrControllers[i]) {
        this.__createController(i, inputSource);
      }
      this.__vrControllers[i].updatePose(this.__refSpace, xrFrame, inputSource);
    }
  }

  /**
   * The draw method.
   * @param {any} xrFrame - The xrFrame value.
   */
  draw(xrFrame) {
    const session = xrFrame.session;
    // Assumed to be a XRWebGLLayer for now.

    // Old
    // const layer = session.baseLayer;
    // New
    const layer = session.renderState.baseLayer;

    const pose = xrFrame.getViewerPose(this.__refSpace);
    const views = pose.views;

    if (!this.__projectionMatriciesUpdated) {
      this.__projectionMatrices = [];
      this.__viewMatrices = [];
      this.__cameraMatrices = [];
      this.__region = [0, 0, 0, 0];
      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const projMat = new Mat4();
        projMat.setDataArray(view.projectionMatrix);
        this.__projectionMatrices[i] = projMat;
        this.__viewMatrices[i] = new Mat4();
        this.__cameraMatrices[i] = new Mat4();

        const vp = layer.getViewport(view);
        this.__region[2] = Math.max(this.__region[2], vp.x + vp.width);
        this.__region[3] = Math.max(this.__region[3], vp.y + vp.height);
      }

      this.__renderer.resizeFbos(this.__region[2], this.__region[3]);
      this.__projectionMatriciesUpdated = true;
    }

    const gl = this.__renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);

    if (this.__backgroundColor) gl.clearColor(...this.__backgroundColor.asArray());
    gl.colorMask(true, true, true, true);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const renderstate = {
      boundRendertarget: layer.framebuffer,
      region: this.__region,
      viewports: [],
    };
    // renderstate.boundRendertarget.vrfbo = true;

    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      this.__viewMatrices[i].setDataArray(view.transform.inverse.matrix);
      this.__viewMatrices[i].multiplyInPlace(this.__stageMatrix);
      // this.__cameraMatrices[i].setDataArray(view.transform.matrix);

      const vp = layer.getViewport(view);
      renderstate.viewports.push({
        viewMatrix: this.__viewMatrices[i],
        projectionMatrix: this.__projectionMatrices[i],
        region: [vp.x, vp.y, vp.width, vp.height],
      });
    }

    this.__vrhead.update(pose);

    this.updateControllers(xrFrame);

    renderstate.viewXfo = this.__vrhead.getTreeItem().getParameter('GlobalXfo').getValue();
    renderstate.viewScale = 1.0 / this.__stageScale;
    renderstate.cameraMatrix = renderstate.viewXfo.toMat4();
    renderstate.region = this.__region;
    renderstate.vrPresenting = true; // Some rendering is ajusted slightly in VR. e.g. Billboards

    this.__renderer.drawScene(renderstate);

    if (this.capturedElement) {
      const event = {
        viewport: this,
      };
      this.capturedElement.onMouseMove(event);
    }

    // ///////////////////////
    // Emit a signal for the shared session.
    const data = {
      interfaceType: 'VR',
      hmd: this.__hmd,
      viewXfo: renderstate.viewXfo,
      controllers: this.__vrControllers,
      vrviewport: this,
    };
    this.emit('viewChanged', data);
  }

  /**
   * The setCapture method.
   * @param {any} target - The target value.
   * @private
   */
  setCapture(target) {
    this.capturedElement = target;
  }

  /**
   * The getCapture method.
   * @return {any} - The return value.
   */
  getCapture() {
    return this.capturedElement
  }

  /**
   * The releaseCapture method.
   */
  releaseCapture() {
    this.capturedElement = null;
    // TODO: This should be a request, wbihch is fulfilled next time
    // a frame is dranw.
    this.renderGeomDataFbo();
  }
}

let activeGLRenderer = undefined;
let mouseIsDown = false;
let mouseLeft = false;

const registeredPasses = {};

/** Class representing a GL base renderer.
 * @extends ParameterOwner
 */
class GLBaseRenderer extends ParameterOwner {
  /**
   * Create a GL base renderer.
   * @param {any} canvasDiv - The canvasDiv value.
   * @param {any} options - The options value.
   */
  constructor(canvasDiv, options = {}) {
    super();
    if (!SystemDesc.gpuDesc) {
      console.warn('Unable to create renderer');
      return
    }

    this.__shaders = {};
    this.__passes = {};
    this.__passCallbacks = [];

    this.__childItemAdded = this.__childItemAdded.bind(this);
    this.__childItemRemoved = this.__childItemRemoved.bind(this);

    this.__viewports = [];
    this.__activeViewport = undefined;
    this.__continuousDrawing = false;
    this.__redrawRequested = false;
    this.__isMobile = SystemDesc.isMobileDevice;

    this.__drawSuspensionLevel = 1;
    this.__shaderDirectives = {};
    this.__preproc = {};

    this.__xrViewportPresenting = false;

    // Function Bindings.
    this.renderGeomDataFbos = this.renderGeomDataFbos.bind(this);
    this.requestRedraw = this.requestRedraw.bind(this);

    this.setupWebGL(canvasDiv, options.webglOptions ? options.webglOptions : {});
    this.bindEventHandlers();

    for (const passtype in registeredPasses) {
      for (const cls of registeredPasses[passtype]) {
        this.addPass(new cls(), passtype, false);
      }
    }

    this.addViewport('main');

    // ////////////////////////////////////////////
    // WebXR
    this.__supportXR = options.supportXR !== undefined ? options.supportXR : true;
    this.__xrViewport = undefined;
    this.__xrViewportPromise = new Promise((resolve, reject) => {
      if (this.__supportXR) {
        // if(!navigator.xr && window.WebVRPolyfill != undefined) {
        //     this.__vrpolyfill = new WebVRPolyfill();
        // }
        if (navigator.xr) {
          const setupXRViewport = () => {
            // Note: could cause a context loss on machines with
            // multi-gpus (integrated Intel).
            // This is because the may force the context to switch
            // to the discrete GPU.
            // TODO: Provide a system to re-load the GPU data.
            // this.__gl.setCompatibleXRDevice(device);
            this.__gl.makeXRCompatible().then(() => {
              this.__xrViewport = this.__setupXRViewport();
              this.emit('xrViewportSetup', {
                xrViewport: this.__xrViewport,
              });
              resolve(this.__xrViewport);
            });
          };
          if (navigator.xr.supportsSessionMode) {
            // Old
            navigator.xr
              .supportsSessionMode('immersive-vr')
              .then(setupXRViewport)
              .catch((reason) => {
                console.warn('Unable to setup XR:' + reason);
              });
          } else {
            // New
            navigator.xr
              .isSessionSupported('immersive-vr')
              .then((isSupported) => {
                if (isSupported) {
                  setupXRViewport();
                }
              })
              .catch((reason) => {
                console.warn('Unable to setup XR:' + reason);
              });
          }

          // TODO:
          // navigator.xr.on('devicechange', checkForXRSupport);
        }
      }
    });
  }

  /**
   * The addShaderPreprocessorDirective method.
   * @param {string} name - The name value.
   * @param {any} value - The value param.
   */
  addShaderPreprocessorDirective(name, value) {
    if (value) this.__shaderDirectives[name] = '#define ' + name + ' = ' + value;
    else this.__shaderDirectives[name] = '#define ' + name;
    const directives = [];
    for (const key in this.__shaderDirectives) {
      directives.push(this.__shaderDirectives[key]);
    }
    this.__preproc.defines = directives.join('\n') + '\n';
    this.__gl.shaderopts = this.__preproc;
  }

  /**
   * The getShaderPreproc method.
   * @return {any} - The return value.
   */
  getShaderPreproc() {
    return this.__preproc
  }

  /**
   * The getWidth method.
   * @return {any} - The return value.
   */
  getWidth() {
    return this.__glcanvas.width
  }

  /**
   * The getHeight method.
   * @return {any} - The return value.
   */
  getHeight() {
    return this.__glcanvas.height
  }

  // //////////////////////////////////////
  // Viewports

  /**
   * Add a viewport.
   * @param {string} name - The name of the viewport.
   * @return {GLViewport} - The return value.
   */
  addViewport(name) {
    const vp = new GLViewport(this, name, this.getWidth(), this.getHeight());

    vp.createGeomDataFbo(this.__floatGeomBuffer);

    const updated = () => {
      this.requestRedraw();
    };
    const viewChanged = (data) => {
      if (!this.__xrViewportPresenting) {
        this.emit('viewChanged', data);
      }
    };
    vp.on('updated', updated);
    vp.on('viewChanged', viewChanged);

    this.__viewports.push(vp);
    return vp
  }

  /**
   * The getViewport method.
   * @param {number} index - The index value.
   * @return {GLViewport} - The return value.
   */
  getViewport(index = 0) {
    return this.__viewports[index]
  }

  /**
   * The getViewportAtPos method.
   * @param {number} offsetX - The viewport offset in the X axis.
   * @param {number} offsetY - The viewport offset in the Y axis.
   * @return {GLViewport} - The return value.
   */
  getViewportAtPos(offsetX, offsetY) {
    for (const vp of this.__viewports) {
      const x = vp.getPosX();
      const y = vp.getPosY();
      const width = vp.getWidth();
      const height = vp.getHeight();
      if (offsetX >= x && offsetY >= y && offsetX <= width + x && offsetY <= height + y) return vp
    }
    return undefined
  }

  /**
   * The activateViewport method.
   * @param {GLViewport} vp - The viewport.
   */
  activateViewport(vp) {
    if (this.__activeViewport == vp) return

    this.__activeViewport = vp;
  }

  /**
   * The activateViewportAtPos method.
   * @param {number} offsetX - The viewport offset in the X axis.
   * @param {number} offsetY - The viewport offset in the Y axis.
   */
  activateViewportAtPos(offsetX, offsetY) {
    if (this.__xrViewportPresenting) return
    const vp = this.getViewportAtPos(offsetX, offsetY);
    if (vp && vp != this.__activeViewport) this.activateViewport(vp);
  }

  /**
   * The getActiveViewport method.
   * @return {any} - The return value.
   */
  getActiveViewport() {
    if (this.__xrViewportPresenting) return this.__xrViewport
    return this.__activeViewport
  }

  /**
   * The suspendDrawing method.
   */
  suspendDrawing() {
    this.__drawSuspensionLevel++;
  }

  /**
   * The resumeDrawing method.
   */
  resumeDrawing() {
    this.__drawSuspensionLevel--;
    if (this.__drawSuspensionLevel == 0) {
      if (this.__loadingImg) this.__glcanvasDiv.removeChild(this.__loadingImg);

      this.renderGeomDataFbos();
      this.requestRedraw();
    }
  }

  /**
   * The renderGeomDataFbos method. Frame buffer (FBO).
   */
  renderGeomDataFbos() {
    if (this.__renderGeomDataFbosRequested == true) return

    this.__renderGeomDataFbosRequested = true;
    const onAnimationFrame = () => {
      for (const vp of this.__viewports) vp.renderGeomDataFbo();
      this.__renderGeomDataFbosRequested = false;
    };
    window.requestAnimationFrame(onAnimationFrame);
  }

  // //////////////////////////////////////
  // Scene

  /**
   * Setup the grid in the scene.
   * @param {any} gridSize - The size of the grid.
   * @param {Color} gridColor - The color of the grid.
   * @param {any} resolution - The resolution of the grid.
   * @param {any} lineThickness - The thickness of the grid lines.
   * @return {any} - The return value.
   */
  setupGrid(gridSize, gridColor, resolution, lineThickness) {
    console.warn('Deprecated Method. Please use scene.setupGrid');
    return this.__scene.setupGrid(gridSize, resolution, gridColor)
  }

  /**
   * The getScene method.
   * @return {any} - The return value.
   */
  getScene() {
    return this.__scene
  }

  /**
   * The setScene method.
   * @param {any} scene - The scene value.
   */
  setScene(scene) {
    this.__scene = scene;
    this.addTreeItem(this.__scene.getRoot());

    if (this.__gizmoContext) this.__gizmoContext.setSelectionManager(scene.getSelectionManager());

    this.emit('sceneSet', { scene: this.__scene });
  }

  __childItemAdded(event) {
    this.addTreeItem(event.childItem);
  }
  __childItemRemoved(event) {
    this.removeTreeItem(event.childItem);
  }

  /**
   * Add tree items to the scene.
   * @param {any} treeItem - The tree item to add.
   */
  addTreeItem(treeItem) {
    // Note: we can have BaseItems in the tree now.
    if (!(treeItem instanceof TreeItem)) return

    for (const passCbs of this.__passCallbacks) {
      const rargs = {
        continueInSubTree: true,
      };
      const handled = passCbs.itemAddedFn(treeItem, rargs);
      if (handled) {
        if (!rargs.continueInSubTree) return
        break
      }
    }

    // Traverse the tree adding items until we hit the leaves (which are usually GeomItems.)
    for (const childItem of treeItem.getChildren()) {
      if (childItem) this.addTreeItem(childItem);
    }

    treeItem.on('childAdded', this.__childItemAdded);
    treeItem.on('childRemoved', this.__childItemRemoved);

    this.renderGeomDataFbos();
  }

  /**
   * Remove tree items from the scene.
   * @param {any} treeItem - The tree item to remove.
   */
  removeTreeItem(treeItem) {
    // Note: we can have BaseItems in the tree now.
    if (!(treeItem instanceof TreeItem)) return

    treeItem.off('childAdded', this.__childItemAdded);
    treeItem.off('childRemoved', this.__childItemRemoved);

    for (const passCbs of this.__passCallbacks) {
      if (!passCbs.itemRemovedFn) continue
      const rargs = {
        continueInSubTree: true,
      };
      const handled = passCbs.itemRemovedFn(treeItem, rargs);
      if (handled) {
        if (!rargs.continueInSubTree) return
        break
      }
    }

    // Traverse the tree adding items till we hit the leaves (which are usually GeomItems).
    for (const childItem of treeItem.getChildren()) {
      if (childItem) this.removeTreeItem(childItem);
    }
    this.renderGeomDataFbos();
  }

  // ///////////////////////
  // Renderer Setup

  /**
   * Getter for gl.
   */
  get gl() {
    return this.__gl
  }

  /**
   * The getGL method.
   * @return {any} - The return value.
   */
  getGL() {
    return this.__gl
  }

  /**
   * The resizeFbos method. Frame buffer (FBO).
   * @param {any} width - The width of the frame buffer.
   * @param {any} height - The height of the frame buffer.
   */
  resizeFbos(width, height) {}

  /**
   * The __onResize method.
   * @private
   */
  __onResize() {
    if (!this.__xrViewportPresenting) {
      // Note: devicePixelRatio has already been factored into the clientWidth and clientHeight,
      // meaning we do not need to multiply client values by devicePixelRatio to get real values.
      // On some devices, this duplicate multiplication (when the meta tag was not present), caused
      // very large offscreen buffers to be created, which crashed devices.
      // (PT 15/10/2019 - Zahner project)
      // In some cases I have seen this is disabled using a viewport meta tag in the DOM, which then
      // requires that we multiply by devicePixelRatio to get the screen pixels size.
      // By removing that tag, it seems like manual zooming now on desktop systems does _NOT_
      // effect the clientWidth/clientHeight which causes blurry rendering(when zoomed).
      // This is a minor issue IMO, and so am disabling devicePixelRatio until its value is clear.
      // _Remove the meta name="viewport" from the HTML_
      const dpr = 1.0; //window.devicePixelRatio
      this.__glcanvas.width = this.__glcanvas.clientWidth * dpr;
      this.__glcanvas.height = this.__glcanvas.clientHeight * dpr;

      for (const vp of this.__viewports) vp.resize(this.__glcanvas.width, this.__glcanvas.height);

      this.resizeFbos(this.__glcanvas.width, this.__glcanvas.height);

      this.emit('resized', {
        width: this.__glcanvas.width,
        height: this.__glcanvas.height,
      });
      this.requestRedraw();
    }
  }

  /**
   * The getDiv method.
   * @return {any} - The return value.
   */
  getDiv() {
    return this.__glcanvasDiv
  }

  /**
   * The setupWebGL method.
   * @param {any} canvasDiv - The canvasDiv value.
   * @param {any} webglOptions - The webglOptions value.
   */
  setupWebGL(canvasDiv, webglOptions) {
    this.__glcanvas = document.createElement('canvas');
    this.__glcanvas.style.position = webglOptions.canvasPosition ? webglOptions.canvasPosition : 'absolute';
    this.__glcanvas.style.left = '0px';
    this.__glcanvas.style.top = '0px';
    this.__glcanvas.style.width = '100%';
    this.__glcanvas.style.height = '100%';

    this.__glcanvasDiv = canvasDiv;
    this.__glcanvasDiv.appendChild(this.__glcanvas);

    onResize(this.__glcanvas, (event) => {
      this.__onResize();
    });
    this.__onResize();

    webglOptions.preserveDrawingBuffer = true;
    webglOptions.stencil = webglOptions.stencil ? webglOptions.stencil : false;
    webglOptions.alpha = webglOptions.alpha ? webglOptions.alpha : false;
    webglOptions.xrCompatible = true;
    this.__gl = create3DContext(this.__glcanvas, webglOptions);
    if (!this.__gl) alert('Unable to create WebGL context. WebGL not supported.');
    this.__gl.renderer = this;

    if (this.__gl.name == 'webgl2') {
      this.addShaderPreprocessorDirective('ENABLE_ES3');
    }
    if (this.__gl.floatTexturesSupported) {
      this.addShaderPreprocessorDirective('ENABLE_FLOAT_TEXTURES');
    }

    this.__gl.screenQuad = new GLScreenQuad(this.__gl);
    this.__screenQuad = this.__gl.screenQuad;

    // Note: Mobile devices don't provide much support for reading data back from float textures,
    // and checking compatibility is patchy at best.
    // Note: We are now pushing on high-end mobile devices.
    // Galaxy and above. We need this. We need to accurately determine
    // if the float buffer is not supported.
    this.__floatGeomBuffer = this.__gl.floatTexturesSupported && SystemDesc.browserName != 'Safari';
    this.__gl.floatGeomBuffer = this.__floatGeomBuffer;
    // Note: the following returns UNSIGNED_BYTE even if the browser supports float.
    // const implType = this.__gl.getParameter(this.__gl.IMPLEMENTATION_COLOR_READ_TYPE);
    // this.__floatGeomBuffer = (implType == this.__gl.FLOAT);

    // //////////////////////////////////
    // Bind a default texture.
    // Note: If shaders have sampler2D uniforms, but we don't bind textures, then
    // they get assigned texture0. If we have no textures bound at all, then
    // we get warnings saying.
    // There is no texture bound to the unit 0
    // Bind a default texture to unit 0 simply to avoid these warnings.
    // this.__texture0 = new GLTexture2D(this.__gl, {
    //     format: 'RGB',
    //     type: 'UNSIGNED_BYTE',
    //     width: 1,
    //     height: 1,
    //     filter: 'NEAREST',
    //     mipMapped: false,
    //     wrap: 'CLAMP_TO_EDGE',
    //     data: new Uint8Array(3)
    // });

    // // gl.activeTexture(this.__gl.TEXTURE0);
    // this.__gl.bindTexture(this.__gl.TEXTURE_2D, this.__texture0.getTexHdl());
  }

  /**
   * The bindEventHandlers method.
   */
  bindEventHandlers() {
    // ////////////////////////////////
    // Setup event handlers
    const isValidCanvas = () => {
      return this.__glcanvas.width > 0 && this.__glcanvas.height
    };

    const calcRendererCoords = (event) => {
      const rect = this.__glcanvas.getBoundingClientRect();
      // Disabling devicePixelRatio for now. See: __onResize
      const dpr = 1.0; //window.devicePixelRatio
      // Note: the rendererX/Y values are relative to the viewport,
      // but are available outside the viewport. So when a mouse
      // drag occurs, and drags outside the viewport, these values
      // provide consistent coords.
      // offsetX/Y are only valid inside the viewport and so cause
      // jumps when the mouse leaves the viewport.
      event.rendererX = (event.clientX - rect.left) * dpr;
      event.rendererY = (event.clientY - rect.top) * dpr;
    };

    this.__glcanvas.addEventListener('mouseenter', (event) => {
      event.undoRedoManager = this.undoRedoManager;
      if (!mouseIsDown) {
        activeGLRenderer = this;
        calcRendererCoords(event);
        // TODO: Check mouse pos.
        activeGLRenderer.activateViewportAtPos(event.rendererX, event.rendererY);
        mouseLeft = false;
      }
    });
    this.__glcanvas.addEventListener('mouseleave', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      event.undoRedoManager = this.undoRedoManager;
      if (!mouseIsDown) {
        const vp = activeGLRenderer.getActiveViewport();
        if (vp) {
          vp.onMouseLeave(event);
          event.preventDefault();
        }
        activeGLRenderer = undefined;
      } else {
        mouseLeft = true;
      }
    });
    this.__glcanvas.addEventListener('mousedown', (event) => {
      event.undoRedoManager = this.undoRedoManager;
      calcRendererCoords(event);
      mouseIsDown = true;
      activeGLRenderer = this;
      activeGLRenderer.activateViewportAtPos(event.rendererX, event.rendererY);
      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onMouseDown(event);
      }
      mouseLeft = false;
      return false
    });
    document.addEventListener('mouseup', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      event.undoRedoManager = this.undoRedoManager;
      calcRendererCoords(event);
      mouseIsDown = false;
      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onMouseUp(event);
      }
      if (mouseLeft) {
        const vp = activeGLRenderer.getActiveViewport();
        if (vp) {
          vp.onMouseLeave(event);
          event.preventDefault();
        }
        activeGLRenderer = undefined;
      }
      return false
    });

    // document.addEventListener('dblclick', (event) =>{
    //     event.preventDefault();
    //     event.stopPropagation();
    // });
    // document.addEventListener('click', (event) =>{
    //     event.preventDefault();
    //     event.stopPropagation();
    // });

    document.addEventListener('mousemove', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      event.undoRedoManager = this.undoRedoManager;
      calcRendererCoords(event);
      if (!mouseIsDown) activeGLRenderer.activateViewportAtPos(event.rendererX, event.rendererY);

      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onMouseMove(event);
      }
      return false
    });

    const onWheel = (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      if (activeGLRenderer) {
        event.undoRedoManager = this.undoRedoManager;
        this.onWheel(event);
      }
      return false
    };
    if (window.addEventListener)
      /** DOMMouseScroll is for mozilla. */
      window.addEventListener('wheel', onWheel, { passive: false });
    else {
      /** IE/Opera. */
      window.onmousewheel = document.onmousewheel = onWheel;
    }

    window.oncontextmenu = function () {
      return false
    };

    document.addEventListener('keypress', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      const key = String.fromCharCode(event.keyCode).toLowerCase();
      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onKeyPressed(key, event);
      }
    });

    document.addEventListener('keydown', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      const key = String.fromCharCode(event.keyCode).toLowerCase();
      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onKeyDown(key, event);
      }
    });

    document.addEventListener('keyup', (event) => {
      if (activeGLRenderer != this || !isValidCanvas()) return
      const key = String.fromCharCode(event.keyCode).toLowerCase();
      const vp = activeGLRenderer.getActiveViewport();
      if (vp) {
        vp.onKeyUp(key, event);
      }
    });

    this.__glcanvas.addEventListener(
      'touchstart',
      (event) => {
        event.stopPropagation();
        event.undoRedoManager = this.undoRedoManager;
        for (let i = 0; i < event.touches.length; i++) {
          calcRendererCoords(event.touches[i]);
        }
        this.getViewport().onTouchStart(event);
      },
      false
    );

    this.__glcanvas.addEventListener(
      'touchmove',
      (event) => {
        event.stopPropagation();
        event.undoRedoManager = this.undoRedoManager;
        for (let i = 0; i < event.touches.length; i++) {
          calcRendererCoords(event.touches[i]);
        }
        this.getViewport().onTouchMove(event);
      },
      false
    );

    this.__glcanvas.addEventListener(
      'touchend',
      (event) => {
        event.stopPropagation();
        event.undoRedoManager = this.undoRedoManager;
        for (let i = 0; i < event.touches.length; i++) {
          calcRendererCoords(event.touches[i]);
        }
        this.getViewport().onTouchEnd(event);
      },
      false
    );

    this.__glcanvas.addEventListener(
      'touchcancel',
      (event) => {
        event.stopPropagation();
        event.undoRedoManager = this.undoRedoManager;
        this.getViewport().onTouchCancel(event);
      },
      false
    );
  }

  /**
   * The setUndoRedoManager method.
   * @param {object} undoRedoManager - The undoRedoManager state.
   */
  setUndoRedoManager(undoRedoManager) {
    this.undoRedoManager = undoRedoManager;
  }

  /**
   * The getGLCanvas method.
   * @return {any} - The return value.
   */
  getGLCanvas() {
    return this.__glcanvas
  }

  /**
   * The getScreenQuad method.
   * @return {any} - The return value.
   */
  getScreenQuad() {
    return this.__screenQuad
  }

  /**
   * Causes an event to occur when the mouse wheel is rolled up or down over an element.
   * @param {any} event - The event that occurs.
   */
  onWheel(event) {
    this.__viewports[0].onWheel(event);
  }

  /**
   * The frameAll method.
   * @param {number} viewportIndex - The viewportIndex value.
   */
  frameAll(viewportIndex = 0) {
    this.__viewports[viewportIndex].frameView([this.__scene.getRoot()]);
  }

  // ///////////////////////
  // Render Items Setup

  /**
   * The getOrCreateShader method.
   * @param {string} shaderName - The shader name.
   * @return {any} - The return value.
   */
  getOrCreateShader(shaderName) {
    let glshader = this.__shaders[shaderName];
    if (!glshader) {
      glshader = Registry.constructClass(shaderName, this.__gl);
      if (!glshader) console.error('Shader not registered with the Registry:', shaderName);
      this.__shaders[shaderName] = glshader;
    }
    return glshader
  }

  /**
   * The addPass method.
   * @param {any} pass - The pass value.
   * @param {number} passtype - The passtype value.
   * @param {boolean} updateIndices - The updateIndices value.
   * @return {any} - The return value.
   */
  addPass(pass, passtype = 0, updateIndices = true) {
    if (!this.__passes[passtype]) this.__passes[passtype] = [];

    let index = 0;
    for (const key in this.__passes) {
      if (key == passtype) break
      index += this.__passes[key].length;
    }
    index += this.__passes[passtype].length;

    pass.on('updated', this.requestRedraw);
    pass.init(this, index);
    this.__passes[passtype].push(pass);

    if (updateIndices) {
      // Now update all the  subsequent pass indices because the
      // indices after will have changed.
      let offset = 0;
      for (const key in this.__passes) {
        const passSet = this.__passes[key];
        passSet.forEach((pass, index) => {
          pass.setPassIndex(offset + index);
        });
        offset += passSet.length;
      }
    }

    this.requestRedraw();
    return index
  }

  /**
   * The registerPass method.
   * @param {any} itemAddedFn - The itemAddedFn value.
   * @param {any} itemRemovedFn - The itemRemovedFn value.
   */
  registerPass(itemAddedFn, itemRemovedFn) {
    // insert at the beginning so it is called first.
    this.__passCallbacks.splice(0, 0, {
      itemAddedFn,
      itemRemovedFn,
    });
  }

  /**
   * The getPass method.
   * @param {number} index - The index value.
   * @return {any} - The return value.
   */
  getPass(index) {
    let offset = 0;
    for (const key in this.__passes) {
      const passSet = this.__passes[key];
      if (index - offset < passSet.length) return passSet[index - offset]
      offset += passSet.length;
    }
  }

  /**
   * The findPass method.
   * @param {any} constructor - The constructor value.
   * @return {any} - The return value.
   */
  findPass(constructor) {
    for (const key in this.__passes) {
      const passSet = this.__passes[key];
      for (const pass of passSet) {
        if (pass.constructor == constructor) return pass
      }
    }
  }

  /**
   * The getGizmoPass method.
   * @return {any} - The return value.
   */
  getGizmoPass() {
    return this.__gizmoPass
  }

  // ///////////////////////
  // VR Setup

  /**
   * The supportsVR method.
   * @return {any} - The return value.
   */
  supportsVR() {
    console.warn('Deprecated Method. Please instead connect to the vrViewportSetup signal.');
    return this.__supportXR && navigator.xr != null
  }

  /**
   * The __setupXRViewport method.
   * @return {any} - The return value.
   * @private
   */
  __setupXRViewport() {
    // Always get the last display. Additional displays are added at the end.(e.g. [Polyfill, HMD])
    const xrvp = new VRViewport(this);

    const emitViewChanged = (event) => {
      this.emit('viewChanged', event);
    };

    xrvp.on('presentingChanged', (event) => {
      const state = event.state;
      this.__xrViewportPresenting = state;
      if (state) {
        // Let the passes know that VR is starting.
        // They can do things like optimize shaders.
        for (const key in this.__passes) {
          const passSet = this.__passes[key];
          for (const pass of passSet) {
            pass.startPresenting();
          }
        }

        xrvp.on('viewChanged', emitViewChanged);
      } else {
        xrvp.off('viewChanged', emitViewChanged);
        this.emit('updated', {});

        for (const key in this.__passes) {
          const passSet = this.__passes[key];
          for (const pass of passSet) {
            pass.stopPresenting();
          }
        }
        const event = {
          interfaceType: 'CameraAndPointer',
          viewXfo: this.getViewport().getCamera().getParameter('GlobalXfo').getValue(),
        };
        this.emit('viewChanged', event);

        this.resizeFbos(this.__glcanvas.width, this.__glcanvas.height);
        this.requestRedraw();
      }
    });
    return xrvp
  }

  /**
   * The getVRViewport method.
   * @return {any} - The return value.
   */
  getVRViewport() {
    return this.__xrViewport
  }

  /**
   * The getXRViewport method.
   * @return {any} - The return value.
   */
  getXRViewport() {
    return this.__xrViewportPromise
  }

  /**
   * The isXRViewportPresenting method.
   * @return {any} - The return value.
   */
  isXRViewportPresenting() {
    return this.__xrViewportPresenting
  }

  // //////////////////////////
  // Rendering

  /**
   * The isContinuouslyDrawing method.
   * @return {any} - The return value.
   */
  isContinuouslyDrawing() {
    return this.__continuousDrawing
  }

  /**
   * The startContinuousDrawing method.
   */
  startContinuousDrawing() {
    if (this.isContinuouslyDrawing() || this.__xrViewportPresenting) return

    const onAnimationFrame = () => {
      if (this.__continuousDrawing && !this.__xrViewportPresenting) window.requestAnimationFrame(onAnimationFrame);
      for (const vp of this.__viewports) vp.draw();
    };

    this.__continuousDrawing = true;
    window.requestAnimationFrame(onAnimationFrame);
  }

  /**
   * The stopContinuousDrawing method.
   */
  stopContinuousDrawing() {
    this.__continuousDrawing = false;
  }

  /**
   * The toggleContinuousDrawing method.
   */
  toggleContinuousDrawing() {
    if (!this.__continuousDrawing) {
      this.startContinuousDrawing();
    } else {
      this.stopContinuousDrawing();
    }
  }

  /**
   * The drawItemChanged method.
   */
  drawItemChanged() {
    for (const vp of this.__viewports) vp.invalidateGeomDataBuffer();
    this.requestRedraw();
  }

  /**
   * Request a single redraw, usually in response to a signal/event.
   * @return {boolean} - The return value.
   */
  requestRedraw() {
    // If a redraw has already been requested, then simply return and wait.
    if (this.__redrawRequested || this.__continuousDrawing || this.__xrViewportPresenting) return false

    const onAnimationFrame = () => {
      this.__redrawRequested = false;
      for (const vp of this.__viewports) {
        vp.draw();
      }
    };
    window.requestAnimationFrame(onAnimationFrame);
    this.__redrawRequested = true;
    return true
  }

  /**
   * The bindGLBaseRenderer method.
   * @param {any} renderstate - The renderstate value.
   */
  bindGLBaseRenderer(renderstate) {
    renderstate.shaderopts = this.__preproc;

    const gl = this.__gl;
    if (!renderstate.viewports || renderstate.viewports.length == 1) {
      renderstate.bindRendererUnifs = (unifs) => {
        const { cameraMatrix, viewMatrix, projectionMatrix, eye } = unifs;
        if (cameraMatrix) {
          gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
        }

        const vp = renderstate.viewports[0];
        if (viewMatrix) {
          gl.uniformMatrix4fv(viewMatrix.location, false, vp.viewMatrix.asArray());
        }

        if (projectionMatrix) {
          gl.uniformMatrix4fv(projectionMatrix.location, false, vp.projectionMatrix.asArray());
        }

        if (eye) {
          // Left or right eye, when rendering sterio VR.
          gl.uniform1i(eye.location, index);
        }
      };
      renderstate.bindViewports = (unifs, cb) => cb();
    } else {
      renderstate.bindRendererUnifs = (unifs) => {
        // Note: the camera matrix should be the head position instead
        // of the eye position. The inverse(viewMatrix) can be used
        // when we want the eye pos.
        const { cameraMatrix } = unifs;
        if (cameraMatrix) {
          gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
        }
      };

      renderstate.bindViewports = (unifs, cb) => {
        renderstate.viewports.forEach((vp, index) => {
          gl.viewport(...vp.region);

          const { viewMatrix, projectionMatrix, eye } = unifs;
          if (viewMatrix) {
            gl.uniformMatrix4fv(viewMatrix.location, false, vp.viewMatrix.asArray());
          }

          if (projectionMatrix) {
            gl.uniformMatrix4fv(projectionMatrix.location, false, vp.projectionMatrix.asArray());
          }

          if (eye) {
            // Left or right eye, when rendering sterio VR.
            gl.uniform1i(eye.location, index);
          }
          cb();
        });
      };
    }
  }

  /**
   * The drawScene method.
   * @param {any} renderstate - The renderstate value.
   */
  drawScene(renderstate) {
    // Bind already called by GLRenderer.
    for (const key in this.__passes) {
      const passSet = this.__passes[key];
      for (const pass of passSet) {
        if (pass.enabled) pass.draw(renderstate);
      }
    }
  }

  /**
   * The drawHighlightedGeoms method.
   * @param {any} renderstate - The renderstate value.
   */
  drawHighlightedGeoms(renderstate) {
    this.bindGLBaseRenderer(renderstate);
    for (const key in this.__passes) {
      const passSet = this.__passes[key];
      for (const pass of passSet) {
        if (pass.enabled) pass.drawHighlightedGeoms(renderstate);
      }
    }
  }

  /**
   * The drawSceneGeomData method.
   * @param {any} renderstate - The renderstate value.
   */
  drawSceneGeomData(renderstate, mask = 255) {
    this.bindGLBaseRenderer(renderstate);
    for (const key in this.__passes) {
      // Skip pass categories that do not match
      // the mask. E.g. we may not want to hit
      // "Overlay" geoms such as labels,
      // or we might be trying to move labels and don't
      // want to grab normal geoms.
      if ((Number.parseInt(key) & mask) == 0) continue
      const passSet = this.__passes[key];
      for (const pass of passSet) {
        if (pass.enabled) pass.drawGeomData(renderstate);
      }
    }
  }

  // ////////////////////////////////////////
  // Static Methods

  /**
   * The registerPass method.
   * @param {any} cls - The cls value.
   * @param {any} passtype - The passtype value.
   */
  static registerPass(cls, passtype) {
    if (!registeredPasses[passtype]) registeredPasses[passtype] = [];
    registeredPasses[passtype].push(cls);
  }
}

const PassType = {
  OPAQUE: 1 << 0,
  TRANSPARENT: 1 << 1,
  OVERLAY: 1 << 2,
};

/** This class abstracts the rendering of a collection of geometries to screen.
 * @extends ParameterOwner
 */
class GLPass extends ParameterOwner {
  /**
   * Create a GL pass.
   */
  constructor() {
    super();
    this.enabled = true;
    this.__passIndex = 0;

    const enabledParam = this.addParameter(new BooleanParameter('Enabled', true));
    enabledParam.on('valueChanged', () => (this.enabled = enabledParam.getValue()));
  }

  /**
   * The __parameterValueChanged method.
   * @param {object} event - The event object.
   * @private
   */
  __parameterValueChanged(event) {
    super.__parameterValueChanged(event);
    if (this.__renderer) this.__renderer.requestRedraw();
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    if (passIndex == undefined) throw new Error('Missing constructor argument.') // Type checking. Seomthing that TypeScript will do for us.

    this.__gl = renderer.gl;
    this.__renderer = renderer;
    this.__passIndex = passIndex;
  }

  /**
   * The setPassIndex method.
   * @param {any} passIndex - The passIndex value.
   */
  setPassIndex(passIndex) {
    this.__passIndex = passIndex;
  }

  /**
   * The startPresenting method.
   */
  startPresenting() {}

  /**
   * The stopPresenting method.
   */
  stopPresenting() {}

  // ///////////////////////////////////
  // Rendering

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {}

  /**
   * The drawHighlightedGeoms method.
   * @param {any} renderstate - The renderstate value.
   */
  drawHighlightedGeoms(renderstate) {}

  /**
   * The drawGeomData method.
   * @param {any} renderstate - The renderstate value.
   */
  drawGeomData(renderstate) {}

  /**
   * The getGeomItemAndDist method.
   * @param {any} geomData - The geomData value.
   */
  getGeomItemAndDist(geomData) {}
}

class OutlinesShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'OutlinesShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;    //(location = 0)

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
    v_texCoord = positions.xy+0.5;
    gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);
}

`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'OutlinesShader.fragmentShader',
      `
precision highp float;

uniform sampler2D highlightDataTexture;
uniform vec2 highlightDataTextureSize;

varying vec2 v_texCoord;


bool isFilledPixel(vec4 p) {
    return p.r > 0.01 || p.g > 0.01 || p.b > 0.01;
}
void accumOutlinePixel(vec2 fragCoord, inout vec4 res) {
    vec3 p = texture2D(highlightDataTexture, fragCoord/highlightDataTextureSize).rgb;
    if(p.r > 0.01 || p.g > 0.01 || p.b > 0.01) {
        res.r += p.r;
        res.g += p.g;
        res.b += p.b;
        res.a += 1.0;
    }
}
vec4 getOutlinePixelColor(vec2 fragCoord) {
    vec4 M = texture2D(highlightDataTexture, fragCoord/highlightDataTextureSize);
    
    /// To display a fill instead of an outline.
    // return M;

    if( isFilledPixel(M) ) {
        // Note: the filled pixel has an alpha value
        // that determines how much fill is applied
        // The outline is a solid color. 
        return M;
    }
    // Search surrounding pixels for selected geoms.
    vec4 res;
    accumOutlinePixel(fragCoord+vec2( 1, 1), res); // NW
    accumOutlinePixel(fragCoord+vec2(-1, 1), res); // NE
    accumOutlinePixel(fragCoord+vec2( 1,-1), res); // SW
    accumOutlinePixel(fragCoord+vec2(-1,-1), res); // SE
    accumOutlinePixel(fragCoord+vec2( 0, 2), res); // NN
    accumOutlinePixel(fragCoord+vec2(-2, 0), res); // EE
    accumOutlinePixel(fragCoord+vec2( 2, 0), res); // WW
    accumOutlinePixel(fragCoord+vec2( 0,-2), res); // SS
    accumOutlinePixel(fragCoord+vec2( 1, 2), res); // NNW
    accumOutlinePixel(fragCoord+vec2(-1, 2), res); // NNE
    accumOutlinePixel(fragCoord+vec2(-2, 1), res); // EEN
    accumOutlinePixel(fragCoord+vec2(-2,-1), res); // EES
    accumOutlinePixel(fragCoord+vec2( 2, 1), res); // WWN
    accumOutlinePixel(fragCoord+vec2( 2,-1), res); // WWS
    accumOutlinePixel(fragCoord+vec2( 1,-2), res); // SSW
    accumOutlinePixel(fragCoord+vec2(-1,-2), res); // SSE

    if(isFilledPixel(res))
        return vec4(res.rgb / res.a, 1.0);
    else
        return vec4(0.0, 0.0, 0.0, 0.0);
}


#ifdef ENABLE_ES3
out vec4 fragColor;
#endif

void main(void) {

    // fragColor = texture2D(highlightDataTexture, v_texCoord);;
    //can also use gl_FragCoord.xy
    mediump vec2 fragCoord = v_texCoord * highlightDataTextureSize; 
    /////////////////
    // Selection Outlines
    vec4 outlineColor = getOutlinePixelColor(fragCoord);
    if(outlineColor.a > 0.0001){
#ifndef ENABLE_ES3
        gl_FragColor = outlineColor;
#else
        fragColor = outlineColor;
#endif
    }
    else {
        discard;
    }
}

`
    );
  }
}

var logo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 789 220\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\">\r\n    <g id=\"Layer-1\" serif:id=\"Layer 1\" transform=\"matrix(4.16667,0,0,4.16667,-196.224,-480.93)\">\r\n        <g transform=\"matrix(1,0,0,1,159.455,129.109)\">\r\n            <path d=\"M0,25.306L-35.309,25.306L-35.309,0L-6.305,0L-6.305,6.284L-30.049,6.284L-30.049,12.276C-30.049,16.473 -26.646,19.875 -22.449,19.875L7.321,19.875L7.323,-6.135C7.323,-10.272 3.97,-13.625 -0.167,-13.626L-41.638,-13.627C-45.774,-13.627 -49.128,-10.274 -49.128,-6.137L-49.129,31.442C-49.129,35.578 -45.776,38.931 -41.64,38.932L7.489,38.933L7.489,32.796C7.489,28.66 4.136,25.306 0,25.306\" style=\"fill:rgb(249,206,3);fill-rule:nonzero;\"/>\r\n        </g>\r\n        <g transform=\"matrix(1,0,0,1,230.966,129.075)\">\r\n            <path d=\"M0,25.314L0,-5.032C0,-9.787 -3.854,-13.643 -8.609,-13.644L-45.856,-13.652C-50.613,-13.653 -54.47,-9.797 -54.47,-5.04L-54.47,30.338C-54.47,35.092 -50.618,38.947 -45.864,38.951L-18.935,38.967L-18.935,32.949C-18.935,28.741 -22.346,25.329 -26.555,25.329L-40.636,25.328L-40.636,-0.003L-13.639,-0.003L-13.639,31.262C-13.639,35.517 -10.189,38.967 -5.935,38.967L5.405,38.967L5.405,29.282C5.405,27.09 3.629,25.314 1.437,25.314L0,25.314Z\" style=\"fill:rgb(249,206,3);fill-rule:nonzero;\"/>\r\n        </g>\r\n        <g transform=\"matrix(1,0,0,1,69.5968,129.035)\">\r\n            <path d=\"M0,25.455L27.636,0.617C29.238,-0.823 30.153,-2.876 30.153,-5.03L30.153,-13.553L-13.422,-13.553C-17.542,-13.553 -20.881,-10.213 -20.881,-6.094L-20.881,-0.009L7.586,-0.008L-19.993,24.844C-21.591,26.284 -22.503,28.334 -22.503,30.484L-22.503,39.008L24.316,39.008C28.436,39.008 31.775,35.668 31.775,31.549L31.775,25.465L0,25.455Z\" style=\"fill:rgb(249,206,3);fill-rule:nonzero;\"/>\r\n        </g>\r\n    </g>\r\n</svg>";

const ALL_PASSES = PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY;

/** Class representing a GL renderer.
 * @extends GLBaseRenderer
 */
class GLRenderer extends GLBaseRenderer {
  /**
   * Create a GL renderer.
   * @param {any} canvasDiv - The canvasDiv value.
   * @param {any} options - The options value.
   */
  constructor(canvasDiv, options = {}) {
    super(canvasDiv, options, {
      antialias: true,
      depth: true,
    });

    // ///////////////////////
    // Renderer Setup
    this.__exposure = 1.0;
    this.__tonemap = true;
    this.__gamma = 2.2;

    this.__glEnvMap = undefined;
    this.__glBackgroundMap = undefined;

    this.__displayEnvironment = true;
    this.__debugMode = 0;
    this._planeDist = 0.0;
    this.__cutPlaneNormal = new Vec3$1(1, 0, 0);

    const gl = this.__gl;

    this.__debugTextures = [undefined];

    this.addShaderPreprocessorDirective('ENABLE_INLINE_GAMMACORRECTION');

    if (!options.disableTextures) this.addShaderPreprocessorDirective('ENABLE_TEXTURES');

    if (!SystemDesc.isMobileDevice) {
      if (!options.disableSpecular) this.addShaderPreprocessorDirective('ENABLE_SPECULAR');
    }

    this.__outlineShader = new OutlinesShader(gl);
    this.quad = new GLMesh(gl, new Plane$1(1, 1));

    this.createSelectedGeomsFbo();
    this.createRayCastRenderTarget();

    // ///////////////////////////////////////////////////
    // setup the splash screen
    if (!options.hideSplash) {
      const setupSplashScreen = (holdTime) => {
        const logoBlob = new Blob([logo], { type: 'image/svg+xml' });
        const logoUrl = URL.createObjectURL(logoBlob);
        const image = document.createElement('img');
        image.addEventListener('load', () => {
          URL.revokeObjectURL(logoUrl), { once: true };
          image.style.opacity = 1;
          const tick = () => {
            // Prevent people from removing the image node.
            if (!image.parentElement != canvasDiv) canvasDiv.appendChild(image);
            image.style.opacity = +image.style.opacity - 0.02;
            if (+image.style.opacity > 0) {
(window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
            } else {
              canvasDiv.removeChild(image);
            }
          };
          setTimeout(tick, holdTime);
        });
        image.style.width = canvasDiv.clientWidth * 0.3 + 'px';
        image.style.position = 'absolute';
        image.style.top = '50%';
        image.style.left = '50%';
        image.style.transform = 'translate(-50%, -50%)';
        image.style['pointer-events'] = 'none';
        image.src = logoUrl;
        canvasDiv.appendChild(image);
      };

      setupSplashScreen(1500);
    }
  }

  /**
   * The __bindEnvMap method.
   * @param {any} env - The env value.
   * @private
   */
  __bindEnvMap(env) {
    const gl = this.__gl;
    if (env instanceof EnvMap) {
      this.__glEnvMap = env.getMetadata('gltexture');
      if (!this.__glEnvMap) {
        if (env.type === 'FLOAT') {
          this.addShaderPreprocessorDirective('ENABLE_SPECULAR');
          this.__glEnvMap = new GLEnvMap(this, env, this.__preproc);
        } else if (env.isStreamAtlas()) {
          this.__glEnvMap = new GLImageStream(gl, env);
        } else {
          this.__glEnvMap = new GLTexture2D(gl, env);
        }
      }
    } else {
      // Note: The difference bween an EnvMap and a BackgroundMap, is that
      // An EnvMap must be HDR, and can be convolved for reflections.
      // A Background map can be simply an image.
      const backgroundMap = env;
      this.__glBackgroundMap = backgroundMap.getMetadata('gltexture');
      if (!this.__glBackgroundMap) {
        if (backgroundMap.type === 'FLOAT') {
          this.__glBackgroundMap = new GLHDRImage(gl, backgroundMap);
        } else {
          this.__glBackgroundMap = new GLTexture2D(gl, backgroundMap);
        }
      }
      this.__glBackgroundMap.on('loaded', this.requestRedraw);
      this.__glBackgroundMap.on('updated', this.requestRedraw);
      if (!this.__backgroundMapShader) {
        if (!gl.__quadVertexIdsBuffer) gl.setupInstancedQuad();
        switch (backgroundMap.getMapping()) {
          case 'octahedral':
            this.__backgroundMapShader = new OctahedralEnvMapShader(gl);
            break
          case 'latlong':
            this.__backgroundMapShader = new LatLongEnvMapShader(gl);
            break
          case 'steriolatlong':
            this.__backgroundMapShader = new SterioLatLongEnvMapShader(gl);
            break
          case 'dualfisheye':
            this.__backgroundMapShader = new DualFishEyeToLatLongBackgroundShader(gl);
            break
          case 'uv':
          default:
            this.__backgroundMapShader = new BackgroundImageShader(gl);
            break
        }
        const shaderComp = this.__backgroundMapShader.compileForTarget();
        this.__backgroundMapShaderBinding = generateShaderGeomBinding(
          gl,
          shaderComp.attrs,
          gl.__quadattrbuffers,
          gl.__quadIndexBuffer
        );
      }
      // console.warn('Unsupported EnvMap:' + env)
      return
    }
    this.__glEnvMap.on('loaded', this.requestRedraw);
    this.__glEnvMap.on('updated', this.requestRedraw);

    this.emit('envMapAssigned', { envMap: this.__glEnvMap });
  }

  /**
   * The getGLEnvMap method.
   * @return {any} - The return value.
   */
  getGLEnvMap() {
    return this.__glEnvMap
  }

  /**
   * The getEnvMapTex method.
   * @return {any} - The return value.
   */
  getEnvMapTex() {
    console.warn('Deprecated Function');
    return this.__glEnvMap
  }

  /**
   * The setScene method.
   * @param {any} scene - The scene value.
   */
  setScene(scene) {
    const envMapParam = scene.settings.getParameter('EnvMap');
    if (envMapParam.getValue() != undefined) {
      this.__bindEnvMap(envMapParam.getValue());
    }
    envMapParam.on('valueChanged', () => {
      this.__bindEnvMap(envMapParam.getValue());
    });
    const displayEnvMapParam = scene.settings.getParameter('Display EnvMap');
    this.__displayEnvironment = displayEnvMapParam.getValue();
    displayEnvMapParam.on('valueChanged', () => {
      this.__displayEnvironment = displayEnvMapParam.getValue();
      this.requestRedraw();
    });

    super.setScene(scene);
  }

  /**
   * The addViewport method.
   * @param {string} name - The name value.
   * @return {any} - The return value.
   */
  addViewport(name) {
    const vp = super.addViewport(name);
    // vp.createOffscreenFbo();
    return vp
  }

  /**
   * The onKeyPressed method.
   * @param {any} key - The key value.
   * @param {any} event - The event value.
   */
  onKeyPressed(key, event) {
    switch (key) {
      case 'b':
        this.__displayEnvironment = !this.__displayEnvironment;
        this.requestRedraw();
        break
      default:
        super.onKeyPressed(key, event);
    }
  }

  // //////////////////////////
  // GUI

  /**
   * Getter for exposure.
   */
  get exposure() {
    return this.__exposure
  }

  /**
   * Setter for exposure.
   * @param {number} val - The val value.
   */
  set exposure(val) {
    this.__exposure = val;
    this.requestRedraw();
  }

  /**
   * Getter for gamma.
   */
  get gamma() {
    return this.__gamma
  }

  /**
   * Setter for gamma.
   * @param {number} val - The val value.
   */
  set gamma(val) {
    this.__gamma = val;
    this.requestRedraw();
  }

  /**
   * Getter for displayEnvironment.
   */
  get displayEnvironment() {
    return this.__displayEnvironment
  }

  /**
   * Setter for displayEnvironment.
   * @param {number} val - The val value.
   */
  set displayEnvironment(val) {
    this.__displayEnvironment = val;
    this.requestRedraw();
  }

  /**
   * Getter for planeDist.
   */
  get planeDist() {
    return this._planeDist
  }

  /**
   * Setter for planeDist.
   * @param {number} val - The val value.
   */
  set planeDist(val) {
    this._planeDist = val;
    this.requestRedraw();
  }

  /**
   * Getter for cutPlaneNormal.
   */
  get cutPlaneNormal() {
    return this.__cutPlaneNormal
  }

  /**
   * Setter for cutPlaneNormal.
   * @param {number} val - The val value.
   */
  set cutPlaneNormal(val) {
    this.__cutPlaneNormal = val;
    this.requestRedraw();
  }

  // //////////////////////////
  // Fbos

  /**
   * The resizeFbos method.
   * @param {any} width - The width value.
   * @param {any} height - The height value.
   */
  resizeFbos(width, height) {
    super.resizeFbos();
    if (this.__fbo) {
      this.__fbo.colorTexture.resize(width, height);
    }
    if (this.__highlightedGeomsBufferFbo) {
      this.__highlightedGeomsBuffer.resize(width, height);
    }
  }

  // //////////////////////////
  // SelectedGeomsBuffer

  /**
   * The createSelectedGeomsFbo method.
   */
  createSelectedGeomsFbo() {
    const gl = this.__gl;
    this.__highlightedGeomsBuffer = new GLTexture2D(gl, {
      type: 'UNSIGNED_BYTE',
      format: 'RGBA',
      filter: 'NEAREST',
      width: this.__glcanvas.width <= 1 ? 1 : this.__glcanvas.width,
      height: this.__glcanvas.height <= 1 ? 1 : this.__glcanvas.height,
    });
    this.__highlightedGeomsBufferFbo = new GLFbo(gl, this.__highlightedGeomsBuffer, true);
    this.__highlightedGeomsBufferFbo.setClearColor([0, 0, 0, 0]);
  }

  /**
   * The getFbo method.
   * @return {any} - The return value.
   */
  getFbo() {
    return this.__fbo
  }

  /**
   * The createOffscreenFbo method.
   * @param {any} format - The format value.
   */
  createOffscreenFbo(format = 'RGB') {
    const targetWidth = this.__glcanvas.width;
    const targetHeight = this.__glcanvas.height;

    const gl = this.__gl;
    this.__fwBuffer = new GLTexture2D(gl, {
      type: 'FLOAT',
      format,
      filter: 'NEAREST',
      width: targetWidth,
      height: targetHeight,
    });
    this.__fbo = new GLFbo(gl, this.__fwBuffer, true);
    this.__fbo.setClearColor(this.__backgroundColor.asArray());
  }

  // //////////////////////////
  // Raycasting

  /**
   * The createRayCastRenderTarget method.
   */
  createRayCastRenderTarget() {
    // The geom data buffer is a 3x3 data buffer.
    // See getGeomItemAtTip below
    const gl = this.__gl;
    this.__rayCastRenderTarget = new GLRenderTarget(gl, {
      type: 'FLOAT',
      format: 'RGBA',
      filter: 'NEAREST',
      width: 3,
      height: 3,
      numColorChannels: 1,
    });
    this.__rayCastRenderTargetProjMatrix = new Mat4();
    this.rayCastDist = 0;
    this.rayCastArea = 0;
  }

  /**
   * The raycast method.
   * @return {any} - The return value.
   */
  raycastWithRay(ray, dist, area = 0.01, mask = ALL_PASSES) {
    const xfo = new Xfo();
    xfo.setLookAt(ray.start, ray.start.add(ray.dir));
    return this.raycast(xfo, ray, dist, area, mask)
  }

  raycastWithXfo(xfo, dist, area = 0.01, mask = ALL_PASSES) {
    const ray = new Ray(xfo.tr, xfo.ori.getZaxis().negate());
    return this.raycast(xfo, ray, dist, area, mask)
  }

  /**
   * The raycast method.
   * @return {any} - The return value.
   */
  raycast(xfo, ray, dist, area = 0.01, mask = ALL_PASSES) {
    if (this.rayCastDist != dist || this.rayCastArea != area) {
      this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(
        area * -0.5,
        area * 0.5,
        area * -0.5,
        area * 0.5,
        0.0,
        dist
      );
      this.rayCastDist = dist;
      this.rayCastArea = area;
    }

    const gl = this.__gl;

    const region = [0, 0, 3, 3];
    const renderstate = {
      cameraMatrix: xfo.toMat4(),
      viewports: [
        {
          region,
          viewMatrix: xfo.inverse().toMat4(),
          projectionMatrix: this.__rayCastRenderTargetProjMatrix,
          isOrthographic: true,
        },
      ],
    };

    this.__rayCastRenderTarget.bindForWriting(renderstate, true);
    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.depthMask(true);

    this.drawSceneGeomData(renderstate, mask);
    gl.finish();
    this.__rayCastRenderTarget.unbindForWriting();
    this.__rayCastRenderTarget.bindForReading();

    const geomDatas = new Float32Array(4 * 9);
    gl.readPixels(0, 0, 3, 3, gl.RGBA, gl.FLOAT, geomDatas);
    this.__rayCastRenderTarget.unbindForReading();

    // ////////////////////////////////////
    // We have a 3x3 grid of pixels, and we
    // scan them to find if any geom was in the
    // frustum.
    // Starting with the center pixel (4),
    // then left and right (3, 5)
    // Then top bottom (1, 7)
    const checkPixel = (id) => geomDatas[id * 4 + 3] != 0;
    const dataPixels = [4, 3, 5, 1, 7];
    let geomData;
    for (const pixelID of dataPixels) {
      if (checkPixel(pixelID)) {
        geomData = geomDatas.subarray(pixelID * 4, pixelID * 4 + 4);
        break
      }
    }
    if (!geomData) return

    // Mask the pass id to be only the first 6 bits of the integer.
    const passId = Math.round(geomData[0]) & (64 - 1);
    const geomItemAndDist = this.getPass(passId).getGeomItemAndDist(geomData);

    if (geomItemAndDist) {
      const intersectionPos = ray.start.add(ray.dir.scale(geomItemAndDist.dist));

      return {
        ray,
        intersectionPos,
        geomItem: geomItemAndDist.geomItem,
        dist: geomItemAndDist.dist,
        geomData,
      }
    }
  }

  // //////////////////////////
  // Rendering

  /**
   * The drawBackground method.
   * @param {any} renderstate - The renderstate value.
   */
  drawBackground(renderstate) {
    if (this.__glBackgroundMap) {
      if (!this.__glBackgroundMap.isLoaded()) return
      const gl = this.__gl;
      gl.depthMask(false);
      this.__backgroundMapShader.bind(renderstate);
      const unifs = renderstate.unifs;
      this.__glBackgroundMap.bindToUniform(renderstate, unifs.backgroundImage);
      this.__backgroundMapShaderBinding.bind(renderstate);
      gl.drawQuad();
    } else if (this.__glEnvMap && this.__glEnvMap.draw /* Note: video env maps cannot be drawn directly.*/) {
      this.__glEnvMap.draw(renderstate);
    }
  }

  /**
   * The bindGLRenderer method.
   * @param {any} renderstate - The renderstate value.
   */
  bindGLRenderer(renderstate) {
    super.bindGLBaseRenderer(renderstate);

    renderstate.envMap = this.__glEnvMap;
    renderstate.exposure = this.__exposure;
    renderstate.gamma = this.__gamma;

    const gl = this.__gl;
    const bindGLBaseRendererUnifs = renderstate.bindRendererUnifs;
    renderstate.bindRendererUnifs = (unifs) => {
      bindGLBaseRendererUnifs(unifs);

      if (this.__glEnvMap) {
        const envMapPyramid = unifs.envMapPyramid;
        if (envMapPyramid && this.__glEnvMap.bindProbeToUniform) {
          this.__glEnvMap.bindProbeToUniform(renderstate, envMapPyramid);
        } else {
          // Bind the env map src 2d image to the env map param
          const { envMapTex, envMapTexType } = unifs;
          if (envMapTex) {
            this.__glEnvMap.bindToUniform(renderstate, envMapTex, {
              textureTypeUnif: envMapTexType,
            });
          }
        }
      }
      {
        const unif = unifs.exposure;
        if (unif) {
          gl.uniform1f(unif.location, this.__exposure);
        }
      }
      {
        const unif = unifs.gamma;
        if (unif) {
          gl.uniform1f(unif.location, this.__gamma);
        }
      }
    };
  }

  /**
   * The drawScene method.
   * @param {any} renderstate - The renderstate value.
   */
  drawScene(renderstate) {
    this.bindGLRenderer(renderstate);

    if (this.__displayEnvironment) this.drawBackground(renderstate);

    super.drawScene(renderstate);
    // console.log("Draw Calls:" + renderstate['drawCalls']);

    if (this.__highlightedGeomsBufferFbo) {
      const gl = this.__gl;

      this.__highlightedGeomsBufferFbo.bindForWriting(renderstate);
      this.__highlightedGeomsBufferFbo.clear();

      // We need to explicitly clear the depth buffer,
      // It seems that sometimes the function above does
      // not do the trick.
      // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.disable(gl.BLEND);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.depthMask(true);

      this.drawHighlightedGeoms(renderstate);

      // Unbind and restore the bound fbo
      this.__highlightedGeomsBufferFbo.unbindForWriting(renderstate);

      // Now render the outlines to the entire screen.
      gl.viewport(...renderstate.region);

      // Turn this on to debug the hilight data buffer.
      // {
      //   gl.screenQuad.bindShader(renderstate);
      //   gl.screenQuad.draw(renderstate, this.__highlightedGeomsBuffer);
      // }

      this.__outlineShader.bind(renderstate);
      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // For add

      const unifs = renderstate.unifs;
      this.__highlightedGeomsBuffer.bindToUniform(renderstate, unifs.highlightDataTexture);
      gl.uniform2f(unifs.highlightDataTextureSize.location, renderstate.region[2], renderstate.region[3]);
      this.quad.bindAndDraw(renderstate);

      gl.disable(gl.BLEND);
    }

    // /////////////////////////////////////
    // // Post processing.
    // if (this.__fbo) {
    //     const gl = this.__gl;

    //     // Bind the default framebuffer
    //     gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    //     gl.viewport(...this.region);
    //     // gl.disable(gl.SCISSOR_TEST);

    //     // this.__glshaderScreenPostProcess.bind(renderstate);

    //     // const unifs = renderstate.unifs;
    //     // if ('antialiase' in unifs)
    //     //     gl.uniform1i(unifs.antialiase.location, this.__antialiase ? 1 : 0);
    //     // if ('textureSize' in unifs)
    //     //     gl.uniform2fv(unifs.textureSize.location, fbo.size);
    //     // if ('gamma' in unifs)
    //     //     gl.uniform1f(unifs.gamma.location, this.__gamma);
    //     // if ('exposure' in unifs)
    //     //     gl.uniform1f(unifs.exposure.location, this.__exposure);
    //     // if ('tonemap' in unifs)
    //     //     gl.uniform1i(unifs.tonemap.location, this.__tonemap ? 1 : 0);

    //     gl.screenQuad.bindShader(renderstate);
    //     gl.screenQuad.draw(renderstate, this.__fbo.colorTexture);

    //     // Note: if the texture is left bound, and no textures are bound to slot 0 befor rendering
    //     // more goem int he next frame then the fbo color tex is being read from and written to
    //     // at the same time. (baaaad).
    //     // Note: any textures bound at all avoids this issue, and it only comes up when we have no env
    //     // map, background or textures params in the scene. When it does happen it can be a bitch to
    //     // track down.
    //     gl.bindTexture(gl.TEXTURE_2D, null);
    // }

    this.emit('redrawOccured', {});
  }
}

shaderLibrary.setShaderModule(
  'drawItemId.glsl',
  `

#ifdef ENABLE_FLOAT_TEXTURES

attribute float instancedIds;    // instanced attribute..
uniform int instancedDraw;
uniform int transformIndex;

int getDrawItemId() {
    if(instancedDraw == 0){
       return transformIndex;
    }
    else{
       return int(instancedIds);
    }
}


#else

uniform int transformIndex;

int getDrawItemId() {
    return transformIndex;
}

#endif

`
);

shaderLibrary.setShaderModule(
  'drawItemTexture.glsl',
  `

#ifdef ENABLE_FLOAT_TEXTURES

uniform sampler2D instancesTexture;
uniform highp int instancesTextureSize;

<%include file="GLSLUtils.glsl"/>

const int pixelsPerItem = 6;

vec4 getInstanceData(int id) {
    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 0);
}

#else

uniform vec4 drawItemData;

vec4 getInstanceData(int id) {
    return drawItemData;
}

#endif


`
);

shaderLibrary.setShaderModule(
  'modelMatrix.glsl',
  `

#ifdef ENABLE_FLOAT_TEXTURES

mat4 getMatrix(sampler2D texture, int textureSize, int index) {
    // Unpack 3 x 4 matix columns into a 4 x 4 matrix.
    vec4 col0 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 1);
    vec4 col1 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 2);
    vec4 col2 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 3);
    mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));
    return transpose(result);
    // return mat4(1.0);
}

mat4 getModelMatrix(int id) {
    return getMatrix(instancesTexture, instancesTextureSize, id);
}

#else

uniform mat4 modelMatrix;

mat4 getModelMatrix(int id) {
    return modelMatrix;
}

#endif


`
);

shaderLibrary.setShaderModule(
  'materialparams.glsl',
  `

////////////////////////
// Material Param Helpers.

vec4 getColorParamValue(vec4 value, sampler2D tex, int texType, vec2 texCoord) {
    if(texType == 0){
        return toLinear(value);
    }
    else if(texType == 1 || texType == 2){
        // TODO: Use SRGB textures.
        return toLinear(texture2D(tex, texCoord));
    }
    else if(texType == 3){
        // Float HDR Texture
        return texture2D(tex, texCoord);
    }
    else
        return value;
}



float luminanceFromRGB(vec3 rgb) {
    return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;
}

float getLuminanceParamValue(float value, sampler2D tex, int texType, vec2 texCoord) {
    if(texType == 0)
        return value;
    else
        return luminanceFromRGB(texture2D(tex, texCoord).rgb);
}
`
);

shaderLibrary.setShaderModule(
  'debugColors.glsl',
  `

float modI(float a, float b) {
    float m=a-floor((a+0.5)/b)*b;
    return floor(m+0.5);
}

vec3 getDebugColor(float id) {
#ifdef GLSL_ES3
    const vec3 clusterColors[4] = vec3[4]( vec3(0.0, 0.25, 0.25), vec3(0.0, 0.85, 0.25), vec3(0.0, 0.25, 0.85), vec3(0.0, 0.85, 0.85) );
#else
    vec3 clusterColors[8];
    clusterColors[0] = vec3(0.0, 0.15, 0.15);
    clusterColors[1] = vec3(0.0, 0.85, 0.15);
    clusterColors[2] = vec3(0.0, 0.15, 0.85);
    clusterColors[3] = vec3(0.0, 0.85, 0.85);
    clusterColors[4] = vec3(0.75, 0.15, 0.15);
    clusterColors[5] = vec3(0.75, 0.85, 0.15);
    clusterColors[6] = vec3(0.75, 0.15, 0.85);
    clusterColors[7] = vec3(0.75, 0.85, 0.85);
#endif

    if(modI(id, 8.0) == 0.0)
        return clusterColors[0];
    else if(modI(id, 8.0) == 1.0)
        return clusterColors[1];
    else if(modI(id, 8.0) == 2.0)
        return clusterColors[2];
    else if(modI(id, 8.0) == 3.0)
        return clusterColors[3];
    else if(modI(id, 8.0) == 4.0)
        return clusterColors[4];
    else if(modI(id, 8.0) == 5.0)
        return clusterColors[5];
    else if(modI(id, 8.0) == 6.0)
        return clusterColors[6];
    else if(modI(id, 8.0) == 7.0)
        return clusterColors[7];

    return vec3(1,0,0);
}


`
);

class BillboardShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'BillboardShader.vertexShader',
      `
precision highp float;


<%include file="utils/quadVertexFromID.glsl"/>

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 cameraMatrix;

#ifdef ENABLE_FLOAT_TEXTURES

instancedattribute float instanceIds;

<%include file="GLSLUtils.glsl"/>
<%include file="stack-gl/transpose.glsl"/>
<%include file="utils/imageAtlas.glsl"/>

uniform sampler2D atlasBillboards_layout;
uniform vec4 atlasBillboards_desc;

uniform sampler2D instancesTexture;
uniform int instancesTextureSize;


const int cols_per_instance = 5;

mat4 getMatrix(sampler2D texture, int textureSize, int index) {
  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.
  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);
  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);
  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);
  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));
  return transpose(result);
  // return mat4(1.0);
}

mat4 getModelMatrix(int id) {
  return getMatrix(instancesTexture, instancesTextureSize, id);
}
vec4 getInstanceData(int id) {
  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 3);
}
vec4 getTintColor(int id) {
  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 4);
}


#else

uniform vec4 atlasBillboards_desc;

uniform mat4 modelMatrix;
uniform vec4 billboardData;
uniform vec4 tintColor;
uniform vec4 layoutData;

#endif

uniform int inVR;

mat4 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {
  // vec3 rr = vec3(sin(roll), 0.0, cos(roll));
  vec3 rr = vec3(0.0, 0.0, 1.0);
  vec3 ww = normalize(target - origin);
  vec3 uu = normalize(cross(rr, ww));
  vec3 vv = normalize(cross(ww, uu));

  return mat4(vec4(uu, 0.0), vec4(vv, 0.0), vec4(ww, 0.0), vec4(origin, 1.0));
}

float map(float value, float inMin, float inMax, float outMin, float outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

/* VS Outputs */
varying vec2 v_texCoord;
varying float v_alpha;
varying vec4 v_tint;

void main(void) {

#ifdef ENABLE_FLOAT_TEXTURES

  int instanceID = int(instanceIds);

  mat4 modelMatrix = getModelMatrix(instanceID);
  vec4 billboardData = getInstanceData(instanceID);
  vec4 layoutData = fetchTexel(atlasBillboards_layout, int(atlasBillboards_desc.z), int(billboardData.z));
  v_tint = getTintColor(instanceID);

#else

  v_tint = tintColor;

#endif

  vec2 quadVertex = getQuadVertexPositionFromID();


  v_texCoord = vec2(quadVertex.x, -quadVertex.y) + 0.5;
  v_alpha = billboardData.w;
  v_texCoord *= layoutData.zw;
  v_texCoord += layoutData.xy;

  float scl = billboardData.x;
  float width = layoutData.z * atlasBillboards_desc.x * scl;
  float height = layoutData.w * atlasBillboards_desc.y * scl;
  int flags = int(billboardData.y);
  bool alignedToCamera = (flags & (1<<2)) != 0;
  mat4 modelViewProjectionMatrix;
  if(alignedToCamera){
    if (inVR == 0) {
      gl_Position = (viewMatrix * modelMatrix) * vec4(0.0, 0.0, 0.0, 1.0);
      gl_Position += vec4(quadVertex.x * width, (quadVertex.y + 0.5) * height, 0.0, 0.0);
      gl_Position = projectionMatrix * gl_Position;
    } else {
      vec3 cameraPos = vec3(cameraMatrix[3][0], cameraMatrix[3][1], cameraMatrix[3][2]);
      vec3 billboardPos = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
      mat4 lookAt = calcLookAtMatrix(billboardPos, cameraPos, 0.0);
      mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * lookAt;
      gl_Position = modelViewProjectionMatrix * vec4(quadVertex.x * width, (quadVertex.y + 0.5) * height, 0.0, 1.0);
    }
  }
  else{
    modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;
    gl_Position = modelViewProjectionMatrix * vec4(quadVertex.x * width, (quadVertex.y + 0.5) * height, 0.0, 1.0);
  }

  // Note: nowhere are we setting this flag
  bool drawOnTop = (flags & (1<<3)) != 0;
  if(drawOnTop){
    gl_Position.z -= 0.05;
  }
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'BillboardShader.fragmentShader',
      `
precision highp float;

<%include file="stack-gl/gamma.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="materialparams.glsl"/>
<%include file="utils/imageAtlas.glsl"/>

uniform sampler2D atlasBillboards;

/* VS Outputs */
varying vec2 v_texCoord;
varying float v_alpha;
varying vec4 v_tint;


#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  fragColor = texture2D(atlasBillboards, v_texCoord) * v_tint;
  fragColor.a *= v_alpha;

  // fragColor.r = 1.0;
  // fragColor.a = 1.0;
  
#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
  }
}

class DepthMapShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'DepthMapShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;    //(location = 0)

uniform mat4 modelMatrix;
uniform mat4 lightViewMatrix;
uniform mat4 lightProjectionMatrix;

/* VS Outputs */
varying vec3 v_viewPos;

void main(void) {
  mat4 modelViewMatrix = lightViewMatrix * modelMatrix;
  v_viewPos = modelViewMatrix * vec4(positions, 1.0);
  gl_Position = lightProjectionMatrix * v_viewPos;
}

`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'DepthMapShader.fragmentShader',
      `
#extension GL_OES_standard_derivatives : enable
precision highp float;

uniform float near;
uniform float far;

varying vec3 v_viewPos;

float linstep(float edge0, float edge1, float value){
  return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);
}

void main(void) {
  float depth = linstep(near, far, -v_viewPos.z);
  //gl_FragColor = vec4(depth, depth, depth,  1.0);

  float dx = dFdx(depth);
  float dy = dFdy(depth);
  gl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);
}
`
    );
  }
}

class EnvProjectionShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'EnvProjectionShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;    //(location = 0)

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform vec3 projectionCenter;

<%include file="stack-gl/inverse.glsl"/>
<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
varying vec3 v_worldDir;
 
void main()
{
  int drawItemId = getDrawItemId();
  vec4 pos = vec4(positions, 1.);
  mat4 modelMatrix = getModelMatrix(drawItemId);
  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;

  gl_Position = modelViewProjectionMatrix * pos;

  vec4 worldPos = modelMatrix * pos;
  v_worldDir = worldPos.xyz - projectionCenter;
}

`
    );

    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'projectionCenter',
      defaultValue: new Vec3$1(0.0, 0.0, 1.7),
    });
    return paramDescs
  }
}

class OctahedralEnvProjectionShader extends EnvProjectionShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'OctahedralEnvProjectionShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>
<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>


uniform color envMap;
uniform sampler2D envMapTex;
uniform int envMapTexType;


uniform float exposure;

/* VS Outputs */
varying vec3 v_worldDir;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 texCoord = dirToSphOctUv(normalize(v_worldDir));
  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);

  fragColor = vec4(env.rgb/env.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

Registry.register('OctahedralEnvProjectionShader', OctahedralEnvProjectionShader);

class LatLongEnvProjectionShader extends EnvProjectionShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'LatLongEnvProjectionShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLUtils.glsl"/>
<%include file="pragmatic-pbr/envmap-equirect.glsl"/>
<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>

uniform color envMap;
uniform sampler2D envMapTex;
uniform int envMapTexType;

uniform float exposure;

/* VS Outputs */
varying vec3 v_worldDir;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  vec2 texCoord = latLongUVsFromDir(normalize(v_worldDir));
  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);
  fragColor = vec4(env.rgb/env.a, 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
  fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif


#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }
}

Registry.register('LatLongEnvProjectionShader', LatLongEnvProjectionShader);

class FatLinesShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'FatLinesShader.vertexShader',
      `
precision highp float;

instancedattribute vec2 segmentIndices;
attribute float vertexIDs;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

uniform sampler2D positionsTexture;
uniform int positionsTextureSize;

uniform float LineThickness;

/* VS Outputs */
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
varying vec2 v_texCoord;

void main(void) {
  int drawItemId = getDrawItemId();
  int vertexID = int(vertexIDs);

  mat4 modelMatrix = getModelMatrix(drawItemId);
  mat4 modelViewMatrix = viewMatrix * modelMatrix;

  int seqentialIndex_0 = int(mod(segmentIndices.x, 2.));
  int seqentialIndex_1 = int(mod(segmentIndices.y, 2.));
  int index_0 = int(segmentIndices.x) / 2;
  int index_1 = int(segmentIndices.y) / 2;

  vec3 viewPos;
  vec4 data_0 = fetchTexel(positionsTexture, positionsTextureSize, index_0);
  vec4 data_1 = fetchTexel(positionsTexture, positionsTextureSize, index_1);

  vec4 pos_0 = modelViewMatrix * vec4(data_0.xyz, 1.0);
  vec4 pos_1 = modelViewMatrix * vec4(data_1.xyz, 1.0);
  // Note: multiply the per-vertex line thickness with the line thickness uniform value;
  float lineThickness_0 = LineThickness * data_0.w;
  float lineThickness_1 = LineThickness * data_1.w;

  if(vertexID < 2){
    viewPos = pos_0.xyz;
  }
  else{
    viewPos = pos_1.xyz;
  }
  if(pos_1 != pos_0){
    vec3 segmentDir = normalize(pos_1.xyz - pos_0.xyz);
    vec3 viewVector = normalize(viewPos);

    if(vertexID < 2){
      vec3 segmentStartDir = segmentDir;
      if(seqentialIndex_0 != 0){
        //if index_0 == 0, get the last index in the line as previous
        int index_prev = (index_0 > 0) ? (index_0-1) : (positionsTextureSize-1);
        vec4 data_prev = fetchTexel(positionsTexture, positionsTextureSize, index_prev);
        vec4 pos_prev = modelViewMatrix * vec4(data_prev.xyz, 1.0);
        segmentStartDir = normalize(segmentDir + normalize(pos_0.xyz - pos_prev.xyz));
      }
      vec3 startBiTangent = normalize(cross(segmentStartDir, viewVector));
      v_viewNormal = normalize(cross(segmentStartDir, startBiTangent));
      // Move the endpoints to overlap a bit more.
      //viewPos -= vec3(segmentStartDir * lineThickness_0 * 0.25);
      if(mod(vertexIDs, 2.0) == 0.0){
        viewPos += vec3(startBiTangent * lineThickness_0);
        v_texCoord.x = 1.0;
      }
      else{
        viewPos -= vec3(startBiTangent * lineThickness_0);
        v_texCoord.x = 0.0;
      }
      v_texCoord.y = 0.0;
    }
    else{
      vec3 segmentEndDir = segmentDir;
      if(seqentialIndex_1 != 0){
        //if index_1 == numPoints-1, get the first index in the line as next
        int index_next = (index_1 < (positionsTextureSize-1)) ? (index_1+1) : 0;
        vec4 data_next = fetchTexel(positionsTexture, positionsTextureSize, index_next);
        vec4 pos_next = modelViewMatrix * vec4(data_next.xyz, 1.0);
        segmentEndDir = normalize(segmentDir + normalize(pos_next.xyz - pos_1.xyz));
      }
      vec3 endBiTangent = normalize(cross(segmentEndDir, viewVector));
      v_viewNormal = normalize(cross(segmentEndDir, endBiTangent));
      // Move the endpoints to overlap a bit more.
      //viewPos += vec3(segmentEndDir * lineThickness_1 * 0.25);
      if(mod(vertexIDs, 2.0) == 0.0){
        viewPos += vec3(endBiTangent * lineThickness_1);
        v_texCoord.x = 1.0;
      }
      else{
        viewPos -= vec3(endBiTangent * lineThickness_1);
        v_texCoord.x = 0.0;
      }
      v_texCoord.y = 1.0;
    }

    // Move the line towards the viewer by the line thickness.
    // this is to avoid depth issues when lines are rendered over meshes. 
    viewPos.z -= (lineThickness_0 + lineThickness_1) * 0.25;
  }

  v_viewPos       = viewPos;
  gl_Position     = projectionMatrix * vec4(viewPos, 1.0);
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'FatLinesShader.fragmentShader',
      `
precision highp float;

/* VS Outputs */
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
varying vec2 v_texCoord;

uniform color BaseColor;
uniform mat4 cameraMatrix;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  int debugLevel = 0;
  if(debugLevel == 0){

    vec3 viewVector = mat3(cameraMatrix) * normalize(-v_viewPos);
    vec3 normal = mat3(cameraMatrix) * v_viewNormal;
    float NdotV = dot(normalize(normal), normalize(viewVector));

    // Modulate the lighting using the texture coord so the line looks round.
    NdotV *= cos((v_texCoord.x - 0.5) * 2.0);

    vec4 color = BaseColor * NdotV;
    fragColor = vec4(color.rgb, BaseColor.a);
  }
  else{
    fragColor = vec4(v_texCoord.x, 0.0, 0.0, 1.0);
  }

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }

  bind(renderstate) {
    if (super.bind(renderstate)) {
      renderstate.supportsInstancing = false;
      return true
    }
    return false
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'Opacity', defaultValue: 1.0 });
    return paramDescs
  }
}

Registry.register('FatLinesShader', FatLinesShader);

shaderLibrary.setShaderModule(
  'stack-gl/gamma.glsl',
  `

const float gamma_const = 2.2;

float toLinear(float v) {
  return pow(v, gamma_const);
}

vec2 toLinear(vec2 v) {
  return pow(v, vec2(gamma_const));
}

vec3 toLinear(vec3 v) {
  return pow(v, vec3(gamma_const));
}

vec4 toLinear(vec4 v) {
  return vec4(toLinear(v.rgb), v.a);
}


float toGamma(float v) {
  return pow(v, 1.0 / gamma_const);
}

vec2 toGamma(vec2 v) {
  return pow(v, vec2(1.0 / gamma_const));
}

vec3 toGamma(vec3 v) {
  return pow(v, vec3(1.0 / gamma_const));
}

vec4 toGamma(vec4 v) {
  return vec4(toGamma(v.rgb), v.a);
}

float toGamma(float v, float gamma) {
  return pow(v, 1.0 / gamma);
}

vec2 toGamma(vec2 v, float gamma) {
  return pow(v, vec2(1.0 / gamma));
}

vec3 toGamma(vec3 v, float gamma) {
  return pow(v, vec3(1.0 / gamma));
}

vec4 toGamma(vec4 v, float gamma) {
  return vec4(toGamma(v.rgb, gamma), v.a);
}


`
);

class FlatSurfaceShader extends GLShader {
  constructor(gl) {
    super(gl);

    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'FlatSurfaceShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;
#ifdef ENABLE_TEXTURES
attribute vec2 texCoords;
#endif

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
varying vec3 v_viewPos;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif


void main(void) {
  int drawItemId = getDrawItemId();
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewMatrix = viewMatrix * modelMatrix;

    vec4 viewPos = (modelViewMatrix * vec4(positions, 1.0));
    gl_Position = projectionMatrix * viewPos;

    v_viewPos = viewPos.xyz;
    v_textureCoord = texCoords;
    v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'FlatSurfaceShader.fragmentShader',
      `
precision highp float;

<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>

uniform color BaseColor;

#ifdef ENABLE_TEXTURES
uniform sampler2D BaseColorTex;
uniform int BaseColorTexType;
#endif

/* VS Outputs */
varying vec3 v_viewPos;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif


#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

#ifndef ENABLE_TEXTURES
    vec4 baseColor = BaseColor;
#else
    vec4 baseColor = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);
#endif

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    fragColor = baseColor;

#ifdef ENABLE_INLINE_GAMMACORRECTION
    fragColor.rgb = toGamma(fragColor.rgb);
#endif

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );

    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'StandardSurfaceGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'StandardSurfaceSelectedGeomsShader'
  }
}

Registry.register('FlatSurfaceShader', FlatSurfaceShader);

class FlatAlphaSurfaceShader extends FlatSurfaceShader {
  static isTransparent() {
    return true
  }

  bind(renderstate, key) {
    if (renderstate.pass != 'ADD') return false
    return super.bind(renderstate, key)
  }
}

Registry.register('FlatAlphaSurfaceShader', FlatAlphaSurfaceShader);

class LinesShader extends GLShader {
  constructor(gl) {
    super(gl, 'LinesShader');
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'LinesShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */

void main(void) {
    int drawItemId = getDrawItemId();
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;
    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'LinesShader.fragmentShader',
      `
precision highp float;

uniform color BaseColor;
uniform float Opacity;

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    fragColor = BaseColor;
    fragColor.a *= Opacity;
    
#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({ name: 'BaseColor', defaultValue: new Color(1.0, 1.0, 0.5) });
    paramDescs.push({ name: 'Opacity', defaultValue: 1.0 });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'StandardSurfaceGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'StandardSurfaceSelectedGeomsShader'
  }

  static isTransparent() {
    return true
  }

  bind(renderstate, key) {
    if (renderstate.pass != 'ADD') return false
    return super.bind(renderstate, key)
  }
}

Registry.register('LinesShader', LinesShader);

class NormalsShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'NormalsShader.vertexShader',
      `
precision highp float;

instancedattribute vec3 positions;
instancedattribute vec3 normals;
attribute vec2 vertexIDs;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

uniform float normalLength;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>


/* VS Outputs */
varying float v_weight;

void main(void) {
  mat4 modelMatrix = getModelMatrix(transformIndex);
  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;
  if(vertexIDs.x == 0.0){
    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);
    v_weight = 1.0;
  }
  else{
    gl_Position = modelViewProjectionMatrix * vec4(positions+(normals*normalLength), 1.0);
    v_weight = 0.0;
  }
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'NormalsShader.fragmentShader',
      `
precision highp float;

uniform color normalColor;

/* VS Outputs */
varying float v_weight;


void main(void) {
  gl_FragColor = normalColor;
  gl_FragColor.a = v_weight;
}
`
    );
  }
}

class PointsShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'PointsShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform float PointSize;

<%include file="stack-gl/transpose.glsl"/>
<%include file="stack-gl/inverse.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */

void main(void) {
  int drawItemId = getDrawItemId();
  mat4 modelMatrix = getModelMatrix(drawItemId);
  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;
  gl_Position = modelViewProjectionMatrix * vec4(positions, 1.);
  
  gl_PointSize = PointSize;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'PointsShader.fragmentShader',
      `
precision highp float;

uniform color BaseColor;

#ifdef ENABLE_ES3
out vec4 fragColor;
#endif

void main(void) {

#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  fragColor = BaseColor;

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'PointSize', defaultValue: 2.0 });
    return paramDescs
  }
}

Registry.register('PointsShader', PointsShader);

class FatPointsShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'FatPointsShader.vertexShader',
      `
precision highp float;

instancedattribute vec3 positions;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="stack-gl/inverse.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>
<%include file="utils/quadVertexFromID.glsl"/>

uniform float PointSize;

/* VS Outputs */
varying vec2 v_texCoord;
varying vec3 v_viewPos;
varying float v_drawItemId;

void main(void) {
  int drawItemId = getDrawItemId();
  vec2 quadPointPos = getQuadVertexPositionFromID();
  v_texCoord = quadPointPos + 0.5;

  mat4 modelMatrix = getModelMatrix(drawItemId);
  mat4 modelViewMatrix = viewMatrix * modelMatrix;
  
  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);

  viewPos += vec4(vec3(quadPointPos, 0.0) * PointSize, 0.);

  // Generate a quad which is 0.5 * PointSize closer towards
  // us. This allows points to be visualized even if snug on 
  // a surface. (else they get fully clipped)
  viewPos.z += 0.5 * PointSize;

  v_drawItemId = float(getDrawItemId());
  v_viewPos = -viewPos.xyz;
  
  gl_Position = projectionMatrix * viewPos;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'FatPointsShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>

uniform color BaseColor;
uniform float Rounded;
uniform float BorderWidth;

/* VS Outputs */
varying vec2 v_texCoord;
varying vec3 v_viewPos;
varying float v_drawItemId;

#ifdef ENABLE_ES3
out vec4 fragColor;
#endif

void main(void) {

#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  float dist = length(v_texCoord - 0.5);
  if(dist > 0.5)
    discard;
  if(dist > 0.5 - (BorderWidth * 0.5))
    fragColor = vec4(0.,0.,0.,1.);
  else {
    // Modulate the lighting using the texture coord so the point looks round.
    float NdotV = cos(dist * PI);

    fragColor = BaseColor * mix(1.0, NdotV, Rounded);
  }
  

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
  }

  bind(renderstate) {
    if (super.bind(renderstate)) {
      renderstate.supportsInstancing = false;
      return true
    }
    return false
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'PointSize', defaultValue: 0.05 });
    paramDescs.push({ name: 'Rounded', defaultValue: 1.0 });
    paramDescs.push({ name: 'BorderWidth', defaultValue: 0.2 });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'FatPointsGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'FatPointsSelectedShader'
  }
}

class FatPointsGeomDataShader extends FatPointsShader {
  constructor(gl) {
    super(gl);

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'FatPointsGeomDataShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLBits.glsl"/>

uniform int floatGeomBuffer;
uniform int passId;

/* VS Outputs */
varying vec2 v_texCoord;
varying vec3 v_viewPos;
varying float v_drawItemId;

#ifdef ENABLE_ES3
out vec4 fragColor;
#endif

void main(void) {

#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  float dist = length(v_texCoord - 0.5);
  if(dist > 0.5)
    discard;
    

  float viewDist = length(v_viewPos);

  if(floatGeomBuffer != 0) {
    fragColor.r = float(passId); 
    fragColor.g = float(v_drawItemId);
    fragColor.b = 0.0;// TODO: store poly-id or something.
    fragColor.a = viewDist;
  }
  else {
    ///////////////////////////////////
    // UInt8 buffer
    fragColor.r = (mod(v_drawItemId, 256.) + 0.5) / 255.;
    fragColor.g = (floor(v_drawItemId / 256.) + 0.5) / 255.;

    // encode the dist as a 16 bit float
    vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);
    fragColor.b = float16bits.x;
    fragColor.a = float16bits.y;
  }


#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
  }
}

class FatPointsSelectedShader extends FatPointsShader {
  constructor(gl) {
    super(gl);

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'FatPointsSelectedShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="GLSLBits.glsl"/>

uniform int floatGeomBuffer;
uniform int passId;

/* VS Outputs */
varying vec2 v_texCoord;
varying vec3 v_viewPos;
varying float v_drawItemId;


<%include file="drawItemTexture.glsl"/>

#ifdef ENABLE_FLOAT_TEXTURES
vec4 getHighlightColor(int id) {
  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);
}
#else

uniform vec4 highlightColor;

vec4 getHighlightColor() {
    return highlightColor;
}

#endif


#ifdef ENABLE_ES3
out vec4 fragColor;
#endif

void main(void) {

#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  float dist = length(v_texCoord - 0.5);
  if(dist > 0.5)
    discard;
  
  int drawItemId = int(v_drawItemId + 0.5);
  fragColor = getHighlightColor(drawItemId);

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`
    );
  }
}

Registry.register('FatPointsShader', FatPointsShader);
Registry.register('FatPointsGeomDataShader', FatPointsGeomDataShader);
Registry.register('FatPointsSelectedShader', FatPointsSelectedShader);

shaderLibrary.setShaderModule(
  'pragmatic-pbr/exposure.glsl',
  `

/*
* Get an exposure using the Saturation-based Speed method.
*/
float getSaturationBasedExposure(float aperture,
                                 float shutterSpeed,
                                 float iso)
{
    float l_max = (7800.0 / 65.0) * sqrt(aperture) / (iso * shutterSpeed);
    return 1.0 / l_max;
}

//White balance middle grey we are targetting for a good scene exposure
//https://en.wikipedia.org/wiki/Middle_gray
const float MIDDLE_GREY = 0.18;

/*
* Get an exposure using the Standard Output Sensitivity method.
* Accepts an additional parameter of the target middle grey.
*/
float getStandardOutputBasedExposure(float aperture,
                                     float shutterSpeed,
                                     float iso)
{
    //https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/
    //https://en.wikipedia.org/wiki/Film_speed#Standard_output_sensitivity_.28SOS.29
    //photometric exposure magic
    //represents the properties of lens
    float q = 0.65;

    //float l_avg = (1000.0f / 65.0f) * sqrt(aperture) / (iso * shutterSpeed);
    float l_avg = (1.0 / q) * sqrt(aperture) / (iso * shutterSpeed);
    //float l_avg = sqrt(aperture) / (iso * shutterSpeed);
    return MIDDLE_GREY / l_avg;
}

`
);

shaderLibrary.setShaderModule(
  'pragmatic-pbr/tonemap-filmic.glsl',
  `

//Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75
vec3 tonemapFilmic(vec3 color) {
    vec3 x = max(vec3(0.0), color - 0.004);
    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
}

`
);

shaderLibrary.setShaderModule(
  'mattdesl/fxaa-texcoords.glsl',
  `
//To save 9 dependent texture reads, you can compute
//these in the vertex shader and use the optimized
//frag.glsl function in your frag shader. 

//This is best suited for mobile devices, like iOS.

void texcoords(vec2 fragCoord, vec2 resolution,
            out vec2 v_rgbNW, out vec2 v_rgbNE,
            out vec2 v_rgbSW, out vec2 v_rgbSE,
            out vec2 v_rgbM) {
    vec2 inverseVP = 1.0 / resolution.xy;
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

`
);

shaderLibrary.setShaderModule(
  'mattdesl/fxaa.glsl',
  `

/**
Basic FXAA implementation based on the code on geeks3d.com with the
modification that the texture2DLod stuff was removed since it's
unsupported by WebGL.
--
From:
https://github.com/mitsuhiko/webgl-meincraft
Copyright (c) 2011 by Armin Ronacher.
Some rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * The names of the contributors may not be used to endorse or
      promote products derived from this software without specific
      prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef FXAA_REDUCE_MIN
    #define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
    #define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
    #define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent 
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,
            vec2 v_rgbNW, vec2 v_rgbNE, 
            vec2 v_rgbSW, vec2 v_rgbSE, 
            vec2 v_rgbM) {
    vec4 color;
    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    
    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
    
    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
              dir * rcpDirMin)) * inverseVP;
    
    vec3 rgbA = 0.5 * (
        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

`
);

shaderLibrary.setShaderModule(
  'mattdesl/fxaa-apply.glsl',
  `

<%include file="mattdesl/fxaa.glsl"/>

vec4 apply(sampler2D tex, vec2 fragCoord, vec2 resolution) {
    mediump vec2 v_rgbNW;
    mediump vec2 v_rgbNE;
    mediump vec2 v_rgbSW;
    mediump vec2 v_rgbSE;
    mediump vec2 v_rgbM;

    //compute the texture coords
    texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
    
    //compute FXAA
    return fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}

`
);

class PostProcessing extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'PostProcessing.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>
<%include file="mattdesl/fxaa-texcoords.glsl"/>

uniform vec2 textureSize;

/* VS Outputs */
varying vec2 v_texCoord;

//texcoords computed in vertex step
//to avoid dependent texture reads
varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

 
void main()
{
    vec2 position = getQuadVertexPositionFromID();
    v_texCoord = position+0.5;
    gl_Position = vec4(position*2.0, 0.0, 1.0);

    vec2 fragCoord = v_texCoord * textureSize;
    texcoords(fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}

`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'PostProcessing.fragmentShader',
      `
precision highp float;

<%include file="pragmatic-pbr/exposure.glsl"/>
<%include file="pragmatic-pbr/tonemap-filmic.glsl"/>
<%include file="stack-gl/gamma.glsl"/>

<%include file="mattdesl/fxaa.glsl"/>

//texcoords computed in vertex step
//to avoid dependent texture reads
varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

uniform sampler2D texture;
uniform vec2 textureSize;

uniform bool antialiase;
uniform bool tonemap;
uniform float exposure;
uniform float gamma;

varying vec2 v_texCoord;

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {
    //can also use gl_FragCoord.xy
    mediump vec2 fragCoord = v_texCoord * textureSize; 

    if (antialiase) {
        fragColor = fxaa(texture, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
    } else {
        fragColor = texture2D(texture, v_texCoord);
    }
    
    //fragColor.rgb *= getStandardOutputBasedExposure(aperture, shutterSpeed, iso);
    fragColor.rgb *= exposure;
    
    if (tonemap) 
        fragColor.rgb = tonemapFilmic(fragColor.rgb);
    else
        fragColor.rgb = toGamma(fragColor.rgb, gamma);

    
    //fragColor.rgb = toGamma(fragColor.rgb, gamma);
    
    fragColor.a = 1.0;

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}`
    );
    this.finalize();
  }
}
//export default PostProcessing;

class SimpleSurfaceShader extends GLShader {
  constructor(name) {
    super(name);

    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'SimpleSurfaceShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;
attribute vec3 normals;
#ifdef ENABLE_TEXTURES
attribute vec2 texCoords;
#endif

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="stack-gl/inverse.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif
varying vec3 v_worldPos;

void main(void) {
    int drawItemId = getDrawItemId();
    v_drawItemId = float(drawItemId);
    v_geomItemData  = getInstanceData(drawItemId);

    vec4 pos = vec4(positions, 1.);
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewMatrix = viewMatrix * modelMatrix;
    vec4 viewPos    = modelViewMatrix * pos;
    gl_Position     = projectionMatrix * viewPos;

    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));
    v_viewPos       = -viewPos.xyz;
    v_viewNormal    = normalMatrix * normals;

#ifdef ENABLE_TEXTURES
    v_textureCoord  = texCoords;
    // v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y
#endif

    v_worldPos      = (modelMatrix * pos).xyz;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'SimpleSurfaceShader.fragmentShader',
      `
precision highp float;

<%include file="drawItemTexture.glsl"/>
<%include file="cutaways.glsl"/>
<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>

/* VS Outputs */
varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif
varying vec3 v_worldPos;

uniform mat4 cameraMatrix;

uniform color BaseColor;
uniform float Opacity;

#ifdef ENABLE_TEXTURES

uniform sampler2D BaseColorTex;
uniform int BaseColorTexType;
uniform sampler2D OpacityTex;
uniform int OpacityTexType;

uniform color cutColor;
vec4 getCutaway(int id) {
    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);
}

#endif

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif

void main(void) {
    int drawItemId = int(v_drawItemId + 0.5);

    int flags = int(v_geomItemData.r + 0.5);
    // Cutaways
    if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) 
    {
        vec4 cutAwayData   = getCutaway(drawItemId);
        vec3 planeNormal = cutAwayData.xyz;
        float planeDist = cutAwayData.w;
        if(cutaway(v_worldPos, planeNormal, planeDist)){
            discard;
            return;
        }
        else if(!gl_FrontFacing){
            fragColor = cutColor;
#ifndef ENABLE_ES3
            gl_FragColor = fragColor;
#endif
            return;
        }
    }

#ifndef ENABLE_TEXTURES
    vec4 baseColor      = BaseColor;
    float opacity       = baseColor.a * Opacity;
#else
    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);
    float opacity       = baseColor.a * getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, v_textureCoord);
#endif

    // Hacky simple irradiance. 
    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));
    vec3 normal = normalize(mat3(cameraMatrix) * v_viewNormal);
    float ndotv = dot(normal, viewVector);
    if(ndotv < 0.0){
        normal = -normal;
        ndotv = dot(normal, viewVector);

        // Note: these 2 lines can be used to debug inverted meshes.
        //baseColor = vec4(1.0, 0.0, 0.0, 1.0);
        //ndotv = 1.0;
    }

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    fragColor = vec4(ndotv * baseColor.rgb, opacity);

#ifdef ENABLE_INLINE_GAMMACORRECTION
    fragColor.rgb = toGamma(fragColor.rgb);
#endif

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'Opacity', defaultValue: 1.0, range: [0, 1] });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'StandardSurfaceGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'StandardSurfaceSelectedGeomsShader'
  }
}

Registry.register('SimpleSurfaceShader', SimpleSurfaceShader);

shaderLibrary.setShaderModule(
  'math/constants.glsl',
  `

#define PI 3.141592653589793
#define TwoPI (2.0 * PI)
#define HalfPI (0.5 * PI)

`
);

shaderLibrary.setShaderModule(
  'GGX_Specular.glsl',
  `


<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>
<%include file="utils/imagePyramid.glsl"/>

// uniform ImageAtlas envMap;
// see: GLImageAtlas.js: line 460.
uniform sampler2D   envMapPyramid;
uniform sampler2D   envMapPyramid_layout;
uniform vec4        envMapPyramid_desc;


vec3 sampleEnvMap(vec3 dir, float roughness) {
    return sampleImagePyramid(dirToSphOctUv(dir), roughness, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc).rgb;
}


// Borrowed heavily from here: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx

vec3 Fresnel_Schlick(float cosT, vec3 F0)
{
    return F0 + (vec3(1.0)-F0) * vec3(pow( 1.0 - cosT, 5.0));

    // for now we calculate this in the suface shader
    // float schlick = reflectance + pow((1.0-reflectance)*(1.0-dot(N,V)), 5.0);
}

float chiGGX(float v)
{
    return v > 0.0 ? 1.0 : 0.0;
}

float saturate(float v)
{
    return clamp(v, 0.0, 1.0);
}

vec3 saturate(vec3 v)
{
    return clamp(v, vec3(0.0), vec3(1.0));
}

float saturatedDot( in vec3 a, in vec3 b )
{
    return max( dot( a, b ), 0.0 );   
}

float GGX_PartialGeometryTerm(vec3 v, vec3 n, vec3 h, float alpha)
{
    float VoH2 = saturate(dot(v,h));
    float chi = chiGGX( VoH2 / saturate(dot(v,n)) );
    VoH2 = VoH2 * VoH2;
    float tan2 = ( 1.0 - VoH2 ) / VoH2;
    return (chi * 2.0) / ( 1.0 + sqrt( 1.0 + alpha * alpha * tan2 ) );
}

vec3 GGX_Specular_PrefilteredEnv(vec3 normal, vec3 viewVector, float roughness, float fresnel)
{
    vec3 reflectionVector = reflect(-viewVector, normal);
    vec3 radiance = vec3(0.0);
    float NoV = saturate(dot(normal, viewVector));

    vec3 sampleVector = reflectionVector;

    // Calculate the half vector
    vec3 halfVector = normalize(sampleVector + viewVector);
    float cosT = saturatedDot(reflectionVector, normal);
    float sinT = sqrt( 1.0 - cosT * cosT);

    // Calculate fresnel
    // vec3 fresnel = Fresnel_Schlick( saturate(dot( halfVector, viewVector ) ), F0 );
    // Geometry term
    float geometry = GGX_PartialGeometryTerm(viewVector, normal, halfVector, clamp(roughness, 0.01, 1.0)) * GGX_PartialGeometryTerm(reflectionVector, normal, halfVector, clamp(roughness, 0.01, 1.0));

    // Calculate the Cook-Torrance denominator
    float denominator = clamp( 4.0 * (NoV * saturate(dot(halfVector, normal)) + 0.05), 0.0, 1.0 );
    // kS += fresnel;

    // Accumulate the radiance
    vec3 envColor = sampleEnvMap(reflectionVector, roughness);
    radiance += envColor * geometry * fresnel * sinT / denominator;
    //radiance += envColor * fresnel; // Removing "geometry" for now until we construct a better geometric shading term

    return radiance;        
}
`
);

shaderLibrary.setShaderModule(
  'PBRSurfaceRadiance.glsl',
  `

struct MaterialParams {
    vec3 baseColor;
    float metallic;
    float roughness;
    float reflectance;
};

vec4 pbrSpecularReflectance(in MaterialParams materialParams, vec3 normal, in vec3 viewVector) {

    float NdotV = dot(normal, viewVector);
    
    // -------------------------- Specular Reflectance --------------------------
    // vec3 ks = vec3(0.0);
    // vec3 specular = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, F0, ks );
    // vec3 kd = (vec3(1.0) - ks) * vec3(1.0 - metallic);    

    float schlickFresnel = materialParams.reflectance + pow((1.0-materialParams.reflectance)*(1.0-NdotV), 5.0);

    vec3 specularReflectance = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, schlickFresnel);


    // -------------------------- Specular Occlusion --------------------------
    // Fast and quick way of reducing specular reflection in areas that are less exposed to the environment
    // A better approch is to try screen space specular occlusion but need to check performance and feasibility in webGL
    //float specularOcclusion = clamp(length(irradiance), 0.01, 1.0);    
    //specularReflectance = (specularReflectance * specularOcclusion); 

    return vec4(specularReflectance, schlickFresnel);
}


vec3 pbrSurfaceRadiance(in MaterialParams materialParams, vec3 irradiance, vec3 normal, in vec3 viewVector) {

    float NdotV = dot(normal, viewVector);
    vec3 specularReflectance;

    // -------------------------- Diffuse Reflectance --------------------------

    vec3 diffuseReflectance = materialParams.baseColor * irradiance;

    // From the Disney dielectric BRDF    
    // Need to check if this is useful for us but the implementation works based on their paper
    //diffuseReflectance = (diffuseReflectance / PI); // << [PT 18-08-2018] What did this line do??? (makes everything 3.1x darker.)
    // diffuseReflectance = vec3(mix(diffuseReflectance, diffuseReflectance * mix(0.5, 2.5, materialParams.roughness), pow(1.0 - NdotV, 5.0)));
    diffuseReflectance = vec3(mix(diffuseReflectance, diffuseReflectance * mix(0.5, 1.0, materialParams.roughness), pow(1.0 - NdotV, 5.0)));


    // -------------------------- Color at normal incidence --------------------------
    
    // Need to use 'Reflectance' here instead of 'ior'
    //vec3 F0 = vec3(abs((1.0 - ior) / (1.0 + ior)));    
    //F0 = F0 * F0;
    //F0 = mix(F0, materialParams.baseColor, materialParams.metallic);      


    // -------------------------- Specular Reflectance --------------------------
    // vec3 ks = vec3(0.0);
    // vec3 specular = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, F0, ks );
    // vec3 kd = (vec3(1.0) - ks) * vec3(1.0 - metallic);    

    float schlickFresnel = materialParams.reflectance + pow((1.0-materialParams.reflectance)*(1.0-NdotV), 5.0);

    specularReflectance = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, schlickFresnel);


    // -------------------------- Specular Occlusion --------------------------
    // Fast and quick way of reducing specular reflection in areas that are less exposed to the environment
    // A better approch is to try screen space specular occlusion but need to check performance and feasibility in webGL
    //float specularOcclusion = clamp(length(irradiance), 0.01, 1.0);    
    //specularReflectance = (specularReflectance * specularOcclusion);  
      

    // -------------------------- Metallic --------------------------
    // We need to do few things given a higher > 0 metallic value
    //      1. tint specular reflectance by the albedo color (not at grazing angles)
    //      2. almost elliminate all diffuse reflectance (in reality metals have some diffuse due to layering (i.e. dust, prints, etc.))
    //      3. set "specular" artistic value to metallic range (0.6 - 0.85)

    specularReflectance = mix(specularReflectance, specularReflectance * materialParams.baseColor, materialParams.metallic);
    diffuseReflectance = mix(diffuseReflectance, vec3(0.0,0.0,0.0), materialParams.metallic); // Leaveing at pure black for now but always need some %3 diffuse left for imperfection of pulished pure metal
    // Would be best to compute reflectace internally and set here to 0.6-0.85 for metals
    

    // -------------------------- Final color --------------------------
    // Energy conservation already taken into account in both the diffuse and specular reflectance
    vec3 radiance = diffuseReflectance + specularReflectance;

    // radiance = vec4( kd * diffuse + /*ks */ specular, 1);
    return radiance;
}
`
);

shaderLibrary.setShaderModule(
  'cutaways.glsl',
  `


const int GEOMITEM_FLAG_CUTAWAY =  1; // 1<<0;

#define RAY_EPS 0.0000001
struct Ray {
    vec3 start;
    vec3 dir;
};

float intersectRayPlane(Ray ray, Ray plane) {
    vec3 w = ray.start - plane.start;
    float D = dot(plane.dir, ray.dir);
    float N = dot(-plane.dir, w);

    if (abs(D) < RAY_EPS) {
        // segment is parallel to plane
        if (N == 0.0)
            return -1.0; // segment lies in plane
        else
            return -1.0; // no intersection
    }
    // they are not parallel
    // compute intersect param
    float sI = N / D;
    if (sI < -RAY_EPS) {
        return -1.0; // no intersection
    }
    return sI;
}


bool cutaway(vec3 worldPos, vec3 planeNormal, float planeDist) {

    vec3 planePos = planeNormal * planeDist;
    vec3 planeDir = worldPos + planePos;
    float planeOffset = dot(planeDir, planeNormal);
    if(planeOffset > 0.0){
        return true;
    }
    return  false;
}
`
);

class StandardSurfaceShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;
attribute vec3 normals;
#ifdef ENABLE_TEXTURES
attribute vec2 texCoords;
#endif

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="stack-gl/inverse.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif
varying vec3 v_worldPos;
/* VS Outputs */


void main(void) {
    int drawItemId = getDrawItemId();
    v_drawItemId = float(drawItemId);
    v_geomItemData = getInstanceData(drawItemId);

    vec4 pos = vec4(positions, 1.);
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewMatrix = viewMatrix * modelMatrix;
    vec4 viewPos    = modelViewMatrix * pos;
    gl_Position     = projectionMatrix * viewPos;

    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));
    v_viewPos       = -viewPos.xyz;
    v_viewNormal    = normalMatrix * normals;

#ifdef ENABLE_TEXTURES
    v_textureCoord  = texCoords;
#endif

    v_worldPos      = (modelMatrix * pos).xyz;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceShader.fragmentShader',
      `
precision highp float;

<%include file="math/constants.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="cutaways.glsl"/>


<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>

<%include file="GGX_Specular.glsl"/>
<%include file="PBRSurfaceRadiance.glsl"/>

/* VS Outputs */
varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying vec3 v_viewNormal;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif
varying vec3 v_worldPos;
/* VS Outputs */

uniform color cutColor;
vec4 getCutaway(int id) {
    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);
}

#ifdef ENABLE_INLINE_GAMMACORRECTION
uniform float exposure;
#endif

uniform mat4 cameraMatrix;

uniform color BaseColor;
uniform float EmissiveStrength;


#ifdef ENABLE_SPECULAR
uniform float Roughness;
uniform float Metallic;
uniform float Reflectance;
#endif

#ifdef ENABLE_TEXTURES
uniform sampler2D BaseColorTex;
uniform int BaseColorTexType;

#ifdef ENABLE_SPECULAR
uniform sampler2D RoughnessTex;
uniform int RoughnessTexType;

uniform sampler2D MetallicTex;
uniform int MetallicTexType;

uniform sampler2D ReflectanceTex;
uniform int ReflectanceTexType;

uniform sampler2D NormalTex;
uniform int NormalTexType;
// uniform float NormalScale;
#endif

uniform sampler2D EmissiveStrengthTex;
uniform int EmissiveStrengthTexType;


#endif

#ifdef ENABLE_ES3
out vec4 fragColor;

#endif

void main(void) {
    int drawItemId = int(v_drawItemId + 0.5);

    int flags = int(v_geomItemData.r + 0.5);
    // Cutaways
    if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {
        vec4 cutAwayData   = getCutaway(drawItemId);
        vec3 planeNormal = cutAwayData.xyz;
        float planeDist = cutAwayData.w;
        if(cutaway(v_worldPos, planeNormal, planeDist)){
            discard;
            return;
        }
        else if(!gl_FrontFacing){
            fragColor = cutColor;
#ifndef ENABLE_ES3
            gl_FragColor = fragColor;
#endif
            return;
        }
    }


    MaterialParams material;

#ifndef ENABLE_TEXTURES
    material.BaseColor     = BaseColor.rgb;
    float emission         = EmissiveStrength;

#ifdef ENABLE_SPECULAR
    material.roughness     = Roughness;
    material.metallic      = Metallic;
    material.reflectance   = Reflectance;
#endif

#else
    // Planar YZ projection for texturing, repeating every meter.
    // vec2 texCoord       = v_worldPos.xz * 0.2;
    vec2 texCoord          = vec2(v_textureCoord.x, 1.0 - v_textureCoord.y);
    material.baseColor     = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord).rgb;

#ifdef ENABLE_SPECULAR
    material.roughness     = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);
    material.metallic      = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);
    material.reflectance   = getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);
#endif
    float emission         = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, texCoord);
#endif

    vec3 viewNormal = normalize(v_viewNormal);
    //vec3 surfacePos = -v_viewPos;

#ifdef ENABLE_TEXTURES
#ifdef ENABLE_SPECULAR
    if(NormalTexType != 0){
        vec3 textureNormal_tangentspace = normalize(texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0);
        viewNormal = normalize(mix(viewNormal, textureNormal_tangentspace, 0.3));
    }
#endif
#endif

    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));
    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);
    if(dot(normal, viewVector) < 0.0){
        normal = -normal;
        // Note: this line can be used to debug inverted meshes.
        //material.baseColor = vec3(1.0, 0.0, 0.0);
    }

    vec3 irradiance;
#ifndef ENABLE_SPECULAR
      irradiance = sampleEnvMap(normal, 1.0);
#else
      irradiance = vec3(dot(normal, viewVector));
#endif

#ifndef ENABLE_SPECULAR
    vec3 radiance = material.baseColor * irradiance;
#else
    vec3 radiance = pbrSurfaceRadiance(material, irradiance, normal, viewVector);
#endif

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    // fragColor = vec4(material.baseColor, 1.0);
    // fragColor = vec4(material.baseColor * irradiance, 1.0);
    fragColor = vec4(radiance + (emission * material.baseColor), 1.0);

#ifdef ENABLE_INLINE_GAMMACORRECTION
    fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );

    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'Metallic', defaultValue: 0.0, range: [0, 1] });
    paramDescs.push({ name: 'Roughness', defaultValue: 0.85, range: [0, 1] });
    // F0 = reflectance and is a physical property of materials
    // It also has direct relation to IOR so we need to dial one or the other
    // For simplicity sake, we don't need to touch this value as metalic can dictate it
    // such that non metallic is mostly around (0.01-0.025) and metallic around (0.7-0.85)
    paramDescs.push({ name: 'Reflectance', defaultValue: 0.1, range: [0, 1] });
    paramDescs.push({
      name: 'EmissiveStrength',
      defaultValue: 0.0,
      range: [0, 1],
    });

    // paramDescs.push({ name: 'TexCoordScale', defaultValue: 1.0, texturable: false });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'StandardSurfaceGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'StandardSurfaceSelectedGeomsShader'
  }
}

Registry.register('StandardSurfaceShader', StandardSurfaceShader);

shaderLibrary.setShaderModule(
  'GLSLBits.glsl',
  `
    
/////////////////////////////////////////////////////////////////
// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js
float shift_right(float v, float amt) {
  v = floor(v) + 0.5;
  return floor(v / exp2(amt));
}
float shift_left(float v, float amt) {
  return floor(v * exp2(amt) + 0.5);
}

float mask_last(float v, float bits) {
  return mod(v, shift_left(1.0, bits));
}
float extract_bits(float num, float from, float to) {
  from = floor(from + 0.5);
  to = floor(to + 0.5);
  return mask_last(shift_right(num, from), to - from);
}

/////////////////////////////////////////////////////////////////
// https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl

const vec4 bitEnc = vec4(1.,255.,65025.,16581375.);
const vec4 bitDec = 1./bitEnc;
vec4 EncodeFloatRGBA (float v) {
    vec4 enc = bitEnc * v;
    enc = fract(enc);
    enc -= enc.yzww * vec2(1./255., 0.).xxxy;
    return enc;
}
float DecodeFloatRGBA (vec4 v) {
    return dot(v, bitDec);
}



/////////////////////////////////////////////////////////////////
// https://gist.github.com/Flexi23/1713774
// 
vec2 encode16BitFloatInto2xUInt8(float v){
    vec2 c = vec2(0.);

    int signum = (v >= 0.) ? 128 : 0;
    v = abs(v);
    int exponent = 15;
    float limit = 1024.; // considering the bias from 2^-5 to 2^10 (==1024)
    for(int exp = 15; exp > 0; exp--){
        if( v < limit){
            limit /= 2.;
            exponent--;
        }
    }

    float rest;
    if(exponent == 0){
        rest = v / limit / 2.;      // "subnormalize" implicite preceding 0. 
    }else{
        rest = (v - limit)/limit;   // normalize accordingly to implicite preceding 1.
    }

    int mantissa = int(rest * 2048.);   // 2048 = 2^11 for the (split) 11 bit mantissa
    int msb = mantissa / 256;           // the most significant 3 bits go into the lower part of the first byte
    int lsb = mantissa - msb * 256;     // there go the other 8 bit of the lower significance

    c.x = float(signum + exponent * 8 + msb) / 255.;    // color normalization for texture2D
    c.y = float(lsb) / 255.;

    if(v >= 2048.){
        c.y = 1.;
    }

    return c;
}

float decode16BitFloatFrom2xUInt8(vec2 c){
    float v = 0.;

    int ix = int(c.x*255.); // 1st byte: 1 bit signum, 4 bits exponent, 3 bits mantissa (MSB)
    int iy = int(c.y*255.); // 2nd byte: 8 bit mantissa (LSB)

    int s = (c.x >= 0.5) ? 1 : -1;
    ix = (s > 0) ? ix - 128 : ix;   // remove the signum bit from exponent
    int iexp = ix / 8;              // cut off the last 3 bits of the mantissa to select the 4 exponent bits
    int msb = ix - iexp * 8;        // subtract the exponent bits to select the 3 most significant bits of the mantissa

    int norm = (iexp == 0) ? 0 : 2048;          // distinguish between normalized and subnormalized numbers
    int mantissa = norm + msb * 256 + iy;       // implicite preceding 1 or 0 added here
    norm = (iexp == 0) ? 1 : 0;                 // normalization toggle
    float exponent = pow( 2., float(iexp + norm) - 16.); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa 
    v = float( s * mantissa ) * exponent;

    return v;
}


// TODO : Encoding Float32 to 4x UInt8
// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js
// http://ultraist.hatenablog.com/entry/20110608/1307539319

`
);

class StandardSurfaceGeomDataShader extends GLShader {
  constructor(gl, floatGeomBuffer) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceGeomDataShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>


varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying float v_drawItemID;
varying vec3 v_worldPos;

void main(void) {
  int drawItemId = getDrawItemId();
  v_drawItemId = float(drawItemId);
  v_geomItemData = getInstanceData(drawItemId);

  vec4 pos = vec4(positions, 1.);
  mat4 modelMatrix = getModelMatrix(drawItemId);
  mat4 modelViewMatrix = viewMatrix * modelMatrix;
  vec4 viewPos = modelViewMatrix * pos;
  gl_Position = projectionMatrix * viewPos;

  v_viewPos = -viewPos.xyz;

  v_drawItemID = float(getDrawItemId());
  
  v_worldPos      = (modelMatrix * pos).xyz;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceGeomDataShader.fragmentShader',
      `
precision highp float;

<%include file="drawItemTexture.glsl"/>
<%include file="cutaways.glsl"/>
<%include file="GLSLBits.glsl"/>

uniform int floatGeomBuffer;
uniform int passId;

uniform color cutColor;
vec4 getCutaway(int id) {
    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);
}

varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
varying float v_drawItemID;
varying vec3 v_worldPos;


#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {
  int drawItemId = int(v_drawItemId + 0.5);

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif

  int flags = int(v_geomItemData.r + 0.5);
  // Cutaways
  if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {
      vec4 cutAwayData   = getCutaway(drawItemId);
      vec3 planeNormal = cutAwayData.xyz;
      float planeDist = cutAwayData.w;
      if(cutaway(v_worldPos, planeNormal, planeDist)){
          discard;
          return;
      }
      else if(!gl_FrontFacing){
          fragColor = cutColor;
  #ifndef ENABLE_ES3
          gl_FragColor = fragColor;
  #endif
          return;
      }
  }

    float dist = length(v_viewPos);

    if(floatGeomBuffer != 0) {
        fragColor.r = float(passId); 
        fragColor.g = float(v_drawItemID);
        fragColor.b = 0.0;// TODO: store poly-id or something.
        fragColor.a = dist;
    }
    else {
        ///////////////////////////////////
        // UInt8 buffer
        fragColor.r = (mod(v_drawItemID, 256.) + 0.5) / 255.;
        fragColor.g = (floor(v_drawItemID / 256.) + 0.5) / 255.;


        // encode the dist as a 16 bit float
        vec2 float16bits = encode16BitFloatInto2xUInt8(dist);
        fragColor.b = float16bits.x;
        fragColor.a = float16bits.y;
    }


#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
  }
}

Registry.register('StandardSurfaceGeomDataShader', StandardSurfaceGeomDataShader);

class StandardSurfaceSelectedGeomsShader extends GLShader {
  constructor(gl, floatGeomBuffer) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceSelectedGeomsShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

varying float v_drawItemId;

void main(void) {
    int drawItemId = getDrawItemId();
    v_drawItemId = float(drawItemId);
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewMatrix = viewMatrix * modelMatrix;
    vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);
    gl_Position = projectionMatrix * viewPos;

}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'StandardSurfaceSelectedGeomsShader.fragmentShader',
      `
precision highp float;

varying float v_drawItemId;


<%include file="drawItemTexture.glsl"/>

#ifdef ENABLE_FLOAT_TEXTURES
vec4 getHighlightColor(int id) {
  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);
}
#else

uniform vec4 highlightColor;

vec4 getHighlightColor() {
    return highlightColor;
}

#endif

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    int drawItemId = int(v_drawItemId + 0.5);
    fragColor = getHighlightColor(drawItemId);

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
  }
}

Registry.register('StandardSurfaceSelectedGeomsShader', StandardSurfaceSelectedGeomsShader);

class TransparentSurfaceShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'TransparentSurfaceShader.vertexShader',
      `
precision highp float;


attribute vec3 positions;
attribute vec3 normals;

uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

<%include file="stack-gl/transpose.glsl"/>
<%include file="stack-gl/inverse.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
varying vec3 v_viewPos;
varying vec3 v_viewNormal;

varying vec3 v_worldPos;
/* VS Outputs */

void main(void) {
    int drawItemId = getDrawItemId();

    vec4 geomItemData = getInstanceData(drawItemId);

    vec4 pos = vec4(positions, 1.);
    mat4 modelMatrix = getModelMatrix(drawItemId);
    mat4 modelViewMatrix = viewMatrix * modelMatrix;
    vec4 viewPos    = modelViewMatrix * pos;
    gl_Position     = projectionMatrix * viewPos;

    v_worldPos      = (modelMatrix * pos).xyz;

    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));
    v_viewPos       = -viewPos.xyz;
    v_viewNormal    = normalMatrix * normals;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'TransparentSurfaceShader.fragmentShader',
      `
precision highp float;

#ifdef ENABLE_INLINE_GAMMACORRECTION
<%include file="stack-gl/gamma.glsl"/>
#endif
<%include file="GLSLUtils.glsl"/>

/* VS Outputs */
varying vec3 v_viewPos;
varying vec3 v_viewNormal;

varying vec3 v_worldPos;
/* VS Outputs */


#ifdef ENABLE_INLINE_GAMMACORRECTION
uniform float exposure;
#endif

uniform mat4 cameraMatrix;
uniform float planeDist;
uniform float planeAngle;

uniform color BaseColor;
uniform float Opacity;

#ifdef ENABLE_SPECULAR
<%include file="math/constants.glsl"/>
<%include file="GGX_Specular.glsl"/>
<%include file="PBRSurfaceRadiance.glsl"/>
uniform float Roughness;
uniform float Metallic;
uniform float Reflectance;
#endif

#ifdef __ENABLE_TEXTURES
uniform sampler2D BaseColorTex;
uniform bool BaseColorTexType;

uniform sampler2D OpacityTex;
uniform bool OpacityTexType;

uniform sampler2D RoughnessTex;
uniform bool RoughnessTexType;

uniform sampler2D ReflectanceTex;
uniform bool ReflectanceTexType;

uniform sampler2D NormalTex;
uniform bool NormalTexType;
uniform float NormalScale;


#endif

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

    MaterialParams material;

#ifndef __ENABLE_TEXTURES
    material.baseColor      = BaseColor.rgb;
    float opacity           = Opacity;

#ifdef ENABLE_SPECULAR
    material.roughness      = Roughness;
    material.metallic       = Metallic;
    material.reflectance    = Reflectance;
#endif

#else
    // Planar YZ projection for texturing, repeating every meter.
    // vec2 texCoord        = v_worldPos.xz * 0.2;
    vec2 texCoord           = vec2(v_textureCoord.x, 1.0 - v_textureCoord.y);
    material.baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord).rgb;
    material.roughness      = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);
    material.metallic       = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);
    material.reflectance    = Reflectance;//getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);

    float opacity           = getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, texCoords);
#endif

#ifndef ENABLE_SPECULAR
    gl_FragColor = vec4(material.baseColor.rgb, opacity);
#else

    vec3 viewNormal = normalize(v_viewNormal);
    //vec3 surfacePos = -v_viewPos;

#ifdef __ENABLE_TEXTURES
    if(NormalTexType != 0){
        vec3 textureNormal_tangentspace = normalize(texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0);
        viewNormal = normalize(mix(viewNormal, textureNormal_tangentspace, 0.3));
    }
#endif

    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));
    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);
    if(dot(normal, viewVector) < 0.0){
        normal = -normal;
        // Note: this line can be used to debug inverted meshes.
        //material.baseColor = vec3(1.0, 0.0, 0.0);
    }

    vec4 specularReflectance = pbrSpecularReflectance(material, normal, viewVector);

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif

    fragColor = vec4(specularReflectance.rgb, mix(opacity, 1.0, specularReflectance.a));

#endif

#ifdef ENABLE_INLINE_GAMMACORRECTION
    fragColor.rgb = toGamma(fragColor.rgb * exposure);
#endif

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );
    this.finalize();
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    paramDescs.push({ name: 'Opacity', defaultValue: 1.0, range: [0, 1] });
    paramDescs.push({ name: 'Roughness', defaultValue: 0.85 });
    // F0 = reflectance and is a physical property of materials
    // It also has direct relation to IOR so we need to dial one or the other
    // For simplicity sake, we don't need to touch this value as metalic can dictate it
    // such that non metallic is mostly around (0.01-0.025) and metallic around (0.7-0.85)
    paramDescs.push({ name: 'Reflectance', defaultValue: 0.0001 });

    // paramDescs.push({ name: 'TexCoordScale', defaultValue: 1.0, texturable: false });
    return paramDescs
  }

  static getGeomDataShaderName() {
    return 'StandardSurfaceGeomDataShader'
  }

  static getSelectedShaderName() {
    return 'StandardSurfaceSelectedGeomsShader'
  }

  static isTransparent() {
    return true
  }

  bind(renderstate, key) {
    if (renderstate.pass != 'ADD') return false
    return super.bind(renderstate, key)
  }
}

Registry.register('TransparentSurfaceShader', TransparentSurfaceShader);

class ScreenSpaceShader extends GLShader {
  constructor(gl) {
    super(gl);

    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'ScreenSpaceShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;
#ifdef ENABLE_TEXTURES
attribute vec2 texCoords;
#endif

<%include file="stack-gl/transpose.glsl"/>
<%include file="drawItemId.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="modelMatrix.glsl"/>

/* VS Outputs */
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif


void main(void) {
  int drawItemId = getDrawItemId();
    mat4 modelMatrix = getModelMatrix(drawItemId);

    gl_Position = (modelMatrix * vec4(positions, 1.0));

    v_textureCoord = texCoords;
    v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'ScreenSpaceShader.fragmentShader',
      `
precision highp float;

<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>

uniform color BaseColor;

#ifdef ENABLE_TEXTURES
uniform sampler2D BaseColorTex;
uniform int BaseColorTexType;
#endif

/* VS Outputs */
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif


#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

#ifndef ENABLE_TEXTURES
    vec4 baseColor = BaseColor;
#else
    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);
#endif

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif
    fragColor = baseColor;

#ifdef ENABLE_INLINE_GAMMACORRECTION
    fragColor.rgb = toGamma(fragColor.rgb);
#endif

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}
`
    );

    this.finalize();
  }

  static isOverlay() {
    return true
  }

  static getParamDeclarations() {
    const paramDescs = super.getParamDeclarations();
    paramDescs.push({
      name: 'BaseColor',
      defaultValue: new Color(1.0, 1.0, 0.5),
    });
    return paramDescs
  }

  static getGeomDataShaderName() {
    // TODO: Provide a geom data shader for overlay items.
    return null
  }

  static getSelectedShaderName() {
    // TODO: Provide a geom data shader for overlay items.
    return null
  }
}

Registry.register('ScreenSpaceShader', ScreenSpaceShader);

class ToolIconShader extends FlatSurfaceShader {
  constructor(gl) {
    super(gl);
    this.invisibleToGeomBuffer = true;
  }
}

Registry.register('ToolIconShader', ToolIconShader);

class UnpackLDRAlphaImageShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'UnpackLDRAlphaImageShader.vertexShader',
      `
precision highp float;

<%include file="utils/quadVertexFromID.glsl"/>

/* VS Outputs */
varying vec2 v_texCoord;
 
void main()
{
    vec2 position = getQuadVertexPositionFromID();
    v_texCoord = position+0.5;
    gl_Position = vec4(position*2.0, 0.0, 1.0);
}
`
    );
    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'UnpackLDRAlphaImageShader.fragmentShader',
      `
precision highp float;

varying vec2 v_texCoord;
uniform sampler2D ldrSampler;
uniform sampler2D alphaSampler;

float luminanceFromRGB(vec3 rgb) {
    return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;
}


#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {

#ifndef ENABLE_ES3
    vec4 fragColor;
#endif

    fragColor = vec4(texture2D(ldrSampler, v_texCoord).rgb, luminanceFromRGB(texture2D(alphaSampler, v_texCoord).rgb));

#ifndef ENABLE_ES3
    gl_FragColor = fragColor;
#endif
}

`
    );
  }
}

class WireShader extends GLShader {
  constructor(gl) {
    super(gl);
    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(
      'WireShader.vertexShader',
      `
precision highp float;

attribute vec3 positions;    //(location = 0)

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

/* VS Outputs */

void main(void) {
    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;
    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);

    // Apply the perspective transform, and then move the vertices
    //  towards the camera by a tiny little bit...
    gl_Position.z -= 0.001 / gl_Position.w;
    //gl_Position.z *= 0.999;
}
`
    );

    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(
      'WireShader.fragmentShader',
      `
precision highp float;

uniform color wireColor;

#ifdef ENABLE_ES3
    out vec4 fragColor;
#endif
void main(void) {
#ifdef ENABLE_ES3
    gl_FragColor = color;
#else
    fragColor = color;
#endif  
}
`
    );
  }
}

const GLGeomItemChangeType = {
  GEOMITEM_CHANGED: 0,
  GEOM_CHANGED: 1,
  VISIBILITY_CHANGED: 2,
  HIGHLIGHT_CHANGED: 3,
};

/** This class abstracts the rendering of a collection of geometries to screen.
 * @extends EventEmitter
 */
class GLGeomItem extends EventEmitter {
  /**
   * Create a GL geom item.
   * @param {any} gl - The gl value.
   * @param {any} geomItem - The geomItem value.
   * @param {any} glGeom - The glGeom value.
   * @param {any} id - The id value.
   * @param {number} flags - The flags value.
   */
  constructor(gl, geomItem, glGeom, id, flags = null) {
    super();
    this.gl = gl;
    this.geomItem = geomItem;
    this.glGeom = glGeom;
    this.id = id;
    this.flags = flags;
    this.visible = this.geomItem.isVisible();
    this.culled = false;

    // if(glGeom.__numTriangles) {
    //   numSceneMeshTriangles += glGeom.__numTriangles
    //   console.log(this.geomItem.getName(), glGeom.__numTriangles, numSceneMeshTriangles)
    // }

    this.updateVisibility = this.updateVisibility.bind(this);
    this.destroy = this.destroy.bind(this);

    if (!gl.floatTexturesSupported) {
      this.geomMatrixDirty = true;
      this.geomMatrixChanged = () => {
        this.geomMatrixDirty = true;
        this.updateGeomMatrix();
      };
    } else {
      this.geomMatrixChanged = () => {
        this.emit('updated', { type: GLGeomItemChangeType.GEOMITEM_CHANGED });
      };
    }

    this.cutAwayChanged = () => {
      this.emit('updated', { type: GLGeomItemChangeType.GEOMITEM_CHANGED });
    };
    this.highlightChanged = () => {
      this.emit('updated', { type: GLGeomItemChangeType.HIGHLIGHT_CHANGED });
      this.emit('highlightChanged');
    };
    this.glGeomUpdated = () => {
      this.emit('updated', { type: GLGeomItemChangeType.GEOM_CHANGED });
    };

    this.geomItem.getParameter('GeomMat').on('valueChanged', this.geomMatrixChanged);
    this.geomItem.on('visibilityChanged', this.updateVisibility);
    this.geomItem.on('cutAwayChanged', this.cutAwayChanged);
    this.geomItem.on('highlightChanged', this.highlightChanged);
    this.glGeom.on('updated', this.glGeomUpdated);

    if (!gl.floatTexturesSupported) {
      const materialId = 0;
      let flags = 0;
      if (this.geomItem.isCutawayEnabled()) {
        const GEOMITEM_FLAG_CUTAWAY = 1; // 1<<0;
        flags |= GEOMITEM_FLAG_CUTAWAY;
      }
      this.geomData = [flags, materialId, 0, 0];
    }
  }

  /**
   * The getGeomItem method.
   * @return {any} - The return value.
   */
  getGeomItem() {
    return this.geomItem
  }

  /**
   * The getGLGeom method.
   * @return {any} - The return value.
   */
  getGLGeom() {
    return this.glGeom
  }

  /**
   * The isVisible method.
   * @return {any} - The return value.
   */
  isVisible() {
    return this.geomItem.isVisible()
  }

  /**
   * The getId method.
   * @return {any} - The return value.
   */
  getId() {
    return this.id
  }

  /**
   * The getFlags method.
   * @return {any} - The return value.
   */
  getFlags() {
    return this.flags
  }

  /**
   * The updateVisibility method.
   */
  updateVisibility() {
    const geomVisible = this.geomItem.isVisible();
    const visible = geomVisible && !this.culled;
    if (this.visible != visible) {
      this.visible = visible;
      this.emit('visibilityChanged', { visible });
      this.emit('updated', {});
    }
  }

  /**
   * The setCullState method.
   * @param {any} culled - The culled value.
   */
  setCullState(culled) {
    this.culled = culled;
    this.updateVisibility();
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    const gl = this.gl;
    const unifs = renderstate.unifs;

    if (!gl.floatTexturesSupported) {
      const modelMatrixunif = unifs.modelMatrix;
      if (modelMatrixunif) {
        if (this.geomMatrixDirty) {
          this.modelMatrixArray = this.geomItem.getGeomMat4().asArray();
        }
        gl.uniformMatrix4fv(modelMatrixunif.location, false, this.modelMatrixArray);
      }
      const drawItemDataunif = unifs.drawItemData;
      if (drawItemDataunif) {
        gl.uniform4f(drawItemDataunif.location, this.geomData);
      }
    }

    const unif = unifs.transformIndex;
    if (unif) {
      gl.uniform1i(unif.location, this.id);
    }
    return true
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.geomItem.getParameter('GeomMat').off('valueChanged', this.geomMatrixChanged);
    this.geomItem.off('visibilityChanged', this.updateVisibility);
    this.geomItem.off('cutAwayChanged', this.cutAwayChanged);
    this.geomItem.off('highlightChanged', this.highlightChanged);
    this.glGeom.off('updated', this.glGeomUpdated);
  }
}

const pixelsPerItem = 6; // The number of RGBA pixels per draw item.

/** This class abstracts the rendering of a collection of geometries to screen.
 * @extends GLPass
 */
class GLStandardGeomsPass extends GLPass {
  /**
   * Create a GL pass.
   */
  constructor() {
    super();

    this.__drawItems = [undefined];
    this.__drawItemsIndexFreeList = [];
    this.__dirtyItemIndices = [];
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);

    this.__renderer.registerPass(
      (treeItem) => {
        if (treeItem instanceof GeomItem) {
          const geomItem = treeItem;
          if (!geomItem.getMetadata('glgeomItem')) {
            const checkGeom = (geomItem) => {
              if (this.filterGeomItem(geomItem)) {
                const geomParam = geomItem.getParameter('Geometry');
                if (geomParam.getValue() == undefined) {
                  // we will add this geomItem once it receives its geom.
                  // TODO: what happens if the item is removed from the tree
                  // and then geom assigned? (maybe impossible with our tools)
                  // e.g. a big asset loaded, added to the tree, then removed again
                  // The geoms will get assigned after the tree is removed.
                  const geomAssigned = () => {
                    this.addGeomItem(geomItem);
                    geomParam.off('valueChanged', geomAssigned);
                  };
                  geomParam.on('valueChanged', geomAssigned);
                } else {
                  this.addGeomItem(geomItem);
                }
                return true
              } else {
                return false
              }
            };

            if (geomItem.getParameter('Material').getValue() == undefined) {
              console.warn('Scene item :' + geomItem.getPath() + ' has no material');
              // TODO: listen for when the material is assigned.(like geoms below)
              return false
            } else {
              return checkGeom(geomItem)
            }
          } else {
            return false
          }
        } else {
          return false
        }
      },
      (treeItem) => {
        if (treeItem instanceof GeomItem && treeItem.getMetadata('glgeomItem')) {
          return this.removeGeomItem(treeItem)
        }
        return false
      }
    );
  }

  /**
   * The filterGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {any} - The return value.
   */
  filterGeomItem(geomItem) {
    return true
  }

  /**
   * The addShader method.
   * @param {any} material - The material value.
   * @return {any} - The return value.
   */
  addShader(material) {
    return this.__renderer.getOrCreateShader(material.getShaderName())
  }

  /**
   * The constructShaders method.
   * Given a material, generate the various shaders required to render objects
   * using this material. There should always be at least a single glshader
   * and optionally a glgeomdatashader for rendering the goem data buffer
   * and a glselectedshader for rendering selection hilghlights
   * @param {string} shaderName - The name of the base shader.
   * @return {object} - The object containing the shader instances.
   */
  constructShaders(shaderName) {
    let glgeomdatashader;
    let glselectedshader;

    const glshader = this.__renderer.getOrCreateShader(shaderName);
    if (glshader.constructor.getGeomDataShaderName()) {
      glgeomdatashader = this.__renderer.getOrCreateShader(glshader.constructor.getGeomDataShaderName());
    }
    if (glshader.constructor.getSelectedShaderName()) {
      glselectedshader = this.__renderer.getOrCreateShader(glshader.constructor.getSelectedShaderName());
    }
    return {
      glshader,
      glgeomdatashader,
      glselectedshader,
    }
  }

  /**
   * The addMaterial method.
   * @param {any} material - The material value.
   * @return {any} - The return value.
   */
  addMaterial(material) {
    let glmaterial = material.getMetadata('glmaterial');
    if (glmaterial) {
      return glmaterial
    }
    const glshader = this.__renderer.getOrCreateShader(material.getShaderName());
    glmaterial = new GLMaterial(this.__gl, material, glshader);
    glmaterial.on('updated', (event) => {
      this.__renderer.requestRedraw();
    });
    material.setMetadata('glmaterial', glmaterial);

    return glmaterial
  }

  /**
   * The addGeom method.
   * @param {any} geom - The geom value.
   * @return {any} - The return value.
   */
  addGeom(geom) {
    let glgeom = geom.getMetadata('glgeom');
    if (glgeom) {
      glgeom.addRef(this);
      return glgeom
    }
    const gl = this.__gl;
    if (geom instanceof Mesh || geom instanceof MeshProxy) {
      glgeom = new GLMesh(gl, geom);
    } else if (geom instanceof Lines || geom instanceof LinesProxy) {
      glgeom = new GLLines(gl, geom);
    } else if (geom instanceof Points || geom instanceof PointsProxy) {
      glgeom = new GLPoints(gl, geom);
    } else {
      throw new Error('Unsupported geom type:' + geom.constructor.name)
    }
    geom.setMetadata('glgeom', glgeom);
    glgeom.addRef(this);
    return glgeom
  }

  /**
   * The removeGeom method.
   * @param {any} geom - The geom value.
   */
  removeGeom(geom) {
    let glgeom = geom.getMetadata('glgeom');
    if (glgeom) {
      glgeom.removeRef(this); // Should result in a destroy
      return glgeom
    }
  }

  /**
   * The addGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {any} - The return value.
   */
  addGeomItem(geomItem) {
    // const material = geomItem.getParameter('Material').getValue()
    // let glmaterialGeomItemSets = this.addMaterial(material);
    // if (!glmaterialGeomItemSets)
    //     return;
    const glgeom = this.addGeom(geomItem.getParameter('Geometry').getValue());

    const flags = 1;
    let index;
    // Use recycled indices if there are any available...
    if (this.__drawItemsIndexFreeList.length > 0) {
      index = this.__drawItemsIndexFreeList.pop();
    } else {
      index = this.__drawItems.length;
      this.__drawItems.push(null);
    }
    this.__dirtyItemIndices.push(index);

    const gl = this.__gl;
    const glgeomItem = new GLGeomItem(gl, geomItem, glgeom, index, flags);
    geomItem.setMetadata('glgeomItem', glgeomItem);

    glgeomItem.on('updated', (event) => {
      switch (event.type) {
        case GLGeomItemChangeType.GEOMITEM_CHANGED:
          if (this.__dirtyItemIndices.indexOf(index) != -1) return
          this.__dirtyItemIndices.push(index);
          break
        case GLGeomItemChangeType.GEOM_CHANGED:
        case GLGeomItemChangeType.VISIBILITY_CHANGED:
          break
        case GLGeomItemChangeType.HIGHLIGHT_CHANGED:
          if (this.__dirtyItemIndices.indexOf(index) != -1) return
          this.__dirtyItemIndices.push(index);
          this.__renderer.requestRedraw();
          return
      }
      this.__renderer.drawItemChanged();
    });

    this.__drawItems[index] = glgeomItem;

    // Note: before the renderer is disabled, this is a  no-op.
    this.__renderer.requestRedraw();

    geomItem.setMetadata('glpass', this);
    return glgeomItem
  }

  /**
   * The removeGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {any} - The return value.
   */
  removeGeomItem(geomItem) {
    if (geomItem.getMetadata('glpass') != this) return

    // TODO: Finish of ref counting GLGeoms.
    // I'm not sure if we ever clean up the renderer properly
    // when geoms are removed. (Run Instancing test and see if
    // GLGeom is ever destoryed when instance counts drop to zero.)
    // this.removeGeom(geomItem.getParameter('Geometry').getValue())

    const glgeomItem = geomItem.getMetadata('glgeomItem');

    const index = glgeomItem.getId();
    this.__drawItems[index] = null;
    this.__drawItemsIndexFreeList.push(index);

    // TODO: review signal disconnections
    // glgeomItem.transformChanged.disconnectScope(this);

    // this.emit('renderTreeUpdated', {});
    this.__renderer.requestRedraw();

    geomItem.getMetadata('glpass');
    geomItem.deleteMetadata('glgeomItem');

    return glgeomItem
  }

  // removeMaterial(material) {
  //     const glshaderMaterials = this.__glshadermaterials[material.hash];
  //     if (!glshaderMaterials || glshaderMaterials != material.getMetadata('glshaderMaterials')) {
  //         console.warn("Material not found in pass");
  //         return;
  //     }

  //     const glmaterialGeomItemSets = material.getMetadata('glmaterialGeomItemSets');
  //     glshaderMaterials.removeMaterialGeomItemSets(glmaterialGeomItemSets);
  // };

  /**
   * The removeGLGeom method.
   * @param {any} geomItemMapping - The geomItemMapping value.
   * @param {any} materialGeomMapping - The materialGeomMapping value.
   */
  removeGLGeom(geomItemMapping, materialGeomMapping) {
    const index = materialGeomMapping.geomItemMappings.indexOf(geomItemMapping);
    materialGeomMapping.geomItemMappings.splice(index, 1);

    // Note: the GLMAterial cleans up iself now...
    // if(materialGeomMapping.geomItemMappings.length == 0 && !this.__explicitShader){
    //     this.removeMaterialGeomMapping(materialGeomMapping.glmaterial);
    // }
  }

  // ////////////////////////////////////////////////////////
  // / GeomItem IDs

  /**
   * The getGeomItem method.
   * @param {any} id - The id value.
   * @return {any} - The return value.
   */
  getGeomItem(id) {
    if (id >= this.__drawItems.length) {
      console.warn('Invalid Draw Item id:' + id + ' NumItems:' + (this.__drawItems.length - 1));
      return undefined
    }
    return this.__drawItems[id]
  }

  // ////////////////////////////////////////////////
  // Data Uploading

  /**
   * The __populateDrawItemDataArray method.
   * @param {any} geomItem - The geomItem value.
   * @param {number} index - The index value.
   * @param {any} dataArray - The dataArray value.
   * @private
   */
  __populateDrawItemDataArray(geomItem, index, dataArray) {
    const stride = pixelsPerItem * 4; // The number of floats per draw item.
    const offset = index * stride;

    // /////////////////////////
    // Geom Item Params
    const materialId = 0;
    let flags = 0;
    if (geomItem.isCutawayEnabled()) {
      const GEOMITEM_FLAG_CUTAWAY = 1; // 1<<0;
      flags |= GEOMITEM_FLAG_CUTAWAY;
    }

    const pix0 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 0) * 4);
    pix0.set(flags, materialId, 0, 0);

    // /////////////////////////
    // Geom Matrix
    const mat4 = geomItem.getGeomMat4();
    const pix1 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 4) * 4);
    const pix2 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 8) * 4);
    const pix3 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 12) * 4);
    pix1.set(mat4.xAxis.x, mat4.yAxis.x, mat4.zAxis.x, mat4.translation.x);
    pix2.set(mat4.xAxis.y, mat4.yAxis.y, mat4.zAxis.y, mat4.translation.y);
    pix3.set(mat4.xAxis.z, mat4.yAxis.z, mat4.zAxis.z, mat4.translation.z);

    // /////////////////////////
    // Hilight
    const pix4 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 16) * 4);
    if (geomItem.isHighlighted()) {
      const highlight = geomItem.getHighlight();
      pix4.set(highlight.r, highlight.g, highlight.b, highlight.a);
    }

    // /////////////////////////
    // Cutaway
    const pix5 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 20) * 4);
    if (geomItem.isCutawayEnabled()) {
      const cutAwayVector = geomItem.getCutVector();
      const cutAwayDist = geomItem.getCutDist();
      // console.log(geomItem.getName(), geomItem.isCutawayEnabled(), flags, pix0.toString())
      pix5.set(cutAwayVector.x, cutAwayVector.y, cutAwayVector.z, cutAwayDist);
    }
  }

  /**
   * The newItemsReadyForLoading method.
   * @return {any} - The return value.
   */
  newItemsReadyForLoading() {
    return this.__dirtyItemIndices.length > 0
  }

  /**
   * The uploadGeomItems method.
   */
  uploadGeomItems() {
    const gl = this.__gl;
    if (!gl.floatTexturesSupported) {
      // Pull on the GeomXfo params. This will trigger the lazy evaluation of the operators in the scene.
      const len = this.__dirtyItemIndices.length;
      for (let i = 0; i < len; i++) {
        const drawItem = this.__drawItems[this.__dirtyItemIndices[i]];
        if (drawItem) {
          drawItem.updateGeomMatrix();
        }
      }
      this.__dirtyItemIndices = [];
      // this.emit('renderTreeUpdated', {});
      return
    }

    let size = Math.round(Math.sqrt(this.__drawItems.length * pixelsPerItem) + 0.5);
    // Only support power 2 textures. Else we get strange corruption on some GPUs
    // in some scenes.
    size = MathFunctions.nextPow2(size);
    // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
    // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
    if (size % pixelsPerItem != 0) size += pixelsPerItem - (size % pixelsPerItem);

    if (!this.__drawItemsTexture) {
      this.__drawItemsTexture = new GLTexture2D(gl, {
        format: 'RGBA',
        type: 'FLOAT',
        width: size,
        height: size,
        filter: 'NEAREST',
        wrap: 'CLAMP_TO_EDGE',
        mipMapped: false,
      });
      this.__drawItemsTexture.clear();
    } else if (this.__drawItemsTexture.width != size) {
      this.__drawItemsTexture.resize(size, size);
      this.__dirtyItemIndices = Array((size * size) / pixelsPerItem)
        .fill()
        .map((v, i) => i);
    }

    gl.bindTexture(gl.TEXTURE_2D, this.__drawItemsTexture.glTex);
    const typeId = this.__drawItemsTexture.getTypeID();

    for (let i = 0; i < this.__dirtyItemIndices.length; i++) {
      const indexStart = this.__dirtyItemIndices[i];
      const yoffset = Math.floor((indexStart * pixelsPerItem) / size);
      let indexEnd = indexStart + 1;
      for (let j = i + 1; j < this.__dirtyItemIndices.length; j++) {
        const index = this.__dirtyItemIndices[j];
        if (Math.floor((index * pixelsPerItem) / size) != yoffset) {
          break
        }
        if (index != indexEnd) {
          break
        }
        indexEnd++;
      }

      // TODO: for contiguous blcoks, we create larger arrays and populate
      // and upload them in one step.
      const uploadCount = indexEnd - indexStart;
      const xoffset = (indexStart * pixelsPerItem) % size;
      const width = pixelsPerItem * uploadCount;
      const height = 1;
      const dataArray = new Float32Array(pixelsPerItem * 4 * uploadCount); // 4==RGBA pixels.

      for (let j = indexStart; j < indexEnd; j++) {
        const glgeomItem = this.__drawItems[j];
        // When an item is deleted, we allocate its index to the free list
        // and null this item in the array. skip over null items.
        if (!glgeomItem) continue
        this.__populateDrawItemDataArray(glgeomItem.getGeomItem(), j - indexStart, dataArray);
      }

      if (typeId == gl.FLOAT) {
        this.__drawItemsTexture.populate(dataArray, width, height, xoffset, yoffset, false);
      } else {
        const unit16s = MathFunctions.convertFloat32ArrayToUInt16Array(dataArray);
        this.__drawItemsTexture.populate(unit16s, width, height, xoffset, yoffset, false);
      }

      i += uploadCount - 1;
    }

    this.__dirtyItemIndices = [];
  }

  /**
   * The finalize method.
   */
  finalize() {
    if (this.__dirtyItemIndices.length == 0) return
    this.uploadGeomItems();
  }

  /**
   * The bind method.
   * @param {any} renderstate - The renderstate value.
   * @return {any} - The return value.
   */
  bind(renderstate) {
    const gl = this.__gl;
    const unifs = renderstate.unifs;
    if (this.__drawItemsTexture && unifs.instancesTexture) {
      this.__drawItemsTexture.bindToUniform(renderstate, unifs.instancesTexture);
      gl.uniform1i(unifs.instancesTextureSize.location, this.__drawItemsTexture.width);
    }
    return true
  }

  /**
   * The bindShader method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} glshader - The glshader value.
   * @return {any} - The return value.
   */
  bindShader(renderstate, glshader) {
    if (!glshader.bind(renderstate)) return false
    if (!this.bind(renderstate)) return false
    return true
  }

  /**
   * The bindMaterial method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} glmaterial - The glmaterial value.
   * @param {any} warnMissingUnifs - The warnMissingUnifs value.
   * @return {any} - The return value.
   */
  bindMaterial(renderstate, glmaterial, warnMissingUnifs) {
    return glmaterial.bind(renderstate, warnMissingUnifs)
  }
}

/** This class abstracts the rendering of a collection of geometries to screen.
 * @extends EventEmitter
 * @private
 */
class GLGeomItemSet extends EventEmitter {
  /**
   * Create a GL geom item set.
   * @param {any} gl - The gl value.
   * @param {any} glgeom - The glgeom value.
   */
  constructor(gl, glgeom) {
    super();
    this.gl = gl;
    this.glgeom = glgeom;
    this.glgeomItems = [];
    this.glgeomItems_freeIndices = [];
    this.glgeomItemEventHandlers = [];
    this.drawIdsArray = null;
    this.drawIdsBuffer = null;
    this.drawIdsBufferDirty = true;

    this.highlightedIdsArray = null;
    this.highlightedIdsBuffer = null;
    this.highlightedIdsBufferDirty = true;

    // this.inverted = false;

    this.visibleItems = [];
    this.highlightedItems = [];
  }

  /**
   * The getGLGeom method.
   * @return {any} - The return value.
   */
  getGLGeom() {
    return this.glgeom
  }

  /**
   * The getDrawCount method.
   * @return {any} - The return value.
   */
  getDrawCount() {
    return this.visibleItems.length
  }

  /**
   * The addGeomItem method.
   * @param {any} glgeomItem - The glgeomItem value.
   */
  addGeomItem(glgeomItem) {
    let index;
    if (this.glgeomItems_freeIndices.length > 0) {
      index = this.glgeomItems_freeIndices.pop();
    } else {
      index = this.glgeomItems.length;
      this.glgeomItems.push(null);
    }
    if (glgeomItem.visible) {
      this.visibleItems.push(index);
      this.emit('drawCountChanged', { count: 1 });
    }
    if (glgeomItem.getGeomItem().isHighlighted()) {
      this.highlightedItems.push(index);
      this.highlightedIdsBufferDirty = true;
    }

    const eventHandlers = {};

    eventHandlers.highlightChanged = () => {
      if (glgeomItem.getGeomItem().isHighlighted()) {
        // Note: highlightChanged is fired when the color changes
        // or another hilight is added over the top. We avoid
        // adding the same index again here. (TODO: use Set?)
        if (this.highlightedItems.indexOf(index) != -1) return
        this.highlightedItems.push(index);
      } else {
        this.highlightedItems.splice(this.highlightedItems.indexOf(index), 1);
      }
      // console.log("highlightChanged:", glgeomItem.getGeomItem().getName(), glgeomItem.getGeomItem().isHighlighted(), this.highlightedItems)
      this.highlightedIdsBufferDirty = true;
    };
    glgeomItem.on('highlightChanged', eventHandlers.highlightChanged);
    eventHandlers.visibilityChanged = (event) => {
      const visible = event.visible;
      if (visible) {
        this.visibleItems.push(index);
        this.emit('drawCountChanged', { count: 1 });
      } else {
        this.visibleItems.splice(this.visibleItems.indexOf(index), 1);
        this.emit('drawCountChanged', { count: -1 });
      }
      this.drawIdsBufferDirty = true;
    };
    glgeomItem.on('visibilityChanged', eventHandlers.visibilityChanged);

    this.glgeomItems[index] = glgeomItem;
    this.glgeomItemEventHandlers[index] = eventHandlers;

    this.drawIdsBufferDirty = true;
  }

  /**
   * The removeGeomItem method.
   * @param {any} glgeomItem - The glgeomItem value.
   */
  removeGeomItem(glgeomItem) {
    const index = this.glgeomItems.indexOf(glgeomItem);
    const eventHandlers = this.glgeomItemEventHandlers[index];
    glgeomItem.off('highlightChanged', eventHandlers.highlightChanged);
    glgeomItem.off('visibilityChanged', eventHandlers.visibilityChanged);

    this.glgeomItems[index] = null;
    this.glgeomItemEventHandlers[index] = null;

    this.glgeomItems_freeIndices.push(index);

    if (glgeomItem.visible) {
      this.visibleItems.splice(this.visibleItems.indexOf(index), 1);
      this.emit('drawCountChanged', { count: -1 });
    }
    const highlighted = glgeomItem.getGeomItem().isHighlighted();
    if (highlighted) {
      this.highlightedItems.splice(this.highlightedItems.indexOf(index), 1);
    }
    this.drawIdsBufferDirty = true;
    // console.log("removeGeomItem:", glgeomItem.getGeomItem().getName(), this.glgeomItems.length)
    if (this.glgeomItems.length == 0) {
      this.destroy();
    }
  }

  // ////////////////////////////////////
  // Instance Ids

  /**
   * The updateDrawIDsBuffer method.
   * The culling system will specify a subset of the total number of items for
   * drawing.
   */
  updateDrawIDsBuffer() {
    const gl = this.gl;
    if (!gl.floatTexturesSupported) {
      this.drawIdsBufferDirty = false;
      return
    }
    if (this.drawIdsBuffer && this.glgeomItems.length != this.drawIdsArray.length) {
      this.gl.deleteBuffer(this.drawIdsBuffer);
      this.drawIdsBuffer = null;
    }
    if (!this.drawIdsBuffer) {
      this.drawIdsArray = new Float32Array(this.glgeomItems.length);
      this.drawIdsBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.drawIdsBuffer);
    }

    // Collect all visible geom ids into the instanceIds array.
    // Note: the draw count can be less than the number of instances
    // we re-use the same buffer and simply invoke fewer draw calls.
    this.visibleItems.forEach((index, tgtIndex) => {
      this.drawIdsArray[tgtIndex] = this.glgeomItems[index].getId();
    });
    gl.bindBuffer(gl.ARRAY_BUFFER, this.drawIdsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.drawIdsArray, gl.STATIC_DRAW);

    this.drawIdsBufferDirty = false;
  }

  // ////////////////////////////////////
  // Selected Items

  /**
   * The updateHighlightedIDsBuffer method.
   */
  updateHighlightedIDsBuffer() {
    const gl = this.gl;
    if (!gl.floatTexturesSupported) {
      this.highlightedIdsBufferDirty = false;
      return
    }
    if (this.highlightedIdsBuffer && this.glgeomItems.length != this.highlightedIdsArray.length) {
      this.gl.deleteBuffer(this.highlightedIdsBuffer);
      this.highlightedIdsBuffer = null;
    }

    // Collect all visible geom ids into the instanceIds array.
    // Note: the draw count can be less than the number of instances
    // we re-use the same buffer and simply invoke fewer draw calls.
    if (!this.highlightedIdsArray || this.highlightedItems.length > this.highlightedIdsArray.length) {
      this.highlightedIdsArray = new Float32Array(this.highlightedItems.length);
      if (this.highlightedIdsBuffer) {
        gl.deleteBuffer(this.highlightedIdsBuffer);
        this.highlightedIdsBuffer = null;
      }
    }

    this.highlightedItems.forEach((index, tgtIndex) => {
      this.highlightedIdsArray[tgtIndex] = this.glgeomItems[index].getId();
    });

    if (!this.highlightedIdsBuffer) {
      this.highlightedIdsBuffer = gl.createBuffer();
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, this.highlightedIdsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.highlightedIdsArray, gl.STATIC_DRAW);

    this.highlightedIdsBufferDirty = false;
  }

  // ////////////////////////////////////
  // Drawing

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.visibleItems.length == 0) {
      return
    }
    if (this.drawIdsBufferDirty) {
      this.updateDrawIDsBuffer();
    }

    this.__bindAndRender(renderstate, this.visibleItems, this.drawIdsBuffer);
  }

  /**
   * The drawHighlighted method.
   * @param {any} renderstate - The renderstate value.
   */
  drawHighlighted(renderstate) {
    if (this.highlightedItems.length == 0) {
      return
    }
    if (this.highlightedIdsBufferDirty) {
      this.updateHighlightedIDsBuffer();
    }

    this.__bindAndRender(renderstate, this.highlightedItems, this.highlightedIdsBuffer);
  }

  /**
   * The __bindAndRender method.
   * @param {any} renderstate - The renderstate value.
   * @param {any} itemIndices - The itemIndices value.
   * @param {any} drawIdsBuffer - The drawIdsBuffer value.
   * @private
   */
  __bindAndRender(renderstate, itemIndices, drawIdsBuffer) {
    const gl = this.gl;
    const unifs = renderstate.unifs;

    // Lazy unbinding. We can have situations where we have many materials
    // all bound to the same geom. e.g. lots of billboards
    // We can avoid the expensive re-binding of geoms with a simple check.
    if (renderstate.glgeom != this.glgeom) {
      this.glgeom.bind(renderstate);
      renderstate.glgeom = this.glgeom;
    }

    if (!gl.floatTexturesSupported || !gl.drawElementsInstanced || !renderstate.supportsInstancing) {
      if (renderstate.unifs.instancedDraw) {
        gl.uniform1i(renderstate.unifs.instancedDraw.location, 0);
      }
      itemIndices.forEach((index) => {
        this.glgeomItems[index].bind(renderstate);
        renderstate.bindViewports(unifs, () => {
          this.glgeom.draw(renderstate);
        });
      });
    } else {
      // console.log("draw:"+ this.drawIdsArray);

      // Specify an instanced draw to the shader so it knows how
      // to retrieve the modelmatrix.
      gl.uniform1i(renderstate.unifs.instancedDraw.location, 1);

      // The instanced transform ids are bound as an instanced attribute.
      const location = renderstate.attrs.instancedIds.location;
      gl.enableVertexAttribArray(location);
      gl.bindBuffer(gl.ARRAY_BUFFER, drawIdsBuffer);
      gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 1 * 4, 0);
      gl.vertexAttribDivisor(location, 1); // This makes it instanced

      renderstate.bindViewports(unifs, () => {
        this.glgeom.drawInstanced(itemIndices.length);
      });
    }
  }

  /**
   * The destroy is called by the system to cause explicit resources cleanup.
   * Users should never need to call this method directly.
   */
  destroy() {
    this.emit('destructing', {});
  }
}

/** Class representing GL shader materials.
 * @private
 */
class GLShaderMaterials {
  /**
   * Create a GL shader material.
   * @param {any} glshader - The glshader value.
   * @param {any} glgeomdatashader - The glgeomdatashader value.
   * @param {any} glselectedshader - The glselectedshader value.
   */
  constructor(shaders) {
    this.glshader = shaders.glshader;
    this.glgeomdatashader = shaders.glgeomdatashader;
    this.glselectedshader = shaders.glselectedshader;
    this.glmaterialGeomItemSets = [];
  }

  /**
   * The findMaterialGeomItemSets method.
   * @param {any} glmaterial - The glmaterial value.
   * @return {any} - The return value.
   */
  findMaterialGeomItemSets(glmaterial) {
    for (const matGeomItemSet of this.glmaterialGeomItemSets) {
      if (matGeomItemSet.glmaterial == glmaterial) return matGeomItemSet
    }
  }

  /**
   * The addMaterialGeomItemSets method.
   * @param {any} glmaterialGeomItemSets - The glmaterialGeomItemSets value.
   */
  addMaterialGeomItemSets(glmaterialGeomItemSets) {
    this.glmaterialGeomItemSets.push(glmaterialGeomItemSets);
  }

  /**
   * The removeMaterialGeomItemSets method.
   * @param {any} glmaterialGeomItemSets - The glmaterialGeomItemSets value.
   */
  removeMaterialGeomItemSets(glmaterialGeomItemSets) {
    const index = this.glmaterialGeomItemSets.indexOf(glmaterialGeomItemSets);
    this.glmaterialGeomItemSets.splice(index, 1);
  }

  /**
   * The getMaterialGeomItemSets method.
   * @return {any} - The return value.
   */
  getMaterialGeomItemSets() {
    return this.glmaterialGeomItemSets
  }
}

/** Class representing GL material geom item sets.
 * @private
 */
class GLMaterialGeomItemSets {
  /**
   * Create a GL material geom item set.
   * @param {any} glmaterial - The glmaterial value.
   */
  constructor(glmaterial = undefined) {
    this.glmaterial = glmaterial;
    this.geomItemSets = [];
    this.drawCount = 0;
    this.visibleInGeomDataBuffer = glmaterial.getMaterial().visibleInGeomDataBuffer;
    this.__drawCountChanged = this.__drawCountChanged.bind(this);
  }

  /**
   * The getGLMaterial method.
   * @return {any} - The return value.
   */
  getGLMaterial() {
    return this.glmaterial
  }

  /**
   * The __drawCountChanged method.
   * @param {any} change - The change value.
   * @private
   */
  __drawCountChanged(change) {
    this.drawCount += change.count;
  }

  /**
   * The addGeomItemSet method.
   * @param {any} geomItemSet - The geomItemSet value.
   */
  addGeomItemSet(geomItemSet) {
    if (this.geomItemSets.indexOf(geomItemSet) == -1) {
      this.geomItemSets.push(geomItemSet);
      geomItemSet.on('drawCountChanged', this.__drawCountChanged);
    } else {
      console.warn('geomItemSet already added to GLMaterialGeomItemSets');
    }
  }

  /**
   * The removeGeomItemSet method.
   * @param {any} geomItemSet - The geomItemSet value.
   */
  removeGeomItemSet(geomItemSet) {
    const index = this.geomItemSets.indexOf(geomItemSet);
    this.geomItemSets.splice(index, 1);
    geomItemSet.off('drawCountChanged', this.__drawCountChanged);
  }

  /**
   * The removeGeomItemSet method.
   * @param {any} glgeom - The glgeom value.
   * @return {any} - The return value.
   */
  findGeomItemSet(glgeom) {
    for (const geomItemSet of this.geomItemSets) {
      if (geomItemSet.getGLGeom() == glgeom) return geomItemSet
    }
    return null
  }

  /**
   * The getGeomItemSets method.
   * @return {any} - The return value.
   */
  getGeomItemSets() {
    return this.geomItemSets
  }
}

/** Class representing a GL opaque geoms pass.
 * @extends GLStandardGeomsPass
 * @private
 */
class GLOpaqueGeomsPass extends GLStandardGeomsPass {
  /**
   * Create a GL opaque geoms pass.
   */
  constructor() {
    super();

    // Optimized Render Tree
    // Structured like so for efficient render traversial.
    // {GLShaders}[GLMaterials][GLGeoms][GLGeomItems]
    this.__glshadermaterials = {};
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);
  }

  // ///////////////////////////////////
  // Bind to Render Tree

  /**
   * The filterGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {boolean} - The return value.
   */
  filterGeomItem(geomItem) {
    const material = geomItem.getParameter('Material').getValue();
    const shaderClass = material.getShaderClass();
    if (shaderClass) {
      if (shaderClass.isTransparent()) return false
      if (shaderClass.isOverlay()) return false

      const baseColorParam = material.getParameter('BaseColor');
      if (baseColorParam && baseColorParam.getValue().a < 1.0) return false

      return true
    }
    return false
  }

  /**
   * The addGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {boolean} - The return value.
   */
  addGeomItem(geomItem) {
    const material = geomItem.getParameter('Material').getValue();
    const shaderName = material.getShaderName();
    const shaders = this.constructShaders(shaderName);
    let glshader = shaders.glshader;
    let glgeomdatashader = shaders.glgeomdatashader;
    let glselectedshader = shaders.glselectedshader;
    // const glshader = this.__renderer.getOrCreateShader(shaderName)
    // if (glshader.constructor.getGeomDataShaderName())
    //   glgeomdatashader = this.__renderer.getOrCreateShader(
    //     glshader.constructor.getGeomDataShaderName()
    //   )
    // if (glshader.constructor.getSelectedShaderName())
    //   glselectedshader = this.__renderer.getOrCreateShader(
    //     glshader.constructor.getSelectedShaderName()
    //   )
    const glmaterial = this.addMaterial(material);
    const glgeomItem = super.addGeomItem(geomItem);

    let glshaderMaterials = this.__glshadermaterials[shaderName];
    if (!glshaderMaterials) {
      glshaderMaterials = new GLShaderMaterials(shaders);
      this.__glshadermaterials[shaderName] = glshaderMaterials;
    }

    let glmaterialGeomItemSets = glshaderMaterials.findMaterialGeomItemSets(glmaterial);
    if (!glmaterialGeomItemSets) {
      glmaterialGeomItemSets = new GLMaterialGeomItemSets(glmaterial);
      glshaderMaterials.addMaterialGeomItemSets(glmaterialGeomItemSets);
    }

    let geomItemSet = glmaterialGeomItemSets.findGeomItemSet(glgeomItem.glGeom);
    if (!geomItemSet) {
      geomItemSet = new GLGeomItemSet(this.__gl, glgeomItem.glGeom);
      glmaterialGeomItemSets.addGeomItemSet(geomItemSet);
    }

    geomItem.setMetadata('geomItemSet', geomItemSet);

    geomItemSet.addGeomItem(glgeomItem);

    return true
  }

  /**
   * The removeGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {boolean} - The return value.
   */
  removeGeomItem(geomItem) {
    const glgeomItem = super.removeGeomItem(geomItem);
    if (!glgeomItem) return false

    const geomItemSet = geomItem.getMetadata('geomItemSet');
    if (geomItemSet) {
      // Note: for now leave the material and geom in place. Multiple
      // GeomItems can reference a given material/geom, so we simply wait
      // for them to be destroyed.
      geomItemSet.removeGeomItem(glgeomItem);
      geomItem.deleteMetadata('geomItemSet');
    }

    return true
  }

  /**
   * The removeMaterial method.
   * @param {any} material - The material value.
   */
  removeMaterial(material) {
    const glshaderMaterials = this.__glshadermaterials[material.hash];
    if (!glshaderMaterials || glshaderMaterials != material.getMetadata('glshaderMaterials')) {
      console.warn('Material not found in pass');
      return
    }

    const glmaterialGeomItemSets = material.getMetadata('glmaterialGeomItemSets');
    glshaderMaterials.removeMaterialGeomItemSets(glmaterialGeomItemSets);
  }

  /**
   * The __traverseTreeAndDraw method.
   * @param {any} renderstate - The renderstate value.
   * @private
   */
  __traverseTreeAndDraw(renderstate) {
    for (const shaderName in this.__glshadermaterials) {
      const glshaderMaterials = this.__glshadermaterials[shaderName];
      const glshader = glshaderMaterials.glshader;
      if (this.bindShader(renderstate, glshader)) {
        const glmaterialGeomItemSets = glshaderMaterials.getMaterialGeomItemSets();
        for (const glmaterialGeomItemSet of glmaterialGeomItemSets) {
          if (glmaterialGeomItemSet.drawCount == 0) continue
          if (this.bindMaterial(renderstate, glmaterialGeomItemSet.getGLMaterial(), true)) {
            const glgeomitemsets = glmaterialGeomItemSet.getGeomItemSets();
            for (const gldrawitemset of glgeomitemsets) {
              gldrawitemset.draw(renderstate);
            }
          }
        }
      }
      glshader.unbind(renderstate);
    }

    if (renderstate.glgeom) {
      renderstate.glgeom.unbind(renderstate);
    }
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.newItemsReadyForLoading()) this.finalize();

    const gl = this.__gl;
    gl.disable(gl.BLEND);

    gl.disable(gl.CULL_FACE);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);

    this.__traverseTreeAndDraw(renderstate);
  }

  /**
   * The drawHighlightedGeoms method.
   * @param {any} renderstate - The renderstate value.
   */
  drawHighlightedGeoms(renderstate) {
    const gl = this.__gl;
    gl.disable(gl.CULL_FACE); // 2-sided rendering.

    // for (let glshaderMaterials of this.__glshadermaterials) {
    for (const shaderName in this.__glshadermaterials) {
      const glshaderMaterials = this.__glshadermaterials[shaderName];
      if (!glshaderMaterials.glselectedshader) continue
      if (!this.bindShader(renderstate, glshaderMaterials.glselectedshader)) continue

      const glmaterialGeomItemSets = glshaderMaterials.getMaterialGeomItemSets();
      for (const glmaterialGeomItemSet of glmaterialGeomItemSets) {
        const glgeomitemsets = glmaterialGeomItemSet.getGeomItemSets();
        for (const gldrawitemset of glgeomitemsets) {
          gldrawitemset.drawHighlighted(renderstate);
        }
      }
    }

    if (renderstate.glgeom) {
      renderstate.glgeom.unbind(renderstate);
    }
  }

  /**
   * The getGeomItemAndDist method.
   * @param {any} geomData - The geomData value.
   * @return {any} - The return value.
   */
  getGeomItemAndDist(geomData) {
    let itemId;
    let dist;
    const gl = this.__gl;
    if (gl.floatGeomBuffer) {
      itemId = Math.round(geomData[1]);
      dist = geomData[3];
    } else {
      itemId = geomData[0] + (geomData[1] << 8);
      dist = MathFunctions.decode16BitFloatFrom2xUInt8([geomData[2], geomData[3]]);
    }

    const glgeomItem = this.__drawItems[itemId];
    if (glgeomItem) {
      return {
        geomItem: glgeomItem.getGeomItem(),
        dist,
      }
    }
  }

  /**
   * The drawGeomData method.
   * @param {any} renderstate - The renderstate value.
   */
  drawGeomData(renderstate) {
    if (this.newItemsReadyForLoading()) this.finalize();

    const gl = this.__gl;
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);

    // eslint-disable-next-line guard-for-in
    for (const shaderName in this.__glshadermaterials) {
      const glshaderMaterials = this.__glshadermaterials[shaderName];
      if (!glshaderMaterials.glgeomdatashader) continue
      if (!this.bindShader(renderstate, glshaderMaterials.glgeomdatashader)) continue

      {
        const unif = renderstate.unifs.floatGeomBuffer;
        if (unif) {
          gl.uniform1i(unif.location, gl.floatGeomBuffer ? 1 : 0);
        }
      }
      {
        const unif = renderstate.unifs.passId;
        if (unif) {
          gl.uniform1i(unif.location, this.__passIndex);
        }
      }

      const glmaterialGeomItemSets = glshaderMaterials.getMaterialGeomItemSets();
      for (const glmaterialGeomItemSet of glmaterialGeomItemSets) {
        if (glmaterialGeomItemSet.drawCount == 0 || !glmaterialGeomItemSet.visibleInGeomDataBuffer) continue
        // Sometimes materials contain params required for rendering.
        // e.g. PointSize.
        // Note: avoid generating warnings for missing uniforms.
        if (this.bindMaterial(renderstate, glmaterialGeomItemSet.getGLMaterial(), false)) {
          const glgeomitemsets = glmaterialGeomItemSet.getGeomItemSets();
          for (const gldrawitemset of glgeomitemsets) {
            gldrawitemset.draw(renderstate);
          }
        }
      }
    }

    if (renderstate.glgeom) {
      renderstate.glgeom.unbind(renderstate);
    }
  }
}

GLRenderer.registerPass(GLOpaqueGeomsPass, PassType.OPAQUE);

/** Class representing a GL transparent geoms pass.
 * @extends GLStandardGeomsPass
 * @private
 */
class GLTransparentGeomsPass extends GLStandardGeomsPass {
  /**
   * Create GL transparent geoms pass.
   */
  constructor() {
    super();
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);

    this.transparentItems = [];
    this.freeList = [];
    this.visibleItems = [];
    this.prevSortCameraPos = new Vec3$1(999, 999, 999);
    this.resort = false;
  }

  /**
   * The init method.
   * @param {any} geomItem - The geomItem value.
   * @return {boolean} - The return value.
   */
  filterGeomItem(geomItem) {
    const material = geomItem.getParameter('Material').getValue();
    const shaderClass = material.getShaderClass();
    if (shaderClass) {
      if (shaderClass.isTransparent()) return true
      if (shaderClass.isOverlay()) return false

      const baseColorParam = material.getParameter('BaseColor');
      if (baseColorParam && baseColorParam.getValue().a < 0.999) return true
    }
    return false
  }

  /**
   * The addGeomItem method.
   * @param {any} geomItem - The geomItem value.
   */
  addGeomItem(geomItem) {
    const material = geomItem.getParameter('Material').getValue();
    const shaderName = material.getShaderName();
    const shaders = this.constructShaders(shaderName);

    // @todo - make sure we remove materials and GeomItems from the base pass.
    // This code will leak memory for these classes as we are not cleaning them up.
    const glmaterial = this.addMaterial(material);
    const glgeomitem = super.addGeomItem(geomItem);

    const visibilityChanged = (event) => {
      if (event.visible) {
        this.visibleItems.push(item);
      } else {
        const index = this.visibleItems.indexOf(item);
        this.visibleItems.splice(index, 1);
      }
    };
    const geomXfoChanged = () => {
      this.resort = true;
    };
    geomItem.on('visibilityChanged', visibilityChanged);
    geomItem.getParameter('GeomMat').on('valueChanged', geomXfoChanged);

    const item = {
      geomItem,
      shaders,
      glmaterial,
      glgeomitem,
      visibilityChanged,
      geomXfoChanged,
    };
    let itemindex;
    if (this.freeList.length > 0) itemindex = this.freeList.pop();
    else itemindex = this.transparentItems.length;
    this.transparentItems[itemindex] = item;
    geomItem.setMetadata('itemIndex', itemindex);
    if (geomItem.isVisible()) {
      this.visibleItems.push(item);
    }

    // force a resort.
    this.resort = true;
  }

  /**
   * The removeGeomItem method.
   * @param {any} geomItem - The geomItem value.
   */
  removeGeomItem(geomItem) {
    if (!super.removeGeomItem(geomItem)) return

    const itemindex = geomItem.getMetadata('itemIndex');
    const item = this.transparentItems[itemindex];

    geomItem.off('visibilityChanged', item.visibilityChanged);
    geomItem.getParameter('GeomMat').off('valueChanged', item.geomXfoChanged);

    this.transparentItems[itemindex] = null;
    this.freeList.push(itemindex);

    const visibleindex = this.visibleItems.indexOf(item);
    if (visibleindex != -1) this.visibleItems.splice(visibleindex, 1);
  }

  /**
   * The sortItems method.
   * @param {any} viewPos - The viewPos value.
   */
  sortItems(viewPos) {
    for (const transparentItem of this.visibleItems) {
      const mat4 = transparentItem.glgeomitem.geomItem.getGeomMat4();
      transparentItem.dist = mat4.translation.distanceTo(viewPos);
    }
    this.visibleItems.sort((a, b) => (a.dist > b.dist ? -1 : a.dist < b.dist ? 1 : 0));
    this.prevSortCameraPos = viewPos;
    this.resort = false;
  }

  _drawItem(renderstate, transparentItem, cache) {
    if (cache.currentglMaterial != transparentItem.glmaterial) {
      cache.currentglMaterial = transparentItem.glmaterial;
      if (!cache.currentglMaterial.bind(renderstate)) {
        return
      }
    }

    const glgeomitem = transparentItem.glgeomitem;
    if (cache.currentglGeom != glgeomitem.glGeom) {
      cache.currentglGeom = glgeomitem.glGeom;
      if (!cache.currentglGeom.bind(renderstate)) {
        return
      }
    }

    if (glgeomitem.bind(renderstate)) {
      // Specify an non-instanced draw to the shader
      if (renderstate.unifs.instancedDraw) {
        const gl = this.__gl;
        gl.uniform1i(renderstate.unifs.instancedDraw.location, 0);
        gl.disableVertexAttribArray(renderstate.attrs.instancedIds.location);
      }

      renderstate.bindViewports(renderstate.unifs, () => {
        cache.currentglGeom.draw(renderstate);
      });
    }
  }

  /**
   * The _drawItems method.
   * @param {any} renderstate - The renderstate value.
   * @private
   */
  _drawItems(renderstate) {
    const cache = {
      currentglShader: null,
      currentglMaterial: null,
      currentglGeom: null,
    };
    for (const transparentItem of this.visibleItems) {
      const glshader = transparentItem.shaders.glshader;
      if (cache.currentglShader != glshader) {
        // Some passes, like the depth pass, bind custom uniforms.
        if (!this.bindShader(renderstate, glshader)) {
          continue
        }
        cache.currentglShader = glshader;
      }

      this._drawItem(renderstate, transparentItem, cache);
    }

    if (cache.currentglGeom) cache.currentglGeom.unbind(renderstate);
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.visibleItems.length == 0) return

    if (this.newItemsReadyForLoading()) this.finalize();

    const gl = this.__gl;

    const viewPos = renderstate.viewXfo.tr;
    // TODO: Avoid sorting if the camera did not movemore than 30cm
    if (this.resort || viewPos.distanceTo(this.prevSortCameraPos) > 0.3) this.sortItems(viewPos);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    // Complex transparent surfaces require mutiple passes.
    // First the multiply pass tints the background color, simulating
    // light passing through the surface, and then the add layer
    // adds new color to the backbuffer to simulate light bouncing off
    // the surface.

    // TODO: Optimise this system.
    // After depth sorting, we should split the items into 2 groups.
    // Multipy items, and Add  items. (Many items will be in both)
    // Then we can simply check if we have any multiply items here
    // before rendering all items.

    renderstate.pass = 'MULTIPLY';
    gl.blendFunc(gl.DST_COLOR, gl.ZERO); // For multiply, select this.
    this._drawItems(renderstate);

    renderstate.pass = 'ADD';
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // For add
    this._drawItems(renderstate);

    gl.disable(gl.BLEND);
  }

  /**
   * The drawHighlightedGeoms method.
   * @param {any} renderstate - The renderstate value.
   */
  drawHighlightedGeoms(renderstate) {
    const gl = this.__gl;
    gl.disable(gl.CULL_FACE); // 2-sided rendering.

    const cache = {
      currentglShader: null,
      currentglMaterial: null,
      currentglGeom: null,
    };
    for (const transparentItem of this.visibleItems) {
      if (!transparentItem.geomItem.isHighlighted()) continue
      if (!transparentItem.shaders.glselectedshader) continue
      const shaders = transparentItem.shaders;
      if (cache.currentglShader != shaders.glselectedshader) {
        // Some passes, like the depth pass, bind custom uniforms.
        if (!this.bindShader(renderstate, shaders.glselectedshader)) {
          continue
        }
        cache.currentglShader = shaders.glselectedshader;
      }

      this._drawItem(renderstate, transparentItem, cache);
    }

    if (cache.currentglGeom) cache.currentglGeom.unbind(renderstate);
  }

  /**
   * The getGeomItemAndDist method.
   * @param {any} geomData - The geomData value.
   * @return {any} - The return value.
   */
  getGeomItemAndDist(geomData) {
    let itemId;
    let dist;
    const gl = this.__gl;
    if (gl.floatGeomBuffer) {
      itemId = Math.round(geomData[1]);
      dist = geomData[3];
    } else {
      itemId = geomData[0] + (geomData[1] << 8);
      dist = MathFunctions.decode16BitFloatFrom2xUInt8([geomData[2], geomData[3]]);
    }

    const glgeomItem = this.__drawItems[itemId];
    if (glgeomItem) {
      return {
        geomItem: glgeomItem.getGeomItem(),
        dist,
      }
    }
  }

  /**
   * The drawGeomData method.
   * @param {any} renderstate - The renderstate value.
   */
  drawGeomData(renderstate) {
    if (this.newItemsReadyForLoading()) this.finalize();

    const gl = this.__gl;
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);

    const cache = {
      currentglShader: null,
      currentglMaterial: null,
      currentglGeom: null,
    };
    for (const transparentItem of this.visibleItems) {
      const shaders = transparentItem.shaders;
      if (shaders.glgeomdatashader) {
        continue
      }
      if (cache.currentglShader != shaders.glgeomdatashader) {
        // Some passes, like the depth pass, bind custom uniforms.
        if (!this.bindShader(renderstate, shaders.glgeomdatashader)) {
          continue
        }
        cache.currentglShader = shaders.glgeomdatashader;
      }
      {
        const unif = renderstate.unifs.floatGeomBuffer;
        if (unif) {
          gl.uniform1i(unif.location, gl.floatGeomBuffer ? 1 : 0);
        }
      }
      {
        const unif = renderstate.unifs.passId;
        if (unif) {
          gl.uniform1i(unif.location, this.__passIndex);
        }
      }

      this._drawItem(renderstate, transparentItem, cache);
    }

    if (cache.currentglGeom) cache.currentglGeom.unbind(renderstate);
  }
}

GLRenderer.registerPass(GLTransparentGeomsPass, PassType.TRANSPARENT);

const pixelsPerItem$1 = 5; // The number of pixels per draw item.

/** Class representing a GL billboards pass.
 * @extends GLPass
 * @private
 */
class GLBillboardsPass extends GLPass {
  /**
   * Create a GL billboards pass.
   */
  constructor() {
    super();
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);

    this.__billboards = [];
    this.__dirtyBillboards = new Set();
    this.__freeIndices = [];
    this.__drawCount = 0;
    this.__threshold = 0.0;
    this.__updateRequested = false;

    this.__prevSortCameraPos = new Vec3$1();

    this.__atlas = new GLImageAtlas(this.__renderer.gl, 'Billboards', 'RGBA', 'UNSIGNED_BYTE', [1, 1, 1, 0]);
    const emitUpdated = (event) => this.emit('updated', event);
    this.__atlas.on('loaded', emitUpdated);
    this.__atlas.on('updated', emitUpdated);

    this.__renderer.registerPass(
      (treeItem) => {
        if (treeItem instanceof BillboardItem) {
          this.addBillboard(treeItem);
          return true
        }
        return false
      },
      (treeItem) => {
        if (treeItem instanceof BillboardItem) {
          this.removeBillboard(treeItem);
          return true
        }
        return false
      }
    );
  }

  // ///////////////////////////////////
  // Bind to Render Tree

  /**
   * The filterRenderTree method.
   */
  filterRenderTree() {}

  /**
   * The addBillboard method.
   * @param {any} billboard - The billboard value.
   */
  addBillboard(billboard) {
    const imageParam = billboard.getParameter('Image');
    const image = imageParam.getValue();
    if (!image) {
      imageParam.on('valueChanged', () => this.addBillboard(billboard));
      return
    }
    let index;
    if (this.__freeIndices.length > 0) index = this.__freeIndices.pop();
    else index = this.__billboards.length;

    const imageIndex = this.__atlas.addSubImage(image);
    billboard.setMetadata('GLBillboardsPass_Index', index);

    const visibilityChanged = () => {
      if (billboard.isVisible()) {
        this.__drawCount++;
        // The billboard Xfo might have changed while it was
        // not visible. We need to update here.
        this.__dirtyBillboards.add(index);
      } else this.__drawCount--;
      this.__reqUpdateIndexArray();
    };
    billboard.on('visibilityChanged', visibilityChanged);

    const xfoChanged = () => {
      if (billboard.isVisible()) {
        this.__dirtyBillboards.add(index);
        this.emit('updated', {});
      }
    };
    billboard.getParameter('GlobalXfo').on('valueChanged', xfoChanged);

    const alphaChanged = () => {
      if (billboard.isVisible()) {
        this.__dirtyBillboards.add(index);
        this.emit('updated', {});
      }
    };
    billboard.getParameter('Alpha').on('valueChanged', alphaChanged);

    if (billboard.isVisible()) this.__drawCount++;

    this.__billboards[index] = {
      billboard,
      imageIndex,
      visibilityChanged,
      xfoChanged,
      alphaChanged,
    };

    this.indexArrayUpdateNeeded = true;
    this.__requestUpdate();
  }

  /**
   * The removeBillboard method.
   * @param {any} billboard - The billboard value.
   */
  removeBillboard(billboard) {
    const index = billboard.getMetadata('GLBillboardsPass_Index');
    if (index == -1) {
      console.warn('Billboard already removed.');
      return
    }
    const billboardData = this.__billboards[index];

    // Currently we are getting errors when trying to re-generate the Fbo
    // after removing and then adding images back to the atlas.
    // I don't have time to figure it out, so simply adding images
    // to the atlas. (for the Zahner demo)
    // Eventually we need to clean up the atlas, so debug this using the
    // survey-point-calibration 190528_Dummy_Srvy_Data.vlexe test
    const image = billboardData.billboard.getParameter('Image').getValue();
    this.__atlas.removeSubImage(image);

    billboard.off('visibilityChanged', billboardData.visibilityChanged);
    billboard.getParameter('GlobalXfo').off('valueChanged', billboardData.xfoChanged);
    billboard.getParameter('Alpha').off('valueChanged', billboardData.alphaChanged);

    this.__billboards[index] = null;
    this.__freeIndices.push(index);

    if (billboard.isVisible()) this.__drawCount--;

    this.indexArrayUpdateNeeded = true;
    this.__requestUpdate();
  }

  /**
   * The __populateBillboardDataArray method.
   * @param {any} billboardData - The billboardData value.
   * @param {number} index - The index value.
   * @param {any} dataArray - The dataArray value.
   * @private
   */
  __populateBillboardDataArray(billboardData, index, dataArray) {
    const billboard = billboardData.billboard;
    const mat4 = billboard.getParameter('GlobalXfo').getValue().toMat4();
    const ppm = billboard.getParameter('PixelsPerMeter').getValue();
    const scale = 1 / ppm;
    let flags = 0;
    if (billboard.getParameter('AlignedToCamera').getValue()) flags |= 1 << 2;
    if (billboard.getParameter('DrawOnTop').getValue()) flags |= 1 << 3;
    const alpha = billboard.getParameter('Alpha').getValue();
    const color = billboard.getParameter('Color').getValue();
    const offset = index * pixelsPerItem$1 * 4;
    const col0 = Vec4$1.createFromBuffer(dataArray.buffer, offset * 4);
    const col1 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 4) * 4);
    const col2 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 8) * 4);
    const col3 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 12) * 4);
    col0.set(mat4.xAxis.x, mat4.yAxis.x, mat4.zAxis.x, mat4.translation.x);
    col1.set(mat4.xAxis.y, mat4.yAxis.y, mat4.zAxis.y, mat4.translation.y);
    col2.set(mat4.xAxis.z, mat4.yAxis.z, mat4.zAxis.z, mat4.translation.z);
    col3.set(scale, flags, billboardData.imageIndex, alpha);

    const col4 = Vec4$1.createFromBuffer(dataArray.buffer, (offset + 16) * 4);
    col4.set(color.r, color.g, color.b, color.a);
  }

  /**
   * The __requestUpdate method.
   * @private
   */
  __requestUpdate() {
    if (!this.__updateRequested) {
      this.__updateRequested = true;
      setTimeout(() => {
        this.__updateBillboards();
      }, 100);
    }
  }

  /**
   * The __reqUpdateIndexArray method.
   * @private
   */
  __reqUpdateIndexArray() {
    if (this.indexArrayUpdateNeeded) return
    this.indexArrayUpdateNeeded = true;
    this.updateIndexArrayId = setTimeout(() => {
      // Another update or a draw might have occured
      // since the request was made.
      if (!this.indexArrayUpdateNeeded) return
      this.__updateIndexArray();
      this.emit('updated', {});
    }, 1);
  }

  // eslint-disable-next-line require-jsdoc
  __updateIndexArray() {
    const gl = this.__gl;
    // Note: When the camera moves, this array is sorted and re-upload.
    if (this.__indexArray && this.__indexArray.length != this.__drawCount) {
      gl.deleteBuffer(this.__instanceIdsBuffer);
      this.__instanceIdsBuffer = null;
    }

    this.__indexArray = new Float32Array(this.__drawCount);
    let offset = 0;
    for (let i = 0; i < this.__billboards.length; i++) {
      if (this.__billboards[i] && this.__billboards[i].billboard.isVisible()) {
        this.__indexArray[offset] = i;
        offset++;
      }
    }
    if (!this.__instanceIdsBuffer) this.__instanceIdsBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.__instanceIdsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.__indexArray, gl.STATIC_DRAW);
    this.indexArrayUpdateNeeded = false;
  }

  /**
   * The __updateBillboards method.
   * @private
   */
  __updateBillboards() {
    const doIt = () => {
      if (this.indexArrayUpdateNeeded) this.__updateIndexArray();

      const gl = this.__gl;
      if (!this.__glshader) {
        if (!gl.__quadVertexIdsBuffer) {
          gl.setupInstancedQuad();
        }
        this.__glshader = new BillboardShader(gl);
        const shaderComp = this.__glshader.compileForTarget('GLBillboardsPass', this.__renderer.getShaderPreproc());
        this.__shaderBinding = generateShaderGeomBinding(
          gl,
          shaderComp.attrs,
          gl.__quadattrbuffers,
          gl.__quadIndexBuffer
        );
      }

      // Note: Maybe the atlas is alreadu up to date. It should
      // maintain its own coherencey by listening to the sub images.
      this.__atlas.renderAtlas();

      if (!gl.floatTexturesSupported || !gl.drawElementsInstanced) {
        this.__modelMatrixArray = [];
        this.__billboardDataArray = [];
        this.__tintColorArray = [];
        this.__indexArray.forEach((index) => {
          // if (index == -1) return;
          const billboardData = this.__billboards[index];
          const billboard = billboardData.billboard;
          const mat4 = billboard.getParameter('GlobalXfo').getValue().toMat4();
          const ppm = billboard.getParameter('PixelsPerMeter').getValue();
          const scale = 1 / ppm;
          let flags = 0;
          if (billboard.getParameter('AlignedToCamera').getValue()) flags |= 1 << 2;
          const alpha = billboard.getParameter('Alpha').getValue();
          const color = billboard.getParameter('Color').getValue();

          this.__modelMatrixArray[index] = mat4.asArray();
          this.__billboardDataArray[index] = [scale, flags, billboardData.imageIndex, alpha];
          this.__tintColorArray[index] = [color.r, color.g, color.b, color.a];
        });
        this.__updateRequested = false;
        return
      }

      let size = Math.round(Math.sqrt((this.__billboards.length - this.__freeIndices.length) * pixelsPerItem$1) + 0.5);
      // Note: the following few lines need a cleanup.
      // We should be using power of 2 textures. The problem is that pot texture sizes don't
      // align with the 6 pixels per draw item. So we need to upload a slightly bigger texture
      // but upload the 'usable' size.

      // Only support power 2 textures. Else we get strange corruption on some GPUs
      // in some scenes.
      // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
      // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
      // size = Math.nextPow2(size);

      if (size % pixelsPerItem$1 != 0) size += pixelsPerItem$1 - (size % pixelsPerItem$1);

      this.__width = size;
      // if((this.__width % pixelsPerItem) != 0)
      //     this.__width -= (this.__width % pixelsPerItem);

      if (!this.__drawItemsTexture) {
        this.__drawItemsTexture = new GLTexture2D(gl, {
          format: 'RGBA',
          type: 'FLOAT',
          width: size,
          height: size,
          filter: 'NEAREST',
          wrap: 'CLAMP_TO_EDGE',
          mipMapped: false,
        });
        this.__drawItemsTexture.clear();
      } else {
        this.__drawItemsTexture.resize(size, size);
      }

      this.__indexArray.forEach((index) => {
        if (index != -1) this.__updateBillboard(index);
      });

      this.__updateRequested = false;
    };

    if (this.__atlas.isLoaded()) {
      doIt();
    } else {
      this.__atlas.on('loaded', doIt);
    }
  }

  /**
   * The __updateBillboards method.
   * @param {number} index - The index value.
   * @private
   */
  __updateBillboard(index) {
    if (this.__drawCount == 0 || !this.__drawItemsTexture) {
      return
    }

    const billboardData = this.__billboards[index];
    if (!billboardData.billboard.isVisible()) return

    const gl = this.__gl;

    const dataArray = new Float32Array(pixelsPerItem$1 * 4);
    this.__populateBillboardDataArray(billboardData, 0, dataArray);

    gl.bindTexture(gl.TEXTURE_2D, this.__drawItemsTexture.glTex);
    const xoffset = (index * pixelsPerItem$1) % this.__width;
    const yoffset = Math.floor((index * pixelsPerItem$1) / this.__width);

    const width = pixelsPerItem$1;
    const height = 1;
    // console.log("xoffset:" + xoffset + " yoffset:" + yoffset +" width:" + width + " dataArray:" + dataArray.length);
    // gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, gl.RGBA, gl.FLOAT, dataArray);

    const type = this.__drawItemsTexture.getType();
    const format = this.__drawItemsTexture.getFormat();

    if (type == 'FLOAT') {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, gl[format], gl[type], dataArray);
    } else {
      const unit16s = MathFunctions.convertFloat32ArrayToUInt16Array(dataArray);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, gl[format], gl[type], unit16s);
    }
  }

  /**
   * The sort method.
   * @param {any} cameraPos - The cameraPos value.
   */
  sort(cameraPos) {
    for (const billboardData of this.__billboards) {
      const { billboard } = billboardData;
      if (billboard && billboard.isVisible()) {
        const xfo = billboard.getParameter('GlobalXfo').getValue();
        billboardData.dist = xfo.tr.distanceTo(cameraPos);
      }
    }
    this.__indexArray.sort((a, b) => {
      if (a == -1) return 1
      if (b == -1) return -1
      return this.__billboards[a].dist > this.__billboards[b].dist
        ? -1
        : this.__billboards[a].dist < this.__billboards[b].dist
        ? 1
        : 0
    });

    const gl = this.__gl;
    if (gl.floatTexturesSupported && this.__instanceIdsBuffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.__instanceIdsBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, this.__indexArray, gl.STATIC_DRAW);
    }
  }

  /**
   * The sort method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.__drawCount == 0 || !this.__atlas.isReady() || this.__updateRequested) {
      return
    }

    if (this.__dirtyBillboards.size > 0) {
      this.__dirtyBillboards.forEach((index) => {
        this.__updateBillboard(index);
      });
      this.__dirtyBillboards.clear();
    }

    if (this.indexArrayUpdateNeeded) this.__updateIndexArray();

    const gl = this.__gl;

    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    const cameraPos = renderstate.viewXfo.tr;
    const dist = cameraPos.distanceTo(this.__prevSortCameraPos);
    // Avoid sorting if the camera did not move more than 3 meters.
    if (dist > this.__threshold) {
      this.sort(cameraPos);
      this.__prevSortCameraPos = cameraPos.clone();
      if (this.__drawCount > 1) {
        const v0 = this.__billboards[this.__indexArray[0]].billboard.getParameter('GlobalXfo').getValue().tr;
        const v1 = this.__billboards[this.__indexArray[1]].billboard.getParameter('GlobalXfo').getValue().tr;
        this.__threshold = v0.distanceTo(v1);
      } else {
        this.__threshold = 9999;
      }
    }

    this.__glshader.bind(renderstate);
    this.__shaderBinding.bind(renderstate);

    const unifs = renderstate.unifs;
    this.__atlas.bindToUniform(renderstate, unifs.atlasBillboards);

    const inVR = renderstate.vrPresenting == true;
    gl.uniform1i(unifs.inVR.location, inVR);

    if (!gl.floatTexturesSupported || !gl.drawElementsInstanced) {
      const len = this.__indexArray.length;
      for (let i = 0; i < len; i++) {
        // this.__drawItems[i].bind(renderstate);
        // this.__glgeom.draw();

        gl.uniformMatrix4fv(unifs.modelMatrix.location, false, this.__modelMatrixArray[i]);
        gl.uniform4fv(unifs.billboardData.location, this.__billboardDataArray[i]);
        gl.uniform4fv(unifs.tintColor.location, this.__tintColorArray[i]);
        gl.uniform4fv(unifs.layoutData.location, this.__atlas.getLayoutData(this.__billboards[i].imageIndex));

        renderstate.bindViewports(unifs, () => {
          gl.drawQuad();
        });
      }
    } else {
      this.__drawItemsTexture.bindToUniform(renderstate, unifs.instancesTexture);
      gl.uniform1i(unifs.instancesTextureSize.location, this.__width);

      {
        // The instance transform ids are bound as an instanced attribute.
        const location = renderstate.attrs.instanceIds.location;
        gl.enableVertexAttribArray(location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.__instanceIdsBuffer);
        gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 4, 0);
        gl.vertexAttribDivisor(location, 1); // This makes it instanced
      }

      renderstate.bindViewports(unifs, () => {
        gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, this.__drawCount);
      });
    }

    gl.disable(gl.BLEND);
  }
}

GLRenderer.registerPass(GLBillboardsPass, PassType.TRANSPARENT);

/** Class representing a GL overlay pass.
 * @extends GLOpaqueGeomsPass
 */
class GLOverlayPass extends GLOpaqueGeomsPass {
  /**
   * Create a GL overlay pass.
   * @param {string} name - The name value.
   */
  constructor() {
    super();
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);
  }

  // ///////////////////////////////////
  // Bind to Render Tree

  /**
   * The filterGeomItem method.
   * @param {any} geomItem - The geomItem value.
   * @return {any} - The return value.
   */
  filterGeomItem(geomItem) {
    if (geomItem.isOverlay()) return true
    const shaderClass = geomItem.getParameter('Material').getValue().getShaderClass();
    if (shaderClass) {
      if (shaderClass.isOverlay()) return true
    }
    return false
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.newItemsReadyForLoading()) this.finalize();

    const gl = this.__gl;

    // Clear the depth buffer so handls are always drawn over the top.
    gl.clear(gl.DEPTH_BUFFER_BIT);

    {
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
    }
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);

    renderstate.pass = 'ADD';
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // For add

    this.__traverseTreeAndDraw(renderstate);

    gl.disable(gl.BLEND);
    // gl.enable(gl.DEPTH_TEST);
  }

  /**
   * The drawGeomData method.
   * @param {any} renderstate - The renderstate value.
   */
  drawGeomData(renderstate) {
    const gl = this.__gl;

    // Clear the depth buffer so handls are always drawn over the top.
    gl.clear(gl.DEPTH_BUFFER_BIT);

    // gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);

    renderstate.pass = 'ADD';
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // For add

    super.drawGeomData(renderstate);

    gl.disable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
  }
}

GLRenderer.registerPass(GLOverlayPass, PassType.OVERLAY);

const AudioContext =
  globalThis.navigator &&
  (window.AudioContext || // Default
  window.webkitAudioContext || // Safari and old versions of Chrome
    false);

let audioCtx;
if (AudioContext) {
  // Do whatever you want using the Web Audio API
  audioCtx = new AudioContext();
  // ...
} else if (globalThis.navigator) {
  // Web Audio API is not supported
  // Alert the user
  alert(
    'Sorry, but the Web Audio API is not supported by your browser. Please, consider upgrading to the latest version or downloading Google Chrome or Mozilla Firefox'
  );
}

/** Class representing a GL audio items pass.
 * @extends GLPass
 */
class GLAudioItemsPass extends GLPass {
  /**
   * Create a GL audio items pass.
   */
  constructor() {
    super();
    this.__audioItems = [];
  }

  /**
   * The init method.
   * @param {any} renderer - The renderer value.
   * @param {any} passIndex - The passIndex value.
   */
  init(renderer, passIndex) {
    super.init(renderer, passIndex);

    if (!audioCtx) return

    this.__renderer.registerPass(
      (treeItem) => {
        if (treeItem instanceof AudioItem) {
          treeItem.on('audioSourceCreated', (event) => {
            const { audioSource } = event;
            this.addAudioSource(treeItem, audioSource, treeItem);
          });
          return true
        }
        if (treeItem instanceof GeomItem) {
          const material = treeItem.getParameter('Material').getValue();
          if (material) {
            const baseColorParam = material.getParameter('BaseColor');
            if (baseColorParam && baseColorParam.getImage && baseColorParam.getImage()) {
              const image = baseColorParam.getImage();
              image.on('loaded', () => {
                if (image.getAudioSource) {
                  const audioSource = image.getAudioSource();
                  if (audioSource instanceof HTMLMediaElement || audioSource instanceof AudioBufferSourceNode)
                    this.addAudioSource(treeItem, audioSource, image);
                }
              });
            }
          }
          // Let other passes handle this item.
          return false
        }
      },
      (treeItem) => {}
    );
  }

  /**
   * The addAudioSource method.
   * @param {any} treeItem - The treeItem value.
   * @param {any} audioSource - The audioSource value.
   * @param {any} parameterOwner - The parameterOwner value.
   */
  addAudioSource(treeItem, audioSource, parameterOwner) {
    if (audioSource.addedToCollector) return

    let source;
    if (audioSource instanceof HTMLMediaElement) source = audioCtx.createMediaElementSource(audioSource);
    else if (audioSource instanceof AudioBufferSourceNode) source = audioSource;
    else source = audioCtx.createMediaStreamSource(audioSource);

    const connectVLParamToAudioNodeParam = (vlParam, param) => {
      if (!vlParam) return
      // Note: setting the gain has no effect. Not sure what to do.
      // param.value = vlParam.getValue();
      param.setValueAtTime(vlParam.getValue(), 0);
      param.setValueAtTime(vlParam.getValue(), 5);
      vlParam.on('valueChanged', () => {
        // param.setTargetAtTime(vlParam.getValue(), audioCtx.currentTime);
        param.value = vlParam.getValue();
      });
    };

    const gainNode = audioCtx.createGain();
    const gainParam = parameterOwner.getParameter('Gain');
    if (gainParam) {
      connectVLParamToAudioNodeParam(gainParam, gainNode.gain);
    }

    inNode;

    const spatializeParam = parameterOwner.getParameter('SpatializeAudio');
    if (spatializeParam && spatializeParam.getValue() == false) {
      dioCtx.destination;
    } else {
      const panner = audioCtx.createPanner();
      panner.panningModel = 'HRTF';
      panner.distanceModel = 'inverse'('pasource', nner)('aupanner', dioCtx.destination);

      const connectVLParamToAudioNode = (paramName) => {
        const vlParam = parameterOwner.getParameter(paramName);
        if (!vlParam) return
        panner[paramName] = vlParam.getValue();
        vlParam.on('valueChanged', () => {
          panner[paramName] = vlParam.getValue();
        });
      };

      // connectVLParamToAudioNode('refDistance');
      // connectVLParamToAudioNode('maxDistance');
      // connectVLParamToAudioNode('rolloffFactor');
      connectVLParamToAudioNode('coneInnerAngle');
      connectVLParamToAudioNode('coneOuterAngle');
      connectVLParamToAudioNode('coneOuterGain');

      const updatePannerNodePosition = () => {
        // Note: the new audio params are reccomended to be used, but cause audio stutter.
        // ITs as if when we set the value, it is set for only a brief moment in time, and
        // then reverts back to the previous value.
        // Note: I downloaded and messed with the 'RoomOfMetal' demo here, and found
        // that I could not move the listener using the reccommended approach (setting values on the AudioParams.)
        // https://developer.mozilla.org/en-US/docs/Web/API/AudioListener/setPosition

        let mat4;
        if (treeItem instanceof GeomItem) mat4 = treeItem.getGeomMat4();
        else mat4 = treeItem.getParameter('GlobalXfo').getValue().toMat4();
        const tr = mat4.translation;
        // if (panner.positionX) {
        //     // panner.positionX.setTargetAtTime(xfo.tr.x, audioCtx.currentTime);
        //     // panner.positionY.setTargetAtTime(xfo.tr.y, audioCtx.currentTime);
        //     // panner.positionZ.setTargetAtTime(xfo.tr.z, audioCtx.currentTime);
        //     panner.positionX.value = xfo.tr.x;
        //     panner.positionY.value = xfo.tr.y;
        //     panner.positionZ.value = xfo.tr.z;
        // } else {
        panner.setPosition(tr.x, tr.y, tr.z);
        // }

        const dir = mat4.zAxis;
        // if (panner.orientationX) {
        //     // panner.orientationX.setTargetAtTime(dir.x, audioCtx.currentTime);
        //     // panner.orientationY.setTargetAtTime(dir.y, audioCtx.currentTime);
        //     // panner.orientationZ.setTargetAtTime(dir.z, audioCtx.currentTime);
        //     panner.orientationX.value = dir.x;
        //     panner.orientationY.value = dir.y;
        //     panner.orientationZ.value = dir.z;
        // } else {
        panner.setOrientation(dir.x, dir.y, dir.z);
        // }

        // TODO:
        // setVelocity()
      };
      updatePannerNodePosition();
      treeItem.on('globalXfoChanged', (event) => {
        updatePannerNodePosition();
      });
    }

    audioSource.addedToCollector = true;
    this.__audioItems.push({
      treeItem,
      audioSource,
      parameterOwner,
    });

    this.emit('updated', {});
  }

  /**
   * The __updateListenerPosition method.
   * @param {any} viewXfo - The viewXfo value.
   * @private
   */
  __updateListenerPosition(viewXfo) {
    if (!audioCtx) return

    // Note: the new audio params are reccomended to be used, but cause audio stutter.
    // ITs as if when we set the value, it is set for only a brief moment in time, and
    // then reverts back to the previous value.
    // Note: I downloaded and messed with the 'RoomOfMetal' demo here, and found
    // that I could not move the listener using the reccommended approach (setting values on the AudioParams.)
    // https://developer.mozilla.org/en-US/docs/Web/API/AudioListener/setPosition

    // Note: Moving the listener seems to cause problems.
    const listener = audioCtx.listener;
    // if(listener.positionX) {
    //   listener.positionX.value = viewXfo.tr.x;
    //   listener.positionY.value = viewXfo.tr.y;
    //   listener.positionZ.value = viewXfo.tr.z;
    //   // listener.positionX.setValueAtTime(viewXfo.tr.x, audioCtx.currentTime);
    //   // listener.positionY.setValueAtTime(viewXfo.tr.y, audioCtx.currentTime);
    //   // listener.positionZ.setValueAtTime(viewXfo.tr.z, audioCtx.currentTime);
    // } else {
    listener.setPosition(viewXfo.tr.x, viewXfo.tr.y, viewXfo.tr.z);
    // }
    const up = viewXfo.ori.getYaxis();
    const fw = viewXfo.ori.getZaxis().negate();
    // if(listener.upX) {
    //   // listener.upX.setValueAtTime(up.x, audioCtx.currentTime);
    //   // listener.upY.setValueAtTime(up.y, audioCtx.currentTime);
    //   // listener.upZ.setValueAtTime(up.z, audioCtx.currentTime);
    //   // listener.forwardX.setValueAtTime(fw.x, audioCtx.currentTime);
    //   // listener.forwardY.setValueAtTime(fw.y, audioCtx.currentTime);
    //   // listener.forwardZ.setValueAtTime(fw.z, audioCtx.currentTime);
    //   listener.upX.value = up.x;
    //   listener.upY.value = up.y;
    //   listener.upZ.value = up.z;
    //   listener.forwardX.value = fw.x;
    //   listener.forwardY.value = fw.y;
    //   listener.forwardZ.value = fw.z;
    // } else {
    listener.setOrientation(fw.x, fw.y, fw.z, up.x, up.y, up.z);
    // }
  }

  /**
   * The draw method.
   * @param {any} renderstate - The renderstate value.
   */
  draw(renderstate) {
    if (this.__audioItems.length == 0) return
    this.__updateListenerPosition(renderstate.viewXfo);
  }
}

GLRenderer.registerPass(GLAudioItemsPass, PassType.OVERLAY);

// Hack so Audio Item can access the context.
if (globalThis.navigator && window) {
  window.ZeaAudioaudioCtx = audioCtx;
}

var Renderer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create3DContext: create3DContext,
  GLTexture2D: GLTexture2D,
  GLMesh: GLMesh,
  GLLines: GLLines,
  GLPoints: GLPoints,
  GLMaterial: GLMaterial,
  GLShader: GLShader,
  GLFbo: GLFbo,
  GLRenderTarget: GLRenderTarget,
  GLRenderer: GLRenderer,
  GLBaseViewport: GLBaseViewport,
  GLViewport: GLViewport,
  shaderLibrary: shaderLibrary,
  generateShaderGeomBinding: generateShaderGeomBinding,
  BillboardShader: BillboardShader,
  ConvolverShader: ConvolverShader,
  DepthMapShader: DepthMapShader,
  EnvMapShader: EnvMapShader,
  BackgroundImageShader: BackgroundImageShader,
  OctahedralEnvMapShader: OctahedralEnvMapShader,
  LatLongEnvMapShader: LatLongEnvMapShader,
  SterioLatLongEnvMapShader: SterioLatLongEnvMapShader,
  DualFishEyeEnvMapShader: DualFishEyeEnvMapShader,
  DualFishEyeToLatLongBackgroundShader: DualFishEyeToLatLongBackgroundShader,
  EnvProjectionShader: EnvProjectionShader,
  OctahedralEnvProjectionShader: OctahedralEnvProjectionShader,
  LatLongEnvProjectionShader: LatLongEnvProjectionShader,
  FatLinesShader: FatLinesShader,
  FlatSurfaceShader: FlatSurfaceShader,
  FlatAlphaSurfaceShader: FlatAlphaSurfaceShader,
  LinesShader: LinesShader,
  NormalsShader: NormalsShader,
  PointsShader: PointsShader,
  FatPointsShader: FatPointsShader,
  FatPointsGeomDataShader: FatPointsGeomDataShader,
  FatPointsSelectedShader: FatPointsSelectedShader,
  PostProcessing: PostProcessing,
  ScreenQuadShader: ScreenQuadShader,
  SimpleSurfaceShader: SimpleSurfaceShader,
  StandardSurfaceShader: StandardSurfaceShader,
  StandardSurfaceGeomDataShader: StandardSurfaceGeomDataShader,
  StandardSurfaceSelectedGeomsShader: StandardSurfaceSelectedGeomsShader,
  TransparentSurfaceShader: TransparentSurfaceShader,
  ScreenSpaceShader: ScreenSpaceShader,
  ToolIconShader: ToolIconShader,
  UnpackHDRShader: UnpackHDRShader,
  UnpackLDRAlphaImageShader: UnpackLDRAlphaImageShader,
  WireShader: WireShader,
  GLPass: GLPass,
  PassType: PassType,
  GLStandardGeomsPass: GLStandardGeomsPass,
  GLOpaqueGeomsPass: GLOpaqueGeomsPass,
  GLTransparentGeomsPass: GLTransparentGeomsPass,
  GLBillboardsPass: GLBillboardsPass,
  GLOverlayPass: GLOverlayPass,
  GLAudioItemsPass: GLAudioItemsPass,
  get audioCtx () { return audioCtx; },
  VRViewport: VRViewport
});

const ZeaEngine = {
  SystemDesc,
  Registry,
  ...Math$1,
  ...Utilities,
  ...SceneTree,
  ...Renderer,
};

export default ZeaEngine;
export { AssetItem, Async, AttrValue, Attribute, AudioItem, BackgroundImageShader, BaseGeom, BaseGeomItem, BaseImage, BaseItem, BillboardItem, BillboardShader, BinReader, BinWriter, BooleanParameter, Box2, Box3$1 as Box3, Camera, CameraMouseAndKeyboard, Circle, CodeParameter, Color, ColorParameter, Cone, ConvolverShader, Cross, Cuboid, Cylinder, DataImage, DepthMapShader, Disc, DualFishEyeEnvMapShader, DualFishEyeToLatLongBackgroundShader, EnvMap, EnvMapShader, EnvProjectionShader, EulerAngles, EventEmitter, FatLinesShader, FatPointsGeomDataShader, FatPointsSelectedShader, FatPointsShader, FileAudioItem, FileImage$1 as FileImage, FileImage2D, FilePathParameter, FlatAlphaSurfaceShader, FlatSurfaceShader, Float32, Frustum, GIFImage, GLAudioItemsPass, GLBaseViewport, GLBillboardsPass, GLFbo, GLLines, GLMaterial, GLMesh, GLOpaqueGeomsPass, GLOverlayPass, GLPass, GLPoints, GLRenderTarget, GLRenderer, GLShader, GLStandardGeomsPass, GLTexture2D, GLTransparentGeomsPass, GLViewport, GeomItem, GeomLibrary, GeometryParameter, Grid, Group, GrowingPacker, ImageParameter, InstanceItem, ItemSetParameter, LDRImage, LDRVideo, Label, LatLongEnvMapShader, LatLongEnvProjectionShader, Lines, LinesCuboid, LinesProxy, LinesShader, ListParameter, Mat3$1 as Mat3, Mat3Parameter, Mat4, Mat4Parameter, Material, MaterialColorParam, MaterialFloatParam, MaterialLibrary, MaterialParameter, MathFunctions, Mesh, MeshProxy, MultiChoiceParameter, NormalsShader, NumberParameter, ObjAsset, OctahedralEnvMapShader, OctahedralEnvProjectionShader, Operator, OperatorInput, OperatorOutput, OperatorOutputMode, Parameter, ParameterOwner, PassType, Plane$1 as Plane, PlaneType, PointGrid, Points, PointsProxy, PointsShader, PostProcessing, ProxyParameter, Quat, RGBA, Ray, Rect, RefCounted, Registry, RouterOperator, SInt16, SInt32, SInt8, Scene, ScreenQuadShader, ScreenSpaceShader, SimpleSurfaceShader, Sphere$1 as Sphere, SphereType, StandardSurfaceGeomDataShader, StandardSurfaceSelectedGeomsShader, StandardSurfaceShader, SterioLatLongEnvMapShader, StringFunctions, StringParameter, StructParameter, SystemDesc, ToolIconShader, Torus, TransparentSurfaceShader, TreeItem, TreeItemParameter, UInt16, UInt32, UInt8, UnpackHDRShader, UnpackLDRAlphaImageShader, VLAAsset$1 as VLAAsset, VRViewport, Vec2, Vec2Parameter, Vec3$1 as Vec3, Vec3Parameter, Vec4$1 as Vec4, Vec4Parameter, Version, VertexAttribute$1 as VertexAttribute, VideoStreamImage2D, WireShader, Xfo, XfoParameter, audioCtx, create3DContext, decodeText, generateShaderGeomBinding, getFileFolder, labelManager, loadBinfile, loadJSONfile, loadTextfile, loadXMLfile, resourceLoader, sgFactory, shaderLibrary };
