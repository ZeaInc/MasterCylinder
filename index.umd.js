(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.zeaEngine = {}));
})(this, (function (exports) { 'use strict';

  var version = "4.13.0";

  /**
   * Libraries registry.
   */
  class LibsRegistry {
      registry;
      version;
      /**
       * Construct a new libraries registry for the specific version.
       * @param version - The version of the Zea Engine that will be validated against the registered libraries.
       */
      constructor(version) {
          this.version = version;
          this.registry = {};
      }
      /**
       * Validate and register a library.
       * @param packageJson - The package.json of the library to register.
       */
      registerLib(packageJson) {
          const libName = packageJson.name;
          const libVersion = packageJson.version;
          if (this.registry[libName]) {
              console.warn("Library already registered:" + libName);
          }
          this.registry[libName] = libVersion;
          console.log(`Registered lib '${libName}' v${libVersion}`);
      }
      /**
       * List the registered libraries with their versions.
       * @return Libraries list.
       */
      listLibs() {
          return this.registry;
      }
  }

  // https://stackoverflow.com/questions/57776001/how-to-detect-ipad-pro-as-ipad-using-javascript
  function isIOSDevice() {
      if (/iPad|iPhone|iPod/.test(navigator.platform)) {
          return true;
      }
      else {
          return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
      }
  }
  // https://stackdiary.com/detect-mobile-browser-javascript/
  function isMobileDevice() {
      return (navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent));
  }
  function getBrowserDesc() {
      const nAgt = navigator.userAgent;
      let browserName = navigator.appName;
      let fullVersion = '' + parseFloat(navigator.appVersion);
      let majorVersion = parseInt(navigator.appVersion, 10);
      let nameOffset;
      let verOffset;
      let ix;
      if (navigator.brave) {
          browserName = 'Brave';
          verOffset = nAgt.indexOf('Chrome');
          fullVersion = nAgt.substring(verOffset + 7, nAgt.indexOf(' ', verOffset + 7));
      }
      // In Opera, the true version is after "Opera" or after "Version"
      else if ((verOffset = nAgt.indexOf('Opera')) != -1) {
          browserName = 'Opera';
          fullVersion = nAgt.substring(verOffset + 6);
          if ((verOffset = nAgt.indexOf('Version')) != -1)
              fullVersion = nAgt.substring(verOffset + 8);
      }
      // In MSIE, the true version is after "MSIE" in userAgent
      else if ((verOffset = nAgt.indexOf('MSIE')) != -1) {
          browserName = 'Microsoft Internet Explorer';
          fullVersion = nAgt.substring(verOffset + 5);
      }
      else if ((verOffset = nAgt.indexOf('Edge')) != -1) {
          browserName = 'Edge';
          fullVersion = nAgt.substring(verOffset + 4);
      }
      // In Chrome, the true version is after "Chrome"
      else if ((verOffset = nAgt.indexOf('Chrome')) != -1) {
          browserName = 'Chrome';
          fullVersion = nAgt.substring(verOffset + 7, nAgt.indexOf(' ', verOffset + 7));
      }
      // TOOD: Parse Samsung userAgent
      // https://developer.samsung.com/technical-doc/view.do?v=T000000203
      // In Safari, the true version is after "Safari" or after "Version"
      else if ((verOffset = nAgt.indexOf('Safari')) != -1) {
          browserName = 'Safari';
          fullVersion = nAgt.substring(verOffset + 7);
          if ((verOffset = nAgt.indexOf('Version')) != -1)
              fullVersion = nAgt.substring(verOffset + 8);
      }
      // In Firefox, the true version is after "Firefox"
      else if ((verOffset = nAgt.indexOf('Firefox')) != -1) {
          browserName = 'Firefox';
          fullVersion = nAgt.substring(verOffset + 8);
      }
      // In most other browsers, "name/version" is at the end of userAgent
      else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
          browserName = nAgt.substring(nameOffset, verOffset);
          fullVersion = nAgt.substring(verOffset + 1);
          if (browserName.toLowerCase() == browserName.toUpperCase()) {
              browserName = navigator.appName;
          }
      }
      // trim the fullVersion string at semicolon/space if present
      if ((ix = fullVersion.indexOf(';')) != -1)
          fullVersion = fullVersion.substring(0, ix);
      if ((ix = fullVersion.indexOf(' ')) != -1)
          fullVersion = fullVersion.substring(0, ix);
      majorVersion = parseInt('' + fullVersion, 10);
      if (isNaN(majorVersion)) {
          fullVersion = '' + parseFloat(navigator.appVersion);
          majorVersion = parseInt(navigator.appVersion, 10);
      }
      return {
          browserName,
          fullVersion,
          majorVersion,
          appName: navigator.appName,
          userAgent: navigator.userAgent,
      };
  }
  // eslint-disable-next-line require-jsdoc
  function getGPUDesc() {
      let webgl;
      try {
          webgl = document.createElement('canvas').getContext('webgl');
      }
      catch (e) { }
      if (!webgl) {
          return {
              vendor: 'Unknown',
              renderer: 'Unknown',
              gpuVendor: 'Unknown',
              maxTextureSize: 0,
              supportsWebGL: false,
              supportsWebGL2: false,
          };
      }
      let webgl2;
      try {
          webgl2 = document.createElement('canvas').getContext('webgl2');
      }
      catch (e) { }
      const debugInfo = webgl.getExtension('WEBGL_debug_renderer_info');
      if (!debugInfo) {
          console.warn('Unable to determine GPU Info:');
          return {
              vendor: 'Unknown',
              renderer: 'Unknown',
              gpuVendor: 'Unknown',
              maxTextureSize: 0,
              supportsWebGL: webgl != undefined,
              supportsWebGL2: webgl2 != undefined,
          };
      }
      const vendor = webgl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
      const renderer = webgl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
      const maxTextureSize = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
      let gpuVendor;
      if (renderer.match(/NVIDIA/i)) {
          gpuVendor = 'NVidia';
      }
      else if (renderer.match(/AMD/i) || renderer.match(/Radeon/i)) {
          gpuVendor = 'AMD';
      }
      else if (renderer.match(/Intel/i)) {
          gpuVendor = 'Intel';
      }
      else if (renderer.match(/Mali/i)) {
          gpuVendor = 'ARM';
      }
      else if (renderer.match(/Apple/i)) {
          gpuVendor = 'Apple';
      }
      else if (renderer.match(/Adreno/i)) {
          gpuVendor = 'Adreno';
      }
      else if (renderer.match(/Swiftshader/i)) {
          gpuVendor = 'Google';
          console.warn('Hardware rendering is disabled or not working on your system. Falling back to the Swiftshader. Expect poor performance:', renderer);
      }
      else {
          console.warn('Unable to determine GPU vendor:', renderer);
      }
      return {
          vendor,
          renderer,
          gpuVendor,
          maxTextureSize,
          supportsWebGL: true,
          supportsWebGL2: webgl2 != undefined,
      };
  }
  const getOS = () => {
      const userAgent = window.navigator.userAgent;
      let os = null;
      if (/macintosh/i.test(userAgent)) {
          os = 'macOS';
      }
      else if (/ios/i.test(userAgent)) {
          os = 'iOS';
      }
      else if (/win/i.test(userAgent)) {
          os = 'Windows';
      }
      else if (/android/i.test(userAgent)) {
          os = 'Android';
      }
      else if (/linux/i.test(userAgent)) {
          os = 'Linux';
      }
      return os;
  };
  const SystemDesc = (function () {
      if (!globalThis.navigator) {
          // When running in NodeJS
          return {
              OS: 'Node',
              isMobileDevice: false,
              isIOSDevice: false,
              browserName: 'Node',
              webGLSupported: false,
              deviceCategory: 'High',
              hardwareConcurrency: 4,
          };
      }
      const isMobile = isMobileDevice();
      const browserDesc = getBrowserDesc();
      const gpuDesc = getGPUDesc();
      let deviceCategory = 'Low';
      if (gpuDesc.supportsWebGL) {
          // We divide devices into 3 categories.
          // 0: low end, we dial everything down as much as possible
          // 1: mid-range, Enb maps and Textures go to mid-lods.
          //    Typically these devices are laptops, so the textures can't be too blurry
          // 2: High-end: turn up as much as needed.
          if (!isMobile) {
              // Remove braces and split into parts
              const parts = gpuDesc.renderer.replace(/[()]/g, '').split(' ');
              if (gpuDesc.gpuVendor == 'NVidia') {
                  const gtxIdx = parts.indexOf('GTX');
                  if (gtxIdx != -1) {
                      const model = parts[gtxIdx + 1];
                      if (model.endsWith('M')) {
                          // laptop GPU.
                          const modelNumber = parseInt(model.substring(0, model.length - 2));
                          if (modelNumber >= 900) {
                              deviceCategory = 'Medium';
                          }
                          else {
                              deviceCategory = 'Low';
                          }
                      }
                      else {
                          const modelNumber = parseInt(model);
                          if (modelNumber >= 1030) {
                              deviceCategory = 'High';
                          }
                          else {
                              deviceCategory = 'Medium';
                          }
                      }
                  }
                  else {
                      if (parts.includes('RTX') || parts.includes('TITAN') || parts.includes('Quadro')) {
                          deviceCategory = 'High';
                      }
                      else {
                          deviceCategory = 'Low';
                      }
                  }
              }
              else if (gpuDesc.gpuVendor == 'AMD') {
                  const radeonIdx = parts.indexOf('Radeon');
                  if (radeonIdx != -1) {
                      const rxIdx = parts.indexOf('RX');
                      if (rxIdx != -1) {
                          if (parts[rxIdx + 1] == 'Vega') {
                              deviceCategory = 'High';
                          }
                          else {
                              const model = parts[rxIdx + 1];
                              let modelNumber;
                              if (model.endsWith('X')) {
                                  modelNumber = parseInt(model.substring(0, model.length - 2));
                                  deviceCategory = 'High';
                              }
                              else {
                                  modelNumber = parseInt(model);
                              }
                              if (modelNumber >= 480) {
                                  deviceCategory = 'High';
                              }
                              else {
                                  deviceCategory = 'Medium';
                              }
                          }
                      }
                      else if (parts[radeonIdx + 1] == 'Pro') {
                          const modelNumber = parseInt(parts[rxIdx + 1]);
                          if (modelNumber >= 450) {
                              deviceCategory = 'Medium';
                          }
                          else {
                              deviceCategory = 'Low';
                          }
                      }
                      else if (parts[radeonIdx + 1] == 'Sky') {
                          const modelNumber = parseInt(parts[rxIdx + 1]);
                          if (modelNumber >= 700) {
                              deviceCategory = 'Medium';
                          }
                          else {
                              deviceCategory = 'Low';
                          }
                      }
                      else {
                          deviceCategory = 'Low';
                      }
                  }
                  else {
                      if (parts.includes('FirePro') || parts.includes('Quadro')) {
                          deviceCategory = 'High';
                      }
                      else {
                          deviceCategory = 'Low';
                      }
                  }
              }
              else if (gpuDesc.gpuVendor == 'Adreno') {
                  deviceCategory = 'Low';
              }
              else if (gpuDesc.gpuVendor == 'Intel') {
                  deviceCategory = 'Low';
              }
              else if (gpuDesc.gpuVendor == 'Google') {
                  deviceCategory = 'Low';
              }
          }
          else {
              deviceCategory = 'Low';
          }
      }
      let hardwareConcurrency = globalThis.navigator.hardwareConcurrency;
      if (!hardwareConcurrency) {
          if (isMobile)
              hardwareConcurrency = 4;
          else
              hardwareConcurrency = 6;
      }
      return {
          OS: getOS(),
          isMobileDevice: isMobile,
          isIOSDevice: isIOSDevice(),
          browserName: browserDesc.browserName,
          fullVersion: browserDesc.fullVersion,
          majorVersion: browserDesc.majorVersion,
          appName: browserDesc.appName,
          userAgent: browserDesc.userAgent,
          webGLSupported: gpuDesc.supportsWebGL,
          gpuDesc,
          deviceCategory,
          hardwareConcurrency,
      };
  })();
  // @ts-ignore
  if (!globalThis.ZeaSystemDesc) {
      // @ts-ignore
      globalThis.ZeaSystemDesc = SystemDesc;
  }

  let registeredClasses = {};
  let classNames = {};
  let classDefinitions = [];
  /**
   * Registry is a static factory that handles registration/reconstruction of
   * classes bases on BaseClass. Registered classes can then be constructed by the Registry by name.
   *
   * Note: className is required because on minification process
   * the name of classes change and we can't simply use '....constructor.name'.
   * So, we need a way of relating minified class names to the one stored for persistency.
   *
   * i.e.
   * ```javascript
   * // Import registry class
   * class Foo() extends BaseClass {}
   *
   * Registry.register('Foo', Foo)
   * // In case 'Foo' class gets its name changed to 'c' on minification,
   * // and the persisted data type is 'Foo', we would know how to relate them.
   * ```
   *
   * @static
   * @class Registry
   */
  class Registry {
      /**
       * Registers a new class to the factory.
       *
       * @param className - Name of the registered class
       * @param classDef - Class representation(Class function, type)
       */
      static register(className, classDef) {
          if (className in registeredClasses) {
              console.warn(`There's a class registered with '${className}' name. Second registration failed.`);
              return;
          }
          // Note: To provide backwards compatibility, same classDef can be stored under multiple names.
          // Thats the reason behind using indexes instead of the classDef.
          const index = classDefinitions.length;
          classDefinitions.push(classDef);
          classNames[index] = className;
          registeredClasses[className] = index;
      }
      /**
       * Returns class definition using the name it was registered with.
       *
       * @param className - Name of the registered class
       * @return - Class representation(Class function, type)
       */
      static getClassDefinition(className) {
          if (!(className in registeredClasses))
              throw new Error(`${className} class is not registered`);
          return classDefinitions[registeredClasses[className]];
      }
      /**
       * Returns class name registered for the instantiated object.
       * @param classDefinition - Class type definition.
       * @return - Name of the registered class
       */
      static getClassName(classDefinition) {
          const classId = classDefinitions.indexOf(classDefinition);
          if (classId >= 0 && classNames[classId])
              return classNames[classId];
          throw new Error(`class is not registered`);
      }
      /**
       * The factory function that construct the class registered under the given name.
       *
       * @param className - Name of the registered class
       * @return - Instantiated object of the specified class
       */
      static constructClass(className) {
          const classDefinition = classDefinitions[registeredClasses[className]];
          if (!classDefinition)
              throw new Error(`${className} class is not registered`);
          return new classDefinition();
      }
      /**
       * For testing purpose only, never call this outside of the test scope.
       *
       * @private
       */
      static flush() {
          registeredClasses = {};
          classNames = {};
          classDefinitions = [];
      }
  }

  /**
   * String functions
   *
   */
  class StringFunctions {
      /**
       * Replaces all matches in a string.
       *
       * @static
       * @param str -
       * @param pattern -
       * @param replacement -
       * @return -
       */
      static replaceAll(str, pattern, replacement) {
          return str.replace(new RegExp(pattern, 'g'), replacement);
      }
      /**
       * Returns JSON object as a formatted string, but the numeric values are fixed to the specified precision.
       *
       * @static
       * @param val -
       * @param space -
       * @param precision -
       * @return -
       */
      static stringifyJSONWithFixedPrecision(val, space = 0, precision = 5) {
          return JSON.stringify(val, (_, val) => {
              return val ? (val.toFixed ? Number(val.toFixed(precision)) : val) : val;
          }, space);
      }
      /**
       * Transforms the given string into a numeric value.
       *
       * @static
       * @param str -
       * @return -
       */
      static hashStr(str) {
          let hash = 0;
          let i;
          let chr;
          let len;
          if (str.length === 0)
              return hash;
          for (i = 0, len = str.length; i < len; i++) {
              chr = str.charCodeAt(i);
              hash = (hash << 5) - hash + chr;
              hash |= 0; // Convert to 32bit integer
          }
          return Math.abs(hash);
      }
  }

  /**
   * Representing a Vec2(two-dimensional floating point vector). A Vec2 is for representing 2 dimensional values, such as screen coordinates or pixel coordinates within an image.
   *
   * Math types internally store values in {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} and
   * expose getters and setters for the component values.
   *
   */
  class Vec2 {
      x;
      y;
      /**
       * Creates a Vec2.
       *
       * ```javascript
       *  const myVec2 = new Vec2(1.2, 3.4)
       * ```
       *
       */
      constructor(x = 0, y = 0) {
          this.x = x;
          this.y = y;
      }
      /**
       * Setter from scalar components.
       * @param x - The x component.
       * @param y  - The y component.
       */
      set(x, y) {
          this.x = x;
          this.y = y;
      }
      /**
       * Replaces this Vec2 data with the Vec2 data passed as parameter.
       *
       * @param other - The other Vec2 to set from.
       */
      setFromOther(other) {
          this.x = other.x;
          this.y = other.y;
      }
      /**
       * Checks if this Vec2 contains the same values as the other Vec2.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns `true` if are the same Vector, otherwise, `false`.
       */
      isEqual(other) {
          return this.x == other.x && this.y == other.y;
      }
      /**
       * Checks if this Vec2 is different from another Vec2.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns `true` if the Vec2s are different, otherwise, `false`.
       */
      notEqual(other) {
          return this.x != other.x && this.y != other.y;
      }
      /**
       * Returns true if this Vec2 is approximately the same as other.
       *
       * @param other - The other Vec2 to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return Math.abs(this.x - other.x) < precision && Math.abs(this.y - other.y) < precision;
      }
      /**
       * Adds other to this Vec2 and returns the result as a new Vec2.
       *
       * @param other - The other Vec2 to add.
       * @return - Returns a new Vec2.
       */
      add(other) {
          return new Vec2(this.x + other.x, this.y + other.y);
      }
      /**
       * Adds a Vec2 to this Vec2.
       *
       * @param other - The other Vec2 to add.
       */
      addInPlace(other) {
          this.x += other.x;
          this.y += other.y;
      }
      /**
       * Subtracts a Vec2 from this Vec2 and returns the result as a new Vec2.
       *
       * @param other - The other Vec2 to subtract.
       * @return - Returns a new Vec2.
       */
      subtract(other) {
          return new Vec2(this.x - other.x, this.y - other.y);
      }
      /**
       * Subtracts a Vec2 from this Vec2.
       *
       * @param other - The other Vec2 to subtract.
       * @return - Returns a new Vec2.
       */
      subtractInPlace(other) {
          this.x -= other.x;
          this.y -= other.y;
          return this;
      }
      /**
       * Scales this Vec2 by scalar and returns the result as a new Vec2.
       *
       * @param scalar - The scalar value.
       * @return - Returns a new Vec2.
       */
      scale(scalar) {
          return new Vec2(this.x * scalar, this.y * scalar);
      }
      /**
       * Scales this Vec2 by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.x *= scalar;
          this.y *= scalar;
      }
      /**
       * Inverts this Vec2 and returns the result as a new Vec2.
       *
       * @return - Returns a new Vec2.
       */
      invert() {
          return new Vec2(1.0 / this.x, 1.0 / this.y);
      }
      /**
       * Inverts this Vec2.
       *
       * @return - The return value.
       */
      invertInPlace() {
          this.x = 1.0 / this.x;
          this.y = 1.0 / this.y;
          return this;
      }
      /**
       * Multiplies a Vec2 with this Vec2 and returns the result as a new Vec2.
       *
       * @param other - The other Vec2 to multiply with.
       * @return - Returns a new Vec2.
       */
      multiply(other) {
          return new Vec2(this.x * other.x, this.y * other.y);
      }
      /**
       * Multiplies a Vec2 with this Vec2.
       *
       * @param other - The other Vec2 to multiply with.
       */
      multiplyInPlace(other) {
          this.x *= other.x;
          this.y *= other.y;
      }
      /**
       * Calculates the squared length of this Vec2.
       *
       * @return - Returns the length squared.
       */
      lengthSquared() {
          const x = this.x;
          const y = this.y;
          return x * x + y * y;
      }
      /**
       * Calculates the length of this Vec2.
       *
       * @return - Returns the length.
       */
      length() {
          return Math.sqrt(this.lengthSquared());
      }
      /**
       * Calculates the distance to another vector.
       *
       * @param other - The other value.
       * @return - Returns the distance between vectors.
       */
      distanceTo(other) {
          const x = this.x - other.x;
          const y = this.y - other.y;
          return Math.sqrt(x * x + y * y);
      }
      /**
       * Normalizes the Vec2 and returns it as a new Vec2.
       * Multiplies coordinates value by the inverse of the vector length.
       *
       * @return - Returns the Vec2 normalized.
       */
      normalize() {
          const x = this.x;
          const y = this.y;
          let len = x * x + y * y;
          if (len < Number.EPSILON) {
              return new Vec2();
          }
          // TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          return new Vec2(x * len, y * len);
      }
      /**
       * Normalizes this Vec2 multiplying coordinate values by the inverse of the vector length.
       */
      normalizeInPlace() {
          const x = this.x;
          const y = this.y;
          let len = x * x + y * y;
          if (len < Number.EPSILON) {
              return;
          }
          len = 1 / Math.sqrt(len);
          this.set(x * len, y * len);
      }
      /**
       * Calculates the dot product of this Vec2 against another Vec2.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns the dot product.
       */
      dot(other) {
          return this.x * other.x + this.y * other.y;
      }
      /**
       * Calculates the cross product of this Vec2 against another Vec2.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns the cross product.
       */
      cross(other) {
          // just calculate the z-component
          return this.x * other.y - this.y * other.x;
      }
      /**
       * Gets the angle between this Vec2 and other assuming both are normalized vectors.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns the angle in radians.
       */
      angleTo(other) {
          const cosine = this.normalize().dot(other.normalize());
          if (cosine > 1.0)
              return 0.0;
          else if (cosine < -1.0)
              return Math.PI;
          else
              return Math.acos(cosine);
      }
      /**
       * Gets the angle between this Vec2 and other.
       *
       * @param other - The other Vec2 to compare with.
       * @return - Returns the angle in radians.
       */
      signedAngleTo(other) {
          const angle = this.angleTo(other);
          if (this.cross(other) < 0.0)
              return -angle;
          else
              return angle;
      }
      /**
       * Rotates a Vec2 in a clockwise direction and returns a new rotated Vec2.
       *
       * @param angle - The angle of rotation.
       * @return - Returns the rotated vector.
       */
      rotate(angle) {
          const cosA = Math.cos(angle);
          const sinA = Math.sin(angle);
          return new Vec2(this.x * cosA - this.y * sinA, this.x * sinA + this.y * cosA);
      }
      /**
       * Performs a linear interpolation between this Vec2 and other Vec2.
       *
       * @param other - The other Vec2 to interpolate between.
       * @param t - Interpolation amount between the two inputs.
       * @return - Returns a new Vec2.
       */
      lerp(other, t) {
          const ax = this.x;
          const ay = this.y;
          return new Vec2(ax + t * (other.x - ax), ay + t * (other.y - ay));
      }
      /**
       * Generates a random vector with the given scale.
       *
       * @param scale - Length of the resulting vector. If omitted, a unit vector will be returned.
       * @return - The return value.
       */
      setRandomDir(scale = 1.0) {
          const r = Math.random() * 2.0 * Math.PI;
          this.x = Math.cos(r) * scale;
          this.y = Math.sin(r) * scale;
          return this;
      }
      /**
       * Randomizes the scale of this Vec2 coordinates.
       *
       * @param scale - The scale value.
       * @return - The return value.
       */
      setRandom(scale = 1.0) {
          this.x = Math.random() * scale;
          this.y = Math.random() * scale;
          return this;
      }
      /**
       * Clones this Vec2 and returns a new Vec2.
       *
       * @return - Returns a new Vec2.
       */
      clone() {
          return new Vec2(this.x, this.y);
      }
      /**
       * Returns current Vec2 data as array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.x, this.y];
      }
      /**
       * Setter from an array.
       */
      fromArray(vals) {
          this.x = vals[0];
          this.y = vals[1];
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * Encodes Vec2 Class as a JSON object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              x: this.x,
              y: this.y,
          };
      }
      /**
       * Decodes a JSON object to set the state of this class.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.x = j.x;
          this.y = j.y;
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.x = reader.loadFloat32();
          this.y = reader.loadFloat32();
      }
      /**
       * Calculate the intersection point of 2 2d lines, returning the parameters values for each line.
       *
       * @param p0 - The point of the first line
       * @param d0 - The direction of the first line
       * @param p1 - The point of the second line
       * @param d1 - The direction of the second line
       * @return - Returns an array containing 2 parameter values for the 2 lines.
       */
      static intersectionOfLines(p1, p2, p3, p4) {
          // https://dirask.com/posts/JavaScript-how-to-calculate-intersection-point-of-two-lines-for-given-4-points-VjvnAj
          // down part of intersection point formula
          const d1 = (p1.x - p2.x) * (p3.y - p4.y); // (x1 - x2) * (y3 - y4)
          const d2 = (p1.y - p2.y) * (p3.x - p4.x); // (y1 - y2) * (x3 - x4)
          const d = d1 - d2;
          if (d == 0) {
              return null;
          }
          // upper part of intersection point formula
          const u1 = p1.x * p2.y - p1.y * p2.x; // (x1 * y2 - y1 * x2)
          const u4 = p3.x * p4.y - p3.y * p4.x; // (x3 * y4 - y3 * x4)
          const u2x = p3.x - p4.x; // (x3 - x4)
          const u3x = p1.x - p2.x; // (x1 - x2)
          const u2y = p3.y - p4.y; // (y3 - y4)
          const u3y = p1.y - p2.y; // (y1 - y2)
          // intersection point formula
          const px = (u1 * u2x - u3x * u4) / d;
          const py = (u1 * u2y - u3y * u4) / d;
          return new Vec2(px, py);
      }
      isValid() {
          for (const v of this.asArray()) {
              if (v == Infinity || isNaN(v))
                  return false;
          }
          return true;
      }
  }

  /**
   * Represents a three dimensional coordinate, such as 3D scene values, or mesh vertex positions.
   */
  class Vec3 {
      x;
      y;
      z;
      /**
       * Creates a Vec3.
       */
      constructor(x = 0, y = 0, z = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
      }
      /**
       * Getter for `xy` swizzel.
       *
       * @return - Returns the xy components as a Vec2.
       */
      get xy() {
          return new Vec2(this.x, this.y);
      }
      /**
       * Getter for `yz` swizzel.
       *
       * @return - Returns the yz components as a Vec2.
       */
      get yz() {
          return new Vec2(this.y, this.z);
      }
      /**
       * Setter from scalar components.
       *
       * @param x - The x component.
       * @param y - The y component.
       * @param z - The y component.
       */
      set(x, y, z) {
          this.x = x;
          this.y = y !== undefined ? y : x;
          this.z = z !== undefined ? z : x;
      }
      /**
       * Sets the state of a Vec3 Object from another Vec3.
       *
       * @param other - The other Vec3 to set from.
       */
      setFromOther(other) {
          this.x = other.x;
          this.y = other.y;
          this.z = other.z;
      }
      /**
       * Checks if the coordinates of this Vec3 are 0 0 0.
       *
       * @return - Returns `true` if the coordinates are(0, 0, 0), otherwise, `false`.
       */
      isNull() {
          return Math.abs(this.x) < Number.EPSILON && Math.abs(this.y) < Number.EPSILON && Math.abs(this.z) < Number.EPSILON;
      }
      /**
       * Checks if the coordinates of this Vec3 are 1 1 1.
       *
       * @return - Returns `true` if the coordinates are(1, 1, 1), otherwise, `false`.
       */
      is111() {
          return (Math.abs(1.0 - this.x) < Number.EPSILON &&
              Math.abs(1.0 - this.y) < Number.EPSILON &&
              Math.abs(1.0 - this.z) < Number.EPSILON);
      }
      /**
       * Checks if this Vec3 contains the same values as the other Vec3.
       *
       * @param other - The other Vec3 to compare with.
       * @return - Returns `true` if the values are the same, otherwise, `false`.
       */
      isEqual(other) {
          return this.x == other.x && this.y == other.y && this.z == other.z;
      }
      /**
       * Checks if this Vec2 is different from another Vec2.
       *
       * @param other - The other Vec3 to compare with.
       * @return - Returns `true` if the Vec3s are different, otherwise, `false`.
       */
      notEqual(other) {
          return this.x != other.x && this.y != other.y && this.z != other.z;
      }
      /**
       * Returns true if this Vec2 is approximately the same as other.
       *
       * @param other - The other Vec3 to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return (Math.abs(this.x - other.x) < precision &&
              Math.abs(this.y - other.y) < precision &&
              Math.abs(this.z - other.z) < precision);
      }
      /**
       * Adds other to this Vec3 and return the result as a new Vec3.
       *
       * @param other - The other Vec3 to add.
       * @return - Returns a new Vec3.
       */
      add(other) {
          return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
      }
      /**
       * Adds other to this Vec3.
       *
       * @param other - The other Vec3 to add.
       */
      addInPlace(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
      }
      /**
       * Subtracts other from this Vec3 and returns the result as a new Vec3.
       *
       * @param other - The other Vec3 to subtract.
       * @return - Returns a new Vec3.
       */
      subtract(other) {
          return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
      }
      /**
       * Subtracts other from this Vec3.
       *
       * @param other - The other Vec3 to subtract.
       */
      subtractInPlace(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
      }
      /**
       * Multiplies two Vec3s and returns the result as a new Vec3.
       *
       * @param other - The other Vec3 to multiply with.
       * @return - Returns a new Vec3.
       */
      multiply(other) {
          return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);
      }
      /**
       * Multiplies two Vec3s.
       *
       * @param other - The other Vec3 to multiply with.
       */
      multiplyInPlace(other) {
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
      }
      /**
       * Divides two Vec3s and returns the result as a new Vec3.
       *
       * @param vec3 - The other Vec3 to divide by.
       * @return - Returns a new Vec3.
       */
      divide(vec3) {
          return new Vec3(this.x / vec3.x, this.y / vec3.y, this.z / vec3.z);
      }
      /**
       * Divides two Vec3s.
       *
       * @param vec3 - The other Vec3 to divide by.
       */
      divideInPlace(vec3) {
          this.x /= vec3.x;
          this.y /= vec3.y;
          this.z /= vec3.z;
      }
      /**
       * Scales this Vec3 by scalar and returns the result as a new Vec3.
       *
       * @param scalar - The scalar value.
       * @return - Returns a new Vec3.
       */
      scale(scalar) {
          return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
      }
      /**
       * Scales this Vec3 by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
      }
      /**
       * Negates this Vec3 (x = -x, y = -y and z = -z), but returns the result as a new Vec3.
       *
       * @return - Returns a new Vec3.
       */
      negate() {
          return new Vec3(-this.x, -this.y, -this.z);
      }
      /**
       * Returns the inverse of this Vec3, but returns. the result as a new Vec3
       *
       * @return - Returns a new Vec3.
       */
      inverse() {
          return new Vec3(1.0 / this.x, 1.0 / this.y, 1.0 / this.z);
      }
      /**
       * Calculates the squared length of this Vec3.
       *
       * @return - Returns the length.
       */
      lengthSquared() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          return x * x + y * y + z * z;
      }
      /**
       * Calculates the length of this Vec3.
       *
       * @return - Returns the length.
       */
      length() {
          return Math.sqrt(this.lengthSquared());
      }
      /**
       * Calculates the distance to another Vec3.
       *
       * @param other - The other Vec3 to calculate the distance to.
       * @return - Returns the distance between vectors.
       */
      distanceTo(other) {
          const x = this.x - other.x;
          const y = this.y - other.y;
          const z = this.z - other.z;
          return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Normalizes the Vec3 and returns it as a new Vec3.
       * Multiplies coordinates value by the inverse of the vector length.
       *
       * @return - Returns the Vec3 normalized.
       */
      normalize() {
          let len = this.x * this.x + this.y * this.y + this.z * this.z;
          if (len < Number.EPSILON) {
              return new Vec3();
          }
          // TODO: evaluate use of glm_invsqrt here?
          len = 1.0 / Math.sqrt(len);
          return new Vec3(this.x * len, this.y * len, this.z * len);
      }
      /**
       * Normalizes this Vec3 multiplying coordinate values by the inverse of the vector length.
       *
       * @return - The return value.
       */
      normalizeInPlace() {
          let len = this.x * this.x + this.y * this.y + this.z * this.z;
          if (len < Number.EPSILON) {
              return;
          }
          len = Math.sqrt(len);
          const tmp = 1.0 / len;
          this.x *= tmp;
          this.y *= tmp;
          this.z *= tmp;
          return len;
      }
      /**
       * Creates and returns a new Vec3 with the new coordinates(calculated with this Vec3 coordinates and the specified length).
       *
       * @param length - The length value.
       * @return - The return value.
       */
      resize(length) {
          const currLen = this.x * this.x + this.y * this.y + this.z * this.z;
          if (currLen < Number.EPSILON) {
              return;
          }
          const scl = length / Math.sqrt(currLen);
          return new Vec3(this.x * scl, this.y * scl, this.z * scl);
      }
      /**
       * Modifies current coordinates using the specified length.
       *
       * @param length - The length value.
       */
      resizeInPlace(length) {
          const currLen = this.x * this.x + this.y * this.y + this.z * this.z;
          if (currLen < Number.EPSILON) {
              return;
          }
          const scl = length / Math.sqrt(currLen);
          this.x *= scl;
          this.y *= scl;
          this.z *= scl;
      }
      /**
       * Calculates the dot product of this Vec3 against another Vec3.
       *
       * @param other - The other Vec3 to compare with.
       * @return - Returns the dot product.
       */
      dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z;
      }
      /**
       * Calculates the cross product of two Vec3s and returns the result as a new Vec3.
       *
       * @param other - The other Vec3 to calculate with.
       * @return - Returns the cross product as a new Vec3.
       */
      cross(other) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const bx = other.x;
          const by = other.y;
          const bz = other.z;
          return new Vec3(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
      }
      /**
       * Gets the angle between this Vec3 and b.
       *
       * @param other - The other Vec3 to compare with.
       * @return - Returns the angle in radians.
       */
      angleTo(other) {
          const cosine = this.dot(other);
          if (cosine > 1.0) {
              return 0;
          }
          else {
              return Math.acos(cosine);
          }
      }
      /**
       * Performs a linear interpolation between this Vec3 and other.
       *
       * @param other - The other Vec3 to interpolate towards.
       * @param t - Interpolation ratio.
       * @return - Returns a new Vec3.
       */
      lerp(other, t) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          return new Vec3(ax + t * (other.x - ax), ay + t * (other.y - ay), az + t * (other.z - az));
      }
      /**
       * Returns a new Vec3 whose component values are the abs of this Vec3s component values.
       *
       * @return - Returns a new Vec3.
       */
      abs() {
          return new Vec3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));
      }
      /**
       * Sets the vector a random vector on the surface of a sphere with the radius of the given scale value.
       *
       * @param scale - The radius of the surface sphere.
       * @return - The random Vec3.
       */
      setRandomDir(scale = 1.0) {
          const r = Math.random() * 2.0 * Math.PI;
          const z = Math.random() * 2.0 - 1.0;
          const zScale = Math.sqrt(1.0 - z * z) * scale;
          this.x = Math.cos(r) * zScale;
          this.y = Math.sin(r) * zScale;
          this.z = z * scale;
          return this;
      }
      /**
       * Generates a random vector anywhere in the sphere defined by the provided scale value.
       *
       * @param scale - The radius of the bounding sphere.
       * @return - The random Vec3.
       */
      setRandom(scale = 1.0) {
          this.x = (Math.random() - 0.5) * scale;
          this.y = (Math.random() - 0.5) * scale;
          this.z = (Math.random() - 0.5) * scale;
          return this;
      }
      /**
       * Clones this Vec3 and returns a new Vec3.
       *
       * @return - Returns a new Vec3.
       */
      clone() {
          return new Vec3(this.x, this.y, this.z);
      }
      /**
       * Returns the type as an array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.x, this.y, this.z];
      }
      /**
       * Setter from an array.
       */
      fromArray(vals) {
          this.x = vals[0];
          this.y = vals[1];
          this.z = vals[1];
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * Encodes Vec3 Class as a JSON object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              x: this.x,
              y: this.y,
              z: this.z,
          };
      }
      /**
       * Decodes a JSON object to set the state of this class.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.x = j.x;
          this.y = j.y;
          this.z = j.z;
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.x = reader.loadFloat32();
          this.y = reader.loadFloat32();
          this.z = reader.loadFloat32();
      }
      isValid() {
          for (const v of this.asArray()) {
              if (v == Infinity || isNaN(v))
                  return false;
          }
          return true;
      }
  }

  /* eslint-disable new-cap */
  /**
   * Represents a four-dimensional coordinate.
   * Math types internally store values in {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array|Float32Array} and
   * expose getters and setters for the component values.
   *
   */
  class Vec4 {
      x;
      y;
      z;
      w;
      /**
       * Creates a Vec4.
       *
       */
      constructor(x = 0, y = 0, z = 0, w = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
      }
      /**
       * Getter for `xyz` swizzel.
       *
       * @return - Returns the z value.
       */
      get xyz() {
          return new Vec3(this.x, this.y, this.z);
      }
      /**
       * Setter from scalar components.
       *
       * @param x - The x value.
       * @param y  - The y value.
       * @param z  - The y value.
       * @param w  - The w value.
       */
      set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
      }
      /**
       * Sets the state of a Vec4 Object from another Vec4.
       *
       * @param other - The other Vec4 to set from.
       */
      setFromOther(other) {
          this.x = other.x;
          this.y = other.y;
          this.z = other.z;
          this.w = other.w;
      }
      /**
       * Checks if this Vec4 contains the same values as the other Vec4.
       *
       * @param other - The other Vec4 to compare with.
       * @return - Returns true or false.
       */
      isEqual(other) {
          return this.x == other.x && this.y == other.y && this.z == other.z && this.w == other.w;
      }
      /**
       * Checks if this Vec4 is different from another Vec4.
       *
       * @param other - The other Vec4 to compare with.
       * @return - Returns true or false.
       */
      notEqual(other) {
          return this.x != other.x && this.y != other.y && this.z != other.z && this.w != other.w;
      }
      /**
       * Returns true if this Vec4 is approximately the same as other.
       *
       * @param other - The other Vec4 to compare with.
       * @param precision - The precision to which the values must match.
       * @return - The return value.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return (Math.abs(this.x - other.x) < precision &&
              Math.abs(this.y - other.y) < precision &&
              Math.abs(this.z - other.z) < precision &&
              Math.abs(this.w - other.w) < precision);
      }
      /**
       * Adds other to this Vec4 and returns the result as a new Vec4.
       *
       * @param other - The other Vec4 to add.
       * @return - Returns a new Vec4.
       */
      add(other) {
          return new Vec4(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);
      }
      /**
       * Adds other to this Vec4 mutating the values of this instance
       *
       * @param other - The other Vec4 to add.
       */
      addInPlace(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          this.w += other.w;
      }
      /**
       * Subtracts other from this Vec4 and returns then result as a new Vec4.
       *
       * @param other - The other Vec4 to subtract.
       * @return - Returns a new Vec4.
       */
      subtract(other) {
          return new Vec4(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);
      }
      /**
       * Subtracts other from this Vec4 mutating the values of this instance
       *
       * @param other - The other Vec4 to subtract.
       */
      subtractInPlace(other) {
          this.x -= other.x;
          this.y -= other.y;
          this.z -= other.z;
          this.w -= other.w;
      }
      /**
       * Multiplies two Vec4s and returns the result as a new Vec4.
       *
       * @param other - The other Vec4 to multiply with.
       * @return - Returns a new Vec4.
       */
      multiply(other) {
          return new Vec4(this.x * other.x, this.y * other.y, this.z * other.z, this.w * other.w);
      }
      /**
       * Multiplies two Vec4s mutating the values of this instance
       *
       * @param other - The other Vec4 to multiply with.
       */
      multiplyInPlace(other) {
          this.x *= other.x;
          this.y *= other.y;
          this.z *= other.z;
          this.w *= other.w;
      }
      /**
       * Divides two Vec4s and returns the result as a new Vec4.
       *
       * @param other - The other Vec4 to divide by.
       * @return - Returns a new Vec4.
       */
      divide(other) {
          return new Vec4(this.x / other.x, this.y / other.y, this.z / other.z, this.w / other.w);
      }
      /**
       * Divides two Vec4s.
       *
       * @param other - The other Vec4 to divide by.
       */
      divideInPlace(other) {
          this.x /= other.x;
          this.y /= other.y;
          this.z /= other.z;
          this.w /= other.w;
      }
      /**
       * Scales this Vec4 by scalar and returns the result as a new Vec4.
       *
       * @param scalar - The scalar value.
       * @return - The return value.
       */
      scale(scalar) {
          return new Vec4(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar);
      }
      /**
       * Scales this Vec4 by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.set(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar);
      }
      /**
       * Calculates the length of this Vec4.
       *
       * @return - Returns the length.
       */
      length() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
      }
      /**
       * Calculates the squared length of this Vec4.
       *
       * @return - Returns the length.
       */
      lengthSquared() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return x * x + y * y + z * z + w * w;
      }
      /**
       * Normalizes the Vec4 and returns it as a new Vec4.
       * Multiplies coordinates value by the inverse of the vector length.
       *
       * @return - Returns the Vec4 normalized.
       */
      normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len < Number.EPSILON) {
              return new Vec4();
          }
          // TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          return new Vec4(x * len, y * len, z * len);
      }
      /**
       * Normalizes this Vec4 multiplying coordinate values by the inverse of the vector length.
       */
      normalizeInPlace() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len < Number.EPSILON) {
              return;
          }
          len = 1 / Math.sqrt(len);
          this.set(x * len, y * len, z * len, w * len);
      }
      /**
       * Calculates the dot product of this Vec4 against another Vec4.
       *
       * @param other - The other Vec4 to compare with.
       * @return - Returns the dot product.
       */
      dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w; // TODO: other.w used to be b.w?
      }
      /**
       * Calculates the cross product of two Vec4s and returns the result as a new Vec4.
       *
       * @param other - The other Vec4 to calculate with.
       * @return - Returns the cross product as a new Vec4.
       */
      cross(other) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const at = this.w;
          const bx = other.x;
          const by = other.y;
          const bz = other.z;
          const bt = other.w;
          return new Vec4(ay * bz - az * by, az * bt - at * bz, at * bx - ax * bt, ax * by - ay * bx);
      }
      /**
       * Gets the angle between this Vec4 and b.
       *
       * @param other - The other Vec4 to compare with.
       * @return - Returns the angle in radians.
       */
      angleTo(other) {
          const tempA = this.normalize();
          const tempB = other.normalize();
          const cosine = tempA.dot(tempB);
          if (cosine > 1.0) {
              return 0;
          }
          else {
              return Math.acos(cosine);
          }
      }
      /**
       * Performs a linear interpolation between this Vec4 and other.
       *
       * @param other - The other Vec4 to interpolate between.
       * @param w - Interpolation amount between the two inputs.
       * @return - Returns a new Vec4.
       */
      lerp(other, t) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const at = this.w;
          return new Vec4(ax + t * (other.x - ax), ay + t * (other.y - ay), az + t * (other.z - az), at + t * (other.w - at));
      }
      /**
       * Generates a random vector with the given scale.
       *
       * @param scale - Length of the resulting vector. If omitted, a unit vector will be returned.
       * @return - The return value.
       */
      // random(scale = 1.0) {
      //   const r = glMatrix.RANDOM() * 2.0 * Math.PI
      //   const z = glMatrix.RANDOM() * 2.0 - 1.0
      //   const zScale = Math.sqrt(1.0 - z * z) * scale
      //   out[0] = Math.cos(r) * zScale
      //   out[1] = Math.sin(r) * zScale
      //   out[2] = z * scale
      //   return out
      // }
      /**
       * Clones this Vec4 and returns a new Vec4.
       *
       * @return - Returns a new Vec4.
       */
      clone() {
          return new Vec4(this.x, this.y, this.z, this.w);
      }
      /**
       * Converts this Vec4 into a Vec3.
       *
       * @return - Returns the value as a new Vec3.
       */
      toVec3() {
          return new Vec3(this.x, this.y, this.z);
      }
      /**
       * Returns the type as an array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.x, this.y, this.z, this.w];
      }
      /**
       * Setter from an array.
       */
      fromArray(vals) {
          this.x = vals[0];
          this.y = vals[1];
          this.z = vals[1];
          this.w = vals[1];
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       * @return - The json object.
       */
      toJSON() {
          return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w,
          };
      }
      /**
       * Decodes a JSON object to set the state of this class.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.x = j.x;
          this.y = j.y;
          this.z = j.z;
          this.w = j.w;
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.x = reader.loadFloat32();
          this.y = reader.loadFloat32();
          this.z = reader.loadFloat32();
          this.w = reader.loadFloat32();
      }
      /**
       * Verifies if the values stored in this Math type are valid numeric values.
       * Returns `false` If at least one of the values is either {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity|Infinity} or
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referencia/Objetos_globales/NaN|NaN}.
       *
       * @return - Returns the result as a boolean.
       */
      isValid() {
          for (const v of this.asArray()) {
              if (v == Infinity || isNaN(v))
                  return false;
          }
          return true;
      }
  }

  /* eslint-disable require-jsdoc */
  /**
   * Class representing the red, green, blue and alpha channel of a color as 8bit values.
   *
   */
  class RGBA {
      r = 0;
      g = 0;
      b = 0;
      a = 255;
      /**
       * Create a RGBA.
       * @param r - The red channel of a color.
       * @param g - The green channel of a color.
       * @param b - The blue channel of a color.
       * @param a - The alpha (transparency) channel of a color.
       */
      constructor(r = 0, g = 0, b = 0, a = 255) {
          if (typeof r == 'string') {
              if (r.startsWith('#')) {
                  this.setFromHex(r);
              }
              else {
                  this.setFromCSSColorName(r);
              }
          }
          else {
              this.r = r;
              this.g = g;
              this.b = b;
              this.a = a;
          }
      }
      /**
       * Setter from scalar components.
       *
       * @param r - The red channel.
       * @param g  - The green channel.
       * @param b  - The blue channel.
       * @param a  - The alpha channel.
       */
      set(r, g, b, a = 255) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
      }
      /**
       * Setter from another RGBA color.
       *
       * @param other - The other RGBA to set from.
       */
      setFromOther(other) {
          this.r = other.r;
          this.g = other.g;
          this.b = other.b;
          this.a = other.a;
      }
      /**
       * Setter from a scalar array.
       *
       * @param values - The array of values.
       */
      setFromArray(values) {
          this.r = values[0];
          this.g = values[1];
          this.b = values[2];
          this.a = values.length == 4 ? values[3] : 1.0;
      }
      /**
       * Setter from a hexadecimal value.
       * E.g. #ff0000
       *
       * @param hex - The hex value.
       */
      setFromHex(hex) {
          function hexToRgb(hex) {
              const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return result
                  ? {
                      r: parseInt(result[1], 16),
                      g: parseInt(result[2], 16),
                      b: parseInt(result[3], 16),
                  }
                  : null;
          }
          const rgb = hexToRgb(hex);
          if (!rgb) {
              console.warn('Invalid hex code:' + hex);
              return;
          }
          this.set(rgb.r, rgb.g, rgb.b);
      }
      /**
       * Setter from a CSS color name.
       * E.g. "red"
       *
       * @param name - The CSS color name.
       */
      setFromCSSColorName(name) {
          const colourNameToHex = (colour) => {
              const colors = {
                  aliceblue: '#f0f8ff',
                  antiquewhite: '#faebd7',
                  aqua: '#00ffff',
                  aquamarine: '#7fffd4',
                  azure: '#f0ffff',
                  beige: '#f5f5dc',
                  bisque: '#ffe4c4',
                  black: '#000000',
                  blanchedalmond: '#ffebcd',
                  blue: '#0000ff',
                  blueviolet: '#8a2be2',
                  brown: '#a52a2a',
                  burlywood: '#deb887',
                  cadetblue: '#5f9ea0',
                  chartreuse: '#7fff00',
                  chocolate: '#d2691e',
                  coral: '#ff7f50',
                  cornflowerblue: '#6495ed',
                  cornsilk: '#fff8dc',
                  crimson: '#dc143c',
                  cyan: '#00ffff',
                  darkblue: '#00008b',
                  darkcyan: '#008b8b',
                  darkgoldenrod: '#b8860b',
                  darkgray: '#a9a9a9',
                  darkgreen: '#006400',
                  darkkhaki: '#bdb76b',
                  darkmagenta: '#8b008b',
                  darkolivegreen: '#556b2f',
                  darkorange: '#ff8c00',
                  darkorchid: '#9932cc',
                  darkred: '#8b0000',
                  darksalmon: '#e9967a',
                  darkseagreen: '#8fbc8f',
                  darkslateblue: '#483d8b',
                  darkslategray: '#2f4f4f',
                  darkturquoise: '#00ced1',
                  darkviolet: '#9400d3',
                  deeppink: '#ff1493',
                  deepskyblue: '#00bfff',
                  dimgray: '#696969',
                  dodgerblue: '#1e90ff',
                  firebrick: '#b22222',
                  floralwhite: '#fffaf0',
                  forestgreen: '#228b22',
                  fuchsia: '#ff00ff',
                  gainsboro: '#dcdcdc',
                  ghostwhite: '#f8f8ff',
                  gold: '#ffd700',
                  goldenrod: '#daa520',
                  gray: '#808080',
                  green: '#008000',
                  greenyellow: '#adff2f',
                  honeydew: '#f0fff0',
                  hotpink: '#ff69b4',
                  'indianred ': '#cd5c5c',
                  indigo: '#4b0082',
                  ivory: '#fffff0',
                  khaki: '#f0e68c',
                  lavender: '#e6e6fa',
                  lavenderblush: '#fff0f5',
                  lawngreen: '#7cfc00',
                  lemonchiffon: '#fffacd',
                  lightblue: '#add8e6',
                  lightcoral: '#f08080',
                  lightcyan: '#e0ffff',
                  lightgoldenrodyellow: '#fafad2',
                  lightgrey: '#d3d3d3',
                  lightgreen: '#90ee90',
                  lightpink: '#ffb6c1',
                  lightsalmon: '#ffa07a',
                  lightseagreen: '#20b2aa',
                  lightskyblue: '#87cefa',
                  lightslategray: '#778899',
                  lightsteelblue: '#b0c4de',
                  lightyellow: '#ffffe0',
                  lime: '#00ff00',
                  limegreen: '#32cd32',
                  linen: '#faf0e6',
                  magenta: '#ff00ff',
                  maroon: '#800000',
                  mediumaquamarine: '#66cdaa',
                  mediumblue: '#0000cd',
                  mediumorchid: '#ba55d3',
                  mediumpurple: '#9370d8',
                  mediumseagreen: '#3cb371',
                  mediumslateblue: '#7b68ee',
                  mediumspringgreen: '#00fa9a',
                  mediumturquoise: '#48d1cc',
                  mediumvioletred: '#c71585',
                  midnightblue: '#191970',
                  mintcream: '#f5fffa',
                  mistyrose: '#ffe4e1',
                  moccasin: '#ffe4b5',
                  navajowhite: '#ffdead',
                  navy: '#000080',
                  oldlace: '#fdf5e6',
                  olive: '#808000',
                  olivedrab: '#6b8e23',
                  orange: '#ffa500',
                  orangered: '#ff4500',
                  orchid: '#da70d6',
                  palegoldenrod: '#eee8aa',
                  palegreen: '#98fb98',
                  paleturquoise: '#afeeee',
                  palevioletred: '#d87093',
                  papayawhip: '#ffefd5',
                  peachpuff: '#ffdab9',
                  peru: '#cd853f',
                  pink: '#ffc0cb',
                  plum: '#dda0dd',
                  powderblue: '#b0e0e6',
                  purple: '#800080',
                  rebeccapurple: '#663399',
                  red: '#ff0000',
                  rosybrown: '#bc8f8f',
                  royalblue: '#4169e1',
                  saddlebrown: '#8b4513',
                  salmon: '#fa8072',
                  sandybrown: '#f4a460',
                  seagreen: '#2e8b57',
                  seashell: '#fff5ee',
                  sienna: '#a0522d',
                  silver: '#c0c0c0',
                  skyblue: '#87ceeb',
                  slateblue: '#6a5acd',
                  slategray: '#708090',
                  snow: '#fffafa',
                  springgreen: '#00ff7f',
                  steelblue: '#4682b4',
                  tan: '#d2b48c',
                  teal: '#008080',
                  thistle: '#d8bfd8',
                  tomato: '#ff6347',
                  turquoise: '#40e0d0',
                  violet: '#ee82ee',
                  wheat: '#f5deb3',
                  white: '#ffffff',
                  whitesmoke: '#f5f5f5',
                  yellow: '#ffff00',
                  yellowgreen: '#9acd32',
              };
              return colors[colour.toLowerCase()];
          };
          if (name.startsWith('#')) {
              this.setFromHex(name);
          }
          else {
              const hexColor = colourNameToHex(name);
              if (hexColor)
                  this.setFromHex(hexColor);
          }
      }
      /**
       * Returns the hexadecimal value of this RGBA color.
       *
       * @return - Returns the hex value.
       */
      toHex() {
          function componentToHex(int) {
              const hex = int.toString(16);
              return hex.length == 1 ? '0' + hex : hex;
          }
          return '#' + componentToHex(this.r) + componentToHex(this.g) + componentToHex(this.b);
      }
      /**
       * Returns true if this RGBA color is exactly the same as other.
       *
       * @param other - The other RGBA to compare with.
       * @return - Returns true or false.
       */
      equal(other) {
          return this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;
      }
      /**
       * Returns true if this RGBA color is NOT exactly the same as other.
       *
       * @param other -  The other RGBA to compare with.
       * @return - Returns true or false.
       */
      notEquals(other) {
          return this.r != other.r && this.g != other.g && this.b != other.b && this.a != other.a;
      }
      /**
       * Returns true if this RGBA color is approximately the same as other.
       *
       * @param other - The other RGBA to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return (Math.abs(this.r - other.r) < precision &&
              Math.abs(this.g - other.g) < precision &&
              Math.abs(this.b - other.b) < precision &&
              Math.abs(this.a - other.a) < precision);
      }
      /**
       * Returns a new RGBA color which is this RGBA color added to other.
       *
       * @param other - The other RGBA to add.
       * @return - Returns a new RGBA.
       */
      add(other) {
          return new RGBA(this.r + other.r, this.g + other.g, this.b + other.b, this.a + other.a);
      }
      /**
       * Returns a new RGBA color which is this RGBA color subtracted from other.
       *
       * @param other - The other RGBA to subtract.
       * @return - Returns a new RGBA.
       */
      subtract(other) {
          return new RGBA(this.r - other.r, this.g - other.g, this.b - other.b, this.a - other.a);
      }
      /**
       * Returns a new RGBA color which is this vector scaled by scalar.
       *
       * @param scalar - The scalar value.
       * @return - Returns a new RGBA.
       */
      scale(scalar) {
          return new RGBA(this.r * scalar, this.g * scalar, this.b * scalar, this.a * scalar);
      }
      /**
       * Scales this RGBA color by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.r *= scalar;
          this.g *= scalar;
          this.b *= scalar;
          this.a *= scalar;
      }
      /**
       * Apply gamma correction to this RGBA color.
       *
       * @param gamma - The gamma value.
       */
      applyGamma(gamma) {
          this.set(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
      }
      /**
       * Converts to linear color space and returns a new color.
       * @param gamma - The gamma value.
       * @return - Returns a new RGBA.
       */
      toLinear(gamma = 2.2) {
          return new RGBA(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
      }
      /**
       * Converts to gamma color space and returns a new RGBA color.
       *
       * @param gamma - The gamma value.
       * @return - Returns a new RGBA.
       */
      toGamma(gamma = 2.2) {
          return new RGBA(Math.pow(this.r, 1.0 / gamma), Math.pow(this.g, 1.0 / gamma), Math.pow(this.b, 1.0 / gamma), this.a);
      }
      /**
       * Calculates and returns the relative luminance of the linear RGB component.
       *
       * @return - The return value.
       */
      luminance() {
          return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b;
      }
      /**
       * Performs a linear interpolation between this RGBA color and other.
       *
       * @param other - The other RGBA to interpolate between.
       * @param t - Interpolation amount between the two inputs.
       * @return - Returns a new RGBA.
       */
      lerp(other, t) {
          const ar = this.r;
          const ag = this.g;
          const ab = this.b;
          const aa = this.a;
          return new RGBA(ar + t * (other.r - ar), ag + t * (other.g - ag), ab + t * (other.b - ab), aa + t * (other.a - aa));
      }
      /**
       * Creates a random RGBA.
       *
       * @param gammaOffset - The gamma offset.
       * @param randomAlpha - Determines whether the alpha channel is random.
       * @return - Returns a new random RGBA.
       */
      static random(gammaOffset = 0.0, randomAlpha = false) {
          if (gammaOffset > 0.0) {
              return new RGBA(gammaOffset + Math.random() * (1.0 - gammaOffset), gammaOffset + Math.random() * (1.0 - gammaOffset), gammaOffset + Math.random() * (1.0 - gammaOffset), randomAlpha ? gammaOffset + Math.random() * (1.0 - gammaOffset) : 1.0);
          }
          else if (gammaOffset < 0.0) {
              return new RGBA(Math.random() * (1.0 + gammaOffset), Math.random() * (1.0 + gammaOffset), Math.random() * (1.0 + gammaOffset), randomAlpha ? Math.random() * (1.0 + gammaOffset) : 1.0);
          }
          else {
              return new RGBA(Math.random(), Math.random(), Math.random(), randomAlpha ? Math.random() : 1.0);
          }
      }
      /**
       * Clones this RGBA color and returns a new RGBA color.
       *
       * @return - Returns a new RGBA.
       */
      clone() {
          return new RGBA(this.r, this.g, this.b, this.a);
      }
      /**
       * Returns the type as an array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.r, this.g, this.b, this.a];
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              r: this.r,
              g: this.g,
              b: this.b,
              a: this.a,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.r = j.r;
          this.g = j.g;
          this.b = j.b;
          this.a = j.a;
      }
      /**
       * Returns the CSS rgba string.
       *
       * @return - The return value.
       */
      toCSSString() {
          return ('rgba(' +
              Math.round(this.r * 255) +
              ', ' +
              Math.round(this.g * 255) +
              ', ' +
              Math.round(this.b * 255) +
              ', ' +
              this.a +
              ')');
      }
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  let counter$1 = 0;
  /**
   * Class representing a BaseClass.
   * The BaseClass is the foundation class of the SceneTree, as almost all classes derive from it.
   */
  class BaseClass {
      __id;
      /**
       * Create an BaseClass.
       */
      constructor() {
          this.__id = ++counter$1;
      }
      /**
       * Every instance of each class based on BaseClass is assigned a unique number.
       * This number is not persistent in between different loads of a scene.
       * Returns the unique id of the object.
       * @return - The Id of the object.
       */
      getId() {
          return this.__id;
      }
      /**
       * Returns the unmangled name of the class.
       * @return - The name of the class definition.
       */
      getClassName() {
          return Registry.getClassName(Object.getPrototypeOf(this).constructor);
      }
  }

  /** Class representing a BaseEvent. */
  class BaseEvent {
      /**
       * Create an BaseEvent.
       */
      constructor() { }
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Provides an interface for emitting events under given names, and registering listeners to those events.
   * This is a base class for most classes in the Scene Tree and Renderer, enabling observers to listen to changes throughout the system.
   * The interface exposed is similar to [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter) in Node.
   *
   * Similar to how the DOM event system in the browser works, events are registered by name.
   * Example: Registering a listener for a custom event, and then emitting that event.
   * ```javascript
   *  const ee = new EventEmitter()
   *
   *  const eventID = ee.on('myEvent', (event) => {
   *    console.log('My Event was emitted:', event)
   *  })
   *
   *  ee.emit('myEvent', { data: 42 })
   *  // We no longer want to listen to this event, so let's remove the listener.
   *  ee.off('myEvent', eventID)
   * ```
   *
   *
   */
  class EventEmitter extends BaseClass {
      listeners = {};
      /**
       * Initializes an empty `listeners` map that will host all the events,
       * which implies that it doesn't allow multiple events with the same name.
       *
       */
      constructor() {
          super();
      }
      /**
       * Adds a listener function for a given event name.
       *
       * @param eventName - The name of the event.
       * @param listener - The listener function(callback).
       * @return - the id that can be used to remove the listener.
       */
      on(eventName, listener) {
          if (!listener) {
              throw new Error('Missing listener.');
          }
          if (!this.listeners[eventName]) {
              this.listeners[eventName] = [];
          }
          const listeners = this.listeners[eventName];
          if (listeners.includes(listener)) {
              throw new Error(`Listener "${listener.name}" already connected to event "${eventName}".`);
          }
          // TODO: Deprecate alongside #addListener.
          const id = listeners.length;
          listeners[id] = listener;
          return id;
      }
      /**
       * Similar to the `on` method with the difference that when the event is triggered,
       * it is automatically unregistered meaning that the event listener will be triggered at most one time.
       *
       * Useful for events that we expect to trigger one time, such as when assets load.
       * ```javascript
       * const asset = new Asset();
       * asset.once('loaded', () => {
       *   console.log("Yay! the asset is loaded")
       * })
       * ```
       *
       * @param eventName - The eventName value
       * @param listener - The listener value
       * @return - the id that can be used to remove the listener.
       */
      once(eventName, listener) {
          const cb = (event) => {
              this.off(eventName, cb);
              listener(event);
          };
          return this.on(eventName, cb);
      }
      /**
       * Removes a listener from the specified event, using either the function or the index id. Depends on what is passed in.
       *
       * @param eventName - The name of the event.
       * @param listenerOrId - The listener function or the id number returned by 'on'.
       */
      off(eventName, listenerOrId) {
          if (listenerOrId == undefined) {
              throw new Error('Missing callback function (listener).');
          }
          const listeners = this.listeners[eventName] || [];
          if (typeof listenerOrId == 'number') {
              const id = listenerOrId;
              // Note: do not splice the array as that would change the indexes of existing listeners.
              listeners[id] = null;
              return;
          }
          const listener = listenerOrId;
          listeners.forEach((e, i) => {
              if (e === listener) {
                  // Note: do not splice the array as that would change the indexes of existing listeners.
                  listeners[i] = null;
              }
          });
      }
      /**
       * remove listener by ID returned from #on
       *
       * @param eventName - The name of the event.
       * @param id - The id returned by addListener
       */
      removeListenerById(eventName, id) {
          this.off(eventName, id);
      }
      /**
       * Triggers all listener functions in an event.
       *
       * @param eventName - The name of the event.
       * @param event - The data you want to pass down to all listener functions as parameter.
       *
       */
      emit(eventName, event = new BaseEvent()) {
          const listeners = this.listeners[eventName] || [];
          listeners.forEach((fn) => {
              // Skip disconnected listeners.
              if (fn) {
                  fn(event);
              }
          });
      }
  }

  class ResizedEvent extends BaseEvent {
      width;
      height;
      constructor(newWidth, newHeight) {
          super();
          this.width = newWidth;
          this.height = newHeight;
      }
  }

  // Taken from here: https://github.com/jakesgordon/bin-packing/blob/master/js/packer.growing.js
  /******************************************************************************

  This is a binary tree based bin packing algorithm that is more complex than
  the simple Packer (packer.js). Instead of starting off with a fixed width and
  height, it starts with the width and height of the first block passed and then
  grows as necessary to accommodate each subsequent block. As it grows it attempts
  to maintain a roughly square ratio by making 'smart' choices about whether to
  grow right or down.

  When growing, the algorithm can only grow to the right OR down. Therefore, if
  the new block is BOTH wider and taller than the current target then it will be
  rejected. This makes it very important to initialize with a sensible starting
  width and height. If you are providing sorted input (largest first) then this
  will not be an issue.

  A potential way to solve this limitation would be to allow growth in BOTH
  directions at once, but this requires maintaining a more complex tree
  with 3 children (down, right and center) and that complexity can be avoided
  by simply choosing a sensible starting block.

  Best results occur when the input blocks are sorted by height, or even better
  when sorted by max(width,height).

  Inputs:
  ------

    blocks: array of any objects that have .w and .h attributes

  Outputs:
  -------

    marks each block that fits with a .fit attribute pointing to a
    node with .x and .y coordinates

  Example:
  -------

    var blocks = [
      { w: 100, h: 100 },
      { w: 100, h: 100 },
      { w:  80, h:  80 },
      { w:  80, h:  80 },
      etc
      etc
    ];

    var packer = new GrowingPacker();
    packer.fit(blocks);

    for(var n = 0 ; n < blocks.length ; n++) {
      var block = blocks[n];
      if (block.fit) {
        Draw(block.fit.x, block.fit.y, block.w, block.h);
      }
    }


  ******************************************************************************/
  class GrowingPacker extends EventEmitter {
      root;
      constructor(w = 0, h = 0) {
          super();
          this.root = {
              x: 0,
              y: 0,
              w: w,
              h: h,
          };
      }
      fit(blocks) {
          const len = blocks.length;
          if (len == 0)
              return;
          let resized = false;
          if (this.root.w < blocks[0].w) {
              this.root.w = blocks[0].w;
              resized = true;
          }
          if (this.root.h < blocks[0].h) {
              this.root.h = blocks[0].h;
              resized = true;
          }
          if (resized) {
              const event = new ResizedEvent(this.root.w, this.root.h);
              this.emit('resized', event);
          }
          const eachBlock = (block) => {
              block.fit = this.__addBlock(block);
          };
          blocks.forEach(eachBlock);
      }
      __addBlock(block) {
          const node = this.findNode(this.root, block.w, block.h);
          if (node)
              return this.splitNode(node, block.w, block.h);
          else
              return this.growNode(block.w, block.h);
      }
      addBlock(block) {
          let resized = false;
          if (this.root.w < block.w) {
              this.root.w = block.w;
              resized = true;
          }
          if (this.root.h < block.h) {
              this.root.h = block.h;
              resized = true;
          }
          if (resized) {
              const event = new ResizedEvent(this.root.w, this.root.h);
              this.emit('resized', event);
          }
          const node = this.findNode(this.root, block.w, block.h);
          if (node)
              return this.splitNode(node, block.w, block.h);
          else
              return this.growNode(block.w, block.h);
      }
      findNode(root, w, h) {
          if (root.used)
              return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);
          else if (w <= root.w && h <= root.h)
              return root;
          else
              return null;
      }
      splitNode(node, w, h) {
          node.used = true;
          node.down = {
              x: node.x,
              y: node.y + h,
              w: node.w,
              h: node.h - h,
          };
          node.right = {
              x: node.x + w,
              y: node.y,
              w: node.w - w,
              h: h,
          };
          return node;
      }
      growNode(w, h) {
          const canGrowDown = w <= this.root.w;
          const canGrowRight = h <= this.root.h;
          const shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width
          const shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height
          if (shouldGrowRight)
              return this.growRight(w, h);
          else if (shouldGrowDown)
              return this.growDown(w, h);
          else if (canGrowRight)
              return this.growRight(w, h);
          else if (canGrowDown)
              return this.growDown(w, h);
          else
              return null; // need to ensure sensible root starting size to avoid this happening
      }
      growRight(w, h) {
          this.root = {
              used: true,
              x: 0,
              y: 0,
              w: this.root.w + w,
              h: this.root.h,
              down: this.root,
              right: {
                  x: this.root.w,
                  y: 0,
                  w: w,
                  h: this.root.h,
              },
          };
          const node = this.findNode(this.root, w, h);
          let res;
          if (node)
              res = this.splitNode(node, w, h);
          const event = new ResizedEvent(this.root.w, this.root.h);
          this.emit('resized', event);
          return res;
      }
      growDown(w, h) {
          this.root = {
              used: true,
              x: 0,
              y: 0,
              w: this.root.w,
              h: this.root.h + h,
              down: {
                  x: 0,
                  y: this.root.h,
                  w: this.root.w,
                  h: h,
              },
              right: this.root,
          };
          const node = this.findNode(this.root, w, h);
          let res;
          if (node)
              res = this.splitNode(node, w, h);
          const event = new ResizedEvent(this.root.w, this.root.h);
          this.emit('resized', event);
          return res;
      }
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  const UInt8 = 0;
  const SInt8 = 1;
  const UInt16 = 2;
  const SInt16 = 3;
  const UInt32 = 4;
  const SInt32 = 5;
  const Float32 = 6;
  /**
   * Math Functions
   */
  class MathFunctions {
      /**
       * Converts Radians to Degrees
       *
       * @static
       * @param rad - Radians value
       * @return - Degrees equivalent
       */
      static radToDeg(rad) {
          return rad / (Math.PI / 180);
      }
      /**
       * Converts Degrees to Radiants
       *
       * @static
       * @param deg - Degrees value
       * @return -  Radians equivalent
       */
      static degToRad(deg) {
          return deg * (Math.PI / 180);
      }
      /**
       * Verifies if the specified parameter is numeric.
       *
       * @static
       * @param number - Number to test
       * @return - `true` when is a valid number
       */
      static isNumeric(number) {
          return !isNaN(parseFloat(number)) && isFinite(number);
      }
      /**
       * Generates and returns a random integer within the specified range.
       *
       * @static
       * @param min - Lower value random int can be.
       * @param max - Highest value random int can be.
       * @return - Random number inside range.
       */
      static randomInt(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min)) + min;
      }
      /**
       * Calculates a lineal interpolation between two inputs for the specified parameter(t).
       *
       * @static
       * @param v0 -
       * @param v1 -
       * @param t -
       * @return -
       */
      static lerp(v0, v1, t) {
          return v0 + t * (v1 - v0);
      }
      /**
       * Restricts the specified value between two numbers
       *
       * @static
       * @param value
       * @param min
       * @param max
       * @return
       */
      static clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
      }
      /**
       * Returns the nearest pow of two value of the specified number.
       *
       * @static
       * @param value -
       * @return -
       */
      static nearestPow2(value) {
          return Math.pow(2, Math.round(Math.log(value) / Math.log(2)));
      }
      /**
       * Returns the nearest pow of ten value of the specified number.
       *
       * @static
       * @param value -
       * @return -
       */
      static nearestPow10(value) {
          return Math.pow(10, Math.round(Math.log10(value) / Math.log10(10)));
      }
      /**
       * Returns the next pow of two value of the specified number.
       *
       * @static
       * @param value -
       * @return -
       */
      static nextPow2(value) {
          if (this.fract(Math.log2(value)) == 0) {
              return value;
          }
          let exp = 0;
          while (value > 0) {
              exp++;
              value = value >> 1;
          }
          return 1 << exp;
      }
      /**
       * Returns the fractional component of a number
       *
       * @static
       * @param value -
       * @return -
       */
      static fract(value) {
          if (value == 0)
              return 0;
          if (value < 0) {
              if (value > -1.0)
                  return -value;
              return -value % Math.floor(-value);
          }
          if (value < 1.0)
              return value;
          return value % Math.floor(value);
      }
      /**
       * Moves the specified value from one numeric domain(range) to another.
       *
       * @static
       * @param value -
       * @param start1 -
       * @param end1 -
       * @param start2 -
       * @param end2 -
       * @return -
       */
      static remap(value, start1, end1, start2, end2) {
          return start2 + (end2 - start2) * ((value - start1) / (end1 - start1));
      }
      /**
       * Perform Hermite interpolation between two values
       *
       * @static
       * @param edge0 -
       * @param edge1 -
       * @param x -
       * @return -
       */
      static smoothStep(edge0, edge1, x) {
          const t = this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
          return t * t * (3.0 - 2.0 * t);
      }
      /**
       * Performs - interpolation between two values
       *
       * @static
       * @param edge0 -
       * @param edge1 -
       * @param x -
       * @return -
       */
      static linStep(edge0, edge1, x) {
          return this.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      }
      /**
       * Decodes a Float16 from two unsigned Int8
       *
       * @static
       * @param c - Array with the two UInt8
       * @return - Decoded Float16
       */
      static decode16BitFloatFrom2xUInt8(c) {
          const ix = c[0]; // 1st byte: 1 bit signed num, 4 bits exponent, 3 bits mantissa (MSB)
          const iy = c[1]; // 2nd byte: 8 bit mantissa (LSB)
          const s = ix & 0x80 ? 1 : -1; // get bit 8
          const iexp = (ix & 0x78) >> 3; // mask bits 7-4
          const msb = ix & 0x7; // mask bits 3-1
          let norm = iexp == 0 ? 0 : 2048; // distinguish between normalized and sub-normalized numbers
          const mantissa = norm + (msb << 8) + iy; // implicit preceding 1 or 0 added here
          norm = iexp == 0 ? 1 : 0; // normalization toggle
          const exponent = Math.pow(2, iexp + norm - 16); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa
          const v = s * mantissa * exponent;
          return v;
      }
      /**
       * Encodes an array of two unsigned Int8 to a Float16
       *
       * @static
       * @param v - Float16 number
       * @return - Encoded Unsigned Int8 array
       */
      static encode16BitFloatInto2xUInt8(v) {
          const c = new Uint8Array(2);
          // const c = [0, 0];
          const signum = v >= 0 ? 128 : 0;
          v = Math.abs(v);
          let exponent = 15;
          let limit = 1024; // considering the bias from 2^-5 to 2^10 (==1024)
          for (let exp = 15; exp > 0; exp--) {
              if (v < limit) {
                  limit /= 2;
                  exponent--;
              }
          }
          let rest;
          if (exponent == 0) {
              rest = v / limit / 2; // "sub-normalize" implicit preceding 0.
          }
          else {
              rest = (v - limit) / limit; // normalize accordingly to implicit preceding 1.
          }
          const mantissa = Math.round(rest * 2048); // 2048 = 2^11 for the (split) 11 bit mantissa
          const msb = mantissa / 256; // the most significant 3 bits go into the lower part of the first byte
          const lsb = mantissa - msb * 256; // there go the other 8 bit of the lower significance
          c[0] = signum + exponent * 8 + msb; // color normalization for texture2D
          c[1] = lsb;
          if (v >= 2048) {
              c[0] = 255;
          }
          return c;
      }
      /**
       * Transforms a 16 bit float to an encoded integer.
       *
       * @static
       * @param v - Float16 number to encode
       * @return - Encoded number
       */
      static encode16BitFloat(v) {
          const float32Array = new Float32Array(1);
          float32Array[0] = v;
          const int32View = new Int32Array(float32Array.buffer);
          const toUInt16 = (x) => {
              let bits = (x >> 16) & 0x8000; /* Get the sign */
              let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
              const e = (x >> 23) & 0xff; /* Using int is faster here */
              /* If zero, or de-normal, or exponent underflows too much for a de-normal
               * half, return signed zero. */
              if (e < 103) {
                  return bits;
              }
              /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
              if (e > 142) {
                  bits |= 0x7c00;
                  /* If exponent was 0xff and one mantissa bit was set, it means NaN,
                   * not Inf, so make sure we set one mantissa bit too. */
                  bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
                  return bits;
              }
              /* If exponent underflows but not too much, return a de-normal */
              if (e < 113) {
                  m |= 0x0800;
                  /* Extra rounding may overflow and set mantissa to 0 and exponent
                   * to 1, which is OK. */
                  bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
                  return bits;
              }
              bits |= ((e - 112) << 10) | (m >> 1);
              /* Extra rounding. An overflow will set mantissa to 0 and increment
               * the exponent, which is OK. */
              bits += m & 1;
              return bits;
          };
          return toUInt16(int32View[0]);
      }
      /**
       * As opposite of the `encode16BitFloat` method, this takes an encoded integer value,
       * and returns the 16 bit float.
       *
       * @static
       * @param h - Encoded integer
       * @return - Decoded 16 bit float.
       */
      static decode16BitFloat(h) {
          const s = (h & 0x8000) >> 15;
          const e = (h & 0x7c00) >> 10;
          const f = h & 0x03ff;
          if (e == 0) {
              return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
          }
          else if (e == 0x1f) {
              return f ? NaN : (s ? -1 : 1) * Infinity;
          }
          return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
      }
      /**
       * Transforms an array of Float 32 to an array of unsigned Int16.
       *
       * @static
       * @param float32Array -
       * @return - Unsigned Int16 array representative of the Float32Array
       */
      static convertFloat32ArrayToUInt16Array(float32Array) {
          const unit16s = new Uint16Array(float32Array.length);
          const int32View = new Int32Array(float32Array.buffer);
          const toUInt16 = (x) => {
              let bits = (x >> 16) & 0x8000; /* Get the sign */
              let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
              const e = (x >> 23) & 0xff; /* Using int is faster here */
              /* If zero, or de-normal, or exponent underflows too much for a de-normal
               * half, return signed zero. */
              if (e < 103) {
                  return bits;
              }
              /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
              if (e > 142) {
                  bits |= 0x7c00;
                  /* If exponent was 0xff and one mantissa bit was set, it means NaN,
                   * not Inf, so make sure we set one mantissa bit too. */
                  bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
                  return bits;
              }
              /* If exponent underflows but not too much, return a de-normal */
              if (e < 113) {
                  m |= 0x0800;
                  /* Extra rounding may overflow and set mantissa to 0 and exponent
                   * to 1, which is OK. */
                  bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
                  return bits;
              }
              bits |= ((e - 112) << 10) | (m >> 1);
              /* Extra rounding. An overflow will set mantissa to 0 and increment
               * the exponent, which is OK. */
              bits += m & 1;
              return bits;
          };
          for (let i = 0; i < float32Array.length; i++) {
              unit16s[i] = toUInt16(int32View[i]);
          }
          return unit16s;
      }
  }

  // import { BaseEvent } from './BaseEvent'
  // TODO:
  // class AllocatorResized extends BaseEvent {
  //   id: number
  //   allocation: any
  //   constructor() {
  //     super()
  //   }
  // }
  /**
   * An Allocation1D represents an allocated block of memory.
   *
   */
  class Allocation1D {
      start;
      size;
      /**
       * Initializes the allocation
       * @param start - The start of the allocated block of memory.
       * @param size - The size of the allocated block of memory.
       */
      constructor(start = 0, size = 0) {
          this.start = start;
          this.size = size;
      }
  }
  /**
   * An 1D allocator is used to manage packing multiple smaller blocks of data
   * into a single large block of memory, supporting resizing and re-allocating.
   * As allocations are changed, fragmentation occurs as blocks must be moved
   *
   * Example:
   * ```javascript
   * const allocator = new Allocator1D()
   *
   * let memory = new Uint32Array(25)
   * allocator.on('resize', () => {
   *   memory = new Uint32Array(allocator.reservedSpace)
   * })
   * allocator.on('dataReallocated', (event) => {
   *   // during allocation, a defragment might occur, which means
   *   // we need to reload some of our data.
   * })
   *
   * allocator.allocate(1, 5)
   * allocator.allocate(2, 10)
   * allocator.allocate(3, 10)
   * allocator.allocate(4, 20)
   * allocator.allocate(3, 20) // resize 3 to grow the allocated space.
   * allocator.allocate(1, 7) // resize 1 to fit into the previous space of 3, leaving a new free block.
   * allocator.allocate(1, 10) // resize 1 to fit into the previous space of 3, consuming the free block.
   * ```
   *
   */
  class Allocator1D extends EventEmitter {
      freeList = [];
      allocations = [];
      allocationsMap = {}; // A mapping of id to index within the allocations list
      allocatedSpace = 0;
      reservedSpace = 0;
      freeSpace = 0;
      /**
       * Initializes the allocator ready to start work
       */
      constructor() {
          super();
      }
      /**
       * Returns the Allocates for the given Id.
       *
       * @param id - The unique numerical identifer for the block.
       * @return - The allocation
       */
      getAllocation(id) {
          return this.allocations[this.allocationsMap[id]];
      }
      /**
       * Allocates space for a new or existing item. The id is a handle that the consuming code uses to
       * track allocations.
       *
       * @param id - The unique numerical identifer for the block.
       * @param size - The name of the event.
       * @return - The new allocation
       */
      allocate(id, size) {
          if (this.allocationsMap[id] != undefined) {
              const index = this.allocationsMap[id];
              const allocation = this.allocations[index];
              // Resizing smaller
              if (size == allocation.size) {
                  return allocation;
              }
              else if (size < allocation.size) {
                  // Split this block into 2. We use the first one for our item, and the second is put on the free list.
                  const splitBlockSize = allocation.size - size;
                  // this.allocations.splice(index + 1, 0, new Allocation1D(allocation.start + size, splitBlockSize))
                  this.addBlock(index + 1, new Allocation1D(allocation.start + size, splitBlockSize));
                  this.freeBlock(index + 1);
                  allocation.size = size;
                  return allocation;
              }
              else {
                  // Try to consume any free blocks directly to our right.
                  const nextIndex = index + 1;
                  if (this.freeList.includes(nextIndex) && allocation.size + this.allocations[nextIndex].size >= size) {
                      const freeBlock = this.allocations[nextIndex];
                      if (allocation.size + freeBlock.size == size) {
                          // consume this free block
                          allocation.size += freeBlock.size;
                          this.freeSpace -= freeBlock.size;
                          this.freeList.splice(this.freeList.indexOf(nextIndex), 1);
                          // this.allocations.splice(nextIndex, 1)
                          this.removeBlock(nextIndex);
                          return allocation;
                      }
                      else {
                          // We want to shrink the next block by the amount we consumed
                          const consumed = size - allocation.size;
                          allocation.size += consumed;
                          this.freeSpace -= consumed;
                          freeBlock.start += consumed;
                          freeBlock.size -= consumed;
                          return allocation;
                      }
                  }
                  else {
                      // free up this slot an find a new one
                      // If the slot was at the end of the allocated memory, just decrement
                      // the allocated space making it immediately available for use.
                      delete this.allocationsMap[id];
                      if (allocation.start + allocation.size == this.allocatedSpace) {
                          this.removeBlock(index);
                          this.allocatedSpace -= allocation.size;
                      }
                      else {
                          this.freeBlock(index);
                      }
                  }
              }
          }
          let freeItemIndex = -1;
          for (let i = 0; i < this.freeList.length; i++) {
              const freeIndex = this.freeList[i];
              const allocation = this.allocations[freeIndex];
              if (allocation.size == size) {
                  freeItemIndex = freeIndex;
                  break;
              }
              else if (allocation.size > size) {
                  freeItemIndex = freeIndex;
              }
          }
          if (freeItemIndex != -1) {
              const freeItem = this.allocations[freeItemIndex];
              this.freeSpace -= freeItem.size;
              this.freeList.splice(this.freeList.indexOf(freeItemIndex), 1);
              if (freeItem.size > size) {
                  // Split this block into 2. We use the first one for our item, and the second is put on the free list.
                  const splitBlockSize = freeItem.size - size;
                  // this.allocations.splice(freeItemIndex + 1, 0, new Allocation1D(freeItem.start + size, splitBlockSize))
                  this.addBlock(freeItemIndex + 1, new Allocation1D(freeItem.start + size, splitBlockSize));
                  this.freeBlock(freeItemIndex + 1);
                  this.allocations[freeItemIndex].size = size;
              }
              this.allocationsMap[id] = freeItemIndex;
          }
          else {
              const start = this.allocatedSpace;
              const index = this.allocations.length;
              this.allocatedSpace += size;
              const reserved = MathFunctions.nextPow2(this.allocatedSpace);
              // Only re-allocate if we  need more space than is reserved.
              // this means we won't resize smaller, even if we free up all allocated space
              // In general, we don't want that anyway, as we would prefer to grow memory, and then
              // keep it.
              if (reserved > this.reservedSpace) {
                  this.reservedSpace = reserved;
                  this.emit('resized', { reservedSpace: this.reservedSpace });
              }
              this.allocations.push(new Allocation1D(start, size));
              this.allocationsMap[id] = index;
          }
          return this.allocations[this.allocationsMap[id]];
      }
      /**
       * Adds a new block
       * @private
       *
       * @param index - The index where the block should be inserted.
       * @param allocation - The allocation to insert
       */
      addBlock(index, allocation) {
          this.allocations.splice(index, 0, allocation);
          for (const id in this.allocationsMap) {
              if (this.allocationsMap[id] >= index) {
                  this.allocationsMap[id]++;
              }
          }
          for (let i = 0; i < this.freeList.length; i++) {
              if (this.freeList[i] >= index) {
                  this.freeList[i]++;
              }
          }
      }
      /**
       * Remove a new block
       * @private
       *
       * @param index - The index where the block should be removed
       */
      removeBlock(index) {
          this.allocations.splice(index, 1);
          for (const id in this.allocationsMap) {
              if (this.allocationsMap[id] > index) {
                  this.allocationsMap[id]--;
              }
          }
          for (let i = 0; i < this.freeList.length; i++) {
              if (this.freeList[i] > index) {
                  this.freeList[i]--;
              }
          }
      }
      /**
       * Frees a block by either growing neighboring blocks or adding a new free block
       * @private
       *
       * @param index - The index of the block to free.
       */
      freeBlock(index) {
          const allocation = this.allocations[index];
          this.freeSpace += allocation.size;
          // check for free blocks on either side of the allocated space
          // and allow them to consume this block instead of adding a new smaller
          // block.
          const prevIndex = index - 1;
          if (this.freeList.includes(prevIndex)) {
              const prevAllocation = this.allocations[prevIndex];
              prevAllocation.size += allocation.size;
              this.removeBlock(index);
              return;
          }
          const nextIndex = index + 1;
          if (this.freeList.includes(nextIndex)) {
              const nextAllocation = this.allocations[nextIndex];
              nextAllocation.start -= allocation.size;
              nextAllocation.size += allocation.size;
              this.removeBlock(index);
              return;
          }
          this.freeList.push(index);
          // Sort the free blocks by size so we use the smallest ones first.
          // This reduces the chance of fragmentation by always consuming the smallerest free blocks first.
          this.freeList.sort((a, b) => this.allocations[a].size - this.allocations[b].size);
      }
      /**
       * Deallocate space for an existing item, making it free for other uses.
       *
       * @param id - The unique numerical identifer for the block.
       */
      deallocate(id) {
          const index = this.allocationsMap[id];
          if (index == undefined) {
              throw new Error(`allocation ${id} does not exist.`);
          }
          this.freeBlock(index);
          delete this.allocationsMap[id];
      }
      /**
       * Returns the ratio of fragmented memory over reserved memory.
       *
       * @return The fragmentation ratio. Between 0 and some value less than 1
       */
      getFragmentation() {
          return this.freeSpace / this.allocatedSpace;
      }
      /**
       * Defragment the memory space reducing memory requirements.
       * TODO: Implement this method.
       */
      defragment() {
          // move the freeblocks to the end of the memory so that
          // we can then reduce the memory used.
      }
      /**
       * Checks that the allocations are consistent and not corrupt in any way.
       */
      verifyConsistency() {
          if (Object.keys(this.allocationsMap).length + this.freeList.length != this.allocations.length) {
              throw new Error('number of blocks does not match the number of allocations');
          }
          // eslint-disable-next-line guard-for-in
          for (const id in this.allocationsMap) {
              const index = this.allocationsMap[id];
              if (this.freeList.includes(index)) {
                  // eslint-disable-next-line no-throw-literal
                  throw new Error('block of used memory is also on the free list');
              }
          }
          let size = 0;
          for (let i = 0; i < this.allocations.length; i++) {
              const allocation = this.allocations[i];
              if (allocation.start != size) {
                  // eslint-disable-next-line no-throw-literal
                  throw 'blocks of memory are not sequential';
              }
              size += allocation.size;
          }
          if (size != this.allocatedSpace) {
              // eslint-disable-next-line no-throw-literal
              throw `allocated size: ${this.allocatedSpace}  does not match allocated blocks: ${size}`;
          }
          if (this.reservedSpace < this.allocatedSpace) {
              // eslint-disable-next-line no-throw-literal
              throw `reserved space: ${this.reservedSpace} is less than allocated space: ${this.allocatedSpace}`;
          }
      }
  }

  class IntersectionData {
      screenPos;
      pointerRay;
      intersectionPos;
      geomData;
      geomItem;
      componentId;
      dist;
      constructor(screenPos, pointerRay, intersectionPos, geomData, geomItemAndDist) {
          this.screenPos = screenPos;
          this.pointerRay = pointerRay;
          this.intersectionPos = intersectionPos;
          this.geomData = geomData;
          this.geomItem = geomItemAndDist.geomItem;
          this.componentId = geomItemAndDist.componentId;
          this.dist = geomItemAndDist.dist;
      }
  }

  class ChildAddedEvent extends BaseEvent {
      index;
      childItem;
      constructor(index, childItem) {
          super();
          this.index = index;
          this.childItem = childItem;
      }
  }

  class ControllerAddedEvent extends BaseEvent {
      controller;
      constructor(controller) {
          super();
          this.controller = controller;
      }
  }

  class CountChangedEvent extends BaseEvent {
      change;
      count;
      constructor(change, count) {
          super();
          this.change = change;
          this.count = count;
      }
  }

  class EnvMapAssignedEvent extends BaseEvent {
      envMap;
      constructor(envMap) {
          super();
          this.envMap = envMap;
      }
  }

  class IndexEvent extends BaseEvent {
      index;
      constructor(index) {
          super();
          this.index = index;
      }
  }

  /**
   * ZeaUIEvent are emitted from a 2D UI, such as from a HTMLCanvas element generated from
   * a mouse or touch interaction, or key presses
   */
  class ZeaUIEvent extends BaseEvent {
      viewport;
      propagating = true;
      constructor() {
          super();
      }
  }

  class ZeaKeyboardEvent extends ZeaUIEvent {
      sourceEvent;
      propagating = true;
      // Returns a boolean value that is true if the Alt (Option or  on OS X) key was active when the key event was generated.
      altKey;
      // Returns a DOMString with the code value of the physical key represented by the event.
      code;
      // Returns a boolean value that is true if the Ctrl key was active when the key event was generated.
      ctrlKey;
      // Returns a boolean value that is true if the event is fired between after compositionstart and before compositionend.
      isComposing;
      // Returns a DOMString representing the key value of the key represented by the event.
      key;
      // Returns a Number representing the location of the key on the keyboard or other input device. A list of the constants identifying the locations is shown above in Keyboard locations.
      location;
      // Returns a boolean value that is true if the Meta key (on Mac keyboards, the  Command key; on Windows keyboards, the Windows key ()) was active when the key event was generated.
      metaKey;
      // Returns a boolean value that is true if the key is being held down such that it is automatically repeating.
      repeat;
      // Returns a boolean value that is true if the Shift key was active when the key event was generated.
      shiftKey;
      // Returns a Number representing a system and implementation dependent numeric code identifying the unmodified value of the pressed key; this is usually the same as keyCode.
      which;
      constructor(sourceEvent) {
          super();
          if (sourceEvent) {
              this.sourceEvent = sourceEvent;
              this.altKey = sourceEvent.altKey;
              this.code = sourceEvent.code;
              this.ctrlKey = sourceEvent.ctrlKey;
              this.isComposing = sourceEvent.isComposing;
              this.key = sourceEvent.key;
              this.location = sourceEvent.location;
              this.metaKey = sourceEvent.metaKey;
              this.repeat = sourceEvent.repeat;
              this.shiftKey = sourceEvent.shiftKey;
          }
      }
      stopPropagation() {
          this.propagating = false;
          if (this.sourceEvent)
              this.sourceEvent.stopPropagation();
      }
      preventDefault() {
          if (this.sourceEvent)
              this.sourceEvent.preventDefault();
      }
  }
  // deprecated class. Please stop using it.
  class KeyboardEvent extends ZeaKeyboardEvent {
  }

  class NameChangedEvent extends BaseEvent {
      oldName;
      newName;
      constructor(oldName, newName) {
          super();
          this.oldName = oldName;
          this.newName = newName;
      }
  }

  class OpacityStateChangedEvent extends BaseEvent {
      isOpaque;
      isOpaqueStateChanged;
      constructor(isOpaque, isOpaqueStateChanged) {
          super();
          this.isOpaque = isOpaque;
          this.isOpaqueStateChanged = isOpaqueStateChanged;
      }
  }

  class ParameterAddedEvent extends BaseEvent {
      name;
      constructor(name) {
          super();
          this.name = name;
      }
  }

  class ParameterRemovedEvent extends BaseEvent {
      name;
      constructor(name) {
          super();
          this.name = name;
      }
  }

  class RangeLoadedEvent extends BaseEvent {
      range;
      constructor(range) {
          super();
          this.range = range;
      }
  }

  class SceneSetEvent extends BaseEvent {
      scene;
      constructor(scene) {
          super();
          this.scene = scene;
      }
  }

  class SelectabilityChangedEvent extends BaseEvent {
      value;
      constructor(value) {
          super();
          this.value = value;
      }
  }

  class SelectedEvent extends BaseEvent {
      selected;
      constructor(selected) {
          super();
          this.selected = selected;
      }
  }

  class ShaderNameChangedEvent extends BaseEvent {
      shaderName;
      constructor(shaderName) {
          super();
          this.shaderName = shaderName;
      }
  }

  class StateChangedEvent extends BaseEvent {
      state;
      constructor(state) {
          super();
          this.state = state;
      }
  }

  class StreamFileParsedEvent extends BaseEvent {
      geomFileID;
      geomCount;
      constructor(geomFileID, geomCount) {
          super();
          this.geomFileID = geomFileID;
          this.geomCount = geomCount;
      }
  }

  //{ isTextured, param }
  class TexturedChangedEvent extends BaseEvent {
      isTextured;
      param;
      constructor(isTextured, param) {
          super();
          this.isTextured = isTextured;
          this.param = param;
      }
  }

  class ViewChangedEvent extends BaseEvent {
      interfaceType;
      viewXfo;
      viewport;
      constructor(interfaceType, viewXfo) {
          super();
          this.interfaceType = interfaceType;
          this.viewXfo = viewXfo;
      }
  }

  class VisibilityChangedEvent extends BaseEvent {
      visible;
      constructor(visible) {
          super();
          this.visible = visible;
      }
  }

  class ProgressEvent extends BaseEvent {
      percent;
      constructor(percent) {
          super();
          this.percent = percent;
      }
  }

  const POINTER_TYPES = {
      mouse: 'mouse',
      touch: 'touch',
      xr: 'xr',
  };
  let capturedItem$1 = null;
  /**
   * ZeaPointerEvent are emitted from mouse or touch interactions or from WebXR controllers.
   */
  class ZeaPointerEvent extends ZeaUIEvent {
      pointerType;
      pointerRay;
      pointerPos;
      detail;
      intersectionData;
      leftGeometry;
      constructor(pointerType) {
          super();
          this.pointerType = pointerType;
      }
      stopPropagation() {
          this.propagating = false;
      }
      setCapture(item) {
          capturedItem$1 = item;
      }
      getCapture() {
          return capturedItem$1;
      }
      releaseCapture() {
          capturedItem$1 = null;
      }
  }

  const captureItems = [];
  class XRControllerEvent extends ZeaPointerEvent {
      controller;
      button;
      buttonPressed = 0;
      constructor(viewport, controller, button, buttonPressed) {
          super(POINTER_TYPES.xr);
          this.viewport = viewport;
          this.controller = controller;
          this.button = button;
          this.buttonPressed = buttonPressed;
      }
      stopPropagation() {
          this.propagating = false;
      }
      setCapture(item) {
          captureItems[this.controller.id] = item;
      }
      getCapture() {
          return captureItems[this.controller.id];
      }
      releaseCapture() {
          captureItems[this.controller.id] = null;
      }
  }

  let capturedItem = null;
  class XRPointerEvent extends ZeaPointerEvent {
      xfo;
      xrSelectEvent;
      hitTestResults;
      constructor(viewport, xfo, xrSelectEvent, hitTestResults) {
          super(POINTER_TYPES.xr);
          this.viewport = viewport;
          this.xfo = xfo;
          this.xrSelectEvent = xrSelectEvent;
          this.hitTestResults = hitTestResults;
      }
      stopPropagation() {
          this.propagating = false;
      }
      setCapture(item) {
          capturedItem = item;
      }
      getCapture() {
          return capturedItem;
      }
      releaseCapture() {
          capturedItem = null;
      }
  }

  // TODO: Once we start the migration to AssemblyScript
  // we will need to extract the cotroller data and package
  // into this struct. Untill then, we will just put the whole
  // controller.
  // class XRControllerPose {
  //   controller: XRController
  //   constructor(controller: XRController) {
  //     this.controller = controller
  //   }
  // }
  class XRPoseEvent extends ZeaPointerEvent {
      viewXfo;
      controllers = [];
      constructor(viewport, viewXfo, controllers = []) {
          super(POINTER_TYPES.xr);
          this.viewport = viewport;
          this.viewXfo = viewXfo;
          controllers.forEach((controller) => {
              this.controllers.push(controller);
          });
      }
  }

  class XRViewChangedEvent extends ViewChangedEvent {
      hmd = '';
      controllers = [];
      xrviewport;
      constructor(viewXfo) {
          super('VR', viewXfo);
      }
  }

  class XrViewportEvent extends BaseEvent {
      xrViewport;
      constructor(xrViewport) {
          super();
          this.xrViewport = xrViewport;
      }
  }

  class ZeaMouseEvent extends ZeaPointerEvent {
      button;
      clientX;
      clientY;
      rendererX;
      rendererY;
      altKey;
      metaKey;
      ctrlKey;
      shiftKey;
      sourceEvent;
      constructor(sourceEvent, rect) {
          super(POINTER_TYPES.mouse);
          this.sourceEvent = sourceEvent;
          this.button = sourceEvent.button;
          this.clientX = sourceEvent.clientX;
          this.clientY = sourceEvent.clientY;
          // Note: the rendererX/Y values are relative to the viewport,
          // but are available outside the viewport. So when a mouse
          // drag occurs, and drags outside the viewport, these values
          // provide consistent coords.
          // offsetX/Y are only valid inside the viewport and so cause
          // jumps when the mouse leaves the viewport.
          this.rendererX = this.clientX - rect.left;
          this.rendererY = this.clientY - rect.top;
          this.altKey = sourceEvent.altKey;
          this.metaKey = sourceEvent.metaKey;
          this.ctrlKey = sourceEvent.ctrlKey;
          this.shiftKey = sourceEvent.shiftKey;
      }
      stopPropagation() {
          super.stopPropagation();
          if (this.sourceEvent)
              this.sourceEvent.stopPropagation();
      }
      preventDefault() {
          if (this.sourceEvent)
              this.sourceEvent.preventDefault();
      }
  }

  /* eslint-disable new-cap */
  /**
   * Class representing a ray that starts from an origin in a specified direction.
   */
  class Ray {
      dir;
      start;
      /**
       * Create a ray.
       *
       * @param start - The origin of the ray.
       * @param dir - The direction of the ray.
       */
      constructor(start, dir) {
          if (start instanceof Vec3) {
              this.start = start;
          }
          else {
              this.start = new Vec3();
          }
          if (dir instanceof Vec3) {
              this.dir = dir;
          }
          else {
              this.dir = new Vec3();
          }
      }
      /**
       * Get the closest point on the ray to the given point.
       *
       * @param point - The point in 3D space.
       * @return - returns a number
       */
      closestPoint(point) {
          const w = point.subtract(this.start);
          const c1 = w.dot(this.dir);
          if (c1 < Number.EPSILON)
              return 0;
          const c2 = this.dir.dot(this.dir);
          if (c2 < Number.EPSILON)
              return 0;
          return c1 / c2;
      }
      /**
       * Get the closest point between the ray and the given line segment made of the 2 points.
       *
       * @param p0 - The point in 3D space.
       * @param p1 - The point in 3D space.
       * @return - Returns an array containing 2 scalar values indicating 0: the fraction of the line segment, 1: distance along the Ray
       */
      closestPointOnLineSegment(p0, p1) {
          const u = this.dir;
          const v = p1.subtract(p0);
          const v_len = v.length();
          v.normalizeInPlace();
          const w = this.start.subtract(p0);
          const a = u.dot(u); // always >= 0
          const b = u.dot(v);
          const c = v.dot(v); // always >= 0
          const d = u.dot(w);
          const e = v.dot(w);
          if (a == 0.0 && c == 0.0) {
              return [this.start.distanceTo(p0), 0.0];
          }
          if (a == 0.0) {
              return [0.0, 0.0];
          }
          if (c == 0.0) {
              return [this.closestPoint(p0), 0.0];
          }
          const D = a * c - b * b; // always >= 0
          // compute the ray parameters of the two closest points
          let this_t;
          let seg_t;
          if (D < 0.001) {
              // the lines are almost parallel
              this_t = 0.0;
              if (b > c) {
                  // use the largest denominator
                  seg_t = d / b;
              }
              else {
                  seg_t = e / c;
              }
          }
          else {
              this_t = (b * e - c * d) / D;
              seg_t = (a * e - b * d) / D;
          }
          return [this_t, MathFunctions.clamp(seg_t / v_len, 0, 1)];
      }
      /**
       * Get the closest point at a distance.
       *
       * @param dist - The distance value.
       * @return - Returns a Vec3.
       */
      pointAtDist(dist) {
          return this.start.add(this.dir.scale(dist));
      }
      /**
       * Returns the two ray params that represent the closest point between the two rays.
       *
       * @param ray - The ray value.
       * @return - Returns a Ray.
       */
      intersectRayVector(ray) {
          const u = this.dir;
          const v = ray.dir;
          const w = this.start.subtract(ray.start);
          const a = u.dot(u); // always >= 0
          const b = u.dot(v);
          const c = v.dot(v); // always >= 0
          const d = u.dot(w);
          const e = v.dot(w);
          if (a == 0.0 && c == 0.0) {
              return this.start.distanceTo(ray.start);
          }
          if (a == 0.0) {
              return ray.closestPoint(this.start);
          }
          if (c == 0.0) {
              return this.closestPoint(ray.start);
          }
          const D = a * c - b * b; // always >= 0
          // compute the ray parameters of the two closest points
          let this_t;
          let ray_t;
          if (D < 0.001) {
              // the lines are almost parallel
              this_t = 0.0;
              if (b > c) {
                  // use the largest denominator
                  ray_t = d / b;
              }
              else {
                  ray_t = e / c;
              }
          }
          else {
              this_t = (b * e - c * d) / D;
              ray_t = (a * e - b * d) / D;
          }
          return [this_t, ray_t];
      }
      /**
       * Returns one ray param representing the intersection
       * of this ray against the plane defined by the given ray.
       *
       * @param plane - The plane to intersect with.
       * @return - The return value.
       */
      intersectRayPlane(plane) {
          const w = this.start.subtract(plane.start);
          const D = plane.dir.dot(this.dir);
          const N = -plane.dir.dot(w);
          if (Math.abs(D) < Number.PRECISION) {
              // segment is parallel to plane
              if (N == 0.0)
                  return -1.0;
              // segment lies in plane
              else
                  return -1.0; // no intersection
          }
          // they are not parallel
          // compute intersect param
          const sI = N / D;
          if (sI < -Number.PRECISION) {
              return -1; // no intersection
          }
          return sI;
      }
      /**
       * Determines if this Box3 intersects a ray.
       *
       * @param box3 - The box to check for intersection against.
       * @param tolerance - The tolerance of the test.
       * @return - The return value.
       */
      intersectRayBox3(box3, tolerance = 0) {
          // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection
          const invDir = new Vec3(1 / this.dir.x, 1 / this.dir.y, 1 / this.dir.z);
          const sign = [];
          sign[0] = invDir.x < 0 ? 1 : 0;
          sign[1] = invDir.y < 0 ? 1 : 0;
          sign[2] = invDir.z < 0 ? 1 : 0;
          const bounds = [];
          if (tolerance > 0) {
              const diag = box3.diagonal();
              diag.normalizeInPlace();
              diag.scaleInPlace(tolerance);
              bounds[0] = box3.p0.subtract(diag);
              bounds[1] = box3.p1.add(diag);
          }
          else {
              bounds[0] = box3.p0;
              bounds[1] = box3.p1;
          }
          let tMin = (bounds[sign[0]].x - this.start.x) * invDir.x;
          let tMax = (bounds[1 - sign[0]].x - this.start.x) * invDir.x;
          const tyMin = (bounds[sign[1]].y - this.start.y) * invDir.y;
          const tyMax = (bounds[1 - sign[1]].y - this.start.y) * invDir.y;
          if (tMin > tyMax || tyMin > tMax)
              return false;
          if (tyMin > tMin)
              tMin = tyMin;
          if (tyMax < tMax)
              tMax = tyMax;
          const tzMin = (bounds[sign[2]].z - this.start.z) * invDir.z;
          const tzMax = (bounds[1 - sign[2]].z - this.start.z) * invDir.z;
          if (tMin > tzMax || tzMin > tMax)
              return false;
          if (tzMin > tMin)
              tMin = tzMin;
          if (tzMax < tMax)
              tMax = tzMax;
          return true;
      }
      /**
       * Clones this Ray and returns a new Ray.
       *
       * @return - Returns a new Ray.
       */
      clone() {
          return new Ray(this.start.clone(), this.dir.clone());
      }
      // ///////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              start: this.start.toJSON(),
              dir: this.dir.toJSON(),
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.start.fromJSON(j.start);
          this.dir.fromJSON(j.dir);
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  class Touch {
      identifier;
      clientX = 0;
      clientY = 0;
      screenX = 0;
      screenY = 0;
      pageX = 0;
      pageY = 0;
      radiusX = 0;
      radiusY = 0;
      rotationAngle = 0;
      force = 0;
      altitudeAngle = 0;
      azimuthAngle = 0;
      touchType = 'direct';
      rendererX;
      rendererY;
      touchPos;
      touchRay;
      constructor(touch, rect) {
          this.identifier = touch.identifier;
          this.clientX = touch.clientX;
          this.clientY = touch.clientY;
          this.screenX = touch.screenX;
          this.screenY = touch.screenY;
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;
          this.radiusX = touch.radiusX;
          this.radiusY = touch.radiusY;
          this.rotationAngle = touch.rotationAngle;
          this.force = touch.force;
          // this.altitudeAngle = touch.altitudeAngle
          // this.azimuthAngle = touch.azimuthAngle
          // this.touchType = touch.touchType
          // Note: the rendererX/Y values are relative to the viewport,
          // but are available outside the viewport. So when a mouse
          // drag occurs, and drags outside the viewport, these values
          // provide consistent coords.
          // offsetX/Y are only valid inside the viewport and so cause
          // jumps when the mouse leaves the viewport.
          this.rendererX = this.clientX - rect.left;
          this.rendererY = this.clientY - rect.top;
          this.touchPos = new Vec2(this.rendererX, this.rendererY);
          this.touchRay = new Ray();
      }
  }
  class ZeaTouchEvent extends ZeaPointerEvent {
      touches = [];
      changedTouches = [];
      targetTouches = [];
      altKey = false;
      metaKey = false;
      ctrlKey = false;
      shiftKey = false;
      sourceEvent;
      constructor(sourceEvent, rect) {
          super(POINTER_TYPES.touch);
          this.sourceEvent = sourceEvent;
          this.sourceEvent.stopPropagation();
          this.altKey = sourceEvent.altKey;
          this.metaKey = sourceEvent.metaKey;
          this.ctrlKey = sourceEvent.ctrlKey;
          this.shiftKey = sourceEvent.shiftKey;
          for (let i = 0; i < sourceEvent.touches.length; i++) {
              this.touches.push(new Touch(sourceEvent.touches[i], rect));
          }
          if (sourceEvent.changedTouches) {
              for (let i = 0; i < sourceEvent.changedTouches.length; i++) {
                  this.changedTouches.push(new Touch(sourceEvent.changedTouches[i], rect));
              }
          }
          if (sourceEvent.targetTouches) {
              for (let i = 0; i < sourceEvent.targetTouches.length; i++) {
                  this.targetTouches.push(new Touch(sourceEvent.targetTouches[i], rect));
              }
          }
      }
      stopPropagation() {
          super.stopPropagation();
          if (this.sourceEvent)
              this.sourceEvent.stopPropagation();
      }
      // Touch events are passive and so cannot call prevent default
      // replace with a stub here...
      preventDefault() { }
  }

  class ZeaWheelEvent extends ZeaMouseEvent {
      wheelDelta;
      deltaMode;
      deltaX;
      deltaY;
      deltaZ;
      constructor(sourceEvent, rect) {
          super(sourceEvent, rect);
          // @ts-ignore
          this.wheelDelta = sourceEvent.wheelDelta;
          this.deltaMode = sourceEvent.deltaMode;
          this.deltaX = sourceEvent.deltaX;
          this.deltaY = sourceEvent.deltaY;
          this.deltaZ = sourceEvent.deltaZ;
      }
  }

  /**
   * Class representing a color as 4 floating point values.
   */
  class Color {
      r = 0;
      g = 0;
      b = 0;
      a = 255;
      /**
       * Creates a `Color` object with an RGBA structure.
       *
       * @param r - The red channel of a color.
       * @param g - The green channel of a color.
       * @param b - The blue channel of a color.
       * @param a - The alpha (transparency) channel of a color.
       */
      constructor(r = 0, g = 0, b = 0, a = 1.0) {
          if (typeof r == 'string') {
              if (r.startsWith('#')) {
                  this.setFromHex(r);
              }
              else {
                  this.setFromCSSColorName(r);
              }
          }
          else {
              this.r = r;
              this.g = g;
              this.b = b;
              this.a = a;
          }
      }
      /**
       * Setter from scalar components.
       *
       * @param r - The red channel.
       * @param g  - The green channel.
       * @param b  - The blue channel.
       * @param a  - The alpha channel.
       */
      set(r, g, b, a = 1.0) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
      }
      /**
       * Sets current color state with another `Color` object.
       *
       * @param other - The other color to set from.
       */
      setFromOther(other) {
          this.r = other.r;
          this.g = other.g;
          this.b = other.b;
          this.a = other.a;
      }
      /**
       * Getter from an RGB array.
       *
       * @return - The return value.
       */
      getAsRGBArray() {
          return [this.r * 255, this.g * 255, this.b * 255];
      }
      /**
       * Getter from an RGB dict.
       *
       * @return - The return value.
       */
      getAsRGBDict() {
          return {
              r: this.r * 255,
              g: this.g * 255,
              b: this.b * 255,
          };
      }
      /**
       * Setter from a RGB value.
       *
       * @param r - The red channel.
       * @param g  - The green channel.
       * @param b  - The blue channel.
       * @param a  - The alpha channel.
       */
      setFromRGB(r, g, b, a) {
          this.r = r / 255;
          this.g = g / 255;
          this.b = b / 255;
          this.a = a ? a / 255 : 1.0;
      }
      /**
       * Setter from an RGB dict.
       *
       * @param vals - The vals param.
       */
      setFromRGBDict(vals) {
          this.r = vals.r / 255;
          this.g = vals.g / 255;
          this.b = vals.b / 255;
          this.a = vals.a == 4 ? vals.a / 255 : 1.0;
      }
      /**
       * Setter from a hexadecimal value.
       * E.g. #ff0000
       * @param hex - The hex value.
       */
      setFromHex(hex) {
          function hexToRgb(hex) {
              const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return result
                  ? {
                      r: parseInt(result[1], 16),
                      g: parseInt(result[2], 16),
                      b: parseInt(result[3], 16),
                  }
                  : null;
          }
          const rgb = hexToRgb(hex);
          if (!rgb) {
              console.warn('Invalid hex code:' + hex);
              return;
          }
          this.setFromRGB(rgb.r, rgb.g, rgb.b);
      }
      /**
       * Sets the Color values from a CSS color name.
       * E.g. "red"
       * @param name - The CSS color name.
       */
      setFromCSSColorName(name) {
          const colourNameToHex = (colour) => {
              const colors = {
                  aliceblue: '#f0f8ff',
                  antiquewhite: '#faebd7',
                  aqua: '#00ffff',
                  aquamarine: '#7fffd4',
                  azure: '#f0ffff',
                  beige: '#f5f5dc',
                  bisque: '#ffe4c4',
                  black: '#000000',
                  blanchedalmond: '#ffebcd',
                  blue: '#0000ff',
                  blueviolet: '#8a2be2',
                  brown: '#a52a2a',
                  burlywood: '#deb887',
                  cadetblue: '#5f9ea0',
                  chartreuse: '#7fff00',
                  chocolate: '#d2691e',
                  coral: '#ff7f50',
                  cornflowerblue: '#6495ed',
                  cornsilk: '#fff8dc',
                  crimson: '#dc143c',
                  cyan: '#00ffff',
                  darkblue: '#00008b',
                  darkcyan: '#008b8b',
                  darkgoldenrod: '#b8860b',
                  darkgray: '#a9a9a9',
                  darkgreen: '#006400',
                  darkkhaki: '#bdb76b',
                  darkmagenta: '#8b008b',
                  darkolivegreen: '#556b2f',
                  darkorange: '#ff8c00',
                  darkorchid: '#9932cc',
                  darkred: '#8b0000',
                  darksalmon: '#e9967a',
                  darkseagreen: '#8fbc8f',
                  darkslateblue: '#483d8b',
                  darkslategray: '#2f4f4f',
                  darkturquoise: '#00ced1',
                  darkviolet: '#9400d3',
                  deeppink: '#ff1493',
                  deepskyblue: '#00bfff',
                  dimgray: '#696969',
                  dodgerblue: '#1e90ff',
                  firebrick: '#b22222',
                  floralwhite: '#fffaf0',
                  forestgreen: '#228b22',
                  fuchsia: '#ff00ff',
                  gainsboro: '#dcdcdc',
                  ghostwhite: '#f8f8ff',
                  gold: '#ffd700',
                  goldenrod: '#daa520',
                  gray: '#808080',
                  green: '#008000',
                  greenyellow: '#adff2f',
                  honeydew: '#f0fff0',
                  hotpink: '#ff69b4',
                  'indianred ': '#cd5c5c',
                  indigo: '#4b0082',
                  ivory: '#fffff0',
                  khaki: '#f0e68c',
                  lavender: '#e6e6fa',
                  lavenderblush: '#fff0f5',
                  lawngreen: '#7cfc00',
                  lemonchiffon: '#fffacd',
                  lightblue: '#add8e6',
                  lightcoral: '#f08080',
                  lightcyan: '#e0ffff',
                  lightgoldenrodyellow: '#fafad2',
                  lightgrey: '#d3d3d3',
                  lightgreen: '#90ee90',
                  lightpink: '#ffb6c1',
                  lightsalmon: '#ffa07a',
                  lightseagreen: '#20b2aa',
                  lightskyblue: '#87cefa',
                  lightslategray: '#778899',
                  lightsteelblue: '#b0c4de',
                  lightyellow: '#ffffe0',
                  lime: '#00ff00',
                  limegreen: '#32cd32',
                  linen: '#faf0e6',
                  magenta: '#ff00ff',
                  maroon: '#800000',
                  mediumaquamarine: '#66cdaa',
                  mediumblue: '#0000cd',
                  mediumorchid: '#ba55d3',
                  mediumpurple: '#9370d8',
                  mediumseagreen: '#3cb371',
                  mediumslateblue: '#7b68ee',
                  mediumspringgreen: '#00fa9a',
                  mediumturquoise: '#48d1cc',
                  mediumvioletred: '#c71585',
                  midnightblue: '#191970',
                  mintcream: '#f5fffa',
                  mistyrose: '#ffe4e1',
                  moccasin: '#ffe4b5',
                  navajowhite: '#ffdead',
                  navy: '#000080',
                  oldlace: '#fdf5e6',
                  olive: '#808000',
                  olivedrab: '#6b8e23',
                  orange: '#ffa500',
                  orangered: '#ff4500',
                  orchid: '#da70d6',
                  palegoldenrod: '#eee8aa',
                  palegreen: '#98fb98',
                  paleturquoise: '#afeeee',
                  palevioletred: '#d87093',
                  papayawhip: '#ffefd5',
                  peachpuff: '#ffdab9',
                  peru: '#cd853f',
                  pink: '#ffc0cb',
                  plum: '#dda0dd',
                  powderblue: '#b0e0e6',
                  purple: '#800080',
                  rebeccapurple: '#663399',
                  red: '#ff0000',
                  rosybrown: '#bc8f8f',
                  royalblue: '#4169e1',
                  saddlebrown: '#8b4513',
                  salmon: '#fa8072',
                  sandybrown: '#f4a460',
                  seagreen: '#2e8b57',
                  seashell: '#fff5ee',
                  sienna: '#a0522d',
                  silver: '#c0c0c0',
                  skyblue: '#87ceeb',
                  slateblue: '#6a5acd',
                  slategray: '#708090',
                  snow: '#fffafa',
                  springgreen: '#00ff7f',
                  steelblue: '#4682b4',
                  tan: '#d2b48c',
                  teal: '#008080',
                  thistle: '#d8bfd8',
                  tomato: '#ff6347',
                  turquoise: '#40e0d0',
                  violet: '#ee82ee',
                  wheat: '#f5deb3',
                  white: '#ffffff',
                  whitesmoke: '#f5f5f5',
                  yellow: '#ffff00',
                  yellowgreen: '#9acd32',
              };
              return colors[colour.toLowerCase()];
              //  if (typeof colors[colour.toLowerCase()] != 'undefined') return colors[colour.toLowerCase()]
              // return false
          };
          if (name.startsWith('#')) {
              this.setFromHex(name);
          }
          else {
              const hexColor = colourNameToHex(name);
              if (hexColor)
                  this.setFromHex(hexColor);
          }
      }
      /**
       * Returns the hexadecimal value of this color, including the leading "#" character.
       *
       * @return - Returns the hex value.
       */
      toHex() {
          function componentToHex(c) {
              const int = Math.round(c * 255);
              const hex = int.toString(16);
              return hex.length == 1 ? '0' + hex : hex;
          }
          return '#' + componentToHex(this.r) + componentToHex(this.g) + componentToHex(this.b);
      }
      /**
       * Checks if this Color  contains the same values as the other.
       *
       * @param other - The other Color to compare with.
       * @return - Returns `true` if the values are the same, otherwise, `false`.
       */
      isEqual(other) {
          return this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;
      }
      /**
       * Returns true if this color is NOT exactly the same as other.
       *
       * @param other - The other color to compare with.
       * @return - Returns true or false.
       */
      notEquals(other) {
          return this.r != other.r && this.g != other.g && this.b != other.b && this.a != other.a;
      }
      /**
       * Returns true if this color is approximately the same as other.
       *
       * @param other - The other color to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return (Math.abs(this.r - other.r) < precision &&
              Math.abs(this.g - other.g) < precision &&
              Math.abs(this.b - other.b) < precision &&
              Math.abs(this.a - other.a) < precision);
      }
      /**
       * Returns a new Color which is this Color added to other.
       *
       * @param other - The other color to add.
       * @return - Returns a new color.
       */
      add(other) {
          return new Color(this.r + other.r, this.g + other.g, this.b + other.b, this.a + other.a);
      }
      /**
       * Updates this Color by adding the values from the other color.
       *
       * @param other - The other color to add.
       */
      addInPlace(other) {
          this.r += other.r;
          this.g += other.g;
          this.b += other.b;
          this.a += other.a;
      }
      /**
       * Returns a new color which is this color subtracted from other.
       *
       * @param other - The other color to subtract.
       * @return - Returns a new color.
       */
      subtract(other) {
          return new Color(this.r - other.r, this.g - other.g, this.b - other.b, this.a - other.a);
      }
      /**
       * Scales this color by scalar and return the result as a new Vec4.
       *
       * @param scalar - The scalar value.
       * @return - Returns a new color.
       */
      scale(scalar) {
          return new Color(this.r * scalar, this.g * scalar, this.b * scalar, this.a * scalar);
      }
      /**
       * Scales this color by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.r *= scalar;
          this.g *= scalar;
          this.b *= scalar;
          this.a *= scalar;
      }
      /**
       * Apply gamma correction to this color
       *
       * @param gamma - The gamma value.
       */
      applyGamma(gamma) {
          this.set(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
      }
      /**
       * Converts to linear color space and returns a new color
       *
       * @param gamma - The gamma value.
       * @return - Returns a new color.
       */
      toLinear(gamma = 2.2) {
          return new Color(Math.pow(this.r, gamma), Math.pow(this.g, gamma), Math.pow(this.b, gamma), this.a);
      }
      /**
       * returns a new color value value is mapped into a gamma curve
       *
       * @param gamma - The gamma value.
       * @return - Returns a new color.
       */
      toGamma(gamma = 2.2) {
          return new Color(Math.pow(this.r, 1.0 / gamma), Math.pow(this.g, 1.0 / gamma), Math.pow(this.b, 1.0 / gamma), this.a);
      }
      /**
       * Calculates and returns the luminance of the linear RGB components.
       *
       * @return - The return value.
       */
      luminance() {
          return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b;
      }
      /**
       * Performs a linear interpolation between this color and other.
       *
       * @param other - The other color to interpolate between.
       * @param t - Interpolation amount between the two inputs.
       * @return - Returns a new color.
       */
      lerp(other, t) {
          const ar = this.r;
          const ag = this.g;
          const ab = this.b;
          const aa = this.a;
          return new Color(ar + t * (other.r - ar), ag + t * (other.g - ag), ab + t * (other.b - ab), aa + t * (other.a - aa));
      }
      /**
       * Creates a random color.
       *
       * @param gammaOffset - The gamma offset. Values between 0 and 1 increase the average brightness of the generated color. Values between 0 and -1 darken the generated color values.
       * @param randomAlpha - Determines whether the alpha channel is random. If not, the alpha values will be 1.0.
       * @return - The new random color.
       */
      static random(gammaOffset = 0.0, randomAlpha = false) {
          if (gammaOffset > 0.0) {
              return new Color(gammaOffset + Math.random() * (1.0 - gammaOffset), gammaOffset + Math.random() * (1.0 - gammaOffset), gammaOffset + Math.random() * (1.0 - gammaOffset), randomAlpha ? gammaOffset + Math.random() * (1.0 - gammaOffset) : 1.0);
          }
          if (gammaOffset < 0.0) {
              return new Color(Math.random() * (1.0 + gammaOffset), Math.random() * (1.0 + gammaOffset), Math.random() * (1.0 + gammaOffset), randomAlpha ? Math.random() * (1.0 + gammaOffset) : 1.0);
          }
          return new Color(Math.random(), Math.random(), Math.random(), randomAlpha ? Math.random() : 1.0);
      }
      /**
       * Clones this color and returns a new color.
       *
       * @return - Returns a new color.
       */
      clone() {
          return new Color(this.r, this.g, this.b, this.a);
      }
      /**
       * Returns the type as an array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.r, this.g, this.b, this.a];
      }
      /**
       * Setter from an RGB array.
       *
       * @param vals - The vals param.
       */
      fromArray(vals) {
          this.r = vals[0] / 255;
          this.g = vals[1] / 255;
          this.b = vals[2] / 255;
          this.a = vals.length == 4 ? vals[3] / 255 : 1.0;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              r: this.r,
              g: this.g,
              b: this.b,
              a: this.a,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.r = j.r;
          this.g = j.g;
          this.b = j.b;
          this.a = j.a;
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.r = reader.loadFloat32();
          this.g = reader.loadFloat32();
          this.b = reader.loadFloat32();
          this.a = reader.loadFloat32();
      }
      /**
       * Returns the CSS rgba string.
       *
       * @return - The return value.
       */
      toCSSString() {
          return ('rgba(' +
              Math.round(this.r * 255) +
              ', ' +
              Math.round(this.g * 255) +
              ', ' +
              Math.round(this.b * 255) +
              ', ' +
              this.a +
              ')');
      }
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  exports.EulerAnglesAxisOrder = void 0;
  (function (EulerAnglesAxisOrder) {
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["XYZ"] = 0] = "XYZ";
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["YZX"] = 1] = "YZX";
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["ZXY"] = 2] = "ZXY";
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["XZY"] = 3] = "XZY";
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["ZYX"] = 4] = "ZYX";
      EulerAnglesAxisOrder[EulerAnglesAxisOrder["YXZ"] = 5] = "YXZ";
  })(exports.EulerAnglesAxisOrder || (exports.EulerAnglesAxisOrder = {}));
  /**
   * Class representing euler angles. Euler angles describe rotating an object
   * around its various axis in a specified axis order.
   *
   */
  class EulerAngles {
      x;
      y;
      z;
      order;
      /**
       * Create a euler angle. Receives the xyz values in radians and the order that the rotations are applied.
       *
       * Order parameter values: `XYZ: 0`, `YZX: 1`, `ZXY: 2`, `XZY: 3`, `ZYX: 4`, `YXZ: 5`
       *
       * It could be either the `string` or the `number` value.
       *
       * @param x - The angle of the x axis in radians. Default is 0.
       * @param y - The angle of the y axis in radians. Default is 0.
       * @param z - The angle of the z axis in radians. Default is 0.
       * @param order - The order in which the rotations are applied.
       */
      constructor(x = 0, y = 0, z = 0, order = 0) {
          this.x = x;
          this.y = y;
          this.z = z;
          if (typeof order === 'number' && !isNaN(order))
              this.order = order;
          else {
              switch (order) {
                  case 'XYZ':
                      this.order = 0;
                      break;
                  case 'YZX':
                      this.order = 1;
                      break;
                  case 'ZXY':
                      this.order = 2;
                      break;
                  case 'XZY':
                      this.order = 3;
                      break;
                  case 'ZYX':
                      this.order = 4;
                      break;
                  case 'YXZ':
                      this.order = 5;
                      break;
                  default:
                      throw new Error('Invalid Euler Angles Order:' + order);
              }
          }
      }
      /**
       * Sets the EulerAngles
       *
       * @param x - The x axis rotation in radians.
       * @param y - The y axis rotation in radians.
       * @param z - The z axis rotation in radians.
       */
      set(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      toJSON() {
          return {
              x: this.x,
              y: this.y,
              z: this.z,
              order: this.order,
          };
      }
      fromJSON(json) {
          this.x = json.x;
          this.y = json.y;
          this.z = json.z;
          this.order = json.order;
      }
  }

  /* eslint-disable new-cap */
  /**
   * A class representing a 3x3 matrix.
   * This matrix class is based on GLM, and is column major.
   *
   */
  class Mat3 {
      m00 = 1;
      m01 = 0;
      m02 = 0;
      m10 = 0;
      m11 = 1;
      m12 = 0;
      m20 = 0;
      m21 = 0;
      m22 = 1;
      /**
       * Initializes the Mat3 class with given data.
       *
       * @param m00 - Row 0, column 0.
       * @param m01 - Row 0, column 1.
       * @param m02 - Row 0, column 2.
       * @param m10 - Row 1, column 0.
       * @param m11 - Row 1, column 1.
       * @param m12 - Row 1, column 2.
       * @param m20 - Row 2, column 0.
       * @param m21 - Row 2, column 1.
       * @param m22 - Row 2, column 2.
       */
      constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
          if (m00 instanceof Vec3 && m01 instanceof Vec3 && m02 instanceof Vec3) {
              this.set(m00.x, m00.y, m00.z, m01.x, m01.y, m01.z, m02.x, m02.y, m02.z);
          }
          else {
              this.set(m00, m01, m02, m10, m11, m12, m20, m21, m22);
          }
      }
      /**
       * Getter for the `x` axis.
       *
       * @return - Returns the `x` axis as a Vec3.
       */
      get xAxis() {
          return new Vec3(this.m00, this.m01, this.m02);
      }
      /**
       * Setter for the `x` axis.
       *
       * @param vec3 - The vec3 value.
       */
      set xAxis(vec3) {
          this.xAxis.set(vec3.x, vec3.y, vec3.z);
      }
      /**
       * Getter for the `y` axis.
       * * @return - Returns the `y` axis as a Vec3.
       */
      get yAxis() {
          return new Vec3(this.m10, this.m11, this.m12);
      }
      /**
       * Setter for the `y` axis.
       * @param vec3 - The vec3 value.
       */
      set yAxis(vec3) {
          this.yAxis.set(vec3.x, vec3.y, vec3.z);
      }
      /**
       * Getter for the `z` axis.
       * * @return - Returns the `z` axis as a Vec3.
       */
      get zAxis() {
          return new Vec3(this.m20, this.m21, this.m22);
      }
      /**
       * Setter for the `z` axis.
       * @param vec3 - The vec3 value.
       */
      set zAxis(vec3) {
          this.zAxis.set(vec3.x, vec3.y, vec3.z);
      }
      // /////////////////////////////////////////
      // Setters
      /**
       * Sets the state of the Mat3 class
       *
       * @param m00 - Row 0, column 0.
       * @param m01 - Row 0, column 1.
       * @param m02 - Row 0, column 2.
       * @param m10 - Row 1, column 0.
       * @param m11 - Row 1, column 1.
       * @param m12 - Row 1, column 2.
       * @param m20 - Row 2, column 0.
       * @param m21 - Row 2, column 1.
       * @param m22 - Row 2, column 2.
       */
      set(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {
          this.m00 = m00;
          this.m01 = m01;
          this.m02 = m02;
          this.m10 = m10;
          this.m11 = m11;
          this.m12 = m12;
          this.m20 = m20;
          this.m21 = m21;
          this.m22 = m22;
      }
      /**
       * Sets state of the Mat3 with the identity  Matrix
       */
      setIdentity() {
          this.set();
      }
      /**
       * Sets state of the Mat3 from another Mat3
       *
       * Note: works with either Mat3 or Mat4.
       *
       * @param mat - The mat value.
       */
      setFromMat(mat) {
          this.m00 = mat.m00;
          this.m01 = mat.m01;
          this.m02 = mat.m02;
          this.m10 = mat.m10;
          this.m11 = mat.m11;
          this.m12 = mat.m12;
          this.m20 = mat.m20;
          this.m21 = mat.m21;
          this.m22 = mat.m22;
      }
      /**
       * Scales and calculates the cross product of the `Vec3` and sets the result in the Mat3
       * Note: the resulting matrix +Z axis is aligned with the provided direction value.
       *
       * @param dir - The dir value.
       * @param up - The up value.
       */
      setFromDirectionAndUpvector(dir, up) {
          const zAxis = dir;
          const zLen = zAxis.length();
          if (zLen < Number.EPSILON) {
              this.setIdentity();
              return;
          }
          zAxis.scaleInPlace(1 / zLen);
          const xAxis = up.cross(zAxis);
          const xLen = xAxis.length();
          if (xLen > Number.EPSILON)
              xAxis.scaleInPlace(1 / xLen);
          const yAxis = zAxis.cross(xAxis);
          const yLen = yAxis.length();
          if (yLen > Number.EPSILON)
              yAxis.scaleInPlace(1 / yLen);
          this.set(xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
      }
      /**
       * Inverts a Mat3 and returns the result as a new instance.
       *
       * @return - Returns a new Mat3.
       */
      inverse() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m10;
          const a11 = this.m11;
          const a12 = this.m12;
          const a20 = this.m20;
          const a21 = this.m21;
          const a22 = this.m22;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          // Calculate the determinant
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (!det) {
              console.warn('Unable to invert Mat3');
              return new Mat3();
          }
          det = 1.0 / det;
          return new Mat3(b01 * det, (-a22 * a01 + a02 * a21) * det, (a12 * a01 - a02 * a11) * det, b11 * det, (a22 * a00 - a02 * a20) * det, (-a12 * a00 + a02 * a10) * det, b21 * det, (-a21 * a00 + a01 * a20) * det, (a11 * a00 - a01 * a10) * det);
      }
      /**
       * Inverts a Mat3 in place modifying its values.
       *
       * @return - The return value.
       */
      invertInPlace() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a10 = this.m10;
          const a11 = this.m11;
          const a12 = this.m12;
          const a20 = this.m20;
          const a21 = this.m21;
          const a22 = this.m22;
          const b01 = a22 * a11 - a12 * a21;
          const b11 = -a22 * a10 + a12 * a20;
          const b21 = a21 * a10 - a11 * a20;
          // Calculate the determinant
          let det = a00 * b01 + a01 * b11 + a02 * b21;
          if (!det) {
              console.warn('Unable to invert Mat3');
              return false;
          }
          det = 1.0 / det;
          this.set(b01 * det, (-a22 * a01 + a02 * a21) * det, (a12 * a01 - a02 * a11) * det, b11 * det, (a22 * a00 - a02 * a20) * det, (-a12 * a00 + a02 * a10) * det, b21 * det, (-a21 * a00 + a01 * a20) * det, (a11 * a00 - a01 * a10) * det);
          return true;
      }
      /**
       * Transposes (exchanges columns with rows) this matrix
       * and returns the result as a new instance.
       *
       * @return - Return a new transposed Mat3.
       */
      transpose() {
          return new Mat3(this.m00, this.m10, this.m20, this.m01, this.m11, this.m21, this.m02, this.m12, this.m22);
      }
      /**
       * Transposes (exchanges columns with rows) this matrix modifying its values.
       */
      transposeInPlace() {
          // If we are transposing ourselves we can skip a few steps but have to cache some values
          const a01 = this.m01;
          const a02 = this.m02;
          const a12 = this.m12;
          this.m01 = this.m10;
          this.m02 = this.m20;
          this.m10 = a01;
          this.m12 = this.m21;
          this.m20 = a02;
          this.m21 = a12;
      }
      /**
       * Transforms the Vec3 with a Mat3.
       *
       * @param vec3 - The vec3 value.
       * @return - Return the result as a new Vec3.
       */
      transformVec3(vec3) {
          return new Vec3(this.m00 * vec3.x + this.m01 * vec3.y + this.m02 * vec3.z, this.m10 * vec3.x + this.m11 * vec3.y + this.m12 * vec3.z, this.m20 * vec3.x + this.m21 * vec3.y + this.m22 * vec3.z);
      }
      /**
       * Clones this Mat3 returning a new instance.
       *
       * @return - Returns a new Mat3.
       */
      clone() {
          return new Mat3(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);
      }
      // ///////////////////////////
      // Persistence
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          const data = reader.loadFloat32Array(9);
          this.fromArray(data);
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       */
      toJSON() {
          return this.asArray();
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json param.
       */
      fromJSON(json) {
          this.fromArray(json);
      }
      // ///////////////////////////
      // Debugging
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * Returns current Math type data as array. Often used to pass types to the GPU.
       *
       * @return - Returns the result as an array.
       */
      asArray() {
          return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22];
      }
      fromArray(array) {
          this.m00 = array[0];
          this.m01 = array[1];
          this.m02 = array[2];
          this.m10 = array[3];
          this.m11 = array[4];
          this.m12 = array[5];
          this.m20 = array[6];
          this.m21 = array[7];
          this.m22 = array[8];
      }
  }

  /**
   * A class representing a 4x4 matrix.
   * This matrix class is based on GLM, and is column major.
   *
   */
  class Mat4 {
      m00;
      m01;
      m02;
      m03;
      m10;
      m11;
      m12;
      m13;
      m20;
      m21;
      m22;
      m23;
      m30;
      m31;
      m32;
      m33;
      constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {
          this.m00 = m00;
          this.m01 = m01;
          this.m02 = m02;
          this.m03 = m03;
          this.m10 = m10;
          this.m11 = m11;
          this.m12 = m12;
          this.m13 = m13;
          this.m20 = m20;
          this.m21 = m21;
          this.m22 = m22;
          this.m23 = m23;
          this.m30 = m30;
          this.m31 = m31;
          this.m32 = m32;
          this.m33 = m33;
      }
      /**
       * Getter for the `x` axis.
       *
       * @return - Returns the `x` axis as a Vec3.
       */
      get xAxis() {
          return new Vec3(this.m00, this.m01, this.m02);
      }
      /**
       * Setter for the `x` axis.
       *
       * @param vec3 - The vec3 value.
       */
      set xAxis(vec3) {
          this.xAxis.set(vec3.x, vec3.y, vec3.z);
      }
      /**
       * Getter for the `y` axis.
       *
       * @return - Returns the `y` axis as a Vec3.
       */
      get yAxis() {
          return new Vec3(this.m10, this.m11, this.m12);
      }
      /**
       * Setter for the `y` axis.
       *
       * @param vec3 - The vec3 value.
       */
      set yAxis(vec3) {
          this.yAxis.set(vec3.x, vec3.y, vec3.z);
      }
      /**
       * Getter for the `z` axis.
       *
       * @return - Returns the `z` axis as a Vec3.
       */
      get zAxis() {
          return new Vec3(this.m20, this.m21, this.m22);
      }
      /**
       * Setter for the `z` axis.
       *
       * @param vec3 - The vec3 value.
       */
      set zAxis(vec3) {
          this.zAxis.set(vec3.x, vec3.y, vec3.z);
      }
      /**
       * Getter for the translation of the matrix. Assumes the translation values are 12, 13, & 14.
       *
       * @return - Returns the translation.
       */
      get translation() {
          return new Vec3(this.m30, this.m31, this.m32);
      }
      /**
       * Setter for the translation of the matrix. Assumes the translation values are 12, 13, & 14.
       *
       * @param vec3 - The translation.
       */
      set translation(vec3) {
          this.m30 = vec3.x;
          this.m31 = vec3.y;
          this.m32 = vec3.z;
      }
      // /////////////////////////////////////////
      // Setters
      /**
       * Sets the state of the Mat4 class
       *
       * @param m00 - Row 0, column 0.
       * @param m01 - Row 0, column 1.
       * @param m02 - Row 0, column 2.
       * @param m03 - Row 0, column 3.
       * @param m10 - Row 1, column 0.
       * @param m11 - Row 1, column 1.
       * @param m12 - Row 1, column 2.
       * @param m13 - Row 1, column 3.
       * @param m20 - Row 2, column 0.
       * @param m21 - Row 2, column 1.
       * @param m22 - Row 2, column 2.
       * @param m23 - Row 2, column 3.
       * @param m30 - Row 3, column 0.
       * @param m31 - Row 3, column 1.
       * @param m32 - Row 3, column 2.
       * @param m33 - Row 3, column 3.
       */
      set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {
          this.m00 = m00;
          this.m01 = m01;
          this.m02 = m02;
          this.m03 = m03;
          this.m10 = m10;
          this.m11 = m11;
          this.m12 = m12;
          this.m13 = m13;
          this.m20 = m20;
          this.m21 = m21;
          this.m22 = m22;
          this.m23 = m23;
          this.m30 = m30;
          this.m31 = m31;
          this.m32 = m32;
          this.m33 = m33;
      }
      /**
       * Sets state of the Mat4 with the identity  Matrix
       */
      setIdentity() {
          this.set();
      }
      /**
       * Sets state of the Mat4 from another Mat4
       *
       * Note: works with either Mat3 or Mat4.
       *
       * @param mat4 - The mat4 value.
       */
      setFromMat4(mat4) {
          this.m00 = mat4.m00;
          this.m01 = mat4.m01;
          this.m02 = mat4.m02;
          this.m03 = mat4.m03;
          this.m10 = mat4.m10;
          this.m11 = mat4.m11;
          this.m12 = mat4.m12;
          this.m13 = mat4.m13;
          this.m20 = mat4.m20;
          this.m21 = mat4.m21;
          this.m22 = mat4.m22;
          this.m23 = mat4.m23;
          this.m30 = mat4.m30;
          this.m31 = mat4.m31;
          this.m32 = mat4.m32;
          this.m33 = mat4.m33;
      }
      /**
       * Converts a Mat4 to a Mat3.
       *
       * @return - Returns a new Mat3.
       */
      toMat3() {
          return new Mat3(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);
      }
      /**
       * Transposes (exchanges columns with rows) this matrix.
       */
      transposeInPlace() {
          // If we are transposing ourselves we can skip a few steps but have to cache some values
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a12 = this.m12;
          const a13 = this.m13;
          const a23 = this.m23;
          this.m01 = this.m10;
          this.m02 = this.m20;
          this.m03 = this.m30;
          this.m10 = a01;
          this.m12 = this.m21;
          this.m13 = this.m31;
          this.m20 = a02;
          this.m21 = a12;
          this.m23 = this.m32;
          this.m30 = a03;
          this.m31 = a13;
          this.m32 = a23;
      }
      /**
       * Transposes (exchanges columns with rows) this matrix
       * and returns the result as a new instance.
       *
       * @return - Return a new transposed Mat4.
       */
      transpose() {
          return new Mat4(this.m00, this.m10, this.m20, this.m30, this.m01, this.m11, this.m21, this.m31, this.m02, this.m12, this.m22, this.m32, this.m03, this.m13, this.m23, this.m33);
      }
      /**
       * Inverts a Mat4 and returns the result as a new instance.
       *
       * @return - Returns a new Mat4.
       */
      inverse() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m10;
          const a11 = this.m11;
          const a12 = this.m12;
          const a13 = this.m13;
          const a20 = this.m20;
          const a21 = this.m21;
          const a22 = this.m22;
          const a23 = this.m23;
          const a30 = this.m30;
          const a31 = this.m31;
          const a32 = this.m32;
          const a33 = this.m33;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          // Calculate the determinant
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
              console.warn('Unable to invert Mat4');
              return this;
          }
          det = 1.0 / det;
          return new Mat4((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
      }
      /**
       * Inverts a Mat4.
       *
       * @return - The return value.
       */
      invertInPlace() {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m10;
          const a11 = this.m11;
          const a12 = this.m12;
          const a13 = this.m13;
          const a20 = this.m20;
          const a21 = this.m21;
          const a22 = this.m22;
          const a23 = this.m23;
          const a30 = this.m30;
          const a31 = this.m31;
          const a32 = this.m32;
          const a33 = this.m33;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          // Calculate the determinant
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
              console.warn('Unable to invert Mat4');
              return false;
          }
          det = 1.0 / det;
          this.set((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
          return true;
      }
      /**
       * Sets this matrix as the inverse of the given Mat4.
       *
       * @param mat4 - The mat4 value.
       * @return - In case the `determinant` can't be calculated, a `null` will be returned, otherwise, nothing is returned
       */
      setInverse(mat4) {
          const a00 = mat4.m00;
          const a01 = mat4.m01;
          const a02 = mat4.m02;
          const a03 = mat4.m03;
          const a10 = mat4.m10;
          const a11 = mat4.m11;
          const a12 = mat4.m12;
          const a13 = mat4.m13;
          const a20 = mat4.m20;
          const a21 = mat4.m21;
          const a22 = mat4.m22;
          const a23 = mat4.m23;
          const a30 = mat4.m30;
          const a31 = mat4.m31;
          const a32 = mat4.m32;
          const a33 = mat4.m33;
          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;
          // Calculate the determinant
          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
              throw new Error('Unable to invert Mat4');
          }
          det = 1.0 / det;
          this.set((a11 * b11 - a12 * b10 + a13 * b09) * det, (a02 * b10 - a01 * b11 - a03 * b09) * det, (a31 * b05 - a32 * b04 + a33 * b03) * det, (a22 * b04 - a21 * b05 - a23 * b03) * det, (a12 * b08 - a10 * b11 - a13 * b07) * det, (a00 * b11 - a02 * b08 + a03 * b07) * det, (a32 * b02 - a30 * b05 - a33 * b01) * det, (a20 * b05 - a22 * b02 + a23 * b01) * det, (a10 * b10 - a11 * b08 + a13 * b06) * det, (a01 * b08 - a00 * b10 - a03 * b06) * det, (a30 * b04 - a31 * b02 + a33 * b00) * det, (a21 * b02 - a20 * b04 - a23 * b00) * det, (a11 * b07 - a10 * b09 - a12 * b06) * det, (a00 * b09 - a01 * b07 + a02 * b06) * det, (a31 * b01 - a30 * b03 - a32 * b00) * det, (a20 * b03 - a21 * b01 + a22 * b00) * det);
      }
      /**
       * Multiplies two Mat4s and returns the result as a new instance.
       *
       * @param other - The other Mat4 to multiply with.
       * @return - Returns a new Mat4.
       */
      multiply(other) {
          const a00 = this.m00;
          const a01 = this.m01;
          const a02 = this.m02;
          const a03 = this.m03;
          const a10 = this.m10;
          const a11 = this.m11;
          const a12 = this.m12;
          const a13 = this.m13;
          const a20 = this.m20;
          const a21 = this.m21;
          const a22 = this.m22;
          const a23 = this.m23;
          const a30 = this.m30;
          const a31 = this.m31;
          const a32 = this.m32;
          const a33 = this.m33;
          // Cache only the current line of the second matrix
          const b = other.asArray();
          let b0 = b[0];
          let b1 = b[1];
          let b2 = b[2];
          let b3 = b[3];
          const result = new Mat4();
          result.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          result.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          result.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          result.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          result.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          result.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          result.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          result.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          result.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          result.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          result.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          result.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          result.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          result.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          result.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          result.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return result;
      }
      /**
       * Multiplies two Mat4s in place explicitly not using SIMD.
       *
       * @param other - The other Mat4 to multiply with.
       * @return - Returns a new Mat4.
       */
      multiplyInPlace(other) {
          const a = this.asArray();
          const a00 = a[0];
          const a01 = a[1];
          const a02 = a[2];
          const a03 = a[3];
          const a10 = a[4];
          const a11 = a[5];
          const a12 = a[6];
          const a13 = a[7];
          const a20 = a[8];
          const a21 = a[9];
          const a22 = a[10];
          const a23 = a[11];
          const a30 = a[12];
          const a31 = a[13];
          const a32 = a[14];
          const a33 = a[15];
          // Cache only the current line of the second matrix
          const b = other.asArray();
          let b0 = b[0];
          let b1 = b[1];
          let b2 = b[2];
          let b3 = b[3];
          this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          this.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          this.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          this.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
      }
      /**
       * Post multiplies two Mat4s in place explicitly not using SIMD.
       *
       * @param other - The other Mat4 to multiply with.
       * @return - Returns the result as a new Mat4.
       */
      postMultiplyInPlace(other) {
          const a = other.asArray();
          const a00 = a[0];
          const a01 = a[1];
          const a02 = a[2];
          const a03 = a[3];
          const a10 = a[4];
          const a11 = a[5];
          const a12 = a[6];
          const a13 = a[7];
          const a20 = a[8];
          const a21 = a[9];
          const a22 = a[10];
          const a23 = a[11];
          const a30 = a[12];
          const a31 = a[13];
          const a32 = a[14];
          const a33 = a[15];
          // Cache only the current line of the second matrix
          const b = this.asArray();
          let b0 = b[0];
          let b1 = b[1];
          let b2 = b[2];
          let b3 = b[3];
          this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          this.m10 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m11 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m12 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m13 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          this.m20 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m21 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m22 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m23 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          this.m30 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          this.m31 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          this.m32 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          this.m33 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return this;
      }
      /**
       * Translate a Mat4 by the given vector not using SIMD.
       *
       * @param v3 - The given vector to translate along.
       * @return - The return value.
       */
      translateInPlace(v3) {
          const a = this.asArray();
          const x = v3.x;
          const y = v3.y;
          const z = v3.z;
          a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          return this;
      }
      /**
       * Generates a look-at matrix with the given position, focal point, and up axis.
       *
       * @param pos - Position of the viewer.
       * @param target - Point the viewer is looking at.
       * @param up - Vec3 pointing up.
       */
      setLookAt(pos, target, up) {
          const zAxis = pos.subtract(target);
          const zLen = zAxis.length();
          if (zLen < Number.EPSILON) {
              this.setIdentity();
              return;
          }
          zAxis.scaleInPlace(1.0 / zLen);
          const xAxis = up.cross(zAxis);
          const xLen = xAxis.length();
          if (xLen > Number.EPSILON)
              xAxis.scaleInPlace(1.0 / xLen);
          const yAxis = zAxis.cross(xAxis);
          const yLen = yAxis.length();
          if (yLen > Number.EPSILON)
              yAxis.scaleInPlace(1.0 / yLen);
          /* eslint-disable prettier/prettier*/
          this.set(xAxis.x, xAxis.y, xAxis.z, 0, yAxis.x, yAxis.y, yAxis.z, 0, zAxis.x, zAxis.y, zAxis.z, 0, pos.x, pos.y, pos.z, 1);
          /* eslint-enable prettier/prettier*/
      }
      /**
       * Creates a matrix from a given angle around a given axis.
       * This is equivalent to (but much faster than):
       *
       *     mat4.identity(dest);
       *     mat4.rotate(dest, dest, rad, axis);
       *
       * @param axis - The axis to rotate around.
       * @param rad - The angle to rotate the matrix by.
       * @return - The return value.
       */
      setRotation(axis, rad) {
          const len = axis.length();
          if (Math.abs(len) < Number.EPSILON) {
              return null;
          }
          const x = axis.x / len;
          const y = axis.y / len;
          const z = axis.z / len;
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          const t = 1 - c;
          // Perform rotation-specific matrix multiplication
          const a = this.asArray();
          a[0] = x * x * t + c;
          a[1] = y * x * t + z * s;
          a[2] = z * x * t - y * s;
          a[3] = 0;
          a[4] = x * y * t - z * s;
          a[5] = y * y * t + c;
          a[6] = z * y * t + x * s;
          a[7] = 0;
          a[8] = x * z * t + y * s;
          a[9] = y * z * t - x * s;
          a[10] = z * z * t + c;
          a[11] = 0;
          a[12] = 0;
          a[13] = 0;
          a[14] = 0;
          a[15] = 1;
          return this;
      }
      /**
       * Creates a matrix from the given angle around the X axis.
       * This is equivalent to (but much faster than):
       *
       *     mat4.identity(dest);
       *     mat4.rotateX(dest, dest, rad);
       *
       * @param rad - The angle to rotate the matrix by.
       * @return - The return value.
       */
      setXRotation(rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          // Perform axis-specific matrix multiplication
          const a = this.asArray();
          /* eslint-disable prettier/prettier*/
          a[0] = 1;
          a[1] = 0;
          a[2] = 0;
          a[3] = 0;
          a[4] = 0;
          a[5] = c;
          a[6] = s;
          a[7] = 0;
          a[8] = 0;
          a[9] = -s;
          a[10] = c;
          a[11] = 0;
          a[12] = 0;
          a[13] = 0;
          a[14] = 0;
          a[15] = 1;
          /* eslint-enable prettier/prettier*/
          return this;
      }
      /**
       * Creates a matrix from the given angle around the Y axis.
       * This is equivalent to (but much faster than):
       *
       *     mat4.identity(dest);
       *     mat4.rotateY(dest, dest, rad);
       *
       * @param rad - The angle to rotate the matrix by.
       * @return - The return value.
       */
      setYRotation(rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          // Perform axis-specific matrix multiplication
          const a = this.asArray();
          /* eslint-disable prettier/prettier*/
          a[0] = c;
          a[1] = 0;
          a[2] = -s;
          a[3] = 0;
          a[4] = 0;
          a[5] = 1;
          a[6] = 0;
          a[7] = 0;
          a[8] = s;
          a[9] = 0;
          a[10] = c;
          a[11] = 0;
          a[12] = 0;
          a[13] = 0;
          a[14] = 0;
          a[15] = 1;
          /* eslint-enable prettier/prettier*/
          return this;
      }
      /**
       * Creates a matrix from the given angle around the Z axis.
       * This is equivalent to (but much faster than):
       *
       *     mat4.identity(dest);
       *     mat4.rotateZ(dest, dest, rad);
       *
       * @param rad - The angle to rotate the matrix by.
       * @return - The return value.
       */
      setZRotation(rad) {
          const s = Math.sin(rad);
          const c = Math.cos(rad);
          // Perform axis-specific matrix multiplication
          const a = this.asArray();
          /* eslint-disable prettier/prettier*/
          a[0] = c;
          a[1] = s;
          a[2] = 0;
          a[3] = 0;
          a[4] = -s;
          a[5] = c;
          a[6] = 0;
          a[7] = 0;
          a[8] = 0;
          a[9] = 0;
          a[10] = 1;
          a[11] = 0;
          a[12] = 0;
          a[13] = 0;
          a[14] = 0;
          a[15] = 1;
          /* eslint-enable prettier/prettier*/
          return this;
      }
      /**
       * Transforms the Vec4 with a Mat4.
       *
       * @param vec - The vec value.
       * @return - Return the result as a new Vec4.
       */
      transformVec4(vec) {
          const a = this.asArray();
          const x = vec.x;
          const y = vec.y;
          const z = vec.z;
          const w = vec.w;
          return new Vec4(a[0] * x + a[4] * y + a[8] * z + a[12] * w, a[1] * x + a[5] * y + a[9] * z + a[13] * w, a[2] * x + a[6] * y + a[10] * z + a[14] * w, a[3] * x + a[7] * y + a[11] * z + a[15] * w);
      }
      /**
       * Transforms the Vec3 with a Mat4.
       *
       * @param vec - The vec value.
       * @return - Return the result as a new Vec3.
       */
      transformVec3(vec) {
          const a = this.asArray();
          const x = vec.x;
          const y = vec.y;
          const z = vec.z;
          return new Vec3(a[0] * x + a[4] * y + a[8] * z + a[12], a[1] * x + a[5] * y + a[9] * z + a[13], a[2] * x + a[6] * y + a[10] * z + a[14]);
      }
      /**
       * Rotates a given `Vec3` and the result is returned as a new `Vec3`, applying only the top left components of the matrix, so not applying any translation.
       * @param vec - The vec value.
       * @return - Return the result as a new Vec3.
       */
      rotateVec3(vec) {
          const a = this.asArray();
          const x = vec.x;
          const y = vec.y;
          const z = vec.z;
          return new Vec3(a[0] * x + a[4] * y + a[8] * z, a[1] * x + a[5] * y + a[9] * z, a[2] * x + a[6] * y + a[10] * z);
      }
      /**
       * Set the perspective from a Mat4.
       *
       * @param fovY - The fovY value.
       * @param aspect - The aspect value.
       * @param near - The near value.
       * @param far - The far value.
       */
      setPerspectiveMatrix(fovy, aspect, near, far) {
          const f = Math.tan(Math.PI * 0.5 - 0.5 * fovy);
          const rangeInv = 1.0 / (near - far);
          /* eslint-disable prettier/prettier*/
          this.set(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (near + far) * rangeInv, -1, 0, 0, near * far * rangeInv * 2, 0);
          /* eslint-enable prettier/prettier*/
      }
      /**
       * Calculates the orthographic matrix and sets the state of the Mat4 class
       *
       * @param left - The left value.
       * @param right - The right value.
       * @param bottom - The bottom value.
       * @param top - The top value.
       * @param near - The near value.
       * @param far - The far value.
       */
      setOrthographicMatrix(left, right, bottom, top, near, far) {
          const lr = 1 / (left - right);
          const bt = 1 / (bottom - top);
          const nf = 1 / (near - far);
          /* eslint-disable prettier/prettier*/
          this.set(-2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1);
          /* eslint-enable prettier/prettier*/
      }
      /**
       * Set the Matrix to be a scale matrix.
       *
       * @param x - The x value.
       * @param y - The y value.
       * @param z - The z value.
       */
      setScale(x, y, z) {
          /* eslint-disable prettier/prettier*/
          if (x instanceof Vec3) {
              this.set(x.x, 0, 0, 0, 0, x.y, 0, 0, 0, 0, x.z, 0, 0, 0, 0, 1);
          }
          else {
              this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
          }
          /* eslint-enable prettier/prettier*/
      }
      /**
       * Transforms a 3x4 matrix into a 4x4 matrix and set the result to the Math4 state.
       *
       * @param m3x4 - The m3x4 value.
       */
      setFromMat3x4Array(m3x4) {
          /* eslint-disable prettier/prettier*/
          this.set(m3x4[0], m3x4[1], m3x4[2], 0, m3x4[3], m3x4[4], m3x4[5], 0, m3x4[6], m3x4[7], m3x4[8], 0, m3x4[9], m3x4[10], m3x4[11], 1);
          /* eslint-enable prettier/prettier*/
      }
      /**
       * Clones this Mat4 returning a new instance.
       *
       * @return - Returns a new Mat4.
       */
      clone() {
          return new Mat4(this.m00, this.m01, this.m02, this.m03, this.m10, this.m11, this.m12, this.m13, this.m20, this.m21, this.m22, this.m23, this.m30, this.m31, this.m32, this.m33);
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       */
      toJSON() {
          return this.asArray();
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       */
      fromJSON(json) {
          this.fromArray(json);
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.fromArray(reader.loadFloat32Array(16));
      }
      /**
       * Returns current Math type data as array. Often used to pass types to the GPU.
       *
       * @return - Returns the result as an array.
       */
      asArray() {
          return [
              this.m00,
              this.m01,
              this.m02,
              this.m03,
              this.m10,
              this.m11,
              this.m12,
              this.m13,
              this.m20,
              this.m21,
              this.m22,
              this.m23,
              this.m30,
              this.m31,
              this.m32,
              this.m33,
          ];
      }
      fromArray(array) {
          this.m00 = array[0];
          this.m01 = array[1];
          this.m02 = array[2];
          this.m03 = array[3];
          this.m10 = array[4];
          this.m11 = array[5];
          this.m12 = array[6];
          this.m13 = array[7];
          this.m20 = array[8];
          this.m21 = array[9];
          this.m22 = array[10];
          this.m23 = array[11];
          this.m30 = array[12];
          this.m31 = array[13];
          this.m32 = array[14];
          this.m33 = array[15];
      }
  }

  /* eslint-disable no-unused-vars */
  /**
   * Class representing a quaternion. Quaternions are used to represent 3 dimensional rotations.
   *
   * While Quaternions are difficult to understand they have important mathematical properties that make them very useful in 3d engines.
   * They can be directly multiplied together in the same was as matrices.
   * They can be interpolated from one value to another while maintaining constant angular velocity.
   * They can be converted to other more easily understood representations such as EulerAngles or Matrices.
   *

   */
  class Quat {
      x;
      y;
      z;
      w;
      /**
       * Creates a quaternion.
       */
      constructor(x = 0, y = 0, z = 0, w = 1) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
      }
      /**
       * Setter from scalar components.
       *
       * @param x - The x axis rotation.
       * @param y  - The y axis rotation.
       * @param z  - The z axis rotation.
       * @param w  - The w value.
       */
      set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
      }
      /**
       * Setter from another vector.
       *
       * @param other - The other vector to set from.
       */
      setFromOther(other) {
          this.x = other.x;
          this.y = other.y;
          this.z = other.z;
          this.w = other.w;
      }
      /**
       * Set this Quat from a euler rotation.
       *
       * @param eulerAngles - The euler angles rotation.
       */
      setFromEulerAngles(eulerAngles) {
          const ordered = new Vec3();
          switch (eulerAngles.order) {
              case exports.EulerAnglesAxisOrder.XYZ:
                  ordered.set(eulerAngles.x, -eulerAngles.y, eulerAngles.z);
                  break;
              case exports.EulerAnglesAxisOrder.YZX:
                  ordered.set(eulerAngles.y, -eulerAngles.z, eulerAngles.x);
                  break;
              case exports.EulerAnglesAxisOrder.ZXY:
                  ordered.set(eulerAngles.z, -eulerAngles.x, eulerAngles.y);
                  break;
              case exports.EulerAnglesAxisOrder.XZY:
                  ordered.set(eulerAngles.x, eulerAngles.z, eulerAngles.y);
                  break;
              case exports.EulerAnglesAxisOrder.ZYX:
                  ordered.set(eulerAngles.z, eulerAngles.y, eulerAngles.x);
                  break;
              case exports.EulerAnglesAxisOrder.YXZ:
                  ordered.set(eulerAngles.y, eulerAngles.x, eulerAngles.z);
                  break;
              default:
                  throw new Error(`Invalid EulerAngles order: ${eulerAngles.order}`);
          }
          const ti = ordered.x * 0.5;
          const tj = ordered.y * 0.5;
          const tk = ordered.z * 0.5;
          const ci = Math.cos(ti);
          const cj = Math.cos(tj);
          const ck = Math.cos(tk);
          const si = Math.sin(ti);
          const sj = Math.sin(tj);
          const sk = Math.sin(tk);
          const cc = ci * ck;
          const cs = ci * sk;
          const sc = si * ck;
          const ss = si * sk;
          const ai = cj * sc - sj * cs;
          const aj = cj * ss + sj * cc;
          const ak = cj * cs - sj * sc;
          this.w = cj * cc + sj * ss;
          switch (eulerAngles.order) {
              case 0:
                  // ' XYZ'
                  this.x = ai;
                  this.y = -aj;
                  this.z = ak;
                  break;
              case 1:
                  // 'YZX'
                  this.x = ak;
                  this.y = ai;
                  this.z = -aj;
                  break;
              case 2:
                  // 'ZXY'
                  this.x = -aj;
                  this.y = ak;
                  this.z = ai;
                  break;
              case 3:
                  // 'XZY'
                  this.x = ai;
                  this.y = ak;
                  this.z = aj;
                  break;
              case 4:
                  // 'ZYX'
                  this.x = ak;
                  this.y = aj;
                  this.z = ai;
                  break;
              case 5:
                  // 'YXZ'
                  this.x = aj;
                  this.y = ai;
                  this.z = ak;
                  break;
              default:
                  throw new Error(`Invalid EulerAngles order: ${eulerAngles.order}`);
          }
      }
      /**
       * Converts Quat to an EulerAngles
       *
       * @param rotationOrder - The order in which the rotations are applied.
       * @return - The return value.
       */
      toEulerAngles(rotationOrder) {
          const ordered = new Vec3();
          switch (rotationOrder) {
              case exports.EulerAnglesAxisOrder.XYZ:
              case 'XYZ':
                  ordered.set(this.z, this.x, this.y);
                  break;
              case exports.EulerAnglesAxisOrder.YZX:
              case 'YZX':
                  ordered.set(this.x, this.y, this.z);
                  break;
              case exports.EulerAnglesAxisOrder.ZXY:
              case 'ZXY':
                  ordered.set(this.y, this.z, this.x);
                  break;
              case exports.EulerAnglesAxisOrder.XZY:
              case 'XZY':
                  ordered.set(this.y, -this.x, this.z);
                  break;
              case exports.EulerAnglesAxisOrder.ZYX:
              case 'ZYX':
                  ordered.set(this.x, -this.z, this.y);
                  break;
              case exports.EulerAnglesAxisOrder.YXZ:
              case 'YXZ':
                  ordered.set(this.z, -this.y, this.x);
                  break;
              default:
                  throw new Error('Invalid rotation order:' + rotationOrder);
          }
          const euler = new Vec3();
          const test = ordered.x * ordered.y + ordered.z * this.w;
          if (test > 0.49999) {
              // singularity at north pole
              euler.y = 2.0 * Math.atan2(ordered.x, this.w);
              euler.z = Math.PI * 0.5;
              euler.x = 0.0;
          }
          else if (test < -0.49999) {
              // singularity at south pole
              euler.y = -2.0 * Math.atan2(ordered.x, this.w);
              euler.z = Math.PI * -0.5;
              euler.x = 0.0;
          }
          else {
              const sqx = ordered.x * ordered.x;
              const sqy = ordered.y * ordered.y;
              const sqz = ordered.z * ordered.z;
              euler.y = Math.atan2(2.0 * ordered.y * this.w - 2.0 * ordered.x * ordered.z, 1.0 - 2.0 * sqy - 2.0 * sqz);
              euler.z = Math.asin(2.0 * test);
              euler.x = Math.atan2(2.0 * ordered.x * this.w - 2.0 * ordered.y * ordered.z, 1.0 - 2.0 * sqx - 2.0 * sqz);
          }
          switch (rotationOrder) {
              case exports.EulerAnglesAxisOrder.XYZ:
              case 'XYZ':
                  return new EulerAngles(euler.y, euler.z, euler.x, rotationOrder);
              case exports.EulerAnglesAxisOrder.YZX:
              case 'YZX':
                  return new EulerAngles(euler.x, euler.y, euler.z, rotationOrder);
              case exports.EulerAnglesAxisOrder.ZXY:
              case 'ZXY':
                  return new EulerAngles(euler.z, euler.x, euler.y, rotationOrder);
              case exports.EulerAnglesAxisOrder.XZY:
              case 'XZY':
                  return new EulerAngles(-euler.y, euler.x, euler.z, rotationOrder);
              case exports.EulerAnglesAxisOrder.ZYX:
              case 'ZYX':
                  return new EulerAngles(euler.x, euler.z, -euler.y, rotationOrder);
              case exports.EulerAnglesAxisOrder.YXZ:
              case 'YXZ':
                  return new EulerAngles(euler.z, -euler.y, euler.x, rotationOrder);
          }
      }
      /**
       * Set this Quat to a rotation defined by an axis and an angle (in radians).
       *
       * @param axis - The axis around which to rotate.
       * @param angle - The angle to rotate
       */
      setFromAxisAndAngle(axis, angle) {
          const halfAngle = angle / 2.0;
          const vec = axis.normalize().scale(Math.sin(halfAngle));
          this.set(vec.x, vec.y, vec.z, Math.cos(halfAngle));
      }
      /**
       * Sets the state of the Quat to look in a particular direction along the z axis.
       * > The camera looks down the negative z axis, so to set a rotation value
       * > for the camera, remember to negate the direction vector.
       *
       * @param dir - The direction value.
       * @param up - The up vector.
       */
      setFromDirectionAndUpvector(dir, up) {
          const mat3 = new Mat3();
          mat3.setFromDirectionAndUpvector(dir, up);
          this.setFromMat3(mat3);
      }
      /**
       * Sets the state of the `Quat` from two `Vec3`. The quaternion would then represent the rotation from v0 to v1 in 3d space.
       *
       * @param v0 - The v0 unit vector.
       * @param v1 - The v1 unit vector.
       */
      setFrom2Vectors(v0, v1) {
          const c = v0.cross(v1);
          const d = v0.dot(v1);
          const s = Math.sqrt((1 + d) * 2);
          // this.set( s/2, c.x / s, c.y / s, c.z / s );
          this.set(c.x / s, c.y / s, c.z / s, s / 2);
          this.normalizeInPlace();
      }
      /**
       * Set the Quat from a Mat3.
       *
       * @param mat3 - The mat3 value.
       */
      setFromMat3(mat3) {
          // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
          // article "Quaternion Calculus and Fast Animation".
          const data = mat3.asArray();
          const fTrace = data[0] + data[4] + data[8];
          let fRoot;
          if (fTrace > 0.0) {
              // |w| > 1/2, may as well choose w > 1/2
              fRoot = Math.sqrt(fTrace + 1); // 2w
              this.w = 0.5 * fRoot;
              fRoot = 0.5 / fRoot; // 1/(4w)
              this.x = (data[5] - data[7]) * fRoot;
              this.y = (data[6] - data[2]) * fRoot;
              this.z = (data[1] - data[3]) * fRoot;
          }
          else {
              // |w| <= 1/2
              let i = 0;
              if (data[4] > data[0])
                  i = 1;
              if (data[8] > data[i * 3 + i])
                  i = 2;
              const j = (i + 1) % 3;
              const k = (i + 2) % 3;
              fRoot = Math.sqrt(data[i * 3 + i] - data[j * 3 + j] - data[k * 3 + k] + 1.0);
              const array = [0, 0, 0, 0];
              array[i] = 0.5 * fRoot;
              fRoot = 0.5 / fRoot;
              array[3] = (data[j * 3 + k] - data[k * 3 + j]) * fRoot;
              array[j] = (data[j * 3 + i] + data[i * 3 + j]) * fRoot;
              array[k] = (data[k * 3 + i] + data[i * 3 + k]) * fRoot;
              this.fromArray(array);
          }
          this.normalizeInPlace();
      }
      /**
       * Set the Quat from a Mat4.
       *
       * @param mat4 - The mat4 value.
       */
      setFromMat4(mat4) {
          // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
          // article "Quaternion Calculus and Fast Animation".
          const data = mat4.asArray();
          const fTrace = data[0] + data[5] + data[10];
          let fRoot;
          if (fTrace > 0.0) {
              // |w| > 1/2, may as well choose w > 1/2
              fRoot = Math.sqrt(fTrace + 1); // 2w
              this.w = 0.5 * fRoot;
              fRoot = 0.5 / fRoot; // 1/(4w)
              this.x = (data[6] - data[9]) * fRoot;
              this.y = (data[8] - data[2]) * fRoot;
              this.z = (data[1] - data[4]) * fRoot;
          }
          else {
              // |w| <= 1/2
              let i = 0;
              if (data[5] > data[0])
                  i = 1;
              if (data[10] > data[i * 4 + i])
                  i = 2;
              const j = (i + 1) % 3;
              const k = (i + 2) % 3;
              fRoot = Math.sqrt(data[i * 4 + i] - data[j * 4 + j] - data[k * 4 + k] + 1.0);
              const array = [0, 0, 0, 0];
              array[i] = 0.5 * fRoot;
              fRoot = 0.5 / fRoot;
              array[3] = (data[j * 4 + k] - data[k * 4 + j]) * fRoot;
              array[j] = (data[j * 4 + i] + data[i * 4 + j]) * fRoot;
              array[k] = (data[k * 4 + i] + data[i * 4 + k]) * fRoot;
              this.fromArray(array);
          }
          this.normalizeInPlace();
      }
      /**
       * Checks if the angle of the Quat is less that ` Number.EPSILON`
       *
       * @return - Returns true or false.
       */
      isIdentity() {
          return this.getAngle() < Number.EPSILON;
      }
      /**
       * Return the angle of the Quat.
       *
       * @return - The return value.
       */
      getAngle() {
          return Math.acos(this.w) * 2.0;
      }
      /**
       * Checks if this Quat contains the same values as the other Quat.
       *
       * @param other - The other Quat to compare with.
       * @return - Returns `true` if are the same Vector, otherwise, `false`.
       */
      isEqual(other) {
          return this.x == other.x && this.y == other.y && this.z == other.z && this.w == other.w;
      }
      /**
       * Returns true if this Quat is NOT exactly the same other.
       *
       * @param other - The other Quat to compare with.
       * @return - Returns true or false.
       */
      notEquals(other) {
          return this.x != other.x && this.y != other.y && this.z != other.z && this.w != other.w;
      }
      /**
       * Returns true if this Quat is approximately the same as other
       *
       * @param other - The other Quat to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return (Math.abs(this.x - other.x) < precision &&
              Math.abs(this.y - other.y) < precision &&
              Math.abs(this.z - other.z) < precision &&
              Math.abs(this.w - other.w) < precision);
      }
      /**
       * Adds other to this Quat and return the result as a new Quat.
       *
       * @param other - The other Quat to add.
       * @return - Returns a new Quat.
       */
      add(other) {
          return new Quat(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);
      }
      /**
       * Adds other to this Quat.
       *
       * @param other - The other Quat to add.
       */
      addInPlace(other) {
          this.x += other.x;
          this.y += other.y;
          this.z += other.z;
          this.w += other.w;
      }
      /**
       * Subtracts other from this Quat and returns the result as a new Quat.
       *
       * @param other - The other Quat to subtract.
       * @return - Returns a new Quat.
       */
      subtract(other) {
          return new Quat(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);
      }
      /**
       * Scales this Quat by scalar and returns the result as a new Quat.
       *
       * @param scalar - The scalar value.
       * @return - Returns a new Vec3.
       */
      scale(scalar) {
          return new Quat(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar);
      }
      /**
       * Scales this Quat by scalar.
       *
       * @param scalar - The scalar value.
       */
      scaleInPlace(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
      }
      /**
       * Calculates the length of this Quat.
       *
       * @return - Returns the length.
       */
      length() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return Math.sqrt(x * x + y * y + z * z + w * w);
      }
      /**
       * Calculates the squared length of this Quat.
       *
       * @return - Returns the length.
       */
      lengthSquared() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          return x * x + y * y + z * z + w * w;
      }
      /**
       * Normalizes the Quat and returns it as a new Quat.
       *
       * @return - Returns the Quat normalized.
       */
      normalize() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len < Number.EPSILON) {
              return new Quat();
          }
          // TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          return new Quat(x * len, y * len, z * len, w * len);
      }
      /**
       * Normalizes the Quat, modifying its values in place.
       */
      normalizeInPlace() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          let len = x * x + y * y + z * z + w * w;
          if (len < Number.EPSILON) {
              return;
          }
          len = 1 / Math.sqrt(len);
          this.set(x * len, y * len, z * len, w * len);
      }
      /**
       * Calculates the dot product of this quat against another.
       *
       * @param other - The other Quat to compare with.
       * @return - Returns the dot product.
       */
      dot(other) {
          return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
      }
      /**
       * Calculates the cross product of two Quats and returns the result as a new Quat.
       *
       * @param other - The other Quat to calculate with.
       * @return - Returns the cross product as a new Quat.
       */
      cross(other) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const at = this.w;
          const bx = other.x;
          const by = other.y;
          const bz = other.z;
          const bt = other.w;
          return new Quat(ay * bz - az * by, az * bt - at * bz, at * bx - ax * bt, ax * by - ay * bx);
      }
      /**
       * Returns the rotational conjugate of this Quat.
       * Conjugation represents the same rotation of the Quat but
       * in the opposite direction around the rotational axis.
       *
       * @return - the return value.
       */
      conjugate() {
          return new Quat(-this.x, -this.y, -this.z, this.w);
      }
      /**
       * Return the inverse of the `Quat`
       *
       * @return - Returns a new Quat.
       */
      inverse() {
          return this.conjugate();
      }
      /**
       * Aligns this quaternion with another one ensuring that the delta between
       * the Quat values is the shortest path over the hyper-sphere.
       *
       *  @param other - The other Quat to divide by.
       */
      alignWith(other) {
          if (this.dot(other) < 0.0) {
              this.set(-this.x, -this.y, -this.z, -this.w);
          }
      }
      /**
       * Multiplies two this quat by another returning the result as a new Quat.
       *
       * @param other - The other Quat to multiply.
       * @return - Returns a new Quat.
       */
      multiply(other) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const aw = this.w;
          const bx = other.x;
          const by = other.y;
          const bz = other.z;
          const bw = other.w;
          return new Quat(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
      }
      /**
       * Multiplies this quat by another, modifying its values in place.
       *
       * @param other - The other Quat to multiply.
       */
      multiplyInPlace(other) {
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const aw = this.w;
          const bx = other.x;
          const by = other.y;
          const bz = other.z;
          const bw = other.w;
          this.set(ax * bw + aw * bx + ay * bz - az * by, ay * bw + aw * by + az * bx - ax * bz, az * bw + aw * bz + ax * by - ay * bx, aw * bw - ax * bx - ay * by - az * bz);
      }
      /**
       * Rotates a vector by this quaternion.
       * Don't forget to normalize the quaternion unless
       * you want axial translation as well as rotation.
       *
       * @param vec3 - The vec3 value.
       * @return - Returns a new Vec3.
       */
      rotateVec3(vec3) {
          const vq = new Quat(vec3.x, vec3.y, vec3.z, 0.0);
          const pq = this.multiply(vq).multiply(this.conjugate());
          return new Vec3(pq.x, pq.y, pq.z);
      }
      /**
       * Sets this quaternion to a rotation by the given angle about the X axis.
       *
       * @param rad - Angle (in radians) to rotate.
       */
      rotateX(rad) {
          rad *= 0.5;
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const aw = this.w;
          const bx = Math.sin(rad);
          const bw = Math.cos(rad);
          this.x = ax * bw + aw * bx;
          this.y = ay * bw + az * bx;
          this.z = az * bw - ay * bx;
          this.w = aw * bw - ax * bx;
      }
      /**
       * Sets this quaternion to a rotation by the given angle about the Y axis.
       *
       * @param rad - Angle (in radians) to rotate.
       */
      rotateY(rad) {
          rad *= 0.5;
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const aw = this.w;
          const by = Math.sin(rad);
          const bw = Math.cos(rad);
          this.x = ax * bw - az * by;
          this.y = ay * bw + aw * by;
          this.z = az * bw + ax * by;
          this.w = aw * bw - ay * by;
      }
      /**
       * Sets this quaternion to a rotation by the given angle about the Z axis.
       *
       * @param rad - Angle (in radians) to rotate.
       */
      rotateZ(rad) {
          rad *= 0.5;
          const ax = this.x;
          const ay = this.y;
          const az = this.z;
          const aw = this.w;
          const bz = Math.sin(rad);
          const bw = Math.cos(rad);
          this.x = ax * bw + ay * bz;
          this.y = ay * bw - ax * bz;
          this.z = az * bw + aw * bz;
          this.w = aw * bw - az * bz;
      }
      /**
       * Converts this Quat to a Mat3 (a 3x3 matrix).
       *
       * @return - TReturns a new Mat3.
       */
      toMat3() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          const mat3 = new Mat3();
          mat3.m00 = 1 - yy - zz;
          mat3.m10 = yx - wz;
          mat3.m20 = zx + wy;
          mat3.m01 = yx + wz;
          mat3.m11 = 1 - xx - zz;
          mat3.m21 = zy - wx;
          mat3.m02 = zx - wy;
          mat3.m12 = zy + wx;
          mat3.m22 = 1 - xx - yy;
          return mat3;
      }
      /**
       * Calculates a Vec3 value aligned with the X axis of this quaternion.
       *
       * @return - The resulting Vec3 value
       */
      getXaxis() {
          const xy = this.x * this.y;
          const xz = this.x * this.z;
          const yy = this.y * this.y;
          const yw = this.y * this.w;
          const zz = this.z * this.z;
          const zw = this.z * this.w;
          return new Vec3(1.0 - 2.0 * (zz + yy), 2.0 * (xy + zw), 2.0 * (xz - yw));
      }
      /**
       * Calculates a Vec3 value aligned with the Y axis of this quaternion.
       *
       * @return - The resulting Vec3 value
       */
      getYaxis() {
          const xx = this.x * this.x;
          const xy = this.x * this.y;
          const xw = this.x * this.w;
          const yz = this.y * this.z;
          const zz = this.z * this.z;
          const zw = this.z * this.w;
          return new Vec3(2.0 * (xy - zw), 1.0 - 2.0 * (zz + xx), 2.0 * (yz + xw));
      }
      /**
       * Calculates a Vec3 value aligned with the Z axis of this quaternion.
       *
       * @return - The resulting Vec3 value
       */
      getZaxis() {
          const xx = this.x * this.x;
          const xz = this.x * this.z;
          const xw = this.x * this.w;
          const yy = this.y * this.y;
          const yz = this.y * this.z;
          const yw = this.y * this.w;
          // const temp = new Vec3()
          return new Vec3(2.0 * (yw + xz), 2.0 * (yz - xw), 1.0 - 2.0 * (yy + xx));
      }
      /**
       * Reflects this quaternion according to the axis provided.
       *
       * @param axisIndex - An integer with value of 0 for the X axis, 1 for the Y axis, and 2 for the Z axis.
       * @return - Returns a new Quat.
       */
      mirror(axisIndex) {
          switch (axisIndex) {
              case 0:
                  return new Quat(this.z, this.w, this.x, this.y);
              case 1:
                  return new Quat(-this.w, this.z, this.y, -this.x);
              case 2:
                  return new Quat(this.x, this.y, this.z, -this.w);
              case 0:
              default:
                  return new Quat(this.z, this.w, this.x, this.y);
          }
      }
      /**
       * Converts this Quat to a Mat4 (a 4x4 matrix).
       *
       * @return - Returns a new Mat4.
       */
      toMat4() {
          const x = this.x;
          const y = this.y;
          const z = this.z;
          const w = this.w;
          const x2 = x + x;
          const y2 = y + y;
          const z2 = z + z;
          const xx = x * x2;
          const yx = y * x2;
          const yy = y * y2;
          const zx = z * x2;
          const zy = z * y2;
          const zz = z * z2;
          const wx = w * x2;
          const wy = w * y2;
          const wz = w * z2;
          // Set the columns
          const mat4 = new Mat4();
          mat4.m00 = 1 - yy - zz;
          mat4.m10 = yx - wz;
          mat4.m20 = zx + wy;
          mat4.m01 = yx + wz;
          mat4.m11 = 1 - xx - zz;
          mat4.m21 = zy - wx;
          mat4.m02 = zx - wy;
          mat4.m12 = zy + wx;
          mat4.m22 = 1 - xx - yy;
          return mat4;
      }
      /**
       * Performs a linear interpolation of this Quat towards another Quat, returning the result as a new Quat.
       *
       * @param other  - The other Quat to interpolate towards.
       * @param t - Interpolation ratio.
       * @return - Returns a new Quat.
       */
      lerp(other, t) {
          const result = new Quat(this.x + t * (other.x - this.x), this.y + t * (other.y - this.y), this.z + t * (other.z - this.z), this.w + t * (other.w - this.w));
          result.normalizeInPlace();
          return result;
      }
      /**
       * Performs a spherical linear interpolation of this Quat towards another Quat, returning the result as a new Quat.
       *
       * @param other - The other Quat to interpolate towards.
       * @param t - Interpolation amount between the two inputs.
       * @return - Returns a new Quat.
       */
      slerp(other, lambda) {
          /// https://www.geometrictools.com/Documentation/FastAndAccurateSlerp.pdf
          const dotProduct = this.dot(other);
          if (dotProduct > 0.999)
              return this;
          // algorithm adapted from Shoemake's paper
          // lambda is in (0, /2]
          const theta = Math.acos(dotProduct);
          const st = Math.sin(theta);
          const sut = Math.sin(lambda * theta);
          const sout = Math.sin((1 - lambda) * theta);
          const coeff1 = sout / st;
          const coeff2 = sut / st;
          const result = new Quat(coeff1 * this.x + coeff2 * other.x, coeff1 * this.y + coeff2 * other.y, coeff1 * this.z + coeff2 * other.z, coeff1 * this.w + coeff2 * other.w);
          result.normalizeInPlace();
          return result;
      }
      /**
       * Clones this Quat and returns a new Quat.
       *
       * @return - Returns a new Quat.
       */
      clone() {
          return new Quat(this.x, this.y, this.z, this.w);
      }
      /**
       * Returns the type as an array. Often used to pass types to the GPU.
       *
       * @return - Returns as an array.
       */
      asArray() {
          return [this.x, this.y, this.z, this.w];
      }
      fromArray(array) {
          this.x = array[0];
          this.y = array[1];
          this.z = array[2];
          this.w = array[3];
      }
      // ///////////////////////////
      // Persistence
      /**
       * Converts this Vec3 to a string in JSON format.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.x = j.x;
          this.y = j.y;
          this.z = j.z;
          this.w = j.w;
          this.normalizeInPlace();
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.x = reader.loadFloat32();
          this.y = reader.loadFloat32();
          this.z = reader.loadFloat32();
          this.w = reader.loadFloat32();
      }
  }

  /* eslint-disable no-unused-vars */
  /**
   * Class representing an Xfo transform, which is a transformation decomposed into 3 component values. Translation, Orientation, and Scaling.
   */
  class Xfo {
      tr;
      ori;
      sc;
      /**
       * Initializes the Xfo object.
       *
       * @param tr - The translation value.
       * @param ori - The orientation value.
       * @param sc - The scaling value.
       */
      constructor(tr = new Vec3(), ori = new Quat(), sc = new Vec3(1, 1, 1)) {
          this.tr = tr;
          this.ori = ori;
          this.sc = sc;
      }
      /**
       * Sets the state of the Xfo object.
       *
       * @param tr - The translation value.
       * @param ori - The orientation value.
       * @param sc - The scaling value.
       */
      set(tr, ori, sc) {
          this.tr = tr;
          this.ori = ori;
          if (sc instanceof Vec3)
              this.sc = sc;
      }
      /**
       * Sets the state of the Xfo object using another Xfo object.
       *
       * @param other - The other Xfo to set from.
       */
      setFromOther(other) {
          this.tr = other.tr;
          this.ori = other.ori;
          this.sc = other.sc;
      }
      /**
       * Verifies that the Xfo object is an `identity`, checking that the translation, orientation and scaling attributes are in their initial state.
       *
       * @return - The return value.
       */
      isIdentity() {
          return this.tr.isNull() && this.ori.isIdentity() && this.sc.is111();
      }
      /**
       * Checks if this Vec3 contains the same values as the other Vec3.
       *
       * @param other - The other Vec3 to compare with.
       * @return - Returns `true` if are the same Vector, otherwise, `false`.
       */
      isEqual(other) {
          return this.tr.isEqual(other.tr) && this.ori.isEqual(other.ori) && this.sc.isEqual(other.sc);
      }
      /**
       * Returns true if this Vec2 is approximately the same as other.
       *
       * @param other - The other Vec3 to compare with.
       * @param precision - The precision to which the values must match.
       * @return - Returns true or false.
       */
      approxEqual(other, precision = Number.EPSILON) {
          return ((other.tr ? this.tr.approxEqual(other.tr, precision) : true) &&
              (other.ori ? this.ori.approxEqual(other.ori, precision) : true) &&
              (other.sc ? this.sc.approxEqual(other.sc, precision) : true));
      }
      /**
       * The setLookAt method.
       * @param pos - The position value.
       * @param target - The target value.
       * @param up - The up value.
       */
      setLookAt(pos, target, up) {
          // Note: We look along the -z axis. Negate the direction.
          const dir = pos.subtract(target);
          const dirLen = dir.length();
          if (dirLen < Number.EPSILON) {
              throw new Error('Invalid dir');
          }
          this.ori.setFromDirectionAndUpvector(dir, up);
          this.tr = pos;
      }
      /**
       * Multiplies two Xfo transforms.
       *
       * @param xfo - The xfo to multiply with.
       * @return - Returns an Xfo.
       */
      multiply(xfo) {
          let this_sc = this.sc;
          // check for non-uniform scale.
          if (Math.abs(this.sc.y - this.sc.x) > 0.001 ||
              Math.abs(this.sc.z - this.sc.x) > 0.001 ||
              Math.abs(this.sc.z - this.sc.y) > 0.001) {
              const this_mat4 = this.toMat4();
              const other_mat4 = xfo.ori.toMat4();
              const resM4 = this_mat4.multiply(other_mat4);
              this_sc = new Vec3(resM4.xAxis.length(), resM4.yAxis.length(), resM4.zAxis.length());
          }
          const result = new Xfo(this.tr.add(this.ori.rotateVec3(this.sc.multiply(xfo.tr))), this.ori.multiply(xfo.ori), this_sc.multiply(xfo.sc));
          return result;
      }
      /**
       * Returns the inverse of the Xfo object, but returns. the result as a new Xfo.
       *
       * @return - Returns a new Xfo.
       */
      inverse() {
          const result = new Xfo();
          result.ori = this.ori.inverse();
          // check for non-uniform scale.
          if (Math.abs(this.sc.y - this.sc.x) > 0.001 ||
              Math.abs(this.sc.z - this.sc.x) > 0.001 ||
              Math.abs(this.sc.z - this.sc.y) > 0.001) {
              const this_mat4 = this.toMat4().inverse();
              result.sc = new Vec3(this_mat4.xAxis.length(), this_mat4.yAxis.length(), this_mat4.zAxis.length());
          }
          else {
              result.sc = this.sc.inverse();
          }
          result.tr = result.ori.rotateVec3(this.tr.negate().multiply(result.sc));
          return result;
      }
      /**
       * Transforms Xfo object using a `Vec3` object. First scaling it, then rotating and finally adding the result to current translation object.
       *
       * @param vec3 - The vec3 value.
       * @return - The return value.
       */
      transformVec3(vec3) {
          return this.tr.add(this.ori.rotateVec3(this.sc.multiply(vec3)));
      }
      /**
       * Performs a linear interpolation between this Xfo and other.
       *
       * @param other - The other Xfo to interpolate towards.
       * @param t - Interpolation ratio.
       * @return - Returns a new Xfo.
       */
      lerp(other, t) {
          return new Xfo(this.tr.lerp(other.tr, t), this.ori.slerp(other.ori, t), this.sc.lerp(other.sc, t));
      }
      /**
       * Converts this Xfo to a Mat4 (a 4x4 matrix).
       *
       * @return - Returns a new Mat4.
       */
      toMat4() {
          const scl = new Mat4(this.sc.x, 0, 0, 0, 0, this.sc.y, 0, 0, 0, 0, this.sc.z, 0, 0, 0, 0, 1.0);
          const rot = this.ori.toMat4();
          const trn = new Mat4();
          trn.translation = this.tr;
          return trn.multiply(rot).multiply(scl);
      }
      /**
       * Sets the state of the Xfo object using Mat4.
       * @param mat4 - The mat4 value.
       */
      setFromMat4(mat4) {
          this.tr = mat4.translation;
          this.ori.setFromMat4(mat4);
          this.sc.set(mat4.xAxis.length(), mat4.yAxis.length(), mat4.zAxis.length());
      }
      /**
       * Clones this Xfo and returns a new Xfo.
       *
       * @return - Returns a new Xfo.
       */
      clone() {
          return new Xfo(this.tr.clone(), this.ori.clone(), this.sc.clone());
      }
      // ///////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          const j = {
              tr: this.tr.toJSON(),
              ori: this.ori.toJSON(),
              sc: this.sc.toJSON(),
          };
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.tr.fromJSON(j.tr);
          this.ori.fromJSON(j.ori);
          if (j.sc) {
              this.sc.fromJSON(j.sc);
          }
      }
      /**
       * Loads the state of the value from a binary reader.
       *
       * @param reader - The reader value.
       */
      readBinary(reader) {
          this.tr.readBinary(reader);
          this.ori.readBinary(reader);
          this.sc.readBinary(reader);
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  /**
   * Represents a box in 2D space. Needing two Vec2 vectors describing the corners
   */
  class Box2 {
      p0;
      p1;
      /**
       * Creates a Box2 object using Vec2s.
       * In case the parameters are not passed by, their values are pre-defined:
       *
       * p0 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
       *
       * p1 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
       *
       * @param p0 - A point representing the corners of a 2D box.
       * @param p1 - A point representing the corners of a 2D box.
       */
      constructor(p0, p1) {
          if (p0 instanceof Vec2) {
              this.p0 = p0;
          }
          else {
              this.p0 = new Vec2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
          }
          if (p1 instanceof Vec2) {
              this.p1 = p1;
          }
          else {
              this.p1 = new Vec2(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
          }
      }
      /**
       * Sets both Vec2 points
       *
       * @param p0 - A point representing the corners of a 2D box.
       * @param p1 - A point representing the corners of a 2D box.
       */
      set(p0, p1) {
          this.p0 = p0;
          this.p1 = p1;
      }
      /**
       * Resets the box2 back to an uninitialized state.
       *
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
       * and {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
       */
      reset() {
          this.p0.x = Number.POSITIVE_INFINITY;
          this.p1.x = Number.NEGATIVE_INFINITY;
          this.p0.y = Number.POSITIVE_INFINITY;
          this.p1.y = Number.NEGATIVE_INFINITY;
      }
      /**
       * Returns `true` if the box has been expanded to contain a point.
       *
       * @return - The return value.
       */
      isValid() {
          return (this.p0.x != Number.POSITIVE_INFINITY &&
              this.p1.x != Number.NEGATIVE_INFINITY &&
              this.p0.y != Number.POSITIVE_INFINITY &&
              this.p1.y != Number.NEGATIVE_INFINITY);
      }
      /**
       * Expands the Box2 to contain the new point.
       *
       * @param point - A point represents the corners of a 2D box.
       */
      addPoint(point) {
          if (this.p0.x == Number.POSITIVE_INFINITY || point.x < this.p0.x)
              this.p0.x = point.x;
          if (this.p0.y == Number.POSITIVE_INFINITY || point.y < this.p0.y)
              this.p0.y = point.y;
          if (this.p1.y == Number.NEGATIVE_INFINITY || point.x > this.p1.x)
              this.p1.x = point.x;
          if (this.p1.y == Number.NEGATIVE_INFINITY || point.y > this.p1.y)
              this.p1.y = point.y;
      }
      /**
       * Returns the length of the diagonal of the box.
       *
       * @return - Returns the distance.
       */
      size() {
          return this.p1.distanceTo(this.p0);
      }
      /**
       * Returns the size of a Box2 - the same as size().
       *
       * @return - Returns a Vec2.
       */
      diagonal() {
          return this.p1.subtract(this.p0);
      }
      /**
       * Returns the center point of a Box2.
       *
       * @return - Returns a Vec2.
       */
      center() {
          const result = this.p1.subtract(this.p0);
          result.scaleInPlace(0.5);
          result.addInPlace(this.p0);
          return result;
      }
      /**
       * Clones this Vec2 and returns a new Vec2.
       *
       * @return - Returns a new Vec2.
       */
      clone() {
          return new Box2(this.p0.clone(), this.p1.clone());
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Encodes `Box2` Class as a JSON object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              p0: this.p0.toJSON(),
              p1: this.p1.toJSON(),
          };
      }
      /**
       * Decodes a JSON object to set the state of this class.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          // We need to verify that p0 and p1 axes are numeric, so in case they are not, we restore them to their default values.
          // This, because 'Infinity' and '-Infinity' are stringified as 'null'.
          const p0 = {
              x: MathFunctions.isNumeric(j.p0.x) ? j.p0.x : Number.POSITIVE_INFINITY,
              y: MathFunctions.isNumeric(j.p0.y) ? j.p0.y : Number.POSITIVE_INFINITY,
          };
          const p1 = {
              x: MathFunctions.isNumeric(j.p1.x) ? j.p1.x : Number.NEGATIVE_INFINITY,
              y: MathFunctions.isNumeric(j.p1.y) ? j.p1.y : Number.NEGATIVE_INFINITY,
          };
          this.p0.fromJSON(p0);
          this.p1.fromJSON(p1);
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  /* eslint-disable new-cap */
  /**
   * Class representing a mathematical sphere, as opposed to the Sphere class derived from ProceduralMesh.
   *
   */
  class SphereType {
      pos;
      radius;
      /**
       * Create a sphere.
       * @param pos - The position of the sphere.
       * @param radius - The radius of the sphere.
       */
      constructor(pos = new Vec3(), radius = 0) {
          if (pos instanceof Vec3) {
              this.pos = pos;
          }
          else {
              this.pos = new Vec3();
          }
          this.radius = radius;
      }
      /**
       * Clones this sphere and returns a new sphere.
       *
       * @return - Returns a new sphere.
       */
      clone() {
          return new SphereType(this.pos.clone(), this.radius);
      }
      /**
       * Checks if this sphere intersects a box.
       *
       * @param box - The box value.
       * @return - The return value.
       */
      intersectsBox(box) {
          return box.intersectsSphere(this);
      }
      // ///////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              pos: this.pos.toJSON(),
              radius: this.radius,
          };
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  /**
   * Class representing a box in 3D space.
   * Represents a box in 3D space defined by two Vec3 values which define opposing corners of the box.
   */
  class Box3 {
      p0;
      p1;
      /**
       * Creates a Box3 object using Vec3s.
       * In case the parameters are not passed by, their values are pre-defined:
       *
       * p0 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY|`Number.POSITIVE_INFINITY`}
       *
       * p1 is a Vec2 with {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY|`Number.NEGATIVE_INFINITY`}
       *
       * @param p0 - A point representing the corners of a 3D box.
       * @param p1 - A point representing the corners of a 3D box.
       */
      constructor(p0 = new Vec3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), p1 = new Vec3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)) {
          this.p0 = p0;
          this.p1 = p1;
      }
      /**
       * Getter for the lower (x, y, z) boundary of the box.
       *
       * @return - Returns the minimum Vec3.
       */
      get min() {
          return this.p0;
      }
      /**
       * Getter for the upper (x, y, z) boundary of the box.
       *
       * @return - Returns the maximum Vec3.
       */
      get max() {
          return this.p1;
      }
      /**
       * Sets both Vec3 points
       *
       * @param p0 - A point representing the corners of a 3D box.
       * @param p1 - A point representing the corners of a 3D box.
       */
      set(p0, p1) {
          this.p0 = p0;
          this.p1 = p1;
      }
      /**
       * Resets the box3 back to an uninitialized state.
       */
      reset() {
          this.p0.x = Number.POSITIVE_INFINITY;
          this.p0.y = Number.POSITIVE_INFINITY;
          this.p0.z = Number.POSITIVE_INFINITY;
          this.p1.x = Number.NEGATIVE_INFINITY;
          this.p1.y = Number.NEGATIVE_INFINITY;
          this.p1.z = Number.NEGATIVE_INFINITY;
      }
      /**
       * Returns `true` if the box has been expanded to contain a point.
       *
       * @return - The return value.
       */
      isValid() {
          return (this.p0.x != Number.POSITIVE_INFINITY &&
              this.p1.x != Number.NEGATIVE_INFINITY &&
              this.p0.y != Number.POSITIVE_INFINITY &&
              this.p1.y != Number.NEGATIVE_INFINITY &&
              this.p0.z != Number.POSITIVE_INFINITY &&
              this.p1.z != Number.NEGATIVE_INFINITY);
      }
      /**
       * Expands the Box3 to contain the new point.
       *
       * @param point - A point represents the corners of a 3D box.
       */
      addPoint(point) {
          if (point.x != Number.POSITIVE_INFINITY && point.x != Number.NEGATIVE_INFINITY) {
              if (point.x < this.p0.x)
                  this.p0.x = point.x;
              if (point.x > this.p1.x)
                  this.p1.x = point.x;
          }
          if (point.y != Number.POSITIVE_INFINITY && point.y != Number.NEGATIVE_INFINITY) {
              if (point.y < this.p0.y)
                  this.p0.y = point.y;
              if (point.y > this.p1.y)
                  this.p1.y = point.y;
          }
          if (point.z != Number.POSITIVE_INFINITY && point.z != Number.NEGATIVE_INFINITY) {
              if (point.z < this.p0.z)
                  this.p0.z = point.z;
              if (point.z > this.p1.z)
                  this.p1.z = point.z;
          }
      }
      /**
       * Adds `Box3` to this `Box3`, of the Xfo instance is passed in the parameters
       * it proceeds to apply the transform for the Vec3.
       *
       * @param box3 - A 3D box.
       * @param xfo - A 3D transform.
       */
      addBox3(box3, transform) {
          if (transform) {
              // Transform each corner of the Box3 into the new coordinate system.
              this.addPoint(transform.transformVec3(box3.p0));
              this.addPoint(transform.transformVec3(new Vec3(box3.p0.x, box3.p0.y, box3.p1.z)));
              this.addPoint(transform.transformVec3(new Vec3(box3.p0.x, box3.p1.y, box3.p0.z)));
              this.addPoint(transform.transformVec3(new Vec3(box3.p1.x, box3.p0.y, box3.p0.z)));
              this.addPoint(transform.transformVec3(new Vec3(box3.p0.x, box3.p1.y, box3.p1.z)));
              this.addPoint(transform.transformVec3(new Vec3(box3.p1.x, box3.p0.y, box3.p1.z)));
              this.addPoint(transform.transformVec3(new Vec3(box3.p1.x, box3.p1.y, box3.p0.z)));
              this.addPoint(transform.transformVec3(box3.p1));
          }
          else {
              this.addPoint(box3.p0);
              this.addPoint(box3.p1);
          }
      }
      /**
       * Returns the length of the diagonal of the box.
       *
       * @return - Returns the distance.
       */
      size() {
          return this.p1.distanceTo(this.p0);
      }
      /**
       * Returns the diagonal vector of the B=box from p0 to p1.
       *
       * @return - Returns a Box3.
       */
      diagonal() {
          return this.p1.subtract(this.p0);
      }
      /**
       * Returns the center point of a Box3.
       *
       * @return - Returns a Vec3.
       */
      center() {
          const result = this.p1.subtract(this.p0);
          result.scaleInPlace(0.5);
          result.addInPlace(this.p0);
          return result;
      }
      /**
       * Converts this Box3 to a Mat4 (a 4x4 matrix). The returned mat4 would transform a unit cube into the shape of the Bounding box.
       *
       * @return - Returns a new Mat4.
       */
      toMat4() {
          const scx = this.p1.x - this.p0.x;
          const scy = this.p1.y - this.p0.y;
          const scz = this.p1.z - this.p0.z;
          return new Mat4(scx, 0, 0, 0, 0, scy, 0, 0, 0, 0, scz, 0, this.p0.x, this.p0.y, this.p0.z, 1.0);
      }
      /**
       * Calculates and returns the bounding Sphere of the Box3
       *
       * @return - The return value.
       */
      getBoundingSphere() {
          return new SphereType(this.center(), this.diagonal().length() * 0.5);
      }
      /**
       * Determines if this Box3 intersects a given box value.
       *
       * @param box - The box to check for intersection against.
       * @return - Returns true if the shapes intersect.
       */
      intersectsBox(box) {
          // Using 6 splitting planes to rule out intersections.
          return box.max.x < this.min.x ||
              box.min.x > this.max.x ||
              box.max.y < this.min.y ||
              box.min.y > this.max.y ||
              box.max.z < this.min.z ||
              box.min.z > this.max.z
              ? false
              : true;
      }
      /**
       * Determines if this Box3 intersects a sphere.
       *
       * @param sphere - The sphere to check for intersection against.
       * @return - Returns true if the shapes intersect.
       */
      intersectsSphere(sphere) {
          let closestPoint = new Vec3();
          // Find the point on the AABB closest to the sphere center.
          // this.clampPoint( sphere.center, closestPoint );
          // If that point is inside the sphere, the AABB and sphere intersect.
          return closestPoint.distanceTo(sphere.pos) <= sphere.radius * sphere.radius;
      }
      /**
       * Determines if this Box3 intersects a plane.
       *
       * @param plane - The plane to check for intersection against.
       * @return - The return value.
       */
      intersectsPlane(plane) {
          // We compute the minimum and maximum dot product values. If those values
          // are on the same side (back or front) of the plane, then there is no intersection.
          let min;
          let max;
          if (plane.normal.x > 0) {
              min = plane.normal.x * this.min.x;
              max = plane.normal.x * this.max.x;
          }
          else {
              min = plane.normal.x * this.max.x;
              max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
              min += plane.normal.y * this.min.y;
              max += plane.normal.y * this.max.y;
          }
          else {
              min += plane.normal.y * this.max.y;
              max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
              min += plane.normal.z * this.min.z;
              max += plane.normal.z * this.max.z;
          }
          else {
              min += plane.normal.z * this.max.z;
              max += plane.normal.z * this.min.z;
          }
          return min <= -plane.w && max >= -plane.w;
      }
      /**
       * Clones this Box3 and returns a new Box3.
       * @return - Returns a new Box3.
       */
      clone() {
          return new Box3(this.p0.clone(), this.p1.clone());
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Encodes `Box3` Class as a JSON object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              p0: this.p0.toJSON(),
              p1: this.p1.toJSON(),
          };
      }
      /**
       * Decodes a JSON object to set the state of this class.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          // We need to verify that p0 and p1 axes are numeric, so in case they are not, we restore them to their default values.
          // This, because 'Infinity' and '-Infinity' are stringified as 'null'.
          const p0 = {
              x: MathFunctions.isNumeric(j.p0.x) ? j.p0.x : Number.POSITIVE_INFINITY,
              y: MathFunctions.isNumeric(j.p0.y) ? j.p0.y : Number.POSITIVE_INFINITY,
              z: MathFunctions.isNumeric(j.p0.z) ? j.p0.z : Number.POSITIVE_INFINITY,
          };
          const p1 = {
              x: MathFunctions.isNumeric(j.p1.x) ? j.p1.x : Number.NEGATIVE_INFINITY,
              y: MathFunctions.isNumeric(j.p1.y) ? j.p1.y : Number.NEGATIVE_INFINITY,
              z: MathFunctions.isNumeric(j.p1.z) ? j.p1.z : Number.NEGATIVE_INFINITY,
          };
          this.p0.fromJSON(p0);
          this.p1.fromJSON(p1);
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          // eslint-disable-next-line new-cap
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  /* eslint-disable new-cap */
  /**
   * Class representing a plane.
   */
  class PlaneType {
      normal;
      w;
      /**
       * Create a plane.
       *
       * @param normal - The normal of the plane.
       * @param w - The w value.
       */
      constructor(normal, w = 0) {
          if (normal instanceof Vec3) {
              this.normal = normal;
          }
          else {
              this.normal = new Vec3();
          }
          this.w = w;
      }
      /**
       * Setter from scalar components.
       *
       * @param x - The x value.
       * @param y - The y value.
       * @param z - The z value.
       * @param w - The w value.
       */
      set(x, y, z, w) {
          this.normal.set(x, y, z);
          this.w = w;
      }
      /**
       * The divideScalar method
       *
       * @param value - The value value.
       */
      divideScalar(value) {
          this.normal.scaleInPlace(1 / value);
          this.w /= value;
      }
      /**
       * Calculates the distance from a point to this plane.
       *
       * @param point - The point value.
       * @return - The return value.
       */
      distanceToPoint(point) {
          return point.dot(this.normal) + this.w;
      }
      /**
       * Normalize this plane in place modifying its values.
       */
      normalizeInPlace() {
          const inverseNormalLength = 1.0 / this.normal.length();
          this.normal.scaleInPlace(inverseNormalLength);
          this.w *= inverseNormalLength;
      }
      /**
       * Clones this plane and returns a new plane.
       *
       * @return - Returns a new plane.
       */
      clone() {
          return new PlaneType(this.normal.clone(), this.w);
      }
      // ///////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              normal: this.normal.toJSON(),
              w: this.w,
          };
      }
      fromJSON(json) {
          this.normal.fromJSON(json.normal);
          this.w = json.w;
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  /* eslint-disable new-cap */
  /**
   * Class representing a Frustum. Frustums are used to determine what
   * is inside the camera's field of view.
   * @private
   * */
  class Frustum {
      planes;
      /**
       * Create a Frustum
       * @param p0 - the p0 value.
       * @param p1 - the p1 value.
       * @param p2 - the p2 value.
       * @param p3 - the p3 value.
       * @param p4 - the p4 value.
       * @param p5 - the p5 value.
       */
      constructor(p0, p1, p2, p3, p4, p5) {
          this.planes = [
              p0 || new PlaneType(),
              p1 || new PlaneType(),
              p2 || new PlaneType(),
              p3 || new PlaneType(),
              p4 || new PlaneType(),
              p5 || new PlaneType(),
          ];
      }
      /**
       * The setFromMatrix configures a Frustum object using a matrix.
       * Typically the matrix is a model view projection matrix.
       * @param mat4 - The matrix to use.
       */
      setFromMatrix(mat4) {
          const m = mat4;
          const planes = this.planes;
          planes[0].set(m.m03 - m.m00, m.m13 - m.m10, m.m23 - m.m20, m.m33 - m.m30);
          planes[1].set(m.m03 + m.m00, m.m13 + m.m10, m.m23 + m.m20, m.m33 + m.m30);
          planes[2].set(m.m03 + m.m01, m.m13 + m.m11, m.m23 + m.m21, m.m33 + m.m31);
          planes[3].set(m.m03 - m.m01, m.m13 - m.m11, m.m23 - m.m21, m.m33 - m.m31);
          planes[4].set(m.m03 - m.m02, m.m13 - m.m12, m.m23 - m.m22, m.m33 - m.m32);
          planes[5].set(m.m03 + m.m02, m.m13 + m.m12, m.m23 + m.m22, m.m33 + m.m32);
          planes.forEach((plane) => plane.normalizeInPlace());
      }
      /**
       * Tests a box to see if it is entirely within the frustum.
       * @param box3 - The box to test.
       * @return - True if the frustum intersects the box.
       */
      intersectsBox(box3) {
          const p = new Vec3();
          const planes = this.planes;
          const { min, max } = box3;
          for (let i = 0; i < 6; i++) {
              const plane = planes[i];
              // corner at max distance
              p.x = plane.normal.x > 0 ? max.x : min.x;
              p.y = plane.normal.y > 0 ? max.y : min.y;
              p.z = plane.normal.z > 0 ? max.z : min.z;
              if (plane.distanceToPoint(p) < 0)
                  return false;
          }
          return true;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @return - The json object.
       */
      toJSON() {
          return {
              p0: this.planes[0].toJSON(),
              p1: this.planes[1].toJSON(),
              p2: this.planes[2].toJSON(),
              p3: this.planes[3].toJSON(),
              p4: this.planes[4].toJSON(),
              p5: this.planes[5].toJSON(),
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object.
       */
      fromJSON(j) {
          this.planes[0].fromJSON(j.p0);
          this.planes[1].fromJSON(j.p1);
          this.planes[2].fromJSON(j.p2);
          this.planes[3].fromJSON(j.p3);
          this.planes[4].fromJSON(j.p4);
          this.planes[5].fromJSON(j.p5);
      }
      /**
       * Calls `toJSON` method and stringifies it.
       *
       * @return - The return value.
       */
      toString() {
          return StringFunctions.stringifyJSONWithFixedPrecision(this.toJSON());
      }
  }

  let counter = 0;
  /** Class representing a ref counted object. RefCounted
   *  objects track ownership and allow explicit cleanup
   *  of resources. This is necessary when JavaScript
   *  objects own references to GPU resources that need to
   *  be cleaned up when the JavaScript object is destroyed.
   * @private
   */
  class RefCounted extends EventEmitter {
      __refs;
      __destroyed;
      /**
       * Create a ref counted object.
       */
      constructor() {
          super();
          if (this.constructor.name == 'RefCounted') {
              throw new Error('RefCounted should not be instantiated directly.');
          }
          this.__id = ++counter;
          this.__refs = [];
          this.__destroyed = false;
      }
      /**
       * Returns the unique id of the object. Every Object has a unique
       * identifier which is based on a counter that is incremented.
       * @return - The return value.
       */
      getId() {
          return this.__id;
      }
      /**
       * The numRefs method.
       * @return - The return value.
       */
      numRefs() {
          return this.__refs.length;
      }
      /**
       * The addRef method.
       * @param referer - The referer value.
       * @return - The return value.
       */
      addRef(referer) {
          if (!referer)
              throw new Error('Error in RefCounted.addRef: Must provide a referer');
          // Note: an object can be reffeed multiple times.
          // e.g. we can create a temporary ref while we re-attach a tree item to a new parent.
          this.__refs.push(referer);
          return true;
      }
      /**
       * The removeRef method.
       * @param referer - The referer value.
       */
      removeRef(referer) {
          if (!referer)
              throw new Error('Error in RefCounted.removeRef: Must provide a referer');
          const index = this.__refs.indexOf(referer);
          if (index == -1)
              throw new Error('Error in RefCounted.removeRef: referer not found in refs list.');
          this.__refs.splice(index, 1);
          if (this.__refs.length == 0) {
              this.destroy();
          }
      }
      /**
       * The getRefer method.
       * @param index - The index value.
       * @return - The return value.
       */
      getRefer(index) {
          return this.__refs[index];
      }
      /**
       * The getRefIndex method.
       * @param referer - The referer value.
       * @return - The return value.
       */
      getRefIndex(referer) {
          return this.__refs.indexOf(referer);
      }
      /**
       * Returns true if this object has already been destroyed.
       * @return - Returns true or false.
       */
      isDestroyed() {
          return this.__destroyed;
      }
      /**
       * The destroy method is invoked when the last owner
       * is removed from a RefCounted object. Derived objects can
       * override this method to perform explicit cleanup.
       * The destructing signal is triggered so observers can
       * respond to this objects destruction.
       */
      destroy() {
          this.__destroyed = true;
          // console.log(this.constructor.name + " destructing");
          //  Note: PoTree listens to the 'destructing' event.
          this.emit('destructing');
      }
  }

  let numBaseItems = 0;
  /**
   * Base class for Items in the scene. It can be parameterized and can emit events.
   *
   * **Events**
   * * **nameChanged:** Emitted every time the Item's name is change. mostly in `setName` method.
   * * **selectedChanged:** Emitted `selected` status changes, mostly in `setSelected` method.
   *
   * @extends {EventEmitter}
   */
  class BaseItem extends EventEmitter {
      __name;
      __ownerItem = undefined;
      __selectable = true;
      __selected = false;
      __metaData = {};
      /**
       * Create a base item by defining its name.
       *
       * @param name - The name of the base item.
       */
      constructor(name = '') {
          super();
          this.__name = name;
          numBaseItems++;
      }
      // ////////////////////////////////////////
      // Static Methods
      /**
       * The getNumBaseItems method returns the total number of base items created.
       * This method is used in debugging memory consumption.
       *
       * @return - Returns the total number of base items created.
       */
      static getNumBaseItems() {
          return numBaseItems;
      }
      // ////////////////////////////////////////
      // Name and Path
      /**
       * Returns the name of the base item.
       *
       * @return - Returns the base item name.
       */
      get name() {
          return this.getName();
      }
      /**
       * Sets the name of the base item(Updates path).
       *
       * @emits `nameChanged` with `newName` and `oldName` data.
       * @param name - The base item name.
       */
      set name(value) {
          this.setName(value);
      }
      /**
       * Returns the current path of the item in the tree as an array of names.
       *
       * @return - Returns an array.
       */
      get path() {
          return this.getPath();
      }
      /**
       * Returns the name of the base item.
       *
       * @return - Returns the base item name.
       */
      getName() {
          return this.__name;
      }
      /**
       * Sets the name of the base item(Updates path).
       *
       * @emits `nameChanged` with `newName` and `oldName` data.
       * @param name - The base item name.
       */
      setName(name) {
          if (this.__name != name) {
              const oldName = this.__name;
              this.__name = name;
              const event = new NameChangedEvent(oldName, name);
              this.emit('nameChanged', event);
          }
      }
      /**
       * Returns the current path of the item in the tree as an array of names.
       *
       * @return - Returns an array.
       */
      getPath() {
          if (this.__ownerItem == undefined)
              return [this.__name];
          return [...this.__ownerItem.getPath(), this.__name];
      }
      // Path Traversal
      /**
       * The resolvePath method traverses the subtree from this item down
       * matching each name in the path with a child until it reaches the
       * end of the path.
       *
       * @param path - The path value.
       * @param index - The index value.
       * @return - The return value.
       */
      resolvePath(path, index = 0) {
          if (index == 0) {
              if (path[0] == '.' || path[0] == this.__name)
                  index++;
          }
          if (path[index] == '..') {
              if (this.__ownerItem) {
                  return this.__ownerItem.resolvePath(path, index + 1);
              }
              else {
                  throw Error('this.__ownerItem is undefined');
              }
          }
          if (index == path.length) {
              return this;
          }
      }
      // ////////////////////////////////////////
      // Owner Item
      /**
       * The getOwner method returns the current owner of the item.
       * The item is a child of the current owner.
       *
       * @return - Returns the current owner.
       */
      getOwner() {
          return this.__ownerItem;
      }
      /**
       * The setOwner method assigns a new owner to the item.
       *
       * @param ownerItem - The new owner item.
       */
      setOwner(ownerItem) {
          this.__ownerItem = ownerItem;
      }
      // ////////////////////////////////////////
      // Selectability and Selection
      /**
       * Returns a boolean indicating if this item is selectable.
       *
       * @return - Returns a boolean indicating if the item is selectable.
       */
      isSelectable() {
          return this.__selectable;
      }
      /**
       * Modifies the selectability of this item.
       *
       * @param val - A boolean indicating the selectability of the item.
       * @return - Returns true if value changed.
       */
      setSelectable(val) {
          if (this.__selectable != val) {
              this.__selectable = val;
              let event = new SelectabilityChangedEvent(this.__selectable);
              this.emit('selectabilityChanged', event);
              return true;
          }
          return false;
      }
      /**
       * The isSelected method.
       * @return - The return value.
       */
      isSelected() {
          return this.__selected;
      }
      /**
       * Changes the current state of the selection of this item.
       *
       * @emits `selectedChanged` with selected state
       * @param sel - Boolean indicating the new selection state.
       */
      setSelected(sel) {
          this.__selected = sel;
          let event = new SelectedEvent(this.__selected);
          this.emit('selectedChanged', event);
      }
      // ////////////////////////////////////////
      // Metadata
      /**
       * Gets Item's meta-data value by passing the `key` string.
       *
       * @param key - The key value under which to check for metadata.
       * @return - Returns the metadata associated with the given key.
       */
      getMetadata(key) {
          return this.__metaData[key];
      }
      /**
       * Checks to see if there is metadata for a given key.
       *
       * @param key - The key value under which to check for metadata.
       * @return - Returns `true` if metadata exists under the given key, otherwise returns `false`.
       */
      hasMetadata(key) {
          return key in this.__metaData;
      }
      /**
       * Assigns metadata to a given key.
       *
       * @param key - The key value under which the metadata is is going to be saved.
       * @param metaData - The metaData value.
       */
      setMetadata(key, metaData) {
          this.__metaData[key] = metaData;
      }
      /**
       * Removes metadata for a given key.
       *
       * @param key - The key value.
       */
      deleteMetadata(key) {
          delete this.__metaData[key];
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Encodes the current object as a json object.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = {
              type: this.getClassName(),
              name: this.__name,
          };
          return json;
      }
      /**
       * Decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          if (json.name)
              this.__name = json.name;
      }
      /**
       * Sets state of current Item(Including parameters) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          // read the type, but don't use it. This line must not be removed.
          // as the binary pointer is incremented.
          /*const type = */ reader.loadStr();
          this.setName(reader.loadStr());
      }
      /**
       * Converts object's JSON value and converts it to a string.
       * @param context
       * @return - String of object's parameter list state.
       */
      toString(context) {
          return JSON.stringify(this.toJSON(), null, 2);
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * Clones this base item and returns a new base item.
       *
       * **Note:** Each class should implement clone to be clonable.
       * @param context - The context value.
       */
      clone(context) {
          throw new Error(this.constructor.name + ' does not implement its clone method');
      }
      /**
       * When a BaseItem is cloned, initially the constructor is
       * called to generate a new instance. This instance then copies
       * its values from the source using this method.
       * This method copies any relevant data from the source object to
       * ensure that it represents a valid clone.
       * Derived classes override this method to copy any relevant
       * data from the source object.
       *
       * @param src - The BaseItem to copy from.
       * @param context - The context value
       */
      copyFrom(src, context) {
          this.setName(src.getName());
          this.setSelectable(src.isSelectable());
      }
  }

  /**
   * Class that allows other classes to be parameterized by `Parameter` type of objects.
   * Not only hosting parameters, but their events.
   *
   * @extends {BaseItem}
   */
  class ParameterOwner extends BaseItem {
      paramEventListenerIDs = {};
      paramMapping = {};
      params = [];
      deprecatedParamMapping = {};
      /**
       * Creates an instance of ParameterOwner by initializing parameter hosting mappings and events.
       *
       * Every Object has a unique identifier which is based on a counter that is incremented.
       */
      constructor(name) {
          super(name);
      }
      /**
       * Returns the number of parameters current object has.
       */
      getNumParameters() {
          return this.params.length;
      }
      /**
       * Returns the number of parameters current object has.
       */
      get numParameters() {
          return this.params.length;
      }
      /**
       * Returns all the parameters of the object.
       *
       * @return - Parameter List
       */
      getParameters() {
          return this.params;
      }
      /**
       * Returns the index of a parameter in parameter list.
       *
       * @param paramName - Name of the parameter.
       * @return - Position in the array
       */
      getParameterIndex(paramName) {
          return this.paramMapping[paramName];
      }
      /**
       * Returns `Parameter` object in a given index
       *
       * @param index - Position of the parameter in the array
       * @return - Parameter object value
       */
      getParameterByIndex(index) {
          return this.params[index];
      }
      /**
       * Validates if the specified parameter exists in the object.
       *
       * @param paramName - The parameter name.
       * @return - The return value.
       */
      hasParameter(paramName) {
          return paramName in this.paramMapping;
      }
      /**
       * Add a mapping from one name to a new parameter.
       * This is used to handle migrating parameters to new names.
       *
       * @param key - The parameter name.
       * @param paramName - The parameter name.
       * @return - The return value.
       */
      addParameterDeprecationMapping(key, paramName) {
          this.deprecatedParamMapping[key] = paramName;
      }
      /**
       * Returns `Parameter` object using the given name
       *
       * @param paramName - The parameter name.
       * @return - Parameter object value
       */
      getParameter(paramName) {
          let index = this.paramMapping[paramName];
          if (index == undefined) {
              const newParamName = this.deprecatedParamMapping[paramName];
              if (!newParamName) {
                  // TODO: Should this method not return null?
                  return null;
                  // throw Error(`No Parameter with that name exists: ${paramName} `)
              }
              else {
                  console.warn(`Parameter name ${paramName} is now deprecated. Please use ${newParamName} instead.`);
                  index = this.paramMapping[newParamName];
              }
          }
          return this.params[index];
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       * @param event - The event object emitted by the parameter.
       * @private
       */
      parameterValueChanged(event) {
          this.emit('parameterValueChanged', event);
      }
      /**
       * Adds `Parameter` object to the owner's parameter list.
       *
       * @emits `parameterAdded` with the name of the param.
       * @param param - The parameter to add.
       * @return - With `owner` and `valueChanged` event set.
       */
      addParameter(param) {
          return this.insertParameter(param, this.params.length);
      }
      /**
       * Adds `Parameter` object to the owner's parameter list using the index.
       * It replaces the event in the specified index.
       *
       *
       * @emits `parameterAdded` with the name of the param.
       * @param param - The parameter to insert.
       * @param index - The index value.
       * @return - With `owner` and `valueChanged` event set.
       */
      insertParameter(param, index) {
          const name = param.getName();
          if (this.paramMapping[name] != undefined) {
              console.warn('Replacing Parameter:' + name);
              this.removeParameter(name);
          }
          param.setOwner(this);
          this.paramEventListenerIDs[name] = param.on('valueChanged', (event) => {
              // Note: spread operators cause errors on iOS 11.
              const newEvent = { param };
              for (const key in event)
                  newEvent[key] = event[key];
              this.parameterValueChanged(newEvent);
          });
          this.params.splice(index, 0, param);
          for (let i = index; i < this.params.length; i++) {
              this.paramMapping[this.params[i].getName()] = i;
          }
          const event = new ParameterAddedEvent(name);
          this.emit('parameterAdded', event);
          return param;
      }
      /**
       * Removes `Parameter` from owner, by using parameter's name.
       * @emits `parameterRemoved` with the name of the param.
       * @param name - The parameter name.
       */
      removeParameter(name) {
          if (this.paramMapping[name] == undefined) {
              throw new Error('Unable to remove Parameter:' + name);
          }
          const index = this.paramMapping[name];
          const param = this.params[this.paramMapping[name]];
          param.off('valueChanged', this.paramEventListenerIDs[name]);
          this.params.splice(index, 1);
          delete this.paramMapping[name];
          for (let i = index; i < this.params.length; i++) {
              this.paramMapping[this.params[i].getName()] = i;
          }
          const event = new ParameterRemovedEvent(name);
          this.emit('parameterRemoved', event);
      }
      /**
       * Replaces old `Parameter` by passing a new one with the same name.
       *
       * @param param - The parameter to replace.
       * @return - `Parameter` with `valueChanged` event set.
       */
      replaceParameter(param) {
          const name = param.getName();
          if (this.paramMapping[name] == undefined) {
              throw new Error('Unable to replace Parameter:' + name);
          }
          const index = this.paramMapping[name];
          this.removeParameter(name);
          this.insertParameter(param, index);
          return param;
      }
      /**
       * The resolvePath method traverses the subtree from this item down
       * matching each name in the path with a child until it reaches the
       * end of the path.
       *
       * @param path - The path value.
       * @param index - The index value.
       * @return - The return value.
       */
      resolvePath(path, index = 0) {
          if (index == 0) {
              if (path[0] == '.' || path[0] == this.__name)
                  index++;
          }
          if (path[index] == '..') {
              if (this.__ownerItem) {
                  return this.__ownerItem.resolvePath(path, index + 1);
              }
              else {
                  throw Error('this.__ownerItem is undefined');
              }
          }
          if (index == path.length) {
              return this;
          }
          // Maybe the name is a parameter name.
          const param = this.getParameter(path[index]);
          if (param) {
              if (index < path.length) {
                  return param.resolvePath(path, index + 1);
              }
              return param;
          }
          throw new Error(`Unable to resolve path : [${path.toString()}] after: ${this.getName()} \nNo child or parameter called : "${path[index]}"`);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = super.toJSON(context);
          const paramsJSON = {};
          let savedParams = 0;
          for (const param of this.params) {
              if (param.isDrivenByOperator())
                  continue;
              const paramJSON = param.toJSON(context);
              if (paramJSON) {
                  paramsJSON[param.getName()] = paramJSON;
                  savedParams++;
              }
          }
          if (savedParams > 0)
              json.params = paramsJSON;
          return json;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          super.fromJSON(json, context);
          if (json.params) {
              for (const key in json.params) {
                  const pj = json.params[key];
                  if (pj.paramPath) {
                      context?.resolvePath(pj.paramPath, (param) => {
                          this.replaceParameter(param);
                      }, () => {
                          console.warn('Unable to resolve shared parameter:' + pj.paramPath);
                      });
                  }
                  else {
                      let param = this.getParameter(key);
                      if (!param && pj.type && pj.name) {
                          param = Registry.constructClass(pj.type);
                          if (!param) {
                              console.error('Unable to construct prop:' + pj.name + ' of type:' + pj.type);
                              continue;
                          }
                          param.setName(pj.name);
                          this.addParameter(param);
                      }
                      if (param)
                          param.fromJSON(pj, context);
                  }
              }
          }
      }
      /**
       * Uses passed in BinReader object(containing an Int32 array with all the parameters) to reconstruct all parameters state.
       *
       * In each iteration of the array, propType and propName are extracted and
       * used to build the right `Parameter` class. Then all of them are added to the object.
       *
       * @emits `parameterAdded` with the name of the param.
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          this.readBinaryParams(reader, context);
      }
      readBinaryParams(reader, context) {
          if (context?.versions['zea-engine'].compare([0, 0, 3]) >= 0) {
              const numProps = reader.loadUInt32();
              for (let i = 0; i < numProps; i++) {
                  const propType = reader.loadStr();
                  const propName = reader.loadStr();
                  let param = this.getParameter(propName);
                  if (!param) {
                      param = Registry.constructClass(propType);
                      if (!param) {
                          console.error('Unable to construct prop:' + propName + ' of type:' + propType);
                          continue;
                      }
                      param.setName(propName);
                      this.addParameter(param);
                  }
                  param.readBinary(reader, context);
              }
          }
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * Clones this base item and returns a new base item.
       *
       * **Note:** Each class should implement clone to be clonable.
       * @param context - The context value.
       */
      clone(context) {
          throw new Error(this.constructor.name + ' does not implement its clone method');
      }
      /**
       * Copies Parameters from another `ParameterOwner` to current object.
       *
       * @param src - The ParameterOwner copy from.
       * @param context - The context value
       */
      copyFrom(src, context) {
          super.copyFrom(src, context);
          // Note: Loop over the parameters in reverse order,
          // this is because often, parameter dependencies
          // are bottom to top (bottom params dependent on higher params).
          // This means that as a parameter is set with a new value
          // it will dirty the params below it.
          let i = src.getNumParameters();
          while (i--) {
              const srcParam = src.getParameterByIndex(i);
              const param = this.getParameter(srcParam.getName());
              if (param) {
                  // Note: we are not cloning the values.
                  param.copyFrom(srcParam);
              }
              else {
                  this.addParameter(srcParam.clone());
              }
          }
      }
  }

  const getFileFolder = function (filePath) {
      return filePath.substring(0, filePath.lastIndexOf('/')) + '/';
  };
  const loadFile = function (url, responseType, onSucceed, onFail, onProgress = undefined) {
      try {
          const xhr = new XMLHttpRequest();
          xhr.responseType = responseType;
          xhr.addEventListener('timeout', (event) => {
              throw new Error('The request for ' + url + ' timed out.');
          });
          xhr.addEventListener('error', (event) => {
              throw new Error('The request for ' + url + ': xhr.readyState:' + xhr.readyState);
              onFail(xhr.statusText);
          });
          xhr.addEventListener('abort', (event) => {
              throw new Error('The request for ' + url + ': xhr.readyState:' + xhr.readyState);
              onFail(xhr.statusText);
          });
          xhr.addEventListener('progress', (event) => {
              if (onProgress)
                  onProgress(event.total, event.loaded);
          });
          xhr.addEventListener('loadend', (event) => {
              if (xhr.status == 200)
                  onSucceed(xhr);
              else
                  onFail(xhr.statusText);
          });
          xhr.open('GET', url, true);
          xhr.send();
          // xhr.open();
      }
      catch (err) {
          onFail(err);
      }
  };
  const loadTextfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
      loadFile(url, 'text', (xhr) => {
          onSucceed(xhr.responseText);
      }, (statusText) => {
          if (onFail != undefined)
              onFail(statusText);
          else {
              throw new Error('Unable to XHR File:' + url);
          }
      }, onProgress);
  };
  const loadJSONfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
      loadFile(url, 'json', (xhr) => {
          onSucceed(xhr.response, xhr);
      }, (statusText) => {
          if (onFail != undefined)
              onFail(statusText);
          else {
              throw new Error('Unable to XHR File:' + url);
          }
      }, onProgress);
  };
  const loadXMLfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
      loadFile(url, 'document', (xhr) => {
          onSucceed(xhr.responseXML);
      }, (statusText) => {
          if (onFail != undefined)
              onFail(statusText);
          else {
              throw new Error('Unable to XHR File:' + url);
          }
      }, onProgress);
  };
  const loadBinfile = function (url, onSucceed, onFail = undefined, onProgress = undefined) {
      loadFile(url, 'arraybuffer', (xhr) => {
          onSucceed(xhr.response);
      }, (statusText) => {
          if (onFail != undefined)
              onFail(statusText);
          else {
              throw new Error('Unable to XHR File:' + url);
          }
      }, onProgress);
  };

  var unpackBase64Str = "AGFzbQEAAAABrgIlYAF/AX5gA39/fwF/YAN/fn8AYAR/f39/AX9gAn9/AX9gAAF/YAJ/fwBgA39/fwBgAABgAX8Bf2AEf39/fwBgBn9/f39/fwBgBX9/f39/AGACf38BfGAFf39/f38Bf2AGf39/f39/AX9gCX9/f39/f39/fwF/YAh/f39/f35/fwF/YAJ+fgF/YAF/AGADf398AGAJf39/f39/f39/AGAKf39/f39/f39/fwBgAn9+AGAHf39/f39/fwF/YAp/f39/f39/f39/AX9gB39/f39/f38AYAt/f39/f39/f39/fwBgDX9/f39/f39/f39/f38AYAh/f39/f39/fwBgA39+fwF/YAN+f38Bf2ACfn8Bf2AGf3x/f39/AX9gAnx/AXxgA39/fwF8YAR/f398AAKID1cDZW52Bm1lbW9yeQIAgAIDZW52BXRhYmxlAXABvAK8AgNlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYIU1RBQ0tUT1ADfwADZW52BWFib3J0ABMDZW52DWVubGFyZ2VNZW1vcnkABQNlbnYOZ2V0VG90YWxNZW1vcnkABQNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkABQNlbnYIaW52b2tlX2kACQNlbnYJaW52b2tlX2lpAAQDZW52Cmludm9rZV9paWkAAQNlbnYLaW52b2tlX2lpaWkAAwNlbnYMaW52b2tlX2lpaWlpAA4DZW52Dmludm9rZV9paWlpaWlpABgDZW52EWludm9rZV9paWlpaWlpaWlpABkDZW52CGludm9rZV92ABMDZW52CWludm9rZV92aQAGA2VudgppbnZva2VfdmlpAAcDZW52C2ludm9rZV92aWlpAAoDZW52DGludm9rZV92aWlpaQAMA2Vudg1pbnZva2VfdmlpaWlpAAsDZW52Dmludm9rZV92aWlpaWlpABoDZW52EWludm9rZV92aWlpaWlpaWlpABYDZW52Emludm9rZV92aWlpaWlpaWlpaQAbA2VudhlfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAkDZW52El9fX2N4YV9iZWdpbl9jYXRjaAAJA2VudhBfX19jeGFfZW5kX2NhdGNoAAgDZW52HF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIABQNlbnYcX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMwAJA2VudhxfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF80AAQDZW52FV9fX2N4YV9mcmVlX2V4Y2VwdGlvbgATA2VudgxfX19jeGFfdGhyb3cABwNlbnYHX19fbG9jawATA2VudgtfX19tYXBfZmlsZQAEA2VudhJfX19yZXN1bWVFeGNlcHRpb24AEwNlbnYLX19fc2V0RXJyTm8AEwNlbnYNX19fc3lzY2FsbDE0MAAEA2Vudg1fX19zeXNjYWxsMTQ1AAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYNX19fc3lzY2FsbDE4MwAEA2Vudg1fX19zeXNjYWxsMTk4AAQDZW52DF9fX3N5c2NhbGwyMAAEA2VudgtfX19zeXNjYWxsNgAEA2VudgxfX19zeXNjYWxsNjAABANlbnYMX19fc3lzY2FsbDgzAAQDZW52DF9fX3N5c2NhbGw5MQAEA2VudglfX191bmxvY2sAEwNlbnYeX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0ABMDZW52Fl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wADANlbnYXX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAHANlbnYjX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IACwNlbnYgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24AHQNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwABgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABwNlbnYZX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgAMA2Vudh1fX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwAHA2VudhxfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAYDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAcDZW52Hl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdAALA2VudiRfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQAFgNlbnYWX19lbWJpbmRfcmVnaXN0ZXJfdm9pZAAGA2VudgZfYWJvcnQACANlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwABA2VudgdfZ2V0ZW52AAkDZW52CV9nZXRncm5hbQAJA2VudglfZ2V0cHduYW0ACQNlbnYIX2pzQ2xvc2UAEwNlbnYJX2pzQ3JlYXRlAAkDZW52B19qc09wZW4ACQNlbnYHX2pzUmVhZAABA2VudgdfanNTZWVrAAEDZW52CF9qc1dyaXRlAAEDZW52E19sbHZtX2VoX3R5cGVpZF9mb3IACQNlbnYKX2xvY2FsdGltZQAJA2VudgdfbWt0aW1lAAkDZW52FF9wdGhyZWFkX2dldHNwZWNpZmljAAkDZW52E19wdGhyZWFkX2tleV9jcmVhdGUABANlbnYNX3B0aHJlYWRfb25jZQAEA2VudhRfcHRocmVhZF9zZXRzcGVjaWZpYwAEA2VudgVfdGltZQAJA2VudhBpbnZva2VfaWlpaWlpamlpABkDZW52Cmludm9rZV9pamoADgNlbnYJaW52b2tlX2ppAAQDZW52Cmludm9rZV92aWoACgNlbnYLaW52b2tlX3ZpamkADANlbnYHX2pzVGVsbAAJA4QEggQTAQEGEwQJCRMGEwEBCQcAEwcGBwwJCgEEAQkGCQETCQkEBAQHBAETAQEJBxMHAwkGBhMIBgkTARMEBBMTAQEBIAkJExMGEwEDCQIEEwcEExMKBgEJDAsIBAwEBAEEBAcJBwkDChMGEAERDAAFCwwKBwMBBwEEBgEJAQEOAQkEABMAAQYHBBMTAQkTEwYTBhMJCgYMCgEABwcGBAcTBAQEAhcKDwQHBwoBExMTBQEDBAcJDgQECQEBAwQJASIJAQQJBAkGCQEBBwQHBBMBCQ4JBgMBEwYTAQwBBwcHBhMXBhMHBhMTEwkPBAkTEwQGFR0MBgYGBwkTCQkJAQEJAQAJBAoTCQkJEwYGBBMEAAIBARMMCgQOGRYVCBQSERIGEA4BDRsWGgsMCiQHBhMZGA8OAwEEIwkBCgwLBwETCQkIEwYICgwLCgwLAQgEBh0BAQkEBh0EBgYGCQMEBAEEAQEBAQEEBAQJAwMHBAEhIB8DAwQBBAQBBAkBBQEBCQQJEwgECQEEHhMDFA0FCgUHBBMFAQcEBg4MBRMJEwcIAwYPExMTBgcHBgMEAQYBBgMJCQYTBAYTBhMEBgQTARMTBh4GFw8BBwkDBgQDBwcBBAQGBgYBCQkGEwYGAwcTEwoTBhMTBwoGEwcGBwYTBwcTFQcHExMTBgkGBgQLEwQJBAMBEwgJBhoFfwEjAQt/ASMCC38BQQALfwFBAAt/AUEACweXBSUYX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwANEDGl9fR0xPQkFMX19zdWJfSV9icmlkZ2VfY3BwAO0DF19fR0xPQkFMX19zdWJfSV9jcmNfY3BwANIEGl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwAOoCEF9fX2N4YV9jYW5fY2F0Y2gAhwMWX19fY3hhX2lzX3BvaW50ZXJfdHlwZQCGAxFfX19lcnJub19sb2NhdGlvbgDKAw5fX19nZXRUeXBlTmFtZQDPAwVfZnJlZQBSB19tYWxsb2MAbAtkeW5DYWxsX2RpaQCFAwlkeW5DYWxsX2kAnwIKZHluQ2FsbF9paQCEAwtkeW5DYWxsX2lpaQCDAwxkeW5DYWxsX2lpaWkAggMNZHluQ2FsbF9paWlpaQCBAw5keW5DYWxsX2lpaWlpaQCAAw9keW5DYWxsX2lpaWlpaWkA/wISZHluQ2FsbF9paWlpaWlpaWlpAP4CEWR5bkNhbGxfaWlpaWlpamlpAOcCC2R5bkNhbGxfaWpqAOYCCmR5bkNhbGxfamkA5QIJZHluQ2FsbF92AP0CCmR5bkNhbGxfdmkA/AILZHluQ2FsbF92aWkA+wIMZHluQ2FsbF92aWlkAPoCDGR5bkNhbGxfdmlpaQD5Ag1keW5DYWxsX3ZpaWlpAPgCDmR5bkNhbGxfdmlpaWlpAPcCD2R5bkNhbGxfdmlpaWlpaQD2AhJkeW5DYWxsX3ZpaWlpaWlpaWkA9QITZHluQ2FsbF92aWlpaWlpaWlpaQD0AgtkeW5DYWxsX3ZpagDkAgxkeW5DYWxsX3ZpamkA4wILc2V0VGVtcFJldDAA3AIIc2V0VGhyZXcA7wIKc3RhY2tBbGxvYwDTBAnKBAEAIwALvALzAtoDvgHoA+ED3QPbA/4BvgG+AYEBzQOPA44DX8YEfKkD0wOlBM0EuwKmAcoCywK4ApYC0QKWArIBcVjqA58CxwKBAYEBgQGBAYEBgQGBAaoB8QHdAu8BvgJqc5kE0gLbAs4E8AHMBLoCyQTSA9UD5APXAd8DnAKaAtcBnAKaAtcBuwOi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DiAAQThqIQ8gAEGQAWohECAAQfAAaiELIABBzABqIREgAEEIaiESIABBBGohDAJAAkADQCAERQRAIAMhAgwCCyANKAIAIQcgACwAAARAIAEgEigCACAMKAIAEFMaIAwoAgAhAiAMQQA2AgAFIAopAwAiEyAErVMhCCATpyECIAgEfyACBSAEIgILBEAgDiwAAARAIAksAAAEQCACIAIgBmpBD3FrIgNBAEoEQCADIQILIAhFBEAgBCECCwsLIAcoAgRFDQQgByAFIAIgBygCACgCDEEfcUHKAGoRAQAhAiAHQbCnAWohCCAPKAIAIgMEfyADBSAIC0GJwQBqLAAABEAgECAFIAIQqwILBSADIQILCyALIAspAwAgAqwiE3w3AwAgAiAGaiEGIAogCikDACATfSITNwMAIBNCAFEgDiwAAEEAR3FFDQEgAgRAIAZBD3FFIAksAABFcg0CCyAFIAJqIQUgBCACayEEIAcgAEEBIBEoAgAQtQEEQCACIQMMAQsLIABBAToAUkF/DwsgDSgCACIDBEAgCykDACADQYi8A2opAwB8IRQgACwAKARAIAApA1ghFSAAKQOIASITQgBRBEAgFSETBSAAKQOAASAUfCEUCyADQazzAGooAgAhAyATIBRTBH9B5AAFIBNCAFEEf0EABSAUQuQAfiATf6cLCyEFIANBzIQDaiwAAEUEQCAFIABByABqIgMoAgBHBEAgAyAFNgIACwsLCyACQX9GBEBBfyEGBSAJLAAABEAgACgCRCABIAYQ6gELCxCFASAGDwtBfwtiAQF/IABFBEBBASEACwJAAkACQANAIAAQbCIBDQJBsLwDQbC8AygCACIBNgIAIAFFDQEgAUEHcUGOAWoRCAAMAAsAC0EEEBQiAEHEJTYCACAAQdgKQQoQGwwBCyABDwtBAAtTAQF/IwQhACMEQeAgaiQEIABBgCBqIgMgAjYCACAAQYAIIAEgAxCAAhogAEGQIGoiAUEANgJEIAFBATYCSCABQUBrQQE2AgAgASAANgIAIAAkBAt6AgV/AX4gAEEYaiIDKAIAIgEgACgCFCIETwRAQgAPCyAAKAIAIQUgASEAAkADQCADIABBAWoiATYCACAFIABqLQAAIgBB/wBxrSACrYYgBnwhBiAAQYABcUUNASACQQdqIQIgASAESQRAIAEhAAwBBUIAIQYLCwsgBgsGAEENEAALGAAgACgCAEEgcUUEQCABIAIgABCNAhoLC+4CAQF/AkACQAJAAkACQCABQQFrDv8BAAIBAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwsgACgCAEUEQCAAIAE2AgALDAMLIAAoAgBBC0cEQCAAQQM2AgALDAILIAAoAgBBAkkEQCAAQQI2AgALDAELIAAgATYCAAsgAEEEaiICIAIoAgBBAWo2AgALrgIBAn8gACgCLEGs8wBqKAIAIgNBpMsEaigCAARAIANBsMsEaigCACIEBEBBASADQazLBGooAgAgASACIARBD3FB6gBqEQMAQX9GBEBBrPUCQf8BEKQBCwsgA0G4ywRqKAIAIgMEQCABIAIgA0EfcUEqahEEAEUEQEGs9QJB/wEQpAELCwsgACABNgIcIAAgAjYCGCAALAAMBEAgAEEQaiIDKAIAIAJPBEAgAEEUaiIEKAIAIAEgAhBTGiAEIAQoAgAgAmo2AgAgAyADKAIAIAJrNgIACwUgACwAKUUEQAJ/IAAoAjAhA0EBIAJFDQAaIAMoAgQgASACEEMLGgsLIABB+ABqIgMgAykDACACrXw3AwAgACwAKgRAEIUBDwsgAEGoAWogASACEKsCEIUBC4ABAQF/IwQhBSMEQYACaiQEIAIgA0ogBEGAwARxRXEEQCAFIAFBGHRBGHUgAiADayIBQYACSQR/IAEFQYACCxBUGiABQf8BSwRAIAIgA2shAgNAIAAgBUGAAhBjIAFBgH5qIgFB/wFLDQALIAJB/wFxIQELIAAgBSABEGMLIAUkBAsrACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyC40JARB/IwQhByMEQYABaiQEIAIgAzYCACAHQUBrIgRCADcCACAEQgA3AgggBEIANwIQIARCADcCGCAEQgA3AiAgBEIANwIoIARCADcCMCAEQgA3AjggA0UiEwR/IARBJGohECAEQShqIRFBAAVBACEAA0AgBCABIABqLAAAQQ9xQQJ0aiIFIAUoAgBBAWo2AgAgAEEBaiIAIANHDQALIARBJGoiACEQIARBKGoiCiERIAQoAgghBiAEKAIMIQggBCgCECEJIAQoAhQhCyAEKAIYIQwgBCgCHCENIAQoAiAhDiAAKAIAIRIgCigCACEKIAQoAgQLIQUgBEEANgIAIAJBiBlqQQAgA0EBdBBUGiACQcQAaiIAQQA2AgAgAkEANgIEIAIgBUEPdDYCCCACQQA2AkggAiAGIAVBAXRqIg9BDnQ2AgwgAiAFNgJMIAIgCCAPQQF0aiIPQQ10NgIQIAIgBiAFaiIFNgJQIAIgCSAPQQF0aiIGQQx0NgIUIAIgCCAFaiIFNgJUIAIgCyAGQQF0aiIGQQt0NgIYIAIgCSAFaiIFNgJYIAIgDCAGQQF0aiIGQQp0NgIcIAIgCyAFaiIFNgJcIAIgDSAGQQF0aiIGQQl0NgIgIAIgDCAFaiIFNgJgIAIgDiAGQQF0aiIGQQh0NgIkIAIgDSAFaiIFNgJkIAIgEiAGQQF0aiIGQQd0NgIoIAIgDiAFaiIFNgJoIAIgCiAGQQF0aiIGQQZ0NgIsIAIgECgCACAFaiIFNgJsIAIgBCgCLCIIIAZBAXRqIgZBBXQ2AjAgAiARKAIAIAVqIgU2AnAgAiAEKAIwIgkgBkEBdGoiBkEEdDYCNCACIAggBWoiBTYCdCACIAQoAjQiCCAGQQF0aiIGQQN0NgI4IAIgCSAFaiIFNgJ4IAIgBCgCOCIJIAZBAXRqIgZBAnQ2AjwgAiAIIAVqIgU2AnwgAkFAayAEKAI8IAZBAXRqQQF0NgIAIAIgCSAFajYCgAEgByAAKQIANwIAIAcgACkCCDcCCCAHIAApAhA3AhAgByAAKQIYNwIYIAcgACkCIDcCICAHIAApAig3AiggByAAKQIwNwIwIAcgACkCODcCOAJAAkAgEw0AQQAhAANAIAEgAGosAABBD3EiBARAIAJBiBlqIAcgBEECdGoiBCgCACIFQQF0aiAAOwEAIAQgBUEBajYCAAsgAEEBaiIAIANHDQALAkACQAJAIANBqgJrDgkAAAEBAQEBAQABC0EKIQQMAQsMAQsMAQtBByEECyACQYQBaiIFIAQ2AgBBASAEdCEGQQAhAUEBIQADQCABQRAgBGt0IQQCQCAAQRBJBEADQCAEIAJBBGogAEECdGooAgBJDQIgAEEBaiIAQRBJDQBBECEACwsLIAJBiAFqIAFqIAA6AAAgAkGICWogAUEBdGogBCACIABBAnRqKAIAa0EQIABrdiACQcQAaiAAQQJ0aigCAGoiBCADSQR/IAJBiBlqIARBAXRqLgEABUEACyIEOwEAIAFBAWoiASAGSQRAIAUoAgAhBAwBCwsgByQEC6cDAQZ/IwQhAyMEQRBqJAQgA0EIaiEEIAFBADoAAAJAIABB/v8DEHQEQEGsIygCACgCAAR/QQQFQQELIAJGBEBBASEEBUEBIQQDQAJAAkACQANAAkAgACAHQQJ0aigCACIFQf7/A0gNAiAFQf7/A2sNACAHQQFqIQcgBiACQawjKAIAKAIABH9BBAVBAQtrSQ0BDAgLCwwBCyAFRQ0BCyAHQQFqIQcgBUGAf3FBgMEDRgR/IAEgBmogBToAACAGQQFqBSADQgA3AwAgASAGaiIIIAUgAxCRAUF/RgRAQQAhBAsgA0IANwMAIAhBrCMoAgAoAgAEf0EEBUEBCyADEIgCIgVBAUoEfyAFBUEBCyAGagsiBiACQawjKAIAKAIABH9BBAVBAQtrSQ0BDAQLCyABIAZqQQA6AAALBSADQgA3AwAgBCAANgIAAn8CQAJAAkAgASAEIAIgAxC4A0F/aw4CAAECC0EADAILIAAoAgBFDAELQQELIQQLCyACRQRAIAMkBCAEQf8BcUEARw8LIAEgAkF/ampBADoAACADJAQgBEH/AXFBAEcLNgEDfyAAIQIDQCABQQRqIQMgAkEEaiEEIAIgASgCACIBNgIAIAEEQCAEIQIgAyEBDAELCyAAC1ABAn8CfyACBH8DQCAALAAAIgMgASwAACIERgRAIABBAWohACABQQFqIQFBACACQX9qIgJFDQMaDAELCyADQf8BcSAEQf8BcWsFQQALCyIAC443AQx/AkACQAJAIwQhASMEQRBqJAQgASEKAkAgAEH1AUkEQCAAQQtqQXhxIQJBwLcDKAIAIgYgAEELSQR/QRAiAgUgAgtBA3YiAHYiAUEDcQRAIAFBAXFBAXMgAGoiAEEDdEHotwNqIgFBCGoiBSgCACICQQhqIgQoAgAiAyABRgRAQcC3AyAGQQEgAHRBf3NxNgIABSADIAE2AgwgBSADNgIACyACIABBA3QiAEEDcjYCBCACIABqQQRqIgAgACgCAEEBcjYCACAKJAQgBA8LIAJByLcDKAIAIghLBEAgAQRAIAEgAHRBAiAAdCIAQQAgAGtycSIAQQAgAGtxQX9qIgFBDHZBEHEhACABIAB2IgFBBXZBCHEiAyAAciABIAN2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiIDQQN0Qei3A2oiAEEIaiIEKAIAIgFBCGoiBygCACIFIABGBEBBwLcDIAZBASADdEF/c3EiADYCAAUgBSAANgIMIAQgBTYCACAGIQALIAEgAkEDcjYCBCABIAJqIgQgA0EDdCIDIAJrIgVBAXI2AgQgASADaiAFNgIAIAgEQEHUtwMoAgAhAyAIQQN2IgJBA3RB6LcDaiEBIABBASACdCICcQR/IAFBCGoiAigCAAVBwLcDIAAgAnI2AgAgAUEIaiECIAELIQAgAiADNgIAIAAgAzYCDCADIAA2AgggAyABNgIMC0HItwMgBTYCAEHUtwMgBDYCACAKJAQgBw8LQcS3AygCACIMBEAgDEEAIAxrcUF/aiIBQQx2QRBxIQAgASAAdiIBQQV2QQhxIgMgAHIgASADdiIAQQJ2QQRxIgFyIAAgAXYiAEEBdkECcSIBciAAIAF2IgBBAXZBAXEiAXIgACABdmpBAnRB8LkDaigCACIDKAIEQXhxIAJrIQEgA0EQaiADKAIQRUECdGooAgAiAARAA0AgACgCBEF4cSACayIFIAFJIgQEQCAFIQELIAQEQCAAIQMLIABBEGogACgCEEVBAnRqKAIAIgANACABIQULBSABIQULIAMgAmoiCyADSwRAIAMoAhghCQJAIAMoAgwiACADRgRAIANBFGoiASgCACIARQRAIANBEGoiASgCACIARQRAQQAhAAwDCwsDQCAAQRRqIgQoAgAiBwRAIAchACAEIQEMAQsgAEEQaiIEKAIAIgcEQCAHIQAgBCEBDAELCyABQQA2AgAFIAMoAggiASAANgIMIAAgATYCCAsLAkAgCQRAIAMgAygCHCIBQQJ0QfC5A2oiBCgCAEYEQCAEIAA2AgAgAEUEQEHEtwMgDEEBIAF0QX9zcTYCAAwDCwUgCUEQaiAJKAIQIANHQQJ0aiAANgIAIABFDQILIAAgCTYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADKAIUIgEEQCAAIAE2AhQgASAANgIYCwsLIAVBEEkEQCADIAUgAmoiAEEDcjYCBCADIABqQQRqIgAgACgCAEEBcjYCAAUgAyACQQNyNgIEIAsgBUEBcjYCBCALIAVqIAU2AgAgCARAQdS3AygCACEEIAhBA3YiAUEDdEHotwNqIQAgBkEBIAF0IgFxBH8gAEEIaiICKAIABUHAtwMgBiABcjYCACAAQQhqIQIgAAshASACIAQ2AgAgASAENgIMIAQgATYCCCAEIAA2AgwLQci3AyAFNgIAQdS3AyALNgIACyAKJAQgA0EIag8FIAIhAAsFIAIhAAsFIAIhAAsFIABBv39LBEBBfyEABSAAQQtqIgBBeHEhA0HEtwMoAgAiBQRAIABBCHYiAAR/IANB////B0sEf0EfBSADQQ4gACAAQYD+P2pBEHZBCHEiAHQiAUGA4B9qQRB2QQRxIgIgAHIgASACdCIAQYCAD2pBEHZBAnEiAXJrIAAgAXRBD3ZqIgBBB2p2QQFxIABBAXRyCwVBAAshCEEAIANrIQICQAJAIAhBAnRB8LkDaigCACIABEBBGSAIQQF2ayEEQQAhASADIAhBH0YEf0EABSAEC3QhB0EAIQQDQCAAKAIEQXhxIANrIgYgAkkEQCAGBEAgACEBIAYhAgVBACECIAAhAQwECwsgACgCFCIGRSAGIABBEGogB0EfdkECdGooAgAiAEZyRQRAIAYhBAsgByAARSIGQQFzdCEHIAZFDQALBUEAIQELIAQgAXIEfyAEBSAFQQIgCHQiAEEAIABrcnEiAEUEQCADIQAMBwsgAEEAIABrcUF/aiIEQQx2QRBxIQBBACEBIAQgAHYiBEEFdkEIcSIHIAByIAQgB3YiAEECdkEEcSIEciAAIAR2IgBBAXZBAnEiBHIgACAEdiIAQQF2QQFxIgRyIAAgBHZqQQJ0QfC5A2ooAgALIgANACABIQQMAQsDQCAAKAIEQXhxIANrIgQgAkkiBwRAIAQhAgsgBwRAIAAhAQsgAEEQaiAAKAIQRUECdGooAgAiAA0AIAEhBAsLIAQEQCACQci3AygCACADa0kEQCAEIANqIgggBE0NBiAEKAIYIQkCQCAEKAIMIgAgBEYEQCAEQRRqIgEoAgAiAEUEQCAEQRBqIgEoAgAiAEUEQEEAIQAMAwsLA0AgAEEUaiIHKAIAIgYEQCAGIQAgByEBDAELIABBEGoiBygCACIGBEAgBiEAIAchAQwBCwsgAUEANgIABSAEKAIIIgEgADYCDCAAIAE2AggLCwJAIAkEQCAEIAQoAhwiAUECdEHwuQNqIgcoAgBGBEAgByAANgIAIABFBEBBxLcDIAVBASABdEF/c3EiADYCAAwDCwUgCUEQaiAJKAIQIARHQQJ0aiAANgIAIABFBEAgBSEADAMLCyAAIAk2AhggBCgCECIBBEAgACABNgIQIAEgADYCGAsgBCgCFCIBBEAgACABNgIUIAEgADYCGAsLIAUhAAsCQCACQRBJBEAgBCACIANqIgBBA3I2AgQgBCAAakEEaiIAIAAoAgBBAXI2AgAFIAQgA0EDcjYCBCAIIAJBAXI2AgQgCCACaiACNgIAIAJBA3YhASACQYACSQRAIAFBA3RB6LcDaiEAQcC3AygCACICQQEgAXQiAXEEfyAAQQhqIgIoAgAFQcC3AyACIAFyNgIAIABBCGohAiAACyEBIAIgCDYCACABIAg2AgwgCCABNgIIIAggADYCDAwCCyACQQh2IgEEfyACQf///wdLBH9BHwUgAkEOIAEgAUGA/j9qQRB2QQhxIgF0IgNBgOAfakEQdkEEcSIFIAFyIAMgBXQiAUGAgA9qQRB2QQJxIgNyayABIAN0QQ92aiIBQQdqdkEBcSABQQF0cgsFQQALIgFBAnRB8LkDaiEDIAggATYCHCAIQRBqIgVBADYCBCAFQQA2AgAgAEEBIAF0IgVxRQRAQcS3AyAAIAVyNgIAIAMgCDYCACAIIAM2AhggCCAINgIMIAggCDYCCAwCCyADKAIAIQBBGSABQQF2ayEDIAIgAUEfRgR/QQAFIAMLdCEBAkADQCAAKAIEQXhxIAJGDQEgAUEBdCEDIABBEGogAUEfdkECdGoiASgCACIFBEAgAyEBIAUhAAwBCwsgASAINgIAIAggADYCGCAIIAg2AgwgCCAINgIIDAILIABBCGoiASgCACICIAg2AgwgASAINgIAIAggAjYCCCAIIAA2AgwgCEEANgIYCwsgCiQEIARBCGoPBSADIQALBSADIQALBSADIQALCwsLQci3AygCACICIABPBEBB1LcDKAIAIQEgAiAAayIDQQ9LBEBB1LcDIAEgAGoiBTYCAEHItwMgAzYCACAFIANBAXI2AgQgASACaiADNgIAIAEgAEEDcjYCBAVByLcDQQA2AgBB1LcDQQA2AgAgASACQQNyNgIEIAEgAmpBBGoiACAAKAIAQQFyNgIACwwDC0HMtwMoAgAiAiAASwRAQcy3AyACIABrIgI2AgAMAgtBmLsDKAIABH9BoLsDKAIABUGguwNBgCA2AgBBnLsDQYAgNgIAQaS7A0F/NgIAQai7A0F/NgIAQay7A0EANgIAQfy6A0EANgIAQZi7AyAKQXBxQdiq1aoFczYCAEGAIAsiASAAQS9qIgRqIgdBACABayIGcSIFIABNDQBB+LoDKAIAIgEEQEHwugMoAgAiAyAFaiIIIANNIAggAUtyDQELIABBMGohCAJAAkBB/LoDKAIAQQRxBEBBACECBQJAAkACQEHYtwMoAgAiAUUNAEGAuwMhAwNAAkAgAygCACIJIAFNBEAgCSADQQRqIgkoAgBqIAFLDQELIAMoAggiAw0BDAILCyAHIAJrIAZxIgJB/////wdJBEAgAhCHASIBIAMoAgAgCSgCAGpGBEAgAUF/Rw0GBQwDCwVBACECCwwCC0EAEIcBIgFBf0YEQEEAIQIFQZy7AygCACICQX9qIgMgAWpBACACa3EgAWshAiADIAFxBH8gAgVBAAsgBWoiAkHwugMoAgAiB2ohAyACIABLIAJB/////wdJcQRAQfi6AygCACIGBEAgAyAHTSADIAZLcgRAQQAhAgwFCwsgAhCHASIDIAFGDQUgAyEBDAIFQQAhAgsLDAELIAggAksgAkH/////B0kgAUF/R3FxRQRAIAFBf0YEQEEAIQIMAgUMBAsACyAEIAJrQaC7AygCACIDakEAIANrcSIDQf////8HTw0CQQAgAmshBCADEIcBQX9GBEAgBBCHARpBACECBSADIAJqIQIMAwsLQfy6A0H8ugMoAgBBBHI2AgALIAVB/////wdJBEAgBRCHASIBQQAQhwEiA0kgAUF/RyADQX9HcXEhBSADIAFrIgMgAEEoaksiBARAIAMhAgsgAUF/RiAEQQFzciAFQQFzckUNAQsMAQtB8LoDQfC6AygCACACaiIDNgIAIANB9LoDKAIASwRAQfS6AyADNgIACwJAQdi3AygCACIEBEBBgLsDIQMCQAJAA0AgASADKAIAIgUgA0EEaiIHKAIAIgZqRg0BIAMoAggiAw0ACwwBCyADKAIMQQhxRQRAIAEgBEsgBSAETXEEQCAHIAYgAmo2AgBBzLcDKAIAIAJqIQJBACAEQQhqIgNrQQdxIQFB2LcDIAQgA0EHcQR/IAEFQQAiAQtqIgM2AgBBzLcDIAIgAWsiATYCACADIAFBAXI2AgQgBCACakEoNgIEQdy3A0GouwMoAgA2AgAMBAsLCyABQdC3AygCAEkEQEHQtwMgATYCAAsgASACaiEFQYC7AyEDAkACQANAIAMoAgAgBUYNASADKAIIIgMNAEGAuwMhAwsMAQsgAygCDEEIcQRAQYC7AyEDBSADIAE2AgAgA0EEaiIDIAMoAgAgAmo2AgBBACABQQhqIgJrQQdxIQNBACAFQQhqIgdrQQdxIQkgASACQQdxBH8gAwVBAAtqIgggAGohBiAFIAdBB3EEfyAJBUEAC2oiBSAIayAAayEHIAggAEEDcjYCBAJAIAQgBUYEQEHMtwNBzLcDKAIAIAdqIgA2AgBB2LcDIAY2AgAgBiAAQQFyNgIEBUHUtwMoAgAgBUYEQEHItwNByLcDKAIAIAdqIgA2AgBB1LcDIAY2AgAgBiAAQQFyNgIEIAYgAGogADYCAAwCCyAFKAIEIgBBA3FBAUYEfyAAQXhxIQkgAEEDdiECAkAgAEGAAkkEQCAFKAIMIgAgBSgCCCIBRgRAQcC3A0HAtwMoAgBBASACdEF/c3E2AgAFIAEgADYCDCAAIAE2AggLBSAFKAIYIQQCQCAFKAIMIgAgBUYEQCAFQRBqIgFBBGoiAigCACIABEAgAiEBBSABKAIAIgBFBEBBACEADAMLCwNAIABBFGoiAigCACIDBEAgAyEAIAIhAQwBCyAAQRBqIgIoAgAiAwRAIAMhACACIQEMAQsLIAFBADYCAAUgBSgCCCIBIAA2AgwgACABNgIICwsgBEUNAQJAIAUoAhwiAUECdEHwuQNqIgIoAgAgBUYEQCACIAA2AgAgAA0BQcS3A0HEtwMoAgBBASABdEF/c3E2AgAMAwUgBEEQaiAEKAIQIAVHQQJ0aiAANgIAIABFDQMLCyAAIAQ2AhggBUEQaiICKAIAIgEEQCAAIAE2AhAgASAANgIYCyACKAIEIgFFDQEgACABNgIUIAEgADYCGAsLIAUgCWohACAJIAdqBSAFIQAgBwshBSAAQQRqIgAgACgCAEF+cTYCACAGIAVBAXI2AgQgBiAFaiAFNgIAIAVBA3YhASAFQYACSQRAIAFBA3RB6LcDaiEAQcC3AygCACICQQEgAXQiAXEEfyAAQQhqIgIoAgAFQcC3AyACIAFyNgIAIABBCGohAiAACyEBIAIgBjYCACABIAY2AgwgBiABNgIIIAYgADYCDAwCCwJ/IAVBCHYiAAR/QR8gBUH///8HSw0BGiAFQQ4gACAAQYD+P2pBEHZBCHEiAHQiAUGA4B9qQRB2QQRxIgIgAHIgASACdCIAQYCAD2pBEHZBAnEiAXJrIAAgAXRBD3ZqIgBBB2p2QQFxIABBAXRyBUEACwsiAUECdEHwuQNqIQAgBiABNgIcIAZBEGoiAkEANgIEIAJBADYCAEHEtwMoAgAiAkEBIAF0IgNxRQRAQcS3AyACIANyNgIAIAAgBjYCACAGIAA2AhggBiAGNgIMIAYgBjYCCAwCCyAAKAIAIQBBGSABQQF2ayECIAUgAUEfRgR/QQAFIAILdCEBAkADQCAAKAIEQXhxIAVGDQEgAUEBdCECIABBEGogAUEfdkECdGoiASgCACIDBEAgAiEBIAMhAAwBCwsgASAGNgIAIAYgADYCGCAGIAY2AgwgBiAGNgIIDAILIABBCGoiASgCACICIAY2AgwgASAGNgIAIAYgAjYCCCAGIAA2AgwgBkEANgIYCwsgCiQEIAhBCGoPCwsDQAJAIAMoAgAiBSAETQRAIAUgAygCBGoiCCAESw0BCyADKAIIIQMMAQsLQQAgCEFRaiIDQQhqIgVrQQdxIQcgAyAFQQdxBH8gBwVBAAtqIgMgBEEQaiIMSQR/IAQiAwUgAwtBCGohBiADQRhqIQUgAkFYaiEJQQAgAUEIaiILa0EHcSEHQdi3AyABIAtBB3EEfyAHBUEAIgcLaiILNgIAQcy3AyAJIAdrIgc2AgAgCyAHQQFyNgIEIAEgCWpBKDYCBEHctwNBqLsDKAIANgIAIANBBGoiB0EbNgIAIAZBgLsDKQIANwIAIAZBiLsDKQIANwIIQYC7AyABNgIAQYS7AyACNgIAQYy7A0EANgIAQYi7AyAGNgIAIAUhAQNAIAFBBGoiAkEHNgIAIAFBCGogCEkEQCACIQEMAQsLIAMgBEcEQCAHIAcoAgBBfnE2AgAgBCADIARrIgdBAXI2AgQgAyAHNgIAIAdBA3YhAiAHQYACSQRAIAJBA3RB6LcDaiEBQcC3AygCACIDQQEgAnQiAnEEfyABQQhqIgMoAgAFQcC3AyADIAJyNgIAIAFBCGohAyABCyECIAMgBDYCACACIAQ2AgwgBCACNgIIIAQgATYCDAwDCyAHQQh2IgEEfyAHQf///wdLBH9BHwUgB0EOIAEgAUGA/j9qQRB2QQhxIgF0IgJBgOAfakEQdkEEcSIDIAFyIAIgA3QiAUGAgA9qQRB2QQJxIgJyayABIAJ0QQ92aiIBQQdqdkEBcSABQQF0cgsFQQALIgJBAnRB8LkDaiEBIAQgAjYCHCAEQQA2AhQgDEEANgIAQcS3AygCACIDQQEgAnQiBXFFBEBBxLcDIAMgBXI2AgAgASAENgIAIAQgATYCGCAEIAQ2AgwgBCAENgIIDAMLIAEoAgAhAUEZIAJBAXZrIQMgByACQR9GBH9BAAUgAwt0IQICQANAIAEoAgRBeHEgB0YNASACQQF0IQMgAUEQaiACQR92QQJ0aiICKAIAIgUEQCADIQIgBSEBDAELCyACIAQ2AgAgBCABNgIYIAQgBDYCDCAEIAQ2AggMAwsgAUEIaiICKAIAIgMgBDYCDCACIAQ2AgAgBCADNgIIIAQgATYCDCAEQQA2AhgLBUHQtwMoAgAiA0UgASADSXIEQEHQtwMgATYCAAtBgLsDIAE2AgBBhLsDIAI2AgBBjLsDQQA2AgBB5LcDQZi7AygCADYCAEHgtwNBfzYCAEH0twNB6LcDNgIAQfC3A0HotwM2AgBB/LcDQfC3AzYCAEH4twNB8LcDNgIAQYS4A0H4twM2AgBBgLgDQfi3AzYCAEGMuANBgLgDNgIAQYi4A0GAuAM2AgBBlLgDQYi4AzYCAEGQuANBiLgDNgIAQZy4A0GQuAM2AgBBmLgDQZC4AzYCAEGkuANBmLgDNgIAQaC4A0GYuAM2AgBBrLgDQaC4AzYCAEGouANBoLgDNgIAQbS4A0GouAM2AgBBsLgDQai4AzYCAEG8uANBsLgDNgIAQbi4A0GwuAM2AgBBxLgDQbi4AzYCAEHAuANBuLgDNgIAQcy4A0HAuAM2AgBByLgDQcC4AzYCAEHUuANByLgDNgIAQdC4A0HIuAM2AgBB3LgDQdC4AzYCAEHYuANB0LgDNgIAQeS4A0HYuAM2AgBB4LgDQdi4AzYCAEHsuANB4LgDNgIAQei4A0HguAM2AgBB9LgDQei4AzYCAEHwuANB6LgDNgIAQfy4A0HwuAM2AgBB+LgDQfC4AzYCAEGEuQNB+LgDNgIAQYC5A0H4uAM2AgBBjLkDQYC5AzYCAEGIuQNBgLkDNgIAQZS5A0GIuQM2AgBBkLkDQYi5AzYCAEGcuQNBkLkDNgIAQZi5A0GQuQM2AgBBpLkDQZi5AzYCAEGguQNBmLkDNgIAQay5A0GguQM2AgBBqLkDQaC5AzYCAEG0uQNBqLkDNgIAQbC5A0GouQM2AgBBvLkDQbC5AzYCAEG4uQNBsLkDNgIAQcS5A0G4uQM2AgBBwLkDQbi5AzYCAEHMuQNBwLkDNgIAQci5A0HAuQM2AgBB1LkDQci5AzYCAEHQuQNByLkDNgIAQdy5A0HQuQM2AgBB2LkDQdC5AzYCAEHkuQNB2LkDNgIAQeC5A0HYuQM2AgBB7LkDQeC5AzYCAEHouQNB4LkDNgIAIAJBWGohA0EAIAFBCGoiBWtBB3EhAkHYtwMgASAFQQdxBH8gAgVBACICC2oiBTYCAEHMtwMgAyACayICNgIAIAUgAkEBcjYCBCABIANqQSg2AgRB3LcDQai7AygCADYCAAsLQcy3AygCACIBIABLBEBBzLcDIAEgAGsiAjYCAAwDCwtBiLwDQQw2AgAgCiQEQQAPCyAKJARBAA8LQdi3A0HYtwMoAgAiASAAaiIDNgIAIAMgAkEBcjYCBCABIABBA3I2AgQLIAokBCABQQhqC8ESASd/IwQhAiMEQYABaiQEIAJBQGsiAyABLQABQQh0IAEtAAByIAEtAAJBEHRyIAEtAANBGHRyNgIAIAMgAS0ABUEIdCABLQAEciABLQAGQRB0ciABLQAHQRh0cjYCBCADIAEtAAlBCHQgAS0ACHIgAS0ACkEQdHIgAS0AC0EYdHI2AgggAyABLQANQQh0IAEtAAxyIAEtAA5BEHRyIAEtAA9BGHRyNgIMIAMgAS0AEUEIdCABLQAQciABLQASQRB0ciABLQATQRh0cjYCECADIAEtABVBCHQgAS0AFHIgAS0AFkEQdHIgAS0AF0EYdHI2AhQgAyABLQAZQQh0IAEtABhyIAEtABpBEHRyIAEtABtBGHRyNgIYIAMgAS0AHUEIdCABLQAcciABLQAeQRB0ciABLQAfQRh0cjYCHCADIAEtACFBCHQgAS0AIHIgAS0AIkEQdHIgAS0AI0EYdHI2AiAgAyABLQAlQQh0IAEtACRyIAEtACZBEHRyIAEtACdBGHRyNgIkIAMgAS0AKUEIdCABLQAociABLQAqQRB0ciABLQArQRh0cjYCKCADIAEtAC1BCHQgAS0ALHIgAS0ALkEQdHIgAS0AL0EYdHI2AiwgAyABLQAxQQh0IAEtADByIAEtADJBEHRyIAEtADNBGHRyNgIwIAMgAS0ANUEIdCABLQA0ciABLQA2QRB0ciABLQA3QRh0cjYCNCADIAEtADlBCHQgAS0AOHIgAS0AOkEQdHIgAS0AO0EYdHI2AjggAyABLQA9QQh0IAEtADxyIAEtAD5BEHRyIAEtAD9BGHRyNgI8IAIiBSAAQfQBaiIjKAIAIgIoAgAiDDYCACAFQQRqIhUgAigCBCIKNgIAIAVBCGoiFiACKAIIIgY2AgAgBUEMaiIXIAIoAgwiATYCACAFQRBqIhggAigCECILNgIAIAVBFGoiGSACKAIUIg82AgAgBUEYaiIkIAIoAhgiDTYCACAFQRxqIiUgAigCHCIINgIAIAVBIGoiJkHnzKfQBjYCACAFQSRqIhpBhd2e23s2AgAgBUEoaiIbQfLmu+MDNgIAIAVBLGoiHEG66r+qejYCACAFQTBqIh0gACgC+AEiAigCAEH/pLmIBXMiBzYCACAFQTRqIh4gAigCBEGM0ZXYeXMiCTYCACAFQThqIicgACgC/AEiACgCAEGrs4/8AXMiAjYCACAFQTxqIiggACgCBEGZmoPfBXMiADYCAEHnzKfQBiEQQYXdntt7IRJB8ua74wMhE0G66r+qeiEUA0AgCyAHIAsgDGogAyAEQQR0Qfcuai0AAEECdGooAgBqIg5zIgdBEHQgB0EQdnIiCyAQaiIMcyIHQRR0IAdBDHZyIgcgDmogAyAEQQR0Qfguai0AAEECdGooAgBqIREgByALIBFzIgdBGHQgB0EIdnIiDiAMaiIQcyIHQRl0IAdBB3ZyIR8gDyAJIA8gCmogAyAEQQR0Qfkuai0AAEECdGooAgBqIgpzIglBEHQgCUEQdnIiCyASaiIPcyIJQRR0IAlBDHZyIgwgCmogAyAEQQR0Qfouai0AAEECdGooAgBqISAgDSACIA0gBmogAyAEQQR0Qfsuai0AAEECdGooAgBqIgpzIgJBEHQgAkEQdnIiCSATaiIGcyICQRR0IAJBDHZyIgIgCmogAyAEQQR0Qfwuai0AAEECdGooAgBqISEgAiAJICFzIgJBGHQgAkEIdnIiEiAGaiIHcyICQRl0IAJBB3ZyIQ0gCCAAIAggAWogAyAEQQR0Qf0uai0AAEECdGooAgBqIgZzIgBBEHQgAEEQdnIiASAUaiICcyIAQRR0IABBDHZyIgAgBmogAyAEQQR0Qf4uai0AAEECdGooAgBqISIgACABICJzIgBBGHQgAEEIdnIiASACaiIKcyIAQRl0IABBB3ZyIQggASAMIAsgIHMiAEEYdCAAQQh2ciIJIA9qIgtzIgBBGXQgAEEHdnIiASARaiADIARBBHRB/y5qLQAAQQJ0aigCAGoiAnMiAEEQdCAAQRB2ciIAIAdqIQYgACABIAZzIgBBFHQgAEEMdnIiASACaiADIARBBHRBgC9qLQAAQQJ0aigCAGoiDHMiAEEYdCAAQQh2ciIRIAZqIRMgASATcyIAQRl0IABBB3ZyIQ8gDSAOIA0gIGogAyAEQQR0QYEvai0AAEECdGooAgBqIgZzIgBBEHQgAEEQdnIiAiAKaiIBcyIAQRR0IABBDHZyIgAgBmogAyAEQQR0QYIvai0AAEECdGooAgBqIQogACACIApzIgBBGHQgAEEIdnIiByABaiIUcyIAQRl0IABBB3ZyIQ0gCCAJIAggIWogAyAEQQR0QYMvai0AAEECdGooAgBqIgZzIgBBEHQgAEEQdnIiAiAQaiIBcyIAQRR0IABBDHZyIgAgBmogAyAEQQR0QYQvai0AAEECdGooAgBqIQYgACACIAZzIgBBGHQgAEEIdnIiCSABaiIQcyIAQRl0IABBB3ZyIQ4gHyASIB8gImogAyAEQQR0QYUvai0AAEECdGooAgBqIghzIgBBEHQgAEEQdnIiAiALaiIBcyIAQRR0IABBDHZyIgAgCGogAyAEQQR0QYYvai0AAEECdGooAgBqIQggACACIAhzIgBBGHQgAEEIdnIiAiABaiIBcyIAQRl0IABBB3ZyIQsgBEEBaiIAQQpHBEAgACEEIAEhEiAIIQEgDiEIIBEhAAwBCwsgBSAMNgIAIBggCzYCACAdIAc2AgAgJiAQNgIAIBUgCjYCACAZIA82AgAgHiAJNgIAIBogATYCACAWIAY2AgAgJCANNgIAICcgAjYCACAbIBM2AgAgFyAINgIAICUgDjYCACAoIBE2AgAgHCAUNgIAICMoAgAiASAMIAEoAgBzIBBzNgIAIAFBBGoiACAVKAIAIAAoAgBzIBooAgBzNgIAIAFBCGoiACAWKAIAIAAoAgBzIBsoAgBzNgIAIAFBDGoiACAXKAIAIAAoAgBzIBwoAgBzNgIAIAFBEGoiACAYKAIAIAAoAgBzIB0oAgBzNgIAIAFBFGoiACAZKAIAIAAoAgBzIB4oAgBzNgIAIAFBGGoiACANIAAoAgBzIAJzNgIAIAFBHGoiACAOIAAoAgBzIBFzNgIAIAUkBAuBAQEDfwJAIAAiAkEDcQRAIAIhAQNAIAEsAABFDQIgAUEBaiIBIgBBA3ENACABIQALCwNAIABBBGohASAAKAIAIgNBgIGChHhxQYCBgoR4cyADQf/9+3dqcUUEQCABIQAMAQsLIANB/wFxBEADQCAAQQFqIgAsAAANAAsLCyAAIAJrCysBAX8gAkUEQCAADwsgACABIAJBf2oiAxCuARogACADQQJ0akEANgIAIAALdwECfyAAQcQdNgIAIABBBGoiAigCACIBRQRADwsgACwAEARADwsgACwAEgRAQQAkBSMFIQBBACQFIABBAXFFBEAPCwVBACQFQSwgARAMIwUhAUEAJAUgAUEBcUUEQCACQQA2AgAgAEEANgIMDwsLQQAQGCIAEFoLhQsBFn8gAEHglwFqIhQoAgAiAyAAQcgMaiIPKAIAIgRPBEBBfw8LIABB6JcBaiIFKAIAIgIgBEkEQEF/DwsgBC4BAEEBRgRAIAQgABCJBAUgBCgCCCIBIANNIAEgAktyBEBBfw8LIAQgABCKBEUEQEF/DwsLIABB9JQBaiIIKAIAIABBgJUBaiIJKAIAIgIgAEH8lAFqIgYoAgAiAWxqIQMgCCADNgIAIAYgAEGElQFqIgwoAgAgAmsgAWwiAjYCAAJAIABB1AxqIhAoAgAiAQRAIABB4AxqIQMFIABB+JQBaiEVIABBjJUBaiERIABB4AxqIQQgAEHYDGohByADIQECQAJAA0ACQANAAkAgAiABaiABc0GAgIAITwRAIAJBgIACTw0BIAZBACABa0H//wFxNgIACyAVKAIAIRMgESgCACIKQQRqIhIoAgAiAUHi/wFKBEAgCkHoAGoiCygCACABayINQQBOBEAgCkHwAGoiFiAKQfgAaiIOKAIAIAFrIBYoAgBqNgIAAkACQCANBEAgCkEQaiICKAIAIgMgAyABaiANEF0aIBJBADYCACALIA02AgAgDUGAgAJHDQFBgIACIQEFIBJBADYCACALQQA2AgAgCkEQaiECDAELDAELIAooAgAgAigCACANakGAgAIgDWsQXiEDIAsoAgAiASADaiECIANBAEoEQCALIAI2AgAgAiEBCwsgCkHsAGoiAyABQWJqIgs2AgAgDiASKAIAIgE2AgAgAUF/aiAWKAIAIgJqIQ4gAkF/RwRAIAMgCyAOSAR/IAsFIA4LNgIACwsLIAooAhAhAiASIAFBAWo2AgAgFSATQQh0IAIgAWotAAByNgIAIAYgBigCAEEIdCICNgIAIAggCCgCAEEIdCIBNgIADAELCyAUKAIAIQMgBCgCACECIA8oAgAhAQNAIAJBAWohAiADIAEoAgwiAU8NASAFKAIAIAFJDQEgBygCACABLwEARg0ACyAEIAI2AgAgDyABNgIAIAEgABCIBEUEQEF/IQIMAwsgCCAIKAIAIAkoAgAiAyAGKAIAIgJsaiIBNgIAIAYgDCgCACADayACbCICNgIAIBAoAgAiA0UNASADIQEgBCEDDAULCwwBC0F/DwsgBCACNgIAIA8gATYCAEF/DwsLIAEtAAAhAgJAAkAgAygCAA0AIBQoAgAgASgCBCIBTw0AIABB0AxqIAE2AgAgDyABNgIADAELIAAQhwQgAEHwFGoiASwAAEUEQCABQQE6AAAgAEHwDGpBAEGAAhBUGgsLIABB+JQBaiEQIABBjJUBaiETIAgoAgAhACAGKAIAIQEDQAJAIAEgAGogAHNBgICACE8EQCABQYCAAk8NASAGQQAgAGtB//8BcTYCAAsgECgCACEOIBMoAgAiBUEEaiIMKAIAIgBB4v8BSgRAIAVB6ABqIgcoAgAgAGsiCUEATgRAIAVB8ABqIhEgBUH4AGoiBCgCACAAayARKAIAajYCAAJAAkAgCQRAIAVBEGoiASgCACIDIAMgAGogCRBdGiAMQQA2AgAgByAJNgIAIAlBgIACRw0BQYCAAiEABSAMQQA2AgAgB0EANgIAIAVBEGohAQwBCwwBCyAFKAIAIAEoAgAgCWpBgIACIAlrEF4hAyAHKAIAIgAgA2ohASADQQBKBEAgByABNgIAIAEhAAsLIAVB7ABqIgMgAEFiaiIHNgIAIAQgDCgCACIANgIAIABBf2ogESgCACIBaiEEIAFBf0cEQCADIAcgBEgEfyAHBSAECzYCAAsLCyAFKAIQIQEgDCAAQQFqNgIAIBAgDkEIdCABIABqLQAAcjYCACAGIAYoAgBBCHQiATYCACAIIAgoAgBBCHQiADYCAAwBCwsgAgvKAQECfwJAIAAQWCIBQYCAA3EiAkEQdEEQdUEASARAIAJBEHRBEHVBgIB+aw0BIABBAhBVIAAQWCEBIABBEBBVIAEPBSACQRB0QRB1QYCAAUgEQCACDQIgAEEGEFUgAUEKdkEPcQ8LIAJBEHRBEHVBgIABaw0BIAFBgPgAcQRAIABBChBVIAFBBnZB/wFxDwUgAEEOEFUgAUECdkGAfnIPCwALAAsgAEECEFUgABBYQRB0IQEgAEEQEFUgABBYIAFyIQEgAEEQEFUgAQteAQJ/IAEoAgAiAkUgACgCACIDRSADIAJHcnIEQCACIQAgAyEBBQNAIAFBBGoiASgCACICRSAAQQRqIgAoAgAiA0UgAyACR3JyBEAgAiEAIAMhAQUMAQsLCyABIABrC0QBAn8gAQRAA0AgAEEEaiEDIAAoAgAiAkUgAiABRnJFBEAgAyEADAELCyACRQRAQQAhAAsFIAAgABBZQQJ0aiEACyAAC9gEAQF/IAAoAoABIAFLBEAgACgCACABag8LAkAgACgChAEgAUsEQEEBIQIFIAAoAogBIAFLBEBBAiECBSAAKAKMASABSwRAQQMhAgUgACgCkAEgAUsEQEEEIQIFIAAoApQBIAFLBEBBBSECBSAAKAKYASABSwRAQQYhAgUgACgCnAEgAUsEQEEHIQIFIAAoAqABIAFLBEBBCCECBSAAKAKkASABSwRAQQkhAgUgACgCqAEgAUsEQEEKIQIFIAAoAqwBIAFLBEBBCyECBSAAKAKwASABSwRAQQwhAgUgACgCtAEgAUsEQEENIQIFIAAoArgBIAFLBEBBDiECBSAAKAK8ASABSwRAQQ8hAgUgACgCwAEgAUsEQEEQIQIFIAAoAsQBIAFLBEBBESECBSAAKALIASABSwRAQRIhAgUgACgCzAEgAUsEQEETIQIMEwsgACgC0AEgAUsEQEEUIQIMEwsgACgC1AEgAUsEQEEVIQIMEwsgACgC2AEgAUsEQEEWIQIMEwsgACgC3AEgAUsEQEEXIQIMEwsgACgC4AEgAUsEQEEYIQIMEwsgACgC5AEgAUsEQEEZIQIMEwsgACgC6AEgAUsEQEEaIQIMEwsgACgC7AEgAUsEQEEbIQIMEwsgACgC8AEgAUsEQEEcIQIMEwsgACgC9AEgAUsEQEEdIQIMEwsgACgC+AEgAUsEQEEeIQIMEwsgACgC/AEgAUsEQEEfIQIMEwsgACgCAA8LCwsLCwsLCwsLCwsLCwsLCwsLIAAgAkECdGooAgAgASAAIAJBAnRqKAJ8a2oL7QMBB38gAEHgAGoiBigCACIEIAJrIgMgAEHMzQNqKAIAQf9faiIFSSAEIAVJcUUEQCABRQRADwsgAEGklgFqIQcgAyECIABB0M0DaiIIKAIAIQMgBCEAA0AgAkEBaiEEIAcoAgAiBSAAaiAFIAMgAnFqLAAAOgAAIAYgBigCAEEBaiAIKAIAIgNxIgA2AgAgAUF/aiIBBEAgBCECDAELCw8LIABBpJYBaigCACIJIANqIQMgCSAEaiEAIAYgBCABajYCACABQQdLBEAgCSAEIAFBeGoiB0F4cSIIakEIaiIFIAJraiEEIAMhAgNAIAAgAiwAADoAACAAIAIsAAE6AAEgACACLAACOgACIAAgAiwAAzoAAyAAIAIsAAQ6AAQgACACLAAFOgAFIAAgAiwABjoABiAAIAIsAAc6AAcgAkEIaiECIABBCGohACABQXhqIgFBB0sNAAsgCSAFaiEAIAQhAyAHIAhrIQELIAFFBEAPCyAAIAMsAAA6AAAgAUEBRgRADwsgACADLAABOgABIAFBAk0EQA8LIAAgAywAAjoAAiABQQNGBEAPCyAAIAMsAAM6AAMgAUEETQRADwsgACADLAAEOgAEIAFBBUYEQA8LIAAgAywABToABSABQQZNBEAPCyAAIAMsAAY6AAYLhxABBH8jBCEFIwRBgAhqJAQgBUGABGohAiAALACABAR/IAIgAEGABBBTGiMEIQAjBEEQaiQEQRQgABAlIQMgACQEIANBywBqIQRBACEAA0AgAiAAaiIDIAQgAGogAy0AAHM6AAAgAEEBaiIAQYAERw0ACyACQfwDagUgAgshAyAFIQAgA0EANgIAIAEsAIAEBH8gACABQYAEEFMaIwQhASMEQRBqJARBFCABECUhAyABJAQgA0HLAGohBEEAIQEDQCAAIAFqIgMgBCABaiADLQAAczoAACABQQFqIgFBgARHDQALIABB/ANqBSAAC0EANgIAIAIgABBzIQEgAkEAOgAAIAJBADoAASACQQA6AAIgAkEAOgADIAJBADoABCACQQA6AAUgAkEAOgAGIAJBADoAByACQQA6AAggAkEAOgAJIAJBADoACiACQQA6AAsgAkEAOgAMIAJBADoADSACQQA6AA4gAkEAOgAPIAJBADoAECACQQA6ABEgAkEAOgASIAJBADoAEyACQQA6ABQgAkEAOgAVIAJBADoAFiACQQA6ABcgAkEAOgAYIAJBADoAGSACQQA6ABogAkEAOgAbIAJBADoAHCACQQA6AB0gAkEAOgAeIAJBADoAHyACQQA6ACAgAkEAOgAhIAJBADoAIiACQQA6ACMgAkEAOgAkIAJBADoAJSACQQA6ACYgAkEAOgAnIAJBADoAKCACQQA6ACkgAkEAOgAqIAJBADoAKyACQQA6ACwgAkEAOgAtIAJBADoALiACQQA6AC8gAkEAOgAwIAJBADoAMSACQQA6ADIgAkEAOgAzIAJBADoANCACQQA6ADUgAkEAOgA2IAJBADoANyACQQA6ADggAkEAOgA5IAJBADoAOiACQQA6ADsgAkEAOgA8IAJBADoAPSACQQA6AD4gAkEAOgA/IAJBQGtBADoAACACQQA6AEEgAkEAOgBCIAJBADoAQyACQQA6AEQgAkEAOgBFIAJBADoARiACQQA6AEcgAkEAOgBIIAJBADoASSACQQA6AEogAkEAOgBLIAJBADoATCACQQA6AE0gAkEAOgBOIAJBADoATyACQQA6AFAgAkEAOgBRIAJBADoAUiACQQA6AFMgAkEAOgBUIAJBADoAVSACQQA6AFYgAkEAOgBXIAJBADoAWCACQQA6AFkgAkEAOgBaIAJBADoAWyACQQA6AFwgAkEAOgBdIAJBADoAXiACQQA6AF8gAkEAOgBgIAJBADoAYSACQQA6AGIgAkEAOgBjIAJBADoAZCACQQA6AGUgAkEAOgBmIAJBADoAZyACQQA6AGggAkEAOgBpIAJBADoAaiACQQA6AGsgAkEAOgBsIAJBADoAbSACQQA6AG4gAkEAOgBvIAJBADoAcCACQQA6AHEgAkEAOgByIAJBADoAcyACQQA6AHQgAkEAOgB1IAJBADoAdiACQQA6AHcgAkEAOgB4IAJBADoAeSACQQA6AHogAkEAOgB7IAJBADoAfCACQQA6AH0gAkEAOgB+IAJBADoAfyAAQQA6AAAgAEEAOgABIABBADoAAiAAQQA6AAMgAEEAOgAEIABBADoABSAAQQA6AAYgAEEAOgAHIABBADoACCAAQQA6AAkgAEEAOgAKIABBADoACyAAQQA6AAwgAEEAOgANIABBADoADiAAQQA6AA8gAEEAOgAQIABBADoAESAAQQA6ABIgAEEAOgATIABBADoAFCAAQQA6ABUgAEEAOgAWIABBADoAFyAAQQA6ABggAEEAOgAZIABBADoAGiAAQQA6ABsgAEEAOgAcIABBADoAHSAAQQA6AB4gAEEAOgAfIABBADoAICAAQQA6ACEgAEEAOgAiIABBADoAIyAAQQA6ACQgAEEAOgAlIABBADoAJiAAQQA6ACcgAEEAOgAoIABBADoAKSAAQQA6ACogAEEAOgArIABBADoALCAAQQA6AC0gAEEAOgAuIABBADoALyAAQQA6ADAgAEEAOgAxIABBADoAMiAAQQA6ADMgAEEAOgA0IABBADoANSAAQQA6ADYgAEEAOgA3IABBADoAOCAAQQA6ADkgAEEAOgA6IABBADoAOyAAQQA6ADwgAEEAOgA9IABBADoAPiAAQQA6AD8gAEFAa0EAOgAAIABBADoAQSAAQQA6AEIgAEEAOgBDIABBADoARCAAQQA6AEUgAEEAOgBGIABBADoARyAAQQA6AEggAEEAOgBJIABBADoASiAAQQA6AEsgAEEAOgBMIABBADoATSAAQQA6AE4gAEEAOgBPIABBADoAUCAAQQA6AFEgAEEAOgBSIABBADoAUyAAQQA6AFQgAEEAOgBVIABBADoAViAAQQA6AFcgAEEAOgBYIABBADoAWSAAQQA6AFogAEEAOgBbIABBADoAXCAAQQA6AF0gAEEAOgBeIABBADoAXyAAQQA6AGAgAEEAOgBhIABBADoAYiAAQQA6AGMgAEEAOgBkIABBADoAZSAAQQA6AGYgAEEAOgBnIABBADoAaCAAQQA6AGkgAEEAOgBqIABBADoAayAAQQA6AGwgAEEAOgBtIABBADoAbiAAQQA6AG8gAEEAOgBwIABBADoAcSAAQQA6AHIgAEEAOgBzIABBADoAdCAAQQA6AHUgAEEAOgB2IABBADoAdyAAQQA6AHggAEEAOgB5IABBADoAeiAAQQA6AHsgAEEAOgB8IABBADoAfSAAQQA6AH4gAEEAOgB/IAAkBCABRQslAQF/IAIgABBZa0F/aiIDQQBMBEAgAA8LIAAgASADELIDGiAACxYAIABBAEHAywQQVBogAEGowAJqEFwLbQEEfyAAKAIUIABBGGoiBCgCACIFayIDIAJJIgYEfyADBSACIgMLBEAgASAAKAIAIAVqIAMQUxoLIAZFBEAgBCAEKAIAIANqNgIAIAMPCyABIANqQQAgAiADaxBUGiAEIAQoAgAgA2o2AgAgAwueAwEIfyMEIQQjBEEgaiQEIARBCGohBSABQQA2AgAgBEIANwMAIARBEGoiAyAANgIAAkACQAJAAkACQAJAIAEgAyACIAQQuQNBf2sOAgABAgsMAgsgACwAAA0BQQEhAAwCC0EBIQAMAQsgAkEBSwRAQQAhAwJAAkADQCAAIAhqIgYsAABFDQEgBUIANwMAIAEgA0ECdGoiCSAGQawjKAIAKAIABH9BBAVBAQsgBRCKAkF/RgR/IAYsAAAiB0EATg0DIApFBEAgCUH+/wM2AgAgA0EBaiIDIAJPDQQgBiwAACEHCyABIANBAnRqIAdB/wFxQYDAA3I2AgBBASEKIAhBAWoFIAVCADcDACAGQawjKAIAKAIABH9BBAVBAQsgBRCIAiIHQQFKBH8gBwVBAQsgCGoLIQggA0EBaiIDIAJJDQBBACEADAULAAsgASADQQJ0akEANgIAQQEhAAwDC0EAIQAFQQAhAAwBCwwBCyACRQRAIAQkBCAAQf8BcUEARw8LCyABIAJBf2pBAnRqQQA2AgAgBCQEIABB/wFxQQBHC/EBAgN/AX4jBCEBIwRB0ABqJAQgAEGtvANqLAAABEAgASQEQQAPCyAAQYi8A2oiAyAAIAAoAgAoAhRBB3FBhgFqEQAAIgQ3AwACQAJAAkACQAJAAkAgAEGYvANqKAIAQQFrDgMAAQIDCyAAENcCIQIMAwsgABDWAiECDAILIAAQ1QIhAgwBCwwBCyACBEAgAykDACEEBSABJARBAA8LCyAAQZC8A2opAwAgBFUEQCABJAQgAg8LIAFBADYCRCABQRg2AkggAUFAa0EBNgIAIAEgAEEYajYCACAAQay8A2pBAToAAEGs9QJBAxBkIAEkBEEAC9cBAgZ/AX4jBCEDIwRBoAJqJAQgA0EgaiEGIAMhBSAAQSBqIgMpAwAhCSADIAkgAq18NwMAIAJFBEAgBUEgEFsgBkGAAhBbIAUkBA8LIABBKGohByAAQSxqIQggCadBP3EhAwNAIAJBwAAgA2siBEsEfyAEBSACIgQLQcAARgRAIAcgATYCAAUgByAINgIAIABBLGogA2ogASAEEFMaCyAEIANqIgNBwABGBEAgABDhAUEAIQMLIAEgBGohASACIARrIgINAAsgBUEgEFsgBkGAAhBbIAUkBAt4AQF/IABB9A02AgAgAEGo8wBqLAAABEAgAEGs8wBqKAIAIgEEQCABEHkgARBSCwsgAEGQ7gJqKAIAIgEEQCABEFILIABB0OcBaigCACIBBEAgARBSCyAAQdjzAGoQtQIgAEHw8QBqEIQBIABBnMAAahCOASAAEHALBgBBEBAACwgAQQUQAEEACwgAQQIQAEEACzABAX8jBCECIwRBEGokBCACIAE2AgBB8CAoAgAiASAAIAIQzgEaQQogARCrAxoQOQujAgEEfyABRQRAIABBvM0DakEANgIAIABByM0DakEANgIAIABBnM0DaiIEKAIAIgEEQCAAQZjNA2ohBQNAIAUoAgAgAkECdGooAgAiAwRAIAMoAjwiAQRAIAEQUgsgAygCLCIBBEAgARBSCyADKAIUIgEEQCABEFILIAMQUiAEKAIAIQELIAJBAWoiAiABSQ0ACwsgBEEANgIACyAAQazNA2oiAygCACICRQRAIANBADYCAA8LIABBqM0DaiEEQQAhASACIQADQCAEKAIAIAFBAnRqKAIAIgIEQCACKAI8IgAEQCAAEFILIAIoAiwiAARAIAAQUgsgAigCFCIABEAgABBSCyACEFIgAygCACEACyABQQFqIgEgAEkNAAsgA0EANgIAC0gBAX8gAEFAaygCACIBBEAgARCOASABEFILIAAoAkQiAQRAIAEQjgEgARBSCyAAQagBahCNASAAQZwBahCNASAAQZABahCNAQsYAEG39QIsAABFBEAPC0Gs9QJB/wEQ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TBogACABEKwDIgALQQEBfwJAIAAQWSICQX9KBEAgACACQQJ0aiECA0AgAigCACABRg0CIAJBfGoiAiAATw0AQQAhAgsFQQAhAgsLIAILZAEDfwJAIAIEQCABIQMgACEBA0AgAygCACIFRQ0CIANBBGohAyABQQRqIQQgASAFNgIAIAJBf2oiAgRAIAQhAQwBBSAEIQFBACECCwsFIAAhAUEAIQILCyABQQAgAhCwAxogAAvCBAEKfyMEIQYjBEGAQGskBCAAIQcDQAJAA0AgACIEKAIAIQgCQAJAA0ACQAJAAkACQCAIDjAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCyAHIQAMBwsMAQsMAgsgBEEEaiIAKAIAIghBLkYNAiAAIQQMAAsACyAEQQRqIQAMAQsgBCgCCEEuRw0ACyAEQRBqIQggBCgCDEEvRgRAIAghBwsMAQsLAkACQANAAkACQAJAAkACQCAAKAIAIgcOXQACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILDAMLIAAoAgRB3ABGBEAgAEEIakHcABB0IgIEQCACQQRqQdwAEHQiA0EEaiECIAMEfyACBSAAIgILIQMFIAAiAyECCwUgACIDIQILQQ0hBQwBCyAAIgohCSAHIQsLA0AgBUENRgRAQQAhBSADIQogAiEJIAMoAgAhCwsCQAJAAkAgC0Euaw4CAAECCyAKQQRqIQMgCSECQQ0hBQwCCyAKQQRqIgIhA0ENIQUMAQsLIAkgAEYNAiAJIQAMAQsLDAELIAAoAgBBLkYEQCAAKAIEQS5GBEAgAEEIaiICKAIARQRAIAIhAAsLCwsgAUUEQCAGJAQgAA8LIAYgAEGAEBBvGiABIAYQahogBiQEIAALEwAgAAR/IAAgAUEAEJEBBUEACwvaAwMBfwF+AXwCQCABQRRNBEACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOCgABAgMEBQYHCAkKCyACKAIAQQNqQXxxIgEoAgAhAyACIAFBBGo2AgAgACADNgIADAsLIAIoAgBBA2pBfHEiASgCACEDIAIgAUEE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ACEEQQAhAwNAIAAgDCADrXxBACAAKAIAKAIQQQNxQbgCahECACAIKAIAQQFGBEAgBiAJNgIACyAHLAAABEAgB0EAOgAACyAGKAIAIAEgAiADayIFQYAESQR/IAUFQYAECxBBIgVBf0YEf0GABAUgBQsgBGohBCADQYAEaiIDIAJJDQALIAQPC0Gs9QIgAxC6BEF/DwsgBAuMAgEDfyABKAIAIQIgAEIANwIAIABBADYCCCACQe////8DSwRAIAAQigELIAFBBGohBAJAIAJBAkkEQCAAIAI6AAsgAgRAIAAhAwUgACACQQJ0akEANgIADwsFIAJBBGpBfHEiAUH/////A00EQCAAIAFBAnQQXyIDNgIAIAAgAUGAgICAeHI2AgggACACNgIEDAILQQgQFCEAQQAkBUEXIABBzO4AEA0jBSEBQQAkBSABQQFxBEAQFyEBIAAQGiABEB4FIABB7CU2AgAgAEH4CkEMEBsLCwtBACQFQR0gAyAEIAIQBxojBSEAQQAkBSAAQQFxBEBBABAYIgAQWgUgAyACQQJ0akEANgIACwsPACABIAAoAgBqIAI2AgALDQAgASAAKAIAaigCAAvQBgECfyAAKAIAIgEEQCABEFIgAEEANgIACyAAQQRqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBCGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEMaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQRBqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBFGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEYaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQRxqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBIGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEkaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQShqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBLGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEwaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQTRqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBOGoiASgCACICBEAgAhBSIAFBADYCAAsgAEE8aiIBKAIAIgIEQCACEFIgAUEANgIACyAAQUBrIgEoAgAiAgRAIAIQUiABQQA2AgALIABBxABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABByABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBzABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB0ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB1ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB2ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB3ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB4ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB5ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB6ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB7ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB8ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB9ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB+ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB/ABqIgAoAgAiAUUEQA8LIAEQUiAAQQA2AgAL6AoBGn8jBCECIwRBEGokBCACQQhqIRIgAiEJIABB4ABqIgooAgAgAEHkAGoiDCgCACICayAAQdDNA2oiDSgCACIDcSETIABBNGohBwJAAkAgAEE4aiILKAIARQ0AIABBHGohDiAAQRhqIRQgAEEgaiEXIABBFGohDyAAQczNA2ohGCAAQaiYAWohFSAAQaSWAWohECAAQaiWAWohESAAQbqYAWohGSAAQcCYAWohFiATIQECQAJAAkACQANAAkAgBygCACIGIAVBBHRqIhosAABBCEcEQCAGIAVBBHRqKAIEIQQgBiAFQQR0akENaiIILAAABEAgBCAMKAIAayADcSATSw0CIAhBADoAAAwCCyAGIAVBBHRqKAIIIQYgAyAEIAJrcSABSQRAIAQgAkcEQCAAIAIgBBCzASAEIQIgCigCACAEayANKAIAIgNxIQELIAYgAUsNBCAGBEAgDigCACEBIBQgBjYCACABIAZJBEAgFygCACICQQBHIAYgAktxBH8gCSACNgIAQaz1AkHYGyAJEGBBrPUCEFYgDigCACEBIBQoAgAFIAYLIQIgDygCACACIAFBIGogAUECdmoiAUsEfyACBSABIgILEFciAUUEQEGs9QIQVgsgDyABNgIAIA4gAjYCAAsgDygCACEBAkAg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ACADIAFBlJUBaiAEai0AACIEQQR0aiEDIAIgBGshAgsgASACakG5lQFqLQAAIQQLIAMgAUHIlgFqIARBAnRqIgEoAgA2AgAgASADNgIACyAKIAA2AgALIA0gADYCACAGJAQLuxIBCX8gAEHwDGpBAEGAAhBUGiAAQZCVAWoiBhCOBCAAQewMaiIIIABB5AxqIgUoAgAiA0F/cyIBQXNKBH8gAQVBcws2AgAgAEHElgFqIgcoAgAiASAAQcCWAWoiAigCAEYEQCAAQciWAWoiBCgCACIBBEAgBCABKAIANgIABSAGQQAQoAEhASAFKAIAIQMLBSAHIAFBcGoiATYCAAsgAEHQDGogATYCACAAQcgMaiIFIAE2AgAgAUEANgIMIABB4AxqIAM2AgAgAUGAAjsBACABQYECOwEEIABByJYBaiAAQbmWAWotAAAiA0ECdGoiBCgCACIBBEAgBCABKAIANgIABSACIAIoAgAiASAAQZSVAWogA2oiCS0AAEEEdGoiBDYCACAEIAcoAgBLBEAgAiAEIAktAABBBHRrNgIAIAYgAxCgASEBCwsgBSgCACABNgIIIABB1AxqIAE2AgAgAEHoDGogCCgCADYCACAAQfEUakEAOgAAIAUoAgBBCGohA0EAIQEDQCADKAIAIAFBA3RqIAE6AAAgAygCACABQQN0akEBOgABIAMoAgAgAUEDdGpBADYCBCABQQFqIgFBgAJHDQBBACEBCwNAIABB9BRqIAFBB3RqQYCAAUHd+QAgAUECaiIDbmtB//8DcSICOwEAIAAgAUEHdGpBhBVqIAI7AQAgACABQQd0akGUFWogAjsBACAAIAFBB3RqQaQVaiACOwEAIAAgAUEHdGpBtBVqIAI7AQAgACABQQd0akHEFWogAjsBACAAIAFBB3RqQdQVaiACOwEAIAAgAUEHdGpB5BVqIAI7AQAgACABQQd0akH2FGpBgIABQb8+IANua0H//wNxIgI7AQAgACABQQd0akGGFWogAjsBACAAIAFBB3RqQZYVaiACOwEAIAAgAUEHdGpBphVqIAI7AQAgACABQQd0akG2FWogAjsBACAAIAFBB3RqQcYVaiACOwEAIAAgAUEHdGpB1hVqIAI7AQAgACABQQd0akHmFWogAjsBACAAIAFBB3RqQfgUakGAgAFBv7MBIANua0H//wNxIgI7AQAgACABQQd0akGIFWogAjsBACAAIAFBB3RqQZgVaiACOwEAIAAgAUEHdGpBqBVqIAI7AQAgACABQQd0akG4FWogAjsBACAAIAFBB3RqQcgVaiACOwEAIAAgAUEHdGpB2BVqIAI7AQAgACABQQd0akHoFWogAjsBACAAIAFBB3RqQfoUakGAgAFB85EBIANua0H//wNxIgI7AQAgACABQQd0akGKFWogAjsBACAAIAFBB3RqQZoVaiACOwEAIAAgAUEHdGpBqhVqIAI7AQAgACABQQd0akG6FWogAjsBACAAIAFBB3RqQcoVaiACOwEAIAAgAUEHdGpB2hVqIAI7AQAgACABQQd0akHqFWogAjsBACAAIAFBB3RqQfwUakGAgAFBockBIANua0H//wNxIgI7AQAgACABQQd0akGMFWogAjsBACAAIAFBB3RqQZwVaiACOwEAIAAgAUEHdGpBrBVqIAI7AQAgACABQQd0akG8FWogAjsBACAAIAFBB3RqQcwVaiACOwEAIAAgAUEHdGpB3BVqIAI7AQAgACABQQd0akHsFWogAjsBACAAIAFBB3RqQf4UakGAgAFBvLUBIANua0H//wNxIgI7AQAgACABQQd0akGOFWogAjsBACAAIAFBB3RqQZ4VaiACOwEAIAAgAUEHdGpBrhVqIAI7AQAgACABQQd0akG+FWogAjsBACAAIAFBB3RqQc4VaiACOwEAIAAgAUEHdGpB3hVqIAI7AQAgACABQQd0akHuFWogAjsBACAAIAFBB3RqQYAVakGAgAFBsswBIANua0H//wNxIgI7AQAgACABQQd0akGQFWogAjsBACAAIAFBB3RqQaAVaiACOwEAIAAgAUEHdGpBsBVqIAI7AQAgACABQQd0akHAFWogAjsBACAAIAFBB3RqQdAVaiACOwEAIAAgAUEHdGpB4BVqIAI7AQAgACABQQd0akHwFWogAjsBACAAIAFBB3RqQYIVakGAgAFB0cABIANua0H//wNxIgM7AQAgACABQQd0akGSFWogAzsBACAAIAFBB3RqQaIVaiADOwEAIAAgAUEHdGpBshVqIAM7AQAgACABQQd0akHCFWogAzsBACAAIAFBB3RqQdIVaiADOwEAIAAgAUEHdGpB4hVqIAM7AQAgACABQQd0akHyFWogAzsBACABQQFqIgFBgAFHDQBB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QEEAEBgQWgUgBhAeCwsgByAZNwMAIAMgGjcDACACIAo2AgAgACgCACgCECECQQAkBSACIAAgF6cgF0IgiKdBABBQIwUhAkEAJAUgAkEBcQRAQQAQGBBaBSABIQ8LCyAPLAAABEAgAEGhvANqLAAARQRAIAUkBEEBDwsLIABB5LwDaiAAQRhqEGoaIAUkBEEBDwsgBSQEQQALBgBBFxAACwYAQRYQAAsGAEEREAALCABBBxAAQQALLQEBfyAAQTsQrQEiAgRAIAJBBGoQyQIhACABBEAgAkEANgIACwVBACEACyAAC9YBAQJ/IwQhAyMEQYAQaiQEAkAgAARAAkACQAJAAkAgACgCAA4wAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsMBAsgAUEANgIADAELIANBgBAQtgNFBEAgA0EAOgAACyADIAEgAhB7GiABEFkiBARAIARBAWogAkkgASAEQX9qQQJ0aigCAEEvR3EEQCABQfwMEIYCGgsLCyABIAAgAhB4GiADJAQPCwsgAkUEQCADJAQPCyABQQA2AgAgAyQEC78BAQJ/AkAgAkF/aiIEBEBBACECA0ACQAJAAkAgACACQQJ0aigCACIDDl0AAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCwwEC0EvIQMLIAEgAkECdGogAzYCACACQQFqIgIgBEkNAAsFQQAhAgsLIAEgAkECdGpBADYCAAtWAQN/IAAoAgQiBUEIdSEEIAVBAXEEQCACKAIAIARqKAIAIQQLIAAoAgAiACgCACgCHCEGIAAgASACIARqIAVBAnEEfyADBUECCyAGQQdxQZgCahEKAAsHACAAIAFGCwsAIAAQ/AEgABBSCxIAIABB2CU2AgAgAEEEahCNAwuDAQEBfyMEIQEjBEEQaiQEQQAkBSAAEAsjBSEAQQAkBSAAQQFxRQRAQQAkBUEZQbvyACABEA1BACQFC0EAEBgiABAVGkEAJAVBGUHj8gAgAUEIahANQQAkBUEAEBghAUEAJAVBBBALIwUhAEEAJAUgAEEBcQRAQQAQGCIAEFoFIAEQWgsLOAEC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IAQQyAEgBSgCACEACwJAIABBqIACahBZIgYEQCACIAYgAhBZIgFJBH8gBgUgAQtBAnRqIQIDQAJAAkACQAJAAkAgAigCAA4wAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsMAwsMAQsMBAsgAkEEaiECDAELCyADQQA2AgAPCwsCQAJAIABByMsEaigCACIBQdgARiAAQeCEA2ooAgBBBEZxBEBBACEBBSABQcUARgRAQQAhAQwCBUEAIQELCyAFKAIAQeCEA2ooAgBBAUYNACADIAIgBBB4GgwBCyADIAIQmwEgBBB4GgsgAygCABCTASEADwv4AQEDfyMEIQMjBEHwFmokBCADQSRqIQQgAyAAKAIAIgU2AgACQAJAAkACQCAFQQFrDgMAAQIDCyADIAAoAgQ2AgQMAgsgAyAAKAIEQX9zNgIEDAELIAQgACgCCBCmBCAEIANBBGoQqQQLIAIEQCADIAIQvwILIAMoAgAiAkUEQCADJARBAQ8LIAEoAgAiAEUEQCADJARBAQ8LIAJBAUYgAEEBRnFFBEAgAkECRiAAQQJGcUUEQCACQQNGIABBA0ZxRQRAIAMkBEEADwsgA0EEaiABQQRqQSAQa0UhACADJAQgAA8LCyADKAIEIAEoAgRGIQAgAyQEIAALcgEBfyAAKAIAIgNBAUYEQCAAQQRqIgMgAygCAEH//wNxIAEgAhDQBEH//wNxNgIAIAAoAgAhAwsgA0ECRgRAIABBBGoiAyADKAIAIAEgAhCZATYCACAAKAIAIQMLIANBA0cEQA8LIAAoAgggASACEKsEC74FAQJ/IABBCGoiBCgCACICRQRAQQBBzBYQXyICIgNrQT9xIANqIQMgAiADNgLwASACIANBgAFqNgL0ASACIANBoAFqNgL4ASACIANBqAFqNgL8ASACQQAgAkGIAmoiA2tBP3EgA2oiAzYC+AMgAiADQYABajYC/AMgAiADQaABajYCgAQgAiADQagBajYChAQgAkEAIAJBkARqIgNrQT9xIANqIgM2AoAGIAIgA0GAAWo2AoQGIAIgA0GgAWo2AogGIAIgA0GoAWo2AowGIAJBiAhqQQAgAkGYBmoiA2tBP3EgA2oiAzYCACACQYwIaiADQYABajYCACACQZAIaiADQaABajYCACAC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AUGg0ABqIAIEfyADBSAECzYAACABQZjQAGogAEHstwdqIgIoAgA2AABBACQFQQUgAEG4twdqEAUhAyMFIQRBACQFIARBAXFFBEAgAUGc0ABqIAM2AAAgAUGk0ABqIABBovcGai0AAEEwajYAACABQajQAGogAEGk9wZqKAIANgAAIAFBtNAAakEANgAAIAFBuNAAakEANgAAIAFBvNAAaiAAQey4B2ooAgBBCnY2AAACQAJAAkACQCAAQei3B2ooAgBBAWsOAwAAAQILIAFBwNAAakEBNgAADAILIAFBwNAAakECNgAAIAFBxNAAaiIDIAIpAAA3AAAgAyACKQAINwAIIAMgAikAEDcAECADIAIpABg3ABgMAQsgAUHA0ABqQQA2AAALIAFB5NAAaiAAQfi4B2ooAgAiAjYAACACBEAgAUHo0ABqKAAAIgIEQCABQezQAGooAAAiA0F/akGfjQZJBEBBACQFQRAgAiAAQfy4B2ogAxAHGiMFIQJBACQFIAJBAXENCQsLCyABQfDQAGogAEH8+AdqLQAANgAAQQAPCwsLCwsLC0GACBAYIQEjB0GACBBERwRAIAEQHgsgARAVIQECQCAAQajLBGooAgAiAEUEQAJAAkACQAJAAkACQAJAAkACQCABKAIADgwHCAABCAIDCAUECAYIC0ESIQAMCQtBDCEADAgLQRMhAAwHC0EPIQAMBgtBECEADAULQQshAAwEC0EYIQAMAwtBACEADAILQRUhAAsLEBYgAAvEAwEEfyMEIQIjBEFAayQEIAJBIGohAyAAKAIAIgRBAkYEQCADIABBBGoiBSgCACIEOgAAIAMgBEEIdjoAASADIARBEHY6AAIgAyAEQRh2OgADIAFBICADQQQgAhCnASAFQQA2AgAgBSACLQAfQRh0IAItAB5BEHQgAi0AHUEIdCACLQAbQRh0IAItABpBEHQgAi0AGUEIdCACLQAXQRh0IAItABZBEHQgAi0AFUEIdCACLQATQRh0IAItABJBEHQgAi0AEUEIdCACLQAPQRh0IAItAA5BEHQgAi0ADUEIdCACLQALQRh0IAItAApBEHQgAi0ACUEIdCACLQAHQRh0IAItAAZBEHQgAi0ABUEIdCACLQADQRh0IAItAAJBEHQgAi0AAUEIdCACLQAAcnJyIAItAARzc3NzIAItAAhzc3NzIAIt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IBwgAa18NwMAAkACQAJAAkACQAJAAkACQAJAAkAgFCgCACIBQQFrDnkAAQEIAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAMFBwYECAtBACQFQRsgAEG4pgFqIgEQDCMFIQJBACQFIAJBAXENDSABIAcpAgA3AgAgASAHKQIINwIIIAEgBygCEDYCEEEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXENDSAAQcymAWoiAyABOwEAQQAkBUEMIAQQBSECIwUhAUEAJAUgAUEBcQ0NIABB0KYBaiACNgIAIABBnbwDaiAAQcCmAWooAgAiAUEBcToAACAAQZy8A2ogAUEDdkEBcToAACAAQZ+8A2ogAUECdkEBcToAACAAQaO8A2ogAUEGdkEBcToAACAIIAFBB3ZBAXE6AAAgAEGgvANqIAIEf0EBBSADLgEAQQBHC0EBcToAACAAQdSmAWogAUEBdkEBcToAACAAQaG8A2ogAUEIdkEBcToAACAAQaK8A2ogAUEEdkEBcToAAAwICyAAQbCnAWohAyAAQfCtAmohAkEAJAVBCCABQQJGIg8EfyADBSACIgMLQQAQDSMFIQFBACQFIAFBAXFFBEAgAyAHKQIANwIAIAMgBykCCDcCCCADIAcoAhA2AhAgA0GIwQBqIANBCGoiCSgCACIBQQFxOgAAIANBicEAaiABQQF2QQFxOgAAIANBi8EAaiIGIAFBAnZBAXE6AAAgA0GQwQBqIAFBCnZBAXE6AAAgA0HgwQBqIA8Ef0EAIQUgAUEEdkEBcQUgAUEQcUEARyEFQQALOgAAIANB6sEAaiAFQQFxOgAAIANB4cEAaiIMIAFB4AFxQeABRiICOgAAIANB5MEAaiACBH9BAAVBgIAEIAFBBXZBB3F0CzYCACADQeLBAGoiGSABQQN2QQFxOgAAIANB48EAaiABQQt2QQFxOgAAQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcUUEQCADQRRqIhogATYCAEEAJAVBDCAEEAUhAiMFIQFBACQFAkAgAUEBcUUEQEEAJAVBCyAEEAUhASMFIQVBACQFIAVBAXFF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AGoiBxAMIwUhAkEAJAUCQCACQQFxBEAQFyECBSAAQdDnAWoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJCADcCICAAQZDuAmoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJCADcCICAAQazzAGoiCEEANgIAIABBqPMAaiABRSICOgAAAkAgAgRAQQAkBUEEQcDLBBAFIQMjBSEBQQAkBSABQQFxBEAQFyECBUEAJAVBGiADEAwjBSEBQQAkBSABQQFxRQRAIAMhAQwDCxAXIQIgAxBSIABBkO4CaigCACIDBEAgAxBSCwsgAEHQ5wFqKAIAIgMEQCADEFILIAcQtQIMAwsLIAggATYCACAAIAFBnYUDaiwAADoAFSAAQZi8A2pBAjYCACAAQai8A2pBADYCACAGQgA3AwAgAEGtvANqQQA6AAAgAEGsvANqQQA6AAAgAEHI8wBqQQA2AgAgAEGIvANqIgFCADcDACABQgA3AwggAEGcvANqIgFCADcCACABQQA6AAggAEGw8wBqQn83AwAgAEG48wBqQX82AgAgAEGwrQJqIgFCADcDACABQgA3AwggAUIANwMQIAFCADcDGCAAQcC8A2pBADYCACAAQeS8A2pBADYCACAAQb68A2pBADoAACAAQdDzAGpBADoAACAAQbimAWoiAUIANwMAIAFCADcDCCABQgA3AxAgAUIANwMYIAFCADcDICABQgA3AyggAUIANwMwIAFCADcDOCABQUBrQgA3AwAgAUIANwNIIAFCADcDUCABQgA3A1ggAUIANwNgIAFCADcDaCABQQA2AnAgAEHIvANqIgBCADcDACAAQgA3AwggAEIANwMQIABBADoAGA8LCyAFEIQBCyAEEI4BIAAQcCACEB4LjwgBC38jBCECIwRBMGokBCACQRBqIQogAkEIaiEHIAIiCUEYaiIFQgA3AgAgBUIANwIIQQAkBUEUIAAgBUEAEAchAiMFIQNBACQFAkAgA0EBcUUEQCACBH8gBUEEaiIGKAIAIgtBAWohAiAGIAI2AgAgAiAFQQhqIggoAgAiBEsEfyAFKAIMIgNBAEcgAiADS3EEf0EAJAUgCSADNgIAQQJBrPUCQdgbIAkQDiMFIQNBACQFIANBAXENBEEAJAVBFEGs9QIQDCMFIQNBACQFIANBAXENBCAIKAIA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IABBwJgBaiIaQgA3AwAgAEHoAGoiA0IANwMAIANCADcDCCADQgA3AxAgA0EANgIYIABB8ABqIgZBfzYCACABRQRAIABBwK4CakEANgIAIABBxK4CakEANgIAIABBuK4CakEANgIAIABBvK4CakEBNgIAIABByK4CakEAQfACEFQaIABBhK8BakEAQbT/ABBUGiAAQczMA2pBADoAACAAQbTJA2pBAEGUAxBUGiAAQbDJA2pBAjYCACAAQcjMA2pBADYCAAsgACABEIMBIAMoAgAiAiAFKAIAIghrIgFBAEgNASAGIABB+ABqIhIoAgAgCGsgBigCAGo2AgAgCEGAgAFKBEAgAUEASgRAIAAoAhAiAiACIAhqIAEQXRoLIAVBADYCACADIAE2AgAFIAIhAQsgAUGAgAJGBEBBACEBQYCAAiECBSAAKAIAIAAoAhAgAWpBgIACIAFrEF4hASADKAIAIgggAWohAiABQQBKBEAgAyACNgIABSAIIQILCyAAQewAaiIOIAJBYmoiAjYCACASIAUoAgAiCDYCACAIQX9qIAYoAgAiDGohCCAMQX9HBEAgDiACIAhIBH8gAgUgCAs2AgALIAFBf0YNASAAIABBBGoiDCAAQfAAaiITEKQCRQ0BIAAgDCATIABBhAFqIhsQowJFDQECQCADIQggBSEXIAYhGAsLIAQhDyAAQdDNA2ohECAAQeAAaiEJIABBBGohCiAAQaCWAWohICAAQRBqIRQgAEGIAmohISAAQaiYAWohFSAAQaSWAWohIiAAQaiWAWohDSAAQfQfaiEjIABBzABqIRwgAEHQAGohJCAAQcgAaiEdIABBxABqIRYgAEHYAGohGSAAQeA9aiElIABB3DxqISYgAEHwHmohJyAAQczbAGohKCAAQcjaAGohKSAAQYQBaiEqIABBsJgBaiErIABB8ABqISwgAEH0AGohLSAAQYABaiEuAkACQAJAA0ACQCAJIAkoAgAgECgCACIEcSICNgIAIAooAgAiASAOKAIATgRAA0ACQCABICwoAgAiAyASKAIAIgVqIgJIBEAgASACQX9qRw0BIAcoAgAgLSgCAEgNAQsgLiwAAA0DIAAgDCATEKQCRQ0GIAAgDCATIBsQowJFDQYgCigCACEBDAELCyAIKAIAIgQgAWsiAkEASA0BIBggBSABayADajYCACAB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NwIIIAJCADcCECACQgA3AhggAkEANgIgIABBoJYBaiAAQczNA2ooAgAiAkGAgIACSQR/IAIFQYCAgAILIABB0M0DaigCAHE2AgALIABBADYCOCAAQQhqIghBADYCACAAQQRqIgdBADYCACAAQcCYAWoiGkIANwMAIABB6ABqIgJCADcDACACQgA3AwggAkIANwMQIAJBADYCGCAAQX82AnAgAUUEQCAAQcCuAmpBADYCACAAQcSuAmpBADYCACAAQbiuAmpBADYCACAAQbyuAmpBATYCACAAQciuAmpBAEHwAhBUGiAAQYSvAWpBAEG0/wAQVBogAEHMzANqQQA6AAAgAEG0yQNqQQBBlAMQVBogAEGwyQNqQQI2AgAgAEHIzANqQQA2AgALIAAgARCDASACKAIAIgogBygCACIJayIDQQBIBEAPCyAJQYCAAUoEQCADQQBKBEAgACgCECIKIAogCWogAxBdGgsgB0EANgIAIAIgAzYCAAUgCiEDCyAAKAIAIABBEGoiDigCACADakGAgAIgA2sQXiEDIAIoAgAiCSADaiEKIANBAEoEQCACIAo2AgAgACAKQWJqNgJsBSAAIAlBYmo2AmwgA0F/RgRADwsLIAEEQCAAQczMA2osAAAEQCACIQkgACEKDAMLCyAAENsBBEAgAiEJIAAhCgUPCwsLIABB0M0DaiERIABB4ABqIQsgAEHsAGohFyAAQeQAaiEfIABByMwDaiESIABBwLECaiEMIABBsMkDaiEgIABBpJYBaiETIABBiAJqISEgAEH0H2ohIiAAQcwAaiEUIABB0ABqIRsgAEHIAGohFSAAQcQAaiEPIABB2ABqIRYgAEG8sQJqIRggAEG4sQJqIRkgAEHgPWohIyAAQdw8aiEkIABB8B5qISUgAEHM2wBqISYgAEHI2gBqIScgAEHMzQNqISggAEHMzANqIRwgAEGEAWohKSAAQbCYAWohKkEAIQECQAJAAkACQAJAAkACQAJAA0ACQCALIAsoAgAgESgCAHE2AgAgBygCACIEIBcoAgBKBEAgCSgCACIDIARrIgJBAEgNASAEQYCAAUoEQCACQQBKBEAgDigCACIDIAMgBGogAhBdGgsgB0EANgIAIAkgAjYCAAUgAyECCyAKKAIAIA4oAgAgAmpBgIACIAJrEF4hAiAJKAIAIgQgAmohAyAC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wQBqEJsECwwBCyABQcytAmosAABFDQEgASAAQRBqQQAgDRC1AQRAIAEgAUGIvANqKQMAQQAgASgCACgCEEEDcUG4AmoRAgAgBiQEQQEPBUGs9QJBARBkDAILAAsgASABQZC8A2opAwBBACABKAIAKAIQQQNxQbgCahECACAGJARBAQ8LIAYkBEEAC5oBAQJ/IABCADcDACAAQRBqIgMQtwIgACABNgIIIABBADYC3AEgAEHgwQBqQQA2AgAgAEEANgLMAUEAJAVBBEHYzQMQBSEBIwUhAkEAJAUgAkEBcQRAEBchAiADEIQBIAIQHgtBACQFQQcgASADEA0jBSECQQAkBSACQQFxRQRAIAAgATYCyAEPCxAXIQAgARBSIAMQhAEgABAeC4IDAgd/AX4gAEGQMmohBkGAgAQgAEGUMmoiAygCACICa0GAAkkEQCAAKAIQIgUgBSACaiAGKAIAIAJrIgIQUxogA0EANgIAIAYgAjYCACAAEOIBGiADKAIAIQILIAJBB2ogBigCAEsEQEEADwsgASAAQRBqIgcoAgAgAmpBBxDpASADIAMoAgBBB2o2AgAgARCmASEIIAFBBBC6AiICQX1qIAEQYSIJp2ohBCAJQgBRIAJFIARBAEhycgRAIABB6DFqQQA6AABBAA8LIAYoAgAgAygCACICayEFAkAgBEEASgRAIAEgBygCACACaiAFIARJBH8gBQUgBAsiAhDpASADIAMoAgAgAmo2AgAgBCACayICQQBKBEADQAJAIANBADYCACAGQQA2AgAgABDiAUUEQEEAIQAMAQsgASAHKAIAIAMoAgBqIAUgAkkEfyAFBSACCyIEEOkBIAMgAygCACAEajYCACACIARrIgJBAEoNAQwECwtBAA8LCwsgCCABELgCRgtOAQF/AkACQAJAIAJBmLwDaigCAEECaw4CAAECCyMEIQQjBEGAEGokBCACQcynAWooAgAaIAQkBEEADwsgACADIAJBsKcBahCdBA8LQQALRwAgAEHJiQNqLAAABEAPCyAAQZCFA2osAABFBEAPCyABQZi8A2ooAgBBAkcEQA8LIAFBkK4CakHMERBzBEAPCyABIAIQoQQLOAAgAEHJiQNqLAAABEAPCyABQeitAmouAQBBgQJHBEAPCyAAQZCFA2osAABFBEAPCyABIAIQogQLrQEBAn8jBCEDIwRBgBBqJAQgAkH0wQBqIgQgA0GAEBBpGgJAAkAgAkHwwQBqKAIAQX5xQQJHDQAgA0G3MEEEEJACBEAgA0G8MEEEEJACBEAgAyADQYAQEIsDDAIFQQAhAAsFQQAhAAsMAQsgAEGThQNqLAAARQRAIAMsAABBL0YEQEEAIQAMAgsgAkEgaiAEEJ8ERQRAQQAhAAwCCwsgAyABEJ4EIQALIAMkBCAAC5YBAQJ/IwQhAiMEQdAQaiQEIAEgAkHQAGoiA0GAEBBpGiAAIAMQtQNBf0cEQCACJARBAQ8LQYi8AygCAEERRgRAIAJBADYCRCACQdsANgJIIAJBQGtBATYCACACIAE2AgAFIAJBADYCRCACQRQ2AkggAkEANgIAIAJBQGtBAjYCACACIAE2AgRBrPUCQQEQZAsgAiQEQQALpwMBBH8gACgCAEEvRgRAQQAPCwJAIAAoAgAiAwRAIAAhAkEAIQADQCACQQRqIQQCQCADQS9GBEAgBCgCACIDRQ0EIANBL0cEQAJAIAQoAgBBLkYEQCACQQhqIgUoAgBBL0YEf0EBBSAFKAIARQshAyAEKAIAQS5GBEAgBSgCAEEuRgRAIAJBDGoiAigCAEEvRwRAIAIoAgAEQCAAQQFqIQIgAw0IIAIhAAwFCwsgAw0GDAMLCyAAQQFqIQIgA0UEQCACIQALBSAAQQFqIQALCwsLCyAEKAIAIgMEQCAEIQIMAQsLBUEAIQALCyABKAIAQS9GBEBBAA8FQQAhAyABIQILA0ACQAJAAkACQAJAIAIoAgAOLwACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsMAwsgAkEEaiIBKAIAQS5GBEAgAkEIaiIEKAIAQS9HBEAgBCgCAA0DCyADBEAgAkF8aigCAEEvRw0DCyAAQX9qIQALDAELIAJBBGohAQsgA0EBaiEDIAEhAgwBCwsgAEF/SgvHAgEEfwJAIwQhAiMEQdAQaiQEIAEgAkHQAGoiBUGAEBBpGgJAIABBqKkCaiIDLAAABEAgAxA9IgQEQCAAQaitAmogBCgCCDYCAAwCCyAAQaapAmosAABFBEAgAxCUASEBIAJBADYCRCACQdcANgJIDAMLCwsCQCAAQairAmoiAywAAARAIAMQPCIEBEAgAEGsrQJqIAQoAgg2AgAMAgsgAEGnqQJqLAAARQRAIAMQlAEhASACQQA2AkQgAkHYADYCSAwDCwsLIAUgAEGorQJqKAIAIABBrK0CaigCABDLAUUEQCACJAQPCyACQQA2AkQgAkHZADYCSCACIABBGGo2AgAgAkFAa0ECNgIAIAIgATYCBEGs9QJBCRBkIAIkBA8LIAIgAEEYajYCACACQUBrQQI2AgAgAiABNgIEQaz1AkEBEGQgAiQEC5gCAQV/AkAjBCECIwRB0CBqJAQgASACQdAQaiIGQYAQEGkaIABBkO4CaigCACIEEG5BAWohAyACQdAAaiIFIAQgA2ogAEGU7gJqKAIAIANrIgMQxgEaIAUgA2pBADoAACAEED0iA0UEQCAEEJQBIQEgAkEANgJEIAJB1wA2AkgMAQsgAygCCCEEIAUQPCIDRQRAIAUQlAEhASACQQA2AkQgAkHYADYCSAwBCyAGIAQgAygCCBDLAQRAIAJBADYCRCACQdkANgJIIAIgAEEYajYCACACQUBrQQI2AgAgAiABNgIEQaz1AkEJEGQLIAIkBA8LIAIgAEEYajYCACACQUBrQQI2AgAgAiABNgIEQaz1AkEBEGQgAiQEC78CAQV/AkAjBCECIwRB0BBqJAQgASACQdAAaiIFQYAQEGkaIABBrLwDaiwAAARAIAJBADYCRCACQdYANgJIDAELQYi8A0EANgIAIABBjLUDaiIDED0iBEUEQCADEJQBIQEgAkEANgJEIAJB1wA2AkggAiAAQRhqNgIAIAJBQGtBAjYCACACIAE2AgRBrPUCQQEQZCACJAQPCyAEKAIIIQZBiLwDQQA2AgAgAEGMtwNqIgMQPCIERQRAIAMQlAEhASACQQA2AkQgAkHYADYCSAwBCyAFIAYgBCgCCBDLAQRAIAJBADYCRCACQdkANgJIIAIgAEEYajYCACACQUBrQQI2AgAgAiABNgIEQaz1AkEJEGQLIAIkBA8LIAIgAEEYajYCACACQUBrQQI2AgAgAiABNgIEQaz1AkEDEGQgAiQECyUBAX8jBCEDIwRB0CBqJAQgASABIAIQ+AECQCADJARBAA8ACwALigQCCH8CfiMEIQQjBEEwaiQEIARBCGoiA0EAELgBQQAkBUEHIAAgAxAGIQIjBSEBQQAkBQJAIAFBAXFFBEAgAgR/QQAkBUEDIAMQThojBSEBQQAkBSABQQFxDQJBACQFQQMgAxBOrSMHrUIghoQhCSMFIQFBACQFIAFBAXENAkEAJAVBAyADEE6tIwetQiCGhCEKIwUhAUEAJAUgAUEBcQ0CIABBmDJqIQYgAEGgMmoiCCgCACEBIABBnDJqIgcgCqciBTYCACABIAVJBEAgAEGkMmooAgAiAkEARyACIAVJcQR/QQAkBSAEIAI2AgBBAkGs9QJB2BsgBBAOIwUhAUEAJAUgAUEBcQ0EQQAkBUEUQaz1AhAMIwUhAUEAJAUgAUEBcQ0EIAgoAgAhAiAHKAIABSABIQIgBQshASAGKAIAIAEgAkEgaiACQQJ2aiICSwR/IAEFIAIiAQsQVyIHRQRAQQAkBUEUQaz1AhAMIwUhAkEAJAUgAkEBcQ0ECyAGIAc2AgAgCCABNgIACyAGKAIAIQFBACQFQRIgAyABIAUQBxojBSEBQQAkBSABQQFxDQIgAEGoMmogAEHwMWopAwAgCX03AwBBAQVBAAshASADKAIAIgBFBEAgBCQEIAEPCyAAEFIgBCQEIAEPCwsQFyEBIAMoAgAiAEUEQCABEB4LIAAQUiABEB5BAAsYACAAKAIAQQJHBEBBAA8LIAAoAgRBf3MLtwwBAn8gAEEAIABrQT9xIABqIgI2AvABIAAgAkGAAWo2AvQBIAAgAkGgAWo2AvgBIAAgAkGoAWo2AvwBIAAgAUYiAwRAIABBACAAQYgCaiICa0E/cSACaiICNgL4AyAAIAJBgAFqNgL8AyAAIAJBoAFqNgKABCAAIAJBqAFqNgKEBCAAQQAgAEGQBGoiAmtBP3EgAmoiAjYCgAYgACACQYABajYChAYgACACQaABajYCiAYgACACQagBajYCjAYgAEGICGpBACAAQZgGaiICa0E/cSACaiICNgIAIABBjAhqIAJBgAFqNgIAIABBkAhqIAJBoAFqNgIAIABBlAhqIAJBqAFqNgIAIABBkApqQQAgAEGgCGoiAmtBP3EgAmoiAjYCACAAQZQKaiACQYABajYCACAAQZgKaiACQaABajYCACAAQZwKaiACQagBajYCACAAQZgMakEAIABBqApqIgJrQT9xIAJqIgI2AgAgAEGcDGogAkGAAWo2AgAgAEGgDGogAkGgAWo2AgAgAEGkDGogAkGoAWo2AgAgAEGgDmpBACAAQbAMaiICa0E/cSACaiICNgIAIABBpA5qIAJBgAFqNgIAIABBqA5qIAJBoAFqNgIAIABBrA5qIAJBqAFqNgIAIABBqBBqQQAgAEG4DmoiAmtBP3EgAmoiAjYCACAAQawQaiACQYABajYCACAAQbAQaiACQaABajYCACAAQbQQaiACQagBajYCAAUgAiABKALwAUGwARBTGiAAIAEoAoACNgKAAiAAIAEsAIQCOgCEAiAAQQAgAEGIAmoiAmtBP3EgAmoiAjYC+AMgACACQYABajYC/AMgACACQaABajYCgAQgACACQagBajYChAQgAiABKAL4A0GwARBTGiAAIAEoAogENgKIBCAAIAEsAIwEOgCMBCAAQQAgAEGQBGoiAmtBP3EgAmoiAjYCgAYgACACQYABajYChAYgACACQaABajYCiAYgACACQagBajYCjAYgAiABKAKABkGwARBTGiAAIAEoApAGNgKQBiAAIAEsAJQGOgCUBiAAQYgIakEAIABBmAZqIgJrQT9xIAJqIgI2AgAgAEGMCGogAkGAAWo2AgAgAEGQCGogAkGgAWo2AgAgAEGUCGogAkGoAWo2AgAgAiABQYgIaigCAEGwARBTGiAAQZgIaiABQZgIaigCADYCACAAQZwIaiABQZwIaiwAADoAACAAQZAKakEAIABBoAhqIgJrQT9xIAJqIgI2AgAgAEGUCmogAkGAAWo2AgAgAEGYCmogAkGgAWo2AgAgAEGcCmogAkGoAWo2AgAgAiABQZAKaigCAEGwARBTGiAAQaAKaiABQaAKaigCADYCACAAQaQKaiABQaQKaiwAADoAACAAQZgMakEAIABBqApqIgJrQT9xIAJqIgI2AgAgAEGcDGogAkGAAWo2AgAgAEGgDGogAkGgAWo2AgAgAEGkDGogAkGoAWo2AgAgAiABQZgMaigCAEGwARBTGiAAQagMaiABQagMaigCADYCACAAQawMaiABQawMaiwAADoAACAAQaAOakEAIABBsAxqIgJrQT9xIAJqIgI2AgAgAEGkDmogAkGAAWo2AgAgAEGoDmogAkGgAWo2AgAgAEGsDmogAkGoAWo2AgAgAiABQaAOaigCAEGwARBTGiAAQbAOaiABQbAOaigCADYCACAAQbQOaiABQbQOaiwAADoAACAAQagQakEAIABBuA5qIgJrQT9xIAJqIgI2AgAgAEGsEGogAkGAAWo2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ABggACACKQAgNwAgIAAgAikAKDcAKCAAIAIpADA3ADAgACACKQA4NwA4IAQgBCgCAEFAaiIANgIAIAMgBmohAyAFIAZrIgUNAAsMAQsgAiADIAUQUxogBCAEKAIAIAVqIgA2AgALQSAhBSAKQYABaiEDAkACQANAIAcoAgAgAGohAiAFQYABIABrIgZNDQEgAiADIAYQUxogBCAEKAIAIAZqNgIAIAkoAgAiACgCACECIAAgAkFAazYCACAAQQRqIgAgACgCACACQb9/S2o2AgAgCCAHKAIAEG0gBygCACIAQUBrIQIgACACKQAANwAAIAAgAikACDcACCAAIAIpABA3ABAgACACKQAYNwAYIAAgAikAIDcAICAAIAIpACg3ACggACACKQAwNwAwIAAgAikAODcAOCAEIAQoAgBBQGoiADYCACADIAZqIQMgBSAGayIFDQALDAELIAIgAyAFEFMaIAQgBCgCACAFaiIANgIAC0EgIQUgCkGgAWohAwJAAkADQCAHKAIAIABqIQIgBUGAASAAayIGTQ0BIAIgAyAGEFMaIAQgBCgCACAGajYCACAJKAIAIgAoAgAhAiAAIAJBQGs2AgAgAEEEaiIAIAAoAgAgAkG/f0tqNgIAIAggBygCABBtIAcoAgAiAEFAayECIAAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCAAIAIpACA3ACAgACACKQAoNwAoIAAgAikAMDcAMCAAIAIpADg3ADggBCAEKAIAQUBqIgA2AgAgAyAGaiEDIAUgBmsiBQ0ACwwBCyACIAMgBRBTGiAEIAQoAgAgBWoiADYCAAtBICEFIApBwAFqIQMCQAJAA0AgBygCACAAaiECIAVBgAEgAGsiBk0NASACIAMgBhBTGiAEIAQoAgAgBmo2AgAgCSgCACIAKAIAIQIgACACQUBrNgIAIABBBGoiACAAKAIAIAJBv39LajYCACAIIAcoAgAQbSAHKAIAIgBBQGshAiAAIAIpAAA3AAAgACACKQAINwAIIAAgAikAEDcAECAAIAIpABg3ABggACACKQAgNwAgIAAgAikAKDcAKCAAIAIpADA3ADAgACACKQA4NwA4IAQgBCgCAEFAaiIANgIAIAMgBmohAyAFIAZrIgUNAAsMAQsgAiADIAUQUxogBCAEKAIAIAVqIgA2AgALQSAhBSAKQeABaiEKAkACQANAAkAgBygCACAAaiEDIAVBgAEgAGsiAk0NACADIAogAhBTGiAEIAQoAgAgAmo2AgAgCSgCACIAKAIAIQMgACADQUBrNgIAIABBBGoiACAAKAIAIANBv39LajYCACAIIAcoAgAQbSAHKAIAIgBBQGshAyAAIAMpAAA3AAAgACADKQAINwAIIAAgAykAEDcAECAAIAMpABg3ABggACADKQAgNwAgIAAgAykAKDcAKCAAIAMpADA3ADAgACADKQA4NwA4IAQgBCgCAEFAaiIANgIAIAUgAmsiBUUNAiAKIAJqIQoMAQsLDAELIAggARDgASALJAQPCyADIAogBRBTGiAEIAQoAgAgBWo2AgAgCCABEOABIAskBAuwAgIEfwN+IABB6DFqIgYsAABFBEBBAA8LIABBqDJqIQUgAEGcMmohByAAQbAyaiEEA0AgBSkDACAHKAIArXwgBCkDAFgEQCAAEKQEDQELCyAGLAAARQRAIABBuDJqLAAARQRAQQAPCyAAKAIAIAQpAwBBABCcAUEADwsgBCkDACIIIAUpAwAiCVoEQCAIIAKtIgp8IAkgBygCAK18WARAIAEgAEGYMmooAgAgCCAJfadqIAIQUxogAyACNgIAIAQgBCkDACAKfDcDACAAQbgyakEBOgAAQQEPCwsgAEG4MmoiBSwAAARAIAAoAgAgCEEAEJwBIAVBADoAAAsgACgCACABIAIQ1AEiAEEASAR/IAZBADoAAEEABSADIAA2AgAgBCAEKQMAIACsfDcDAEEBCwv2BgEPf0GABCAAQcgWaiIOKAIAIgdrIQYgB0UgBiACS3IEfyABIQkgAgUgAEHIEmogB2ogASAGEFMaA0AgACADQYgCbGohDCAAIANBiAJsakHwAWohCCAAIANBiAJsakH4AWohDUHAACEKIABByBJqIANBBnRqIQsgACADQYgCbGpBgAJqIgcoAgAhBAJAAkADQCAIKAIAIARqIQUgCkGAASAEayIJTQ0BIAUgCyAJEFMaIAcgBygCACAJajYCACANKAIAIgQoAgAhBSAEIAVBQGs2AgAgBEEEaiIEIAQoAgAgBUG/f0tqNgIAIAwgCCgCABBtIAgoAgAiBEFAayEFIAQgBSkAADcAACAEIAUpAAg3AAggBCAFKQAQNwAQIAQgBSkAGDcAGCAEIAUpACA3ACAgBCAFKQAoNwAoIAQgBSkAMDcAMCAEIAUpADg3ADggByAHKAIAQUBqIgQ2AgAgCyAJaiELIAogCWsiCg0ACwwBCyAFIAsgChBTGiAHIAcoAgAgCmo2AgALIANBAWoiA0EIRw0ACyABIAZqIQlBACEHIAIgBmsLIgtB/wNLIQ9BACEEA0AgACAEQYgCbGohECAPBEAgACAEQYgCbGpB8AFqIQ0gACAEQYgCbGpB+AFqIREgCSAEQQZ0aiECIAshCiAAIARBiAJsakGAAmoiCCgCACEDA0BBwAAhBSACIQECQAJAA0AgDSgCACADaiEGIAVBgAEgA2siDE0NASAGIAEgDBBTGiAIIAgoAgAgDGo2AgAgESgCACIDKAIAIQYgAyAGQUBrNgIAIANBBGoiAyADKAIAIAZBv39LajYCACAQIA0oAgAQbSANKAIAIgNBQGshBiADIAYpAAA3AAAgAyAGKQAINwAIIAMgBikAEDcAECADIAYpABg3ABggAyAGKQAgNwAgIAMgBikAKDcAKCADIAYpADA3ADAgAyAGKQA4NwA4IAggCCgCAEFAaiIDNgIAIAEgDGohASAFIAxrIgUNACADIQELDAELIAYgASAFEFMaIAggCCgCACAFaiIBNgIACyACQYAEaiECIApBgHxqIgpB/wNLBEAgASEDDAELCwsgBEEBaiIEQQhJDQALIAtB/wNxIgFFBEAgDiABIAdqNgIADwsgAEHIEmogB2ogCSALIAFraiABEFMaIA4gASAHajYCAAu5CgEDfyAAQcAQakEAQfABEFQaIABBwBJqQQA2AgAgAEHEEmoiA0EAOgAAIABByBJqQQBBhAQQVBogAEG0EmoiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBDGoiASABKAIAQYCAhIACczYCACAAQQBB8AEQVBogAEEANgKAAiAAQQA6AIQCIABB9AFqIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEGIAmpBAEHwARBUGiAAQQA2AogEIABBADoAjAQgAEH8A2oiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBCGoiAiACKAIAQQFzNgIAIAFBDGoiASABKAIAQYCAgIACczYCACAAQZAEakEAQfABEFQaIABBADYCkAYgAEEAOgCUBiAAQYQGaiICKAIAIgFBrBEpAgA3AgAgAUG0ESkCADcCCCABQbwRKQIANwIQIAFBxBEpAgA3AhggAigCACIBIAEoAgBBoICgEHM2AgAgAUEIaiICIAIoAgBBAnM2AgAgAUEMaiIBIAEoAgBBgICAgAJzNgIAIABBmAZqQQBB8AEQVBogAEGYCGpBADYCACAAQZwIakEAOgAAIABBjAhqIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQhqIgIgAigCAEEDczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEGgCGpBAEHwARBUGiAAQaAKakEANgIAIABBpApqQQA6AAAgAEGUCmoiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBCGoiAiACKAIAQQRzNgIAIAFBDGoiASABKAIAQYCAgIACczYCACAAQagKakEAQfABEFQaIABBqAxqQQA2AgAgAEGsDGpBADoAACAAQZwMaiICKAIAIgFBrBEpAgA3AgAgAUG0ESkCADcCCCABQbwRKQIANwIQIAFBxBEpAgA3AhggAigCACIBIAEoAgBBoICgEHM2AgAgAUEIaiICIAIoAgBBBXM2AgAgAUEMaiIBIAEoAgBBgICAgAJzNgIAIABBsAxqQQBB8AEQVBogAEGwDmpBADYCACAAQbQOakEAOgAAIABBpA5qIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQhqIgIgAigCAEEGczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEG4DmpBAEHwARBUGiAAQbgQakEANgIA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BgYGaWkAdgBSYXJBcmNoaXZlAHZpAG9wZW4AaWlpaWlpAGdldEZpbGVIZWFkZXIAaWlpAHJlYWRGaWxlAGlpaWkAU3RhdGUAaQBlcnJDb2RlAHZpaWkAZXJyVHlwZQBBcmNIZWFkZXIAc3RhdGUAY29tbWVudABmbGFncwBBcmNGaWxlSGVhZGVyAG5hbWUAcGFja1NpemUAZGlpAHZpaWQAdW5wU2l6ZQBob3N0T1MAY3JjAHRpbWUAdW5wVmVyAG1ldGhvZABmaWxlQXR0cgAxM0FyY0ZpbGVIZWFkZXIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQA5QXJjSGVhZGVyAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFADVTdGF0ZQBFUlJfUFJPQ0VTUwBFUlJfUkVBRABFUlJfT1BFTgBQSzEwUmFyQXJjaGl2ZQBQMTBSYXJBcmNoaXZlADEwUmFyQXJjaGl2ZQBTRVQARU5EAENVUgA0RmlsZQB2b2lkAGJvb2wAY2hhcgBzaWduZWQgY2hhcgB1bnNpZ25lZCBjaGFyAHNob3J0AHVuc2lnbmVkIHNob3J0AGludAB1bnNpZ25lZCBpbnQAbG9uZwB1bnNpZ25lZCBsb25nAGZsb2F0AGRvdWJsZQBzdGQ6OnN0cmluZwBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZyBkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWVFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAE4xMGVtc2NyaXB0ZW4zdmFsRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQASERMUFRYXGBkaGxwdHh8gIREiIyQRJSYnKCkqKywRLS4vEBAwEBAQEBAQEDEyMxA0NRAQERERERERERERERERERERERERERERERERETYRERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE3ERERETgROTo7PD0+ERERERERERERERERERERERERERERERERERERERERERERERERERERERERET8QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBARQEERQkNERUZHSEkQEBBKS0xNThAQEE9QEBAQEFEQEBAQEBAQEBARERFSUxAQEBAQEBAQEBAQEREREVQQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAREVUQEBAQVhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBXEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBYWVpbEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFwQEBAQEBAQEBAQEBAQEBAQEABBusMACyD//////////////////////////////////////////wBB4sMACzb+//8H/v//BwAAAAAABCAE//9/////f//////////////////////////////////D/wMAH1AAQaLEAAukASAAAAAAAN88QNf///v///////////+///////////////////////8D/P////////////////////////8A/v///38C/v////8AAAAAAP+/tgD///8HBwAAAP8H//////////7/w////////////////+8f/uH/nwAA////////AOD///////////////8DAP//////BzAE/////P8fAAD///8BAEHOxQAL5AH9HwAAAAAAAPAD/3//////////7//f4f/P//7+7p/5///9xeOfWYCwz/8DAO6H+f///W3DhxkCXsD/PwDuv/v///3t478bAQDP/wAA7p/5///97eOfGcCwz/8CAOzHPdYYx//Dxx2BAMD/AADu3/3///3v498dYAPP/wAA7N/9///97+PfHWBAz/8GAOzf/f/////n312AAM//APzs/3/8///7L3+AX/8AAAwA/v////9//wc/IP8DAAAAAJYl8P6u7P87XyD/8wAAAAABAAAA/wMAAP/+////H/7/A////v///x8AQbrHAAuVAv///////3/5/wP//+fB//9/QP8z/////78g///////3////////////PX89//////89/////z1/Pf9//////////z3//////////4cAAAAA//8AAP////////////8fAP7//////////////////////////////////////////////////////////5////7//wf////////////HAQD/3w8A//8PAP//DwD/3w0A////////z///AYAQ/wMAAAAA/wP//////////////wD//////wf//////////z8A////H/8P/wHA/////z8fAP//////D////wP/AwAAAAD///8P/////////3/+/x8A/wP/A4AAQdrJAAsw////////7//vD/8DAAAAAP//////8////////7//AwD///////8/AP/j//////8/AEGXygALG95vAP///////////////////////////////wBBusoACyD//z8//////z8//6r///8/////////31/cH88P/x/cHwBB6MoACwYCgAAA/x8AQfrKAAsShPwvPlC9//PgQwAA//////8BAEGwywALUMD///////8DAAD//////3///////3//////////////////////H3gMAP////+/IP////////+AAAD//38Af39/f39/f3//////AAAAAACAAEGazAALV+AAAAD+Az4f/v///////////3/g/v/////////////34P////8//v////////////9/AAD///8HAAAAAAAA////////////////////////////////PwBB+swACzL/////////////////////////////////HwAAAAAAAP//////////////////////HwBBtM0ACzz//////z//H////w8AAP//////f/CP////gP////////////8AAAAAgP/8////////////////eQ8A/wcAQfnNAAtn/7v3////AAAA////////DwD//////////w8A/wMAAPwI//////8H/////wcA////H/////////f/AID/AwAAAAD///////9/AP8//wP//38E/////////38FAAA4//88AH5+fgB/fwBB8s4AC4gB//////8H/wP//////////////////////////w8A//9/+P//////D/////////////////8//////////////////wMAAAAAfwD44P/9f1/b/////////////////wMAAAD4////////////////PwAA///////////8////////AAAAAAD/DwBBiNAAC1Lf/////////////////////x8AAP8D/v//B/7//wfA/////////////3/8/PwcAAAAAP/v//9///+3/z//PwAAAAD///////////////////8HAEHi0AALB////////x8AQYrRAAtG////H////////wEAAAAAAP///38AAP///wcAAAAAAAD///8//////w//PgAAAAAA/////////////////////////z//AwBB2tEACws//f////+/kf//PwBB+tEACwj//z8A////AwBBitIACwj/////////wABBmtIACxBv8O/+//8PAAAAAAD///8fAEG60gALD////////z8A//8/AP//BwBB2tIACwr///////////8BAEH60gALKP//////////PwAAAMD/AAD8////////AQAA////Af8D////////x/8AQarTAAsM//////////8eAP8DAEHK0wALHv///////z8A/wMAAAAAAAD/////////////////fwBB+tMACw3///////////////8HAEGa1AALBv//////fwBButQACwj/////////AQBB2tQACxT//////////x8A//////9/AAD4/wBB+tQACwEDAEGa1QALmAH/////////////3///////////32Te/+vv/////////7/n39////97X/z9//////////////////////////////////////////////////////8//////f//9/////f//9/////f//9/////f/////3////9///3z////////+////+W/vcKhOqWqpb3917/+/8P7vv/DwBButYAC+sPVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAABMQ19BTEwATENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVMATEFORwBDLlVURi04AFBPU0lYAE1VU0xfTE9DUEFUSAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAQa3mAAshEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAEHe5gALAQsAQefmAAsYEQAKChEREQAKAAACAAkLAAAACQALAAALAEGY5wALAQwAQaTnAAsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEHS5wALAQ4AQd7nAAsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGM6AALARAAQZjoAAseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEHP6AALDhIAAAASEhIAAAAAAAAJAEGA6QALAQsAQYzpAAsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEG66QALAQwAQcbpAAtdDAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAwMTIzNDU2Nzg5QUJDREVGLgBDLlVURi04AEGs6gALGkMAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAEHO6gALGhEADwoREREDCgcAARMJCwsAAAkGCwAACwAGAEH/6gALAQsAQYrrAAsWCgoAAAAACgAAAgAJCwAAAAkACwAACwBBuesACwEMAEHF6wALFQwAAAAADAAAAAAJDAAAAAAADAAADABB8+sACwEOAEH/6wALFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBrewACwEQAEG57AALHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB8OwACw4SAAAAEhISAAAAAAAACQBBoe0ACwELAEGt7QALFQoAAAAACgAAAAAJCwAAAAAACwAACwBB2+0ACwEMAEHn7QALvAcMAAAAAAwAAAAACQwAAAAAAAwAAAwAACUqcwAobnVsbCkAIwArAC0AIAAwAEwAAGpMTEwAagAAAAAAamoAAAAAagAAaiUlJXMlcyVzJXMlcyouKiVjJWMAYmFzaWNfc3RyaW5nAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlczogJXMAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0aW5nAHVuY2F1Z2h0AFN0OWV4Y2VwdGlvbgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBwdGhyZWFkX29uY2UgZmFpbHVyZSBpbiBfX2N4YV9nZXRfZ2xvYmFsc19mYXN0KCkAY2Fubm90IGNyZWF0ZSBwdGhyZWFkIGtleSBmb3IgX19jeGFfZ2V0X2dsb2JhbHMoKQBjYW5ub3QgemVybyBvdXQgdGhyZWFkIHZhbHVlIGZvciBfX2N4YV9nZXRfZ2xvYmFscygpAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZAB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgdGhyZXcgYW4gZXhjZXB0aW9uAHN0ZDo6YmFkX2FsbG9jAFN0OWJhZF9hbGxvYwBTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAGwAbQBmAGQATjEwX19jeHhhYml2MTE2X19lbnVtX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQ==";

  class ResourceLoaderPlugin {
      /**
       * The type of file this plugin handles.
       * @return The type of file.
       */
      getType() {
          return 'none';
      }
      async loadFile(url) {
          return null;
      }
  }

  // <!-- prettier-ignore-start -->
  /* eslint-disable require-jsdoc */

  const Module = {};

  const WorkerScope = {};

  //--------------------unpackBridge.js----------------------------
  !(function (t, e) {
    // The following code has been _carefully_ modified by hand.
    // There were various cases for in what context the code might
    // be run, and I removed all but the webworker case.
    // There was code to handle loading in a nodeJS context, that tried to import("fs")
    // WebPack kepts tripping up on that code in its static analysis of the code, so
    // I carefully removed it.
    t.unpackBridge = e(t.fs);
  })(WorkerScope, function (t) {
    return (function (t) {
      var e = {};
      function r(n) {
        if (e[n]) return e[n].exports
        var i = (e[n] = { i: n, l: !1, exports: {} });
        return t[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports
      }
      return (
        (r.m = t),
        (r.c = e),
        (r.d = function (t, e, n) {
          r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n });
        }),
        (r.r = function (t) {
          'undefined' != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(t, '__esModule', { value: !0 });
        }),
        (r.t = function (t, e) {
          if ((1 & e && (t = r(t)), 8 & e)) return t
          if (4 & e && 'object' == typeof t && t && t.__esModule) return t
          var n = Object.create(null);
          if ((r.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: t }), 2 & e && 'string' != typeof t))
            for (var i in t)
              r.d(
                n,
                i,
                function (e) {
                  return t[e]
                }.bind(null, i)
              );
          return n
        }),
        (r.n = function (t) {
          var e =
            t && t.__esModule
              ? function () {
                  return t.default
                }
              : function () {
                  return t
                };
          return r.d(e, 'a', e), e
        }),
        (r.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e)
        }),
        (r.p = ''),
        r((r.s = 2))
      )
    })([
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 });
        const n = r(1),
          i = {
            0: 'ERAR_SUCCESS',
            10: 'ERAR_END_ARCHIVE',
            11: 'ERAR_NO_MEMORY',
            12: 'ERAR_BAD_DATA',
            13: 'ERAR_BAD_ARCHIVE',
            14: 'ERAR_UNKNOWN_FORMAT',
            15: 'ERAR_EOPEN',
            16: 'ERAR_ECREATE',
            17: 'ERAR_ECLOSE',
            18: 'ERAR_EREAD',
            19: 'ERAR_EWRITE',
            20: 'ERAR_SMALL_BUF',
            21: 'ERAR_UNKNOWN',
            22: 'ERAR_MISSING_PASSWORD',
            23: 'ERAR_EREFERENCE',
            24: 'ERAR_BAD_PASSWORD',
          },
          o = {
            0: 'Success',
            11: 'Not enough memory',
            12: 'Archive header or data are damaged',
            13: 'File is not RAR archive',
            14: 'Unknown archive format',
            15: 'File open error',
            16: 'File create error',
            17: 'File close error',
            18: 'File read error',
            19: 'File write error',
            20: 'Buffer for archive comment is too small, comment truncated',
            21: 'Unknown error',
            22: 'Password for encrypted file or header is not specified',
            23: 'Cannot open file source for reference record',
            24: 'Wrong password is specified',
          };
        class s {
          constructor(t = '') {
  (this._password = t), (this._archive = null);
          }
          getFileList() {
            let t,
              [e, r] = this.openArc(!0);
            if ('SUCCESS' !== e.state) t = [e, null];
            else {
              let e,
                n,
                i = [];
              for (; ([e, n] = this.processNextFile(() => !0)), 'SUCCESS' === e.state; ) i.push(n.fileHeader);
              t = 'ERAR_END_ARCHIVE' !== e.reason ? [e, null] : [{ state: 'SUCCESS' }, { arcHeader: r, fileHeaders: i }];
            }
            return this.closeArc(), t
          }
          extractAll() {
            let t,
              [e, r] = this.openArc(!1);
            if ('SUCCESS' !== e.state) t = [e, null];
            else {
              let e,
                n,
                i = [];
              for (; ([e, n] = this.processNextFile(() => !1)), 'SUCCESS' === e.state; ) i.push(n);
              t = 'ERAR_END_ARCHIVE' !== e.reason ? [e, null] : [{ state: 'SUCCESS' }, { arcHeader: r, files: i }];
            }
            return this.closeArc(), t
          }
          extractFiles(t, e) {
            let r,
              [n, i] = this.openArc(!1, e),
              o = {};
            for (let e = 0; e < t.length; ++e) o[t[e]] = e;
            if ('SUCCESS' !== n.state) r = [n, null];
            else {
              let e,
                n,
                s = Array(t.length).fill(null),
                u = 0;
              for (;;) {
                let r = !1,
                  i = null;
                if (
                  (([e, n] = this.processNextFile((t) => (t in o ? ((i = o[t]), !1) : ((r = !0), !0)))),
                  'SUCCESS' !== e.state)
                )
                  break
                if (!r && ((s[i] = n), ++u === t.length)) {
                  e.reason = 'ERAR_END_ARCHIVE';
                  break
                }
              }
              r = 'ERAR_END_ARCHIVE' !== e.reason ? [e, null] : [{ state: 'SUCCESS' }, { arcHeader: i, files: s }];
            }
            return this.closeArc(), r
          }
          fileCreated(t) {}
          close(t) {
            this._lastFileContent = this.closeFile(t);
          }
          openArc(t, e) {
  (n.Ext.current = this), (this._archive = new unpack.RarArchive());
            let r,
              i = this._archive.open(this._filePath, e || this._password, t);
            return (
              (r =
                0 !== i.state.errCode
                  ? [this.getFailInfo(i.state.errCode, i.state.errType), null]
                  : [
                      { state: 'SUCCESS' },
                      {
                        comment: i.comment,
                        flags: {
                          volume: 0 != (1 & i.flags),
                          lock: 0 != (4 & i.flags),
                          solid: 0 != (8 & i.flags),
                          authInfo: 0 != (32 & i.flags),
                          recoveryRecord: 0 != (64 & i.flags),
                          headerEncrypted: 0 != (128 & i.flags),
                        },
                      },
                    ]),
              (n.Ext.current = null),
              r
            )
          }
          processNextFile(t) {
            let e;
            n.Ext.current = this;
            let r = this._archive.getFileHeader(),
              i = [{ state: 'SUCCESS' }, null];
            if (0 === r.state.errCode) {
              let e = t(r.name);
              this._lastFileContent = null;
              let n = this._archive.readFile(e);
              0 === n.errCode ||
                e ||
                ((i[0] = this.getFailInfo(n.errCode, n.errType)),
                22 === n.errCode ? (n = this._archive.readFile(!0)) : (n.errCode = 0)),
                0 === n.errCode
                  ? (i[1] = this._lastFileContent)
                  : ((r.state.errCode = n.errCode), (r.state.errType = n.errType)),
                (this._lastFileContent = null);
            }
            return (
              (e =
                0 !== r.state.errCode
                  ? [this.getFailInfo(r.state.errCode, r.state.errType), null]
                  : [
                      { state: 'SUCCESS' },
                      {
                        fileHeader: {
                          name: r.name,
                          flags: {
                            encrypted: 0 != (4 & r.flags),
                            solid: 0 != (16 & r.flags),
                            directory: 0 != (32 & r.flags),
                          },
                          packSize: r.packSize,
                          unpSize: r.unpSize,
                          crc: r.crc,
                          time: (function (t) {
                            const e = [5, 6, 5, 5, 4, 7];
                            let r = [];
                            for (let n of e) r.push(t & ((1 << n) - 1)), (t >>= n);
                            let n = (t) => (t < 10 ? '0' + t : '' + t);
                            return (
                              `${1980 + (r = r.reverse())[0]}-${n(r[1])}-${n(r[2])}` +
                              `T${n(r[3])}:${n(r[4])}:${n(2 * r[5])}.000`
                            )
                          })(r.time),
                          unpVer: `${Math.floor(r.unpVer / 10)}.${r.unpVer % 10}`,
                          method: (function (t) {
                            return (
                              { 48: 'Storing', 49: 'Fastest', 50: 'Fast', 51: 'Normal', 52: 'Good', 53: 'Best' }[t] ||
                              'Unknown'
                            )
                          })(r.method),
                        },
                        extract: i,
                      },
                    ]),
              (n.Ext.current = null),
              e
            )
          }
          closeArc() {
  (n.Ext.current = this), this._archive.delete(), (n.Ext.current = null), (this._archive = null);
          }
          getFailInfo(t, e) {
            return { state: 'FAIL', reason: i[t], msg: o[t] }
          }
        }
  (s._current = null), (e.Extractor = s);
      },
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 }), (e.Ext = { current: null });
      },
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 }),
          (function (t) {
            for (var r in t) e.hasOwnProperty(r) || (e[r] = t[r]);
          })(r(3));
        var n = r(1);
        e.Ext = n.Ext;
      },
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 });
        const n = r(4),
          i = r(6)
        ;(e.createExtractorFromData = function (t, e = '') {
          return new n.DataExtractor(t, e)
        }),
          (e.createExtractorFromFile = function (t, e = '', r = '') {
            return new i.FileExtractor(t, e, r)
          });
      },
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 });
        const n = r(5),
          i = r(0);
        e.DataExtractor = class extends i.Extractor {
          constructor(t, e) {
            super(e), (this.dataFiles = {}), (this.dataFileMap = {}), (this.currentFd = 1);
            let r = { file: new n.DataFile(new Uint8Array(t)), fd: this.currentFd++ }
            ;(this._filePath = '_defaultUnrarJS_.rar'),
              (this.dataFiles[this._filePath] = r),
              (this.dataFileMap[r.fd] = this._filePath);
          }
          open(t) {
            let e = this.dataFiles[t];
            return e ? e.fd : 0
          }
          create(t) {
            let e = this.currentFd++;
            return (this.dataFiles[t] = { file: new n.DataFile(), fd: this.currentFd++ }), (this.dataFileMap[e] = t), e
          }
          closeFile(t) {
            let e = this.dataFiles[this.dataFileMap[t]];
            if (!e) return null
            let r = e.file.readAll();
            return (
              1 !== t ? (delete this.dataFiles[this.dataFileMap[t]], delete this.dataFileMap[t]) : e.file.seek(0, 'SET'),
              r
            )
          }
          read(t, e, r) {
            let n = this.dataFiles[this.dataFileMap[t]];
            if (!n) return -1
            let i = n.file.read(r);
            return null === i ? -1 : (unpack.HEAPU8.set(i, e), i.byteLength)
          }
          write(t, e, r) {
            let n = this.dataFiles[this.dataFileMap[t]];
            return !!n && (n.file.write(unpack.HEAPU8.slice(e, e + r)), !0)
          }
          tell(t) {
            let e = this.dataFiles[this.dataFileMap[t]];
            return e ? e.file.tell() : -1
          }
          seek(t, e, r) {
            let n = this.dataFiles[this.dataFileMap[t]];
            return !!n && n.file.seek(e, r)
          }
        };
      },
      function (t, e, r) {
        Object.defineProperty(e, '__esModule', { value: !0 });
        e.DataFile = class {
          constructor(t) {
  (this.buffers = []),
              (this.pos = 0),
              (this.size = 0),
              t && (this.buffers.push(t), (this.size = t.byteLength), (this.pos = 0));
          }
          read(t) {
            if ((this.flatten(), t + this.pos > this.size)) return null
            let e = this.pos;
            return (this.pos += t), this.buffers[0].slice(e, this.pos)
          }
          readAll() {
            return this.flatten(), this.buffers[0]
          }
          write(t) {
            return this.buffers.push(t), (this.size += t.byteLength), (this.pos += t.byteLength), !0
          }
          tell() {
            return this.pos
          }
          seek(t, e) {
            let r = this.pos;
            return (
              'SET' === e ? (r = t) : 'CUR' === e ? (r += t) : (r = this.size - t),
              !(r < 0 || r > this.size || ((this.pos = r), 0))
            )
          }
          flatten() {
            if (this.buffers.length <= 1) return
            let t = new Uint8Array(this.size),
              e = 0;
            for (let r of this.buffers) t.set(r, e), (e += r.byteLength);
            this.buffers = [t];
          }
        };
      },
      function (t, e, r) {
  (function (t) {
          Object.defineProperty(e, '__esModule', { value: !0 });
          const n = r(12),
            i = r(13),
            o = r(0);
          e.FileExtractor = class extends o.Extractor {
            constructor(t, e, r) {
              super(r), (this._filePath = t), (this.fileMap = {}), (this._target = e);
            }
            open(t) {
              let e = n.openSync(t, 'r');
              return (this.fileMap[e] = { size: n.fstatSync(e).size, pos: 0, name: t }), e
            }
            create(t) {
              let e = i.join(this._target, t);
              i.parse(e)
                .dir.split('/')
                .reduce((t, e) => ((t += e + '/'), n.existsSync(t) || n.mkdirSync(t), t), '');
              let r = n.openSync(e, 'w');
              return (this.fileMap[r] = { size: 0, pos: 0, name: t }), r
            }
            closeFile(t) {
              return delete this.fileMap[t], n.closeSync(t), null
            }
            read(e, r, i) {
              let o = this.fileMap[e],
                s = new t(i),
                u = n.readSync(e, s, 0, i, o.pos);
              return unpack.HEAPU8.set(s, r), (o.pos += u), u
            }
            write(e, r, i) {
              let o = this.fileMap[e],
                s = n.writeSync(e, new t(unpack.HEAPU8.subarray(r, r + i)), 0, i);
              return (o.pos += s), (o.size += s), s === i
            }
            tell(t) {
              return this.fileMap[t].pos
            }
            seek(t, e, r) {
              let n = this.fileMap[t],
                i = n.pos;
              return (
                'SET' === r ? (i = 0) : 'END' === r && (i = n.size), !((i += e) < 0 || i > n.size || ((n.pos = i), 0))
              )
            }
          };
        }.call(this, r(7).Buffer));
      },
      function (t, e, r) {
  (function (t) {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          var n = r(9),
            i = r(10),
            o = r(11);
          function s() {
            return a.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
          }
          function u(t, e) {
            if (s() < e) throw new RangeError('Invalid typed array length')
            return (
              a.TYPED_ARRAY_SUPPORT
                ? ((t = new Uint8Array(e)).__proto__ = a.prototype)
                : (null === t && (t = new a(e)), (t.length = e)),
              t
            )
          }
          function a(t, e, r) {
            if (!(a.TYPED_ARRAY_SUPPORT || this instanceof a)) return new a(t, e, r)
            if ('number' == typeof t) {
              if ('string' == typeof e)
                throw new Error('If encoding is specified then the first argument must be a string')
              return l(this, t)
            }
            return f(this, t, e, r)
          }
          function f(t, e, r, n) {
            if ('number' == typeof e) throw new TypeError('"value" argument must not be a number')
            return 'undefined' != typeof ArrayBuffer && e instanceof ArrayBuffer
              ? (function (t, e, r, n) {
                  if ((e.byteLength, r < 0 || e.byteLength < r)) throw new RangeError("'offset' is out of bounds")
                  if (e.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds")
                  e =
                    void 0 === r && void 0 === n
                      ? new Uint8Array(e)
                      : void 0 === n
                      ? new Uint8Array(e, r)
                      : new Uint8Array(e, r, n);
                  a.TYPED_ARRAY_SUPPORT ? ((t = e).__proto__ = a.prototype) : (t = c(t, e));
                  return t
                })(t, e, r, n)
              : 'string' == typeof e
              ? (function (t, e, r) {
  ('string' == typeof r && '' !== r) || (r = 'utf8');
                  if (!a.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding')
                  var n = 0 | g(e, r),
                    i = (t = u(t, n)).write(e, r);
                  i !== n && (t = t.slice(0, i));
                  return t
                })(t, e, r)
              : (function (t, e) {
                  if (a.isBuffer(e)) {
                    var r = 0 | p(e.length);
                    return 0 === (t = u(t, r)).length ? t : (e.copy(t, 0, 0, r), t)
                  }
                  if (e) {
                    if (('undefined' != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer) || 'length' in e)
                      return 'number' != typeof e.length ||
                        (function (t) {
                          return t != t
                        })(e.length)
                        ? u(t, 0)
                        : c(t, e)
                    if ('Buffer' === e.type && o(e.data)) return c(t, e.data)
                  }
                  throw new TypeError(
                    'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
                  )
                })(t, e)
          }
          function h(t) {
            if ('number' != typeof t) throw new TypeError('"size" argument must be a number')
            if (t < 0) throw new RangeError('"size" argument must not be negative')
          }
          function l(t, e) {
            if ((h(e), (t = u(t, e < 0 ? 0 : 0 | p(e))), !a.TYPED_ARRAY_SUPPORT)) for (var r = 0; r < e; ++r) t[r] = 0;
            return t
          }
          function c(t, e) {
            var r = e.length < 0 ? 0 : 0 | p(e.length);
            t = u(t, r);
            for (var n = 0; n < r; n += 1) t[n] = 255 & e[n];
            return t
          }
          function p(t) {
            if (t >= s())
              throw new RangeError(
                'Attempt to allocate Buffer larger than maximum size: 0x' + s().toString(16) + ' bytes'
              )
            return 0 | t
          }
          function g(t, e) {
            if (a.isBuffer(t)) return t.length
            if (
              'undefined' != typeof ArrayBuffer &&
              'function' == typeof ArrayBuffer.isView &&
              (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
            )
              return t.byteLength
            'string' != typeof t && (t = '' + t);
            var r = t.length;
            if (0 === r) return 0
            for (var n = !1; ; )
              switch (e) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return r
                case 'utf8':
                case 'utf-8':
                case void 0:
                  return k(t).length
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return 2 * r
                case 'hex':
                  return r >>> 1
                case 'base64':
                  return j(t).length
                default:
                  if (n) return k(t).length
                  ;(e = ('' + e).toLowerCase()), (n = !0);
              }
          }
          function d(t, e, r) {
            var n = t[e]
            ;(t[e] = t[r]), (t[r] = n);
          }
          function y(t, e, r, n, i) {
            if (0 === t.length) return -1
            if (
              ('string' == typeof r
                ? ((n = r), (r = 0))
                : r > 2147483647
                ? (r = 2147483647)
                : r < -2147483648 && (r = -2147483648),
              (r = +r),
              isNaN(r) && (r = i ? 0 : t.length - 1),
              r < 0 && (r = t.length + r),
              r >= t.length)
            ) {
              if (i) return -1
              r = t.length - 1;
            } else if (r < 0) {
              if (!i) return -1
              r = 0;
            }
            if (('string' == typeof e && (e = a.from(e, n)), a.isBuffer(e))) return 0 === e.length ? -1 : w(t, e, r, n, i)
            if ('number' == typeof e)
              return (
                (e &= 255),
                a.TYPED_ARRAY_SUPPORT && 'function' == typeof Uint8Array.prototype.indexOf
                  ? i
                    ? Uint8Array.prototype.indexOf.call(t, e, r)
                    : Uint8Array.prototype.lastIndexOf.call(t, e, r)
                  : w(t, [e], r, n, i)
              )
            throw new TypeError('val must be string, number or Buffer')
          }
          function w(t, e, r, n, i) {
            var o,
              s = 1,
              u = t.length,
              a = e.length;
            if (
              void 0 !== n &&
              ('ucs2' === (n = String(n).toLowerCase()) || 'ucs-2' === n || 'utf16le' === n || 'utf-16le' === n)
            ) {
              if (t.length < 2 || e.length < 2) return -1
              ;(s = 2), (u /= 2), (a /= 2), (r /= 2);
            }
            function f(t, e) {
              return 1 === s ? t[e] : t.readUInt16BE(e * s)
            }
            if (i) {
              var h = -1;
              for (o = r; o < u; o++)
                if (f(t, o) === f(e, -1 === h ? 0 : o - h)) {
                  if ((-1 === h && (h = o), o - h + 1 === a)) return h * s
                } else -1 !== h && (o -= o - h), (h = -1);
            } else
              for (r + a > u && (r = u - a), o = r; o >= 0; o--) {
                for (var l = !0, c = 0; c < a; c++)
                  if (f(t, o + c) !== f(e, c)) {
                    l = !1;
                    break
                  }
                if (l) return o
              }
            return -1
          }
          function E(t, e, r, n) {
            r = Number(r) || 0;
            var i = t.length - r;
            n ? (n = Number(n)) > i && (n = i) : (n = i);
            var o = e.length;
            if (o % 2 != 0) throw new TypeError('Invalid hex string')
            n > o / 2 && (n = o / 2);
            for (var s = 0; s < n; ++s) {
              var u = parseInt(e.substr(2 * s, 2), 16);
              if (isNaN(u)) return s
              t[r + s] = u;
            }
            return s
          }
          function v(t, e, r, n) {
            return z(k(e, t.length - r), t, r, n)
          }
          function A(t, e, r, n) {
            return z(
              (function (t) {
                for (var e = [], r = 0; r < t.length; ++r) e.push(255 & t.charCodeAt(r));
                return e
              })(e),
              t,
              r,
              n
            )
          }
          function _(t, e, r, n) {
            return A(t, e, r, n)
          }
          function b(t, e, r, n) {
            return z(j(e), t, r, n)
          }
          function m(t, e, r, n) {
            return z(
              (function (t, e) {
                for (var r, n, i, o = [], s = 0; s < t.length && !((e -= 2) < 0); ++s)
                  (r = t.charCodeAt(s)), (n = r >> 8), (i = r % 256), o.push(i), o.push(n);
                return o
              })(e, t.length - r),
              t,
              r,
              n
            )
          }
          function R(t, e, r) {
            return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r))
          }
          function S(t, e, r) {
            r = Math.min(t.length, r);
            for (var n = [], i = e; i < r; ) {
              var o,
                s,
                u,
                a,
                f = t[i],
                h = null,
                l = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1;
              if (i + l <= r)
                switch (l) {
                  case 1:
                    f < 128 && (h = f);
                    break
                  case 2:
                    128 == (192 & (o = t[i + 1])) && (a = ((31 & f) << 6) | (63 & o)) > 127 && (h = a);
                    break
                  case 3:
  (o = t[i + 1]),
                      (s = t[i + 2]),
                      128 == (192 & o) &&
                        128 == (192 & s) &&
                        (a = ((15 & f) << 12) | ((63 & o) << 6) | (63 & s)) > 2047 &&
                        (a < 55296 || a > 57343) &&
                        (h = a);
                    break
                  case 4:
  (o = t[i + 1]),
                      (s = t[i + 2]),
                      (u = t[i + 3]),
                      128 == (192 & o) &&
                        128 == (192 & s) &&
                        128 == (192 & u) &&
                        (a = ((15 & f) << 18) | ((63 & o) << 12) | ((63 & s) << 6) | (63 & u)) > 65535 &&
                        a < 1114112 &&
                        (h = a);
                }
              null === h
                ? ((h = 65533), (l = 1))
                : h > 65535 && ((h -= 65536), n.push(((h >>> 10) & 1023) | 55296), (h = 56320 | (1023 & h))),
                n.push(h),
                (i += l);
            }
            return (function (t) {
              var e = t.length;
              if (e <= T) return String.fromCharCode.apply(String, t)
              var r = '',
                n = 0;
              for (; n < e; ) r += String.fromCharCode.apply(String, t.slice(n, (n += T)));
              return r
            })(n)
          }
  (e.Buffer = a),
            (e.SlowBuffer = function (t) {
  +t != t && (t = 0);
              return a.alloc(+t)
            }),
            (e.INSPECT_MAX_BYTES = 50),
            (a.TYPED_ARRAY_SUPPORT =
              void 0 !== t.TYPED_ARRAY_SUPPORT
                ? t.TYPED_ARRAY_SUPPORT
                : (function () {
                    try {
                      var t = new Uint8Array(1);
                      return (
                        (t.__proto__ = {
                          __proto__: Uint8Array.prototype,
                          foo: function () {
                            return 42
                          },
                        }),
                        42 === t.foo() && 'function' == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
                      )
                    } catch (t) {
                      return !1
                    }
                  })()),
            (e.kMaxLength = s()),
            (a.poolSize = 8192),
            (a._augment = function (t) {
              return (t.__proto__ = a.prototype), t
            }),
            (a.from = function (t, e, r) {
              return f(null, t, e, r)
            }),
            a.TYPED_ARRAY_SUPPORT &&
              ((a.prototype.__proto__ = Uint8Array.prototype),
              (a.__proto__ = Uint8Array),
              'undefined' != typeof Symbol &&
                Symbol.species &&
                a[Symbol.species] === a &&
                Object.defineProperty(a, Symbol.species, { value: null, configurable: !0 })),
            (a.alloc = function (t, e, r) {
              return (function (t, e, r, n) {
                return (
                  h(e),
                  e <= 0
                    ? u(t, e)
                    : void 0 !== r
                    ? 'string' == typeof n
                      ? u(t, e).fill(r, n)
                      : u(t, e).fill(r)
                    : u(t, e)
                )
              })(null, t, e, r)
            }),
            (a.allocUnsafe = function (t) {
              return l(null, t)
            }),
            (a.allocUnsafeSlow = function (t) {
              return l(null, t)
            }),
            (a.isBuffer = function (t) {
              return !(null == t || !t._isBuffer)
            }),
            (a.compare = function (t, e) {
              if (!a.isBuffer(t) || !a.isBuffer(e)) throw new TypeError('Arguments must be Buffers')
              if (t === e) return 0
              for (var r = t.length, n = e.length, i = 0, o = Math.min(r, n); i < o; ++i)
                if (t[i] !== e[i]) {
  (r = t[i]), (n = e[i]);
                  break
                }
              return r < n ? -1 : n < r ? 1 : 0
            }),
            (a.isEncoding = function (t) {
              switch (String(t).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return !0
                default:
                  return !1
              }
            }),
            (a.concat = function (t, e) {
              if (!o(t)) throw new TypeError('"list" argument must be an Array of Buffers')
              if (0 === t.length) return a.alloc(0)
              var r;
              if (void 0 === e) for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
              var n = a.allocUnsafe(e),
                i = 0;
              for (r = 0; r < t.length; ++r) {
                var s = t[r];
                if (!a.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers')
                s.copy(n, i), (i += s.length);
              }
              return n
            }),
            (a.byteLength = g),
            (a.prototype._isBuffer = !0),
            (a.prototype.swap16 = function () {
              var t = this.length;
              if (t % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
              for (var e = 0; e < t; e += 2) d(this, e, e + 1);
              return this
            }),
            (a.prototype.swap32 = function () {
              var t = this.length;
              if (t % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
              for (var e = 0; e < t; e += 4) d(this, e, e + 3), d(this, e + 1, e + 2);
              return this
            }),
            (a.prototype.swap64 = function () {
              var t = this.length;
              if (t % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
              for (var e = 0; e < t; e += 8)
                d(this, e, e + 7), d(this, e + 1, e + 6), d(this, e + 2, e + 5), d(this, e + 3, e + 4);
              return this
            }),
            (a.prototype.toString = function () {
              var t = 0 | this.length;
              return 0 === t
                ? ''
                : 0 === arguments.length
                ? S(this, 0, t)
                : function (t, e, r) {
                    var n = !1;
                    if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return ''
                    if (((void 0 === r || r > this.length) && (r = this.length), r <= 0)) return ''
                    if ((r >>>= 0) <= (e >>>= 0)) return ''
                    for (t || (t = 'utf8'); ; )
                      switch (t) {
                        case 'hex':
                          return U(this, e, r)
                        case 'utf8':
                        case 'utf-8':
                          return S(this, e, r)
                        case 'ascii':
                          return P(this, e, r)
                        case 'latin1':
                        case 'binary':
                          return C(this, e, r)
                        case 'base64':
                          return R(this, e, r)
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                          return B(this, e, r)
                        default:
                          if (n) throw new TypeError('Unknown encoding: ' + t)
                          ;(t = (t + '').toLowerCase()), (n = !0);
                      }
                  }.apply(this, arguments)
            }),
            (a.prototype.equals = function (t) {
              if (!a.isBuffer(t)) throw new TypeError('Argument must be a Buffer')
              return this === t || 0 === a.compare(this, t)
            }),
            (a.prototype.inspect = function () {
              var t = '',
                r = e.INSPECT_MAX_BYTES;
              return (
                this.length > 0 &&
                  ((t = this.toString('hex', 0, r).match(/.{2}/g).join(' ')), this.length > r && (t += ' ... ')),
                '<Buffer ' + t + '>'
              )
            }),
            (a.prototype.compare = function (t, e, r, n, i) {
              if (!a.isBuffer(t)) throw new TypeError('Argument must be a Buffer')
              if (
                (void 0 === e && (e = 0),
                void 0 === r && (r = t ? t.length : 0),
                void 0 === n && (n = 0),
                void 0 === i && (i = this.length),
                e < 0 || r > t.length || n < 0 || i > this.length)
              )
                throw new RangeError('out of range index')
              if (n >= i && e >= r) return 0
              if (n >= i) return -1
              if (e >= r) return 1
              if (((e >>>= 0), (r >>>= 0), (n >>>= 0), (i >>>= 0), this === t)) return 0
              for (
                var o = i - n, s = r - e, u = Math.min(o, s), f = this.slice(n, i), h = t.slice(e, r), l = 0;
                l < u;
                ++l
              )
                if (f[l] !== h[l]) {
  (o = f[l]), (s = h[l]);
                  break
                }
              return o < s ? -1 : s < o ? 1 : 0
            }),
            (a.prototype.includes = function (t, e, r) {
              return -1 !== this.indexOf(t, e, r)
            }),
            (a.prototype.indexOf = function (t, e, r) {
              return y(this, t, e, r, !0)
            }),
            (a.prototype.lastIndexOf = function (t, e, r) {
              return y(this, t, e, r, !1)
            }),
            (a.prototype.write = function (t, e, r, n) {
              if (void 0 === e) (n = 'utf8'), (r = this.length), (e = 0);
              else if (void 0 === r && 'string' == typeof e) (n = e), (r = this.length), (e = 0);
              else {
                if (!isFinite(e))
                  throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
                ;(e |= 0), isFinite(r) ? ((r |= 0), void 0 === n && (n = 'utf8')) : ((n = r), (r = void 0));
              }
              var i = this.length - e;
              if (((void 0 === r || r > i) && (r = i), (t.length > 0 && (r < 0 || e < 0)) || e > this.length))
                throw new RangeError('Attempt to write outside buffer bounds')
              n || (n = 'utf8');
              for (var o = !1; ; )
                switch (n) {
                  case 'hex':
                    return E(this, t, e, r)
                  case 'utf8':
                  case 'utf-8':
                    return v(this, t, e, r)
                  case 'ascii':
                    return A(this, t, e, r)
                  case 'latin1':
                  case 'binary':
                    return _(this, t, e, r)
                  case 'base64':
                    return b(this, t, e, r)
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return m(this, t, e, r)
                  default:
                    if (o) throw new TypeError('Unknown encoding: ' + n)
                    ;(n = ('' + n).toLowerCase()), (o = !0);
                }
            }),
            (a.prototype.toJSON = function () {
              return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
            });
          var T = 4096;
          function P(t, e, r) {
            var n = '';
            r = Math.min(t.length, r);
            for (var i = e; i < r; ++i) n += String.fromCharCode(127 & t[i]);
            return n
          }
          function C(t, e, r) {
            var n = '';
            r = Math.min(t.length, r);
            for (var i = e; i < r; ++i) n += String.fromCharCode(t[i]);
            return n
          }
          function U(t, e, r) {
            var n = t.length
            ;(!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
            for (var i = '', o = e; o < r; ++o) i += N(t[o]);
            return i
          }
          function B(t, e, r) {
            for (var n = t.slice(e, r), i = '', o = 0; o < n.length; o += 2)
              i += String.fromCharCode(n[o] + 256 * n[o + 1]);
            return i
          }
          function F(t, e, r) {
            if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint')
            if (t + e > r) throw new RangeError('Trying to access beyond buffer length')
          }
          function M(t, e, r, n, i, o) {
            if (!a.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance')
            if (e > i || e < o) throw new RangeError('"value" argument is out of bounds')
            if (r + n > t.length) throw new RangeError('Index out of range')
          }
          function x(t, e, r, n) {
            e < 0 && (e = 65535 + e + 1);
            for (var i = 0, o = Math.min(t.length - r, 2); i < o; ++i)
              t[r + i] = (e & (255 << (8 * (n ? i : 1 - i)))) >>> (8 * (n ? i : 1 - i));
          }
          function I(t, e, r, n) {
            e < 0 && (e = 4294967295 + e + 1);
            for (var i = 0, o = Math.min(t.length - r, 4); i < o; ++i) t[r + i] = (e >>> (8 * (n ? i : 3 - i))) & 255;
          }
          function O(t, e, r, n, i, o) {
            if (r + n > t.length) throw new RangeError('Index out of range')
            if (r < 0) throw new RangeError('Index out of range')
          }
          function Y(t, e, r, n, o) {
            return o || O(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4
          }
          function L(t, e, r, n, o) {
            return o || O(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8
          }
  (a.prototype.slice = function (t, e) {
            var r,
              n = this.length;
            if (
              ((t = ~~t),
              (e = void 0 === e ? n : ~~e),
              t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
              e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
              e < t && (e = t),
              a.TYPED_ARRAY_SUPPORT)
            )
              (r = this.subarray(t, e)).__proto__ = a.prototype;
            else {
              var i = e - t;
              r = new a(i, void 0);
              for (var o = 0; o < i; ++o) r[o] = this[o + t];
            }
            return r
          }),
            (a.prototype.readUIntLE = function (t, e, r) {
  (t |= 0), (e |= 0), r || F(t, e, this.length);
              for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256); ) n += this[t + o] * i;
              return n
            }),
            (a.prototype.readUIntBE = function (t, e, r) {
  (t |= 0), (e |= 0), r || F(t, e, this.length);
              for (var n = this[t + --e], i = 1; e > 0 && (i *= 256); ) n += this[t + --e] * i;
              return n
            }),
            (a.prototype.readUInt8 = function (t, e) {
              return e || F(t, 1, this.length), this[t]
            }),
            (a.prototype.readUInt16LE = function (t, e) {
              return e || F(t, 2, this.length), this[t] | (this[t + 1] << 8)
            }),
            (a.prototype.readUInt16BE = function (t, e) {
              return e || F(t, 2, this.length), (this[t] << 8) | this[t + 1]
            }),
            (a.prototype.readUInt32LE = function (t, e) {
              return (
                e || F(t, 4, this.length), (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) + 16777216 * this[t + 3]
              )
            }),
            (a.prototype.readUInt32BE = function (t, e) {
              return (
                e || F(t, 4, this.length), 16777216 * this[t] + ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
              )
            }),
            (a.prototype.readIntLE = function (t, e, r) {
  (t |= 0), (e |= 0), r || F(t, e, this.length);
              for (var n = this[t], i = 1, o = 0; ++o < e && (i *= 256); ) n += this[t + o] * i;
              return n >= (i *= 128) && (n -= Math.pow(2, 8 * e)), n
            }),
            (a.prototype.readIntBE = function (t, e, r) {
  (t |= 0), (e |= 0), r || F(t, e, this.length);
              for (var n = e, i = 1, o = this[t + --n]; n > 0 && (i *= 256); ) o += this[t + --n] * i;
              return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o
            }),
            (a.prototype.readInt8 = function (t, e) {
              return e || F(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            }),
            (a.prototype.readInt16LE = function (t, e) {
              e || F(t, 2, this.length);
              var r = this[t] | (this[t + 1] << 8);
              return 32768 & r ? 4294901760 | r : r
            }),
            (a.prototype.readInt16BE = function (t, e) {
              e || F(t, 2, this.length);
              var r = this[t + 1] | (this[t] << 8);
              return 32768 & r ? 4294901760 | r : r
            }),
            (a.prototype.readInt32LE = function (t, e) {
              return e || F(t, 4, this.length), this[t] | (this[t + 1] << 8) | (this[t + 2] << 16) | (this[t + 3] << 24)
            }),
            (a.prototype.readInt32BE = function (t, e) {
              return e || F(t, 4, this.length), (this[t] << 24) | (this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3]
            }),
            (a.prototype.readFloatLE = function (t, e) {
              return e || F(t, 4, this.length), i.read(this, t, !0, 23, 4)
            }),
            (a.prototype.readFloatBE = function (t, e) {
              return e || F(t, 4, this.length), i.read(this, t, !1, 23, 4)
            }),
            (a.prototype.readDoubleLE = function (t, e) {
              return e || F(t, 8, this.length), i.read(this, t, !0, 52, 8)
            }),
            (a.prototype.readDoubleBE = function (t, e) {
              return e || F(t, 8, this.length), i.read(this, t, !1, 52, 8)
            }),
            (a.prototype.writeUIntLE = function (t, e, r, n) {
  ((t = +t), (e |= 0), (r |= 0), n) || M(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
              var i = 1,
                o = 0;
              for (this[e] = 255 & t; ++o < r && (i *= 256); ) this[e + o] = (t / i) & 255;
              return e + r
            }),
            (a.prototype.writeUIntBE = function (t, e, r, n) {
  ((t = +t), (e |= 0), (r |= 0), n) || M(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
              var i = r - 1,
                o = 1;
              for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); ) this[e + i] = (t / o) & 255;
              return e + r
            }),
            (a.prototype.writeUInt8 = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 1, 255, 0),
                a.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                (this[e] = 255 & t),
                e + 1
              )
            }),
            (a.prototype.writeUInt16LE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 2, 65535, 0),
                a.TYPED_ARRAY_SUPPORT ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8)) : x(this, t, e, !0),
                e + 2
              )
            }),
            (a.prototype.writeUInt16BE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 2, 65535, 0),
                a.TYPED_ARRAY_SUPPORT ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t)) : x(this, t, e, !1),
                e + 2
              )
            }),
            (a.prototype.writeUInt32LE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 4, 4294967295, 0),
                a.TYPED_ARRAY_SUPPORT
                  ? ((this[e + 3] = t >>> 24), (this[e + 2] = t >>> 16), (this[e + 1] = t >>> 8), (this[e] = 255 & t))
                  : I(this, t, e, !0),
                e + 4
              )
            }),
            (a.prototype.writeUInt32BE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 4, 4294967295, 0),
                a.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 24), (this[e + 1] = t >>> 16), (this[e + 2] = t >>> 8), (this[e + 3] = 255 & t))
                  : I(this, t, e, !1),
                e + 4
              )
            }),
            (a.prototype.writeIntLE = function (t, e, r, n) {
              if (((t = +t), (e |= 0), !n)) {
                var i = Math.pow(2, 8 * r - 1);
                M(this, t, e, r, i - 1, -i);
              }
              var o = 0,
                s = 1,
                u = 0;
              for (this[e] = 255 & t; ++o < r && (s *= 256); )
                t < 0 && 0 === u && 0 !== this[e + o - 1] && (u = 1), (this[e + o] = (((t / s) >> 0) - u) & 255);
              return e + r
            }),
            (a.prototype.writeIntBE = function (t, e, r, n) {
              if (((t = +t), (e |= 0), !n)) {
                var i = Math.pow(2, 8 * r - 1);
                M(this, t, e, r, i - 1, -i);
              }
              var o = r - 1,
                s = 1,
                u = 0;
              for (this[e + o] = 255 & t; --o >= 0 && (s *= 256); )
                t < 0 && 0 === u && 0 !== this[e + o + 1] && (u = 1), (this[e + o] = (((t / s) >> 0) - u) & 255);
              return e + r
            }),
            (a.prototype.writeInt8 = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 1, 127, -128),
                a.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                t < 0 && (t = 255 + t + 1),
                (this[e] = 255 & t),
                e + 1
              )
            }),
            (a.prototype.writeInt16LE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 2, 32767, -32768),
                a.TYPED_ARRAY_SUPPORT ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8)) : x(this, t, e, !0),
                e + 2
              )
            }),
            (a.prototype.writeInt16BE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 2, 32767, -32768),
                a.TYPED_ARRAY_SUPPORT ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t)) : x(this, t, e, !1),
                e + 2
              )
            }),
            (a.prototype.writeInt32LE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 4, 2147483647, -2147483648),
                a.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8), (this[e + 2] = t >>> 16), (this[e + 3] = t >>> 24))
                  : I(this, t, e, !0),
                e + 4
              )
            }),
            (a.prototype.writeInt32BE = function (t, e, r) {
              return (
                (t = +t),
                (e |= 0),
                r || M(this, t, e, 4, 2147483647, -2147483648),
                t < 0 && (t = 4294967295 + t + 1),
                a.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 24), (this[e + 1] = t >>> 16), (this[e + 2] = t >>> 8), (this[e + 3] = 255 & t))
                  : I(this, t, e, !1),
                e + 4
              )
            }),
            (a.prototype.writeFloatLE = function (t, e, r) {
              return Y(this, t, e, !0, r)
            }),
            (a.prototype.writeFloatBE = function (t, e, r) {
              return Y(this, t, e, !1, r)
            }),
            (a.prototype.writeDoubleLE = function (t, e, r) {
              return L(this, t, e, !0, r)
            }),
            (a.prototype.writeDoubleBE = function (t, e, r) {
              return L(this, t, e, !1, r)
            }),
            (a.prototype.copy = function (t, e, r, n) {
              if (
                (r || (r = 0),
                n || 0 === n || (n = this.length),
                e >= t.length && (e = t.length),
                e || (e = 0),
                n > 0 && n < r && (n = r),
                n === r)
              )
                return 0
              if (0 === t.length || 0 === this.length) return 0
              if (e < 0) throw new RangeError('targetStart out of bounds')
              if (r < 0 || r >= this.length) throw new RangeError('sourceStart out of bounds')
              if (n < 0) throw new RangeError('sourceEnd out of bounds')
              n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r);
              var i,
                o = n - r;
              if (this === t && r < e && e < n) for (i = o - 1; i >= 0; --i) t[i + e] = this[i + r];
              else if (o < 1e3 || !a.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i) t[i + e] = this[i + r];
              else Uint8Array.prototype.set.call(t, this.subarray(r, r + o), e);
              return o
            }),
            (a.prototype.fill = function (t, e, r, n) {
              if ('string' == typeof t) {
                if (
                  ('string' == typeof e
                    ? ((n = e), (e = 0), (r = this.length))
                    : 'string' == typeof r && ((n = r), (r = this.length)),
                  1 === t.length)
                ) {
                  var i = t.charCodeAt(0);
                  i < 256 && (t = i);
                }
                if (void 0 !== n && 'string' != typeof n) throw new TypeError('encoding must be a string')
                if ('string' == typeof n && !a.isEncoding(n)) throw new TypeError('Unknown encoding: ' + n)
              } else 'number' == typeof t && (t &= 255);
              if (e < 0 || this.length < e || this.length < r) throw new RangeError('Out of range index')
              if (r <= e) return this
              var o;
              if (((e >>>= 0), (r = void 0 === r ? this.length : r >>> 0), t || (t = 0), 'number' == typeof t))
                for (o = e; o < r; ++o) this[o] = t;
              else {
                var s = a.isBuffer(t) ? t : k(new a(t, n).toString()),
                  u = s.length;
                for (o = 0; o < r - e; ++o) this[o + e] = s[o % u];
              }
              return this
            });
          var D = /[^+\/0-9A-Za-z-_]/g;
          function N(t) {
            return t < 16 ? '0' + t.toString(16) : t.toString(16)
          }
          function k(t, e) {
            var r;
            e = e || 1 / 0;
            for (var n = t.length, i = null, o = [], s = 0; s < n; ++s) {
              if ((r = t.charCodeAt(s)) > 55295 && r < 57344) {
                if (!i) {
                  if (r > 56319) {
  (e -= 3) > -1 && o.push(239, 191, 189);
                    continue
                  }
                  if (s + 1 === n) {
  (e -= 3) > -1 && o.push(239, 191, 189);
                    continue
                  }
                  i = r;
                  continue
                }
                if (r < 56320) {
  (e -= 3) > -1 && o.push(239, 191, 189), (i = r);
                  continue
                }
                r = 65536 + (((i - 55296) << 10) | (r - 56320));
              } else i && (e -= 3) > -1 && o.push(239, 191, 189);
              if (((i = null), r < 128)) {
                if ((e -= 1) < 0) break
                o.push(r);
              } else if (r < 2048) {
                if ((e -= 2) < 0) break
                o.push((r >> 6) | 192, (63 & r) | 128);
              } else if (r < 65536) {
                if ((e -= 3) < 0) break
                o.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
              } else {
                if (!(r < 1114112)) throw new Error('Invalid code point')
                if ((e -= 4) < 0) break
                o.push((r >> 18) | 240, ((r >> 12) & 63) | 128, ((r >> 6) & 63) | 128, (63 & r) | 128);
              }
            }
            return o
          }
          function j(t) {
            return n.toByteArray(
              (function (t) {
                if (
                  (t = (function (t) {
                    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '')
                  })(t).replace(D, '')).length < 2
                )
                  return ''
                for (; t.length % 4 != 0; ) t += '=';
                return t
              })(t)
            )
          }
          function z(t, e, r, n) {
            for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i) e[i + r] = t[i];
            return i
          }
        }.call(this, r(8)));
      },
      function (t, e) {
        var r;
        r = (function () {
          return this
        })();
        try {
          r = r || Function('return this')() || (0, eval)('this');
        } catch (t) {
          'object' == typeof window && (r = window);
        }
        t.exports = r;
      },
      function (t, e, r) {
  (e.byteLength = function (t) {
          var e = f(t),
            r = e[0],
            n = e[1];
          return (3 * (r + n)) / 4 - n
        }),
          (e.toByteArray = function (t) {
            for (
              var e,
                r = f(t),
                n = r[0],
                s = r[1],
                u = new o(
                  (function (t, e, r) {
                    return (3 * (e + r)) / 4 - r
                  })(0, n, s)
                ),
                a = 0,
                h = s > 0 ? n - 4 : n,
                l = 0;
              l < h;
              l += 4
            )
              (e =
                (i[t.charCodeAt(l)] << 18) |
                (i[t.charCodeAt(l + 1)] << 12) |
                (i[t.charCodeAt(l + 2)] << 6) |
                i[t.charCodeAt(l + 3)]),
                (u[a++] = (e >> 16) & 255),
                (u[a++] = (e >> 8) & 255),
                (u[a++] = 255 & e);
            2 === s && ((e = (i[t.charCodeAt(l)] << 2) | (i[t.charCodeAt(l + 1)] >> 4)), (u[a++] = 255 & e));
            1 === s &&
              ((e = (i[t.charCodeAt(l)] << 10) | (i[t.charCodeAt(l + 1)] << 4) | (i[t.charCodeAt(l + 2)] >> 2)),
              (u[a++] = (e >> 8) & 255),
              (u[a++] = 255 & e));
            return u
          }),
          (e.fromByteArray = function (t) {
            for (var e, r = t.length, i = r % 3, o = [], s = 0, u = r - i; s < u; s += 16383)
              o.push(l(t, s, s + 16383 > u ? u : s + 16383));
            1 === i
              ? ((e = t[r - 1]), o.push(n[e >> 2] + n[(e << 4) & 63] + '=='))
              : 2 === i &&
                ((e = (t[r - 2] << 8) + t[r - 1]), o.push(n[e >> 10] + n[(e >> 4) & 63] + n[(e << 2) & 63] + '='));
            return o.join('')
          });
        for (
          var n = [],
            i = [],
            o = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
            s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
            u = 0,
            a = s.length;
          u < a;
          ++u
        )
          (n[u] = s[u]), (i[s.charCodeAt(u)] = u);
        function f(t) {
          var e = t.length;
          if (e % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
          var r = t.indexOf('=');
          return -1 === r && (r = e), [r, r === e ? 0 : 4 - (r % 4)]
        }
        function h(t) {
          return n[(t >> 18) & 63] + n[(t >> 12) & 63] + n[(t >> 6) & 63] + n[63 & t]
        }
        function l(t, e, r) {
          for (var n, i = [], o = e; o < r; o += 3)
            (n = ((t[o] << 16) & 16711680) + ((t[o + 1] << 8) & 65280) + (255 & t[o + 2])), i.push(h(n));
          return i.join('')
        }
  (i['-'.charCodeAt(0)] = 62), (i['_'.charCodeAt(0)] = 63);
      },
      function (t, e) {
  (e.read = function (t, e, r, n, i) {
          var o,
            s,
            u = 8 * i - n - 1,
            a = (1 << u) - 1,
            f = a >> 1,
            h = -7,
            l = r ? i - 1 : 0,
            c = r ? -1 : 1,
            p = t[e + l];
          for (l += c, o = p & ((1 << -h) - 1), p >>= -h, h += u; h > 0; o = 256 * o + t[e + l], l += c, h -= 8);
          for (s = o & ((1 << -h) - 1), o >>= -h, h += n; h > 0; s = 256 * s + t[e + l], l += c, h -= 8);
          if (0 === o) o = 1 - f;
          else {
            if (o === a) return s ? NaN : (1 / 0) * (p ? -1 : 1)
            ;(s += Math.pow(2, n)), (o -= f);
          }
          return (p ? -1 : 1) * s * Math.pow(2, o - n)
        }),
          (e.write = function (t, e, r, n, i, o) {
            var s,
              u,
              a,
              f = 8 * o - i - 1,
              h = (1 << f) - 1,
              l = h >> 1,
              c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              p = n ? 0 : o - 1,
              g = n ? 1 : -1,
              d = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
            for (
              e = Math.abs(e),
                isNaN(e) || e === 1 / 0
                  ? ((u = isNaN(e) ? 1 : 0), (s = h))
                  : ((s = Math.floor(Math.log(e) / Math.LN2)),
                    e * (a = Math.pow(2, -s)) < 1 && (s--, (a *= 2)),
                    (e += s + l >= 1 ? c / a : c * Math.pow(2, 1 - l)) * a >= 2 && (s++, (a /= 2)),
                    s + l >= h
                      ? ((u = 0), (s = h))
                      : s + l >= 1
                      ? ((u = (e * a - 1) * Math.pow(2, i)), (s += l))
                      : ((u = e * Math.pow(2, l - 1) * Math.pow(2, i)), (s = 0)));
              i >= 8;
              t[r + p] = 255 & u, p += g, u /= 256, i -= 8
            );
            for (s = (s << i) | u, f += i; f > 0; t[r + p] = 255 & s, p += g, s /= 256, f -= 8);
            t[r + p - g] |= 128 * d;
          });
      },
      function (t, e) {
        var r = {}.toString;
        t.exports =
          Array.isArray ||
          function (t) {
            return '[object Array]' == r.call(t)
          };
      },
      function (e, r) {
        e.exports = t;
      },
      function (t, e, r) {
  (function (t) {
          function r(t, e) {
            for (var r = 0, n = t.length - 1; n >= 0; n--) {
              var i = t[n];
              '.' === i ? t.splice(n, 1) : '..' === i ? (t.splice(n, 1), r++) : r && (t.splice(n, 1), r--);
            }
            if (e) for (; r--; r) t.unshift('..');
            return t
          }
          var n = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,
            i = function (t) {
              return n.exec(t).slice(1)
            };
          function o(t, e) {
            if (t.filter) return t.filter(e)
            for (var r = [], n = 0; n < t.length; n++) e(t[n], n, t) && r.push(t[n]);
            return r
          }
  (e.resolve = function () {
            for (var e = '', n = !1, i = arguments.length - 1; i >= -1 && !n; i--) {
              var s = i >= 0 ? arguments[i] : t.cwd();
              if ('string' != typeof s) throw new TypeError('Arguments to path.resolve must be strings')
              s && ((e = s + '/' + e), (n = '/' === s.charAt(0)));
            }
            return (
              (e = r(
                o(e.split('/'), function (t) {
                  return !!t
                }),
                !n
              ).join('/')),
              (n ? '/' : '') + e || '.'
            )
          }),
            (e.normalize = function (t) {
              var n = e.isAbsolute(t),
                i = '/' === s(t, -1);
              return (
                (t = r(
                  o(t.split('/'), function (t) {
                    return !!t
                  }),
                  !n
                ).join('/')) ||
                  n ||
                  (t = '.'),
                t && i && (t += '/'),
                (n ? '/' : '') + t
              )
            }),
            (e.isAbsolute = function (t) {
              return '/' === t.charAt(0)
            }),
            (e.join = function () {
              var t = Array.prototype.slice.call(arguments, 0);
              return e.normalize(
                o(t, function (t, e) {
                  if ('string' != typeof t) throw new TypeError('Arguments to path.join must be strings')
                  return t
                }).join('/')
              )
            }),
            (e.relative = function (t, r) {
              function n(t) {
                for (var e = 0; e < t.length && '' === t[e]; e++);
                for (var r = t.length - 1; r >= 0 && '' === t[r]; r--);
                return e > r ? [] : t.slice(e, r - e + 1)
              }
  (t = e.resolve(t).substr(1)), (r = e.resolve(r).substr(1));
              for (
                var i = n(t.split('/')), o = n(r.split('/')), s = Math.min(i.length, o.length), u = s, a = 0;
                a < s;
                a++
              )
                if (i[a] !== o[a]) {
                  u = a;
                  break
                }
              var f = [];
              for (a = u; a < i.length; a++) f.push('..');
              return (f = f.concat(o.slice(u))).join('/')
            }),
            (e.sep = '/'),
            (e.delimiter = ':'),
            (e.dirname = function (t) {
              var e = i(t),
                r = e[0],
                n = e[1];
              return r || n ? (n && (n = n.substr(0, n.length - 1)), r + n) : '.'
            }),
            (e.basename = function (t, e) {
              var r = i(t)[2];
              return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r
            }),
            (e.extname = function (t) {
              return i(t)[3]
            });
          var s =
            'b' === 'ab'.substr(-1)
              ? function (t, e, r) {
                  return t.substr(e, r)
                }
              : function (t, e, r) {
                  return e < 0 && (e = t.length + e), t.substr(e, r)
                };
        }.call(this, r(14)));
      },
      function (t, e) {
        var r,
          n,
          i = (t.exports = {});
        function o() {
          throw new Error('setTimeout has not been defined')
        }
        function s() {
          throw new Error('clearTimeout has not been defined')
        }
        function u(t) {
          if (r === setTimeout) return setTimeout(t, 0)
          if ((r === o || !r) && setTimeout) return (r = setTimeout), setTimeout(t, 0)
          try {
            return r(t, 0)
          } catch (e) {
            try {
              return r.call(null, t, 0)
            } catch (e) {
              return r.call(this, t, 0)
            }
          }
        }
        !(function () {
          try {
            r = 'function' == typeof setTimeout ? setTimeout : o;
          } catch (t) {
            r = o;
          }
          try {
            n = 'function' == typeof clearTimeout ? clearTimeout : s;
          } catch (t) {
            n = s;
          }
        })();
        var a,
          f = [],
          h = !1,
          l = -1;
        function c() {
          h && a && ((h = !1), a.length ? (f = a.concat(f)) : (l = -1), f.length && p());
        }
        function p() {
          if (!h) {
            var t = u(c);
            h = !0;
            for (var e = f.length; e; ) {
              for (a = f, f = []; ++l < e; ) a && a[l].run()
              ;(l = -1), (e = f.length);
            }
  (a = null),
              (h = !1),
              (function (t) {
                if (n === clearTimeout) return clearTimeout(t)
                if ((n === s || !n) && clearTimeout) return (n = clearTimeout), clearTimeout(t)
                try {
                  n(t);
                } catch (e) {
                  try {
                    return n.call(null, t)
                  } catch (e) {
                    return n.call(this, t)
                  }
                }
              })(t);
          }
        }
        function g(t, e) {
  (this.fun = t), (this.array = e);
        }
        function d() {}
  (i.nextTick = function (t) {
          var e = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
          f.push(new g(t, e)), 1 !== f.length || h || u(p);
        }),
          (g.prototype.run = function () {
            this.fun.apply(null, this.array);
          }),
          (i.title = 'browser'),
          (i.browser = !0),
          (i.env = {}),
          (i.argv = []),
          (i.version = ''),
          (i.versions = {}),
          (i.on = d),
          (i.addListener = d),
          (i.once = d),
          (i.off = d),
          (i.removeListener = d),
          (i.removeAllListeners = d),
          (i.emit = d),
          (i.prependListener = d),
          (i.prependOnceListener = d),
          (i.listeners = function (t) {
            return []
          }),
          (i.binding = function (t) {
            throw new Error('process.binding is not supported')
          }),
          (i.cwd = function () {
            return '/'
          }),
          (i.chdir = function (t) {
            throw new Error('process.chdir is not supported')
          }),
          (i.umask = function () {
            return 0
          });
      },
    ])
  });
  //-------------------------------------------------------------

  const unpackBridge = WorkerScope.unpackBridge;

  let unpack;

  //-------------------------unpack--------------------------
  var initunpack = function (buffer) {
    // The following code has been _carefully_ modified by hand.
    // Due to WebPack embedding this script into the Zea engine
    // build, certain features broke.
    // There was code to handle loading in a nodeJS context, that tried to import("fs")
    // WebPack kepts tripping up on that code in its static analysis of the code, so
    // I carefully removed it.
    // The global scope of the script seems to be different, so unpackBridge was not available.
    // The unpackBridge code assigns unpackBridge to the passed in scope, which is 'this', but that
    // scope isn't available inside this 'unpack' function.
    const unpack = Module;

    // Note: the following is the URL of the unpack.wasm file in our ZeaEngine project on our
    // server. Ideally we could use a relative path from the ZeaEngine file, but
    // that isn't possible yet. (TODO: Ask Mauro about this)
    const credentials = 'omit';

    var Ext = unpackBridge.Ext;
    var jsAPI = {
      open: function () {
        return Ext.current.open.apply(Ext.current, arguments)
      },
      close: function () {
        return Ext.current.close.apply(Ext.current, arguments)
      },
      read: function () {
        return Ext.current.read.apply(Ext.current, arguments)
      },
      write: function () {
        return Ext.current.write.apply(Ext.current, arguments)
      },
      tell: function () {
        return Ext.current.tell.apply(Ext.current, arguments)
      },
      seek: function () {
        return Ext.current.seek.apply(Ext.current, arguments)
      },
      create: function () {
        return Ext.current.create.apply(Ext.current, arguments)
      },
    };
    var moduleOverrides = {};
    var key;
    for (key in Module) {
      if (Module.hasOwnProperty(key)) {
        moduleOverrides[key] = Module[key];
      }
    }
    Module['wasmBinary'] = buffer;
    Module['arguments'] = [];
    Module['thisProgram'] = './this.program';
    Module['quit'] = function (status, toThrow) {
      throw toThrow
    };
    Module['preRun'] = [];
    Module['postRun'] = [];
    var ENVIRONMENT_IS_WEB = false;
    var ENVIRONMENT_IS_WORKER = false;
    var ENVIRONMENT_IS_NODE = false;
    if (Module['ENVIRONMENT']) {
      if (Module['ENVIRONMENT'] === 'WEB') {
        ENVIRONMENT_IS_WEB = true;
      } else if (Module['ENVIRONMENT'] === 'WORKER') {
        ENVIRONMENT_IS_WORKER = true;
      } else if (Module['ENVIRONMENT'] === 'NODE') {
        ENVIRONMENT_IS_NODE = true;
      } else if (Module['ENVIRONMENT'] === 'SHELL') ; else {
        throw new Error("Module['ENVIRONMENT'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.")
      }
    } else {
      ENVIRONMENT_IS_WEB = typeof window === 'object';
      ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
      ENVIRONMENT_IS_NODE =
        typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
    }
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      Module['read'] = function shell_read(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText
      };
      if (ENVIRONMENT_IS_WORKER) {
        Module['readBinary'] = function readBinary(url) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.responseType = 'arraybuffer';
          xhr.send(null);
          return new Uint8Array(xhr.response)
        };
      }
      Module['readAsync'] = function readAsync(url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
            onload(xhr.response);
            return
          }
          onerror();
        };
        xhr.onerror = onerror;
        xhr.send(null);
      };
      Module['setWindowTitle'] = function (title) {
        document.title = title;
      };
    }
    Module['print'] =
      typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null;
    Module['printErr'] =
      typeof printErr !== 'undefined'
        ? printErr
        : (typeof console !== 'undefined' && console.warn.bind(console)) || Module['print'];
    Module.print = Module['print'];
    Module.printErr = Module['printErr'];
    for (key in moduleOverrides) {
      if (moduleOverrides.hasOwnProperty(key)) {
        Module[key] = moduleOverrides[key];
      }
    }
    moduleOverrides = undefined;
    var STACK_ALIGN = 16;
    function staticAlloc(size) {
      assert(!staticSealed);
      var ret = STATICTOP;
      STATICTOP = (STATICTOP + size + 15) & -16;
      return ret
    }
    function dynamicAlloc(size) {
      assert(DYNAMICTOP_PTR);
      var ret = HEAP32[DYNAMICTOP_PTR >> 2];
      var end = (ret + size + 15) & -16;
      HEAP32[DYNAMICTOP_PTR >> 2] = end;
      if (end >= TOTAL_MEMORY) {
        var success = enlargeMemory();
        if (!success) {
          HEAP32[DYNAMICTOP_PTR >> 2] = ret;
          return 0
        }
      }
      return ret
    }
    function alignMemory(size, factor) {
      if (!factor) factor = STACK_ALIGN;
      var ret = (size = Math.ceil(size / factor) * factor);
      return ret
    }
    function getNativeTypeSize(type) {
      switch (type) {
        case 'i1':
        case 'i8':
          return 1
        case 'i16':
          return 2
        case 'i32':
          return 4
        case 'i64':
          return 8
        case 'float':
          return 4
        case 'double':
          return 8
        default: {
          if (type[type.length - 1] === '*') {
            return 4
          } else if (type[0] === 'i') {
            var bits = parseInt(type.substr(1));
            assert(bits % 8 === 0);
            return bits / 8
          } else {
            return 0
          }
        }
      }
    }
    new Array(0);
    var GLOBAL_BASE = 1024;
    var ABORT = 0;
    function assert(condition, text) {
      if (!condition) {
        abort('Assertion failed: ' + text);
      }
    }
    function setValue(ptr, value, type, noSafe) {
      type = type || 'i8';
      if (type.charAt(type.length - 1) === '*') type = 'i32';
      switch (type) {
        case 'i1':
          HEAP8[ptr >> 0] = value;
          break
        case 'i8':
          HEAP8[ptr >> 0] = value;
          break
        case 'i16':
          HEAP16[ptr >> 1] = value;
          break
        case 'i32':
          HEAP32[ptr >> 2] = value;
          break
        case 'i64':
  (tempI64 = [
            value >>> 0,
            ((tempDouble = value),
            +Math_abs(tempDouble) >= 1
              ? tempDouble > 0
                ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0
                : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
              : 0),
          ]),
            (HEAP32[ptr >> 2] = tempI64[0]),
            (HEAP32[(ptr + 4) >> 2] = tempI64[1]);
          break
        case 'float':
          HEAPF32[ptr >> 2] = value;
          break
        case 'double':
          HEAPF64[ptr >> 3] = value;
          break
        default:
          abort('invalid type for setValue: ' + type);
      }
    }
    var ALLOC_NORMAL = 0;
    var ALLOC_STATIC = 2;
    var ALLOC_NONE = 4;
    function allocate(slab, types, allocator, ptr) {
      var zeroinit, size;
      if (typeof slab === 'number') {
        zeroinit = true;
        size = slab;
      } else {
        zeroinit = false;
        size = slab.length;
      }
      var singleType = typeof types === 'string' ? types : null;
      var ret;
      if (allocator == ALLOC_NONE) {
        ret = ptr;
      } else {
        ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][
          allocator === undefined ? ALLOC_STATIC : allocator
        ](Math.max(size, singleType ? 1 : types.length));
      }
      if (zeroinit) {
        var stop;
        ptr = ret;
        assert((ret & 3) == 0);
        stop = ret + (size & ~3);
        for (; ptr < stop; ptr += 4) {
          HEAP32[ptr >> 2] = 0;
        }
        stop = ret + size;
        while (ptr < stop) {
          HEAP8[ptr++ >> 0] = 0;
        }
        return ret
      }
      if (singleType === 'i8') {
        if (slab.subarray || slab.slice) {
          HEAPU8.set(slab, ret);
        } else {
          HEAPU8.set(new Uint8Array(slab), ret);
        }
        return ret
      }
      var i = 0,
        type,
        typeSize,
        previousType;
      while (i < size) {
        var curr = slab[i];
        type = singleType || types[i];
        if (type === 0) {
          i++;
          continue
        }
        if (type == 'i64') type = 'i32';
        setValue(ret + i, curr, type);
        if (previousType !== type) {
          typeSize = getNativeTypeSize(type);
          previousType = type;
        }
        i += typeSize;
      }
      return ret
    }
    function Pointer_stringify(ptr, length) {
      if (length === 0 || !ptr) return ''
      var hasUtf = 0;
      var t;
      var i = 0;
      while (1) {
        t = HEAPU8[(ptr + i) >> 0];
        hasUtf |= t;
        if (t == 0 && !length) break
        i++;
        if (length && i == length) break
      }
      if (!length) length = i;
      var ret = '';
      if (hasUtf < 128) {
        var MAX_CHUNK = 1024;
        var curr;
        while (length > 0) {
          curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
          ret = ret ? ret + curr : curr;
          ptr += MAX_CHUNK;
          length -= MAX_CHUNK;
        }
        return ret
      }
      return UTF8ToString(ptr)
    }
    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;
    function UTF8ArrayToString(u8Array, idx) {
      var endPtr = idx;
      while (u8Array[endPtr]) ++endPtr;
      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
      } else {
        var u0, u1, u2, u3, u4, u5;
        var str = '';
        while (1) {
          u0 = u8Array[idx++];
          if (!u0) return str
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue
          }
          u1 = u8Array[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode(((u0 & 31) << 6) | u1);
            continue
          }
          u2 = u8Array[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
          } else {
            u3 = u8Array[idx++] & 63;
            if ((u0 & 248) == 240) {
              u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
            } else {
              u4 = u8Array[idx++] & 63;
              if ((u0 & 252) == 248) {
                u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
              } else {
                u5 = u8Array[idx++] & 63;
                u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
              }
            }
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
          }
        }
      }
    }
    function UTF8ToString(ptr) {
      return UTF8ArrayToString(HEAPU8, ptr)
    }
    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
        if (u <= 127) {
          if (outIdx >= endIdx) break
          outU8Array[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break
          outU8Array[outIdx++] = 192 | (u >> 6);
          outU8Array[outIdx++] = 128 | (u & 63);
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break
          outU8Array[outIdx++] = 224 | (u >> 12);
          outU8Array[outIdx++] = 128 | ((u >> 6) & 63);
          outU8Array[outIdx++] = 128 | (u & 63);
        } else if (u <= 2097151) {
          if (outIdx + 3 >= endIdx) break
          outU8Array[outIdx++] = 240 | (u >> 18);
          outU8Array[outIdx++] = 128 | ((u >> 12) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 6) & 63);
          outU8Array[outIdx++] = 128 | (u & 63);
        } else if (u <= 67108863) {
          if (outIdx + 4 >= endIdx) break
          outU8Array[outIdx++] = 248 | (u >> 24);
          outU8Array[outIdx++] = 128 | ((u >> 18) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 12) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 6) & 63);
          outU8Array[outIdx++] = 128 | (u & 63);
        } else {
          if (outIdx + 5 >= endIdx) break
          outU8Array[outIdx++] = 252 | (u >> 30);
          outU8Array[outIdx++] = 128 | ((u >> 24) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 18) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 12) & 63);
          outU8Array[outIdx++] = 128 | ((u >> 6) & 63);
          outU8Array[outIdx++] = 128 | (u & 63);
        }
      }
      outU8Array[outIdx] = 0;
      return outIdx - startIdx
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)
    }
    function lengthBytesUTF8(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
        if (u <= 127) {
          ++len;
        } else if (u <= 2047) {
          len += 2;
        } else if (u <= 65535) {
          len += 3;
        } else if (u <= 2097151) {
          len += 4;
        } else if (u <= 67108863) {
          len += 5;
        } else {
          len += 6;
        }
      }
      return len
    }
    typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
    function UTF32ToString(ptr) {
      var i = 0;
      var str = '';
      while (1) {
        var utf32 = HEAP32[(ptr + i * 4) >> 2];
        if (utf32 == 0) return str
        ++i;
        if (utf32 >= 65536) {
          var ch = utf32 - 65536;
          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
        } else {
          str += String.fromCharCode(utf32);
        }
      }
    }
    function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret
    }
    function demangle(func) {
      return func
    }
    function demangleAll(text) {
      var regex = /__Z[\w\d_]+/g;
      return text.replace(regex, function (x) {
        var y = demangle(x);
        return x === y ? x : x + ' [' + y + ']'
      })
    }
    function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        try {
          throw new Error(0)
        } catch (e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)'
        }
      }
      return err.stack.toString()
    }
    function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js)
    }
    var WASM_PAGE_SIZE = 65536;
    var ASMJS_PAGE_SIZE = 16777216;
    var MIN_TOTAL_MEMORY = 16777216;
    function alignUp(x, multiple) {
      if (x % multiple > 0) {
        x += multiple - (x % multiple);
      }
      return x
    }
    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateGlobalBuffer(buf) {
      Module['buffer'] = buffer = buf;
    }
    function updateGlobalBufferViews() {
      Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
      Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
      Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
      Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
      Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
    }
    var STATIC_BASE, STATICTOP, staticSealed;
    var STACK_BASE, STACKTOP, STACK_MAX;
    var DYNAMIC_BASE, DYNAMICTOP_PTR;
    STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
    staticSealed = false;
    function abortOnCannotGrowMemory() {
      abort(
        'Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' +
          TOTAL_MEMORY +
          ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 '
      );
    }
    if (!Module['reallocBuffer'])
      Module['reallocBuffer'] = function (size) {
        var ret;
        try {
          if (ArrayBuffer.transfer) {
            ret = ArrayBuffer.transfer(buffer, size);
          } else {
            var oldHEAP8 = HEAP8;
            ret = new ArrayBuffer(size);
            var temp = new Int8Array(ret);
            temp.set(oldHEAP8);
          }
        } catch (e) {
          return false
        }
        var success = _emscripten_replace_memory(ret);
        if (!success) return false
        return ret
      };
    function enlargeMemory() {
      var PAGE_MULTIPLE = Module['usingWasm'] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;
      var LIMIT = 2147483648 - PAGE_MULTIPLE;
      if (HEAP32[DYNAMICTOP_PTR >> 2] > LIMIT) {
        return false
      }
      var OLD_TOTAL_MEMORY = TOTAL_MEMORY;
      TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY);
      while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR >> 2]) {
        if (TOTAL_MEMORY <= 536870912) {
          TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE);
        } else {
          TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
        }
      }
      var replacement = Module['reallocBuffer'](TOTAL_MEMORY);
      if (!replacement || replacement.byteLength != TOTAL_MEMORY) {
        TOTAL_MEMORY = OLD_TOTAL_MEMORY;
        return false
      }
      updateGlobalBuffer(replacement);
      updateGlobalBufferViews();
      return true
    }
    var byteLength;
    try {
      byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);
      byteLength(new ArrayBuffer(4));
    } catch (e) {
      byteLength = function (buffer) {
        return buffer.byteLength
      };
    }
    var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
    var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
    if (TOTAL_MEMORY < TOTAL_STACK)
      Module.printErr(
        'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'
      );
    if (Module['buffer']) {
      buffer = Module['buffer'];
    } else {
      if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {
        Module['wasmMemory'] = new WebAssembly.Memory({ initial: TOTAL_MEMORY / WASM_PAGE_SIZE });
        buffer = Module['wasmMemory'].buffer;
      } else {
        buffer = new ArrayBuffer(TOTAL_MEMORY);
      }
      Module['buffer'] = buffer;
    }
    updateGlobalBufferViews();
    function getTotalMemory() {
      return TOTAL_MEMORY
    }
    HEAP32[0] = 1668509029;
    HEAP16[1] = 25459;
    if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw 'Runtime error: expected the system to be little-endian!'
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback();
          continue
        }
        var func = callback.func;
        if (typeof func === 'number') {
          if (callback.arg === undefined) {
            Module['dynCall_v'](func);
          } else {
            Module['dynCall_vi'](func, callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATEXIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module['preRun']) {
        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
        while (Module['preRun'].length) {
          addOnPreRun(Module['preRun'].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function ensureInitRuntime() {
      if (runtimeInitialized) return
      runtimeInitialized = true;
      callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }
    function exitRuntime() {
      callRuntimeCallbacks(__ATEXIT__);
    }
    function postRun() {
      if (Module['postRun']) {
        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
        while (Module['postRun'].length) {
          addOnPostRun(Module['postRun'].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }
      if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }
    var Math_abs = Math.abs;
    var Math_ceil = Math.ceil;
    var Math_floor = Math.floor;
    var Math_min = Math.min;
    var runDependencies = 0;
    var dependenciesFulfilled = null;
    function addRunDependency(id) {
      runDependencies++;
      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }
    }
    function removeRunDependency(id) {
      runDependencies--;
      if (Module['monitorRunDependencies']) {
        Module['monitorRunDependencies'](runDependencies);
      }
      if (runDependencies == 0) {
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    Module['preloadedImages'] = {};
    Module['preloadedAudios'] = {};
    var dataURIPrefix = 'data:application/octet-stream;base64,';
    function isDataURI(filename) {
      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0
    }
    function integrateWasmJS() {
      var wasmTextFile = 'unpack.wast';
      var asmjsCodeFile = 'unpack.temp.asm.js';
      if (typeof Module['locateFile'] === 'function') {
        if (!isDataURI(wasmTextFile)) {
          wasmTextFile = Module['locateFile'](wasmTextFile);
        }
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = Module['locateFile'](wasmBinaryFile);
        }
        if (!isDataURI(asmjsCodeFile)) {
          asmjsCodeFile = Module['locateFile'](asmjsCodeFile);
        }
      }
      const wasmPageSize = 64 * 1024;
      const info = {
        asm2wasm: {
          'f64-rem': function (x, y) {
            return x % y
          },
          debugger: function () {
            debugger
          },
        },
        parent: Module,
      };
      var exports = null;
      function mergeMemory(newBuffer) {
        var oldBuffer = Module['buffer'];
        if (newBuffer.byteLength < oldBuffer.byteLength) {
          Module['printErr'](
            'the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here'
          );
        }
        var oldView = new Int8Array(oldBuffer);
        var newView = new Int8Array(newBuffer);
        newView.set(oldView);
        updateGlobalBuffer(newBuffer);
        updateGlobalBufferViews();
      }
      function fixImports(imports) {
        return imports
      }
      function getBinary() {
        try {
          if (Module['wasmBinary']) {
            return new Uint8Array(Module['wasmBinary'])
          }
          if (Module['readBinary']) {
            return Module['readBinary'](wasmBinaryFile)
          } else {
            throw "on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)"
          }
        } catch (err) {
          abort(err);
        }
      }
      function getBinaryPromise() {
        if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
          return fetch(wasmBinaryFile, { credentials })
            .then(function (response) {
              if (!response['ok']) {
                throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"
              }
              return response['arrayBuffer']()
            })
            .catch(function () {
              return getBinary()
            })
        }
        return new Promise(function (resolve, reject) {
          resolve(getBinary());
        })
      }
      function doNativeWasm(global, env, providedBuffer) {
        if (typeof WebAssembly !== 'object') {
          Module['printErr']('no native wasm support detected');
          return false
        }
        if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {
          Module['printErr']('no native wasm Memory in use');
          return false
        }
        env['memory'] = Module['wasmMemory'];
        info['global'] = { NaN: NaN, Infinity: Infinity };
        info['global.Math'] = Math;
        info['env'] = env;
        function receiveInstance(instance, module) {
          exports = instance.exports;
          if (exports.memory) mergeMemory(exports.memory);
          Module['asm'] = exports;
          Module['usingWasm'] = true;
          removeRunDependency();
        }
        addRunDependency();
        if (Module['instantiateWasm']) {
          try {
            return Module['instantiateWasm'](info, receiveInstance)
          } catch (e) {
            Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);
            return false
          }
        }
        function receiveInstantiatedSource(output) {
          receiveInstance(output['instance'], output['module']);
        }
        function instantiateArrayBuffer(receiver) {
          getBinaryPromise()
            .then(function (binary) {
              return WebAssembly.instantiate(binary, info)
            })
            .then(receiver)
            .catch(function (reason) {
              Module['printErr']('failed to asynchronously prepare wasm: ' + reason);
              abort(reason);
            });
        }
        if (
          !Module['wasmBinary'] &&
          typeof WebAssembly.instantiateStreaming === 'function' &&
          !isDataURI(wasmBinaryFile) &&
          typeof fetch === 'function'
        ) {
          WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials }), info)
            .then(receiveInstantiatedSource)
            .catch(function (reason) {
              Module['printErr']('wasm streaming compile failed: ' + reason);
              Module['printErr']('falling back to ArrayBuffer instantiation');
              instantiateArrayBuffer(receiveInstantiatedSource);
            });
        } else {
          instantiateArrayBuffer(receiveInstantiatedSource);
        }
        return {}
      }
      Module['asmPreload'] = Module['asm'];
      var asmjsReallocBuffer = Module['reallocBuffer'];
      var wasmReallocBuffer = function (size) {
        var PAGE_MULTIPLE = Module['usingWasm'] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;
        size = alignUp(size, PAGE_MULTIPLE);
        var old = Module['buffer'];
        var oldSize = old.byteLength;
        if (Module['usingWasm']) {
          try {
            var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize);
            if (result !== (-1 | 0)) {
              return (Module['buffer'] = Module['wasmMemory'].buffer)
            } else {
              return null
            }
          } catch (e) {
            return null
          }
        }
      };
      Module['reallocBuffer'] = function (size) {
        if (finalMethod === 'asmjs') {
          return asmjsReallocBuffer(size)
        } else {
          return wasmReallocBuffer(size)
        }
      };
      var finalMethod = '';
      Module['asm'] = function (global, env, providedBuffer) {
        env = fixImports(env);
        if (!env['table']) {
          var TABLE_SIZE = Module['wasmTableSize'];
          if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;
          var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];
          if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {
            if (MAX_TABLE_SIZE !== undefined) {
              env['table'] = new WebAssembly.Table({ initial: TABLE_SIZE, maximum: MAX_TABLE_SIZE, element: 'anyfunc' });
            } else {
              env['table'] = new WebAssembly.Table({ initial: TABLE_SIZE, element: 'anyfunc' });
            }
          } else {
            env['table'] = new Array(TABLE_SIZE);
          }
          Module['wasmTable'] = env['table'];
        }
        if (!env['memoryBase']) {
          env['memoryBase'] = Module['STATIC_BASE'];
        }
        if (!env['tableBase']) {
          env['tableBase'] = 0;
        }
        var exports;
        exports = doNativeWasm(global, env);
        if (!exports)
          abort(
            'no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods'
          );
        return exports
      };
    }
    integrateWasmJS();
    STATIC_BASE = GLOBAL_BASE;
    STATICTOP = STATIC_BASE + 66960;
    __ATINIT__.push(
      {
        func: function () {
          __GLOBAL__sub_I_global_cpp();
        },
      },
      {
        func: function () {
          __GLOBAL__sub_I_crc_cpp();
        },
      },
      {
        func: function () {
          __GLOBAL__sub_I_bridge_cpp();
        },
      },
      {
        func: function () {
          __GLOBAL__sub_I_bind_cpp();
        },
      }
    );
    var STATIC_BUMP = 66960;
    Module['STATIC_BASE'] = STATIC_BASE;
    Module['STATIC_BUMP'] = STATIC_BUMP;
    STATICTOP += 16;
    function ___cxa_allocate_exception(size) {
      return _malloc(size)
    }
    function __ZSt18uncaught_exceptionv() {
      return !!__ZSt18uncaught_exceptionv.uncaught_exception
    }
    var EXCEPTIONS = {
      last: 0,
      caught: [],
      infos: {},
      deAdjust: function (adjusted) {
        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted
        for (var key in EXCEPTIONS.infos) {
          var ptr = +key;
          var info = EXCEPTIONS.infos[ptr];
          if (info.adjusted === adjusted) {
            return ptr
          }
        }
        return adjusted
      },
      addRef: function (ptr) {
        if (!ptr) return
        var info = EXCEPTIONS.infos[ptr];
        info.refcount++;
      },
      decRef: function (ptr) {
        if (!ptr) return
        var info = EXCEPTIONS.infos[ptr];
        assert(info.refcount > 0);
        info.refcount--;
        if (info.refcount === 0 && !info.rethrown) {
          if (info.destructor) {
            Module['dynCall_vi'](info.destructor, ptr);
          }
          delete EXCEPTIONS.infos[ptr];
          ___cxa_free_exception(ptr);
        }
      },
      clearRef: function (ptr) {
        if (!ptr) return
        var info = EXCEPTIONS.infos[ptr];
        info.refcount = 0;
      },
    };
    function ___cxa_begin_catch(ptr) {
      var info = EXCEPTIONS.infos[ptr];
      if (info && !info.caught) {
        info.caught = true;
        __ZSt18uncaught_exceptionv.uncaught_exception--;
      }
      if (info) info.rethrown = false;
      EXCEPTIONS.caught.push(ptr);
      EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));
      return ptr
    }
    function ___cxa_free_exception(ptr) {
      try {
        return _free(ptr)
      } catch (e) {}
    }
    function ___cxa_end_catch() {
      Module['setThrew'](0);
      var ptr = EXCEPTIONS.caught.pop();
      if (ptr) {
        EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));
        EXCEPTIONS.last = 0;
      }
    }
    function ___cxa_find_matching_catch_2() {
      return ___cxa_find_matching_catch.apply(null, arguments)
    }
    function ___cxa_find_matching_catch_3() {
      return ___cxa_find_matching_catch.apply(null, arguments)
    }
    function ___cxa_find_matching_catch_4() {
      return ___cxa_find_matching_catch.apply(null, arguments)
    }
    function ___resumeException(ptr) {
      if (!EXCEPTIONS.last) {
        EXCEPTIONS.last = ptr;
      }
      throw ptr
    }
    function ___cxa_find_matching_catch() {
      var thrown = EXCEPTIONS.last;
      if (!thrown) {
        return (setTempRet0(0), 0) | 0
      }
      var info = EXCEPTIONS.infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        return (setTempRet0(0), thrown) | 0
      }
      var typeArray = Array.prototype.slice.call(arguments);
      Module['___cxa_is_pointer_type'](throwntype);
      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);
      HEAP32[___cxa_find_matching_catch.buffer >> 2] = thrown;
      thrown = ___cxa_find_matching_catch.buffer;
      for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[thrown >> 2];
          info.adjusted = thrown;
          return (setTempRet0(typeArray[i]), thrown) | 0
        }
      }
      thrown = HEAP32[thrown >> 2];
      return (setTempRet0(throwntype), thrown) | 0
    }
    function ___cxa_throw(ptr, type, destructor) {
      EXCEPTIONS.infos[ptr] = {
        ptr: ptr,
        adjusted: ptr,
        type: type,
        destructor: destructor,
        refcount: 0,
        caught: false,
        rethrown: false,
      };
      EXCEPTIONS.last = ptr;
      if (!('uncaught_exception' in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr
    }
    function ___lock() {}
    var ERRNO_CODES = {
      EPERM: 1,
      ENOENT: 2,
      ESRCH: 3,
      EINTR: 4,
      EIO: 5,
      ENXIO: 6,
      E2BIG: 7,
      ENOEXEC: 8,
      EBADF: 9,
      ECHILD: 10,
      EAGAIN: 11,
      EWOULDBLOCK: 11,
      ENOMEM: 12,
      EACCES: 13,
      EFAULT: 14,
      ENOTBLK: 15,
      EBUSY: 16,
      EEXIST: 17,
      EXDEV: 18,
      ENODEV: 19,
      ENOTDIR: 20,
      EISDIR: 21,
      EINVAL: 22,
      ENFILE: 23,
      EMFILE: 24,
      ENOTTY: 25,
      ETXTBSY: 26,
      EFBIG: 27,
      ENOSPC: 28,
      ESPIPE: 29,
      EROFS: 30,
      EMLINK: 31,
      EPIPE: 32,
      EDOM: 33,
      ERANGE: 34,
      ENOMSG: 42,
      EIDRM: 43,
      ECHRNG: 44,
      EL2NSYNC: 45,
      EL3HLT: 46,
      EL3RST: 47,
      ELNRNG: 48,
      EUNATCH: 49,
      ENOCSI: 50,
      EL2HLT: 51,
      EDEADLK: 35,
      ENOLCK: 37,
      EBADE: 52,
      EBADR: 53,
      EXFULL: 54,
      ENOANO: 55,
      EBADRQC: 56,
      EBADSLT: 57,
      EDEADLOCK: 35,
      EBFONT: 59,
      ENOSTR: 60,
      ENODATA: 61,
      ETIME: 62,
      ENOSR: 63,
      ENONET: 64,
      ENOPKG: 65,
      EREMOTE: 66,
      ENOLINK: 67,
      EADV: 68,
      ESRMNT: 69,
      ECOMM: 70,
      EPROTO: 71,
      EMULTIHOP: 72,
      EDOTDOT: 73,
      EBADMSG: 74,
      ENOTUNIQ: 76,
      EBADFD: 77,
      EREMCHG: 78,
      ELIBACC: 79,
      ELIBBAD: 80,
      ELIBSCN: 81,
      ELIBMAX: 82,
      ELIBEXEC: 83,
      ENOSYS: 38,
      ENOTEMPTY: 39,
      ENAMETOOLONG: 36,
      ELOOP: 40,
      EOPNOTSUPP: 95,
      EPFNOSUPPORT: 96,
      ECONNRESET: 104,
      ENOBUFS: 105,
      EAFNOSUPPORT: 97,
      EPROTOTYPE: 91,
      ENOTSOCK: 88,
      ENOPROTOOPT: 92,
      ESHUTDOWN: 108,
      ECONNREFUSED: 111,
      EADDRINUSE: 98,
      ECONNABORTED: 103,
      ENETUNREACH: 101,
      ENETDOWN: 100,
      ETIMEDOUT: 110,
      EHOSTDOWN: 112,
      EHOSTUNREACH: 113,
      EINPROGRESS: 115,
      EALREADY: 114,
      EDESTADDRREQ: 89,
      EMSGSIZE: 90,
      EPROTONOSUPPORT: 93,
      ESOCKTNOSUPPORT: 94,
      EADDRNOTAVAIL: 99,
      ENETRESET: 102,
      EISCONN: 106,
      ENOTCONN: 107,
      ETOOMANYREFS: 109,
      EUSERS: 87,
      EDQUOT: 122,
      ESTALE: 116,
      ENOTSUP: 95,
      ENOMEDIUM: 123,
      EILSEQ: 84,
      EOVERFLOW: 75,
      ECANCELED: 125,
      ENOTRECOVERABLE: 131,
      EOWNERDEAD: 130,
      ESTRPIPE: 86,
    };
    function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value;
      return value
    }
    function ___map_file(pathname, size) {
      ___setErrNo(ERRNO_CODES.EPERM);
      return -1
    }
    var ERRNO_MESSAGES = {
      0: 'Success',
      1: 'Not super-user',
      2: 'No such file or directory',
      3: 'No such process',
      4: 'Interrupted system call',
      5: 'I/O error',
      6: 'No such device or address',
      7: 'Arg list too long',
      8: 'Exec format error',
      9: 'Bad file number',
      10: 'No children',
      11: 'No more processes',
      12: 'Not enough core',
      13: 'Permission denied',
      14: 'Bad address',
      15: 'Block device required',
      16: 'Mount device busy',
      17: 'File exists',
      18: 'Cross-device link',
      19: 'No such device',
      20: 'Not a directory',
      21: 'Is a directory',
      22: 'Invalid argument',
      23: 'Too many open files in system',
      24: 'Too many open files',
      25: 'Not a typewriter',
      26: 'Text file busy',
      27: 'File too large',
      28: 'No space left on device',
      29: 'Illegal seek',
      30: 'Read only file system',
      31: 'Too many links',
      32: 'Broken pipe',
      33: 'Math arg out of domain of func',
      34: 'Math result not representable',
      35: 'File locking deadlock error',
      36: 'File or path name too long',
      37: 'No record locks available',
      38: 'Function not implemented',
      39: 'Directory not empty',
      40: 'Too many symbolic links',
      42: 'No message of desired type',
      43: 'Identifier removed',
      44: 'Channel number out of range',
      45: 'Level 2 not synchronized',
      46: 'Level 3 halted',
      47: 'Level 3 reset',
      48: 'Link number out of range',
      49: 'Protocol driver not attached',
      50: 'No CSI structure available',
      51: 'Level 2 halted',
      52: 'Invalid exchange',
      53: 'Invalid request descriptor',
      54: 'Exchange full',
      55: 'No anode',
      56: 'Invalid request code',
      57: 'Invalid slot',
      59: 'Bad font file fmt',
      60: 'Device not a stream',
      61: 'No data (for no delay io)',
      62: 'Timer expired',
      63: 'Out of streams resources',
      64: 'Machine is not on the network',
      65: 'Package not installed',
      66: 'The object is remote',
      67: 'The link has been severed',
      68: 'Advertise error',
      69: 'Srmount error',
      70: 'Communication error on send',
      71: 'Protocol error',
      72: 'Multihop attempted',
      73: 'Cross mount point (not really error)',
      74: 'Trying to read unreadable message',
      75: 'Value too large for defined data type',
      76: 'Given log. name not unique',
      77: 'f.d. invalid for this operation',
      78: 'Remote address changed',
      79: 'Can   access a needed shared lib',
      80: 'Accessing a corrupted shared lib',
      81: '.lib section in a.out corrupted',
      82: 'Attempting to link in too many libs',
      83: 'Attempting to exec a shared library',
      84: 'Illegal byte sequence',
      86: 'Streams pipe error',
      87: 'Too many users',
      88: 'Socket operation on non-socket',
      89: 'Destination address required',
      90: 'Message too long',
      91: 'Protocol wrong type for socket',
      92: 'Protocol not available',
      93: 'Unknown protocol',
      94: 'Socket type not supported',
      95: 'Not supported',
      96: 'Protocol family not supported',
      97: 'Address family not supported by protocol family',
      98: 'Address already in use',
      99: 'Address not available',
      100: 'Network interface is not configured',
      101: 'Network is unreachable',
      102: 'Connection reset by network',
      103: 'Connection aborted',
      104: 'Connection reset by peer',
      105: 'No buffer space available',
      106: 'Socket is already connected',
      107: 'Socket is not connected',
      108: "Can't send after socket shutdown",
      109: 'Too many references',
      110: 'Connection timed out',
      111: 'Connection refused',
      112: 'Host is down',
      113: 'Host is unreachable',
      114: 'Socket already connected',
      115: 'Connection already in progress',
      116: 'Stale file handle',
      122: 'Quota exceeded',
      123: 'No medium (in tape drive)',
      125: 'Operation canceled',
      130: 'Previous owner died',
      131: 'State not recoverable',
    };
    var PATH = {
      splitPath: function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1)
      },
      normalizeArray: function (parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts
      },
      normalize: function (path) {
        var isAbsolute = path.charAt(0) === '/',
          trailingSlash = path.substr(-1) === '/';
        path = PATH.normalizeArray(
          path.split('/').filter(function (p) {
            return !!p
          }),
          !isAbsolute
        ).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path
      },
      dirname: function (path) {
        var result = PATH.splitPath(path),
          root = result[0],
          dir = result[1];
        if (!root && !dir) {
          return '.'
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir
      },
      basename: function (path) {
        if (path === '/') return '/'
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path
        return path.substr(lastSlash + 1)
      },
      extname: function (path) {
        return PATH.splitPath(path)[3]
      },
      join: function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'))
      },
      join2: function (l, r) {
        return PATH.normalize(l + '/' + r)
      },
      resolve: function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : FS.cwd();
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings')
          } else if (!path) {
            return ''
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        resolvedPath = PATH.normalizeArray(
          resolvedPath.split('/').filter(function (p) {
            return !!p
          }),
          !resolvedAbsolute
        ).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.'
      },
      relative: function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break
          }
          if (start > end) return []
          return arr.slice(start, end - start + 1)
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/')
      },
    };
    var TTY = {
      ttys: [],
      init: function () {},
      shutdown: function () {},
      register: function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
      stream_ops: {
        open: function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
          }
          stream.tty = tty;
          stream.seekable = false;
        },
        close: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        flush: function (stream) {
          stream.tty.ops.flush(stream.tty);
        },
        read: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO)
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO)
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)
            }
            if (result === null || result === undefined) break
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead
        },
        write: function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO)
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO)
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i
        },
      },
      default_tty_ops: {
        get_char: function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = new Buffer(BUFSIZE);
              var bytesRead = 0;
              var isPosixPlatform = process.platform != 'win32';
              var fd = process.stdin.fd;
              if (isPosixPlatform) {
                var usingDevice = false;
                try {
                  fd = fs.openSync('/dev/stdin', 'r');
                  usingDevice = true;
                } catch (e) {}
              }
              try {
                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;
                else throw e
              }
              if (usingDevice) {
                fs.closeSync(fd);
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else if (typeof window != 'undefined' && typeof window.prompt == 'function') {
              result = window.prompt('Input: ');
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift()
        },
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
      default_tty1_ops: {
        put_char: function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
        flush: function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
      },
    };
    var MEMFS = {
      ops_table: null,
      mount: function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511, 0)
      },
      createNode: function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink,
              },
              stream: { llseek: MEMFS.stream_ops.llseek },
            },
            file: {
              node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync,
              },
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink,
              },
              stream: {},
            },
            chrdev: {
              node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
              stream: FS.chrdev_stream_ops,
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
        }
        return node
      },
      getFileDataAsRegularArray: function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr
        }
        return node.contents
      },
      getFileDataAsTypedArray: function (node) {
        if (!node.contents) return new Uint8Array()
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes)
        return new Uint8Array(node.contents)
      },
      expandFileStorage: function (node, newCapacity) {
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length;
        }
        if (!node.contents || node.contents.subarray) {
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity) return
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          return
        }
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },
      resizeFileStorage: function (node, newSize) {
        if (node.usedBytes == newSize) return
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
          return
        }
        if (!node.contents || node.contents.subarray) {
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize));
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }
          node.usedBytes = newSize;
          return
        }
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },
      node_ops: {
        getattr: function (node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
        lookup: function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT]
        },
        mknod: function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev)
        },
        rename: function (old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },
        unlink: function (parent, name) {
          delete parent.contents[name];
        },
        rmdir: function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
          }
          delete parent.contents[name];
        },
        readdir: function (node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue
            }
            entries.push(key);
          }
          return entries
        },
        symlink: function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node
        },
        readlink: function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
          }
          return node.link
        },
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) {
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size
        },
        write: function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer.subarray)
            node.contents.set(buffer.subarray(offset, offset + length), position);
          else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
          }
          return position
        },
        allocate: function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
        mmap: function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated }
        },
        msync: function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
          }
          if (mmapFlags & 2) {
            return 0
          }
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0
        },
      },
    };
    var IDBFS = {
      dbs: {},
      indexedDB: function () {
        if (typeof indexedDB !== 'undefined') return indexedDB
        var ret = null;
        if (typeof window === 'object')
          ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret
      },
      DB_VERSION: 21,
      DB_STORE_NAME: 'FILE_DATA',
      mount: function (mount) {
        return MEMFS.mount.apply(null, arguments)
      },
      syncfs: function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function (err, local) {
          if (err) return callback(err)
          IDBFS.getRemoteSet(mount, function (err, remote) {
            if (err) return callback(err)
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },
      getDB: function (name, callback) {
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db)
        }
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e)
        }
        if (!req) {
          return callback('Unable to connect to IndexedDB')
        }
        req.onupgradeneeded = function (e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
          var fileStore;
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function () {
          db = req.result;
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function (e) {
          callback(this.error);
          e.preventDefault();
        };
      },
      getLocalSet: function (mount, callback) {
        var entries = {};
        function isRealDir(p) {
          return p !== '.' && p !== '..'
        }
        function toAbsolute(root) {
          return function (p) {
            return PATH.join2(root, p)
          }
        }
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
        while (check.length) {
          var path = check.pop();
          var stat;
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e)
          }
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
          entries[path] = { timestamp: stat.mtime };
        }
        return callback(null, { type: 'local', entries: entries })
      },
      getRemoteSet: function (mount, callback) {
        var entries = {};
        IDBFS.getDB(mount.mountpoint, function (err, db) {
          if (err) return callback(err)
          try {
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
            transaction.onerror = function (e) {
              callback(this.error);
              e.preventDefault();
            };
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            var index = store.index('timestamp');
            index.openKeyCursor().onsuccess = function (event) {
              var cursor = event.target.result;
              if (!cursor) {
                return callback(null, { type: 'remote', db: db, entries: entries })
              }
              entries[cursor.primaryKey] = { timestamp: cursor.key };
              cursor.continue();
            };
          } catch (e) {
            return callback(e)
          }
        });
      },
      loadLocalEntry: function (path, callback) {
        var stat, node;
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e)
        }
        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode })
        } else if (FS.isFile(stat.mode)) {
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents })
        } else {
          return callback(new Error('node type not supported'))
        }
      },
      storeLocalEntry: function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { canOwn: true });
          } else {
            return callback(new Error('node type not supported'))
          }
          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e)
        }
        callback(null);
      },
      removeLocalEntry: function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e)
        }
        callback(null);
      },
      loadRemoteEntry: function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function (event) {
          callback(null, event.target.result);
        };
        req.onerror = function (e) {
          callback(this.error);
          e.preventDefault();
        };
      },
      storeRemoteEntry: function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function () {
          callback(null);
        };
        req.onerror = function (e) {
          callback(this.error);
          e.preventDefault();
        };
      },
      removeRemoteEntry: function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function () {
          callback(null);
        };
        req.onerror = function (e) {
          callback(this.error);
          e.preventDefault();
        };
      },
      reconcile: function (src, dst, callback) {
        var total = 0;
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
        if (!total) {
          return callback(null)
        }
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err)
            }
            return
          }
          if (++completed >= total) {
            return callback(null)
          }
        }
        transaction.onerror = function (e) {
          done(this.error);
          e.preventDefault();
        };
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err)
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err)
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
        remove
          .sort()
          .reverse()
          .forEach(function (path) {
            if (dst.type === 'local') {
              IDBFS.removeLocalEntry(path, done);
            } else {
              IDBFS.removeRemoteEntry(store, path, done);
            }
          });
      },
    };
    var NODEFS = {
      isWindows: false,
      staticInit: function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
        var flags = process['binding']('constants');
        if (flags['fs']) {
          flags = flags['fs'];
        }
        NODEFS.flagsForNodeMap = {
          1024: flags['O_APPEND'],
          64: flags['O_CREAT'],
          128: flags['O_EXCL'],
          0: flags['O_RDONLY'],
          2: flags['O_RDWR'],
          4096: flags['O_SYNC'],
          512: flags['O_TRUNC'],
          1: flags['O_WRONLY'],
        };
      },
      bufferFrom: function (arrayBuffer) {
        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer)
      },
      mount: function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0)
      },
      createNode: function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node
      },
      getMode: function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            stat.mode = stat.mode | ((stat.mode & 292) >> 2);
          }
        } catch (e) {
          if (!e.code) throw e
          throw new FS.ErrnoError(ERRNO_CODES[e.code])
        }
        return stat.mode
      },
      realPath: function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts)
      },
      flagsForNode: function (flags) {
        flags &= ~2097152;
        flags &= ~2048;
        flags &= ~32768;
        flags &= ~524288;
        var newFlags = 0;
        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }
        if (!flags) {
          return newFlags
        } else {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
      },
      node_ops: {
        getattr: function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = ((stat.size + stat.blksize - 1) / stat.blksize) | 0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks,
          }
        },
        setattr: function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        lookup: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode)
        },
        mknod: function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
          return node
        },
        rename: function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        unlink: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        rmdir: function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        readdir: function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path)
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        symlink: function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        readlink: function (node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
      },
      stream_ops: {
        open: function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        close: function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        read: function (stream, buffer, offset, length, position) {
          if (length === 0) return 0
          try {
            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        write: function (stream, buffer, offset, length, position) {
          try {
            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position)
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
          }
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
              }
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
          }
          return position
        },
      },
    };
    var WORKERFS = {
      DIR_MODE: 16895,
      FILE_MODE: 33279,
      reader: null,
      mount: function (mount) {
        assert(ENVIRONMENT_IS_WORKER);
        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();
        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);
        var createdParents = {};
        function ensureParent(path) {
          var parts = path.split('/');
          var parent = root;
          for (var i = 0; i < parts.length - 1; i++) {
            var curr = parts.slice(0, i + 1).join('/');
            if (!createdParents[curr]) {
              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);
            }
            parent = createdParents[curr];
          }
          return parent
        }
        function base(path) {
          var parts = path.split('/');
          return parts[parts.length - 1]
        }
        Array.prototype.forEach.call(mount.opts['files'] || [], function (file) {
          WORKERFS.createNode(
            ensureParent(file.name),
            base(file.name),
            WORKERFS.FILE_MODE,
            0,
            file,
            file.lastModifiedDate
          );
        })
        ;(mount.opts['blobs'] || []).forEach(function (obj) {
          WORKERFS.createNode(ensureParent(obj['name']), base(obj['name']), WORKERFS.FILE_MODE, 0, obj['data']);
        })
        ;(mount.opts['packages'] || []).forEach(function (pack) {
          pack['metadata'].files.forEach(function (file) {
            var name = file.filename.substr(1);
            WORKERFS.createNode(
              ensureParent(name),
              base(name),
              WORKERFS.FILE_MODE,
              0,
              pack['blob'].slice(file.start, file.end)
            );
          });
        });
        return root
      },
      createNode: function (parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = WORKERFS.node_ops;
        node.stream_ops = WORKERFS.stream_ops;
        node.timestamp = (mtime || new Date()).getTime();
        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
        if (mode === WORKERFS.FILE_MODE) {
          node.size = contents.size;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node
      },
      node_ops: {
        getattr: function (node) {
          return {
            dev: 1,
            ino: undefined,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: undefined,
            size: node.size,
            atime: new Date(node.timestamp),
            mtime: new Date(node.timestamp),
            ctime: new Date(node.timestamp),
            blksize: 4096,
            blocks: Math.ceil(node.size / 4096),
          }
        },
        setattr: function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
        },
        lookup: function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        },
        mknod: function (parent, name, mode, dev) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
        rename: function (oldNode, newDir, newName) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
        unlink: function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
        rmdir: function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
        readdir: function (node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue
            }
            entries.push(key);
          }
          return entries
        },
        symlink: function (parent, newName, oldPath) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
        readlink: function (node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        },
      },
      stream_ops: {
        read: function (stream, buffer, offset, length, position) {
          if (position >= stream.node.size) return 0
          var chunk = stream.node.contents.slice(position, position + length);
          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
          buffer.set(new Uint8Array(ab), offset);
          return chunk.size
        },
        write: function (stream, buffer, offset, length, position) {
          throw new FS.ErrnoError(ERRNO_CODES.EIO)
        },
        llseek: function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
          }
          return position
        },
      },
    };
    STATICTOP += 16;
    STATICTOP += 16;
    STATICTOP += 16;
    var FS = {
      root: null,
      mounts: [],
      devices: {},
      streams: [],
      nextInode: 1,
      nameTable: null,
      currentPath: '/',
      initialized: false,
      ignorePermissions: true,
      trackingDelegate: {},
      tracking: { openFlags: { READ: 1, WRITE: 2 } },
      ErrnoError: null,
      genericErrors: {},
      filesystems: null,
      syncFSRequests: 0,
      handleFSError: function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace()
        return ___setErrNo(e.errno)
      },
      lookupPath: function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
        if (!path) return { path: '', node: null }
        var defaults = { follow_mount: true, recurse_count: 0 };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP)
        }
        var parts = PATH.normalizeArray(
          path.split('/').filter(function (p) {
            return !!p
          }),
          false
        );
        var current = FS.root;
        var current_path = '/';
        for (var i = 0; i < parts.length; i++) {
          var islast = i === parts.length - 1;
          if (islast && opts.parent) {
            break
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP)
              }
            }
          }
        }
        return { path: current_path, node: current }
      },
      getPath: function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount
            return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },
      hashName: function (parentid, name) {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length
      },
      hashAddNode: function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
      hashRemoveNode: function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break
            }
            current = current.name_next;
          }
        }
      },
      lookupNode: function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent)
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node
          }
        }
        return FS.lookup(parent, name)
      },
      createNode: function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function (parent, name, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          FS.FSNode.prototype = {};
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function () {
                return (this.mode & readMode) === readMode
              },
              set: function (val) {
                val ? (this.mode |= readMode) : (this.mode &= ~readMode);
              },
            },
            write: {
              get: function () {
                return (this.mode & writeMode) === writeMode
              },
              set: function (val) {
                val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
              },
            },
            isFolder: {
              get: function () {
                return FS.isDir(this.mode)
              },
            },
            isDevice: {
              get: function () {
                return FS.isChrdev(this.mode)
              },
            },
          });
        }
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node
      },
      destroyNode: function (node) {
        FS.hashRemoveNode(node);
      },
      isRoot: function (node) {
        return node === node.parent
      },
      isMountpoint: function (node) {
        return !!node.mounted
      },
      isFile: function (mode) {
        return (mode & 61440) === 32768
      },
      isDir: function (mode) {
        return (mode & 61440) === 16384
      },
      isLink: function (mode) {
        return (mode & 61440) === 40960
      },
      isChrdev: function (mode) {
        return (mode & 61440) === 8192
      },
      isBlkdev: function (mode) {
        return (mode & 61440) === 24576
      },
      isFIFO: function (mode) {
        return (mode & 61440) === 4096
      },
      isSocket: function (mode) {
        return (mode & 49152) === 49152
      },
      flagModes: {
        r: 0,
        rs: 1052672,
        'r+': 2,
        w: 577,
        wx: 705,
        xw: 705,
        'w+': 578,
        'wx+': 706,
        'xw+': 706,
        a: 1089,
        ax: 1217,
        xa: 1217,
        'a+': 1090,
        'ax+': 1218,
        'xa+': 1218,
      },
      modeStringToFlags: function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str)
        }
        return flags
      },
      flagsToPermissionString: function (flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if (flag & 512) {
          perms += 'w';
        }
        return perms
      },
      nodePermissions: function (node, perms) {
        if (FS.ignorePermissions) {
          return 0
        }
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES
        }
        return 0
      },
      mayLookup: function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES
        return 0
      },
      mayCreate: function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST
        } catch (e) {}
        return FS.nodePermissions(dir, 'wx')
      },
      mayDelete: function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR
          }
        }
        return 0
      },
      mayOpen: function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
            return ERRNO_CODES.EISDIR
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags))
      },
      MAX_OPEN_FDS: 4096,
      nextfd: function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE)
      },
      getStream: function (fd) {
        return FS.streams[fd]
      },
      createStream: function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function () {};
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function () {
                return this.node
              },
              set: function (val) {
                this.node = val;
              },
            },
            isRead: {
              get: function () {
                return (this.flags & 2097155) !== 1
              },
            },
            isWrite: {
              get: function () {
                return (this.flags & 2097155) !== 0
              },
            },
            isAppend: {
              get: function () {
                return this.flags & 1024
              },
            },
          });
        }
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream
      },
      closeStream: function (fd) {
        FS.streams[fd] = null;
      },
      chrdev_stream_ops: {
        open: function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },
        llseek: function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        },
      },
      major: function (dev) {
        return dev >> 8
      },
      minor: function (dev) {
        return dev & 255
      },
      makedev: function (ma, mi) {
        return (ma << 8) | mi
      },
      registerDevice: function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
      getDevice: function (dev) {
        return FS.devices[dev]
      },
      getMounts: function (mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
          var m = check.pop();
          mounts.push(m);
          check.push.apply(check, m.mounts);
        }
        return mounts
      },
      syncfs: function (populate, callback) {
        if (typeof populate === 'function') {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          console.log(
            'warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work'
          );
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(err) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(err)
        }
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(err)
            }
            return
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null)
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
      mount: function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
          }
        }
        var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot
      },
      unmount: function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
          while (current) {
            var next = current.name_next;
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },
      lookup: function (parent, name) {
        return parent.node_ops.lookup(parent, name)
      },
      mknod: function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return parent.node_ops.mknod(parent, name, mode, dev)
      },
      create: function (path, mode) {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0)
      },
      mkdir: function (path, mode) {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0)
      },
      mkdirTree: function (path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != ERRNO_CODES.EEXIST) throw e
          }
        }
      },
      mkdev: function (path, mode, dev) {
        if (typeof dev === 'undefined') {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev)
      },
      symlink: function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return parent.node_ops.symlink(parent, newname, oldpath)
      },
      rename: function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV)
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}
        if (old_node === new_node) {
          return
        }
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err)
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch (e) {
          console.log(
            "FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message
          );
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e
        } finally {
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch (e) {
          console.log(
            "FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message
          );
        }
      },
      rmdir: function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch (e) {
          console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch (e) {
          console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      },
      readdir: function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        return node.node_ops.readdir(node)
      },
      unlink: function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch (e) {
          console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch (e) {
          console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
        }
      },
      readlink: function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))
      },
      stat: function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return node.node_ops.getattr(node)
      },
      lstat: function (path) {
        return FS.stat(path, true)
      },
      chmod: function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        node.node_ops.setattr(node, { mode: (mode & 4095) | (node.mode & ~4095), timestamp: Date.now() });
      },
      lchmod: function (path, mode) {
        FS.chmod(path, mode, true);
      },
      fchmod: function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        FS.chmod(stream.node, mode);
      },
      chown: function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        node.node_ops.setattr(node, { timestamp: Date.now() });
      },
      lchown: function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
      fchown: function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        FS.chown(stream.node, uid, gid);
      },
      truncate: function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err)
        }
        node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
      },
      ftruncate: function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        FS.truncate(stream.node, len);
      },
      utime: function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
      },
      open: function (path, flags, mode, fd_start, fd_end) {
        if (path === '') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 : mode;
        if (flags & 64) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
            node = lookup.node;
          } catch (e) {}
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST)
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err)
          }
        }
        if (flags & 512) {
          FS.truncate(node, 0);
        }
        flags &= ~(128 | 512);
        var stream = FS.createStream(
          {
            node: node,
            path: FS.getPath(node),
            flags: flags,
            seekable: true,
            position: 0,
            stream_ops: node.stream_ops,
            ungotten: [],
            error: false,
          },
          fd_start,
          fd_end
        );
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch (e) {
          console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
        }
        return stream
      },
      close: function (stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
      isClosed: function (stream) {
        return stream.fd === null
      },
      llseek: function (stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position
      },
      read: function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead
      },
      write: function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if (stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch (e) {
          console.log("FS.trackingDelegate['onWriteToFile']('" + path + "') threw an exception: " + e.message);
        }
        return bytesWritten
      },
      allocate: function (stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
      mmap: function (stream, buffer, offset, length, position, prot, flags) {
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES)
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags)
      },
      msync: function (stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)
      },
      munmap: function (stream) {
        return 0
      },
      ioctl: function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)
        }
        return stream.stream_ops.ioctl(stream, cmd, arg)
      },
      readFile: function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"')
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret
      },
      writeFile: function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type')
        }
        FS.close(stream);
      },
      cwd: function () {
        return FS.currentPath
      },
      chdir: function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err)
        }
        FS.currentPath = lookup.path;
      },
      createDefaultDirectories: function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
      createDefaultDevices: function () {
        FS.mkdir('/dev');
        FS.registerDevice(FS.makedev(1, 3), {
          read: function () {
            return 0
          },
          write: function (stream, buffer, offset, length, pos) {
            return length
          },
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        var random_device;
        if (typeof crypto !== 'undefined') {
          var randomBuffer = new Uint8Array(1);
          random_device = function () {
            crypto.getRandomValues(randomBuffer);
            return randomBuffer[0]
          };
        } else if (ENVIRONMENT_IS_NODE) {
          random_device = function () {
            return require('crypto')['randomBytes'](1)[0]
          };
        } else {
          random_device = function () {
            return (Math.random() * 256) | 0
          };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
      createSpecialDirectories: function () {
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount(
          {
            mount: function () {
              var node = FS.createNode('/proc/self', 'fd', 16384 | 511, 73);
              node.node_ops = {
                lookup: function (parent, name) {
                  var fd = +name;
                  var stream = FS.getStream(fd);
                  if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF)
                  var ret = {
                    parent: null,
                    mount: { mountpoint: 'fake' },
                    node_ops: {
                      readlink: function () {
                        return stream.path
                      },
                    },
                  };
                  ret.parent = ret;
                  return ret
                },
              };
              return node
            },
          },
          {},
          '/proc/self/fd'
        );
      },
      createStandardStreams: function () {
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
        var stdin = FS.open('/dev/stdin', 'r');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        var stdout = FS.open('/dev/stdout', 'w');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        var stderr = FS.open('/dev/stderr', 'w');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },
      ensureErrnoError: function () {
        if (FS.ErrnoError) return
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function (errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
          if (this.stack) Object.defineProperty(this, 'stack', { value: new Error().stack, writable: true });
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError
        ;[ERRNO_CODES.ENOENT].forEach(function (code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },
      staticInit: function () {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, '/');
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = { MEMFS: MEMFS, IDBFS: IDBFS, NODEFS: NODEFS, WORKERFS: WORKERFS };
      },
      init: function (input, output, error) {
        assert(
          !FS.init.initialized,
          'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)'
        );
        FS.init.initialized = true;
        FS.ensureErrnoError();
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
        FS.createStandardStreams();
      },
      quit: function () {
        FS.init.initialized = false;
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue
          }
          FS.close(stream);
        }
      },
      getMode: function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode
      },
      joinPath: function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path
      },
      absolutePath: function (relative, base) {
        return PATH.resolve(base, relative)
      },
      standardizePath: function (path) {
        return PATH.normalize(path)
      },
      findObject: function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object
        } else {
          ___setErrNo(ret.error);
          return null
        }
      },
      analyzePath: function (path, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {}
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null,
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        }
        return ret
      },
      createFolder: function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode)
      },
      createPath: function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {}
          parent = current;
        }
        return current
      },
      createFile: function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode)
      },
      createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node
      },
      createDevice: function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
          open: function (stream) {
            stream.seekable = false;
          },
          close: function (stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function (stream, buffer, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO)
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)
              }
              if (result === null || result === undefined) break
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead
          },
          write: function (stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO)
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i
          },
        });
        return FS.mkdev(path, mode, dev)
      },
      createLink: function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path)
      },
      forceLoadFile: function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error(
            'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.'
          )
        } else if (Module['read']) {
          try {
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.')
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success
      },
      createLazyFile: function (parent, name, url, canRead, canWrite) {
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = [];
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return undefined
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize) | 0;
          return this.getter(chunkNum)[chunkOffset]
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
            throw new Error("Couldn't load " + url + '. Status: ' + xhr.status)
          var datalength = Number(xhr.getResponseHeader('Content-length'));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes';
          var usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip';
          var chunkSize = 1024 * 1024;
          if (!hasByteServing) chunkSize = datalength;
          var doXHR = function (from, to) {
            if (from > to) throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!')
            if (to > datalength - 1) throw new Error('only ' + datalength + ' bytes available! programmer error!')
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
            xhr.send(null);
            if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
              throw new Error("Couldn't load " + url + '. Status: ' + xhr.status)
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || [])
            } else {
              return intArrayFromString(xhr.responseText || '', true)
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter(function (chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum + 1) * chunkSize - 1;
            end = Math.min(end, datalength - 1);
            if (typeof lazyArray.chunks[chunkNum] === 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] === 'undefined') throw new Error('doXHR failed!')
            return lazyArray.chunks[chunkNum]
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            console.log('LazyFiles on gzip forces download of the whole file when length is accessed');
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER)
            throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc'
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length
              },
            },
            chunkSize: {
              get: function () {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize
              },
            },
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, {
          usedBytes: {
            get: function () {
              return this.contents.length
            },
          },
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function (key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO)
            }
            return fn.apply(null, arguments)
          };
        });
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO)
          }
          var contents = stream.node.contents;
          if (position >= contents.length) return 0
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size
        };
        node.stream_ops = stream_ops;
        return node
      },
      createPreloadedFile: function (
        parent,
        name,
        url,
        canRead,
        canWrite,
        onload,
        onerror,
        dontCreateFile,
        canOwn,
        preFinish
      ) {
        Browser.init();
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency();
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function (plugin) {
            if (handled) return
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function () {
                if (onerror) onerror();
                removeRunDependency();
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency();
        if (typeof url == 'string') {
          Browser.asyncLoad(
            url,
            function (byteArray) {
              processData(byteArray);
            },
            onerror
          );
        } else {
          processData(url);
        }
      },
      indexedDB: function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB
      },
      DB_NAME: function () {
        return 'EM_FS_' + window.location.pathname
      },
      DB_VERSION: 20,
      DB_STORE_NAME: 'FILE_DATA',
      saveFilesToDB: function (paths, onload, onerror) {
        onload = onload || function () {};
        onerror = onerror || function () {};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e)
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach(function (path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() {
              ok++;
              if (ok + fail == total) finish();
            };
            putRequest.onerror = function putRequest_onerror() {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
      loadFilesFromDB: function (paths, onload, onerror) {
        onload = onload || function () {};
        onerror = onerror || function () {};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e)
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch (e) {
            onerror(e);
            return
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0,
            fail = 0,
            total = paths.length;
          function finish() {
            if (fail == 0) onload();
            else onerror();
          }
          paths.forEach(function (path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() {
              fail++;
              if (ok + fail == total) finish();
            };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },
    };
    var SYSCALLS = {
      DEFAULT_POLLMASK: 5,
      mappings: {},
      umask: 511,
      calculateAt: function (dirfd, path) {
        if (path[0] !== '/') {
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF)
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path
      },
      doStat: function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            return -ERRNO_CODES.ENOTDIR
          }
          throw e
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[(buf + 4) >> 2] = 0;
        HEAP32[(buf + 8) >> 2] = stat.ino;
        HEAP32[(buf + 12) >> 2] = stat.mode;
        HEAP32[(buf + 16) >> 2] = stat.nlink;
        HEAP32[(buf + 20) >> 2] = stat.uid;
        HEAP32[(buf + 24) >> 2] = stat.gid;
        HEAP32[(buf + 28) >> 2] = stat.rdev;
        HEAP32[(buf + 32) >> 2] = 0;
        HEAP32[(buf + 36) >> 2] = stat.size;
        HEAP32[(buf + 40) >> 2] = 4096;
        HEAP32[(buf + 44) >> 2] = stat.blocks;
        HEAP32[(buf + 48) >> 2] = (stat.atime.getTime() / 1e3) | 0;
        HEAP32[(buf + 52) >> 2] = 0;
        HEAP32[(buf + 56) >> 2] = (stat.mtime.getTime() / 1e3) | 0;
        HEAP32[(buf + 60) >> 2] = 0;
        HEAP32[(buf + 64) >> 2] = (stat.ctime.getTime() / 1e3) | 0;
        HEAP32[(buf + 68) >> 2] = 0;
        HEAP32[(buf + 72) >> 2] = stat.ino;
        return 0
      },
      doMsync: function (addr, stream, len, flags) {
        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
        FS.msync(stream, buffer, 0, len, flags);
      },
      doMkdir: function (path, mode) {
        path = PATH.normalize(path);
        if (path[path.length - 1] === '/') path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0
      },
      doMknod: function (path, mode, dev) {
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break
          default:
            return -ERRNO_CODES.EINVAL
        }
        FS.mknod(path, mode, dev);
        return 0
      },
      doReadlink: function (path, buf, bufsize) {
        if (bufsize <= 0) return -ERRNO_CODES.EINVAL
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len
      },
      doAccess: function (path, amode) {
        if (amode & ~7) {
          return -ERRNO_CODES.EINVAL
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms && FS.nodePermissions(node, perms)) {
          return -ERRNO_CODES.EACCES
        }
        return 0
      },
      doDup: function (path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd
      },
      doReadv: function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(iov + i * 8) >> 2];
          var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
          var curr = FS.read(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1
          ret += curr;
          if (curr < len) break
        }
        return ret
      },
      doWritev: function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(iov + i * 8) >> 2];
          var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
          var curr = FS.write(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1
          ret += curr;
        }
        return ret
      },
      varargs: 0,
      get: function (varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
        return ret
      },
      getStr: function () {
        var ret = Pointer_stringify(SYSCALLS.get());
        return ret
      },
      getStreamFromFD: function () {
        var stream = FS.getStream(SYSCALLS.get());
        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        return stream
      },
      getSocketFromFD: function () {
        var socket = SOCKFS.getSocket(SYSCALLS.get());
        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        return socket
      },
      getSocketAddress: function (allowNull) {
        var addrp = SYSCALLS.get(),
          addrlen = SYSCALLS.get();
        if (allowNull && addrp === 0) return null
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new FS.ErrnoError(info.errno)
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info
      },
      get64: function () {
        var low = SYSCALLS.get(),
          high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low
      },
      getZero: function () {
        assert(SYSCALLS.get() === 0);
      },
    };
    function ___syscall140(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(),
          offset_high = SYSCALLS.get(),
          offset_low = SYSCALLS.get(),
          result = SYSCALLS.get(),
          whence = SYSCALLS.get();
        var offset = offset_low;
        FS.llseek(stream, offset, whence);
        HEAP32[result >> 2] = stream.position;
        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
        return 0
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall145(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(),
          iov = SYSCALLS.get(),
          iovcnt = SYSCALLS.get();
        return SYSCALLS.doReadv(stream, iov, iovcnt)
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall146(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD(),
          iov = SYSCALLS.get(),
          iovcnt = SYSCALLS.get();
        return SYSCALLS.doWritev(stream, iov, iovcnt)
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall183(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var buf = SYSCALLS.get(),
          size = SYSCALLS.get();
        if (size === 0) return -ERRNO_CODES.EINVAL
        var cwd = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd);
        if (size < cwdLengthInBytes + 1) return -ERRNO_CODES.ERANGE
        stringToUTF8(cwd, buf, size);
        return buf
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall198(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var path = SYSCALLS.getStr(),
          owner = SYSCALLS.get(),
          group = SYSCALLS.get();
        FS.chown(path, owner, group);
        return 0
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    var PROCINFO = { ppid: 1, pid: 42, sid: 42, pgid: 42 };
    function ___syscall20(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        return PROCINFO.pid
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall6(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream = SYSCALLS.getStreamFromFD();
        FS.close(stream);
        return 0
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall60(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var mask = SYSCALLS.get();
        var old = SYSCALLS.umask;
        SYSCALLS.umask = mask;
        return old
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall83(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var target = SYSCALLS.getStr(),
          linkpath = SYSCALLS.getStr();
        FS.symlink(target, linkpath);
        return 0
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___syscall91(which, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var addr = SYSCALLS.get(),
          len = SYSCALLS.get();
        var info = SYSCALLS.mappings[addr];
        if (!info) return 0
        if (len === info.len) {
          var stream = FS.getStream(info.fd);
          SYSCALLS.doMsync(addr, stream, len, info.flags);
          FS.munmap(stream);
          SYSCALLS.mappings[addr] = null;
          if (info.allocated) {
            _free(info.malloc);
          }
        }
        return 0
      } catch (e) {
        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
      }
    }
    function ___unlock() {}
    var structRegistrations = {};
    function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    }
    function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2])
    }
    var awaitingDependencies = {};
    var registeredTypes = {};
    var typeDependencies = {};
    var char_0 = 48;
    var char_9 = 57;
    function makeLegalFunctionName(name) {
      if (undefined === name) {
        return '_unknown'
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return '_' + name
      } else {
        return name
      }
    }
    function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      return new Function(
        'body',
        'return function ' + name + '() {\n' + '    "use strict";' + '    return body.apply(this, arguments);\n' + '};\n'
      )(body)
    }
    function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function (message) {
        this.name = errorName;
        this.message = message;
        var stack = new Error(message).stack;
        if (stack !== undefined) {
          this.stack = this.toString() + '\n' + stack.replace(/^Error(:[^\n]*)?\n/, '');
        }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function () {
        if (this.message === undefined) {
          return this.name
        } else {
          return this.name + ': ' + this.message
        }
      };
      return errorClass
    }
    var InternalError = undefined;
    function throwInternalError(message) {
      throw new InternalError(message)
    }
    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function (type) {
        typeDependencies[type] = dependentTypes;
      });
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach(function (dt, i) {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(function () {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }
    function __embind_finalize_value_object(structType) {
      var reg = structRegistrations[structType];
      delete structRegistrations[structType];
      var rawConstructor = reg.rawConstructor;
      var rawDestructor = reg.rawDestructor;
      var fieldRecords = reg.fields;
      var fieldTypes = fieldRecords
        .map(function (field) {
          return field.getterReturnType
        })
        .concat(
          fieldRecords.map(function (field) {
            return field.setterArgumentType
          })
        );
      whenDependentTypesAreResolved([structType], fieldTypes, function (fieldTypes) {
        var fields = {};
        fieldRecords.forEach(function (field, i) {
          var fieldName = field.fieldName;
          var getterReturnType = fieldTypes[i];
          var getter = field.getter;
          var getterContext = field.getterContext;
          var setterArgumentType = fieldTypes[i + fieldRecords.length];
          var setter = field.setter;
          var setterContext = field.setterContext;
          fields[fieldName] = {
            read: function (ptr) {
              return getterReturnType['fromWireType'](getter(getterContext, ptr))
            },
            write: function (ptr, o) {
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
              runDestructors(destructors);
            },
          };
        });
        return [
          {
            name: reg.name,
            fromWireType: function (ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv
            },
            toWireType: function (destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field')
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr
            },
            argPackAdvance: 8,
            readValueFromPointer: simpleReadValueFromPointer,
            destructorFunction: rawDestructor,
          },
        ]
      });
    }
    function getShiftFromSize(size) {
      switch (size) {
        case 1:
          return 0
        case 2:
          return 1
        case 4:
          return 2
        case 8:
          return 3
        default:
          throw new TypeError('Unknown type size: ' + size)
      }
    }
    function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }
    var embind_charCodes = undefined;
    function readLatin1String(ptr) {
      var ret = '';
      var c = ptr;
      while (HEAPU8[c]) {
        ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret
    }
    var BindingError = undefined;
    function throwBindingError(message) {
      throw new BindingError(message)
    }
    function registerType(rawType, registeredInstance, options) {
      options = options || {};
      if (!('argPackAdvance' in registeredInstance)) {
        throw new TypeError('registerType registeredInstance requires argPackAdvance')
      }
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return
        } else {
          throwBindingError("Cannot register type '" + name + "' twice");
        }
      }
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach(function (cb) {
          cb();
        });
      }
    }
    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: function (wt) {
          return !!wt
        },
        toWireType: function (destructors, o) {
          return o ? trueValue : falseValue
        },
        argPackAdvance: 8,
        readValueFromPointer: function (pointer) {
          var heap;
          if (size === 1) {
            heap = HEAP8;
          } else if (size === 2) {
            heap = HEAP16;
          } else if (size === 4) {
            heap = HEAP32;
          } else {
            throw new TypeError('Unknown boolean type size: ' + name)
          }
          return this['fromWireType'](heap[pointer >> shift])
        },
        destructorFunction: null,
      });
    }
    function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false
      }
      if (!(other instanceof ClassHandle)) {
        return false
      }
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
      while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
      }
      while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
      }
      return leftClass === rightClass && left === right
    }
    function shallowCopyInternalPointer(o) {
      return {
        count: o.count,
        deleteScheduled: o.deleteScheduled,
        preservePointerOnDelete: o.preservePointerOnDelete,
        ptr: o.ptr,
        ptrType: o.ptrType,
        smartPtr: o.smartPtr,
        smartPtrType: o.smartPtrType,
      }
    }
    function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }
    function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;
        return this
      } else {
        var clone = Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } });
        clone.$$.count.value += 1;
        clone.$$.deleteScheduled = false;
        return clone
      }
    }
    function runDestructor(handle) {
      var $$ = handle.$$;
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }
    function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
      this.$$.count.value -= 1;
      var toDelete = 0 === this.$$.count.value;
      if (toDelete) {
        runDestructor(this);
      }
      if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = undefined;
        this.$$.ptr = undefined;
      }
    }
    function ClassHandle_isDeleted() {
      return !this.$$.ptr
    }
    var delayFunction = undefined;
    var deletionQueue = [];
    function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj['delete']();
      }
    }
    function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this
    }
    function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }
    function ClassHandle() {}
    var registeredPointers = {};
    function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        proto[methodName] = function () {
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
            throwBindingError(
              "Function '" +
                humanName +
                "' called with an invalid number of arguments (" +
                arguments.length +
                ') - expects one of (' +
                proto[methodName].overloadTable +
                ')!'
            );
          }
          return proto[methodName].overloadTable[arguments.length].apply(this, arguments)
        };
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }
    function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
        if (
          undefined === numArguments ||
          (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])
        ) {
          throwBindingError("Cannot register public name '" + name + "' twice");
        }
        ensureOverloadTable(Module, name, name);
        if (Module.hasOwnProperty(numArguments)) {
          throwBindingError(
            'Cannot register multiple overloads of a function with the same number of arguments (' + numArguments + ')!'
          );
        }
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        if (undefined !== numArguments) {
          Module[name].numArguments = numArguments;
        }
      }
    }
    function RegisteredClass(
      name,
      constructor,
      instancePrototype,
      rawDestructor,
      baseClass,
      getActualType,
      upcast,
      downcast
    ) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
    function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError('Expected null or instance of ' + desiredClass.name + ', got an instance of ' + ptrClass.name);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr
    }
    function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0
      }
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr
    }
    function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr
        } else {
          return 0
        }
      }
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(
          'Cannot convert argument of type ' +
            (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) +
            ' to parameter type ' +
            this.name
        );
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      if (this.isSmartPointer) {
        if (undefined === handle.$$.smartPtr) {
          throwBindingError('Passing raw pointer to smart pointer is illegal');
        }
        switch (this.sharingPolicy) {
          case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(
                'Cannot convert argument of type ' +
                  (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) +
                  ' to parameter type ' +
                  this.name
              );
            }
            break
          case 1:
            ptr = handle.$$.smartPtr;
            break
          case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle['clone']();
              ptr = this.rawShare(
                ptr,
                __emval_register(function () {
                  clonedHandle['delete']();
                })
              );
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break
          default:
            throwBindingError('Unsupporting sharing policy');
        }
      }
      return ptr
    }
    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError('null is not a valid ' + this.name);
        }
        return 0
      }
      if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
        throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr
    }
    function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }
      return ptr
    }
    function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }
    function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle['delete']();
      }
    }
    function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr
      }
      if (undefined === desiredClass.baseClass) {
        return null
      }
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null
      }
      return desiredClass.downcast(rv)
    }
    function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length
    }
    function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }
      return rv
    }
    function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }
    function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }
    var registeredInstances = {};
    function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
        throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
        ptr = class_.upcast(ptr);
        class_ = class_.baseClass;
      }
      return ptr
    }
    function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr]
    }
    function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return Object.create(prototype, { $$: { value: record } })
    }
    function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null
      }
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance['clone']()
        } else {
          var rv = registeredInstance['clone']();
          this.destructor(ptr);
          return rv
        }
      }
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: rawPointer,
            smartPtrType: this,
            smartPtr: ptr,
          })
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr: ptr })
        }
      }
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this)
      }
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
      if (dp === null) {
        return makeDefaultHandle.call(this)
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
          smartPtrType: this,
          smartPtr: ptr,
        })
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp })
      }
    }
    function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }
    function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this['toWireType'] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this['toWireType'] = genericPointerToWireType;
      }
    }
    function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistant public symbol');
      }
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    }
    function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
      function makeDynCaller(dynCall) {
        var args = [];
        for (var i = 1; i < signature.length; ++i) {
          args.push('a' + i);
        }
        var name = 'dynCall_' + signature + '_' + rawFunction;
        var body = 'return function ' + name + '(' + args.join(', ') + ') {\n';
        body += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\n';
        body += '};\n';
        return new Function('dynCall', 'rawFunction', body)(dynCall, rawFunction)
      }
      var fp;
      if (Module['FUNCTION_TABLE_' + signature] !== undefined) {
        fp = Module['FUNCTION_TABLE_' + signature][rawFunction];
      } else if (typeof FUNCTION_TABLE !== 'undefined') {
        fp = FUNCTION_TABLE[rawFunction];
      } else {
        var dc = Module['asm']['dynCall_' + signature];
        if (dc === undefined) {
          dc = Module['asm']['dynCall_' + signature.replace(/f/g, 'd')];
          if (dc === undefined) {
            throwBindingError('No dynCall invoker for signature: ' + signature);
          }
        }
        fp = makeDynCaller(dc);
      }
      if (typeof fp !== 'function') {
        throwBindingError('unknown function pointer with signature ' + signature + ': ' + rawFunction);
      }
      return fp
    }
    var UnboundTypeError = undefined;
    function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv
    }
    function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return
        }
        if (registeredTypes[type]) {
          return
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']))
    }
    function __embind_register_class(
      rawType,
      rawPointerType,
      rawConstPointerType,
      baseClassRawType,
      getActualTypeSignature,
      getActualType,
      upcastSignature,
      upcast,
      downcastSignature,
      downcast,
      name,
      destructorSignature,
      rawDestructor
    ) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
      exposePublicSymbol(legalFunctionName, function () {
        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });
      whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        function (base) {
          base = base[0];
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
          var constructor = createNamedFunction(legalFunctionName, function () {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name)
            }
            if (undefined === registeredClass.constructor_body) {
              throw new BindingError(name + ' has no accessible constructor')
            }
            var body = registeredClass.constructor_body[arguments.length];
            if (undefined === body) {
              throw new BindingError(
                'Tried to invoke ctor of ' +
                  name +
                  ' with invalid number of parameters (' +
                  arguments.length +
                  ') - expected (' +
                  Object.keys(registeredClass.constructor_body).toString() +
                  ') parameters instead!'
              )
            }
            return body.apply(this, arguments)
          });
          var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
          constructor.prototype = instancePrototype;
          var registeredClass = new RegisteredClass(
            name,
            constructor,
            instancePrototype,
            rawDestructor,
            baseClass,
            getActualType,
            upcast,
            downcast
          );
          var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
          var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);
          var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);
          registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
          replacePublicSymbol(legalFunctionName, constructor);
          return [referenceConverter, pointerConverter, constPointerConverter]
        }
      );
    }
    function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
        array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array
    }
    function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      whenDependentTypesAreResolved([], [rawClassType], function (classType) {
        classType = classType[0];
        var humanName = 'constructor ' + classType.name;
        if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError(
            'Cannot register multiple constructors with identical number of parameters (' +
              (argCount - 1) +
              ") for class '" +
              classType.name +
              "'! Overload resolution is currently only performed using the parameter count, not actual type info!"
          )
        }
        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
        };
        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
          classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
            if (arguments.length !== argCount - 1) {
              throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount - 1));
            }
            var destructors = [];
            var args = new Array(argCount);
            args[0] = rawConstructor;
            for (var i = 1; i < argCount; ++i) {
              args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);
            }
            var ptr = invoker.apply(null, args);
            runDestructors(destructors);
            return argTypes[0]['fromWireType'](ptr)
          };
          return []
        });
        return []
      });
    }
    function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError('new_ called with constructor type ' + typeof constructor + ' which is not a function')
      }
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function () {});
      dummy.prototype = constructor.prototype;
      var obj = new dummy();
      var r = constructor.apply(obj, argumentList);
      return r instanceof Object ? r : obj
    }
    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      var argCount = argTypes.length;
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
      var isClassMethodFunc = argTypes[1] !== null && classType !== null;
      var needsDestructorStack = false;
      for (var i = 1; i < argTypes.length; ++i) {
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          needsDestructorStack = true;
          break
        }
      }
      var returns = argTypes[0].name !== 'void';
      var argsList = '';
      var argsListWired = '';
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i !== 0 ? ', ' : '') + 'arg' + i;
        argsListWired += (i !== 0 ? ', ' : '') + 'arg' + i + 'Wired';
      }
      var invokerFnBody =
        'return function ' +
        makeLegalFunctionName(humanName) +
        '(' +
        argsList +
        ') {\n' +
        'if (arguments.length !== ' +
        (argCount - 2) +
        ') {\n' +
        "throwBindingError('function " +
        humanName +
        " called with ' + arguments.length + ' arguments, expected " +
        (argCount - 2) +
        " args!');\n" +
        '}\n';
      if (needsDestructorStack) {
        invokerFnBody += 'var destructors = [];\n';
      }
      var dtorStack = needsDestructorStack ? 'destructors' : 'null';
      var args1 = ['throwBindingError', 'invoker', 'fn', 'runDestructors', 'retType', 'classParam'];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
      if (isClassMethodFunc) {
        invokerFnBody += 'var thisWired = classParam.toWireType(' + dtorStack + ', this);\n';
      }
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody +=
          'var arg' +
          i +
          'Wired = argType' +
          i +
          '.toWireType(' +
          dtorStack +
          ', arg' +
          i +
          '); // ' +
          argTypes[i + 2].name +
          '\n';
        args1.push('argType' + i);
        args2.push(argTypes[i + 2]);
      }
      if (isClassMethodFunc) {
        argsListWired = 'thisWired' + (argsListWired.length > 0 ? ', ' : '') + argsListWired;
      }
      invokerFnBody +=
        (returns ? 'var rv = ' : '') + 'invoker(fn' + (argsListWired.length > 0 ? ', ' : '') + argsListWired + ');\n';
      if (needsDestructorStack) {
        invokerFnBody += 'runDestructors(destructors);\n';
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? 'thisWired' : 'arg' + (i - 2) + 'Wired';
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName + '_dtor(' + paramName + '); // ' + argTypes[i].name + '\n';
            args1.push(paramName + '_dtor');
            args2.push(argTypes[i].destructorFunction);
          }
        }
      }
      if (returns) {
        invokerFnBody += 'var ret = retType.fromWireType(rv);\n' + 'return ret;\n';
      }
      invokerFnBody += '}\n';
      args1.push(invokerFnBody);
      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction
    }
    function __embind_register_class_function(
      rawClassType,
      methodName,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      rawInvoker,
      context,
      isPureVirtual
    ) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], function (classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
        function unboundTypesHandler() {
          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
        }
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (
          undefined === method ||
          (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)
        ) {
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
          if (undefined === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
          return []
        });
        return []
      });
    }
    var emval_free_list = [];
    var emval_handle_array = [{}, { value: undefined }, { value: null }, { value: true }, { value: false }];
    function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
        emval_handle_array[handle] = undefined;
        emval_free_list.push(handle);
      }
    }
    function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          ++count;
        }
      }
      return count
    }
    function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          return emval_handle_array[i]
        }
      }
      return null
    }
    function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }
    function __emval_register(value) {
      switch (value) {
        case undefined: {
          return 1
        }
        case null: {
          return 2
        }
        case true: {
          return 3
        }
        case false: {
          return 4
        }
        default: {
          var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
          emval_handle_array[handle] = { refcount: 1, value: value };
          return handle
        }
      }
    }
    function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: function (handle) {
          var rv = emval_handle_array[handle].value;
          __emval_decref(handle);
          return rv
        },
        toWireType: function (destructors, value) {
          return __emval_register(value)
        },
        argPackAdvance: 8,
        readValueFromPointer: simpleReadValueFromPointer,
        destructorFunction: null,
      });
    }
    function _embind_repr(v) {
      if (v === null) {
        return 'null'
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
        return v.toString()
      } else {
        return '' + v
      }
    }
    function floatReadValueFromPointer(name, shift) {
      switch (shift) {
        case 2:
          return function (pointer) {
            return this['fromWireType'](HEAPF32[pointer >> 2])
          }
        case 3:
          return function (pointer) {
            return this['fromWireType'](HEAPF64[pointer >> 3])
          }
        default:
          throw new TypeError('Unknown float type: ' + name)
      }
    }
    function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: function (value) {
          return value
        },
        toWireType: function (destructors, value) {
          if (typeof value !== 'number' && typeof value !== 'boolean') {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name)
          }
          return value
        },
        argPackAdvance: 8,
        readValueFromPointer: floatReadValueFromPointer(name, shift),
        destructorFunction: null,
      });
    }
    function integerReadValueFromPointer(name, shift, signed) {
      switch (shift) {
        case 0:
          return signed
            ? function readS8FromPointer(pointer) {
                return HEAP8[pointer]
              }
            : function readU8FromPointer(pointer) {
                return HEAPU8[pointer]
              }
        case 1:
          return signed
            ? function readS16FromPointer(pointer) {
                return HEAP16[pointer >> 1]
              }
            : function readU16FromPointer(pointer) {
                return HEAPU16[pointer >> 1]
              }
        case 2:
          return signed
            ? function readS32FromPointer(pointer) {
                return HEAP32[pointer >> 2]
              }
            : function readU32FromPointer(pointer) {
                return HEAPU32[pointer >> 2]
              }
        default:
          throw new TypeError('Unknown integer type: ' + name)
      }
    }
    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) {
        maxRange = 4294967295;
      }
      var shift = getShiftFromSize(size);
      var fromWireType = function (value) {
        return value
      };
      if (minRange === 0) {
        var bitshift = 32 - 8 * size;
        fromWireType = function (value) {
          return (value << bitshift) >>> bitshift
        };
      }
      var isUnsignedType = name.indexOf('unsigned') != -1;
      registerType(primitiveType, {
        name: name,
        fromWireType: fromWireType,
        toWireType: function (destructors, value) {
          if (typeof value !== 'number' && typeof value !== 'boolean') {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name)
          }
          if (value < minRange || value > maxRange) {
            throw new TypeError(
              'Passing a number "' +
                _embind_repr(value) +
                '" from JS side to C/C++ side to an argument of type "' +
                name +
                '", which is outside the valid range [' +
                minRange +
                ', ' +
                maxRange +
                ']!'
            )
          }
          return isUnsignedType ? value >>> 0 : value | 0
        },
        argPackAdvance: 8,
        readValueFromPointer: integerReadValueFromPointer(name, shift, minRange !== 0),
        destructorFunction: null,
      });
    }
    function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
      var TA = typeMapping[dataTypeIndex];
      function decodeMemoryView(handle) {
        handle = handle >> 2;
        var heap = HEAPU32;
        var size = heap[handle];
        var data = heap[handle + 1];
        return new TA(heap['buffer'], data, size)
      }
      name = readLatin1String(name);
      registerType(
        rawType,
        { name: name, fromWireType: decodeMemoryView, argPackAdvance: 8, readValueFromPointer: decodeMemoryView },
        { ignoreDuplicateRegistrations: true }
      );
    }
    function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: function (value) {
          var length = HEAPU32[value >> 2];
          var a = new Array(length);
          for (var i = 0; i < length; ++i) {
            a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
          }
          _free(value);
          return a.join('')
        },
        toWireType: function (destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
          function getTAElement(ta, index) {
            return ta[index]
          }
          function getStringElement(string, index) {
            return string.charCodeAt(index)
          }
          var getElement;
          if (value instanceof Uint8Array) {
            getElement = getTAElement;
          } else if (value instanceof Uint8ClampedArray) {
            getElement = getTAElement;
          } else if (value instanceof Int8Array) {
            getElement = getTAElement;
          } else if (typeof value === 'string') {
            getElement = getStringElement;
          } else {
            throwBindingError('Cannot pass non-string to std::string');
          }
          var length = value.length;
          var ptr = _malloc(4 + length);
          HEAPU32[ptr >> 2] = length;
          for (var i = 0; i < length; ++i) {
            var charCode = getElement(value, i);
            if (charCode > 255) {
              _free(ptr);
              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
            }
            HEAPU8[ptr + 4 + i] = charCode;
          }
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr
        },
        argPackAdvance: 8,
        readValueFromPointer: simpleReadValueFromPointer,
        destructorFunction: function (ptr) {
          _free(ptr);
        },
      });
    }
    function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);
      var getHeap, shift;
      if (charSize === 2) {
        getHeap = function () {
          return HEAPU16
        };
        shift = 1;
      } else if (charSize === 4) {
        getHeap = function () {
          return HEAPU32
        };
        shift = 2;
      }
      registerType(rawType, {
        name: name,
        fromWireType: function (value) {
          var HEAP = getHeap();
          var length = HEAPU32[value >> 2];
          var a = new Array(length);
          var start = (value + 4) >> shift;
          for (var i = 0; i < length; ++i) {
            a[i] = String.fromCharCode(HEAP[start + i]);
          }
          _free(value);
          return a.join('')
        },
        toWireType: function (destructors, value) {
          var HEAP = getHeap();
          var length = value.length;
          var ptr = _malloc(4 + length * charSize);
          HEAPU32[ptr >> 2] = length;
          var start = (ptr + 4) >> shift;
          for (var i = 0; i < length; ++i) {
            HEAP[start + i] = value.charCodeAt(i);
          }
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr
        },
        argPackAdvance: 8,
        readValueFromPointer: simpleReadValueFromPointer,
        destructorFunction: function (ptr) {
          _free(ptr);
        },
      });
    }
    function __embind_register_value_object(
      rawType,
      name,
      constructorSignature,
      rawConstructor,
      destructorSignature,
      rawDestructor
    ) {
      structRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),
        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),
        fields: [],
      };
    }
    function __embind_register_value_object_field(
      structType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) {
      structRegistrations[structType].fields.push({
        fieldName: readLatin1String(fieldName),
        getterReturnType: getterReturnType,
        getter: embind__requireFunction(getterSignature, getter),
        getterContext: getterContext,
        setterArgumentType: setterArgumentType,
        setter: embind__requireFunction(setterSignature, setter),
        setterContext: setterContext,
      });
    }
    function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
        isVoid: true,
        name: name,
        argPackAdvance: 0,
        fromWireType: function () {
          return undefined
        },
        toWireType: function (destructors, o) {
          return undefined
        },
      });
    }
    function _abort() {
      Module['abort']();
    }
    var _environ = STATICTOP;
    STATICTOP += 16;
    function ___buildEnvironment(env) {
      var MAX_ENV_VALUES = 64;
      var TOTAL_ENV_SIZE = 1024;
      var poolPtr;
      var envPtr;
      if (!___buildEnvironment.called) {
        ___buildEnvironment.called = true;
        ENV['USER'] = ENV['LOGNAME'] = 'web_user';
        ENV['PATH'] = '/';
        ENV['PWD'] = '/';
        ENV['HOME'] = '/home/web_user';
        ENV['LANG'] = 'C.UTF-8';
        ENV['_'] = Module['thisProgram'];
        poolPtr = staticAlloc(TOTAL_ENV_SIZE);
        envPtr = staticAlloc(MAX_ENV_VALUES * 4);
        HEAP32[envPtr >> 2] = poolPtr;
        HEAP32[_environ >> 2] = envPtr;
      } else {
        envPtr = HEAP32[_environ >> 2];
        poolPtr = HEAP32[envPtr >> 2];
      }
      var strings = [];
      var totalSize = 0;
      for (var key in env) {
        if (typeof env[key] === 'string') {
          var line = key + '=' + env[key];
          strings.push(line);
          totalSize += line.length;
        }
      }
      if (totalSize > TOTAL_ENV_SIZE) {
        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!')
      }
      var ptrSize = 4;
      for (var i = 0; i < strings.length; i++) {
        var line = strings[i];
        writeAsciiToMemory(line, poolPtr);
        HEAP32[(envPtr + i * ptrSize) >> 2] = poolPtr;
        poolPtr += line.length + 1;
      }
      HEAP32[(envPtr + strings.length * ptrSize) >> 2] = 0;
    }
    var ENV = {};
    function _getenv(name) {
      if (name === 0) return 0
      name = Pointer_stringify(name);
      if (!ENV.hasOwnProperty(name)) return 0
      if (_getenv.ret) _free(_getenv.ret);
      _getenv.ret = allocateUTF8(ENV[name]);
      return _getenv.ret
    }
    function _getgrnam() {
      Module['printErr']('missing function: getgrnam');
      abort(-1);
    }
    function _getpwnam() {
      throw 'getpwnam: TODO'
    }
    function _jsClose() {
      return jsAPI.close.apply(null, arguments)
    }
    function _jsCreate(filename) {
      return jsAPI.create.call(null, UTF32ToString(filename))
    }
    function _jsOpen(filename) {
      return jsAPI.open.call(null, UTF32ToString(filename))
    }
    function _jsRead() {
      return jsAPI.read.apply(null, arguments)
    }
    function _jsSeek(fd, offset, method) {
      return jsAPI.seek.call(null, fd, offset, UTF8ToString(method))
    }
    function _jsTell() {
      return jsAPI.tell.apply(null, arguments)
    }
    function _jsWrite() {
      return jsAPI.write.apply(null, arguments)
    }
    function _llvm_eh_typeid_for(type) {
      return type
    }
    var ___tm_current = STATICTOP;
    STATICTOP += 48;
    allocate(intArrayFromString('GMT'), 'i8', ALLOC_STATIC);
    var _tzname = STATICTOP;
    STATICTOP += 16;
    var _daylight = STATICTOP;
    STATICTOP += 16;
    var _timezone = STATICTOP;
    STATICTOP += 16;
    function _tzset() {
      if (_tzset.called) return
      _tzset.called = true;
      HEAP32[_timezone >> 2] = new Date().getTimezoneOffset() * 60;
      var winter = new Date(2e3, 0, 1);
      var summer = new Date(2e3, 6, 1);
      HEAP32[_daylight >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : 'GMT'
      }
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);
      var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);
      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        HEAP32[_tzname >> 2] = winterNamePtr;
        HEAP32[(_tzname + 4) >> 2] = summerNamePtr;
      } else {
        HEAP32[_tzname >> 2] = summerNamePtr;
        HEAP32[(_tzname + 4) >> 2] = winterNamePtr;
      }
    }
    function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[time >> 2] * 1e3);
      HEAP32[tmPtr >> 2] = date.getSeconds();
      HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
      HEAP32[(tmPtr + 8) >> 2] = date.getHours();
      HEAP32[(tmPtr + 12) >> 2] = date.getDate();
      HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
      HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;
      HEAP32[(tmPtr + 24) >> 2] = date.getDay();
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;
      HEAP32[(tmPtr + 28) >> 2] = yday;
      HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);
      var summerOffset = new Date(2e3, 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[(tmPtr + 32) >> 2] = dst;
      var zonePtr = HEAP32[(_tzname + (dst ? 4 : 0)) >> 2];
      HEAP32[(tmPtr + 40) >> 2] = zonePtr;
      return tmPtr
    }
    function _localtime(time) {
      return _localtime_r(time, ___tm_current)
    }
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
      return dest
    }
    function _mktime(tmPtr) {
      _tzset();
      var date = new Date(
        HEAP32[(tmPtr + 20) >> 2] + 1900,
        HEAP32[(tmPtr + 16) >> 2],
        HEAP32[(tmPtr + 12) >> 2],
        HEAP32[(tmPtr + 8) >> 2],
        HEAP32[(tmPtr + 4) >> 2],
        HEAP32[tmPtr >> 2],
        0
      );
      var dst = HEAP32[(tmPtr + 32) >> 2];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(2e3, 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset);
      if (dst < 0) {
        HEAP32[(tmPtr + 32) >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if (dst > 0 != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        date.setTime(date.getTime() + (trueOffset - guessedOffset) * 6e4);
      }
      HEAP32[(tmPtr + 24) >> 2] = date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24)) | 0;
      HEAP32[(tmPtr + 28) >> 2] = yday;
      return (date.getTime() / 1e3) | 0
    }
    var PTHREAD_SPECIFIC = {};
    function _pthread_getspecific(key) {
      return PTHREAD_SPECIFIC[key] || 0
    }
    var PTHREAD_SPECIFIC_NEXT_KEY = 1;
    function _pthread_key_create(key, destructor) {
      if (key == 0) {
        return ERRNO_CODES.EINVAL
      }
      HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY;
      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;
      PTHREAD_SPECIFIC_NEXT_KEY++;
      return 0
    }
    function _pthread_once(ptr, func) {
      if (!_pthread_once.seen) _pthread_once.seen = {};
      if (ptr in _pthread_once.seen) return
      Module['dynCall_v'](func);
      _pthread_once.seen[ptr] = 1;
    }
    function _pthread_setspecific(key, value) {
      if (!(key in PTHREAD_SPECIFIC)) {
        return ERRNO_CODES.EINVAL
      }
      PTHREAD_SPECIFIC[key] = value;
      return 0
    }
    function _time(ptr) {
      var ret = (Date.now() / 1e3) | 0;
      if (ptr) {
        HEAP32[ptr >> 2] = ret;
      }
      return ret
    }
    FS.staticInit();
    __ATINIT__.unshift(function () {
      if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
    });
    __ATMAIN__.push(function () {
      FS.ignorePermissions = false;
    });
    __ATEXIT__.push(function () {
      FS.quit();
    });
    __ATINIT__.unshift(function () {
    });
    __ATEXIT__.push(function () {
    });
    InternalError = Module['InternalError'] = extendError(Error, 'InternalError');
    embind_init_charCodes();
    BindingError = Module['BindingError'] = extendError(Error, 'BindingError');
    init_ClassHandle();
    init_RegisteredPointer();
    init_embind();
    UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');
    init_emval();
    ___buildEnvironment(ENV);
    DYNAMICTOP_PTR = staticAlloc(4);
    STACK_BASE = STACKTOP = alignMemory(STATICTOP);
    STACK_MAX = STACK_BASE + TOTAL_STACK;
    DYNAMIC_BASE = alignMemory(STACK_MAX);
    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
    staticSealed = true;
    function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array
    }
    Module['wasmTableSize'] = 316;
    Module['wasmMaxTableSize'] = 316;
    function invoke_i(index) {
      try {
        return Module['dynCall_i'](index)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_ii(index, a1) {
      try {
        return Module['dynCall_ii'](index, a1)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iii(index, a1, a2) {
      try {
        return Module['dynCall_iii'](index, a1, a2)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iiii(index, a1, a2, a3) {
      try {
        return Module['dynCall_iiii'](index, a1, a2, a3)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iiiii(index, a1, a2, a3, a4) {
      try {
        return Module['dynCall_iiiii'](index, a1, a2, a3, a4)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
      try {
        return Module['dynCall_iiiiiii'](index, a1, a2, a3, a4, a5, a6)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
      try {
        return Module['dynCall_iiiiiiiiii'](index, a1, a2, a3, a4, a5, a6, a7, a8, a9)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_iiiiiijii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
      try {
        return Module['dynCall_iiiiiijii'](index, a1, a2, a3, a4, a5, a6, a7, a8, a9)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_ijj(index, a1, a2, a3, a4) {
      try {
        return Module['dynCall_ijj'](index, a1, a2, a3, a4)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_ji(index, a1) {
      try {
        return Module['dynCall_ji'](index, a1)
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_v(index) {
      try {
        Module['dynCall_v'](index);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_vi(index, a1) {
      try {
        Module['dynCall_vi'](index, a1);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_vii(index, a1, a2) {
      try {
        Module['dynCall_vii'](index, a1, a2);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viii(index, a1, a2, a3) {
      try {
        Module['dynCall_viii'](index, a1, a2, a3);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viiii(index, a1, a2, a3, a4) {
      try {
        Module['dynCall_viiii'](index, a1, a2, a3, a4);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viiiii(index, a1, a2, a3, a4, a5) {
      try {
        Module['dynCall_viiiii'](index, a1, a2, a3, a4, a5);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
      try {
        Module['dynCall_viiiiii'](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
      try {
        Module['dynCall_viiiiiiiii'](index, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
      try {
        Module['dynCall_viiiiiiiiii'](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_vij(index, a1, a2, a3) {
      try {
        Module['dynCall_vij'](index, a1, a2, a3);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    function invoke_viji(index, a1, a2, a3, a4) {
      try {
        Module['dynCall_viji'](index, a1, a2, a3, a4);
      } catch (e) {
        if (typeof e !== 'number' && e !== 'longjmp') throw e
        Module['setThrew'](1, 0);
      }
    }
    Module.asmGlobalArg = {};
    Module.asmLibraryArg = {
      abort: abort,
      enlargeMemory: enlargeMemory,
      getTotalMemory: getTotalMemory,
      abortOnCannotGrowMemory: abortOnCannotGrowMemory,
      invoke_i: invoke_i,
      invoke_ii: invoke_ii,
      invoke_iii: invoke_iii,
      invoke_iiii: invoke_iiii,
      invoke_iiiii: invoke_iiiii,
      invoke_iiiiiii: invoke_iiiiiii,
      invoke_iiiiiiiiii: invoke_iiiiiiiiii,
      invoke_iiiiiijii: invoke_iiiiiijii,
      invoke_ijj: invoke_ijj,
      invoke_ji: invoke_ji,
      invoke_v: invoke_v,
      invoke_vi: invoke_vi,
      invoke_vii: invoke_vii,
      invoke_viii: invoke_viii,
      invoke_viiii: invoke_viiii,
      invoke_viiiii: invoke_viiiii,
      invoke_viiiiii: invoke_viiiiii,
      invoke_viiiiiiiii: invoke_viiiiiiiii,
      invoke_viiiiiiiiii: invoke_viiiiiiiiii,
      invoke_vij: invoke_vij,
      invoke_viji: invoke_viji,
      ___cxa_allocate_exception: ___cxa_allocate_exception,
      ___cxa_begin_catch: ___cxa_begin_catch,
      ___cxa_end_catch: ___cxa_end_catch,
      ___cxa_find_matching_catch_2: ___cxa_find_matching_catch_2,
      ___cxa_find_matching_catch_3: ___cxa_find_matching_catch_3,
      ___cxa_find_matching_catch_4: ___cxa_find_matching_catch_4,
      ___cxa_free_exception: ___cxa_free_exception,
      ___cxa_throw: ___cxa_throw,
      ___lock: ___lock,
      ___map_file: ___map_file,
      ___resumeException: ___resumeException,
      ___setErrNo: ___setErrNo,
      ___syscall140: ___syscall140,
      ___syscall145: ___syscall145,
      ___syscall146: ___syscall146,
      ___syscall183: ___syscall183,
      ___syscall198: ___syscall198,
      ___syscall20: ___syscall20,
      ___syscall6: ___syscall6,
      ___syscall60: ___syscall60,
      ___syscall83: ___syscall83,
      ___syscall91: ___syscall91,
      ___unlock: ___unlock,
      __embind_finalize_value_object: __embind_finalize_value_object,
      __embind_register_bool: __embind_register_bool,
      __embind_register_class: __embind_register_class,
      __embind_register_class_constructor: __embind_register_class_constructor,
      __embind_register_class_function: __embind_register_class_function,
      __embind_register_emval: __embind_register_emval,
      __embind_register_float: __embind_register_float,
      __embind_register_integer: __embind_register_integer,
      __embind_register_memory_view: __embind_register_memory_view,
      __embind_register_std_string: __embind_register_std_string,
      __embind_register_std_wstring: __embind_register_std_wstring,
      __embind_register_value_object: __embind_register_value_object,
      __embind_register_value_object_field: __embind_register_value_object_field,
      __embind_register_void: __embind_register_void,
      _abort: _abort,
      _emscripten_memcpy_big: _emscripten_memcpy_big,
      _getenv: _getenv,
      _getgrnam: _getgrnam,
      _getpwnam: _getpwnam,
      _jsClose: _jsClose,
      _jsCreate: _jsCreate,
      _jsOpen: _jsOpen,
      _jsRead: _jsRead,
      _jsSeek: _jsSeek,
      _jsTell: _jsTell,
      _jsWrite: _jsWrite,
      _llvm_eh_typeid_for: _llvm_eh_typeid_for,
      _localtime: _localtime,
      _mktime: _mktime,
      _pthread_getspecific: _pthread_getspecific,
      _pthread_key_create: _pthread_key_create,
      _pthread_once: _pthread_once,
      _pthread_setspecific: _pthread_setspecific,
      _time: _time,
      DYNAMICTOP_PTR: DYNAMICTOP_PTR,
      STACKTOP: STACKTOP,
    };
    var asm = Module['asm'](Module.asmGlobalArg, Module.asmLibraryArg, buffer);
    Module['asm'] = asm;
    var __GLOBAL__sub_I_bind_cpp = (Module['__GLOBAL__sub_I_bind_cpp'] = function () {
      return Module['asm']['__GLOBAL__sub_I_bind_cpp'].apply(null, arguments)
    });
    var __GLOBAL__sub_I_bridge_cpp = (Module['__GLOBAL__sub_I_bridge_cpp'] = function () {
      return Module['asm']['__GLOBAL__sub_I_bridge_cpp'].apply(null, arguments)
    });
    var __GLOBAL__sub_I_crc_cpp = (Module['__GLOBAL__sub_I_crc_cpp'] = function () {
      return Module['asm']['__GLOBAL__sub_I_crc_cpp'].apply(null, arguments)
    });
    var __GLOBAL__sub_I_global_cpp = (Module['__GLOBAL__sub_I_global_cpp'] = function () {
      return Module['asm']['__GLOBAL__sub_I_global_cpp'].apply(null, arguments)
    });
    (Module['___cxa_can_catch'] = function () {
      return Module['asm']['___cxa_can_catch'].apply(null, arguments)
    });
    (Module['___cxa_is_pointer_type'] = function () {
      return Module['asm']['___cxa_is_pointer_type'].apply(null, arguments)
    });
    (Module['___errno_location'] = function () {
      return Module['asm']['___errno_location'].apply(null, arguments)
    });
    var ___getTypeName = (Module['___getTypeName'] = function () {
      return Module['asm']['___getTypeName'].apply(null, arguments)
    });
    var _emscripten_replace_memory = (Module['_emscripten_replace_memory'] = function () {
      return Module['asm']['_emscripten_replace_memory'].apply(null, arguments)
    });
    var _free = (Module['_free'] = function () {
      return Module['asm']['_free'].apply(null, arguments)
    });
    var _malloc = (Module['_malloc'] = function () {
      return Module['asm']['_malloc'].apply(null, arguments)
    });
    var setTempRet0 = (Module['setTempRet0'] = function () {
      return Module['asm']['setTempRet0'].apply(null, arguments)
    });
    (Module['setThrew'] = function () {
      return Module['asm']['setThrew'].apply(null, arguments)
    });
    var stackAlloc = (Module['stackAlloc'] = function () {
      return Module['asm']['stackAlloc'].apply(null, arguments)
    });
    (Module['dynCall_dii'] = function () {
      return Module['asm']['dynCall_dii'].apply(null, arguments)
    });
    (Module['dynCall_i'] = function () {
      return Module['asm']['dynCall_i'].apply(null, arguments)
    });
    (Module['dynCall_ii'] = function () {
      return Module['asm']['dynCall_ii'].apply(null, arguments)
    });
    (Module['dynCall_iii'] = function () {
      return Module['asm']['dynCall_iii'].apply(null, arguments)
    });
    (Module['dynCall_iiii'] = function () {
      return Module['asm']['dynCall_iiii'].apply(null, arguments)
    });
    (Module['dynCall_iiiii'] = function () {
      return Module['asm']['dynCall_iiiii'].apply(null, arguments)
    });
    (Module['dynCall_iiiiii'] = function () {
      return Module['asm']['dynCall_iiiiii'].apply(null, arguments)
    });
    (Module['dynCall_iiiiiii'] = function () {
      return Module['asm']['dynCall_iiiiiii'].apply(null, arguments)
    });
    (Module['dynCall_iiiiiiiiii'] = function () {
      return Module['asm']['dynCall_iiiiiiiiii'].apply(null, arguments)
    });
    (Module['dynCall_iiiiiijii'] = function () {
      return Module['asm']['dynCall_iiiiiijii'].apply(null, arguments)
    });
    (Module['dynCall_ijj'] = function () {
      return Module['asm']['dynCall_ijj'].apply(null, arguments)
    });
    (Module['dynCall_ji'] = function () {
      return Module['asm']['dynCall_ji'].apply(null, arguments)
    });
    (Module['dynCall_v'] = function () {
      return Module['asm']['dynCall_v'].apply(null, arguments)
    });
    (Module['dynCall_vi'] = function () {
      return Module['asm']['dynCall_vi'].apply(null, arguments)
    });
    (Module['dynCall_vii'] = function () {
      return Module['asm']['dynCall_vii'].apply(null, arguments)
    });
    (Module['dynCall_viid'] = function () {
      return Module['asm']['dynCall_viid'].apply(null, arguments)
    });
    (Module['dynCall_viii'] = function () {
      return Module['asm']['dynCall_viii'].apply(null, arguments)
    });
    (Module['dynCall_viiii'] = function () {
      return Module['asm']['dynCall_viiii'].apply(null, arguments)
    });
    (Module['dynCall_viiiii'] = function () {
      return Module['asm']['dynCall_viiiii'].apply(null, arguments)
    });
    (Module['dynCall_viiiiii'] = function () {
      return Module['asm']['dynCall_viiiiii'].apply(null, arguments)
    });
    (Module['dynCall_viiiiiiiii'] = function () {
      return Module['asm']['dynCall_viiiiiiiii'].apply(null, arguments)
    });
    (Module['dynCall_viiiiiiiiii'] = function () {
      return Module['asm']['dynCall_viiiiiiiiii'].apply(null, arguments)
    });
    (Module['dynCall_vij'] = function () {
      return Module['asm']['dynCall_vij'].apply(null, arguments)
    });
    (Module['dynCall_viji'] = function () {
      return Module['asm']['dynCall_viji'].apply(null, arguments)
    });
    Module['asm'] = asm;
    function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }
    ExitStatus.prototype = new Error();
    ExitStatus.prototype.constructor = ExitStatus;
    var initialStackTop;
    dependenciesFulfilled = function runCaller() {
      if (!Module['calledRun']) run();
      if (!Module['calledRun']) dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || Module['arguments'];
      if (runDependencies > 0) {
        return
      }
      preRun();
      if (runDependencies > 0) return
      if (Module['calledRun']) return
      function doRun() {
        if (Module['calledRun']) return
        Module['calledRun'] = true;
        if (ABORT) return
        ensureInitRuntime();
        preMain();
        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
        postRun();
      }
      if (Module['setStatus']) {
        Module['setStatus']('Running...');
        setTimeout(function () {
          setTimeout(function () {
            Module['setStatus']('');
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    Module['run'] = run;
    function exit(status, implicit) {
      if (implicit && Module['noExitRuntime'] && status === 0) {
        return
      }
      if (Module['noExitRuntime']) ; else {
        ABORT = true;
        STACKTOP = initialStackTop;
        exitRuntime();
        if (Module['onExit']) Module['onExit'](status);
      }
      if (ENVIRONMENT_IS_NODE) {
        process['exit'](status);
      }
      Module['quit'](status, new ExitStatus(status));
    }
    Module['exit'] = exit;
    function abort(what) {
      if (Module['onAbort']) {
        Module['onAbort'](what);
      }
      if (what !== undefined) {
        Module.print(what);
        Module.printErr(what);
        what = JSON.stringify(what);
      } else {
        what = '';
      }
      ABORT = true;
      throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.'
    }
    Module['abort'] = abort;
    if (Module['preInit']) {
      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
      while (Module['preInit'].length > 0) {
        Module['preInit'].pop()();
      }
    }
    Module['noExitRuntime'] = true;
    run();

    return unpack
  };
  //-------------------------------------------------------------

  /**
   * Returns a Promise containing the rar extractor for the given filename.
   * @private
   */
  function getExtractor(url) {
    return fetch(new Request(url))
      .then((response) => {
        if (response.ok) return response.arrayBuffer()
        else {
          throw new Error('404 Error: File not found.')
        }
      })
      .then((buffer) => unpackBridge.createExtractorFromData(buffer))
  }

  /**
   *  Returns a string representing the formatted contents of the given file.
   * @private
   */
  function extract({ resourceId, url }) {
    return new Promise(function (resolve, reject) {
      if (!unpackBridge) {
        throw new Error('unpackBridge not detected')
      }
      if (!unpack) {
        throw new Error('unpack not detected')
      }

      getExtractor(url).then(
        (extractor) => {
          // return extractor.extractAll();
          resolve(extractor.extractAll());
        },
        (err) => {
          reject(err);
        }
      );
    })
  }

  /**
   * Listen for messages sent to the worker.
   * @private
   */
  function handleMessage$1(data, postMessage) {
    if (data.type == 'init') {
      unpack = initunpack(data.buffer);
      unpack.onRuntimeInitialized = () => {
        postMessage({ type: 'WASM_LOADED' });
      };
    } else if (data.type == 'fetch') {
      extract(data).then(
        (unpacked) => {
          returnData(data, unpacked, postMessage);
        },
        (err) => {
          const result = {
            taskId: data.taskId,
            type: 'ERROR',
            resourceId: data.resourceId,
            url: data.url,
          };
          postMessage(result);
        }
      );
    } else if (data.type == 'unpack') {
      const { buffer } = data;

      if (!unpackBridge) {
        throw new Error('unpackBridge not detected')
      }
      if (!unpack) {
        throw new Error('unpack not detected')
      }

      const extractor = unpackBridge.createExtractorFromData(buffer);
      const unpacked = extractor.extractAll();
      returnData(data, unpacked, postMessage);
    }
  }

  function returnData(data, unpacked, postMessage) {
    const [state, list] = unpacked;
    if (state.state == 'FAIL') {
      const result = {
        taskId: data.taskId,
        type: 'ERROR',
        reason: state.reason,
        msg: state.msg,
        resourceId: data.resourceId,
        url: data.url,
      };
      postMessage(result);
      return
    }
    const result = {
      taskId: data.taskId,
      type: 'FINISHED',
      resourceId: data.resourceId,
      entries: {},
    };

    const transferables = [];
    if (list && list.files) {
      for (const file of list.files) {
        result.entries[file.fileHeader.name] = file.extract[1];
        transferables.push(file.extract[1].buffer);
      }
    }
    postMessage(result, transferables);
  }

  globalThis.onmessage = function (event) {
    handleMessage$1(event.data, self.postMessage);
  };

  /**
   * When the WASM runtime has been initialized on the unpack.js module, send a message indicating
   * that the library is ready.
   */
  // <!-- prettier-ignore-end -->

  let taskCounter = 0;
  class WorkerPool extends EventEmitter {
      poolSize = Math.max(1, SystemDesc.hardwareConcurrency - 1); // always leave one main thread code spare.
      workers = [];
      workerTaskCount = [];
      taskPromiseResolves = {};
      taskQueue = [];
      availableWorkers = [];
      terminationTimeouts = [];
      terminateWorkersWhenFree = true;
      terminationLatency = 2000;
      constructor(terminateWorkersWhenFree) {
          super();
          this.terminateWorkersWhenFree = terminateWorkersWhenFree;
      }
      addTask(taskData, transferables) {
          return this.addTaskCallback(() => {
              return {
                  taskData,
                  transferables,
              };
          });
      }
      addTaskCallback(dataFactory) {
          taskCounter++;
          const taskId = taskCounter;
          return new Promise(async (resolve) => {
              this.taskPromiseResolves[taskId] = resolve;
              // @ts-ignore
              this.taskQueue.push({
                  taskId,
                  dataFactory,
              });
              if (this.availableWorkers.length > 0) {
                  this.consumeTask();
              }
              else if (this.workers.length < this.poolSize) {
                  await this.addWorker();
                  this.consumeTask();
              }
          });
      }
      async consumeTask() {
          const workerId = this.availableWorkers.pop();
          if (this.workerTaskCount[workerId] > 0) {
              return;
          }
          if (this.taskQueue.length == 0) {
              // Multiple consumeTask were issued, and all tasks have been consumed.
              if (this.terminateWorkersWhenFree) {
                  this.scheduleWorkerTermination(workerId);
              }
              return;
          }
          if (this.terminationTimeouts[workerId] != -1) {
              clearTimeout(this.terminationTimeouts[workerId]);
              this.terminationTimeouts[workerId] = -1;
          }
          else if (!this.workers[workerId]) {
              // Workers get terminated, and we need to restart them.
              await this.allocWorker(workerId);
          }
          if (this.taskQueue.length == 0) {
              // Multiple consumeTask were issued, and all tasks have been consumed.
              if (this.terminateWorkersWhenFree) {
                  this.scheduleWorkerTermination(workerId);
              }
              return;
          }
          const task = this.taskQueue.pop();
          const { taskData, transferables } = task.dataFactory(workerId);
          // @ts-ignore
          taskData.taskId = task.taskId;
          this.workerTaskCount[workerId]++;
          // @ts-ignore
          this.workers[workerId].postMessage(taskData, transferables);
      }
      addWorker() {
          const workerId = this.workers.length;
          this.workers.push(null);
          return this.allocWorker(workerId);
      }
      allocWorker(workerId) {
          // Note: This function immediately adds the worker to the list
          // and then asynchronously creates it.
          return new Promise((resolve) => {
              this.constructWorker().then((worker) => {
                  // @ts-ignore
                  worker.onmessage = (event) => {
                      if (event.data.taskId in this.taskPromiseResolves) {
                          const taskId = event.data.taskId;
                          delete event.data.taskId;
                          this.taskPromiseResolves[taskId](event.data);
                          delete this.taskPromiseResolves[taskId];
                          this.workerTaskCount[workerId]--;
                          if (this.workerTaskCount[workerId] > 0) {
                              // Another task is already sent to this worker.
                              // Let it complete.
                              return;
                          }
                          // Check that we are not already on the available list.
                          // This happens if multiple tasks get issued to the same worker.
                          if (this.availableWorkers.indexOf(workerId) == -1) {
                              this.availableWorkers.push(workerId);
                          }
                          if (this.taskQueue.length > 0) {
                              this.consumeTask();
                          }
                          else {
                              if (this.terminateWorkersWhenFree) {
                                  this.scheduleWorkerTermination(workerId);
                              }
                          }
                      }
                      else if (event.data.eventName) {
                          event.data.workerId = workerId;
                          this.emit(event.data.eventName, event.data);
                      }
                  };
                  this.workers[workerId] = worker;
                  this.terminationTimeouts[workerId] = -1;
                  this.workerTaskCount[workerId] = 0;
                  this.availableWorkers.push(workerId);
                  resolve();
              });
          });
      }
      scheduleWorkerTermination(workerId) {
          // @ts-ignore
          this.terminationTimeouts[workerId] = setTimeout(() => {
              this.terminateWorker(workerId);
              this.terminationTimeouts[workerId] = -1;
          }, this.terminationLatency);
      }
      terminateWorker(workerId) {
          // @ts-ignore
          this.workers[workerId].terminate();
          this.workers[workerId] = null;
      }
      messageWorker(workerId, message) {
          taskCounter++;
          const taskId = taskCounter;
          // console.log('addTask:', taskId)
          return new Promise((resolve) => {
              this.taskPromiseResolves[taskId] = resolve;
              // @ts-ignore
              message.taskId = taskId;
              // @ts-ignore
              this.workers[workerId].postMessage(message);
          });
      }
  }

  function decodeBase64(base64, enableUnicode) {
      var binaryString = atob(base64);
      if (enableUnicode) {
          var binaryView = new Uint8Array(binaryString.length);
          for (var i = 0, n = binaryString.length; i < n; ++i) {
              binaryView[i] = binaryString.charCodeAt(i);
          }
          return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
      }
      return binaryString;
  }

  function createURL(base64, sourcemapArg, enableUnicodeArg) {
      var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
      var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
      var source = decodeBase64(base64, enableUnicode);
      var start = source.indexOf('\n', 10) + 1;
      var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
      var blob = new Blob([body], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
  }

  function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
      var url;
      return function WorkerFactory(options) {
          url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
          return new Worker(url, options);
      };
  }

  var WorkerFactory$2 = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAndXNlIHN0cmljdCc7CgogIC8vIDwhLS0gcHJldHRpZXItaWdub3JlLXN0YXJ0IC0tPgogIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MgKi8KCiAgY29uc3QgTW9kdWxlID0ge307CgogIGNvbnN0IFdvcmtlclNjb3BlID0ge307CgogIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS11bnBhY2tCcmlkZ2UuanMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIShmdW5jdGlvbiAodCwgZSkgewogICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGhhcyBiZWVuIF9jYXJlZnVsbHlfIG1vZGlmaWVkIGJ5IGhhbmQuCiAgICAvLyBUaGVyZSB3ZXJlIHZhcmlvdXMgY2FzZXMgZm9yIGluIHdoYXQgY29udGV4dCB0aGUgY29kZSBtaWdodAogICAgLy8gYmUgcnVuLCBhbmQgSSByZW1vdmVkIGFsbCBidXQgdGhlIHdlYndvcmtlciBjYXNlLgogICAgLy8gVGhlcmUgd2FzIGNvZGUgdG8gaGFuZGxlIGxvYWRpbmcgaW4gYSBub2RlSlMgY29udGV4dCwgdGhhdCB0cmllZCB0byBpbXBvcnQoImZzIikKICAgIC8vIFdlYlBhY2sga2VwdHMgdHJpcHBpbmcgdXAgb24gdGhhdCBjb2RlIGluIGl0cyBzdGF0aWMgYW5hbHlzaXMgb2YgdGhlIGNvZGUsIHNvCiAgICAvLyBJIGNhcmVmdWxseSByZW1vdmVkIGl0LgogICAgdC51bnBhY2tCcmlkZ2UgPSBlKHQuZnMpOwogIH0pKFdvcmtlclNjb3BlLCBmdW5jdGlvbiAodCkgewogICAgcmV0dXJuIChmdW5jdGlvbiAodCkgewogICAgICB2YXIgZSA9IHt9OwogICAgICBmdW5jdGlvbiByKG4pIHsKICAgICAgICBpZiAoZVtuXSkgcmV0dXJuIGVbbl0uZXhwb3J0cwogICAgICAgIHZhciBpID0gKGVbbl0gPSB7IGk6IG4sIGw6ICExLCBleHBvcnRzOiB7fSB9KTsKICAgICAgICByZXR1cm4gdFtuXS5jYWxsKGkuZXhwb3J0cywgaSwgaS5leHBvcnRzLCByKSwgKGkubCA9ICEwKSwgaS5leHBvcnRzCiAgICAgIH0KICAgICAgcmV0dXJuICgKICAgICAgICAoci5tID0gdCksCiAgICAgICAgKHIuYyA9IGUpLAogICAgICAgIChyLmQgPSBmdW5jdGlvbiAodCwgZSwgbikgewogICAgICAgICAgci5vKHQsIGUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IG4gfSk7CiAgICAgICAgfSksCiAgICAgICAgKHIuciA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAndW5kZWZpbmVkJyAhPSB0eXBlb2YgU3ltYm9sICYmCiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJgogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSwKICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgfSksCiAgICAgICAgKHIudCA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICBpZiAoKDEgJiBlICYmICh0ID0gcih0KSksIDggJiBlKSkgcmV0dXJuIHQKICAgICAgICAgIGlmICg0ICYgZSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdCAmJiB0ICYmIHQuX19lc01vZHVsZSkgcmV0dXJuIHQKICAgICAgICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgICAgICAgIGlmICgoci5yKG4pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogdCB9KSwgMiAmIGUgJiYgJ3N0cmluZycgIT0gdHlwZW9mIHQpKQogICAgICAgICAgICBmb3IgKHZhciBpIGluIHQpCiAgICAgICAgICAgICAgci5kKAogICAgICAgICAgICAgICAgbiwKICAgICAgICAgICAgICAgIGksCiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdFtlXQogICAgICAgICAgICAgICAgfS5iaW5kKG51bGwsIGkpCiAgICAgICAgICAgICAgKTsKICAgICAgICAgIHJldHVybiBuCiAgICAgICAgfSksCiAgICAgICAgKHIubiA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB2YXIgZSA9CiAgICAgICAgICAgIHQgJiYgdC5fX2VzTW9kdWxlCiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0LmRlZmF1bHQKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICByZXR1cm4gci5kKGUsICdhJywgZSksIGUKICAgICAgICB9KSwKICAgICAgICAoci5vID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgZSkKICAgICAgICB9KSwKICAgICAgICAoci5wID0gJycpLAogICAgICAgIHIoKHIucyA9IDIpKQogICAgICApCiAgICB9KShbCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgY29uc3QgbiA9IHIoMSksCiAgICAgICAgICBpID0gewogICAgICAgICAgICAwOiAnRVJBUl9TVUNDRVNTJywKICAgICAgICAgICAgMTA6ICdFUkFSX0VORF9BUkNISVZFJywKICAgICAgICAgICAgMTE6ICdFUkFSX05PX01FTU9SWScsCiAgICAgICAgICAgIDEyOiAnRVJBUl9CQURfREFUQScsCiAgICAgICAgICAgIDEzOiAnRVJBUl9CQURfQVJDSElWRScsCiAgICAgICAgICAgIDE0OiAnRVJBUl9VTktOT1dOX0ZPUk1BVCcsCiAgICAgICAgICAgIDE1OiAnRVJBUl9FT1BFTicsCiAgICAgICAgICAgIDE2OiAnRVJBUl9FQ1JFQVRFJywKICAgICAgICAgICAgMTc6ICdFUkFSX0VDTE9TRScsCiAgICAgICAgICAgIDE4OiAnRVJBUl9FUkVBRCcsCiAgICAgICAgICAgIDE5OiAnRVJBUl9FV1JJVEUnLAogICAgICAgICAgICAyMDogJ0VSQVJfU01BTExfQlVGJywKICAgICAgICAgICAgMjE6ICdFUkFSX1VOS05PV04nLAogICAgICAgICAgICAyMjogJ0VSQVJfTUlTU0lOR19QQVNTV09SRCcsCiAgICAgICAgICAgIDIzOiAnRVJBUl9FUkVGRVJFTkNFJywKICAgICAgICAgICAgMjQ6ICdFUkFSX0JBRF9QQVNTV09SRCcsCiAgICAgICAgICB9LAogICAgICAgICAgbyA9IHsKICAgICAgICAgICAgMDogJ1N1Y2Nlc3MnLAogICAgICAgICAgICAxMTogJ05vdCBlbm91Z2ggbWVtb3J5JywKICAgICAgICAgICAgMTI6ICdBcmNoaXZlIGhlYWRlciBvciBkYXRhIGFyZSBkYW1hZ2VkJywKICAgICAgICAgICAgMTM6ICdGaWxlIGlzIG5vdCBSQVIgYXJjaGl2ZScsCiAgICAgICAgICAgIDE0OiAnVW5rbm93biBhcmNoaXZlIGZvcm1hdCcsCiAgICAgICAgICAgIDE1OiAnRmlsZSBvcGVuIGVycm9yJywKICAgICAgICAgICAgMTY6ICdGaWxlIGNyZWF0ZSBlcnJvcicsCiAgICAgICAgICAgIDE3OiAnRmlsZSBjbG9zZSBlcnJvcicsCiAgICAgICAgICAgIDE4OiAnRmlsZSByZWFkIGVycm9yJywKICAgICAgICAgICAgMTk6ICdGaWxlIHdyaXRlIGVycm9yJywKICAgICAgICAgICAgMjA6ICdCdWZmZXIgZm9yIGFyY2hpdmUgY29tbWVudCBpcyB0b28gc21hbGwsIGNvbW1lbnQgdHJ1bmNhdGVkJywKICAgICAgICAgICAgMjE6ICdVbmtub3duIGVycm9yJywKICAgICAgICAgICAgMjI6ICdQYXNzd29yZCBmb3IgZW5jcnlwdGVkIGZpbGUgb3IgaGVhZGVyIGlzIG5vdCBzcGVjaWZpZWQnLAogICAgICAgICAgICAyMzogJ0Nhbm5vdCBvcGVuIGZpbGUgc291cmNlIGZvciByZWZlcmVuY2UgcmVjb3JkJywKICAgICAgICAgICAgMjQ6ICdXcm9uZyBwYXNzd29yZCBpcyBzcGVjaWZpZWQnLAogICAgICAgICAgfTsKICAgICAgICBjbGFzcyBzIHsKICAgICAgICAgIGNvbnN0cnVjdG9yKHQgPSAnJykgewogICh0aGlzLl9wYXNzd29yZCA9IHQpLCAodGhpcy5fYXJjaGl2ZSA9IG51bGwpOwogICAgICAgICAgfQogICAgICAgICAgZ2V0RmlsZUxpc3QoKSB7CiAgICAgICAgICAgIGxldCB0LAogICAgICAgICAgICAgIFtlLCByXSA9IHRoaXMub3BlbkFyYyghMCk7CiAgICAgICAgICAgIGlmICgnU1VDQ0VTUycgIT09IGUuc3RhdGUpIHQgPSBbZSwgbnVsbF07CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGxldCBlLAogICAgICAgICAgICAgICAgbiwKICAgICAgICAgICAgICAgIGkgPSBbXTsKICAgICAgICAgICAgICBmb3IgKDsgKFtlLCBuXSA9IHRoaXMucHJvY2Vzc05leHRGaWxlKCgpID0+ICEwKSksICdTVUNDRVNTJyA9PT0gZS5zdGF0ZTsgKSBpLnB1c2gobi5maWxlSGVhZGVyKTsKICAgICAgICAgICAgICB0ID0gJ0VSQVJfRU5EX0FSQ0hJVkUnICE9PSBlLnJlYXNvbiA/IFtlLCBudWxsXSA6IFt7IHN0YXRlOiAnU1VDQ0VTUycgfSwgeyBhcmNIZWFkZXI6IHIsIGZpbGVIZWFkZXJzOiBpIH1dOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlQXJjKCksIHQKICAgICAgICAgIH0KICAgICAgICAgIGV4dHJhY3RBbGwoKSB7CiAgICAgICAgICAgIGxldCB0LAogICAgICAgICAgICAgIFtlLCByXSA9IHRoaXMub3BlbkFyYyghMSk7CiAgICAgICAgICAgIGlmICgnU1VDQ0VTUycgIT09IGUuc3RhdGUpIHQgPSBbZSwgbnVsbF07CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGxldCBlLAogICAgICAgICAgICAgICAgbiwKICAgICAgICAgICAgICAgIGkgPSBbXTsKICAgICAgICAgICAgICBmb3IgKDsgKFtlLCBuXSA9IHRoaXMucHJvY2Vzc05leHRGaWxlKCgpID0+ICExKSksICdTVUNDRVNTJyA9PT0gZS5zdGF0ZTsgKSBpLnB1c2gobik7CiAgICAgICAgICAgICAgdCA9ICdFUkFSX0VORF9BUkNISVZFJyAhPT0gZS5yZWFzb24gPyBbZSwgbnVsbF0gOiBbeyBzdGF0ZTogJ1NVQ0NFU1MnIH0sIHsgYXJjSGVhZGVyOiByLCBmaWxlczogaSB9XTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUFyYygpLCB0CiAgICAgICAgICB9CiAgICAgICAgICBleHRyYWN0RmlsZXModCwgZSkgewogICAgICAgICAgICBsZXQgciwKICAgICAgICAgICAgICBbbiwgaV0gPSB0aGlzLm9wZW5BcmMoITEsIGUpLAogICAgICAgICAgICAgIG8gPSB7fTsKICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgKytlKSBvW3RbZV1dID0gZTsKICAgICAgICAgICAgaWYgKCdTVUNDRVNTJyAhPT0gbi5zdGF0ZSkgciA9IFtuLCBudWxsXTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgbGV0IGUsCiAgICAgICAgICAgICAgICBuLAogICAgICAgICAgICAgICAgcyA9IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLAogICAgICAgICAgICAgICAgdSA9IDA7CiAgICAgICAgICAgICAgZm9yICg7OykgewogICAgICAgICAgICAgICAgbGV0IHIgPSAhMSwKICAgICAgICAgICAgICAgICAgaSA9IG51bGw7CiAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICgoW2UsIG5dID0gdGhpcy5wcm9jZXNzTmV4dEZpbGUoKHQpID0+ICh0IGluIG8gPyAoKGkgPSBvW3RdKSwgITEpIDogKChyID0gITApLCAhMCkpKSksCiAgICAgICAgICAgICAgICAgICdTVUNDRVNTJyAhPT0gZS5zdGF0ZSkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIGlmICghciAmJiAoKHNbaV0gPSBuKSwgKyt1ID09PSB0Lmxlbmd0aCkpIHsKICAgICAgICAgICAgICAgICAgZS5yZWFzb24gPSAnRVJBUl9FTkRfQVJDSElWRSc7CiAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHIgPSAnRVJBUl9FTkRfQVJDSElWRScgIT09IGUucmVhc29uID8gW2UsIG51bGxdIDogW3sgc3RhdGU6ICdTVUNDRVNTJyB9LCB7IGFyY0hlYWRlcjogaSwgZmlsZXM6IHMgfV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VBcmMoKSwgcgogICAgICAgICAgfQogICAgICAgICAgZmlsZUNyZWF0ZWQodCkge30KICAgICAgICAgIGNsb3NlKHQpIHsKICAgICAgICAgICAgdGhpcy5fbGFzdEZpbGVDb250ZW50ID0gdGhpcy5jbG9zZUZpbGUodCk7CiAgICAgICAgICB9CiAgICAgICAgICBvcGVuQXJjKHQsIGUpIHsKICAobi5FeHQuY3VycmVudCA9IHRoaXMpLCAodGhpcy5fYXJjaGl2ZSA9IG5ldyB1bnBhY2suUmFyQXJjaGl2ZSgpKTsKICAgICAgICAgICAgbGV0IHIsCiAgICAgICAgICAgICAgaSA9IHRoaXMuX2FyY2hpdmUub3Blbih0aGlzLl9maWxlUGF0aCwgZSB8fCB0aGlzLl9wYXNzd29yZCwgdCk7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgKHIgPQogICAgICAgICAgICAgICAgMCAhPT0gaS5zdGF0ZS5lcnJDb2RlCiAgICAgICAgICAgICAgICAgID8gW3RoaXMuZ2V0RmFpbEluZm8oaS5zdGF0ZS5lcnJDb2RlLCBpLnN0YXRlLmVyclR5cGUpLCBudWxsXQogICAgICAgICAgICAgICAgICA6IFsKICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGU6ICdTVUNDRVNTJyB9LAogICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBpLmNvbW1lbnQsCiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAwICE9ICgxICYgaS5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jazogMCAhPSAoNCAmIGkuZmxhZ3MpLAogICAgICAgICAgICAgICAgICAgICAgICAgIHNvbGlkOiAwICE9ICg4ICYgaS5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEluZm86IDAgIT0gKDMyICYgaS5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlSZWNvcmQ6IDAgIT0gKDY0ICYgaS5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyRW5jcnlwdGVkOiAwICE9ICgxMjggJiBpLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgXSksCiAgICAgICAgICAgICAgKG4uRXh0LmN1cnJlbnQgPSBudWxsKSwKICAgICAgICAgICAgICByCiAgICAgICAgICAgICkKICAgICAgICAgIH0KICAgICAgICAgIHByb2Nlc3NOZXh0RmlsZSh0KSB7CiAgICAgICAgICAgIGxldCBlOwogICAgICAgICAgICBuLkV4dC5jdXJyZW50ID0gdGhpczsKICAgICAgICAgICAgbGV0IHIgPSB0aGlzLl9hcmNoaXZlLmdldEZpbGVIZWFkZXIoKSwKICAgICAgICAgICAgICBpID0gW3sgc3RhdGU6ICdTVUNDRVNTJyB9LCBudWxsXTsKICAgICAgICAgICAgaWYgKDAgPT09IHIuc3RhdGUuZXJyQ29kZSkgewogICAgICAgICAgICAgIGxldCBlID0gdChyLm5hbWUpOwogICAgICAgICAgICAgIHRoaXMuX2xhc3RGaWxlQ29udGVudCA9IG51bGw7CiAgICAgICAgICAgICAgbGV0IG4gPSB0aGlzLl9hcmNoaXZlLnJlYWRGaWxlKGUpOwogICAgICAgICAgICAgIDAgPT09IG4uZXJyQ29kZSB8fAogICAgICAgICAgICAgICAgZSB8fAogICAgICAgICAgICAgICAgKChpWzBdID0gdGhpcy5nZXRGYWlsSW5mbyhuLmVyckNvZGUsIG4uZXJyVHlwZSkpLAogICAgICAgICAgICAgICAgMjIgPT09IG4uZXJyQ29kZSA/IChuID0gdGhpcy5fYXJjaGl2ZS5yZWFkRmlsZSghMCkpIDogKG4uZXJyQ29kZSA9IDApKSwKICAgICAgICAgICAgICAgIDAgPT09IG4uZXJyQ29kZQogICAgICAgICAgICAgICAgICA/IChpWzFdID0gdGhpcy5fbGFzdEZpbGVDb250ZW50KQogICAgICAgICAgICAgICAgICA6ICgoci5zdGF0ZS5lcnJDb2RlID0gbi5lcnJDb2RlKSwgKHIuc3RhdGUuZXJyVHlwZSA9IG4uZXJyVHlwZSkpLAogICAgICAgICAgICAgICAgKHRoaXMuX2xhc3RGaWxlQ29udGVudCA9IG51bGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgKGUgPQogICAgICAgICAgICAgICAgMCAhPT0gci5zdGF0ZS5lcnJDb2RlCiAgICAgICAgICAgICAgICAgID8gW3RoaXMuZ2V0RmFpbEluZm8oci5zdGF0ZS5lcnJDb2RlLCByLnN0YXRlLmVyclR5cGUpLCBudWxsXQogICAgICAgICAgICAgICAgICA6IFsKICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGU6ICdTVUNDRVNTJyB9LAogICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBmaWxlSGVhZGVyOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogci5uYW1lLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWQ6IDAgIT0gKDQgJiByLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbGlkOiAwICE9ICgxNiAmIHIuZmxhZ3MpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiAwICE9ICgzMiAmIHIuZmxhZ3MpLAogICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja1NpemU6IHIucGFja1NpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wU2l6ZTogci51bnBTaXplLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNyYzogci5jcmMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gWzUsIDYsIDUsIDUsIDQsIDddOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBbXTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG4gb2YgZSkgci5wdXNoKHQgJiAoKDEgPDwgbikgLSAxKSksICh0ID4+PSBuKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuID0gKHQpID0+ICh0IDwgMTAgPyAnMCcgKyB0IDogJycgKyB0KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAkezE5ODAgKyAociA9IHIucmV2ZXJzZSgpKVswXX0tJHtuKHJbMV0pfS0ke24oclsyXSl9YCArCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBUJHtuKHJbM10pfToke24ocls0XSl9OiR7bigyICogcls1XSl9LjAwMGAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICB9KShyLnRpbWUpLAogICAgICAgICAgICAgICAgICAgICAgICAgIHVucFZlcjogYCR7TWF0aC5mbG9vcihyLnVucFZlciAvIDEwKX0uJHtyLnVucFZlciAlIDEwfWAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgNDg6ICdTdG9yaW5nJywgNDk6ICdGYXN0ZXN0JywgNTA6ICdGYXN0JywgNTE6ICdOb3JtYWwnLCA1MjogJ0dvb2QnLCA1MzogJ0Jlc3QnIH1bdF0gfHwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoci5tZXRob2QpLAogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0OiBpLAogICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBdKSwKICAgICAgICAgICAgICAobi5FeHQuY3VycmVudCA9IG51bGwpLAogICAgICAgICAgICAgIGUKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgY2xvc2VBcmMoKSB7CiAgKG4uRXh0LmN1cnJlbnQgPSB0aGlzKSwgdGhpcy5fYXJjaGl2ZS5kZWxldGUoKSwgKG4uRXh0LmN1cnJlbnQgPSBudWxsKSwgKHRoaXMuX2FyY2hpdmUgPSBudWxsKTsKICAgICAgICAgIH0KICAgICAgICAgIGdldEZhaWxJbmZvKHQsIGUpIHsKICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6ICdGQUlMJywgcmVhc29uOiBpW3RdLCBtc2c6IG9bdF0gfQogICAgICAgICAgfQogICAgICAgIH0KICAocy5fY3VycmVudCA9IG51bGwpLCAoZS5FeHRyYWN0b3IgPSBzKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KSwgKGUuRXh0ID0geyBjdXJyZW50OiBudWxsIH0pOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnX19lc01vZHVsZScsIHsgdmFsdWU6ICEwIH0pLAogICAgICAgICAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIGZvciAodmFyIHIgaW4gdCkgZS5oYXNPd25Qcm9wZXJ0eShyKSB8fCAoZVtyXSA9IHRbcl0pOwogICAgICAgICAgfSkocigzKSk7CiAgICAgICAgdmFyIG4gPSByKDEpOwogICAgICAgIGUuRXh0ID0gbi5FeHQ7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgY29uc3QgbiA9IHIoNCksCiAgICAgICAgICBpID0gcig2KQogICAgICAgIDsoZS5jcmVhdGVFeHRyYWN0b3JGcm9tRGF0YSA9IGZ1bmN0aW9uICh0LCBlID0gJycpIHsKICAgICAgICAgIHJldHVybiBuZXcgbi5EYXRhRXh0cmFjdG9yKHQsIGUpCiAgICAgICAgfSksCiAgICAgICAgICAoZS5jcmVhdGVFeHRyYWN0b3JGcm9tRmlsZSA9IGZ1bmN0aW9uICh0LCBlID0gJycsIHIgPSAnJykgewogICAgICAgICAgICByZXR1cm4gbmV3IGkuRmlsZUV4dHJhY3Rvcih0LCBlLCByKQogICAgICAgICAgfSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgY29uc3QgbiA9IHIoNSksCiAgICAgICAgICBpID0gcigwKTsKICAgICAgICBlLkRhdGFFeHRyYWN0b3IgPSBjbGFzcyBleHRlbmRzIGkuRXh0cmFjdG9yIHsKICAgICAgICAgIGNvbnN0cnVjdG9yKHQsIGUpIHsKICAgICAgICAgICAgc3VwZXIoZSksICh0aGlzLmRhdGFGaWxlcyA9IHt9KSwgKHRoaXMuZGF0YUZpbGVNYXAgPSB7fSksICh0aGlzLmN1cnJlbnRGZCA9IDEpOwogICAgICAgICAgICBsZXQgciA9IHsgZmlsZTogbmV3IG4uRGF0YUZpbGUobmV3IFVpbnQ4QXJyYXkodCkpLCBmZDogdGhpcy5jdXJyZW50RmQrKyB9CiAgICAgICAgICAgIDsodGhpcy5fZmlsZVBhdGggPSAnX2RlZmF1bHRVbnJhckpTXy5yYXInKSwKICAgICAgICAgICAgICAodGhpcy5kYXRhRmlsZXNbdGhpcy5fZmlsZVBhdGhdID0gciksCiAgICAgICAgICAgICAgKHRoaXMuZGF0YUZpbGVNYXBbci5mZF0gPSB0aGlzLl9maWxlUGF0aCk7CiAgICAgICAgICB9CiAgICAgICAgICBvcGVuKHQpIHsKICAgICAgICAgICAgbGV0IGUgPSB0aGlzLmRhdGFGaWxlc1t0XTsKICAgICAgICAgICAgcmV0dXJuIGUgPyBlLmZkIDogMAogICAgICAgICAgfQogICAgICAgICAgY3JlYXRlKHQpIHsKICAgICAgICAgICAgbGV0IGUgPSB0aGlzLmN1cnJlbnRGZCsrOwogICAgICAgICAgICByZXR1cm4gKHRoaXMuZGF0YUZpbGVzW3RdID0geyBmaWxlOiBuZXcgbi5EYXRhRmlsZSgpLCBmZDogdGhpcy5jdXJyZW50RmQrKyB9KSwgKHRoaXMuZGF0YUZpbGVNYXBbZV0gPSB0KSwgZQogICAgICAgICAgfQogICAgICAgICAgY2xvc2VGaWxlKHQpIHsKICAgICAgICAgICAgbGV0IGUgPSB0aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTsKICAgICAgICAgICAgaWYgKCFlKSByZXR1cm4gbnVsbAogICAgICAgICAgICBsZXQgciA9IGUuZmlsZS5yZWFkQWxsKCk7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgMSAhPT0gdCA/IChkZWxldGUgdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV0sIGRlbGV0ZSB0aGlzLmRhdGFGaWxlTWFwW3RdKSA6IGUuZmlsZS5zZWVrKDAsICdTRVQnKSwKICAgICAgICAgICAgICByCiAgICAgICAgICAgICkKICAgICAgICAgIH0KICAgICAgICAgIHJlYWQodCwgZSwgcikgewogICAgICAgICAgICBsZXQgbiA9IHRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dOwogICAgICAgICAgICBpZiAoIW4pIHJldHVybiAtMQogICAgICAgICAgICBsZXQgaSA9IG4uZmlsZS5yZWFkKHIpOwogICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gaSA/IC0xIDogKHVucGFjay5IRUFQVTguc2V0KGksIGUpLCBpLmJ5dGVMZW5ndGgpCiAgICAgICAgICB9CiAgICAgICAgICB3cml0ZSh0LCBlLCByKSB7CiAgICAgICAgICAgIGxldCBuID0gdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07CiAgICAgICAgICAgIHJldHVybiAhIW4gJiYgKG4uZmlsZS53cml0ZSh1bnBhY2suSEVBUFU4LnNsaWNlKGUsIGUgKyByKSksICEwKQogICAgICAgICAgfQogICAgICAgICAgdGVsbCh0KSB7CiAgICAgICAgICAgIGxldCBlID0gdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07CiAgICAgICAgICAgIHJldHVybiBlID8gZS5maWxlLnRlbGwoKSA6IC0xCiAgICAgICAgICB9CiAgICAgICAgICBzZWVrKHQsIGUsIHIpIHsKICAgICAgICAgICAgbGV0IG4gPSB0aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTsKICAgICAgICAgICAgcmV0dXJuICEhbiAmJiBuLmZpbGUuc2VlayhlLCByKQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgZS5EYXRhRmlsZSA9IGNsYXNzIHsKICAgICAgICAgIGNvbnN0cnVjdG9yKHQpIHsKICAodGhpcy5idWZmZXJzID0gW10pLAogICAgICAgICAgICAgICh0aGlzLnBvcyA9IDApLAogICAgICAgICAgICAgICh0aGlzLnNpemUgPSAwKSwKICAgICAgICAgICAgICB0ICYmICh0aGlzLmJ1ZmZlcnMucHVzaCh0KSwgKHRoaXMuc2l6ZSA9IHQuYnl0ZUxlbmd0aCksICh0aGlzLnBvcyA9IDApKTsKICAgICAgICAgIH0KICAgICAgICAgIHJlYWQodCkgewogICAgICAgICAgICBpZiAoKHRoaXMuZmxhdHRlbigpLCB0ICsgdGhpcy5wb3MgPiB0aGlzLnNpemUpKSByZXR1cm4gbnVsbAogICAgICAgICAgICBsZXQgZSA9IHRoaXMucG9zOwogICAgICAgICAgICByZXR1cm4gKHRoaXMucG9zICs9IHQpLCB0aGlzLmJ1ZmZlcnNbMF0uc2xpY2UoZSwgdGhpcy5wb3MpCiAgICAgICAgICB9CiAgICAgICAgICByZWFkQWxsKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCksIHRoaXMuYnVmZmVyc1swXQogICAgICAgICAgfQogICAgICAgICAgd3JpdGUodCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLnB1c2godCksICh0aGlzLnNpemUgKz0gdC5ieXRlTGVuZ3RoKSwgKHRoaXMucG9zICs9IHQuYnl0ZUxlbmd0aCksICEwCiAgICAgICAgICB9CiAgICAgICAgICB0ZWxsKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MKICAgICAgICAgIH0KICAgICAgICAgIHNlZWsodCwgZSkgewogICAgICAgICAgICBsZXQgciA9IHRoaXMucG9zOwogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICdTRVQnID09PSBlID8gKHIgPSB0KSA6ICdDVVInID09PSBlID8gKHIgKz0gdCkgOiAociA9IHRoaXMuc2l6ZSAtIHQpLAogICAgICAgICAgICAgICEociA8IDAgfHwgciA+IHRoaXMuc2l6ZSB8fCAoKHRoaXMucG9zID0gciksIDApKQogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICBmbGF0dGVuKCkgewogICAgICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA8PSAxKSByZXR1cm4KICAgICAgICAgICAgbGV0IHQgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemUpLAogICAgICAgICAgICAgIGUgPSAwOwogICAgICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuYnVmZmVycykgdC5zZXQociwgZSksIChlICs9IHIuYnl0ZUxlbmd0aCk7CiAgICAgICAgICAgIHRoaXMuYnVmZmVycyA9IFt0XTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSwgcikgewogIChmdW5jdGlvbiAodCkgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSk7CiAgICAgICAgICBjb25zdCBuID0gcigxMiksCiAgICAgICAgICAgIGkgPSByKDEzKSwKICAgICAgICAgICAgbyA9IHIoMCk7CiAgICAgICAgICBlLkZpbGVFeHRyYWN0b3IgPSBjbGFzcyBleHRlbmRzIG8uRXh0cmFjdG9yIHsKICAgICAgICAgICAgY29uc3RydWN0b3IodCwgZSwgcikgewogICAgICAgICAgICAgIHN1cGVyKHIpLCAodGhpcy5fZmlsZVBhdGggPSB0KSwgKHRoaXMuZmlsZU1hcCA9IHt9KSwgKHRoaXMuX3RhcmdldCA9IGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG9wZW4odCkgewogICAgICAgICAgICAgIGxldCBlID0gbi5vcGVuU3luYyh0LCAncicpOwogICAgICAgICAgICAgIHJldHVybiAodGhpcy5maWxlTWFwW2VdID0geyBzaXplOiBuLmZzdGF0U3luYyhlKS5zaXplLCBwb3M6IDAsIG5hbWU6IHQgfSksIGUKICAgICAgICAgICAgfQogICAgICAgICAgICBjcmVhdGUodCkgewogICAgICAgICAgICAgIGxldCBlID0gaS5qb2luKHRoaXMuX3RhcmdldCwgdCk7CiAgICAgICAgICAgICAgaS5wYXJzZShlKQogICAgICAgICAgICAgICAgLmRpci5zcGxpdCgnLycpCiAgICAgICAgICAgICAgICAucmVkdWNlKCh0LCBlKSA9PiAoKHQgKz0gZSArICcvJyksIG4uZXhpc3RzU3luYyh0KSB8fCBuLm1rZGlyU3luYyh0KSwgdCksICcnKTsKICAgICAgICAgICAgICBsZXQgciA9IG4ub3BlblN5bmMoZSwgJ3cnKTsKICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZmlsZU1hcFtyXSA9IHsgc2l6ZTogMCwgcG9zOiAwLCBuYW1lOiB0IH0pLCByCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2xvc2VGaWxlKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuZmlsZU1hcFt0XSwgbi5jbG9zZVN5bmModCksIG51bGwKICAgICAgICAgICAgfQogICAgICAgICAgICByZWFkKGUsIHIsIGkpIHsKICAgICAgICAgICAgICBsZXQgbyA9IHRoaXMuZmlsZU1hcFtlXSwKICAgICAgICAgICAgICAgIHMgPSBuZXcgdChpKSwKICAgICAgICAgICAgICAgIHUgPSBuLnJlYWRTeW5jKGUsIHMsIDAsIGksIG8ucG9zKTsKICAgICAgICAgICAgICByZXR1cm4gdW5wYWNrLkhFQVBVOC5zZXQocywgciksIChvLnBvcyArPSB1KSwgdQogICAgICAgICAgICB9CiAgICAgICAgICAgIHdyaXRlKGUsIHIsIGkpIHsKICAgICAgICAgICAgICBsZXQgbyA9IHRoaXMuZmlsZU1hcFtlXSwKICAgICAgICAgICAgICAgIHMgPSBuLndyaXRlU3luYyhlLCBuZXcgdCh1bnBhY2suSEVBUFU4LnN1YmFycmF5KHIsIHIgKyBpKSksIDAsIGkpOwogICAgICAgICAgICAgIHJldHVybiAoby5wb3MgKz0gcyksIChvLnNpemUgKz0gcyksIHMgPT09IGkKICAgICAgICAgICAgfQogICAgICAgICAgICB0ZWxsKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlTWFwW3RdLnBvcwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNlZWsodCwgZSwgcikgewogICAgICAgICAgICAgIGxldCBuID0gdGhpcy5maWxlTWFwW3RdLAogICAgICAgICAgICAgICAgaSA9IG4ucG9zOwogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAnU0VUJyA9PT0gciA/IChpID0gMCkgOiAnRU5EJyA9PT0gciAmJiAoaSA9IG4uc2l6ZSksICEoKGkgKz0gZSkgPCAwIHx8IGkgPiBuLnNpemUgfHwgKChuLnBvcyA9IGkpLCAwKSkKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgfS5jYWxsKHRoaXMsIHIoNykuQnVmZmVyKSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAvKiEKICAgICAgICAgICAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogICAgICAgICAgICoKICAgICAgICAgICAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPgogICAgICAgICAgICogQGxpY2Vuc2UgIE1JVAogICAgICAgICAgICovCiAgICAgICAgICB2YXIgbiA9IHIoOSksCiAgICAgICAgICAgIGkgPSByKDEwKSwKICAgICAgICAgICAgbyA9IHIoMTEpOwogICAgICAgICAgZnVuY3Rpb24gcygpIHsKICAgICAgICAgICAgcmV0dXJuIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/IDIxNDc0ODM2NDcgOiAxMDczNzQxODIzCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiB1KHQsIGUpIHsKICAgICAgICAgICAgaWYgKHMoKSA8IGUpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpCiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUCiAgICAgICAgICAgICAgICA/ICgodCA9IG5ldyBVaW50OEFycmF5KGUpKS5fX3Byb3RvX18gPSBhLnByb3RvdHlwZSkKICAgICAgICAgICAgICAgIDogKG51bGwgPT09IHQgJiYgKHQgPSBuZXcgYShlKSksICh0Lmxlbmd0aCA9IGUpKSwKICAgICAgICAgICAgICB0CiAgICAgICAgICAgICkKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGEodCwgZSwgcikgewogICAgICAgICAgICBpZiAoIShhLlRZUEVEX0FSUkFZX1NVUFBPUlQgfHwgdGhpcyBpbnN0YW5jZW9mIGEpKSByZXR1cm4gbmV3IGEodCwgZSwgcikKICAgICAgICAgICAgaWYgKCdudW1iZXInID09IHR5cGVvZiB0KSB7CiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpCiAgICAgICAgICAgICAgcmV0dXJuIGwodGhpcywgdCkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZih0aGlzLCB0LCBlLCByKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZih0LCBlLCByLCBuKSB7CiAgICAgICAgICAgIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpCiAgICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyCiAgICAgICAgICAgICAgPyAoZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgICAgICAgaWYgKChlLmJ5dGVMZW5ndGgsIHIgPCAwIHx8IGUuYnl0ZUxlbmd0aCA8IHIpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kcyIpCiAgICAgICAgICAgICAgICAgIGlmIChlLmJ5dGVMZW5ndGggPCByICsgKG4gfHwgMCkpIHRocm93IG5ldyBSYW5nZUVycm9yKCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzIikKICAgICAgICAgICAgICAgICAgZSA9CiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSByICYmIHZvaWQgMCA9PT0gbgogICAgICAgICAgICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheShlKQogICAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgPT09IG4KICAgICAgICAgICAgICAgICAgICAgID8gbmV3IFVpbnQ4QXJyYXkoZSwgcikKICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoZSwgciwgbik7CiAgICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/ICgodCA9IGUpLl9fcHJvdG9fXyA9IGEucHJvdG90eXBlKSA6ICh0ID0gYyh0LCBlKSk7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0CiAgICAgICAgICAgICAgICB9KSh0LCBlLCByLCBuKQogICAgICAgICAgICAgIDogJ3N0cmluZycgPT0gdHlwZW9mIGUKICAgICAgICAgICAgICA/IChmdW5jdGlvbiAodCwgZSwgcikgewogICgnc3RyaW5nJyA9PSB0eXBlb2YgciAmJiAnJyAhPT0gcikgfHwgKHIgPSAndXRmOCcpOwogICAgICAgICAgICAgICAgICBpZiAoIWEuaXNFbmNvZGluZyhyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignImVuY29kaW5nIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJykKICAgICAgICAgICAgICAgICAgdmFyIG4gPSAwIHwgZyhlLCByKSwKICAgICAgICAgICAgICAgICAgICBpID0gKHQgPSB1KHQsIG4pKS53cml0ZShlLCByKTsKICAgICAgICAgICAgICAgICAgaSAhPT0gbiAmJiAodCA9IHQuc2xpY2UoMCwgaSkpOwogICAgICAgICAgICAgICAgICByZXR1cm4gdAogICAgICAgICAgICAgICAgfSkodCwgZSwgcikKICAgICAgICAgICAgICA6IChmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgICBpZiAoYS5pc0J1ZmZlcihlKSkgewogICAgICAgICAgICAgICAgICAgIHZhciByID0gMCB8IHAoZS5sZW5ndGgpOwogICAgICAgICAgICAgICAgICAgIHJldHVybiAwID09PSAodCA9IHUodCwgcikpLmxlbmd0aCA/IHQgOiAoZS5jb3B5KHQsIDAsIDAsIHIpLCB0KQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChlKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCgndW5kZWZpbmVkJyAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gZSkKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJyAhPSB0eXBlb2YgZS5sZW5ndGggfHwKICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgIT0gdAogICAgICAgICAgICAgICAgICAgICAgICB9KShlLmxlbmd0aCkKICAgICAgICAgICAgICAgICAgICAgICAgPyB1KHQsIDApCiAgICAgICAgICAgICAgICAgICAgICAgIDogYyh0LCBlKQogICAgICAgICAgICAgICAgICAgIGlmICgnQnVmZmVyJyA9PT0gZS50eXBlICYmIG8oZS5kYXRhKSkgcmV0dXJuIGModCwgZS5kYXRhKQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nCiAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIH0pKHQsIGUpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBoKHQpIHsKICAgICAgICAgICAgaWYgKCdudW1iZXInICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgICAgICAgICAgIGlmICh0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBsKHQsIGUpIHsKICAgICAgICAgICAgaWYgKChoKGUpLCAodCA9IHUodCwgZSA8IDAgPyAwIDogMCB8IHAoZSkpKSwgIWEuVFlQRURfQVJSQVlfU1VQUE9SVCkpIGZvciAodmFyIHIgPSAwOyByIDwgZTsgKytyKSB0W3JdID0gMDsKICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGModCwgZSkgewogICAgICAgICAgICB2YXIgciA9IGUubGVuZ3RoIDwgMCA/IDAgOiAwIHwgcChlLmxlbmd0aCk7CiAgICAgICAgICAgIHQgPSB1KHQsIHIpOwogICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHI7IG4gKz0gMSkgdFtuXSA9IDI1NSAmIGVbbl07CiAgICAgICAgICAgIHJldHVybiB0CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBwKHQpIHsKICAgICAgICAgICAgaWYgKHQgPj0gcygpKQogICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKAogICAgICAgICAgICAgICAgJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgnICsgcygpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnCiAgICAgICAgICAgICAgKQogICAgICAgICAgICByZXR1cm4gMCB8IHQKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGcodCwgZSkgewogICAgICAgICAgICBpZiAoYS5pc0J1ZmZlcih0KSkgcmV0dXJuIHQubGVuZ3RoCiAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAndW5kZWZpbmVkJyAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYKICAgICAgICAgICAgICAnZnVuY3Rpb24nID09IHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgJiYKICAgICAgICAgICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHQpIHx8IHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikKICAgICAgICAgICAgKQogICAgICAgICAgICAgIHJldHVybiB0LmJ5dGVMZW5ndGgKICAgICAgICAgICAgJ3N0cmluZycgIT0gdHlwZW9mIHQgJiYgKHQgPSAnJyArIHQpOwogICAgICAgICAgICB2YXIgciA9IHQubGVuZ3RoOwogICAgICAgICAgICBpZiAoMCA9PT0gcikgcmV0dXJuIDAKICAgICAgICAgICAgZm9yICh2YXIgbiA9ICExOyA7ICkKICAgICAgICAgICAgICBzd2l0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOgogICAgICAgICAgICAgICAgICByZXR1cm4gcgogICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6CiAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgICAgICAgICBjYXNlIHZvaWQgMDoKICAgICAgICAgICAgICAgICAgcmV0dXJuIGsodCkubGVuZ3RoCiAgICAgICAgICAgICAgICBjYXNlICd1Y3MyJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3Vjcy0yJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICAgICAgICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgICAgICAgICAgICByZXR1cm4gMiAqIHIKICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgICAgICAgICAgIHJldHVybiByID4+PiAxCiAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgICAgICAgICAgICByZXR1cm4gaih0KS5sZW5ndGgKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgIGlmIChuKSByZXR1cm4gayh0KS5sZW5ndGgKICAgICAgICAgICAgICAgICAgOyhlID0gKCcnICsgZSkudG9Mb3dlckNhc2UoKSksIChuID0gITApOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGQodCwgZSwgcikgewogICAgICAgICAgICB2YXIgbiA9IHRbZV0KICAgICAgICAgICAgOyh0W2VdID0gdFtyXSksICh0W3JdID0gbik7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiB5KHQsIGUsIHIsIG4sIGkpIHsKICAgICAgICAgICAgaWYgKDAgPT09IHQubGVuZ3RoKSByZXR1cm4gLTEKICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICgnc3RyaW5nJyA9PSB0eXBlb2YgcgogICAgICAgICAgICAgICAgPyAoKG4gPSByKSwgKHIgPSAwKSkKICAgICAgICAgICAgICAgIDogciA+IDIxNDc0ODM2NDcKICAgICAgICAgICAgICAgID8gKHIgPSAyMTQ3NDgzNjQ3KQogICAgICAgICAgICAgICAgOiByIDwgLTIxNDc0ODM2NDggJiYgKHIgPSAtMjE0NzQ4MzY0OCksCiAgICAgICAgICAgICAgKHIgPSArciksCiAgICAgICAgICAgICAgaXNOYU4ocikgJiYgKHIgPSBpID8gMCA6IHQubGVuZ3RoIC0gMSksCiAgICAgICAgICAgICAgciA8IDAgJiYgKHIgPSB0Lmxlbmd0aCArIHIpLAogICAgICAgICAgICAgIHIgPj0gdC5sZW5ndGgpCiAgICAgICAgICAgICkgewogICAgICAgICAgICAgIGlmIChpKSByZXR1cm4gLTEKICAgICAgICAgICAgICByID0gdC5sZW5ndGggLSAxOwogICAgICAgICAgICB9IGVsc2UgaWYgKHIgPCAwKSB7CiAgICAgICAgICAgICAgaWYgKCFpKSByZXR1cm4gLTEKICAgICAgICAgICAgICByID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKCdzdHJpbmcnID09IHR5cGVvZiBlICYmIChlID0gYS5mcm9tKGUsIG4pKSwgYS5pc0J1ZmZlcihlKSkpIHJldHVybiAwID09PSBlLmxlbmd0aCA/IC0xIDogdyh0LCBlLCByLCBuLCBpKQogICAgICAgICAgICBpZiAoJ251bWJlcicgPT0gdHlwZW9mIGUpCiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgIChlICY9IDI1NSksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZgogICAgICAgICAgICAgICAgICA/IGkKICAgICAgICAgICAgICAgICAgICA/IFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0LCBlLCByKQogICAgICAgICAgICAgICAgICAgIDogVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbCh0LCBlLCByKQogICAgICAgICAgICAgICAgICA6IHcodCwgW2VdLCByLCBuLCBpKQogICAgICAgICAgICAgICkKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJykKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHcodCwgZSwgciwgbiwgaSkgewogICAgICAgICAgICB2YXIgbywKICAgICAgICAgICAgICBzID0gMSwKICAgICAgICAgICAgICB1ID0gdC5sZW5ndGgsCiAgICAgICAgICAgICAgYSA9IGUubGVuZ3RoOwogICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgdm9pZCAwICE9PSBuICYmCiAgICAgICAgICAgICAgKCd1Y3MyJyA9PT0gKG4gPSBTdHJpbmcobikudG9Mb3dlckNhc2UoKSkgfHwgJ3Vjcy0yJyA9PT0gbiB8fCAndXRmMTZsZScgPT09IG4gfHwgJ3V0Zi0xNmxlJyA9PT0gbikKICAgICAgICAgICAgKSB7CiAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoIDwgMiB8fCBlLmxlbmd0aCA8IDIpIHJldHVybiAtMQogICAgICAgICAgICAgIDsocyA9IDIpLCAodSAvPSAyKSwgKGEgLz0gMiksIChyIC89IDIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGYodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiAxID09PSBzID8gdFtlXSA6IHQucmVhZFVJbnQxNkJFKGUgKiBzKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChpKSB7CiAgICAgICAgICAgICAgdmFyIGggPSAtMTsKICAgICAgICAgICAgICBmb3IgKG8gPSByOyBvIDwgdTsgbysrKQogICAgICAgICAgICAgICAgaWYgKGYodCwgbykgPT09IGYoZSwgLTEgPT09IGggPyAwIDogbyAtIGgpKSB7CiAgICAgICAgICAgICAgICAgIGlmICgoLTEgPT09IGggJiYgKGggPSBvKSwgbyAtIGggKyAxID09PSBhKSkgcmV0dXJuIGggKiBzCiAgICAgICAgICAgICAgICB9IGVsc2UgLTEgIT09IGggJiYgKG8gLT0gbyAtIGgpLCAoaCA9IC0xKTsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgZm9yIChyICsgYSA+IHUgJiYgKHIgPSB1IC0gYSksIG8gPSByOyBvID49IDA7IG8tLSkgewogICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9ICEwLCBjID0gMDsgYyA8IGE7IGMrKykKICAgICAgICAgICAgICAgICAgaWYgKGYodCwgbyArIGMpICE9PSBmKGUsIGMpKSB7CiAgICAgICAgICAgICAgICAgICAgbCA9ICExOwogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChsKSByZXR1cm4gbwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIC0xCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBFKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgciA9IE51bWJlcihyKSB8fCAwOwogICAgICAgICAgICB2YXIgaSA9IHQubGVuZ3RoIC0gcjsKICAgICAgICAgICAgbiA/IChuID0gTnVtYmVyKG4pKSA+IGkgJiYgKG4gPSBpKSA6IChuID0gaSk7CiAgICAgICAgICAgIHZhciBvID0gZS5sZW5ndGg7CiAgICAgICAgICAgIGlmIChvICUgMiAhPSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKQogICAgICAgICAgICBuID4gbyAvIDIgJiYgKG4gPSBvIC8gMik7CiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbjsgKytzKSB7CiAgICAgICAgICAgICAgdmFyIHUgPSBwYXJzZUludChlLnN1YnN0cigyICogcywgMiksIDE2KTsKICAgICAgICAgICAgICBpZiAoaXNOYU4odSkpIHJldHVybiBzCiAgICAgICAgICAgICAgdFtyICsgc10gPSB1OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBzCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiB2KHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgcmV0dXJuIHooayhlLCB0Lmxlbmd0aCAtIHIpLCB0LCByLCBuKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gQSh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgIHJldHVybiB6KAogICAgICAgICAgICAgIChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gMDsgciA8IHQubGVuZ3RoOyArK3IpIGUucHVzaCgyNTUgJiB0LmNoYXJDb2RlQXQocikpOwogICAgICAgICAgICAgICAgcmV0dXJuIGUKICAgICAgICAgICAgICB9KShlKSwKICAgICAgICAgICAgICB0LAogICAgICAgICAgICAgIHIsCiAgICAgICAgICAgICAgbgogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBfKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgcmV0dXJuIEEodCwgZSwgciwgbikKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGIodCwgZSwgciwgbikgewogICAgICAgICAgICByZXR1cm4geihqKGUpLCB0LCByLCBuKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gbSh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgIHJldHVybiB6KAogICAgICAgICAgICAgIChmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgZm9yICh2YXIgciwgbiwgaSwgbyA9IFtdLCBzID0gMDsgcyA8IHQubGVuZ3RoICYmICEoKGUgLT0gMikgPCAwKTsgKytzKQogICAgICAgICAgICAgICAgICAociA9IHQuY2hhckNvZGVBdChzKSksIChuID0gciA+PiA4KSwgKGkgPSByICUgMjU2KSwgby5wdXNoKGkpLCBvLnB1c2gobik7CiAgICAgICAgICAgICAgICByZXR1cm4gbwogICAgICAgICAgICAgIH0pKGUsIHQubGVuZ3RoIC0gciksCiAgICAgICAgICAgICAgdCwKICAgICAgICAgICAgICByLAogICAgICAgICAgICAgIG4KICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gUih0LCBlLCByKSB7CiAgICAgICAgICAgIHJldHVybiAwID09PSBlICYmIHIgPT09IHQubGVuZ3RoID8gbi5mcm9tQnl0ZUFycmF5KHQpIDogbi5mcm9tQnl0ZUFycmF5KHQuc2xpY2UoZSwgcikpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBTKHQsIGUsIHIpIHsKICAgICAgICAgICAgciA9IE1hdGgubWluKHQubGVuZ3RoLCByKTsKICAgICAgICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gZTsgaSA8IHI7ICkgewogICAgICAgICAgICAgIHZhciBvLAogICAgICAgICAgICAgICAgcywKICAgICAgICAgICAgICAgIHUsCiAgICAgICAgICAgICAgICBhLAogICAgICAgICAgICAgICAgZiA9IHRbaV0sCiAgICAgICAgICAgICAgICBoID0gbnVsbCwKICAgICAgICAgICAgICAgIGwgPSBmID4gMjM5ID8gNCA6IGYgPiAyMjMgPyAzIDogZiA+IDE5MSA/IDIgOiAxOwogICAgICAgICAgICAgIGlmIChpICsgbCA8PSByKQogICAgICAgICAgICAgICAgc3dpdGNoIChsKSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICBmIDwgMTI4ICYmIChoID0gZik7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIDEyOCA9PSAoMTkyICYgKG8gPSB0W2kgKyAxXSkpICYmIChhID0gKCgzMSAmIGYpIDw8IDYpIHwgKDYzICYgbykpID4gMTI3ICYmIChoID0gYSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgY2FzZSAzOgogIChvID0gdFtpICsgMV0pLAogICAgICAgICAgICAgICAgICAgICAgKHMgPSB0W2kgKyAyXSksCiAgICAgICAgICAgICAgICAgICAgICAxMjggPT0gKDE5MiAmIG8pICYmCiAgICAgICAgICAgICAgICAgICAgICAgIDEyOCA9PSAoMTkyICYgcykgJiYKICAgICAgICAgICAgICAgICAgICAgICAgKGEgPSAoKDE1ICYgZikgPDwgMTIpIHwgKCg2MyAmIG8pIDw8IDYpIHwgKDYzICYgcykpID4gMjA0NyAmJgogICAgICAgICAgICAgICAgICAgICAgICAoYSA8IDU1Mjk2IHx8IGEgPiA1NzM0MykgJiYKICAgICAgICAgICAgICAgICAgICAgICAgKGggPSBhKTsKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgKG8gPSB0W2kgKyAxXSksCiAgICAgICAgICAgICAgICAgICAgICAocyA9IHRbaSArIDJdKSwKICAgICAgICAgICAgICAgICAgICAgICh1ID0gdFtpICsgM10pLAogICAgICAgICAgICAgICAgICAgICAgMTI4ID09ICgxOTIgJiBvKSAmJgogICAgICAgICAgICAgICAgICAgICAgICAxMjggPT0gKDE5MiAmIHMpICYmCiAgICAgICAgICAgICAgICAgICAgICAgIDEyOCA9PSAoMTkyICYgdSkgJiYKICAgICAgICAgICAgICAgICAgICAgICAgKGEgPSAoKDE1ICYgZikgPDwgMTgpIHwgKCg2MyAmIG8pIDw8IDEyKSB8ICgoNjMgJiBzKSA8PCA2KSB8ICg2MyAmIHUpKSA+IDY1NTM1ICYmCiAgICAgICAgICAgICAgICAgICAgICAgIGEgPCAxMTE0MTEyICYmCiAgICAgICAgICAgICAgICAgICAgICAgIChoID0gYSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbnVsbCA9PT0gaAogICAgICAgICAgICAgICAgPyAoKGggPSA2NTUzMyksIChsID0gMSkpCiAgICAgICAgICAgICAgICA6IGggPiA2NTUzNSAmJiAoKGggLT0gNjU1MzYpLCBuLnB1c2goKChoID4+PiAxMCkgJiAxMDIzKSB8IDU1Mjk2KSwgKGggPSA1NjMyMCB8ICgxMDIzICYgaCkpKSwKICAgICAgICAgICAgICAgIG4ucHVzaChoKSwKICAgICAgICAgICAgICAgIChpICs9IGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICB2YXIgZSA9IHQubGVuZ3RoOwogICAgICAgICAgICAgIGlmIChlIDw9IFQpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdCkKICAgICAgICAgICAgICB2YXIgciA9ICcnLAogICAgICAgICAgICAgICAgbiA9IDA7CiAgICAgICAgICAgICAgZm9yICg7IG4gPCBlOyApIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHQuc2xpY2UobiwgKG4gKz0gVCkpKTsKICAgICAgICAgICAgICByZXR1cm4gcgogICAgICAgICAgICB9KShuKQogICAgICAgICAgfQogIChlLkJ1ZmZlciA9IGEpLAogICAgICAgICAgICAoZS5TbG93QnVmZmVyID0gZnVuY3Rpb24gKHQpIHsKICArdCAhPSB0ICYmICh0ID0gMCk7CiAgICAgICAgICAgICAgcmV0dXJuIGEuYWxsb2MoK3QpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoZS5JTlNQRUNUX01BWF9CWVRFUyA9IDUwKSwKICAgICAgICAgICAgKGEuVFlQRURfQVJSQVlfU1VQUE9SVCA9CiAgICAgICAgICAgICAgdm9pZCAwICE9PSB0LlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgID8gdC5UWVBFRF9BUlJBWV9TVVBQT1JUCiAgICAgICAgICAgICAgICA6IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgICAgICAgICAodC5fX3Byb3RvX18gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgICBmb286IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0MgogICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAgICAgICA0MiA9PT0gdC5mb28oKSAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiB0LnN1YmFycmF5ICYmIDAgPT09IHQuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aAogICAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfSkoKSksCiAgICAgICAgICAgIChlLmtNYXhMZW5ndGggPSBzKCkpLAogICAgICAgICAgICAoYS5wb29sU2l6ZSA9IDgxOTIpLAogICAgICAgICAgICAoYS5fYXVnbWVudCA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuICh0Ll9fcHJvdG9fXyA9IGEucHJvdG90eXBlKSwgdAogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuZnJvbSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGYobnVsbCwgdCwgZSwgcikKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCAmJgogICAgICAgICAgICAgICgoYS5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGUpLAogICAgICAgICAgICAgIChhLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkpLAogICAgICAgICAgICAgICd1bmRlZmluZWQnICE9IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgICAgIFN5bWJvbC5zcGVjaWVzICYmCiAgICAgICAgICAgICAgICBhW1N5bWJvbC5zcGVjaWVzXSA9PT0gYSAmJgogICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFN5bWJvbC5zcGVjaWVzLCB7IHZhbHVlOiBudWxsLCBjb25maWd1cmFibGU6ICEwIH0pKSwKICAgICAgICAgICAgKGEuYWxsb2MgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgIGgoZSksCiAgICAgICAgICAgICAgICAgIGUgPD0gMAogICAgICAgICAgICAgICAgICAgID8gdSh0LCBlKQogICAgICAgICAgICAgICAgICAgIDogdm9pZCAwICE9PSByCiAgICAgICAgICAgICAgICAgICAgPyAnc3RyaW5nJyA9PSB0eXBlb2YgbgogICAgICAgICAgICAgICAgICAgICAgPyB1KHQsIGUpLmZpbGwociwgbikKICAgICAgICAgICAgICAgICAgICAgIDogdSh0LCBlKS5maWxsKHIpCiAgICAgICAgICAgICAgICAgICAgOiB1KHQsIGUpCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgfSkobnVsbCwgdCwgZSwgcikKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gbChudWxsLCB0KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gbChudWxsLCB0KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuaXNCdWZmZXIgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiAhKG51bGwgPT0gdCB8fCAhdC5faXNCdWZmZXIpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5jb21wYXJlID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIodCkgfHwgIWEuaXNCdWZmZXIoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKQogICAgICAgICAgICAgIGlmICh0ID09PSBlKSByZXR1cm4gMAogICAgICAgICAgICAgIGZvciAodmFyIHIgPSB0Lmxlbmd0aCwgbiA9IGUubGVuZ3RoLCBpID0gMCwgbyA9IE1hdGgubWluKHIsIG4pOyBpIDwgbzsgKytpKQogICAgICAgICAgICAgICAgaWYgKHRbaV0gIT09IGVbaV0pIHsKICAociA9IHRbaV0pLCAobiA9IGVbaV0pOwogICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiByIDwgbiA/IC0xIDogbiA8IHIgPyAxIDogMAogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuaXNFbmNvZGluZyA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgc3dpdGNoIChTdHJpbmcodCkudG9Mb3dlckNhc2UoKSkgewogICAgICAgICAgICAgICAgY2FzZSAnaGV4JzoKICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgICAgICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgICAgICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgICAgICAgICAgY2FzZSAndWNzMic6CiAgICAgICAgICAgICAgICBjYXNlICd1Y3MtMic6CiAgICAgICAgICAgICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgICAgICAgICAgICAgcmV0dXJuICEwCiAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICByZXR1cm4gITEKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5jb25jYXQgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIGlmICghbyh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCiAgICAgICAgICAgICAgaWYgKDAgPT09IHQubGVuZ3RoKSByZXR1cm4gYS5hbGxvYygwKQogICAgICAgICAgICAgIHZhciByOwogICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIGZvciAoZSA9IDAsIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgZSArPSB0W3JdLmxlbmd0aDsKICAgICAgICAgICAgICB2YXIgbiA9IGEuYWxsb2NVbnNhZmUoZSksCiAgICAgICAgICAgICAgICBpID0gMDsKICAgICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgewogICAgICAgICAgICAgICAgdmFyIHMgPSB0W3JdOwogICAgICAgICAgICAgICAgaWYgKCFhLmlzQnVmZmVyKHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKICAgICAgICAgICAgICAgIHMuY29weShuLCBpKSwgKGkgKz0gcy5sZW5ndGgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gbgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuYnl0ZUxlbmd0aCA9IGcpLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuX2lzQnVmZmVyID0gITApLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICAgICAgaWYgKHQgJSAyICE9IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpCiAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0OyBlICs9IDIpIGQodGhpcywgZSwgZSArIDEpOwogICAgICAgICAgICAgIHJldHVybiB0aGlzCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5sZW5ndGg7CiAgICAgICAgICAgICAgaWYgKHQgJSA0ICE9IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpCiAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0OyBlICs9IDQpIGQodGhpcywgZSwgZSArIDMpLCBkKHRoaXMsIGUgKyAxLCBlICsgMik7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgICAgICBpZiAodCAlIDggIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJykKICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQ7IGUgKz0gOCkKICAgICAgICAgICAgICAgIGQodGhpcywgZSwgZSArIDcpLCBkKHRoaXMsIGUgKyAxLCBlICsgNiksIGQodGhpcywgZSArIDIsIGUgKyA1KSwgZCh0aGlzLCBlICsgMywgZSArIDQpOwogICAgICAgICAgICAgIHJldHVybiB0aGlzCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSAwIHwgdGhpcy5sZW5ndGg7CiAgICAgICAgICAgICAgcmV0dXJuIDAgPT09IHQKICAgICAgICAgICAgICAgID8gJycKICAgICAgICAgICAgICAgIDogMCA9PT0gYXJndW1lbnRzLmxlbmd0aAogICAgICAgICAgICAgICAgPyBTKHRoaXMsIDAsIHQpCiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAhMTsKICAgICAgICAgICAgICAgICAgICBpZiAoKCh2b2lkIDAgPT09IGUgfHwgZSA8IDApICYmIChlID0gMCksIGUgPiB0aGlzLmxlbmd0aCkpIHJldHVybiAnJwogICAgICAgICAgICAgICAgICAgIGlmICgoKHZvaWQgMCA9PT0gciB8fCByID4gdGhpcy5sZW5ndGgpICYmIChyID0gdGhpcy5sZW5ndGgpLCByIDw9IDApKSByZXR1cm4gJycKICAgICAgICAgICAgICAgICAgICBpZiAoKHIgPj4+PSAwKSA8PSAoZSA+Pj49IDApKSByZXR1cm4gJycKICAgICAgICAgICAgICAgICAgICBmb3IgKHQgfHwgKHQgPSAndXRmOCcpOyA7ICkKICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdoZXgnOgogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVKHRoaXMsIGUsIHIpCiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFModGhpcywgZSwgcikKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQKHRoaXMsIGUsIHIpCiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEModGhpcywgZSwgcikKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzoKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUih0aGlzLCBlLCByKQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1Y3MyJzoKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndWNzLTInOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCKHRoaXMsIGUsIHIpCiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyB0KQogICAgICAgICAgICAgICAgICAgICAgICAgIDsodCA9ICh0ICsgJycpLnRvTG93ZXJDYXNlKCkpLCAobiA9ICEwKTsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfS5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIodCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKQogICAgICAgICAgICAgIHJldHVybiB0aGlzID09PSB0IHx8IDAgPT09IGEuY29tcGFyZSh0aGlzLCB0KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSAnJywKICAgICAgICAgICAgICAgIHIgPSBlLklOU1BFQ1RfTUFYX0JZVEVTOwogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA+IDAgJiYKICAgICAgICAgICAgICAgICAgKCh0ID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgcikubWF0Y2goLy57Mn0vZykuam9pbignICcpKSwgdGhpcy5sZW5ndGggPiByICYmICh0ICs9ICcgLi4uICcpKSwKICAgICAgICAgICAgICAgICc8QnVmZmVyICcgKyB0ICsgJz4nCiAgICAgICAgICAgICAgKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkgewogICAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcih0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgKHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLAogICAgICAgICAgICAgICAgdm9pZCAwID09PSByICYmIChyID0gdCA/IHQubGVuZ3RoIDogMCksCiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAwKSwKICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHRoaXMubGVuZ3RoKSwKICAgICAgICAgICAgICAgIGUgPCAwIHx8IHIgPiB0Lmxlbmd0aCB8fCBuIDwgMCB8fCBpID4gdGhpcy5sZW5ndGgpCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpCiAgICAgICAgICAgICAgaWYgKG4gPj0gaSAmJiBlID49IHIpIHJldHVybiAwCiAgICAgICAgICAgICAgaWYgKG4gPj0gaSkgcmV0dXJuIC0xCiAgICAgICAgICAgICAgaWYgKGUgPj0gcikgcmV0dXJuIDEKICAgICAgICAgICAgICBpZiAoKChlID4+Pj0gMCksIChyID4+Pj0gMCksIChuID4+Pj0gMCksIChpID4+Pj0gMCksIHRoaXMgPT09IHQpKSByZXR1cm4gMAogICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICB2YXIgbyA9IGkgLSBuLCBzID0gciAtIGUsIHUgPSBNYXRoLm1pbihvLCBzKSwgZiA9IHRoaXMuc2xpY2UobiwgaSksIGggPSB0LnNsaWNlKGUsIHIpLCBsID0gMDsKICAgICAgICAgICAgICAgIGwgPCB1OwogICAgICAgICAgICAgICAgKytsCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgaWYgKGZbbF0gIT09IGhbbF0pIHsKICAobyA9IGZbbF0pLCAocyA9IGhbbF0pOwogICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBvIDwgcyA/IC0xIDogcyA8IG8gPyAxIDogMAogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHRoaXMuaW5kZXhPZih0LCBlLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiB5KHRoaXMsIHQsIGUsIHIsICEwKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4geSh0aGlzLCB0LCBlLCByLCAhMSkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgKG4gPSAndXRmOCcpLCAociA9IHRoaXMubGVuZ3RoKSwgKGUgPSAwKTsKICAgICAgICAgICAgICBlbHNlIGlmICh2b2lkIDAgPT09IHIgJiYgJ3N0cmluZycgPT0gdHlwZW9mIGUpIChuID0gZSksIChyID0gdGhpcy5sZW5ndGgpLCAoZSA9IDApOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShlKSkKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcpCiAgICAgICAgICAgICAgICA7KGUgfD0gMCksIGlzRmluaXRlKHIpID8gKChyIHw9IDApLCB2b2lkIDAgPT09IG4gJiYgKG4gPSAndXRmOCcpKSA6ICgobiA9IHIpLCAociA9IHZvaWQgMCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gZTsKICAgICAgICAgICAgICBpZiAoKCh2b2lkIDAgPT09IHIgfHwgciA+IGkpICYmIChyID0gaSksICh0Lmxlbmd0aCA+IDAgJiYgKHIgPCAwIHx8IGUgPCAwKSkgfHwgZSA+IHRoaXMubGVuZ3RoKSkKICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpCiAgICAgICAgICAgICAgbiB8fCAobiA9ICd1dGY4Jyk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbyA9ICExOyA7ICkKICAgICAgICAgICAgICAgIHN3aXRjaCAobikgewogICAgICAgICAgICAgICAgICBjYXNlICdoZXgnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBFKHRoaXMsIHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYodGhpcywgdCwgZSwgcikKICAgICAgICAgICAgICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBBKHRoaXMsIHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8odGhpcywgdCwgZSwgcikKICAgICAgICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYih0aGlzLCB0LCBlLCByKQogICAgICAgICAgICAgICAgICBjYXNlICd1Y3MyJzoKICAgICAgICAgICAgICAgICAgY2FzZSAndWNzLTInOgogICAgICAgICAgICAgICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBtKHRoaXMsIHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBuKQogICAgICAgICAgICAgICAgICAgIDsobiA9ICgnJyArIG4pLnRvTG93ZXJDYXNlKCkpLCAobyA9ICEwKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKSB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIFQgPSA0MDk2OwogICAgICAgICAgZnVuY3Rpb24gUCh0LCBlLCByKSB7CiAgICAgICAgICAgIHZhciBuID0gJyc7CiAgICAgICAgICAgIHIgPSBNYXRoLm1pbih0Lmxlbmd0aCwgcik7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlOyBpIDwgcjsgKytpKSBuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3ICYgdFtpXSk7CiAgICAgICAgICAgIHJldHVybiBuCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBDKHQsIGUsIHIpIHsKICAgICAgICAgICAgdmFyIG4gPSAnJzsKICAgICAgICAgICAgciA9IE1hdGgubWluKHQubGVuZ3RoLCByKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IGU7IGkgPCByOyArK2kpIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0W2ldKTsKICAgICAgICAgICAgcmV0dXJuIG4KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIFUodCwgZSwgcikgewogICAgICAgICAgICB2YXIgbiA9IHQubGVuZ3RoCiAgICAgICAgICAgIDsoIWUgfHwgZSA8IDApICYmIChlID0gMCksICghciB8fCByIDwgMCB8fCByID4gbikgJiYgKHIgPSBuKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9ICcnLCBvID0gZTsgbyA8IHI7ICsrbykgaSArPSBOKHRbb10pOwogICAgICAgICAgICByZXR1cm4gaQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gQih0LCBlLCByKSB7CiAgICAgICAgICAgIGZvciAodmFyIG4gPSB0LnNsaWNlKGUsIHIpLCBpID0gJycsIG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8gKz0gMikKICAgICAgICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobltvXSArIDI1NiAqIG5bbyArIDFdKTsKICAgICAgICAgICAgcmV0dXJuIGkKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEYodCwgZSwgcikgewogICAgICAgICAgICBpZiAodCAlIDEgIT0gMCB8fCB0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpCiAgICAgICAgICAgIGlmICh0ICsgZSA+IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJykKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIE0odCwgZSwgciwgbiwgaSwgbykgewogICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIodCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKQogICAgICAgICAgICBpZiAoZSA+IGkgfHwgZSA8IG8pIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKQogICAgICAgICAgICBpZiAociArIG4gPiB0Lmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiB4KHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgZSA8IDAgJiYgKGUgPSA2NTUzNSArIGUgKyAxKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG8gPSBNYXRoLm1pbih0Lmxlbmd0aCAtIHIsIDIpOyBpIDwgbzsgKytpKQogICAgICAgICAgICAgIHRbciArIGldID0gKGUgJiAoMjU1IDw8ICg4ICogKG4gPyBpIDogMSAtIGkpKSkpID4+PiAoOCAqIChuID8gaSA6IDEgLSBpKSk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBJKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgZSA8IDAgJiYgKGUgPSA0Mjk0OTY3Mjk1ICsgZSArIDEpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbyA9IE1hdGgubWluKHQubGVuZ3RoIC0gciwgNCk7IGkgPCBvOyArK2kpIHRbciArIGldID0gKGUgPj4+ICg4ICogKG4gPyBpIDogMyAtIGkpKSkgJiAyNTU7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBPKHQsIGUsIHIsIG4sIGksIG8pIHsKICAgICAgICAgICAgaWYgKHIgKyBuID4gdC5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQogICAgICAgICAgICBpZiAociA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gWSh0LCBlLCByLCBuLCBvKSB7CiAgICAgICAgICAgIHJldHVybiBvIHx8IE8odCwgMCwgciwgNCksIGkud3JpdGUodCwgZSwgciwgbiwgMjMsIDQpLCByICsgNAogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gTCh0LCBlLCByLCBuLCBvKSB7CiAgICAgICAgICAgIHJldHVybiBvIHx8IE8odCwgMCwgciwgOCksIGkud3JpdGUodCwgZSwgciwgbiwgNTIsIDgpLCByICsgOAogICAgICAgICAgfQogIChhLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgIHZhciByLAogICAgICAgICAgICAgIG4gPSB0aGlzLmxlbmd0aDsKICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICgodCA9IH5+dCksCiAgICAgICAgICAgICAgKGUgPSB2b2lkIDAgPT09IGUgPyBuIDogfn5lKSwKICAgICAgICAgICAgICB0IDwgMCA/ICh0ICs9IG4pIDwgMCAmJiAodCA9IDApIDogdCA+IG4gJiYgKHQgPSBuKSwKICAgICAgICAgICAgICBlIDwgMCA/IChlICs9IG4pIDwgMCAmJiAoZSA9IDApIDogZSA+IG4gJiYgKGUgPSBuKSwKICAgICAgICAgICAgICBlIDwgdCAmJiAoZSA9IHQpLAogICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCkKICAgICAgICAgICAgKQogICAgICAgICAgICAgIChyID0gdGhpcy5zdWJhcnJheSh0LCBlKSkuX19wcm90b19fID0gYS5wcm90b3R5cGU7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciBpID0gZSAtIHQ7CiAgICAgICAgICAgICAgciA9IG5ldyBhKGksIHZvaWQgMCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBpOyArK28pIHJbb10gPSB0aGlzW28gKyB0XTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcgogICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAodCB8PSAwKSwgKGUgfD0gMCksIHIgfHwgRih0LCBlLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IHRoaXNbdF0sIGkgPSAxLCBvID0gMDsgKytvIDwgZSAmJiAoaSAqPSAyNTYpOyApIG4gKz0gdGhpc1t0ICsgb10gKiBpOwogICAgICAgICAgICAgIHJldHVybiBuCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKHQgfD0gMCksIChlIHw9IDApLCByIHx8IEYodCwgZSwgdGhpcy5sZW5ndGgpOwogICAgICAgICAgICAgIGZvciAodmFyIG4gPSB0aGlzW3QgKyAtLWVdLCBpID0gMTsgZSA+IDAgJiYgKGkgKj0gMjU2KTsgKSBuICs9IHRoaXNbdCArIC0tZV0gKiBpOwogICAgICAgICAgICAgIHJldHVybiBuCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDEsIHRoaXMubGVuZ3RoKSwgdGhpc1t0XQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCAyLCB0aGlzLmxlbmd0aCksIHRoaXNbdF0gfCAodGhpc1t0ICsgMV0gPDwgOCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgMiwgdGhpcy5sZW5ndGgpLCAodGhpc1t0XSA8PCA4KSB8IHRoaXNbdCArIDFdCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgZSB8fCBGKHQsIDQsIHRoaXMubGVuZ3RoKSwgKHRoaXNbdF0gfCAodGhpc1t0ICsgMV0gPDwgOCkgfCAodGhpc1t0ICsgMl0gPDwgMTYpKSArIDE2Nzc3MjE2ICogdGhpc1t0ICsgM10KICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgZSB8fCBGKHQsIDQsIHRoaXMubGVuZ3RoKSwgMTY3NzcyMTYgKiB0aGlzW3RdICsgKCh0aGlzW3QgKyAxXSA8PCAxNikgfCAodGhpc1t0ICsgMl0gPDwgOCkgfCB0aGlzW3QgKyAzXSkKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAodCB8PSAwKSwgKGUgfD0gMCksIHIgfHwgRih0LCBlLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IHRoaXNbdF0sIGkgPSAxLCBvID0gMDsgKytvIDwgZSAmJiAoaSAqPSAyNTYpOyApIG4gKz0gdGhpc1t0ICsgb10gKiBpOwogICAgICAgICAgICAgIHJldHVybiBuID49IChpICo9IDEyOCkgJiYgKG4gLT0gTWF0aC5wb3coMiwgOCAqIGUpKSwgbgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKHQgfD0gMCksIChlIHw9IDApLCByIHx8IEYodCwgZSwgdGhpcy5sZW5ndGgpOwogICAgICAgICAgICAgIGZvciAodmFyIG4gPSBlLCBpID0gMSwgbyA9IHRoaXNbdCArIC0tbl07IG4gPiAwICYmIChpICo9IDI1Nik7ICkgbyArPSB0aGlzW3QgKyAtLW5dICogaTsKICAgICAgICAgICAgICByZXR1cm4gbyA+PSAoaSAqPSAxMjgpICYmIChvIC09IE1hdGgucG93KDIsIDggKiBlKSksIG8KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCAxLCB0aGlzLmxlbmd0aCksIDEyOCAmIHRoaXNbdF0gPyAtMSAqICgyNTUgLSB0aGlzW3RdICsgMSkgOiB0aGlzW3RdCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIGUgfHwgRih0LCAyLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzW3RdIHwgKHRoaXNbdCArIDFdIDw8IDgpOwogICAgICAgICAgICAgIHJldHVybiAzMjc2OCAmIHIgPyA0Mjk0OTAxNzYwIHwgciA6IHIKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgZSB8fCBGKHQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICAgICAgICB2YXIgciA9IHRoaXNbdCArIDFdIHwgKHRoaXNbdF0gPDwgOCk7CiAgICAgICAgICAgICAgcmV0dXJuIDMyNzY4ICYgciA/IDQyOTQ5MDE3NjAgfCByIDogcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDQsIHRoaXMubGVuZ3RoKSwgdGhpc1t0XSB8ICh0aGlzW3QgKyAxXSA8PCA4KSB8ICh0aGlzW3QgKyAyXSA8PCAxNikgfCAodGhpc1t0ICsgM10gPDwgMjQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1t0XSA8PCAyNCkgfCAodGhpc1t0ICsgMV0gPDwgMTYpIHwgKHRoaXNbdCArIDJdIDw8IDgpIHwgdGhpc1t0ICsgM10KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCA0LCB0aGlzLmxlbmd0aCksIGkucmVhZCh0aGlzLCB0LCAhMCwgMjMsIDQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgNCwgdGhpcy5sZW5ndGgpLCBpLnJlYWQodGhpcywgdCwgITEsIDIzLCA0KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCA4LCB0aGlzLmxlbmd0aCksIGkucmVhZCh0aGlzLCB0LCAhMCwgNTIsIDgpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDgsIHRoaXMubGVuZ3RoKSwgaS5yZWFkKHRoaXMsIHQsICExLCA1MiwgOCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgKCh0ID0gK3QpLCAoZSB8PSAwKSwgKHIgfD0gMCksIG4pIHx8IE0odGhpcywgdCwgZSwgciwgTWF0aC5wb3coMiwgOCAqIHIpIC0gMSwgMCk7CiAgICAgICAgICAgICAgdmFyIGkgPSAxLAogICAgICAgICAgICAgICAgbyA9IDA7CiAgICAgICAgICAgICAgZm9yICh0aGlzW2VdID0gMjU1ICYgdDsgKytvIDwgciAmJiAoaSAqPSAyNTYpOyApIHRoaXNbZSArIG9dID0gKHQgLyBpKSAmIDI1NTsKICAgICAgICAgICAgICByZXR1cm4gZSArIHIKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgKCh0ID0gK3QpLCAoZSB8PSAwKSwgKHIgfD0gMCksIG4pIHx8IE0odGhpcywgdCwgZSwgciwgTWF0aC5wb3coMiwgOCAqIHIpIC0gMSwgMCk7CiAgICAgICAgICAgICAgdmFyIGkgPSByIC0gMSwKICAgICAgICAgICAgICAgIG8gPSAxOwogICAgICAgICAgICAgIGZvciAodGhpc1tlICsgaV0gPSAyNTUgJiB0OyAtLWkgPj0gMCAmJiAobyAqPSAyNTYpOyApIHRoaXNbZSArIGldID0gKHQgLyBvKSAmIDI1NTsKICAgICAgICAgICAgICByZXR1cm4gZSArIHIKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCAxLCAyNTUsIDApLAogICAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUIHx8ICh0ID0gTWF0aC5mbG9vcih0KSksCiAgICAgICAgICAgICAgICAodGhpc1tlXSA9IDI1NSAmIHQpLAogICAgICAgICAgICAgICAgZSArIDEKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgMiwgNjU1MzUsIDApLAogICAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKCh0aGlzW2VdID0gMjU1ICYgdCksICh0aGlzW2UgKyAxXSA9IHQgPj4+IDgpKSA6IHgodGhpcywgdCwgZSwgITApLAogICAgICAgICAgICAgICAgZSArIDIKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgMiwgNjU1MzUsIDApLAogICAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKCh0aGlzW2VdID0gdCA+Pj4gOCksICh0aGlzW2UgKyAxXSA9IDI1NSAmIHQpKSA6IHgodGhpcywgdCwgZSwgITEpLAogICAgICAgICAgICAgICAgZSArIDIKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgNCwgNDI5NDk2NzI5NSwgMCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgICAgPyAoKHRoaXNbZSArIDNdID0gdCA+Pj4gMjQpLCAodGhpc1tlICsgMl0gPSB0ID4+PiAxNiksICh0aGlzW2UgKyAxXSA9IHQgPj4+IDgpLCAodGhpc1tlXSA9IDI1NSAmIHQpKQogICAgICAgICAgICAgICAgICA6IEkodGhpcywgdCwgZSwgITApLAogICAgICAgICAgICAgICAgZSArIDQKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgNCwgNDI5NDk2NzI5NSwgMCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgICAgPyAoKHRoaXNbZV0gPSB0ID4+PiAyNCksICh0aGlzW2UgKyAxXSA9IHQgPj4+IDE2KSwgKHRoaXNbZSArIDJdID0gdCA+Pj4gOCksICh0aGlzW2UgKyAzXSA9IDI1NSAmIHQpKQogICAgICAgICAgICAgICAgICA6IEkodGhpcywgdCwgZSwgITEpLAogICAgICAgICAgICAgICAgZSArIDQKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgICAgaWYgKCgodCA9ICt0KSwgKGUgfD0gMCksICFuKSkgewogICAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLnBvdygyLCA4ICogciAtIDEpOwogICAgICAgICAgICAgICAgTSh0aGlzLCB0LCBlLCByLCBpIC0gMSwgLWkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgbyA9IDAsCiAgICAgICAgICAgICAgICBzID0gMSwKICAgICAgICAgICAgICAgIHUgPSAwOwogICAgICAgICAgICAgIGZvciAodGhpc1tlXSA9IDI1NSAmIHQ7ICsrbyA8IHIgJiYgKHMgKj0gMjU2KTsgKQogICAgICAgICAgICAgICAgdCA8IDAgJiYgMCA9PT0gdSAmJiAwICE9PSB0aGlzW2UgKyBvIC0gMV0gJiYgKHUgPSAxKSwgKHRoaXNbZSArIG9dID0gKCgodCAvIHMpID4+IDApIC0gdSkgJiAyNTUpOwogICAgICAgICAgICAgIHJldHVybiBlICsgcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikgewogICAgICAgICAgICAgIGlmICgoKHQgPSArdCksIChlIHw9IDApLCAhbikpIHsKICAgICAgICAgICAgICAgIHZhciBpID0gTWF0aC5wb3coMiwgOCAqIHIgLSAxKTsKICAgICAgICAgICAgICAgIE0odGhpcywgdCwgZSwgciwgaSAtIDEsIC1pKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIG8gPSByIC0gMSwKICAgICAgICAgICAgICAgIHMgPSAxLAogICAgICAgICAgICAgICAgdSA9IDA7CiAgICAgICAgICAgICAgZm9yICh0aGlzW2UgKyBvXSA9IDI1NSAmIHQ7IC0tbyA+PSAwICYmIChzICo9IDI1Nik7ICkKICAgICAgICAgICAgICAgIHQgPCAwICYmIDAgPT09IHUgJiYgMCAhPT0gdGhpc1tlICsgbyArIDFdICYmICh1ID0gMSksICh0aGlzW2UgKyBvXSA9ICgoKHQgLyBzKSA+PiAwKSAtIHUpICYgMjU1KTsKICAgICAgICAgICAgICByZXR1cm4gZSArIHIKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAodCA9ICt0KSwKICAgICAgICAgICAgICAgIChlIHw9IDApLAogICAgICAgICAgICAgICAgciB8fCBNKHRoaXMsIHQsIGUsIDEsIDEyNywgLTEyOCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgfHwgKHQgPSBNYXRoLmZsb29yKHQpKSwKICAgICAgICAgICAgICAgIHQgPCAwICYmICh0ID0gMjU1ICsgdCArIDEpLAogICAgICAgICAgICAgICAgKHRoaXNbZV0gPSAyNTUgJiB0KSwKICAgICAgICAgICAgICAgIGUgKyAxCiAgICAgICAgICAgICAgKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgMiwgMzI3NjcsIC0zMjc2OCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAoKHRoaXNbZV0gPSAyNTUgJiB0KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gOCkpIDogeCh0aGlzLCB0LCBlLCAhMCksCiAgICAgICAgICAgICAgICBlICsgMgogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAodCA9ICt0KSwKICAgICAgICAgICAgICAgIChlIHw9IDApLAogICAgICAgICAgICAgICAgciB8fCBNKHRoaXMsIHQsIGUsIDIsIDMyNzY3LCAtMzI3NjgpLAogICAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKCh0aGlzW2VdID0gdCA+Pj4gOCksICh0aGlzW2UgKyAxXSA9IDI1NSAmIHQpKSA6IHgodGhpcywgdCwgZSwgITEpLAogICAgICAgICAgICAgICAgZSArIDIKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgICAgPyAoKHRoaXNbZV0gPSAyNTUgJiB0KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gOCksICh0aGlzW2UgKyAyXSA9IHQgPj4+IDE2KSwgKHRoaXNbZSArIDNdID0gdCA+Pj4gMjQpKQogICAgICAgICAgICAgICAgICA6IEkodGhpcywgdCwgZSwgITApLAogICAgICAgICAgICAgICAgZSArIDQKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksCiAgICAgICAgICAgICAgICB0IDwgMCAmJiAodCA9IDQyOTQ5NjcyOTUgKyB0ICsgMSksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgICAgPyAoKHRoaXNbZV0gPSB0ID4+PiAyNCksICh0aGlzW2UgKyAxXSA9IHQgPj4+IDE2KSwgKHRoaXNbZSArIDJdID0gdCA+Pj4gOCksICh0aGlzW2UgKyAzXSA9IDI1NSAmIHQpKQogICAgICAgICAgICAgICAgICA6IEkodGhpcywgdCwgZSwgITEpLAogICAgICAgICAgICAgICAgZSArIDQKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gWSh0aGlzLCB0LCBlLCAhMCwgcikKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiBZKHRoaXMsIHQsIGUsICExLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiBMKHRoaXMsIHQsIGUsICEwLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiBMKHRoaXMsIHQsIGUsICExLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodCwgZSwgciwgbikgewogICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgIChyIHx8IChyID0gMCksCiAgICAgICAgICAgICAgICBuIHx8IDAgPT09IG4gfHwgKG4gPSB0aGlzLmxlbmd0aCksCiAgICAgICAgICAgICAgICBlID49IHQubGVuZ3RoICYmIChlID0gdC5sZW5ndGgpLAogICAgICAgICAgICAgICAgZSB8fCAoZSA9IDApLAogICAgICAgICAgICAgICAgbiA+IDAgJiYgbiA8IHIgJiYgKG4gPSByKSwKICAgICAgICAgICAgICAgIG4gPT09IHIpCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgcmV0dXJuIDAKICAgICAgICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGggfHwgMCA9PT0gdGhpcy5sZW5ndGgpIHJldHVybiAwCiAgICAgICAgICAgICAgaWYgKGUgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpCiAgICAgICAgICAgICAgaWYgKHIgPCAwIHx8IHIgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJykKICAgICAgICAgICAgICBpZiAobiA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpCiAgICAgICAgICAgICAgbiA+IHRoaXMubGVuZ3RoICYmIChuID0gdGhpcy5sZW5ndGgpLCB0Lmxlbmd0aCAtIGUgPCBuIC0gciAmJiAobiA9IHQubGVuZ3RoIC0gZSArIHIpOwogICAgICAgICAgICAgIHZhciBpLAogICAgICAgICAgICAgICAgbyA9IG4gLSByOwogICAgICAgICAgICAgIGlmICh0aGlzID09PSB0ICYmIHIgPCBlICYmIGUgPCBuKSBmb3IgKGkgPSBvIC0gMTsgaSA+PSAwOyAtLWkpIHRbaSArIGVdID0gdGhpc1tpICsgcl07CiAgICAgICAgICAgICAgZWxzZSBpZiAobyA8IDFlMyB8fCAhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKSBmb3IgKGkgPSAwOyBpIDwgbzsgKytpKSB0W2kgKyBlXSA9IHRoaXNbaSArIHJdOwogICAgICAgICAgICAgIGVsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodCwgdGhpcy5zdWJhcnJheShyLCByICsgbyksIGUpOwogICAgICAgICAgICAgIHJldHVybiBvCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0KSB7CiAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICgnc3RyaW5nJyA9PSB0eXBlb2YgZQogICAgICAgICAgICAgICAgICAgID8gKChuID0gZSksIChlID0gMCksIChyID0gdGhpcy5sZW5ndGgpKQogICAgICAgICAgICAgICAgICAgIDogJ3N0cmluZycgPT0gdHlwZW9mIHIgJiYgKChuID0gciksIChyID0gdGhpcy5sZW5ndGgpKSwKICAgICAgICAgICAgICAgICAgMSA9PT0gdC5sZW5ndGgpCiAgICAgICAgICAgICAgICApIHsKICAgICAgICAgICAgICAgICAgdmFyIGkgPSB0LmNoYXJDb2RlQXQoMCk7CiAgICAgICAgICAgICAgICAgIGkgPCAyNTYgJiYgKHQgPSBpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IG4gJiYgJ3N0cmluZycgIT0gdHlwZW9mIG4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKQogICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBuICYmICFhLmlzRW5jb2RpbmcobikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBuKQogICAgICAgICAgICAgIH0gZWxzZSAnbnVtYmVyJyA9PSB0eXBlb2YgdCAmJiAodCAmPSAyNTUpOwogICAgICAgICAgICAgIGlmIChlIDwgMCB8fCB0aGlzLmxlbmd0aCA8IGUgfHwgdGhpcy5sZW5ndGggPCByKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JykKICAgICAgICAgICAgICBpZiAociA8PSBlKSByZXR1cm4gdGhpcwogICAgICAgICAgICAgIHZhciBvOwogICAgICAgICAgICAgIGlmICgoKGUgPj4+PSAwKSwgKHIgPSB2b2lkIDAgPT09IHIgPyB0aGlzLmxlbmd0aCA6IHIgPj4+IDApLCB0IHx8ICh0ID0gMCksICdudW1iZXInID09IHR5cGVvZiB0KSkKICAgICAgICAgICAgICAgIGZvciAobyA9IGU7IG8gPCByOyArK28pIHRoaXNbb10gPSB0OwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdmFyIHMgPSBhLmlzQnVmZmVyKHQpID8gdCA6IGsobmV3IGEodCwgbikudG9TdHJpbmcoKSksCiAgICAgICAgICAgICAgICAgIHUgPSBzLmxlbmd0aDsKICAgICAgICAgICAgICAgIGZvciAobyA9IDA7IG8gPCByIC0gZTsgKytvKSB0aGlzW28gKyBlXSA9IHNbbyAlIHVdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gdGhpcwogICAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBEID0gL1teK1wvMC05QS1aYS16LV9dL2c7CiAgICAgICAgICBmdW5jdGlvbiBOKHQpIHsKICAgICAgICAgICAgcmV0dXJuIHQgPCAxNiA/ICcwJyArIHQudG9TdHJpbmcoMTYpIDogdC50b1N0cmluZygxNikKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGsodCwgZSkgewogICAgICAgICAgICB2YXIgcjsKICAgICAgICAgICAgZSA9IGUgfHwgMSAvIDA7CiAgICAgICAgICAgIGZvciAodmFyIG4gPSB0Lmxlbmd0aCwgaSA9IG51bGwsIG8gPSBbXSwgcyA9IDA7IHMgPCBuOyArK3MpIHsKICAgICAgICAgICAgICBpZiAoKHIgPSB0LmNoYXJDb2RlQXQocykpID4gNTUyOTUgJiYgciA8IDU3MzQ0KSB7CiAgICAgICAgICAgICAgICBpZiAoIWkpIHsKICAgICAgICAgICAgICAgICAgaWYgKHIgPiA1NjMxOSkgewogIChlIC09IDMpID4gLTEgJiYgby5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHMgKyAxID09PSBuKSB7CiAgKGUgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpID0gcjsKICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChyIDwgNTYzMjApIHsKICAoZSAtPSAzKSA+IC0xICYmIG8ucHVzaCgyMzksIDE5MSwgMTg5KSwgKGkgPSByKTsKICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHIgPSA2NTUzNiArICgoKGkgLSA1NTI5NikgPDwgMTApIHwgKHIgLSA1NjMyMCkpOwogICAgICAgICAgICAgIH0gZWxzZSBpICYmIChlIC09IDMpID4gLTEgJiYgby5wdXNoKDIzOSwgMTkxLCAxODkpOwogICAgICAgICAgICAgIGlmICgoKGkgPSBudWxsKSwgciA8IDEyOCkpIHsKICAgICAgICAgICAgICAgIGlmICgoZSAtPSAxKSA8IDApIGJyZWFrCiAgICAgICAgICAgICAgICBvLnB1c2gocik7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyIDwgMjA0OCkgewogICAgICAgICAgICAgICAgaWYgKChlIC09IDIpIDwgMCkgYnJlYWsKICAgICAgICAgICAgICAgIG8ucHVzaCgociA+PiA2KSB8IDE5MiwgKDYzICYgcikgfCAxMjgpOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAociA8IDY1NTM2KSB7CiAgICAgICAgICAgICAgICBpZiAoKGUgLT0gMykgPCAwKSBicmVhawogICAgICAgICAgICAgICAgby5wdXNoKChyID4+IDEyKSB8IDIyNCwgKChyID4+IDYpICYgNjMpIHwgMTI4LCAoNjMgJiByKSB8IDEyOCk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICghKHIgPCAxMTE0MTEyKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKQogICAgICAgICAgICAgICAgaWYgKChlIC09IDQpIDwgMCkgYnJlYWsKICAgICAgICAgICAgICAgIG8ucHVzaCgociA+PiAxOCkgfCAyNDAsICgociA+PiAxMikgJiA2MykgfCAxMjgsICgociA+PiA2KSAmIDYzKSB8IDEyOCwgKDYzICYgcikgfCAxMjgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gaih0KSB7CiAgICAgICAgICAgIHJldHVybiBuLnRvQnl0ZUFycmF5KAogICAgICAgICAgICAgIChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgICAodCA9IChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRyaW0gPyB0LnRyaW0oKSA6IHQucmVwbGFjZSgvXlxzK3xccyskL2csICcnKQogICAgICAgICAgICAgICAgICB9KSh0KS5yZXBsYWNlKEQsICcnKSkubGVuZ3RoIDwgMgogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICByZXR1cm4gJycKICAgICAgICAgICAgICAgIGZvciAoOyB0Lmxlbmd0aCAlIDQgIT0gMDsgKSB0ICs9ICc9JzsKICAgICAgICAgICAgICAgIHJldHVybiB0CiAgICAgICAgICAgICAgfSkodCkKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24geih0LCBlLCByLCBuKSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAmJiAhKGkgKyByID49IGUubGVuZ3RoIHx8IGkgPj0gdC5sZW5ndGgpOyArK2kpIGVbaSArIHJdID0gdFtpXTsKICAgICAgICAgICAgcmV0dXJuIGkKICAgICAgICAgIH0KICAgICAgICB9LmNhbGwodGhpcywgcig4KSkpOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgIHZhciByOwogICAgICAgIHIgPSAoZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIHRoaXMKICAgICAgICB9KSgpOwogICAgICAgIHRyeSB7CiAgICAgICAgICByID0gciB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpIHx8ICgwLCBldmFsKSgndGhpcycpOwogICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICdvYmplY3QnID09IHR5cGVvZiB3aW5kb3cgJiYgKHIgPSB3aW5kb3cpOwogICAgICAgIH0KICAgICAgICB0LmV4cG9ydHMgPSByOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSwgcikgewogIChlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgdmFyIGUgPSBmKHQpLAogICAgICAgICAgICByID0gZVswXSwKICAgICAgICAgICAgbiA9IGVbMV07CiAgICAgICAgICByZXR1cm4gKDMgKiAociArIG4pKSAvIDQgLSBuCiAgICAgICAgfSksCiAgICAgICAgICAoZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgdmFyIGUsCiAgICAgICAgICAgICAgICByID0gZih0KSwKICAgICAgICAgICAgICAgIG4gPSByWzBdLAogICAgICAgICAgICAgICAgcyA9IHJbMV0sCiAgICAgICAgICAgICAgICB1ID0gbmV3IG8oCiAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgICAgICAgIHJldHVybiAoMyAqIChlICsgcikpIC8gNCAtIHIKICAgICAgICAgICAgICAgICAgfSkoMCwgbiwgcykKICAgICAgICAgICAgICAgICksCiAgICAgICAgICAgICAgICBhID0gMCwKICAgICAgICAgICAgICAgIGggPSBzID4gMCA/IG4gLSA0IDogbiwKICAgICAgICAgICAgICAgIGwgPSAwOwogICAgICAgICAgICAgIGwgPCBoOwogICAgICAgICAgICAgIGwgKz0gNAogICAgICAgICAgICApCiAgICAgICAgICAgICAgKGUgPQogICAgICAgICAgICAgICAgKGlbdC5jaGFyQ29kZUF0KGwpXSA8PCAxOCkgfAogICAgICAgICAgICAgICAgKGlbdC5jaGFyQ29kZUF0KGwgKyAxKV0gPDwgMTIpIHwKICAgICAgICAgICAgICAgIChpW3QuY2hhckNvZGVBdChsICsgMildIDw8IDYpIHwKICAgICAgICAgICAgICAgIGlbdC5jaGFyQ29kZUF0KGwgKyAzKV0pLAogICAgICAgICAgICAgICAgKHVbYSsrXSA9IChlID4+IDE2KSAmIDI1NSksCiAgICAgICAgICAgICAgICAodVthKytdID0gKGUgPj4gOCkgJiAyNTUpLAogICAgICAgICAgICAgICAgKHVbYSsrXSA9IDI1NSAmIGUpOwogICAgICAgICAgICAyID09PSBzICYmICgoZSA9IChpW3QuY2hhckNvZGVBdChsKV0gPDwgMikgfCAoaVt0LmNoYXJDb2RlQXQobCArIDEpXSA+PiA0KSksICh1W2ErK10gPSAyNTUgJiBlKSk7CiAgICAgICAgICAgIDEgPT09IHMgJiYKICAgICAgICAgICAgICAoKGUgPSAoaVt0LmNoYXJDb2RlQXQobCldIDw8IDEwKSB8IChpW3QuY2hhckNvZGVBdChsICsgMSldIDw8IDQpIHwgKGlbdC5jaGFyQ29kZUF0KGwgKyAyKV0gPj4gMikpLAogICAgICAgICAgICAgICh1W2ErK10gPSAoZSA+PiA4KSAmIDI1NSksCiAgICAgICAgICAgICAgKHVbYSsrXSA9IDI1NSAmIGUpKTsKICAgICAgICAgICAgcmV0dXJuIHUKICAgICAgICAgIH0pLAogICAgICAgICAgKGUuZnJvbUJ5dGVBcnJheSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIGZvciAodmFyIGUsIHIgPSB0Lmxlbmd0aCwgaSA9IHIgJSAzLCBvID0gW10sIHMgPSAwLCB1ID0gciAtIGk7IHMgPCB1OyBzICs9IDE2MzgzKQogICAgICAgICAgICAgIG8ucHVzaChsKHQsIHMsIHMgKyAxNjM4MyA+IHUgPyB1IDogcyArIDE2MzgzKSk7CiAgICAgICAgICAgIDEgPT09IGkKICAgICAgICAgICAgICA/ICgoZSA9IHRbciAtIDFdKSwgby5wdXNoKG5bZSA+PiAyXSArIG5bKGUgPDwgNCkgJiA2M10gKyAnPT0nKSkKICAgICAgICAgICAgICA6IDIgPT09IGkgJiYKICAgICAgICAgICAgICAgICgoZSA9ICh0W3IgLSAyXSA8PCA4KSArIHRbciAtIDFdKSwgby5wdXNoKG5bZSA+PiAxMF0gKyBuWyhlID4+IDQpICYgNjNdICsgblsoZSA8PCAyKSAmIDYzXSArICc9JykpOwogICAgICAgICAgICByZXR1cm4gby5qb2luKCcnKQogICAgICAgICAgfSk7CiAgICAgICAgZm9yICgKICAgICAgICAgIHZhciBuID0gW10sCiAgICAgICAgICAgIGkgPSBbXSwKICAgICAgICAgICAgbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBVaW50OEFycmF5ID8gVWludDhBcnJheSA6IEFycmF5LAogICAgICAgICAgICBzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLAogICAgICAgICAgICB1ID0gMCwKICAgICAgICAgICAgYSA9IHMubGVuZ3RoOwogICAgICAgICAgdSA8IGE7CiAgICAgICAgICArK3UKICAgICAgICApCiAgICAgICAgICAoblt1XSA9IHNbdV0pLCAoaVtzLmNoYXJDb2RlQXQodSldID0gdSk7CiAgICAgICAgZnVuY3Rpb24gZih0KSB7CiAgICAgICAgICB2YXIgZSA9IHQubGVuZ3RoOwogICAgICAgICAgaWYgKGUgJSA0ID4gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JykKICAgICAgICAgIHZhciByID0gdC5pbmRleE9mKCc9Jyk7CiAgICAgICAgICByZXR1cm4gLTEgPT09IHIgJiYgKHIgPSBlKSwgW3IsIHIgPT09IGUgPyAwIDogNCAtIChyICUgNCldCiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGgodCkgewogICAgICAgICAgcmV0dXJuIG5bKHQgPj4gMTgpICYgNjNdICsgblsodCA+PiAxMikgJiA2M10gKyBuWyh0ID4+IDYpICYgNjNdICsgbls2MyAmIHRdCiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGwodCwgZSwgcikgewogICAgICAgICAgZm9yICh2YXIgbiwgaSA9IFtdLCBvID0gZTsgbyA8IHI7IG8gKz0gMykKICAgICAgICAgICAgKG4gPSAoKHRbb10gPDwgMTYpICYgMTY3MTE2ODApICsgKCh0W28gKyAxXSA8PCA4KSAmIDY1MjgwKSArICgyNTUgJiB0W28gKyAyXSkpLCBpLnB1c2goaChuKSk7CiAgICAgICAgICByZXR1cm4gaS5qb2luKCcnKQogICAgICAgIH0KICAoaVsnLScuY2hhckNvZGVBdCgwKV0gPSA2MiksIChpWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAoZS5yZWFkID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHsKICAgICAgICAgIHZhciBvLAogICAgICAgICAgICBzLAogICAgICAgICAgICB1ID0gOCAqIGkgLSBuIC0gMSwKICAgICAgICAgICAgYSA9ICgxIDw8IHUpIC0gMSwKICAgICAgICAgICAgZiA9IGEgPj4gMSwKICAgICAgICAgICAgaCA9IC03LAogICAgICAgICAgICBsID0gciA/IGkgLSAxIDogMCwKICAgICAgICAgICAgYyA9IHIgPyAtMSA6IDEsCiAgICAgICAgICAgIHAgPSB0W2UgKyBsXTsKICAgICAgICAgIGZvciAobCArPSBjLCBvID0gcCAmICgoMSA8PCAtaCkgLSAxKSwgcCA+Pj0gLWgsIGggKz0gdTsgaCA+IDA7IG8gPSAyNTYgKiBvICsgdFtlICsgbF0sIGwgKz0gYywgaCAtPSA4KTsKICAgICAgICAgIGZvciAocyA9IG8gJiAoKDEgPDwgLWgpIC0gMSksIG8gPj49IC1oLCBoICs9IG47IGggPiAwOyBzID0gMjU2ICogcyArIHRbZSArIGxdLCBsICs9IGMsIGggLT0gOCk7CiAgICAgICAgICBpZiAoMCA9PT0gbykgbyA9IDEgLSBmOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIChvID09PSBhKSByZXR1cm4gcyA/IE5hTiA6ICgxIC8gMCkgKiAocCA/IC0xIDogMSkKICAgICAgICAgICAgOyhzICs9IE1hdGgucG93KDIsIG4pKSwgKG8gLT0gZik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gKHAgPyAtMSA6IDEpICogcyAqIE1hdGgucG93KDIsIG8gLSBuKQogICAgICAgIH0pLAogICAgICAgICAgKGUud3JpdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgbykgewogICAgICAgICAgICB2YXIgcywKICAgICAgICAgICAgICB1LAogICAgICAgICAgICAgIGEsCiAgICAgICAgICAgICAgZiA9IDggKiBvIC0gaSAtIDEsCiAgICAgICAgICAgICAgaCA9ICgxIDw8IGYpIC0gMSwKICAgICAgICAgICAgICBsID0gaCA+PiAxLAogICAgICAgICAgICAgIGMgPSAyMyA9PT0gaSA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCwKICAgICAgICAgICAgICBwID0gbiA/IDAgOiBvIC0gMSwKICAgICAgICAgICAgICBnID0gbiA/IDEgOiAtMSwKICAgICAgICAgICAgICBkID0gZSA8IDAgfHwgKDAgPT09IGUgJiYgMSAvIGUgPCAwKSA/IDEgOiAwOwogICAgICAgICAgICBmb3IgKAogICAgICAgICAgICAgIGUgPSBNYXRoLmFicyhlKSwKICAgICAgICAgICAgICAgIGlzTmFOKGUpIHx8IGUgPT09IDEgLyAwCiAgICAgICAgICAgICAgICAgID8gKCh1ID0gaXNOYU4oZSkgPyAxIDogMCksIChzID0gaCkpCiAgICAgICAgICAgICAgICAgIDogKChzID0gTWF0aC5mbG9vcihNYXRoLmxvZyhlKSAvIE1hdGguTE4yKSksCiAgICAgICAgICAgICAgICAgICAgZSAqIChhID0gTWF0aC5wb3coMiwgLXMpKSA8IDEgJiYgKHMtLSwgKGEgKj0gMikpLAogICAgICAgICAgICAgICAgICAgIChlICs9IHMgKyBsID49IDEgPyBjIC8gYSA6IGMgKiBNYXRoLnBvdygyLCAxIC0gbCkpICogYSA+PSAyICYmIChzKyssIChhIC89IDIpKSwKICAgICAgICAgICAgICAgICAgICBzICsgbCA+PSBoCiAgICAgICAgICAgICAgICAgICAgICA/ICgodSA9IDApLCAocyA9IGgpKQogICAgICAgICAgICAgICAgICAgICAgOiBzICsgbCA+PSAxCiAgICAgICAgICAgICAgICAgICAgICA/ICgodSA9IChlICogYSAtIDEpICogTWF0aC5wb3coMiwgaSkpLCAocyArPSBsKSkKICAgICAgICAgICAgICAgICAgICAgIDogKCh1ID0gZSAqIE1hdGgucG93KDIsIGwgLSAxKSAqIE1hdGgucG93KDIsIGkpKSwgKHMgPSAwKSkpOwogICAgICAgICAgICAgIGkgPj0gODsKICAgICAgICAgICAgICB0W3IgKyBwXSA9IDI1NSAmIHUsIHAgKz0gZywgdSAvPSAyNTYsIGkgLT0gOAogICAgICAgICAgICApOwogICAgICAgICAgICBmb3IgKHMgPSAocyA8PCBpKSB8IHUsIGYgKz0gaTsgZiA+IDA7IHRbciArIHBdID0gMjU1ICYgcywgcCArPSBnLCBzIC89IDI1NiwgZiAtPSA4KTsKICAgICAgICAgICAgdFtyICsgcCAtIGddIHw9IDEyOCAqIGQ7CiAgICAgICAgICB9KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICB2YXIgciA9IHt9LnRvU3RyaW5nOwogICAgICAgIHQuZXhwb3J0cyA9CiAgICAgICAgICBBcnJheS5pc0FycmF5IHx8CiAgICAgICAgICBmdW5jdGlvbiAodCkgewogICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgQXJyYXldJyA9PSByLmNhbGwodCkKICAgICAgICAgIH07CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIChlLCByKSB7CiAgICAgICAgZS5leHBvcnRzID0gdDsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIGZ1bmN0aW9uIHIodCwgZSkgewogICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IHQubGVuZ3RoIC0gMTsgbiA+PSAwOyBuLS0pIHsKICAgICAgICAgICAgICB2YXIgaSA9IHRbbl07CiAgICAgICAgICAgICAgJy4nID09PSBpID8gdC5zcGxpY2UobiwgMSkgOiAnLi4nID09PSBpID8gKHQuc3BsaWNlKG4sIDEpLCByKyspIDogciAmJiAodC5zcGxpY2UobiwgMSksIHItLSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGUpIGZvciAoOyByLS07IHIpIHQudW5zaGlmdCgnLi4nKTsKICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgIH0KICAgICAgICAgIHZhciBuID0gL14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvLAogICAgICAgICAgICBpID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gbi5leGVjKHQpLnNsaWNlKDEpCiAgICAgICAgICAgIH07CiAgICAgICAgICBmdW5jdGlvbiBvKHQsIGUpIHsKICAgICAgICAgICAgaWYgKHQuZmlsdGVyKSByZXR1cm4gdC5maWx0ZXIoZSkKICAgICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIGUodFtuXSwgbiwgdCkgJiYgci5wdXNoKHRbbl0pOwogICAgICAgICAgICByZXR1cm4gcgogICAgICAgICAgfQogIChlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGZvciAodmFyIGUgPSAnJywgbiA9ICExLCBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIW47IGktLSkgewogICAgICAgICAgICAgIHZhciBzID0gaSA+PSAwID8gYXJndW1lbnRzW2ldIDogdC5jd2QoKTsKICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHMpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJykKICAgICAgICAgICAgICBzICYmICgoZSA9IHMgKyAnLycgKyBlKSwgKG4gPSAnLycgPT09IHMuY2hhckF0KDApKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAoZSA9IHIoCiAgICAgICAgICAgICAgICBvKGUuc3BsaXQoJy8nKSwgZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdAogICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICAhbgogICAgICAgICAgICAgICkuam9pbignLycpKSwKICAgICAgICAgICAgICAobiA/ICcvJyA6ICcnKSArIGUgfHwgJy4nCiAgICAgICAgICAgICkKICAgICAgICAgIH0pLAogICAgICAgICAgICAoZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHZhciBuID0gZS5pc0Fic29sdXRlKHQpLAogICAgICAgICAgICAgICAgaSA9ICcvJyA9PT0gcyh0LCAtMSk7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gcigKICAgICAgICAgICAgICAgICAgbyh0LnNwbGl0KCcvJyksIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdAogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgIW4KICAgICAgICAgICAgICAgICkuam9pbignLycpKSB8fAogICAgICAgICAgICAgICAgICBuIHx8CiAgICAgICAgICAgICAgICAgICh0ID0gJy4nKSwKICAgICAgICAgICAgICAgIHQgJiYgaSAmJiAodCArPSAnLycpLAogICAgICAgICAgICAgICAgKG4gPyAnLycgOiAnJykgKyB0CiAgICAgICAgICAgICAgKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGUuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuICcvJyA9PT0gdC5jaGFyQXQoMCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLmpvaW4gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOwogICAgICAgICAgICAgIHJldHVybiBlLm5vcm1hbGl6ZSgKICAgICAgICAgICAgICAgIG8odCwgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpCiAgICAgICAgICAgICAgICAgIHJldHVybiB0CiAgICAgICAgICAgICAgICB9KS5qb2luKCcvJykKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoZS5yZWxhdGl2ZSA9IGZ1bmN0aW9uICh0LCByKSB7CiAgICAgICAgICAgICAgZnVuY3Rpb24gbih0KSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoICYmICcnID09PSB0W2VdOyBlKyspOwogICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHQubGVuZ3RoIC0gMTsgciA+PSAwICYmICcnID09PSB0W3JdOyByLS0pOwogICAgICAgICAgICAgICAgcmV0dXJuIGUgPiByID8gW10gOiB0LnNsaWNlKGUsIHIgLSBlICsgMSkKICAgICAgICAgICAgICB9CiAgKHQgPSBlLnJlc29sdmUodCkuc3Vic3RyKDEpKSwgKHIgPSBlLnJlc29sdmUocikuc3Vic3RyKDEpKTsKICAgICAgICAgICAgICBmb3IgKAogICAgICAgICAgICAgICAgdmFyIGkgPSBuKHQuc3BsaXQoJy8nKSksIG8gPSBuKHIuc3BsaXQoJy8nKSksIHMgPSBNYXRoLm1pbihpLmxlbmd0aCwgby5sZW5ndGgpLCB1ID0gcywgYSA9IDA7CiAgICAgICAgICAgICAgICBhIDwgczsKICAgICAgICAgICAgICAgIGErKwogICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIGlmIChpW2FdICE9PSBvW2FdKSB7CiAgICAgICAgICAgICAgICAgIHUgPSBhOwogICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBmID0gW107CiAgICAgICAgICAgICAgZm9yIChhID0gdTsgYSA8IGkubGVuZ3RoOyBhKyspIGYucHVzaCgnLi4nKTsKICAgICAgICAgICAgICByZXR1cm4gKGYgPSBmLmNvbmNhdChvLnNsaWNlKHUpKSkuam9pbignLycpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoZS5zZXAgPSAnLycpLAogICAgICAgICAgICAoZS5kZWxpbWl0ZXIgPSAnOicpLAogICAgICAgICAgICAoZS5kaXJuYW1lID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICB2YXIgZSA9IGkodCksCiAgICAgICAgICAgICAgICByID0gZVswXSwKICAgICAgICAgICAgICAgIG4gPSBlWzFdOwogICAgICAgICAgICAgIHJldHVybiByIHx8IG4gPyAobiAmJiAobiA9IG4uc3Vic3RyKDAsIG4ubGVuZ3RoIC0gMSkpLCByICsgbikgOiAnLicKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLmJhc2VuYW1lID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICB2YXIgciA9IGkodClbMl07CiAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgci5zdWJzdHIoLTEgKiBlLmxlbmd0aCkgPT09IGUgJiYgKHIgPSByLnN1YnN0cigwLCByLmxlbmd0aCAtIGUubGVuZ3RoKSksIHIKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLmV4dG5hbWUgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiBpKHQpWzNdCiAgICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIHMgPQogICAgICAgICAgICAnYicgPT09ICdhYicuc3Vic3RyKC0xKQogICAgICAgICAgICAgID8gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuc3Vic3RyKGUsIHIpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgOiBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gZSA8IDAgJiYgKGUgPSB0Lmxlbmd0aCArIGUpLCB0LnN1YnN0cihlLCByKQogICAgICAgICAgICAgICAgfTsKICAgICAgICB9LmNhbGwodGhpcywgcigxNCkpKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICB2YXIgciwKICAgICAgICAgIG4sCiAgICAgICAgICBpID0gKHQuZXhwb3J0cyA9IHt9KTsKICAgICAgICBmdW5jdGlvbiBvKCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJykKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcygpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJykKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdSh0KSB7CiAgICAgICAgICBpZiAociA9PT0gc2V0VGltZW91dCkgcmV0dXJuIHNldFRpbWVvdXQodCwgMCkKICAgICAgICAgIGlmICgociA9PT0gbyB8fCAhcikgJiYgc2V0VGltZW91dCkgcmV0dXJuIChyID0gc2V0VGltZW91dCksIHNldFRpbWVvdXQodCwgMCkKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiByKHQsIDApCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcmV0dXJuIHIuY2FsbChudWxsLCB0LCAwKQogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHIuY2FsbCh0aGlzLCB0LCAwKQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICEoZnVuY3Rpb24gKCkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgciA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogbzsKICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgciA9IG87CiAgICAgICAgICB9CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBuID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogczsKICAgICAgICAgIH0gY2F0Y2ggKHQpIHsKICAgICAgICAgICAgbiA9IHM7CiAgICAgICAgICB9CiAgICAgICAgfSkoKTsKICAgICAgICB2YXIgYSwKICAgICAgICAgIGYgPSBbXSwKICAgICAgICAgIGggPSAhMSwKICAgICAgICAgIGwgPSAtMTsKICAgICAgICBmdW5jdGlvbiBjKCkgewogICAgICAgICAgaCAmJiBhICYmICgoaCA9ICExKSwgYS5sZW5ndGggPyAoZiA9IGEuY29uY2F0KGYpKSA6IChsID0gLTEpLCBmLmxlbmd0aCAmJiBwKCkpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBwKCkgewogICAgICAgICAgaWYgKCFoKSB7CiAgICAgICAgICAgIHZhciB0ID0gdShjKTsKICAgICAgICAgICAgaCA9ICEwOwogICAgICAgICAgICBmb3IgKHZhciBlID0gZi5sZW5ndGg7IGU7ICkgewogICAgICAgICAgICAgIGZvciAoYSA9IGYsIGYgPSBbXTsgKytsIDwgZTsgKSBhICYmIGFbbF0ucnVuKCkKICAgICAgICAgICAgICA7KGwgPSAtMSksIChlID0gZi5sZW5ndGgpOwogICAgICAgICAgICB9CiAgKGEgPSBudWxsKSwKICAgICAgICAgICAgICAoaCA9ICExKSwKICAgICAgICAgICAgICAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgIGlmIChuID09PSBjbGVhclRpbWVvdXQpIHJldHVybiBjbGVhclRpbWVvdXQodCkKICAgICAgICAgICAgICAgIGlmICgobiA9PT0gcyB8fCAhbikgJiYgY2xlYXJUaW1lb3V0KSByZXR1cm4gKG4gPSBjbGVhclRpbWVvdXQpLCBjbGVhclRpbWVvdXQodCkKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIG4odCk7CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uY2FsbChudWxsLCB0KQogICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCB0KQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSkodCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGcodCwgZSkgewogICh0aGlzLmZ1biA9IHQpLCAodGhpcy5hcnJheSA9IGUpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkKCkge30KICAoaS5uZXh0VGljayA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB2YXIgZSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7CiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSBlW3IgLSAxXSA9IGFyZ3VtZW50c1tyXTsKICAgICAgICAgIGYucHVzaChuZXcgZyh0LCBlKSksIDEgIT09IGYubGVuZ3RoIHx8IGggfHwgdShwKTsKICAgICAgICB9KSwKICAgICAgICAgIChnLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpOwogICAgICAgICAgfSksCiAgICAgICAgICAoaS50aXRsZSA9ICdicm93c2VyJyksCiAgICAgICAgICAoaS5icm93c2VyID0gITApLAogICAgICAgICAgKGkuZW52ID0ge30pLAogICAgICAgICAgKGkuYXJndiA9IFtdKSwKICAgICAgICAgIChpLnZlcnNpb24gPSAnJyksCiAgICAgICAgICAoaS52ZXJzaW9ucyA9IHt9KSwKICAgICAgICAgIChpLm9uID0gZCksCiAgICAgICAgICAoaS5hZGRMaXN0ZW5lciA9IGQpLAogICAgICAgICAgKGkub25jZSA9IGQpLAogICAgICAgICAgKGkub2ZmID0gZCksCiAgICAgICAgICAoaS5yZW1vdmVMaXN0ZW5lciA9IGQpLAogICAgICAgICAgKGkucmVtb3ZlQWxsTGlzdGVuZXJzID0gZCksCiAgICAgICAgICAoaS5lbWl0ID0gZCksCiAgICAgICAgICAoaS5wcmVwZW5kTGlzdGVuZXIgPSBkKSwKICAgICAgICAgIChpLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBkKSwKICAgICAgICAgIChpLmxpc3RlbmVycyA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgICAgfSksCiAgICAgICAgICAoaS5iaW5kaW5nID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpCiAgICAgICAgICB9KSwKICAgICAgICAgIChpLmN3ZCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuICcvJwogICAgICAgICAgfSksCiAgICAgICAgICAoaS5jaGRpciA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJykKICAgICAgICAgIH0pLAogICAgICAgICAgKGkudW1hc2sgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiAwCiAgICAgICAgICB9KTsKICAgICAgfSwKICAgIF0pCiAgfSk7CiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogIGNvbnN0IHVucGFja0JyaWRnZSA9IFdvcmtlclNjb3BlLnVucGFja0JyaWRnZTsKCiAgbGV0IHVucGFjazsKCiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tdW5wYWNrLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICB2YXIgaW5pdHVucGFjayA9IGZ1bmN0aW9uIChidWZmZXIpIHsKICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBoYXMgYmVlbiBfY2FyZWZ1bGx5XyBtb2RpZmllZCBieSBoYW5kLgogICAgLy8gRHVlIHRvIFdlYlBhY2sgZW1iZWRkaW5nIHRoaXMgc2NyaXB0IGludG8gdGhlIFplYSBlbmdpbmUKICAgIC8vIGJ1aWxkLCBjZXJ0YWluIGZlYXR1cmVzIGJyb2tlLgogICAgLy8gVGhlcmUgd2FzIGNvZGUgdG8gaGFuZGxlIGxvYWRpbmcgaW4gYSBub2RlSlMgY29udGV4dCwgdGhhdCB0cmllZCB0byBpbXBvcnQoImZzIikKICAgIC8vIFdlYlBhY2sga2VwdHMgdHJpcHBpbmcgdXAgb24gdGhhdCBjb2RlIGluIGl0cyBzdGF0aWMgYW5hbHlzaXMgb2YgdGhlIGNvZGUsIHNvCiAgICAvLyBJIGNhcmVmdWxseSByZW1vdmVkIGl0LgogICAgLy8gVGhlIGdsb2JhbCBzY29wZSBvZiB0aGUgc2NyaXB0IHNlZW1zIHRvIGJlIGRpZmZlcmVudCwgc28gdW5wYWNrQnJpZGdlIHdhcyBub3QgYXZhaWxhYmxlLgogICAgLy8gVGhlIHVucGFja0JyaWRnZSBjb2RlIGFzc2lnbnMgdW5wYWNrQnJpZGdlIHRvIHRoZSBwYXNzZWQgaW4gc2NvcGUsIHdoaWNoIGlzICd0aGlzJywgYnV0IHRoYXQKICAgIC8vIHNjb3BlIGlzbid0IGF2YWlsYWJsZSBpbnNpZGUgdGhpcyAndW5wYWNrJyBmdW5jdGlvbi4KICAgIGNvbnN0IHVucGFjayA9IE1vZHVsZTsKCiAgICAvLyBOb3RlOiB0aGUgZm9sbG93aW5nIGlzIHRoZSBVUkwgb2YgdGhlIHVucGFjay53YXNtIGZpbGUgaW4gb3VyIFplYUVuZ2luZSBwcm9qZWN0IG9uIG91cgogICAgLy8gc2VydmVyLiBJZGVhbGx5IHdlIGNvdWxkIHVzZSBhIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgWmVhRW5naW5lIGZpbGUsIGJ1dAogICAgLy8gdGhhdCBpc24ndCBwb3NzaWJsZSB5ZXQuIChUT0RPOiBBc2sgTWF1cm8gYWJvdXQgdGhpcykKICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gJ29taXQnOwoKICAgIHZhciBFeHQgPSB1bnBhY2tCcmlkZ2UuRXh0OwogICAgdmFyIGpzQVBJID0gewogICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEV4dC5jdXJyZW50Lm9wZW4uYXBwbHkoRXh0LmN1cnJlbnQsIGFyZ3VtZW50cykKICAgICAgfSwKICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQuY2xvc2UuYXBwbHkoRXh0LmN1cnJlbnQsIGFyZ3VtZW50cykKICAgICAgfSwKICAgICAgcmVhZDogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiBFeHQuY3VycmVudC5yZWFkLmFwcGx5KEV4dC5jdXJyZW50LCBhcmd1bWVudHMpCiAgICAgIH0sCiAgICAgIHdyaXRlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEV4dC5jdXJyZW50LndyaXRlLmFwcGx5KEV4dC5jdXJyZW50LCBhcmd1bWVudHMpCiAgICAgIH0sCiAgICAgIHRlbGw6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQudGVsbC5hcHBseShFeHQuY3VycmVudCwgYXJndW1lbnRzKQogICAgICB9LAogICAgICBzZWVrOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEV4dC5jdXJyZW50LnNlZWsuYXBwbHkoRXh0LmN1cnJlbnQsIGFyZ3VtZW50cykKICAgICAgfSwKICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEV4dC5jdXJyZW50LmNyZWF0ZS5hcHBseShFeHQuY3VycmVudCwgYXJndW1lbnRzKQogICAgICB9LAogICAgfTsKICAgIHZhciBtb2R1bGVPdmVycmlkZXMgPSB7fTsKICAgIHZhciBrZXk7CiAgICBmb3IgKGtleSBpbiBNb2R1bGUpIHsKICAgICAgaWYgKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgbW9kdWxlT3ZlcnJpZGVzW2tleV0gPSBNb2R1bGVba2V5XTsKICAgICAgfQogICAgfQogICAgTW9kdWxlWyd3YXNtQmluYXJ5J10gPSBidWZmZXI7CiAgICBNb2R1bGVbJ2FyZ3VtZW50cyddID0gW107CiAgICBNb2R1bGVbJ3RoaXNQcm9ncmFtJ10gPSAnLi90aGlzLnByb2dyYW0nOwogICAgTW9kdWxlWydxdWl0J10gPSBmdW5jdGlvbiAoc3RhdHVzLCB0b1Rocm93KSB7CiAgICAgIHRocm93IHRvVGhyb3cKICAgIH07CiAgICBNb2R1bGVbJ3ByZVJ1biddID0gW107CiAgICBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtdOwogICAgdmFyIEVOVklST05NRU5UX0lTX1dFQiA9IGZhbHNlOwogICAgdmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IGZhbHNlOwogICAgdmFyIEVOVklST05NRU5UX0lTX05PREUgPSBmYWxzZTsKICAgIGlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10pIHsKICAgICAgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ1dFQicpIHsKICAgICAgICBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlOwogICAgICB9IGVsc2UgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ1dPUktFUicpIHsKICAgICAgICBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0cnVlOwogICAgICB9IGVsc2UgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ05PREUnKSB7CiAgICAgICAgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnU0hFTEwnKSA7IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiTW9kdWxlWydFTlZJUk9OTUVOVCddIHZhbHVlIGlzIG5vdCB2YWxpZC4gbXVzdCBiZSBvbmUgb2Y6IFdFQnxXT1JLRVJ8Tk9ERXxTSEVMTC4iKQogICAgICB9CiAgICB9IGVsc2UgewogICAgICBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JzsKICAgICAgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbic7CiAgICAgIEVOVklST05NRU5UX0lTX05PREUgPQogICAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7CiAgICB9CiAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikgewogICAgICBNb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQodXJsKSB7CiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTsKICAgICAgICB4aHIuc2VuZChudWxsKTsKICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dAogICAgICB9OwogICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7CiAgICAgICAgTW9kdWxlWydyZWFkQmluYXJ5J10gPSBmdW5jdGlvbiByZWFkQmluYXJ5KHVybCkgewogICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpOwogICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7CiAgICAgICAgICB4aHIuc2VuZChudWxsKTsKICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpCiAgICAgICAgfTsKICAgICAgfQogICAgICBNb2R1bGVbJ3JlYWRBc3luYyddID0gZnVuY3Rpb24gcmVhZEFzeW5jKHVybCwgb25sb2FkLCBvbmVycm9yKSB7CiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpOwogICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInOwogICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiB4aHJfb25sb2FkKCkgewogICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8ICh4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSkgewogICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTsKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICB9CiAgICAgICAgICBvbmVycm9yKCk7CiAgICAgICAgfTsKICAgICAgICB4aHIub25lcnJvciA9IG9uZXJyb3I7CiAgICAgICAgeGhyLnNlbmQobnVsbCk7CiAgICAgIH07CiAgICAgIE1vZHVsZVsnc2V0V2luZG93VGl0bGUnXSA9IGZ1bmN0aW9uICh0aXRsZSkgewogICAgICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7CiAgICAgIH07CiAgICB9CiAgICBNb2R1bGVbJ3ByaW50J10gPQogICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpIDogdHlwZW9mIHByaW50ICE9PSAndW5kZWZpbmVkJyA/IHByaW50IDogbnVsbDsKICAgIE1vZHVsZVsncHJpbnRFcnInXSA9CiAgICAgIHR5cGVvZiBwcmludEVyciAhPT0gJ3VuZGVmaW5lZCcKICAgICAgICA/IHByaW50RXJyCiAgICAgICAgOiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpKSB8fCBNb2R1bGVbJ3ByaW50J107CiAgICBNb2R1bGUucHJpbnQgPSBNb2R1bGVbJ3ByaW50J107CiAgICBNb2R1bGUucHJpbnRFcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ107CiAgICBmb3IgKGtleSBpbiBtb2R1bGVPdmVycmlkZXMpIHsKICAgICAgaWYgKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgTW9kdWxlW2tleV0gPSBtb2R1bGVPdmVycmlkZXNba2V5XTsKICAgICAgfQogICAgfQogICAgbW9kdWxlT3ZlcnJpZGVzID0gdW5kZWZpbmVkOwogICAgdmFyIFNUQUNLX0FMSUdOID0gMTY7CiAgICBmdW5jdGlvbiBzdGF0aWNBbGxvYyhzaXplKSB7CiAgICAgIGFzc2VydCghc3RhdGljU2VhbGVkKTsKICAgICAgdmFyIHJldCA9IFNUQVRJQ1RPUDsKICAgICAgU1RBVElDVE9QID0gKFNUQVRJQ1RPUCArIHNpemUgKyAxNSkgJiAtMTY7CiAgICAgIHJldHVybiByZXQKICAgIH0KICAgIGZ1bmN0aW9uIGR5bmFtaWNBbGxvYyhzaXplKSB7CiAgICAgIGFzc2VydChEWU5BTUlDVE9QX1BUUik7CiAgICAgIHZhciByZXQgPSBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl07CiAgICAgIHZhciBlbmQgPSAocmV0ICsgc2l6ZSArIDE1KSAmIC0xNjsKICAgICAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdID0gZW5kOwogICAgICBpZiAoZW5kID49IFRPVEFMX01FTU9SWSkgewogICAgICAgIHZhciBzdWNjZXNzID0gZW5sYXJnZU1lbW9yeSgpOwogICAgICAgIGlmICghc3VjY2VzcykgewogICAgICAgICAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdID0gcmV0OwogICAgICAgICAgcmV0dXJuIDAKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHJldAogICAgfQogICAgZnVuY3Rpb24gYWxpZ25NZW1vcnkoc2l6ZSwgZmFjdG9yKSB7CiAgICAgIGlmICghZmFjdG9yKSBmYWN0b3IgPSBTVEFDS19BTElHTjsKICAgICAgdmFyIHJldCA9IChzaXplID0gTWF0aC5jZWlsKHNpemUgLyBmYWN0b3IpICogZmFjdG9yKTsKICAgICAgcmV0dXJuIHJldAogICAgfQogICAgZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSkgewogICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICBjYXNlICdpMSc6CiAgICAgICAgY2FzZSAnaTgnOgogICAgICAgICAgcmV0dXJuIDEKICAgICAgICBjYXNlICdpMTYnOgogICAgICAgICAgcmV0dXJuIDIKICAgICAgICBjYXNlICdpMzInOgogICAgICAgICAgcmV0dXJuIDQKICAgICAgICBjYXNlICdpNjQnOgogICAgICAgICAgcmV0dXJuIDgKICAgICAgICBjYXNlICdmbG9hdCc6CiAgICAgICAgICByZXR1cm4gNAogICAgICAgIGNhc2UgJ2RvdWJsZSc6CiAgICAgICAgICByZXR1cm4gOAogICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09ICcqJykgewogICAgICAgICAgICByZXR1cm4gNAogICAgICAgICAgfSBlbHNlIGlmICh0eXBlWzBdID09PSAnaScpIHsKICAgICAgICAgICAgdmFyIGJpdHMgPSBwYXJzZUludCh0eXBlLnN1YnN0cigxKSk7CiAgICAgICAgICAgIGFzc2VydChiaXRzICUgOCA9PT0gMCk7CiAgICAgICAgICAgIHJldHVybiBiaXRzIC8gOAogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIDAKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIG5ldyBBcnJheSgwKTsKICAgIHZhciBHTE9CQUxfQkFTRSA9IDEwMjQ7CiAgICB2YXIgQUJPUlQgPSAwOwogICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkgewogICAgICBpZiAoIWNvbmRpdGlvbikgewogICAgICAgIGFib3J0KCdBc3NlcnRpb24gZmFpbGVkOiAnICsgdGV4dCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHNldFZhbHVlKHB0ciwgdmFsdWUsIHR5cGUsIG5vU2FmZSkgewogICAgICB0eXBlID0gdHlwZSB8fCAnaTgnOwogICAgICBpZiAodHlwZS5jaGFyQXQodHlwZS5sZW5ndGggLSAxKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgJ2kxJzoKICAgICAgICAgIEhFQVA4W3B0ciA+PiAwXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdpOCc6CiAgICAgICAgICBIRUFQOFtwdHIgPj4gMF0gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAnaTE2JzoKICAgICAgICAgIEhFQVAxNltwdHIgPj4gMV0gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAnaTMyJzoKICAgICAgICAgIEhFQVAzMltwdHIgPj4gMl0gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAnaTY0JzoKICAodGVtcEk2NCA9IFsKICAgICAgICAgICAgdmFsdWUgPj4+IDAsCiAgICAgICAgICAgICgodGVtcERvdWJsZSA9IHZhbHVlKSwKICAgICAgICAgICAgK01hdGhfYWJzKHRlbXBEb3VibGUpID49IDEKICAgICAgICAgICAgICA/IHRlbXBEb3VibGUgPiAwCiAgICAgICAgICAgICAgICA/IChNYXRoX21pbigrTWF0aF9mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5NiksIDQyOTQ5NjcyOTUpIHwgMCkgPj4+IDAKICAgICAgICAgICAgICAgIDogfn4rTWF0aF9jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwCiAgICAgICAgICAgICAgOiAwKSwKICAgICAgICAgIF0pLAogICAgICAgICAgICAoSEVBUDMyW3B0ciA+PiAyXSA9IHRlbXBJNjRbMF0pLAogICAgICAgICAgICAoSEVBUDMyWyhwdHIgKyA0KSA+PiAyXSA9IHRlbXBJNjRbMV0pOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdmbG9hdCc6CiAgICAgICAgICBIRUFQRjMyW3B0ciA+PiAyXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdkb3VibGUnOgogICAgICAgICAgSEVBUEY2NFtwdHIgPj4gM10gPSB2YWx1ZTsKICAgICAgICAgIGJyZWFrCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAnICsgdHlwZSk7CiAgICAgIH0KICAgIH0KICAgIHZhciBBTExPQ19OT1JNQUwgPSAwOwogICAgdmFyIEFMTE9DX1NUQVRJQyA9IDI7CiAgICB2YXIgQUxMT0NfTk9ORSA9IDQ7CiAgICBmdW5jdGlvbiBhbGxvY2F0ZShzbGFiLCB0eXBlcywgYWxsb2NhdG9yLCBwdHIpIHsKICAgICAgdmFyIHplcm9pbml0LCBzaXplOwogICAgICBpZiAodHlwZW9mIHNsYWIgPT09ICdudW1iZXInKSB7CiAgICAgICAgemVyb2luaXQgPSB0cnVlOwogICAgICAgIHNpemUgPSBzbGFiOwogICAgICB9IGVsc2UgewogICAgICAgIHplcm9pbml0ID0gZmFsc2U7CiAgICAgICAgc2l6ZSA9IHNsYWIubGVuZ3RoOwogICAgICB9CiAgICAgIHZhciBzaW5nbGVUeXBlID0gdHlwZW9mIHR5cGVzID09PSAnc3RyaW5nJyA/IHR5cGVzIDogbnVsbDsKICAgICAgdmFyIHJldDsKICAgICAgaWYgKGFsbG9jYXRvciA9PSBBTExPQ19OT05FKSB7CiAgICAgICAgcmV0ID0gcHRyOwogICAgICB9IGVsc2UgewogICAgICAgIHJldCA9IFt0eXBlb2YgX21hbGxvYyA9PT0gJ2Z1bmN0aW9uJyA/IF9tYWxsb2MgOiBzdGF0aWNBbGxvYywgc3RhY2tBbGxvYywgc3RhdGljQWxsb2MsIGR5bmFtaWNBbGxvY11bCiAgICAgICAgICBhbGxvY2F0b3IgPT09IHVuZGVmaW5lZCA/IEFMTE9DX1NUQVRJQyA6IGFsbG9jYXRvcgogICAgICAgIF0oTWF0aC5tYXgoc2l6ZSwgc2luZ2xlVHlwZSA/IDEgOiB0eXBlcy5sZW5ndGgpKTsKICAgICAgfQogICAgICBpZiAoemVyb2luaXQpIHsKICAgICAgICB2YXIgc3RvcDsKICAgICAgICBwdHIgPSByZXQ7CiAgICAgICAgYXNzZXJ0KChyZXQgJiAzKSA9PSAwKTsKICAgICAgICBzdG9wID0gcmV0ICsgKHNpemUgJiB+Myk7CiAgICAgICAgZm9yICg7IHB0ciA8IHN0b3A7IHB0ciArPSA0KSB7CiAgICAgICAgICBIRUFQMzJbcHRyID4+IDJdID0gMDsKICAgICAgICB9CiAgICAgICAgc3RvcCA9IHJldCArIHNpemU7CiAgICAgICAgd2hpbGUgKHB0ciA8IHN0b3ApIHsKICAgICAgICAgIEhFQVA4W3B0cisrID4+IDBdID0gMDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9CiAgICAgIGlmIChzaW5nbGVUeXBlID09PSAnaTgnKSB7CiAgICAgICAgaWYgKHNsYWIuc3ViYXJyYXkgfHwgc2xhYi5zbGljZSkgewogICAgICAgICAgSEVBUFU4LnNldChzbGFiLCByZXQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHNsYWIpLCByZXQpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0KICAgICAgdmFyIGkgPSAwLAogICAgICAgIHR5cGUsCiAgICAgICAgdHlwZVNpemUsCiAgICAgICAgcHJldmlvdXNUeXBlOwogICAgICB3aGlsZSAoaSA8IHNpemUpIHsKICAgICAgICB2YXIgY3VyciA9IHNsYWJbaV07CiAgICAgICAgdHlwZSA9IHNpbmdsZVR5cGUgfHwgdHlwZXNbaV07CiAgICAgICAgaWYgKHR5cGUgPT09IDApIHsKICAgICAgICAgIGkrKzsKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQogICAgICAgIGlmICh0eXBlID09ICdpNjQnKSB0eXBlID0gJ2kzMic7CiAgICAgICAgc2V0VmFsdWUocmV0ICsgaSwgY3VyciwgdHlwZSk7CiAgICAgICAgaWYgKHByZXZpb3VzVHlwZSAhPT0gdHlwZSkgewogICAgICAgICAgdHlwZVNpemUgPSBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKTsKICAgICAgICAgIHByZXZpb3VzVHlwZSA9IHR5cGU7CiAgICAgICAgfQogICAgICAgIGkgKz0gdHlwZVNpemU7CiAgICAgIH0KICAgICAgcmV0dXJuIHJldAogICAgfQogICAgZnVuY3Rpb24gUG9pbnRlcl9zdHJpbmdpZnkocHRyLCBsZW5ndGgpIHsKICAgICAgaWYgKGxlbmd0aCA9PT0gMCB8fCAhcHRyKSByZXR1cm4gJycKICAgICAgdmFyIGhhc1V0ZiA9IDA7CiAgICAgIHZhciB0OwogICAgICB2YXIgaSA9IDA7CiAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgdCA9IEhFQVBVOFsocHRyICsgaSkgPj4gMF07CiAgICAgICAgaGFzVXRmIHw9IHQ7CiAgICAgICAgaWYgKHQgPT0gMCAmJiAhbGVuZ3RoKSBicmVhawogICAgICAgIGkrKzsKICAgICAgICBpZiAobGVuZ3RoICYmIGkgPT0gbGVuZ3RoKSBicmVhawogICAgICB9CiAgICAgIGlmICghbGVuZ3RoKSBsZW5ndGggPSBpOwogICAgICB2YXIgcmV0ID0gJyc7CiAgICAgIGlmIChoYXNVdGYgPCAxMjgpIHsKICAgICAgICB2YXIgTUFYX0NIVU5LID0gMTAyNDsKICAgICAgICB2YXIgY3VycjsKICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkgewogICAgICAgICAgY3VyciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBIRUFQVTguc3ViYXJyYXkocHRyLCBwdHIgKyBNYXRoLm1pbihsZW5ndGgsIE1BWF9DSFVOSykpKTsKICAgICAgICAgIHJldCA9IHJldCA/IHJldCArIGN1cnIgOiBjdXJyOwogICAgICAgICAgcHRyICs9IE1BWF9DSFVOSzsKICAgICAgICAgIGxlbmd0aCAtPSBNQVhfQ0hVTks7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQKICAgICAgfQogICAgICByZXR1cm4gVVRGOFRvU3RyaW5nKHB0cikKICAgIH0KICAgIHZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDsKICAgIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKHU4QXJyYXksIGlkeCkgewogICAgICB2YXIgZW5kUHRyID0gaWR4OwogICAgICB3aGlsZSAodThBcnJheVtlbmRQdHJdKSArK2VuZFB0cjsKICAgICAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIHU4QXJyYXkuc3ViYXJyYXkgJiYgVVRGOERlY29kZXIpIHsKICAgICAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKHU4QXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKQogICAgICB9IGVsc2UgewogICAgICAgIHZhciB1MCwgdTEsIHUyLCB1MywgdTQsIHU1OwogICAgICAgIHZhciBzdHIgPSAnJzsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgdTAgPSB1OEFycmF5W2lkeCsrXTsKICAgICAgICAgIGlmICghdTApIHJldHVybiBzdHIKICAgICAgICAgIGlmICghKHUwICYgMTI4KSkgewogICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICB9CiAgICAgICAgICB1MSA9IHU4QXJyYXlbaWR4KytdICYgNjM7CiAgICAgICAgICBpZiAoKHUwICYgMjI0KSA9PSAxOTIpIHsKICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCh1MCAmIDMxKSA8PCA2KSB8IHUxKTsKICAgICAgICAgICAgY29udGludWUKICAgICAgICAgIH0KICAgICAgICAgIHUyID0gdThBcnJheVtpZHgrK10gJiA2MzsKICAgICAgICAgIGlmICgodTAgJiAyNDApID09IDIyNCkgewogICAgICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB1MyA9IHU4QXJyYXlbaWR4KytdICYgNjM7CiAgICAgICAgICAgIGlmICgodTAgJiAyNDgpID09IDI0MCkgewogICAgICAgICAgICAgIHUwID0gKCh1MCAmIDcpIDw8IDE4KSB8ICh1MSA8PCAxMikgfCAodTIgPDwgNikgfCB1MzsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB1NCA9IHU4QXJyYXlbaWR4KytdICYgNjM7CiAgICAgICAgICAgICAgaWYgKCh1MCAmIDI1MikgPT0gMjQ4KSB7CiAgICAgICAgICAgICAgICB1MCA9ICgodTAgJiAzKSA8PCAyNCkgfCAodTEgPDwgMTgpIHwgKHUyIDw8IDEyKSB8ICh1MyA8PCA2KSB8IHU0OwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB1NSA9IHU4QXJyYXlbaWR4KytdICYgNjM7CiAgICAgICAgICAgICAgICB1MCA9ICgodTAgJiAxKSA8PCAzMCkgfCAodTEgPDwgMjQpIHwgKHUyIDw8IDE4KSB8ICh1MyA8PCAxMikgfCAodTQgPDwgNikgfCB1NTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmICh1MCA8IDY1NTM2KSB7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBjaCA9IHUwIC0gNjU1MzY7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGNoID4+IDEwKSwgNTYzMjAgfCAoY2ggJiAxMDIzKSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyKSB7CiAgICAgIHJldHVybiBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0cikKICAgIH0KICAgIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgb3V0VThBcnJheSwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHsKICAgICAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIHJldHVybiAwCiAgICAgIHZhciBzdGFydElkeCA9IG91dElkeDsKICAgICAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB1ID0gKDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyk7CiAgICAgICAgaWYgKHUgPD0gMTI3KSB7CiAgICAgICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gdTsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMjA0NykgewogICAgICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhawogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxOTIgfCAodSA+PiA2KTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKHUgJiA2Myk7CiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7CiAgICAgICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrCiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDIyNCB8ICh1ID4+IDEyKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDYpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMjA5NzE1MSkgewogICAgICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhawogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAyNDAgfCAodSA+PiAxOCk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiAxMikgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiA2KSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKHUgJiA2Myk7CiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDY3MTA4ODYzKSB7CiAgICAgICAgICBpZiAob3V0SWR4ICsgNCA+PSBlbmRJZHgpIGJyZWFrCiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDI0OCB8ICh1ID4+IDI0KTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDE4KSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDEyKSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDYpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKG91dElkeCArIDUgPj0gZW5kSWR4KSBicmVhawogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAyNTIgfCAodSA+PiAzMCk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiAyNCkgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiAxOCkgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiAxMikgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICgodSA+PiA2KSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKHUgJiA2Myk7CiAgICAgICAgfQogICAgICB9CiAgICAgIG91dFU4QXJyYXlbb3V0SWR4XSA9IDA7CiAgICAgIHJldHVybiBvdXRJZHggLSBzdGFydElkeAogICAgfQogICAgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHsKICAgICAgcmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUFU4LCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkKICAgIH0KICAgIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHsKICAgICAgdmFyIGxlbiA9IDA7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAgICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsKICAgICAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB1ID0gKDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyk7CiAgICAgICAgaWYgKHUgPD0gMTI3KSB7CiAgICAgICAgICArK2xlbjsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMjA0NykgewogICAgICAgICAgbGVuICs9IDI7CiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7CiAgICAgICAgICBsZW4gKz0gMzsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gMjA5NzE1MSkgewogICAgICAgICAgbGVuICs9IDQ7CiAgICAgICAgfSBlbHNlIGlmICh1IDw9IDY3MTA4ODYzKSB7CiAgICAgICAgICBsZW4gKz0gNTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbGVuICs9IDY7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBsZW4KICAgIH0KICAgIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNmxlJykgOiB1bmRlZmluZWQ7CiAgICBmdW5jdGlvbiBVVEYzMlRvU3RyaW5nKHB0cikgewogICAgICB2YXIgaSA9IDA7CiAgICAgIHZhciBzdHIgPSAnJzsKICAgICAgd2hpbGUgKDEpIHsKICAgICAgICB2YXIgdXRmMzIgPSBIRUFQMzJbKHB0ciArIGkgKiA0KSA+PiAyXTsKICAgICAgICBpZiAodXRmMzIgPT0gMCkgcmV0dXJuIHN0cgogICAgICAgICsraTsKICAgICAgICBpZiAodXRmMzIgPj0gNjU1MzYpIHsKICAgICAgICAgIHZhciBjaCA9IHV0ZjMyIC0gNjU1MzY7CiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IChjaCA+PiAxMCksIDU2MzIwIHwgKGNoICYgMTAyMykpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKSB7CiAgICAgIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxOwogICAgICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTsKICAgICAgaWYgKHJldCkgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTsKICAgICAgcmV0dXJuIHJldAogICAgfQogICAgZnVuY3Rpb24gZGVtYW5nbGUoZnVuYykgewogICAgICByZXR1cm4gZnVuYwogICAgfQogICAgZnVuY3Rpb24gZGVtYW5nbGVBbGwodGV4dCkgewogICAgICB2YXIgcmVnZXggPSAvX19aW1x3XGRfXSsvZzsKICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24gKHgpIHsKICAgICAgICB2YXIgeSA9IGRlbWFuZ2xlKHgpOwogICAgICAgIHJldHVybiB4ID09PSB5ID8geCA6IHggKyAnIFsnICsgeSArICddJwogICAgICB9KQogICAgfQogICAgZnVuY3Rpb24ganNTdGFja1RyYWNlKCkgewogICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7CiAgICAgIGlmICghZXJyLnN0YWNrKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigwKQogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGVyciA9IGU7CiAgICAgICAgfQogICAgICAgIGlmICghZXJyLnN0YWNrKSB7CiAgICAgICAgICByZXR1cm4gJyhubyBzdGFjayB0cmFjZSBhdmFpbGFibGUpJwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gZXJyLnN0YWNrLnRvU3RyaW5nKCkKICAgIH0KICAgIGZ1bmN0aW9uIHN0YWNrVHJhY2UoKSB7CiAgICAgIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpOwogICAgICBpZiAoTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSkganMgKz0gJ1xuJyArIE1vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10oKTsKICAgICAgcmV0dXJuIGRlbWFuZ2xlQWxsKGpzKQogICAgfQogICAgdmFyIFdBU01fUEFHRV9TSVpFID0gNjU1MzY7CiAgICB2YXIgQVNNSlNfUEFHRV9TSVpFID0gMTY3NzcyMTY7CiAgICB2YXIgTUlOX1RPVEFMX01FTU9SWSA9IDE2Nzc3MjE2OwogICAgZnVuY3Rpb24gYWxpZ25VcCh4LCBtdWx0aXBsZSkgewogICAgICBpZiAoeCAlIG11bHRpcGxlID4gMCkgewogICAgICAgIHggKz0gbXVsdGlwbGUgLSAoeCAlIG11bHRpcGxlKTsKICAgICAgfQogICAgICByZXR1cm4geAogICAgfQogICAgdmFyIGJ1ZmZlciwgSEVBUDgsIEhFQVBVOCwgSEVBUDE2LCBIRUFQVTE2LCBIRUFQMzIsIEhFQVBVMzIsIEhFQVBGMzIsIEhFQVBGNjQ7CiAgICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXIoYnVmKSB7CiAgICAgIE1vZHVsZVsnYnVmZmVyJ10gPSBidWZmZXIgPSBidWY7CiAgICB9CiAgICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpIHsKICAgICAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGJ1ZmZlcik7CiAgICAgIE1vZHVsZVsnSEVBUDE2J10gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShidWZmZXIpOwogICAgICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmZmVyKTsKICAgICAgTW9kdWxlWydIRUFQVTgnXSA9IEhFQVBVOCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7CiAgICAgIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpOwogICAgICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTsKICAgICAgTW9kdWxlWydIRUFQRjMyJ10gPSBIRUFQRjMyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpOwogICAgICBNb2R1bGVbJ0hFQVBGNjQnXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7CiAgICB9CiAgICB2YXIgU1RBVElDX0JBU0UsIFNUQVRJQ1RPUCwgc3RhdGljU2VhbGVkOwogICAgdmFyIFNUQUNLX0JBU0UsIFNUQUNLVE9QLCBTVEFDS19NQVg7CiAgICB2YXIgRFlOQU1JQ19CQVNFLCBEWU5BTUlDVE9QX1BUUjsKICAgIFNUQVRJQ19CQVNFID0gU1RBVElDVE9QID0gU1RBQ0tfQkFTRSA9IFNUQUNLVE9QID0gU1RBQ0tfTUFYID0gRFlOQU1JQ19CQVNFID0gRFlOQU1JQ1RPUF9QVFIgPSAwOwogICAgc3RhdGljU2VhbGVkID0gZmFsc2U7CiAgICBmdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpIHsKICAgICAgYWJvcnQoCiAgICAgICAgJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICcgKwogICAgICAgICAgVE9UQUxfTUVNT1JZICsKICAgICAgICAgICcsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICcKICAgICAgKTsKICAgIH0KICAgIGlmICghTW9kdWxlWydyZWFsbG9jQnVmZmVyJ10pCiAgICAgIE1vZHVsZVsncmVhbGxvY0J1ZmZlciddID0gZnVuY3Rpb24gKHNpemUpIHsKICAgICAgICB2YXIgcmV0OwogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIudHJhbnNmZXIpIHsKICAgICAgICAgICAgcmV0ID0gQXJyYXlCdWZmZXIudHJhbnNmZXIoYnVmZmVyLCBzaXplKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBvbGRIRUFQOCA9IEhFQVA4OwogICAgICAgICAgICByZXQgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7CiAgICAgICAgICAgIHZhciB0ZW1wID0gbmV3IEludDhBcnJheShyZXQpOwogICAgICAgICAgICB0ZW1wLnNldChvbGRIRUFQOCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfQogICAgICAgIHZhciBzdWNjZXNzID0gX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnkocmV0KTsKICAgICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVybiBmYWxzZQogICAgICAgIHJldHVybiByZXQKICAgICAgfTsKICAgIGZ1bmN0aW9uIGVubGFyZ2VNZW1vcnkoKSB7CiAgICAgIHZhciBQQUdFX01VTFRJUExFID0gTW9kdWxlWyd1c2luZ1dhc20nXSA/IFdBU01fUEFHRV9TSVpFIDogQVNNSlNfUEFHRV9TSVpFOwogICAgICB2YXIgTElNSVQgPSAyMTQ3NDgzNjQ4IC0gUEFHRV9NVUxUSVBMRTsKICAgICAgaWYgKEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXSA+IExJTUlUKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgdmFyIE9MRF9UT1RBTF9NRU1PUlkgPSBUT1RBTF9NRU1PUlk7CiAgICAgIFRPVEFMX01FTU9SWSA9IE1hdGgubWF4KFRPVEFMX01FTU9SWSwgTUlOX1RPVEFMX01FTU9SWSk7CiAgICAgIHdoaWxlIChUT1RBTF9NRU1PUlkgPCBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0pIHsKICAgICAgICBpZiAoVE9UQUxfTUVNT1JZIDw9IDUzNjg3MDkxMikgewogICAgICAgICAgVE9UQUxfTUVNT1JZID0gYWxpZ25VcCgyICogVE9UQUxfTUVNT1JZLCBQQUdFX01VTFRJUExFKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgVE9UQUxfTUVNT1JZID0gTWF0aC5taW4oYWxpZ25VcCgoMyAqIFRPVEFMX01FTU9SWSArIDIxNDc0ODM2NDgpIC8gNCwgUEFHRV9NVUxUSVBMRSksIExJTUlUKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIHJlcGxhY2VtZW50ID0gTW9kdWxlWydyZWFsbG9jQnVmZmVyJ10oVE9UQUxfTUVNT1JZKTsKICAgICAgaWYgKCFyZXBsYWNlbWVudCB8fCByZXBsYWNlbWVudC5ieXRlTGVuZ3RoICE9IFRPVEFMX01FTU9SWSkgewogICAgICAgIFRPVEFMX01FTU9SWSA9IE9MRF9UT1RBTF9NRU1PUlk7CiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgdXBkYXRlR2xvYmFsQnVmZmVyKHJlcGxhY2VtZW50KTsKICAgICAgdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTsKICAgICAgcmV0dXJuIHRydWUKICAgIH0KICAgIHZhciBieXRlTGVuZ3RoOwogICAgdHJ5IHsKICAgICAgYnl0ZUxlbmd0aCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUJ1ZmZlci5wcm90b3R5cGUsICdieXRlTGVuZ3RoJykuZ2V0KTsKICAgICAgYnl0ZUxlbmd0aChuZXcgQXJyYXlCdWZmZXIoNCkpOwogICAgfSBjYXRjaCAoZSkgewogICAgICBieXRlTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikgewogICAgICAgIHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aAogICAgICB9OwogICAgfQogICAgdmFyIFRPVEFMX1NUQUNLID0gTW9kdWxlWydUT1RBTF9TVEFDSyddIHx8IDUyNDI4ODA7CiAgICB2YXIgVE9UQUxfTUVNT1JZID0gTW9kdWxlWydUT1RBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjsKICAgIGlmIChUT1RBTF9NRU1PUlkgPCBUT1RBTF9TVEFDSykKICAgICAgTW9kdWxlLnByaW50RXJyKAogICAgICAgICdUT1RBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFRPVEFMX1NUQUNLLCB3YXMgJyArIFRPVEFMX01FTU9SWSArICchIChUT1RBTF9TVEFDSz0nICsgVE9UQUxfU1RBQ0sgKyAnKScKICAgICAgKTsKICAgIGlmIChNb2R1bGVbJ2J1ZmZlciddKSB7CiAgICAgIGJ1ZmZlciA9IE1vZHVsZVsnYnVmZmVyJ107CiAgICB9IGVsc2UgewogICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgTW9kdWxlWyd3YXNtTWVtb3J5J10gPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsgaW5pdGlhbDogVE9UQUxfTUVNT1JZIC8gV0FTTV9QQUdFX1NJWkUgfSk7CiAgICAgICAgYnVmZmVyID0gTW9kdWxlWyd3YXNtTWVtb3J5J10uYnVmZmVyOwogICAgICB9IGVsc2UgewogICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihUT1RBTF9NRU1PUlkpOwogICAgICB9CiAgICAgIE1vZHVsZVsnYnVmZmVyJ10gPSBidWZmZXI7CiAgICB9CiAgICB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpOwogICAgZnVuY3Rpb24gZ2V0VG90YWxNZW1vcnkoKSB7CiAgICAgIHJldHVybiBUT1RBTF9NRU1PUlkKICAgIH0KICAgIEhFQVAzMlswXSA9IDE2Njg1MDkwMjk7CiAgICBIRUFQMTZbMV0gPSAyNTQ1OTsKICAgIGlmIChIRUFQVThbMl0gIT09IDExNSB8fCBIRUFQVThbM10gIT09IDk5KSB0aHJvdyAnUnVudGltZSBlcnJvcjogZXhwZWN0ZWQgdGhlIHN5c3RlbSB0byBiZSBsaXR0bGUtZW5kaWFuIScKICAgIGZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykgewogICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHsKICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTsKICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHsKICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgICBjb250aW51ZQogICAgICAgIH0KICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrLmZ1bmM7CiAgICAgICAgaWYgKHR5cGVvZiBmdW5jID09PSAnbnVtYmVyJykgewogICAgICAgICAgaWYgKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIE1vZHVsZVsnZHluQ2FsbF92J10oZnVuYyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmknXShmdW5jLCBjYWxsYmFjay5hcmcpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBmdW5jKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrLmFyZyk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICB2YXIgX19BVFBSRVJVTl9fID0gW107CiAgICB2YXIgX19BVElOSVRfXyA9IFtdOwogICAgdmFyIF9fQVRNQUlOX18gPSBbXTsKICAgIHZhciBfX0FURVhJVF9fID0gW107CiAgICB2YXIgX19BVFBPU1RSVU5fXyA9IFtdOwogICAgdmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlOwogICAgZnVuY3Rpb24gcHJlUnVuKCkgewogICAgICBpZiAoTW9kdWxlWydwcmVSdW4nXSkgewogICAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dOwogICAgICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkgewogICAgICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIGVuc3VyZUluaXRSdW50aW1lKCkgewogICAgICBpZiAocnVudGltZUluaXRpYWxpemVkKSByZXR1cm4KICAgICAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTsKICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7CiAgICB9CiAgICBmdW5jdGlvbiBwcmVNYWluKCkgewogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUTUFJTl9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIGV4aXRSdW50aW1lKCkgewogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FURVhJVF9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIHBvc3RSdW4oKSB7CiAgICAgIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkgewogICAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dOwogICAgICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHsKICAgICAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7CiAgICB9CiAgICBmdW5jdGlvbiBhZGRPblByZVJ1bihjYikgewogICAgICBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7CiAgICB9CiAgICBmdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHsKICAgICAgX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTsKICAgIH0KICAgIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICBIRUFQOFtidWZmZXIrKyA+PiAwXSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICB9CiAgICAgIGlmICghZG9udEFkZE51bGwpIEhFQVA4W2J1ZmZlciA+PiAwXSA9IDA7CiAgICB9CiAgICB2YXIgTWF0aF9hYnMgPSBNYXRoLmFiczsKICAgIHZhciBNYXRoX2NlaWwgPSBNYXRoLmNlaWw7CiAgICB2YXIgTWF0aF9mbG9vciA9IE1hdGguZmxvb3I7CiAgICB2YXIgTWF0aF9taW4gPSBNYXRoLm1pbjsKICAgIHZhciBydW5EZXBlbmRlbmNpZXMgPSAwOwogICAgdmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7CiAgICBmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7CiAgICAgIHJ1bkRlcGVuZGVuY2llcysrOwogICAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHsKICAgICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7CiAgICAgIHJ1bkRlcGVuZGVuY2llcy0tOwogICAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHsKICAgICAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpOwogICAgICB9CiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPT0gMCkgewogICAgICAgIGlmIChkZXBlbmRlbmNpZXNGdWxmaWxsZWQpIHsKICAgICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDsKICAgICAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7CiAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgTW9kdWxlWydwcmVsb2FkZWRJbWFnZXMnXSA9IHt9OwogICAgTW9kdWxlWydwcmVsb2FkZWRBdWRpb3MnXSA9IHt9OwogICAgdmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7CiAgICBmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHsKICAgICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA/IGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCkgOiBmaWxlbmFtZS5pbmRleE9mKGRhdGFVUklQcmVmaXgpID09PSAwCiAgICB9CiAgICBmdW5jdGlvbiBpbnRlZ3JhdGVXYXNtSlMoKSB7CiAgICAgIHZhciB3YXNtVGV4dEZpbGUgPSAndW5wYWNrLndhc3QnOwogICAgICB2YXIgYXNtanNDb2RlRmlsZSA9ICd1bnBhY2sudGVtcC5hc20uanMnOwogICAgICBpZiAodHlwZW9mIE1vZHVsZVsnbG9jYXRlRmlsZSddID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgaWYgKCFpc0RhdGFVUkkod2FzbVRleHRGaWxlKSkgewogICAgICAgICAgd2FzbVRleHRGaWxlID0gTW9kdWxlWydsb2NhdGVGaWxlJ10od2FzbVRleHRGaWxlKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7CiAgICAgICAgICB3YXNtQmluYXJ5RmlsZSA9IE1vZHVsZVsnbG9jYXRlRmlsZSddKHdhc21CaW5hcnlGaWxlKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFpc0RhdGFVUkkoYXNtanNDb2RlRmlsZSkpIHsKICAgICAgICAgIGFzbWpzQ29kZUZpbGUgPSBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShhc21qc0NvZGVGaWxlKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgY29uc3Qgd2FzbVBhZ2VTaXplID0gNjQgKiAxMDI0OwogICAgICBjb25zdCBpbmZvID0gewogICAgICAgIGFzbTJ3YXNtOiB7CiAgICAgICAgICAnZjY0LXJlbSc6IGZ1bmN0aW9uICh4LCB5KSB7CiAgICAgICAgICAgIHJldHVybiB4ICUgeQogICAgICAgICAgfSwKICAgICAgICAgIGRlYnVnZ2VyOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGRlYnVnZ2VyCiAgICAgICAgICB9LAogICAgICAgIH0sCiAgICAgICAgcGFyZW50OiBNb2R1bGUsCiAgICAgIH07CiAgICAgIHZhciBleHBvcnRzID0gbnVsbDsKICAgICAgZnVuY3Rpb24gbWVyZ2VNZW1vcnkobmV3QnVmZmVyKSB7CiAgICAgICAgdmFyIG9sZEJ1ZmZlciA9IE1vZHVsZVsnYnVmZmVyJ107CiAgICAgICAgaWYgKG5ld0J1ZmZlci5ieXRlTGVuZ3RoIDwgb2xkQnVmZmVyLmJ5dGVMZW5ndGgpIHsKICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgKICAgICAgICAgICAgJ3RoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUnCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICB2YXIgb2xkVmlldyA9IG5ldyBJbnQ4QXJyYXkob2xkQnVmZmVyKTsKICAgICAgICB2YXIgbmV3VmlldyA9IG5ldyBJbnQ4QXJyYXkobmV3QnVmZmVyKTsKICAgICAgICBuZXdWaWV3LnNldChvbGRWaWV3KTsKICAgICAgICB1cGRhdGVHbG9iYWxCdWZmZXIobmV3QnVmZmVyKTsKICAgICAgICB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpeEltcG9ydHMoaW1wb3J0cykgewogICAgICAgIHJldHVybiBpbXBvcnRzCiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0QmluYXJ5KCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KE1vZHVsZVsnd2FzbUJpbmFyeSddKQogICAgICAgICAgfQogICAgICAgICAgaWYgKE1vZHVsZVsncmVhZEJpbmFyeSddKSB7CiAgICAgICAgICAgIHJldHVybiBNb2R1bGVbJ3JlYWRCaW5hcnknXSh3YXNtQmluYXJ5RmlsZSkKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93ICJvbiB0aGUgd2ViLCB3ZSBuZWVkIHRoZSB3YXNtIGJpbmFyeSB0byBiZSBwcmVsb2FkZWQgYW5kIHNldCBvbiBNb2R1bGVbJ3dhc21CaW5hcnknXS4gZW1jYy5weSB3aWxsIGRvIHRoYXQgZm9yIHlvdSB3aGVuIGdlbmVyYXRpbmcgSFRNTCAoYnV0IG5vdCBKUykiCiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBhYm9ydChlcnIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkgewogICAgICAgIGlmICghTW9kdWxlWyd3YXNtQmluYXJ5J10gJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpICYmIHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzIH0pCiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkgewogICAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHsKICAgICAgICAgICAgICAgIHRocm93ICJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICciICsgd2FzbUJpbmFyeUZpbGUgKyAiJyIKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCkKICAgICAgICAgICAgfSkKICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KCkKICAgICAgICAgICAgfSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIHJlc29sdmUoZ2V0QmluYXJ5KCkpOwogICAgICAgIH0pCiAgICAgIH0KICAgICAgZnVuY3Rpb24gZG9OYXRpdmVXYXNtKGdsb2JhbCwgZW52LCBwcm92aWRlZEJ1ZmZlcikgewogICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICdvYmplY3QnKSB7CiAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTsKICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0KICAgICAgICBpZiAoIShNb2R1bGVbJ3dhc21NZW1vcnknXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpIHsKICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnbm8gbmF0aXZlIHdhc20gTWVtb3J5IGluIHVzZScpOwogICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfQogICAgICAgIGVudlsnbWVtb3J5J10gPSBNb2R1bGVbJ3dhc21NZW1vcnknXTsKICAgICAgICBpbmZvWydnbG9iYWwnXSA9IHsgTmFOOiBOYU4sIEluZmluaXR5OiBJbmZpbml0eSB9OwogICAgICAgIGluZm9bJ2dsb2JhbC5NYXRoJ10gPSBNYXRoOwogICAgICAgIGluZm9bJ2VudiddID0gZW52OwogICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7CiAgICAgICAgICBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0czsKICAgICAgICAgIGlmIChleHBvcnRzLm1lbW9yeSkgbWVyZ2VNZW1vcnkoZXhwb3J0cy5tZW1vcnkpOwogICAgICAgICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7CiAgICAgICAgICBNb2R1bGVbJ3VzaW5nV2FzbSddID0gdHJ1ZTsKICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koKTsKICAgICAgICB9CiAgICAgICAgYWRkUnVuRGVwZW5kZW5jeSgpOwogICAgICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpOwogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZShvdXRwdXQpIHsKICAgICAgICAgIHJlY2VpdmVJbnN0YW5jZShvdXRwdXRbJ2luc3RhbmNlJ10sIG91dHB1dFsnbW9kdWxlJ10pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7CiAgICAgICAgICBnZXRCaW5hcnlQcm9taXNlKCkKICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpbmFyeSkgewogICAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pCiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC50aGVuKHJlY2VpdmVyKQogICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikgewogICAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7CiAgICAgICAgICAgICAgYWJvcnQocmVhc29uKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGlmICgKICAgICAgICAgICFNb2R1bGVbJ3dhc21CaW5hcnknXSAmJgogICAgICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nICYmCiAgICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJgogICAgICAgICAgdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nCiAgICAgICAgKSB7CiAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFscyB9KSwgaW5mbykKICAgICAgICAgICAgLnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSkKICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHsKICAgICAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTsKICAgICAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7CiAgICAgICAgICAgICAgaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB7fQogICAgICB9CiAgICAgIE1vZHVsZVsnYXNtUHJlbG9hZCddID0gTW9kdWxlWydhc20nXTsKICAgICAgdmFyIGFzbWpzUmVhbGxvY0J1ZmZlciA9IE1vZHVsZVsncmVhbGxvY0J1ZmZlciddOwogICAgICB2YXIgd2FzbVJlYWxsb2NCdWZmZXIgPSBmdW5jdGlvbiAoc2l6ZSkgewogICAgICAgIHZhciBQQUdFX01VTFRJUExFID0gTW9kdWxlWyd1c2luZ1dhc20nXSA/IFdBU01fUEFHRV9TSVpFIDogQVNNSlNfUEFHRV9TSVpFOwogICAgICAgIHNpemUgPSBhbGlnblVwKHNpemUsIFBBR0VfTVVMVElQTEUpOwogICAgICAgIHZhciBvbGQgPSBNb2R1bGVbJ2J1ZmZlciddOwogICAgICAgIHZhciBvbGRTaXplID0gb2xkLmJ5dGVMZW5ndGg7CiAgICAgICAgaWYgKE1vZHVsZVsndXNpbmdXYXNtJ10pIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5ncm93KChzaXplIC0gb2xkU2l6ZSkgLyB3YXNtUGFnZVNpemUpOwogICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAoLTEgfCAwKSkgewogICAgICAgICAgICAgIHJldHVybiAoTW9kdWxlWydidWZmZXInXSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddLmJ1ZmZlcikKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbAogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBudWxsCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgICAgICAgaWYgKGZpbmFsTWV0aG9kID09PSAnYXNtanMnKSB7CiAgICAgICAgICByZXR1cm4gYXNtanNSZWFsbG9jQnVmZmVyKHNpemUpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB3YXNtUmVhbGxvY0J1ZmZlcihzaXplKQogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGZpbmFsTWV0aG9kID0gJyc7CiAgICAgIE1vZHVsZVsnYXNtJ10gPSBmdW5jdGlvbiAoZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7CiAgICAgICAgZW52ID0gZml4SW1wb3J0cyhlbnYpOwogICAgICAgIGlmICghZW52Wyd0YWJsZSddKSB7CiAgICAgICAgICB2YXIgVEFCTEVfU0laRSA9IE1vZHVsZVsnd2FzbVRhYmxlU2l6ZSddOwogICAgICAgICAgaWYgKFRBQkxFX1NJWkUgPT09IHVuZGVmaW5lZCkgVEFCTEVfU0laRSA9IDEwMjQ7CiAgICAgICAgICB2YXIgTUFYX1RBQkxFX1NJWkUgPSBNb2R1bGVbJ3dhc21NYXhUYWJsZVNpemUnXTsKICAgICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBpZiAoTUFYX1RBQkxFX1NJWkUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIGVudlsndGFibGUnXSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7IGluaXRpYWw6IFRBQkxFX1NJWkUsIG1heGltdW06IE1BWF9UQUJMRV9TSVpFLCBlbGVtZW50OiAnYW55ZnVuYycgfSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsgaW5pdGlhbDogVEFCTEVfU0laRSwgZWxlbWVudDogJ2FueWZ1bmMnIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgQXJyYXkoVEFCTEVfU0laRSk7CiAgICAgICAgICB9CiAgICAgICAgICBNb2R1bGVbJ3dhc21UYWJsZSddID0gZW52Wyd0YWJsZSddOwogICAgICAgIH0KICAgICAgICBpZiAoIWVudlsnbWVtb3J5QmFzZSddKSB7CiAgICAgICAgICBlbnZbJ21lbW9yeUJhc2UnXSA9IE1vZHVsZVsnU1RBVElDX0JBU0UnXTsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbnZbJ3RhYmxlQmFzZSddKSB7CiAgICAgICAgICBlbnZbJ3RhYmxlQmFzZSddID0gMDsKICAgICAgICB9CiAgICAgICAgdmFyIGV4cG9ydHM7CiAgICAgICAgZXhwb3J0cyA9IGRvTmF0aXZlV2FzbShnbG9iYWwsIGVudik7CiAgICAgICAgaWYgKCFleHBvcnRzKQogICAgICAgICAgYWJvcnQoCiAgICAgICAgICAgICdubyBiaW5hcnllbiBtZXRob2Qgc3VjY2VlZGVkLiBjb25zaWRlciBlbmFibGluZyBtb3JlIG9wdGlvbnMsIGxpa2UgaW50ZXJwcmV0aW5nLCBpZiB5b3Ugd2FudCB0aGF0OiBodHRwczovL2dpdGh1Yi5jb20va3JpcGtlbi9lbXNjcmlwdGVuL3dpa2kvV2ViQXNzZW1ibHkjYmluYXJ5ZW4tbWV0aG9kcycKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIGV4cG9ydHMKICAgICAgfTsKICAgIH0KICAgIGludGVncmF0ZVdhc21KUygpOwogICAgU1RBVElDX0JBU0UgPSBHTE9CQUxfQkFTRTsKICAgIFNUQVRJQ1RPUCA9IFNUQVRJQ19CQVNFICsgNjY5NjA7CiAgICBfX0FUSU5JVF9fLnB1c2goCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfZ2xvYmFsX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfYmluZF9jcHAoKTsKICAgICAgICB9LAogICAgICB9CiAgICApOwogICAgdmFyIFNUQVRJQ19CVU1QID0gNjY5NjA7CiAgICBNb2R1bGVbJ1NUQVRJQ19CQVNFJ10gPSBTVEFUSUNfQkFTRTsKICAgIE1vZHVsZVsnU1RBVElDX0JVTVAnXSA9IFNUQVRJQ19CVU1QOwogICAgU1RBVElDVE9QICs9IDE2OwogICAgZnVuY3Rpb24gX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbihzaXplKSB7CiAgICAgIHJldHVybiBfbWFsbG9jKHNpemUpCiAgICB9CiAgICBmdW5jdGlvbiBfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udigpIHsKICAgICAgcmV0dXJuICEhX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9uCiAgICB9CiAgICB2YXIgRVhDRVBUSU9OUyA9IHsKICAgICAgbGFzdDogMCwKICAgICAgY2F1Z2h0OiBbXSwKICAgICAgaW5mb3M6IHt9LAogICAgICBkZUFkanVzdDogZnVuY3Rpb24gKGFkanVzdGVkKSB7CiAgICAgICAgaWYgKCFhZGp1c3RlZCB8fCBFWENFUFRJT05TLmluZm9zW2FkanVzdGVkXSkgcmV0dXJuIGFkanVzdGVkCiAgICAgICAgZm9yICh2YXIga2V5IGluIEVYQ0VQVElPTlMuaW5mb3MpIHsKICAgICAgICAgIHZhciBwdHIgPSAra2V5OwogICAgICAgICAgdmFyIGluZm8gPSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgICAgICBpZiAoaW5mby5hZGp1c3RlZCA9PT0gYWRqdXN0ZWQpIHsKICAgICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYWRqdXN0ZWQKICAgICAgfSwKICAgICAgYWRkUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGluZm8ucmVmY291bnQrKzsKICAgICAgfSwKICAgICAgZGVjUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGFzc2VydChpbmZvLnJlZmNvdW50ID4gMCk7CiAgICAgICAgaW5mby5yZWZjb3VudC0tOwogICAgICAgIGlmIChpbmZvLnJlZmNvdW50ID09PSAwICYmICFpbmZvLnJldGhyb3duKSB7CiAgICAgICAgICBpZiAoaW5mby5kZXN0cnVjdG9yKSB7CiAgICAgICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aSddKGluZm8uZGVzdHJ1Y3RvciwgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIGRlbGV0ZSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgICAgICBfX19jeGFfZnJlZV9leGNlcHRpb24ocHRyKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGNsZWFyUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGluZm8ucmVmY291bnQgPSAwOwogICAgICB9LAogICAgfTsKICAgIGZ1bmN0aW9uIF9fX2N4YV9iZWdpbl9jYXRjaChwdHIpIHsKICAgICAgdmFyIGluZm8gPSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgIGlmIChpbmZvICYmICFpbmZvLmNhdWdodCkgewogICAgICAgIGluZm8uY2F1Z2h0ID0gdHJ1ZTsKICAgICAgICBfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udi51bmNhdWdodF9leGNlcHRpb24tLTsKICAgICAgfQogICAgICBpZiAoaW5mbykgaW5mby5yZXRocm93biA9IGZhbHNlOwogICAgICBFWENFUFRJT05TLmNhdWdodC5wdXNoKHB0cik7CiAgICAgIEVYQ0VQVElPTlMuYWRkUmVmKEVYQ0VQVElPTlMuZGVBZGp1c3QocHRyKSk7CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV9mcmVlX2V4Y2VwdGlvbihwdHIpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gX2ZyZWUocHRyKQogICAgICB9IGNhdGNoIChlKSB7fQogICAgfQogICAgZnVuY3Rpb24gX19fY3hhX2VuZF9jYXRjaCgpIHsKICAgICAgTW9kdWxlWydzZXRUaHJldyddKDApOwogICAgICB2YXIgcHRyID0gRVhDRVBUSU9OUy5jYXVnaHQucG9wKCk7CiAgICAgIGlmIChwdHIpIHsKICAgICAgICBFWENFUFRJT05TLmRlY1JlZihFWENFUFRJT05TLmRlQWRqdXN0KHB0cikpOwogICAgICAgIEVYQ0VQVElPTlMubGFzdCA9IDA7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIoKSB7CiAgICAgIHJldHVybiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaC5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9CiAgICBmdW5jdGlvbiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zKCkgewogICAgICByZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfQogICAgZnVuY3Rpb24gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNCgpIHsKICAgICAgcmV0dXJuIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0KICAgIGZ1bmN0aW9uIF9fX3Jlc3VtZUV4Y2VwdGlvbihwdHIpIHsKICAgICAgaWYgKCFFWENFUFRJT05TLmxhc3QpIHsKICAgICAgICBFWENFUFRJT05TLmxhc3QgPSBwdHI7CiAgICAgIH0KICAgICAgdGhyb3cgcHRyCiAgICB9CiAgICBmdW5jdGlvbiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaCgpIHsKICAgICAgdmFyIHRocm93biA9IEVYQ0VQVElPTlMubGFzdDsKICAgICAgaWYgKCF0aHJvd24pIHsKICAgICAgICByZXR1cm4gKHNldFRlbXBSZXQwKDApLCAwKSB8IDAKICAgICAgfQogICAgICB2YXIgaW5mbyA9IEVYQ0VQVElPTlMuaW5mb3NbdGhyb3duXTsKICAgICAgdmFyIHRocm93bnR5cGUgPSBpbmZvLnR5cGU7CiAgICAgIGlmICghdGhyb3dudHlwZSkgewogICAgICAgIHJldHVybiAoc2V0VGVtcFJldDAoMCksIHRocm93bikgfCAwCiAgICAgIH0KICAgICAgdmFyIHR5cGVBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7CiAgICAgIE1vZHVsZVsnX19fY3hhX2lzX3BvaW50ZXJfdHlwZSddKHRocm93bnR5cGUpOwogICAgICBpZiAoIV9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlcikgX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyID0gX21hbGxvYyg0KTsKICAgICAgSEVBUDMyW19fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlciA+PiAyXSA9IHRocm93bjsKICAgICAgdGhyb3duID0gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVBcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmICh0eXBlQXJyYXlbaV0gJiYgTW9kdWxlWydfX19jeGFfY2FuX2NhdGNoJ10odHlwZUFycmF5W2ldLCB0aHJvd250eXBlLCB0aHJvd24pKSB7CiAgICAgICAgICB0aHJvd24gPSBIRUFQMzJbdGhyb3duID4+IDJdOwogICAgICAgICAgaW5mby5hZGp1c3RlZCA9IHRocm93bjsKICAgICAgICAgIHJldHVybiAoc2V0VGVtcFJldDAodHlwZUFycmF5W2ldKSwgdGhyb3duKSB8IDAKICAgICAgICB9CiAgICAgIH0KICAgICAgdGhyb3duID0gSEVBUDMyW3Rocm93biA+PiAyXTsKICAgICAgcmV0dXJuIChzZXRUZW1wUmV0MCh0aHJvd250eXBlKSwgdGhyb3duKSB8IDAKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsIHR5cGUsIGRlc3RydWN0b3IpIHsKICAgICAgRVhDRVBUSU9OUy5pbmZvc1twdHJdID0gewogICAgICAgIHB0cjogcHRyLAogICAgICAgIGFkanVzdGVkOiBwdHIsCiAgICAgICAgdHlwZTogdHlwZSwKICAgICAgICBkZXN0cnVjdG9yOiBkZXN0cnVjdG9yLAogICAgICAgIHJlZmNvdW50OiAwLAogICAgICAgIGNhdWdodDogZmFsc2UsCiAgICAgICAgcmV0aHJvd246IGZhbHNlLAogICAgICB9OwogICAgICBFWENFUFRJT05TLmxhc3QgPSBwdHI7CiAgICAgIGlmICghKCd1bmNhdWdodF9leGNlcHRpb24nIGluIF9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252KSkgewogICAgICAgIF9fWlN0MTh1bmNhdWdodF9leGNlcHRpb252LnVuY2F1Z2h0X2V4Y2VwdGlvbiA9IDE7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgX19aU3QxOHVuY2F1Z2h0X2V4Y2VwdGlvbnYudW5jYXVnaHRfZXhjZXB0aW9uKys7CiAgICAgIH0KICAgICAgdGhyb3cgcHRyCiAgICB9CiAgICBmdW5jdGlvbiBfX19sb2NrKCkge30KICAgIHZhciBFUlJOT19DT0RFUyA9IHsKICAgICAgRVBFUk06IDEsCiAgICAgIEVOT0VOVDogMiwKICAgICAgRVNSQ0g6IDMsCiAgICAgIEVJTlRSOiA0LAogICAgICBFSU86IDUsCiAgICAgIEVOWElPOiA2LAogICAgICBFMkJJRzogNywKICAgICAgRU5PRVhFQzogOCwKICAgICAgRUJBREY6IDksCiAgICAgIEVDSElMRDogMTAsCiAgICAgIEVBR0FJTjogMTEsCiAgICAgIEVXT1VMREJMT0NLOiAxMSwKICAgICAgRU5PTUVNOiAxMiwKICAgICAgRUFDQ0VTOiAxMywKICAgICAgRUZBVUxUOiAxNCwKICAgICAgRU5PVEJMSzogMTUsCiAgICAgIEVCVVNZOiAxNiwKICAgICAgRUVYSVNUOiAxNywKICAgICAgRVhERVY6IDE4LAogICAgICBFTk9ERVY6IDE5LAogICAgICBFTk9URElSOiAyMCwKICAgICAgRUlTRElSOiAyMSwKICAgICAgRUlOVkFMOiAyMiwKICAgICAgRU5GSUxFOiAyMywKICAgICAgRU1GSUxFOiAyNCwKICAgICAgRU5PVFRZOiAyNSwKICAgICAgRVRYVEJTWTogMjYsCiAgICAgIEVGQklHOiAyNywKICAgICAgRU5PU1BDOiAyOCwKICAgICAgRVNQSVBFOiAyOSwKICAgICAgRVJPRlM6IDMwLAogICAgICBFTUxJTks6IDMxLAogICAgICBFUElQRTogMzIsCiAgICAgIEVET006IDMzLAogICAgICBFUkFOR0U6IDM0LAogICAgICBFTk9NU0c6IDQyLAogICAgICBFSURSTTogNDMsCiAgICAgIEVDSFJORzogNDQsCiAgICAgIEVMMk5TWU5DOiA0NSwKICAgICAgRUwzSExUOiA0NiwKICAgICAgRUwzUlNUOiA0NywKICAgICAgRUxOUk5HOiA0OCwKICAgICAgRVVOQVRDSDogNDksCiAgICAgIEVOT0NTSTogNTAsCiAgICAgIEVMMkhMVDogNTEsCiAgICAgIEVERUFETEs6IDM1LAogICAgICBFTk9MQ0s6IDM3LAogICAgICBFQkFERTogNTIsCiAgICAgIEVCQURSOiA1MywKICAgICAgRVhGVUxMOiA1NCwKICAgICAgRU5PQU5POiA1NSwKICAgICAgRUJBRFJRQzogNTYsCiAgICAgIEVCQURTTFQ6IDU3LAogICAgICBFREVBRExPQ0s6IDM1LAogICAgICBFQkZPTlQ6IDU5LAogICAgICBFTk9TVFI6IDYwLAogICAgICBFTk9EQVRBOiA2MSwKICAgICAgRVRJTUU6IDYyLAogICAgICBFTk9TUjogNjMsCiAgICAgIEVOT05FVDogNjQsCiAgICAgIEVOT1BLRzogNjUsCiAgICAgIEVSRU1PVEU6IDY2LAogICAgICBFTk9MSU5LOiA2NywKICAgICAgRUFEVjogNjgsCiAgICAgIEVTUk1OVDogNjksCiAgICAgIEVDT01NOiA3MCwKICAgICAgRVBST1RPOiA3MSwKICAgICAgRU1VTFRJSE9QOiA3MiwKICAgICAgRURPVERPVDogNzMsCiAgICAgIEVCQURNU0c6IDc0LAogICAgICBFTk9UVU5JUTogNzYsCiAgICAgIEVCQURGRDogNzcsCiAgICAgIEVSRU1DSEc6IDc4LAogICAgICBFTElCQUNDOiA3OSwKICAgICAgRUxJQkJBRDogODAsCiAgICAgIEVMSUJTQ046IDgxLAogICAgICBFTElCTUFYOiA4MiwKICAgICAgRUxJQkVYRUM6IDgzLAogICAgICBFTk9TWVM6IDM4LAogICAgICBFTk9URU1QVFk6IDM5LAogICAgICBFTkFNRVRPT0xPTkc6IDM2LAogICAgICBFTE9PUDogNDAsCiAgICAgIEVPUE5PVFNVUFA6IDk1LAogICAgICBFUEZOT1NVUFBPUlQ6IDk2LAogICAgICBFQ09OTlJFU0VUOiAxMDQsCiAgICAgIEVOT0JVRlM6IDEwNSwKICAgICAgRUFGTk9TVVBQT1JUOiA5NywKICAgICAgRVBST1RPVFlQRTogOTEsCiAgICAgIEVOT1RTT0NLOiA4OCwKICAgICAgRU5PUFJPVE9PUFQ6IDkyLAogICAgICBFU0hVVERPV046IDEwOCwKICAgICAgRUNPTk5SRUZVU0VEOiAxMTEsCiAgICAgIEVBRERSSU5VU0U6IDk4LAogICAgICBFQ09OTkFCT1JURUQ6IDEwMywKICAgICAgRU5FVFVOUkVBQ0g6IDEwMSwKICAgICAgRU5FVERPV046IDEwMCwKICAgICAgRVRJTUVET1VUOiAxMTAsCiAgICAgIEVIT1NURE9XTjogMTEyLAogICAgICBFSE9TVFVOUkVBQ0g6IDExMywKICAgICAgRUlOUFJPR1JFU1M6IDExNSwKICAgICAgRUFMUkVBRFk6IDExNCwKICAgICAgRURFU1RBRERSUkVROiA4OSwKICAgICAgRU1TR1NJWkU6IDkwLAogICAgICBFUFJPVE9OT1NVUFBPUlQ6IDkzLAogICAgICBFU09DS1ROT1NVUFBPUlQ6IDk0LAogICAgICBFQUREUk5PVEFWQUlMOiA5OSwKICAgICAgRU5FVFJFU0VUOiAxMDIsCiAgICAgIEVJU0NPTk46IDEwNiwKICAgICAgRU5PVENPTk46IDEwNywKICAgICAgRVRPT01BTllSRUZTOiAxMDksCiAgICAgIEVVU0VSUzogODcsCiAgICAgIEVEUVVPVDogMTIyLAogICAgICBFU1RBTEU6IDExNiwKICAgICAgRU5PVFNVUDogOTUsCiAgICAgIEVOT01FRElVTTogMTIzLAogICAgICBFSUxTRVE6IDg0LAogICAgICBFT1ZFUkZMT1c6IDc1LAogICAgICBFQ0FOQ0VMRUQ6IDEyNSwKICAgICAgRU5PVFJFQ09WRVJBQkxFOiAxMzEsCiAgICAgIEVPV05FUkRFQUQ6IDEzMCwKICAgICAgRVNUUlBJUEU6IDg2LAogICAgfTsKICAgIGZ1bmN0aW9uIF9fX3NldEVyck5vKHZhbHVlKSB7CiAgICAgIGlmIChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10pIEhFQVAzMltNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10oKSA+PiAyXSA9IHZhbHVlOwogICAgICByZXR1cm4gdmFsdWUKICAgIH0KICAgIGZ1bmN0aW9uIF9fX21hcF9maWxlKHBhdGhuYW1lLCBzaXplKSB7CiAgICAgIF9fX3NldEVyck5vKEVSUk5PX0NPREVTLkVQRVJNKTsKICAgICAgcmV0dXJuIC0xCiAgICB9CiAgICB2YXIgRVJSTk9fTUVTU0FHRVMgPSB7CiAgICAgIDA6ICdTdWNjZXNzJywKICAgICAgMTogJ05vdCBzdXBlci11c2VyJywKICAgICAgMjogJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknLAogICAgICAzOiAnTm8gc3VjaCBwcm9jZXNzJywKICAgICAgNDogJ0ludGVycnVwdGVkIHN5c3RlbSBjYWxsJywKICAgICAgNTogJ0kvTyBlcnJvcicsCiAgICAgIDY6ICdObyBzdWNoIGRldmljZSBvciBhZGRyZXNzJywKICAgICAgNzogJ0FyZyBsaXN0IHRvbyBsb25nJywKICAgICAgODogJ0V4ZWMgZm9ybWF0IGVycm9yJywKICAgICAgOTogJ0JhZCBmaWxlIG51bWJlcicsCiAgICAgIDEwOiAnTm8gY2hpbGRyZW4nLAogICAgICAxMTogJ05vIG1vcmUgcHJvY2Vzc2VzJywKICAgICAgMTI6ICdOb3QgZW5vdWdoIGNvcmUnLAogICAgICAxMzogJ1Blcm1pc3Npb24gZGVuaWVkJywKICAgICAgMTQ6ICdCYWQgYWRkcmVzcycsCiAgICAgIDE1OiAnQmxvY2sgZGV2aWNlIHJlcXVpcmVkJywKICAgICAgMTY6ICdNb3VudCBkZXZpY2UgYnVzeScsCiAgICAgIDE3OiAnRmlsZSBleGlzdHMnLAogICAgICAxODogJ0Nyb3NzLWRldmljZSBsaW5rJywKICAgICAgMTk6ICdObyBzdWNoIGRldmljZScsCiAgICAgIDIwOiAnTm90IGEgZGlyZWN0b3J5JywKICAgICAgMjE6ICdJcyBhIGRpcmVjdG9yeScsCiAgICAgIDIyOiAnSW52YWxpZCBhcmd1bWVudCcsCiAgICAgIDIzOiAnVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0nLAogICAgICAyNDogJ1RvbyBtYW55IG9wZW4gZmlsZXMnLAogICAgICAyNTogJ05vdCBhIHR5cGV3cml0ZXInLAogICAgICAyNjogJ1RleHQgZmlsZSBidXN5JywKICAgICAgMjc6ICdGaWxlIHRvbyBsYXJnZScsCiAgICAgIDI4OiAnTm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UnLAogICAgICAyOTogJ0lsbGVnYWwgc2VlaycsCiAgICAgIDMwOiAnUmVhZCBvbmx5IGZpbGUgc3lzdGVtJywKICAgICAgMzE6ICdUb28gbWFueSBsaW5rcycsCiAgICAgIDMyOiAnQnJva2VuIHBpcGUnLAogICAgICAzMzogJ01hdGggYXJnIG91dCBvZiBkb21haW4gb2YgZnVuYycsCiAgICAgIDM0OiAnTWF0aCByZXN1bHQgbm90IHJlcHJlc2VudGFibGUnLAogICAgICAzNTogJ0ZpbGUgbG9ja2luZyBkZWFkbG9jayBlcnJvcicsCiAgICAgIDM2OiAnRmlsZSBvciBwYXRoIG5hbWUgdG9vIGxvbmcnLAogICAgICAzNzogJ05vIHJlY29yZCBsb2NrcyBhdmFpbGFibGUnLAogICAgICAzODogJ0Z1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCcsCiAgICAgIDM5OiAnRGlyZWN0b3J5IG5vdCBlbXB0eScsCiAgICAgIDQwOiAnVG9vIG1hbnkgc3ltYm9saWMgbGlua3MnLAogICAgICA0MjogJ05vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlJywKICAgICAgNDM6ICdJZGVudGlmaWVyIHJlbW92ZWQnLAogICAgICA0NDogJ0NoYW5uZWwgbnVtYmVyIG91dCBvZiByYW5nZScsCiAgICAgIDQ1OiAnTGV2ZWwgMiBub3Qgc3luY2hyb25pemVkJywKICAgICAgNDY6ICdMZXZlbCAzIGhhbHRlZCcsCiAgICAgIDQ3OiAnTGV2ZWwgMyByZXNldCcsCiAgICAgIDQ4OiAnTGluayBudW1iZXIgb3V0IG9mIHJhbmdlJywKICAgICAgNDk6ICdQcm90b2NvbCBkcml2ZXIgbm90IGF0dGFjaGVkJywKICAgICAgNTA6ICdObyBDU0kgc3RydWN0dXJlIGF2YWlsYWJsZScsCiAgICAgIDUxOiAnTGV2ZWwgMiBoYWx0ZWQnLAogICAgICA1MjogJ0ludmFsaWQgZXhjaGFuZ2UnLAogICAgICA1MzogJ0ludmFsaWQgcmVxdWVzdCBkZXNjcmlwdG9yJywKICAgICAgNTQ6ICdFeGNoYW5nZSBmdWxsJywKICAgICAgNTU6ICdObyBhbm9kZScsCiAgICAgIDU2OiAnSW52YWxpZCByZXF1ZXN0IGNvZGUnLAogICAgICA1NzogJ0ludmFsaWQgc2xvdCcsCiAgICAgIDU5OiAnQmFkIGZvbnQgZmlsZSBmbXQnLAogICAgICA2MDogJ0RldmljZSBub3QgYSBzdHJlYW0nLAogICAgICA2MTogJ05vIGRhdGEgKGZvciBubyBkZWxheSBpbyknLAogICAgICA2MjogJ1RpbWVyIGV4cGlyZWQnLAogICAgICA2MzogJ091dCBvZiBzdHJlYW1zIHJlc291cmNlcycsCiAgICAgIDY0OiAnTWFjaGluZSBpcyBub3Qgb24gdGhlIG5ldHdvcmsnLAogICAgICA2NTogJ1BhY2thZ2Ugbm90IGluc3RhbGxlZCcsCiAgICAgIDY2OiAnVGhlIG9iamVjdCBpcyByZW1vdGUnLAogICAgICA2NzogJ1RoZSBsaW5rIGhhcyBiZWVuIHNldmVyZWQnLAogICAgICA2ODogJ0FkdmVydGlzZSBlcnJvcicsCiAgICAgIDY5OiAnU3Jtb3VudCBlcnJvcicsCiAgICAgIDcwOiAnQ29tbXVuaWNhdGlvbiBlcnJvciBvbiBzZW5kJywKICAgICAgNzE6ICdQcm90b2NvbCBlcnJvcicsCiAgICAgIDcyOiAnTXVsdGlob3AgYXR0ZW1wdGVkJywKICAgICAgNzM6ICdDcm9zcyBtb3VudCBwb2ludCAobm90IHJlYWxseSBlcnJvciknLAogICAgICA3NDogJ1RyeWluZyB0byByZWFkIHVucmVhZGFibGUgbWVzc2FnZScsCiAgICAgIDc1OiAnVmFsdWUgdG9vIGxhcmdlIGZvciBkZWZpbmVkIGRhdGEgdHlwZScsCiAgICAgIDc2OiAnR2l2ZW4gbG9nLiBuYW1lIG5vdCB1bmlxdWUnLAogICAgICA3NzogJ2YuZC4gaW52YWxpZCBmb3IgdGhpcyBvcGVyYXRpb24nLAogICAgICA3ODogJ1JlbW90ZSBhZGRyZXNzIGNoYW5nZWQnLAogICAgICA3OTogJ0NhbiAgIGFjY2VzcyBhIG5lZWRlZCBzaGFyZWQgbGliJywKICAgICAgODA6ICdBY2Nlc3NpbmcgYSBjb3JydXB0ZWQgc2hhcmVkIGxpYicsCiAgICAgIDgxOiAnLmxpYiBzZWN0aW9uIGluIGEub3V0IGNvcnJ1cHRlZCcsCiAgICAgIDgyOiAnQXR0ZW1wdGluZyB0byBsaW5rIGluIHRvbyBtYW55IGxpYnMnLAogICAgICA4MzogJ0F0dGVtcHRpbmcgdG8gZXhlYyBhIHNoYXJlZCBsaWJyYXJ5JywKICAgICAgODQ6ICdJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UnLAogICAgICA4NjogJ1N0cmVhbXMgcGlwZSBlcnJvcicsCiAgICAgIDg3OiAnVG9vIG1hbnkgdXNlcnMnLAogICAgICA4ODogJ1NvY2tldCBvcGVyYXRpb24gb24gbm9uLXNvY2tldCcsCiAgICAgIDg5OiAnRGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZCcsCiAgICAgIDkwOiAnTWVzc2FnZSB0b28gbG9uZycsCiAgICAgIDkxOiAnUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0JywKICAgICAgOTI6ICdQcm90b2NvbCBub3QgYXZhaWxhYmxlJywKICAgICAgOTM6ICdVbmtub3duIHByb3RvY29sJywKICAgICAgOTQ6ICdTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkJywKICAgICAgOTU6ICdOb3Qgc3VwcG9ydGVkJywKICAgICAgOTY6ICdQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZCcsCiAgICAgIDk3OiAnQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbCBmYW1pbHknLAogICAgICA5ODogJ0FkZHJlc3MgYWxyZWFkeSBpbiB1c2UnLAogICAgICA5OTogJ0FkZHJlc3Mgbm90IGF2YWlsYWJsZScsCiAgICAgIDEwMDogJ05ldHdvcmsgaW50ZXJmYWNlIGlzIG5vdCBjb25maWd1cmVkJywKICAgICAgMTAxOiAnTmV0d29yayBpcyB1bnJlYWNoYWJsZScsCiAgICAgIDEwMjogJ0Nvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yaycsCiAgICAgIDEwMzogJ0Nvbm5lY3Rpb24gYWJvcnRlZCcsCiAgICAgIDEwNDogJ0Nvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcicsCiAgICAgIDEwNTogJ05vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUnLAogICAgICAxMDY6ICdTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQnLAogICAgICAxMDc6ICdTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcsCiAgICAgIDEwODogIkNhbid0IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duIiwKICAgICAgMTA5OiAnVG9vIG1hbnkgcmVmZXJlbmNlcycsCiAgICAgIDExMDogJ0Nvbm5lY3Rpb24gdGltZWQgb3V0JywKICAgICAgMTExOiAnQ29ubmVjdGlvbiByZWZ1c2VkJywKICAgICAgMTEyOiAnSG9zdCBpcyBkb3duJywKICAgICAgMTEzOiAnSG9zdCBpcyB1bnJlYWNoYWJsZScsCiAgICAgIDExNDogJ1NvY2tldCBhbHJlYWR5IGNvbm5lY3RlZCcsCiAgICAgIDExNTogJ0Nvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcycsCiAgICAgIDExNjogJ1N0YWxlIGZpbGUgaGFuZGxlJywKICAgICAgMTIyOiAnUXVvdGEgZXhjZWVkZWQnLAogICAgICAxMjM6ICdObyBtZWRpdW0gKGluIHRhcGUgZHJpdmUpJywKICAgICAgMTI1OiAnT3BlcmF0aW9uIGNhbmNlbGVkJywKICAgICAgMTMwOiAnUHJldmlvdXMgb3duZXIgZGllZCcsCiAgICAgIDEzMTogJ1N0YXRlIG5vdCByZWNvdmVyYWJsZScsCiAgICB9OwogICAgdmFyIFBBVEggPSB7CiAgICAgIHNwbGl0UGF0aDogZnVuY3Rpb24gKGZpbGVuYW1lKSB7CiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvOwogICAgICAgIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKQogICAgICB9LAogICAgICBub3JtYWxpemVBcnJheTogZnVuY3Rpb24gKHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkgewogICAgICAgIHZhciB1cCA9IDA7CiAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgICAgICB2YXIgbGFzdCA9IHBhcnRzW2ldOwogICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykgewogICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7CiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHsKICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpOwogICAgICAgICAgICB1cCsrOwogICAgICAgICAgfSBlbHNlIGlmICh1cCkgewogICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgIHVwLS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkgewogICAgICAgICAgZm9yICg7IHVwOyB1cC0tKSB7CiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXJ0cwogICAgICB9LAogICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLAogICAgICAgICAgdHJhaWxpbmdTbGFzaCA9IHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nOwogICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KAogICAgICAgICAgcGF0aC5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbiAocCkgewogICAgICAgICAgICByZXR1cm4gISFwCiAgICAgICAgICB9KSwKICAgICAgICAgICFpc0Fic29sdXRlCiAgICAgICAgKS5qb2luKCcvJyk7CiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7CiAgICAgICAgICBwYXRoID0gJy4nOwogICAgICAgIH0KICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7CiAgICAgICAgICBwYXRoICs9ICcvJzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aAogICAgICB9LAogICAgICBkaXJuYW1lOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSwKICAgICAgICAgIHJvb3QgPSByZXN1bHRbMF0sCiAgICAgICAgICBkaXIgPSByZXN1bHRbMV07CiAgICAgICAgaWYgKCFyb290ICYmICFkaXIpIHsKICAgICAgICAgIHJldHVybiAnLicKICAgICAgICB9CiAgICAgICAgaWYgKGRpcikgewogICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByb290ICsgZGlyCiAgICAgIH0sCiAgICAgIGJhc2VuYW1lOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIGlmIChwYXRoID09PSAnLycpIHJldHVybiAnLycKICAgICAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpOwogICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aAogICAgICAgIHJldHVybiBwYXRoLnN1YnN0cihsYXN0U2xhc2ggKyAxKQogICAgICB9LAogICAgICBleHRuYW1lOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHJldHVybiBQQVRILnNwbGl0UGF0aChwYXRoKVszXQogICAgICB9LAogICAgICBqb2luOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTsKICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbignLycpKQogICAgICB9LAogICAgICBqb2luMjogZnVuY3Rpb24gKGwsIHIpIHsKICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUobCArICcvJyArIHIpCiAgICAgIH0sCiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsCiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7CiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHsKICAgICAgICAgIHZhciBwYXRoID0gaSA+PSAwID8gYXJndW1lbnRzW2ldIDogRlMuY3dkKCk7CiAgICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJykKICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHsKICAgICAgICAgICAgcmV0dXJuICcnCiAgICAgICAgICB9CiAgICAgICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoOwogICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7CiAgICAgICAgfQogICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkoCiAgICAgICAgICByZXNvbHZlZFBhdGguc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHApIHsKICAgICAgICAgICAgcmV0dXJuICEhcAogICAgICAgICAgfSksCiAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZQogICAgICAgICkuam9pbignLycpOwogICAgICAgIHJldHVybiAocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCB8fCAnLicKICAgICAgfSwKICAgICAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykgewogICAgICAgIGZyb20gPSBQQVRILnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpOwogICAgICAgIHRvID0gUEFUSC5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7CiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHsKICAgICAgICAgIHZhciBzdGFydCA9IDA7CiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7CiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTsKICAgICAgICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHsKICAgICAgICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdCiAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpCiAgICAgICAgfQogICAgICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7CiAgICAgICAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpOwogICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7CiAgICAgICAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7CiAgICAgICAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7CiAgICAgICAgfQogICAgICAgIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7CiAgICAgICAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKQogICAgICB9LAogICAgfTsKICAgIHZhciBUVFkgPSB7CiAgICAgIHR0eXM6IFtdLAogICAgICBpbml0OiBmdW5jdGlvbiAoKSB7fSwKICAgICAgc2h1dGRvd246IGZ1bmN0aW9uICgpIHt9LAogICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGRldiwgb3BzKSB7CiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9OwogICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwgVFRZLnN0cmVhbV9vcHMpOwogICAgICB9LAogICAgICBzdHJlYW1fb3BzOiB7CiAgICAgICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdOwogICAgICAgICAgaWYgKCF0dHkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKQogICAgICAgICAgfQogICAgICAgICAgc3RyZWFtLnR0eSA9IHR0eTsKICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlOwogICAgICAgIH0sCiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpOwogICAgICAgIH0sCiAgICAgICAgZmx1c2g6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpOwogICAgICAgIH0sCiAgICAgICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7CiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOWElPKQogICAgICAgICAgfQogICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciByZXN1bHQ7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIoc3RyZWFtLnR0eSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkgewogICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBR0FJTikKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhawogICAgICAgICAgICBieXRlc1JlYWQrKzsKICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gcmVzdWx0OwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJ5dGVzUmVhZCkgewogICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZAogICAgICAgIH0sCiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgewogICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTlhJTykKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0ICsgaV0pOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAobGVuZ3RoKSB7CiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaQogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIGRlZmF1bHRfdHR5X29wczogewogICAgICAgIGdldF9jaGFyOiBmdW5jdGlvbiAodHR5KSB7CiAgICAgICAgICBpZiAoIXR0eS5pbnB1dC5sZW5ndGgpIHsKICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7CiAgICAgICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7CiAgICAgICAgICAgICAgdmFyIEJVRlNJWkUgPSAyNTY7CiAgICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoQlVGU0laRSk7CiAgICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7CiAgICAgICAgICAgICAgdmFyIGlzUG9zaXhQbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm0gIT0gJ3dpbjMyJzsKICAgICAgICAgICAgICB2YXIgZmQgPSBwcm9jZXNzLnN0ZGluLmZkOwogICAgICAgICAgICAgIGlmIChpc1Bvc2l4UGxhdGZvcm0pIHsKICAgICAgICAgICAgICAgIHZhciB1c2luZ0RldmljZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgZmQgPSBmcy5vcGVuU3luYygnL2Rldi9zdGRpbicsICdyJyk7CiAgICAgICAgICAgICAgICAgIHVzaW5nRGV2aWNlID0gdHJ1ZTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZCwgYnVmLCAwLCBCVUZTSVpFLCBudWxsKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLmluZGV4T2YoJ0VPRicpICE9IC0xKSBieXRlc1JlYWQgPSAwOwogICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBlCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh1c2luZ0RldmljZSkgewogICAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCA+IDApIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGJ1Zi5zbGljZSgwLCBieXRlc1JlYWQpLnRvU3RyaW5nKCd1dGYtOCcpOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgICByZXN1bHQgPSB3aW5kb3cucHJvbXB0KCdJbnB1dDogJyk7CiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcbic7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkbGluZSA9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVhZGxpbmUoKTsKICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xuJzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbAogICAgICAgICAgICB9CiAgICAgICAgICAgIHR0eS5pbnB1dCA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHR0eS5pbnB1dC5zaGlmdCgpCiAgICAgICAgfSwKICAgICAgICBwdXRfY2hhcjogZnVuY3Rpb24gKHR0eSwgdmFsKSB7CiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHsKICAgICAgICAgICAgTW9kdWxlWydwcmludCddKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTsKICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKHZhbCAhPSAwKSB0dHkub3V0cHV0LnB1c2godmFsKTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsdXNoOiBmdW5jdGlvbiAodHR5KSB7CiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgTW9kdWxlWydwcmludCddKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTsKICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIGRlZmF1bHRfdHR5MV9vcHM6IHsKICAgICAgICBwdXRfY2hhcjogZnVuY3Rpb24gKHR0eSwgdmFsKSB7CiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHsKICAgICAgICAgICAgTW9kdWxlWydwcmludEVyciddKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTsKICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKHZhbCAhPSAwKSB0dHkub3V0cHV0LnB1c2godmFsKTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGZsdXNoOiBmdW5jdGlvbiAodHR5KSB7CiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgTW9kdWxlWydwcmludEVyciddKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTsKICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgIH0sCiAgICB9OwogICAgdmFyIE1FTUZTID0gewogICAgICBvcHNfdGFibGU6IG51bGwsCiAgICAgIG1vdW50OiBmdW5jdGlvbiAobW91bnQpIHsKICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIDE2Mzg0IHwgNTExLCAwKQogICAgICB9LAogICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHsKICAgICAgICBpZiAoRlMuaXNCbGtkZXYobW9kZSkgfHwgRlMuaXNGSUZPKG1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgaWYgKCFNRU1GUy5vcHNfdGFibGUpIHsKICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHsKICAgICAgICAgICAgZGlyOiB7CiAgICAgICAgICAgICAgbm9kZTogewogICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0ciwKICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsCiAgICAgICAgICAgICAgICBsb29rdXA6IE1FTUZTLm5vZGVfb3BzLmxvb2t1cCwKICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCwKICAgICAgICAgICAgICAgIHJlbmFtZTogTUVNRlMubm9kZV9vcHMucmVuYW1lLAogICAgICAgICAgICAgICAgdW5saW5rOiBNRU1GUy5ub2RlX29wcy51bmxpbmssCiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsCiAgICAgICAgICAgICAgICByZWFkZGlyOiBNRU1GUy5ub2RlX29wcy5yZWFkZGlyLAogICAgICAgICAgICAgICAgc3ltbGluazogTUVNRlMubm9kZV9vcHMuc3ltbGluaywKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHN0cmVhbTogeyBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZpbGU6IHsKICAgICAgICAgICAgICBub2RlOiB7IGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIgfSwKICAgICAgICAgICAgICBzdHJlYW06IHsKICAgICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWssCiAgICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsCiAgICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSwKICAgICAgICAgICAgICAgIGFsbG9jYXRlOiBNRU1GUy5zdHJlYW1fb3BzLmFsbG9jYXRlLAogICAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLAogICAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmMsCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbGluazogewogICAgICAgICAgICAgIG5vZGU6IHsKICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsCiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLAogICAgICAgICAgICAgICAgcmVhZGxpbms6IE1FTUZTLm5vZGVfb3BzLnJlYWRsaW5rLAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgc3RyZWFtOiB7fSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY2hyZGV2OiB7CiAgICAgICAgICAgICAgbm9kZTogeyBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLCBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyIH0sCiAgICAgICAgICAgICAgc3RyZWFtOiBGUy5jaHJkZXZfc3RyZWFtX29wcywKICAgICAgICAgICAgfSwKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7CiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHsKICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLm5vZGU7CiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTsKICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7CiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTsKICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTsKICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsOwogICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHsKICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5ub2RlOwogICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtOwogICAgICAgIH0gZWxzZSBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkgewogICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTsKICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtOwogICAgICAgIH0KICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7CiAgICAgICAgaWYgKHBhcmVudCkgewogICAgICAgICAgcGFyZW50LmNvbnRlbnRzW25hbWVdID0gbm9kZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5vZGUKICAgICAgfSwKICAgICAgZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheTogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICBpZiAobm9kZS5jb250ZW50cyAmJiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSB7CiAgICAgICAgICB2YXIgYXJyID0gW107CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUudXNlZEJ5dGVzOyArK2kpIGFyci5wdXNoKG5vZGUuY29udGVudHNbaV0pOwogICAgICAgICAgcmV0dXJuIGFycgogICAgICAgIH0KICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50cwogICAgICB9LAogICAgICBnZXRGaWxlRGF0YUFzVHlwZWRBcnJheTogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgpCiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKQogICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShub2RlLmNvbnRlbnRzKQogICAgICB9LAogICAgICBleHBhbmRGaWxlU3RvcmFnZTogZnVuY3Rpb24gKG5vZGUsIG5ld0NhcGFjaXR5KSB7CiAgICAgICAgaWYgKG5vZGUuY29udGVudHMgJiYgbm9kZS5jb250ZW50cy5zdWJhcnJheSAmJiBuZXdDYXBhY2l0eSA+IG5vZGUuY29udGVudHMubGVuZ3RoKSB7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gTUVNRlMuZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheShub2RlKTsKICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbm9kZS5jb250ZW50cy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIGlmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSB7CiAgICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDsKICAgICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgPj0gbmV3Q2FwYWNpdHkpIHJldHVybgogICAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0OwogICAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgKHByZXZDYXBhY2l0eSAqIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyIDogMS4xMjUpKSB8IDApOwogICAgICAgICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpOwogICAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50czsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7CiAgICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPiAwKSBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcyksIDApOwogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIGlmICghbm9kZS5jb250ZW50cyAmJiBuZXdDYXBhY2l0eSA+IDApIG5vZGUuY29udGVudHMgPSBbXTsKICAgICAgICB3aGlsZSAobm9kZS5jb250ZW50cy5sZW5ndGggPCBuZXdDYXBhY2l0eSkgbm9kZS5jb250ZW50cy5wdXNoKDApOwogICAgICB9LAogICAgICByZXNpemVGaWxlU3RvcmFnZTogZnVuY3Rpb24gKG5vZGUsIG5ld1NpemUpIHsKICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPT0gbmV3U2l6ZSkgcmV0dXJuCiAgICAgICAgaWYgKG5ld1NpemUgPT0gMCkgewogICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7CiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzIHx8IG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHsKICAgICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKG5ld1NpemUpKTsKICAgICAgICAgIGlmIChvbGRDb250ZW50cykgewogICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBNYXRoLm1pbihuZXdTaXplLCBub2RlLnVzZWRCeXRlcykpKTsKICAgICAgICAgIH0KICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTsKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIG5vZGUuY29udGVudHMgPSBbXTsKICAgICAgICBpZiAobm9kZS5jb250ZW50cy5sZW5ndGggPiBuZXdTaXplKSBub2RlLmNvbnRlbnRzLmxlbmd0aCA9IG5ld1NpemU7CiAgICAgICAgZWxzZSB3aGlsZSAobm9kZS5jb250ZW50cy5sZW5ndGggPCBuZXdTaXplKSBub2RlLmNvbnRlbnRzLnB1c2goMCk7CiAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplOwogICAgICB9LAogICAgICBub2RlX29wczogewogICAgICAgIGdldGF0dHI6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB2YXIgYXR0ciA9IHt9OwogICAgICAgICAgYXR0ci5kZXYgPSBGUy5pc0NocmRldihub2RlLm1vZGUpID8gbm9kZS5pZCA6IDE7CiAgICAgICAgICBhdHRyLmlubyA9IG5vZGUuaWQ7CiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7CiAgICAgICAgICBhdHRyLm5saW5rID0gMTsKICAgICAgICAgIGF0dHIudWlkID0gMDsKICAgICAgICAgIGF0dHIuZ2lkID0gMDsKICAgICAgICAgIGF0dHIucmRldiA9IG5vZGUucmRldjsKICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7CiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IG5vZGUudXNlZEJ5dGVzOwogICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkgewogICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLmxpbmsubGVuZ3RoOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYXR0ci5zaXplID0gMDsKICAgICAgICAgIH0KICAgICAgICAgIGF0dHIuYXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7CiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApOwogICAgICAgICAgYXR0ci5jdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTsKICAgICAgICAgIGF0dHIuYmxrc2l6ZSA9IDQwOTY7CiAgICAgICAgICBhdHRyLmJsb2NrcyA9IE1hdGguY2VpbChhdHRyLnNpemUgLyBhdHRyLmJsa3NpemUpOwogICAgICAgICAgcmV0dXJuIGF0dHIKICAgICAgICB9LAogICAgICAgIHNldGF0dHI6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7CiAgICAgICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGF0dHIudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhdHRyLnNpemUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLCBhdHRyLnNpemUpOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB0aHJvdyBGUy5nZW5lcmljRXJyb3JzW0VSUk5PX0NPREVTLkVOT0VOVF0KICAgICAgICB9LAogICAgICAgIG1rbm9kOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHsKICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KQogICAgICAgIH0sCiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7CiAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHsKICAgICAgICAgICAgdmFyIG5ld19ub2RlOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgICAgIGlmIChuZXdfbm9kZSkgewogICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07CiAgICAgICAgICBvbGRfbm9kZS5uYW1lID0gbmV3X25hbWU7CiAgICAgICAgICBuZXdfZGlyLmNvbnRlbnRzW25ld19uYW1lXSA9IG9sZF9ub2RlOwogICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjsKICAgICAgICB9LAogICAgICAgIHVubGluazogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkgewogICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTsKICAgICAgICB9LAogICAgICAgIHJtZGlyOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTsKICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5jb250ZW50cykgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URU1QVFkpCiAgICAgICAgICB9CiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdOwogICAgICAgIH0sCiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBlbnRyaWVzID0gWycuJywgJy4uJ107CiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykgewogICAgICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZW50cmllcy5wdXNoKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZW50cmllcwogICAgICAgIH0sCiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkgewogICAgICAgICAgdmFyIG5vZGUgPSBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmV3bmFtZSwgNTExIHwgNDA5NjAsIDApOwogICAgICAgICAgbm9kZS5saW5rID0gb2xkcGF0aDsKICAgICAgICAgIHJldHVybiBub2RlCiAgICAgICAgfSwKICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIGlmICghRlMuaXNMaW5rKG5vZGUubW9kZSkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5vZGUubGluawogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHN0cmVhbV9vcHM6IHsKICAgICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7CiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzKSByZXR1cm4gMAogICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMgLSBwb3NpdGlvbiwgbGVuZ3RoKTsKICAgICAgICAgIGFzc2VydChzaXplID49IDApOwogICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7CiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzaXplCiAgICAgICAgfSwKICAgICAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgewogICAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAwCiAgICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbS5ub2RlOwogICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHsKICAgICAgICAgICAgaWYgKGNhbk93bikgewogICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpOwogICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoOwogICAgICAgICAgICAgIHJldHVybiBsZW5ndGgKICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkgewogICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTsKICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDsKICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoCiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gKyBsZW5ndGggPD0gbm9kZS51c2VkQnl0ZXMpIHsKICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7CiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbiArIGxlbmd0aCk7CiAgICAgICAgICBpZiAobm9kZS5jb250ZW50cy5zdWJhcnJheSAmJiBidWZmZXIuc3ViYXJyYXkpCiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgbm9kZS5jb250ZW50c1twb3NpdGlvbiArIGldID0gYnVmZmVyW29mZnNldCArIGldOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KG5vZGUudXNlZEJ5dGVzLCBwb3NpdGlvbiArIGxlbmd0aCk7CiAgICAgICAgICByZXR1cm4gbGVuZ3RoCiAgICAgICAgfSwKICAgICAgICBsbHNlZWs6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7CiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQ7CiAgICAgICAgICBpZiAod2hlbmNlID09PSAxKSB7CiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjsKICAgICAgICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7CiAgICAgICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHBvc2l0aW9uCiAgICAgICAgfSwKICAgICAgICBhbGxvY2F0ZTogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLCBvZmZzZXQgKyBsZW5ndGgpOwogICAgICAgICAgc3RyZWFtLm5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgoc3RyZWFtLm5vZGUudXNlZEJ5dGVzLCBvZmZzZXQgKyBsZW5ndGgpOwogICAgICAgIH0sCiAgICAgICAgbW1hcDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7CiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcHRyOwogICAgICAgICAgdmFyIGFsbG9jYXRlZDsKICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzOwogICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiAoY29udGVudHMuYnVmZmVyID09PSBidWZmZXIgfHwgY29udGVudHMuYnVmZmVyID09PSBidWZmZXIuYnVmZmVyKSkgewogICAgICAgICAgICBhbGxvY2F0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IDAgfHwgcG9zaXRpb24gKyBsZW5ndGggPCBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHsKICAgICAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHsKICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cywgcG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYWxsb2NhdGVkID0gdHJ1ZTsKICAgICAgICAgICAgcHRyID0gX21hbGxvYyhsZW5ndGgpOwogICAgICAgICAgICBpZiAoIXB0cikgewogICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT01FTSkKICAgICAgICAgICAgfQogICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLCBwdHIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHsgcHRyOiBwdHIsIGFsbG9jYXRlZDogYWxsb2NhdGVkIH0KICAgICAgICB9LAogICAgICAgIG1zeW5jOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpIHsKICAgICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVikKICAgICAgICAgIH0KICAgICAgICAgIGlmIChtbWFwRmxhZ3MgJiAyKSB7CiAgICAgICAgICAgIHJldHVybiAwCiAgICAgICAgICB9CiAgICAgICAgICBNRU1GUy5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCAwLCBsZW5ndGgsIG9mZnNldCwgZmFsc2UpOwogICAgICAgICAgcmV0dXJuIDAKICAgICAgICB9LAogICAgICB9LAogICAgfTsKICAgIHZhciBJREJGUyA9IHsKICAgICAgZGJzOiB7fSwKICAgICAgaW5kZXhlZERCOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gaW5kZXhlZERCCiAgICAgICAgdmFyIHJldCA9IG51bGw7CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKQogICAgICAgICAgcmV0ID0gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCOwogICAgICAgIGFzc2VydChyZXQsICdJREJGUyB1c2VkLCBidXQgaW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQnKTsKICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0sCiAgICAgIERCX1ZFUlNJT046IDIxLAogICAgICBEQl9TVE9SRV9OQU1FOiAnRklMRV9EQVRBJywKICAgICAgbW91bnQ6IGZ1bmN0aW9uIChtb3VudCkgewogICAgICAgIHJldHVybiBNRU1GUy5tb3VudC5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICAgIH0sCiAgICAgIHN5bmNmczogZnVuY3Rpb24gKG1vdW50LCBwb3B1bGF0ZSwgY2FsbGJhY2spIHsKICAgICAgICBJREJGUy5nZXRMb2NhbFNldChtb3VudCwgZnVuY3Rpb24gKGVyciwgbG9jYWwpIHsKICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpCiAgICAgICAgICBJREJGUy5nZXRSZW1vdGVTZXQobW91bnQsIGZ1bmN0aW9uIChlcnIsIHJlbW90ZSkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKQogICAgICAgICAgICB2YXIgc3JjID0gcG9wdWxhdGUgPyByZW1vdGUgOiBsb2NhbDsKICAgICAgICAgICAgdmFyIGRzdCA9IHBvcHVsYXRlID8gbG9jYWwgOiByZW1vdGU7CiAgICAgICAgICAgIElEQkZTLnJlY29uY2lsZShzcmMsIGRzdCwgY2FsbGJhY2spOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0sCiAgICAgIGdldERCOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsKICAgICAgICB2YXIgZGIgPSBJREJGUy5kYnNbbmFtZV07CiAgICAgICAgaWYgKGRiKSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGIpCiAgICAgICAgfQogICAgICAgIHZhciByZXE7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHJlcSA9IElEQkZTLmluZGV4ZWREQigpLm9wZW4obmFtZSwgSURCRlMuREJfVkVSU0lPTik7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpCiAgICAgICAgfQogICAgICAgIGlmICghcmVxKSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ1VuYWJsZSB0byBjb25uZWN0IHRvIEluZGV4ZWREQicpCiAgICAgICAgfQogICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkgewogICAgICAgICAgdmFyIGRiID0gZS50YXJnZXQucmVzdWx0OwogICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZS50YXJnZXQudHJhbnNhY3Rpb247CiAgICAgICAgICB2YXIgZmlsZVN0b3JlOwogICAgICAgICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoSURCRlMuREJfU1RPUkVfTkFNRSkpIHsKICAgICAgICAgICAgZmlsZVN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmaWxlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShJREJGUy5EQl9TVE9SRV9OQU1FKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICghZmlsZVN0b3JlLmluZGV4TmFtZXMuY29udGFpbnMoJ3RpbWVzdGFtcCcpKSB7CiAgICAgICAgICAgIGZpbGVTdG9yZS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcsIHsgdW5pcXVlOiBmYWxzZSB9KTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBkYiA9IHJlcS5yZXN1bHQ7CiAgICAgICAgICBJREJGUy5kYnNbbmFtZV0gPSBkYjsKICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRiKTsKICAgICAgICB9OwogICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3IpOwogICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIH07CiAgICAgIH0sCiAgICAgIGdldExvY2FsU2V0OiBmdW5jdGlvbiAobW91bnQsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGVudHJpZXMgPSB7fTsKICAgICAgICBmdW5jdGlvbiBpc1JlYWxEaXIocCkgewogICAgICAgICAgcmV0dXJuIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nCiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHRvQWJzb2x1dGUocm9vdCkgewogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7CiAgICAgICAgICAgIHJldHVybiBQQVRILmpvaW4yKHJvb3QsIHApCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHZhciBjaGVjayA9IEZTLnJlYWRkaXIobW91bnQubW91bnRwb2ludCkuZmlsdGVyKGlzUmVhbERpcikubWFwKHRvQWJzb2x1dGUobW91bnQubW91bnRwb2ludCkpOwogICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHsKICAgICAgICAgIHZhciBwYXRoID0gY2hlY2sucG9wKCk7CiAgICAgICAgICB2YXIgc3RhdDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHN0YXQgPSBGUy5zdGF0KHBhdGgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSkKICAgICAgICAgIH0KICAgICAgICAgIGlmIChGUy5pc0RpcihzdGF0Lm1vZGUpKSB7CiAgICAgICAgICAgIGNoZWNrLnB1c2guYXBwbHkoY2hlY2ssIEZTLnJlYWRkaXIocGF0aCkuZmlsdGVyKGlzUmVhbERpcikubWFwKHRvQWJzb2x1dGUocGF0aCkpKTsKICAgICAgICAgIH0KICAgICAgICAgIGVudHJpZXNbcGF0aF0gPSB7IHRpbWVzdGFtcDogc3RhdC5tdGltZSB9OwogICAgICAgIH0KICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgeyB0eXBlOiAnbG9jYWwnLCBlbnRyaWVzOiBlbnRyaWVzIH0pCiAgICAgIH0sCiAgICAgIGdldFJlbW90ZVNldDogZnVuY3Rpb24gKG1vdW50LCBjYWxsYmFjaykgewogICAgICAgIHZhciBlbnRyaWVzID0ge307CiAgICAgICAgSURCRlMuZ2V0REIobW91bnQubW91bnRwb2ludCwgZnVuY3Rpb24gKGVyciwgZGIpIHsKICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpCiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbSURCRlMuREJfU1RPUkVfTkFNRV0sICdyZWFkb25seScpOwogICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLmVycm9yKTsKICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpOwogICAgICAgICAgICB2YXIgaW5kZXggPSBzdG9yZS5pbmRleCgndGltZXN0YW1wJyk7CiAgICAgICAgICAgIGluZGV4Lm9wZW5LZXlDdXJzb3IoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDsKICAgICAgICAgICAgICBpZiAoIWN1cnNvcikgewogICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgdHlwZTogJ3JlbW90ZScsIGRiOiBkYiwgZW50cmllczogZW50cmllcyB9KQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbnRyaWVzW2N1cnNvci5wcmltYXJ5S2V5XSA9IHsgdGltZXN0YW1wOiBjdXJzb3Iua2V5IH07CiAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKQogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9LAogICAgICBsb2FkTG9jYWxFbnRyeTogZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHN0YXQsIG5vZGU7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgpOwogICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgc3RhdCA9IEZTLnN0YXQocGF0aCk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc0RpcihzdGF0Lm1vZGUpKSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgeyB0aW1lc3RhbXA6IHN0YXQubXRpbWUsIG1vZGU6IHN0YXQubW9kZSB9KQogICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKHN0YXQubW9kZSkpIHsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSBNRU1GUy5nZXRGaWxlRGF0YUFzVHlwZWRBcnJheShub2RlKTsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IHRpbWVzdGFtcDogc3RhdC5tdGltZSwgbW9kZTogc3RhdC5tb2RlLCBjb250ZW50czogbm9kZS5jb250ZW50cyB9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdub2RlIHR5cGUgbm90IHN1cHBvcnRlZCcpKQogICAgICAgIH0KICAgICAgfSwKICAgICAgc3RvcmVMb2NhbEVudHJ5OiBmdW5jdGlvbiAocGF0aCwgZW50cnksIGNhbGxiYWNrKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChGUy5pc0RpcihlbnRyeS5tb2RlKSkgewogICAgICAgICAgICBGUy5ta2RpcihwYXRoLCBlbnRyeS5tb2RlKTsKICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKGVudHJ5Lm1vZGUpKSB7CiAgICAgICAgICAgIEZTLndyaXRlRmlsZShwYXRoLCBlbnRyeS5jb250ZW50cywgeyBjYW5Pd246IHRydWUgfSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdub2RlIHR5cGUgbm90IHN1cHBvcnRlZCcpKQogICAgICAgICAgfQogICAgICAgICAgRlMuY2htb2QocGF0aCwgZW50cnkubW9kZSk7CiAgICAgICAgICBGUy51dGltZShwYXRoLCBlbnRyeS50aW1lc3RhbXAsIGVudHJ5LnRpbWVzdGFtcCk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpCiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG51bGwpOwogICAgICB9LAogICAgICByZW1vdmVMb2NhbEVudHJ5OiBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2spIHsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCk7CiAgICAgICAgICB2YXIgc3RhdCA9IEZTLnN0YXQocGF0aCk7CiAgICAgICAgICBpZiAoRlMuaXNEaXIoc3RhdC5tb2RlKSkgewogICAgICAgICAgICBGUy5ybWRpcihwYXRoKTsKICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKHN0YXQubW9kZSkpIHsKICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKQogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgfSwKICAgICAgbG9hZFJlbW90ZUVudHJ5OiBmdW5jdGlvbiAoc3RvcmUsIHBhdGgsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmdldChwYXRoKTsKICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7CiAgICAgICAgICBjYWxsYmFjayhudWxsLCBldmVudC50YXJnZXQucmVzdWx0KTsKICAgICAgICB9OwogICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3IpOwogICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIH07CiAgICAgIH0sCiAgICAgIHN0b3JlUmVtb3RlRW50cnk6IGZ1bmN0aW9uIChzdG9yZSwgcGF0aCwgZW50cnksIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHJlcSA9IHN0b3JlLnB1dChlbnRyeSwgcGF0aCk7CiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGNhbGxiYWNrKG51bGwpOwogICAgICAgIH07CiAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkgewogICAgICAgICAgY2FsbGJhY2sodGhpcy5lcnJvcik7CiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgfTsKICAgICAgfSwKICAgICAgcmVtb3ZlUmVtb3RlRW50cnk6IGZ1bmN0aW9uIChzdG9yZSwgcGF0aCwgY2FsbGJhY2spIHsKICAgICAgICB2YXIgcmVxID0gc3RvcmUuZGVsZXRlKHBhdGgpOwogICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICB9OwogICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3IpOwogICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIH07CiAgICAgIH0sCiAgICAgIHJlY29uY2lsZTogZnVuY3Rpb24gKHNyYywgZHN0LCBjYWxsYmFjaykgewogICAgICAgIHZhciB0b3RhbCA9IDA7CiAgICAgICAgdmFyIGNyZWF0ZSA9IFtdOwogICAgICAgIE9iamVjdC5rZXlzKHNyYy5lbnRyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICAgIHZhciBlID0gc3JjLmVudHJpZXNba2V5XTsKICAgICAgICAgIHZhciBlMiA9IGRzdC5lbnRyaWVzW2tleV07CiAgICAgICAgICBpZiAoIWUyIHx8IGUudGltZXN0YW1wID4gZTIudGltZXN0YW1wKSB7CiAgICAgICAgICAgIGNyZWF0ZS5wdXNoKGtleSk7CiAgICAgICAgICAgIHRvdGFsKys7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgdmFyIHJlbW92ZSA9IFtdOwogICAgICAgIE9iamVjdC5rZXlzKGRzdC5lbnRyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICAgIGRzdC5lbnRyaWVzW2tleV07CiAgICAgICAgICB2YXIgZTIgPSBzcmMuZW50cmllc1trZXldOwogICAgICAgICAgaWYgKCFlMikgewogICAgICAgICAgICByZW1vdmUucHVzaChrZXkpOwogICAgICAgICAgICB0b3RhbCsrOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGlmICghdG90YWwpIHsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKQogICAgICAgIH0KICAgICAgICB2YXIgY29tcGxldGVkID0gMDsKICAgICAgICB2YXIgZGIgPSBzcmMudHlwZSA9PT0gJ3JlbW90ZScgPyBzcmMuZGIgOiBkc3QuZGI7CiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0lEQkZTLkRCX1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7CiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSk7CiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHsKICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHsKICAgICAgICAgICAgICBkb25lLmVycm9yZWQgPSB0cnVlOwogICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKytjb21wbGV0ZWQgPj0gdG90YWwpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkgewogICAgICAgICAgZG9uZSh0aGlzLmVycm9yKTsKICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICB9OwogICAgICAgIGNyZWF0ZS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkgewogICAgICAgICAgaWYgKGRzdC50eXBlID09PSAnbG9jYWwnKSB7CiAgICAgICAgICAgIElEQkZTLmxvYWRSZW1vdGVFbnRyeShzdG9yZSwgcGF0aCwgZnVuY3Rpb24gKGVyciwgZW50cnkpIHsKICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpCiAgICAgICAgICAgICAgSURCRlMuc3RvcmVMb2NhbEVudHJ5KHBhdGgsIGVudHJ5LCBkb25lKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBJREJGUy5sb2FkTG9jYWxFbnRyeShwYXRoLCBmdW5jdGlvbiAoZXJyLCBlbnRyeSkgewogICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycikKICAgICAgICAgICAgICBJREJGUy5zdG9yZVJlbW90ZUVudHJ5KHN0b3JlLCBwYXRoLCBlbnRyeSwgZG9uZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJlbW92ZQogICAgICAgICAgLnNvcnQoKQogICAgICAgICAgLnJldmVyc2UoKQogICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICAgICAgaWYgKGRzdC50eXBlID09PSAnbG9jYWwnKSB7CiAgICAgICAgICAgICAgSURCRlMucmVtb3ZlTG9jYWxFbnRyeShwYXRoLCBkb25lKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBJREJGUy5yZW1vdmVSZW1vdGVFbnRyeShzdG9yZSwgcGF0aCwgZG9uZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICB9LAogICAgfTsKICAgIHZhciBOT0RFRlMgPSB7CiAgICAgIGlzV2luZG93czogZmFsc2UsCiAgICAgIHN0YXRpY0luaXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICBOT0RFRlMuaXNXaW5kb3dzID0gISFwcm9jZXNzLnBsYXRmb3JtLm1hdGNoKC9ed2luLyk7CiAgICAgICAgdmFyIGZsYWdzID0gcHJvY2Vzc1snYmluZGluZyddKCdjb25zdGFudHMnKTsKICAgICAgICBpZiAoZmxhZ3NbJ2ZzJ10pIHsKICAgICAgICAgIGZsYWdzID0gZmxhZ3NbJ2ZzJ107CiAgICAgICAgfQogICAgICAgIE5PREVGUy5mbGFnc0Zvck5vZGVNYXAgPSB7CiAgICAgICAgICAxMDI0OiBmbGFnc1snT19BUFBFTkQnXSwKICAgICAgICAgIDY0OiBmbGFnc1snT19DUkVBVCddLAogICAgICAgICAgMTI4OiBmbGFnc1snT19FWENMJ10sCiAgICAgICAgICAwOiBmbGFnc1snT19SRE9OTFknXSwKICAgICAgICAgIDI6IGZsYWdzWydPX1JEV1InXSwKICAgICAgICAgIDQwOTY6IGZsYWdzWydPX1NZTkMnXSwKICAgICAgICAgIDUxMjogZmxhZ3NbJ09fVFJVTkMnXSwKICAgICAgICAgIDE6IGZsYWdzWydPX1dST05MWSddLAogICAgICAgIH07CiAgICAgIH0sCiAgICAgIGJ1ZmZlckZyb206IGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikgewogICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikgOiBuZXcgQnVmZmVyKGFycmF5QnVmZmVyKQogICAgICB9LAogICAgICBtb3VudDogZnVuY3Rpb24gKG1vdW50KSB7CiAgICAgICAgYXNzZXJ0KEVOVklST05NRU5UX0lTX05PREUpOwogICAgICAgIHJldHVybiBOT0RFRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIE5PREVGUy5nZXRNb2RlKG1vdW50Lm9wdHMucm9vdCksIDApCiAgICAgIH0sCiAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikgewogICAgICAgIGlmICghRlMuaXNEaXIobW9kZSkgJiYgIUZTLmlzRmlsZShtb2RlKSAmJiAhRlMuaXNMaW5rKG1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUpOwogICAgICAgIG5vZGUubm9kZV9vcHMgPSBOT0RFRlMubm9kZV9vcHM7CiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTk9ERUZTLnN0cmVhbV9vcHM7CiAgICAgICAgcmV0dXJuIG5vZGUKICAgICAgfSwKICAgICAgZ2V0TW9kZTogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICB2YXIgc3RhdDsKICAgICAgICB0cnkgewogICAgICAgICAgc3RhdCA9IGZzLmxzdGF0U3luYyhwYXRoKTsKICAgICAgICAgIGlmIChOT0RFRlMuaXNXaW5kb3dzKSB7CiAgICAgICAgICAgIHN0YXQubW9kZSA9IHN0YXQubW9kZSB8ICgoc3RhdC5tb2RlICYgMjkyKSA+PiAyKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0YXQubW9kZQogICAgICB9LAogICAgICByZWFsUGF0aDogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICB2YXIgcGFydHMgPSBbXTsKICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnQgIT09IG5vZGUpIHsKICAgICAgICAgIHBhcnRzLnB1c2gobm9kZS5uYW1lKTsKICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDsKICAgICAgICB9CiAgICAgICAgcGFydHMucHVzaChub2RlLm1vdW50Lm9wdHMucm9vdCk7CiAgICAgICAgcGFydHMucmV2ZXJzZSgpOwogICAgICAgIHJldHVybiBQQVRILmpvaW4uYXBwbHkobnVsbCwgcGFydHMpCiAgICAgIH0sCiAgICAgIGZsYWdzRm9yTm9kZTogZnVuY3Rpb24gKGZsYWdzKSB7CiAgICAgICAgZmxhZ3MgJj0gfjIwOTcxNTI7CiAgICAgICAgZmxhZ3MgJj0gfjIwNDg7CiAgICAgICAgZmxhZ3MgJj0gfjMyNzY4OwogICAgICAgIGZsYWdzICY9IH41MjQyODg7CiAgICAgICAgdmFyIG5ld0ZsYWdzID0gMDsKICAgICAgICBmb3IgKHZhciBrIGluIE5PREVGUy5mbGFnc0Zvck5vZGVNYXApIHsKICAgICAgICAgIGlmIChmbGFncyAmIGspIHsKICAgICAgICAgICAgbmV3RmxhZ3MgfD0gTk9ERUZTLmZsYWdzRm9yTm9kZU1hcFtrXTsKICAgICAgICAgICAgZmxhZ3MgXj0gazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKCFmbGFncykgewogICAgICAgICAgcmV0dXJuIG5ld0ZsYWdzCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgIH0sCiAgICAgIG5vZGVfb3BzOiB7CiAgICAgICAgZ2V0YXR0cjogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBwYXRoID0gTk9ERUZTLnJlYWxQYXRoKG5vZGUpOwogICAgICAgICAgdmFyIHN0YXQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzdGF0ID0gZnMubHN0YXRTeW5jKHBhdGgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgICAgaWYgKE5PREVGUy5pc1dpbmRvd3MgJiYgIXN0YXQuYmxrc2l6ZSkgewogICAgICAgICAgICBzdGF0LmJsa3NpemUgPSA0MDk2OwogICAgICAgICAgfQogICAgICAgICAgaWYgKE5PREVGUy5pc1dpbmRvd3MgJiYgIXN0YXQuYmxvY2tzKSB7CiAgICAgICAgICAgIHN0YXQuYmxvY2tzID0gKChzdGF0LnNpemUgKyBzdGF0LmJsa3NpemUgLSAxKSAvIHN0YXQuYmxrc2l6ZSkgfCAwOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZGV2OiBzdGF0LmRldiwKICAgICAgICAgICAgaW5vOiBzdGF0LmlubywKICAgICAgICAgICAgbW9kZTogc3RhdC5tb2RlLAogICAgICAgICAgICBubGluazogc3RhdC5ubGluaywKICAgICAgICAgICAgdWlkOiBzdGF0LnVpZCwKICAgICAgICAgICAgZ2lkOiBzdGF0LmdpZCwKICAgICAgICAgICAgcmRldjogc3RhdC5yZGV2LAogICAgICAgICAgICBzaXplOiBzdGF0LnNpemUsCiAgICAgICAgICAgIGF0aW1lOiBzdGF0LmF0aW1lLAogICAgICAgICAgICBtdGltZTogc3RhdC5tdGltZSwKICAgICAgICAgICAgY3RpbWU6IHN0YXQuY3RpbWUsCiAgICAgICAgICAgIGJsa3NpemU6IHN0YXQuYmxrc2l6ZSwKICAgICAgICAgICAgYmxvY2tzOiBzdGF0LmJsb2NrcywKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNldGF0dHI6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IE5PREVGUy5yZWFsUGF0aChub2RlKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIGZzLmNobW9kU3luYyhwYXRoLCBhdHRyLm1vZGUpOwogICAgICAgICAgICAgIG5vZGUubW9kZSA9IGF0dHIubW9kZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoYXR0ci50aW1lc3RhbXApOwogICAgICAgICAgICAgIGZzLnV0aW1lc1N5bmMocGF0aCwgZGF0ZSwgZGF0ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgZnMudHJ1bmNhdGVTeW5jKHBhdGgsIGF0dHIuc2l6ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGxvb2t1cDogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkgewogICAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLCBuYW1lKTsKICAgICAgICAgIHZhciBtb2RlID0gTk9ERUZTLmdldE1vZGUocGF0aCk7CiAgICAgICAgICByZXR1cm4gTk9ERUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlKQogICAgICAgIH0sCiAgICAgICAgbWtub2Q6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikgewogICAgICAgICAgdmFyIG5vZGUgPSBOT0RFRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7CiAgICAgICAgICB2YXIgcGF0aCA9IE5PREVGUy5yZWFsUGF0aChub2RlKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGgsIG5vZGUubW9kZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCAnJywgeyBtb2RlOiBub2RlLm1vZGUgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBub2RlCiAgICAgICAgfSwKICAgICAgICByZW5hbWU6IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdEaXIsIG5ld05hbWUpIHsKICAgICAgICAgIHZhciBvbGRQYXRoID0gTk9ERUZTLnJlYWxQYXRoKG9sZE5vZGUpOwogICAgICAgICAgdmFyIG5ld1BhdGggPSBQQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChuZXdEaXIpLCBuZXdOYW1lKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB1bmxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSwgbmFtZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmcy51bmxpbmtTeW5jKHBhdGgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSwgbmFtZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmcy5ybWRpclN5bmMocGF0aCk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICByZWFkZGlyOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgICAgdmFyIHBhdGggPSBOT0RFRlMucmVhbFBhdGgobm9kZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gZnMucmVhZGRpclN5bmMocGF0aCkKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHN5bWxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5ld05hbWUsIG9sZFBhdGgpIHsKICAgICAgICAgIHZhciBuZXdQYXRoID0gUEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSwgbmV3TmFtZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmcy5zeW1saW5rU3luYyhvbGRQYXRoLCBuZXdQYXRoKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJlYWRsaW5rOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgICAgdmFyIHBhdGggPSBOT0RFRlMucmVhbFBhdGgobm9kZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBwYXRoID0gZnMucmVhZGxpbmtTeW5jKHBhdGgpOwogICAgICAgICAgICBwYXRoID0gTk9ERUpTX1BBVEgucmVsYXRpdmUoTk9ERUpTX1BBVEgucmVzb2x2ZShub2RlLm1vdW50Lm9wdHMucm9vdCksIHBhdGgpOwogICAgICAgICAgICByZXR1cm4gcGF0aAogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHN0cmVhbV9vcHM6IHsKICAgICAgICBvcGVuOiBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IE5PREVGUy5yZWFsUGF0aChzdHJlYW0ubm9kZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICAgICAgc3RyZWFtLm5mZCA9IGZzLm9wZW5TeW5jKHBhdGgsIE5PREVGUy5mbGFnc0Zvck5vZGUoc3RyZWFtLmZsYWdzKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpICYmIHN0cmVhbS5uZmQpIHsKICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoc3RyZWFtLm5mZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7CiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMAogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWRTeW5jKHN0cmVhbS5uZmQsIE5PREVGUy5idWZmZXJGcm9tKGJ1ZmZlci5idWZmZXIpLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBmcy53cml0ZVN5bmMoc3RyZWFtLm5mZCwgTk9ERUZTLmJ1ZmZlckZyb20oYnVmZmVyLmJ1ZmZlciksIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGxsc2VlazogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHsKICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9mZnNldDsKICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHsKICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLnBvc2l0aW9uOwogICAgICAgICAgfSBlbHNlIGlmICh3aGVuY2UgPT09IDIpIHsKICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICB2YXIgc3RhdCA9IGZzLmZzdGF0U3luYyhzdHJlYW0ubmZkKTsKICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0YXQuc2l6ZTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcG9zaXRpb24KICAgICAgICB9LAogICAgICB9LAogICAgfTsKICAgIHZhciBXT1JLRVJGUyA9IHsKICAgICAgRElSX01PREU6IDE2ODk1LAogICAgICBGSUxFX01PREU6IDMzMjc5LAogICAgICByZWFkZXI6IG51bGwsCiAgICAgIG1vdW50OiBmdW5jdGlvbiAobW91bnQpIHsKICAgICAgICBhc3NlcnQoRU5WSVJPTk1FTlRfSVNfV09SS0VSKTsKICAgICAgICBpZiAoIVdPUktFUkZTLnJlYWRlcikgV09SS0VSRlMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXJTeW5jKCk7CiAgICAgICAgdmFyIHJvb3QgPSBXT1JLRVJGUy5jcmVhdGVOb2RlKG51bGwsICcvJywgV09SS0VSRlMuRElSX01PREUsIDApOwogICAgICAgIHZhciBjcmVhdGVkUGFyZW50cyA9IHt9OwogICAgICAgIGZ1bmN0aW9uIGVuc3VyZVBhcmVudChwYXRoKSB7CiAgICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7CiAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdDsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgICAgICAgIHZhciBjdXJyID0gcGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy8nKTsKICAgICAgICAgICAgaWYgKCFjcmVhdGVkUGFyZW50c1tjdXJyXSkgewogICAgICAgICAgICAgIGNyZWF0ZWRQYXJlbnRzW2N1cnJdID0gV09SS0VSRlMuY3JlYXRlTm9kZShwYXJlbnQsIHBhcnRzW2ldLCBXT1JLRVJGUy5ESVJfTU9ERSwgMCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcGFyZW50ID0gY3JlYXRlZFBhcmVudHNbY3Vycl07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcGFyZW50CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGJhc2UocGF0aCkgewogICAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpOwogICAgICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdCiAgICAgICAgfQogICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobW91bnQub3B0c1snZmlsZXMnXSB8fCBbXSwgZnVuY3Rpb24gKGZpbGUpIHsKICAgICAgICAgIFdPUktFUkZTLmNyZWF0ZU5vZGUoCiAgICAgICAgICAgIGVuc3VyZVBhcmVudChmaWxlLm5hbWUpLAogICAgICAgICAgICBiYXNlKGZpbGUubmFtZSksCiAgICAgICAgICAgIFdPUktFUkZTLkZJTEVfTU9ERSwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgZmlsZSwKICAgICAgICAgICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlCiAgICAgICAgICApOwogICAgICAgIH0pCiAgICAgICAgOyhtb3VudC5vcHRzWydibG9icyddIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHsKICAgICAgICAgIFdPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KG9ialsnbmFtZSddKSwgYmFzZShvYmpbJ25hbWUnXSksIFdPUktFUkZTLkZJTEVfTU9ERSwgMCwgb2JqWydkYXRhJ10pOwogICAgICAgIH0pCiAgICAgICAgOyhtb3VudC5vcHRzWydwYWNrYWdlcyddIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChwYWNrKSB7CiAgICAgICAgICBwYWNrWydtZXRhZGF0YSddLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHsKICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWxlLmZpbGVuYW1lLnN1YnN0cigxKTsKICAgICAgICAgICAgV09SS0VSRlMuY3JlYXRlTm9kZSgKICAgICAgICAgICAgICBlbnN1cmVQYXJlbnQobmFtZSksCiAgICAgICAgICAgICAgYmFzZShuYW1lKSwKICAgICAgICAgICAgICBXT1JLRVJGUy5GSUxFX01PREUsCiAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICBwYWNrWydibG9iJ10uc2xpY2UoZmlsZS5zdGFydCwgZmlsZS5lbmQpCiAgICAgICAgICAgICk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gcm9vdAogICAgICB9LAogICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYsIGNvbnRlbnRzLCBtdGltZSkgewogICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUpOwogICAgICAgIG5vZGUubW9kZSA9IG1vZGU7CiAgICAgICAgbm9kZS5ub2RlX29wcyA9IFdPUktFUkZTLm5vZGVfb3BzOwogICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IFdPUktFUkZTLnN0cmVhbV9vcHM7CiAgICAgICAgbm9kZS50aW1lc3RhbXAgPSAobXRpbWUgfHwgbmV3IERhdGUoKSkuZ2V0VGltZSgpOwogICAgICAgIGFzc2VydChXT1JLRVJGUy5GSUxFX01PREUgIT09IFdPUktFUkZTLkRJUl9NT0RFKTsKICAgICAgICBpZiAobW9kZSA9PT0gV09SS0VSRlMuRklMRV9NT0RFKSB7CiAgICAgICAgICBub2RlLnNpemUgPSBjb250ZW50cy5zaXplOwogICAgICAgICAgbm9kZS5jb250ZW50cyA9IGNvbnRlbnRzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBub2RlLnNpemUgPSA0MDk2OwogICAgICAgICAgbm9kZS5jb250ZW50cyA9IHt9OwogICAgICAgIH0KICAgICAgICBpZiAocGFyZW50KSB7CiAgICAgICAgICBwYXJlbnQuY29udGVudHNbbmFtZV0gPSBub2RlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbm9kZQogICAgICB9LAogICAgICBub2RlX29wczogewogICAgICAgIGdldGF0dHI6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBkZXY6IDEsCiAgICAgICAgICAgIGlubzogdW5kZWZpbmVkLAogICAgICAgICAgICBtb2RlOiBub2RlLm1vZGUsCiAgICAgICAgICAgIG5saW5rOiAxLAogICAgICAgICAgICB1aWQ6IDAsCiAgICAgICAgICAgIGdpZDogMCwKICAgICAgICAgICAgcmRldjogdW5kZWZpbmVkLAogICAgICAgICAgICBzaXplOiBub2RlLnNpemUsCiAgICAgICAgICAgIGF0aW1lOiBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksCiAgICAgICAgICAgIG10aW1lOiBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksCiAgICAgICAgICAgIGN0aW1lOiBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksCiAgICAgICAgICAgIGJsa3NpemU6IDQwOTYsCiAgICAgICAgICAgIGJsb2NrczogTWF0aC5jZWlsKG5vZGUuc2l6ZSAvIDQwOTYpLAogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgc2V0YXR0cjogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsKICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wOwogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfSwKICAgICAgICBta25vZDogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9LAogICAgICAgIHJlbmFtZTogZnVuY3Rpb24gKG9sZE5vZGUsIG5ld0RpciwgbmV3TmFtZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfSwKICAgICAgICB1bmxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0sCiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0sCiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBlbnRyaWVzID0gWycuJywgJy4uJ107CiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykgewogICAgICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZW50cmllcy5wdXNoKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZW50cmllcwogICAgICAgIH0sCiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHBhcmVudCwgbmV3TmFtZSwgb2xkUGF0aCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfSwKICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHN0cmVhbV9vcHM6IHsKICAgICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnNpemUpIHJldHVybiAwCiAgICAgICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ubm9kZS5jb250ZW50cy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpOwogICAgICAgICAgdmFyIGFiID0gV09SS0VSRlMucmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTsKICAgICAgICAgIGJ1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYWIpLCBvZmZzZXQpOwogICAgICAgICAgcmV0dXJuIGNodW5rLnNpemUKICAgICAgICB9LAogICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKQogICAgICAgIH0sCiAgICAgICAgbGxzZWVrOiBmdW5jdGlvbiAoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgewogICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0OwogICAgICAgICAgaWYgKHdoZW5jZSA9PT0gMSkgewogICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247CiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikgewogICAgICAgICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUuc2l6ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcG9zaXRpb24KICAgICAgICB9LAogICAgICB9LAogICAgfTsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIHZhciBGUyA9IHsKICAgICAgcm9vdDogbnVsbCwKICAgICAgbW91bnRzOiBbXSwKICAgICAgZGV2aWNlczoge30sCiAgICAgIHN0cmVhbXM6IFtdLAogICAgICBuZXh0SW5vZGU6IDEsCiAgICAgIG5hbWVUYWJsZTogbnVsbCwKICAgICAgY3VycmVudFBhdGg6ICcvJywKICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLAogICAgICBpZ25vcmVQZXJtaXNzaW9uczogdHJ1ZSwKICAgICAgdHJhY2tpbmdEZWxlZ2F0ZToge30sCiAgICAgIHRyYWNraW5nOiB7IG9wZW5GbGFnczogeyBSRUFEOiAxLCBXUklURTogMiB9IH0sCiAgICAgIEVycm5vRXJyb3I6IG51bGwsCiAgICAgIGdlbmVyaWNFcnJvcnM6IHt9LAogICAgICBmaWxlc3lzdGVtczogbnVsbCwKICAgICAgc3luY0ZTUmVxdWVzdHM6IDAsCiAgICAgIGhhbmRsZUZTRXJyb3I6IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlICsgJyA6ICcgKyBzdGFja1RyYWNlKCkKICAgICAgICByZXR1cm4gX19fc2V0RXJyTm8oZS5lcnJubykKICAgICAgfSwKICAgICAgbG9va3VwUGF0aDogZnVuY3Rpb24gKHBhdGgsIG9wdHMpIHsKICAgICAgICBwYXRoID0gUEFUSC5yZXNvbHZlKEZTLmN3ZCgpLCBwYXRoKTsKICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTsKICAgICAgICBpZiAoIXBhdGgpIHJldHVybiB7IHBhdGg6ICcnLCBub2RlOiBudWxsIH0KICAgICAgICB2YXIgZGVmYXVsdHMgPSB7IGZvbGxvd19tb3VudDogdHJ1ZSwgcmVjdXJzZV9jb3VudDogMCB9OwogICAgICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykgewogICAgICAgICAgaWYgKG9wdHNba2V5XSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG9wdHNba2V5XSA9IGRlZmF1bHRzW2tleV07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTE9PUCkKICAgICAgICB9CiAgICAgICAgdmFyIHBhcnRzID0gUEFUSC5ub3JtYWxpemVBcnJheSgKICAgICAgICAgIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHApIHsKICAgICAgICAgICAgcmV0dXJuICEhcAogICAgICAgICAgfSksCiAgICAgICAgICBmYWxzZQogICAgICAgICk7CiAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290OwogICAgICAgIHZhciBjdXJyZW50X3BhdGggPSAnLyc7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIGlzbGFzdCA9IGkgPT09IHBhcnRzLmxlbmd0aCAtIDE7CiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICB9CiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7CiAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILmpvaW4yKGN1cnJlbnRfcGF0aCwgcGFydHNbaV0pOwogICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSkgewogICAgICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkgewogICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKCFpc2xhc3QgfHwgb3B0cy5mb2xsb3cpIHsKICAgICAgICAgICAgdmFyIGNvdW50ID0gMDsKICAgICAgICAgICAgd2hpbGUgKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKSB7CiAgICAgICAgICAgICAgdmFyIGxpbmsgPSBGUy5yZWFkbGluayhjdXJyZW50X3BhdGgpOwogICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEgucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7CiAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7IHJlY3Vyc2VfY291bnQ6IG9wdHMucmVjdXJzZV9jb3VudCB9KTsKICAgICAgICAgICAgICBjdXJyZW50ID0gbG9va3VwLm5vZGU7CiAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUxPT1ApCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiB7IHBhdGg6IGN1cnJlbnRfcGF0aCwgbm9kZTogY3VycmVudCB9CiAgICAgIH0sCiAgICAgIGdldFBhdGg6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgdmFyIHBhdGg7CiAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkpIHsKICAgICAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudC5tb3VudHBvaW50OwogICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBtb3VudAogICAgICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoIC0gMV0gIT09ICcvJyA/IG1vdW50ICsgJy8nICsgcGF0aCA6IG1vdW50ICsgcGF0aAogICAgICAgICAgfQogICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lOwogICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50OwogICAgICAgIH0KICAgICAgfSwKICAgICAgaGFzaE5hbWU6IGZ1bmN0aW9uIChwYXJlbnRpZCwgbmFtZSkgewogICAgICAgIHZhciBoYXNoID0gMDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZS5jaGFyQ29kZUF0KGkpKSB8IDA7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoKHBhcmVudGlkICsgaGFzaCkgPj4+IDApICUgRlMubmFtZVRhYmxlLmxlbmd0aAogICAgICB9LAogICAgICBoYXNoQWRkTm9kZTogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpOwogICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdOwogICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGU7CiAgICAgIH0sCiAgICAgIGhhc2hSZW1vdmVOb2RlOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7CiAgICAgICAgaWYgKEZTLm5hbWVUYWJsZVtoYXNoXSA9PT0gbm9kZSkgewogICAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZS5uYW1lX25leHQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdOwogICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHsKICAgICAgICAgICAgaWYgKGN1cnJlbnQubmFtZV9uZXh0ID09PSBub2RlKSB7CiAgICAgICAgICAgICAgY3VycmVudC5uYW1lX25leHQgPSBub2RlLm5hbWVfbmV4dDsKICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICB9CiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIGxvb2t1cE5vZGU6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICB2YXIgZXJyID0gRlMubWF5TG9va3VwKHBhcmVudCk7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyLCBwYXJlbnQpCiAgICAgICAgfQogICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUocGFyZW50LmlkLCBuYW1lKTsKICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHsKICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTsKICAgICAgICAgIGlmIChub2RlLnBhcmVudC5pZCA9PT0gcGFyZW50LmlkICYmIG5vZGVOYW1lID09PSBuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiBub2RlCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKQogICAgICB9LAogICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7CiAgICAgICAgaWYgKCFGUy5GU05vZGUpIHsKICAgICAgICAgIEZTLkZTTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHsKICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHsKICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50OwogICAgICAgICAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50OwogICAgICAgICAgICB0aGlzLm1vdW50ZWQgPSBudWxsOwogICAgICAgICAgICB0aGlzLmlkID0gRlMubmV4dElub2RlKys7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7CiAgICAgICAgICAgIHRoaXMubm9kZV9vcHMgPSB7fTsKICAgICAgICAgICAgdGhpcy5zdHJlYW1fb3BzID0ge307CiAgICAgICAgICAgIHRoaXMucmRldiA9IHJkZXY7CiAgICAgICAgICB9OwogICAgICAgICAgRlMuRlNOb2RlLnByb3RvdHlwZSA9IHt9OwogICAgICAgICAgdmFyIHJlYWRNb2RlID0gMjkyIHwgNzM7CiAgICAgICAgICB2YXIgd3JpdGVNb2RlID0gMTQ2OwogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNOb2RlLnByb3RvdHlwZSwgewogICAgICAgICAgICByZWFkOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHJlYWRNb2RlKSA9PT0gcmVhZE1vZGUKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgewogICAgICAgICAgICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSByZWFkTW9kZSkgOiAodGhpcy5tb2RlICY9IH5yZWFkTW9kZSk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgd3JpdGU6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgd3JpdGVNb2RlKSA9PT0gd3JpdGVNb2RlCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsKICAgICAgICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gd3JpdGVNb2RlKSA6ICh0aGlzLm1vZGUgJj0gfndyaXRlTW9kZSk7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaXNGb2xkZXI6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiBGUy5pc0Rpcih0aGlzLm1vZGUpCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaXNEZXZpY2U6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICB2YXIgbm9kZSA9IG5ldyBGUy5GU05vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KTsKICAgICAgICBGUy5oYXNoQWRkTm9kZShub2RlKTsKICAgICAgICByZXR1cm4gbm9kZQogICAgICB9LAogICAgICBkZXN0cm95Tm9kZTogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShub2RlKTsKICAgICAgfSwKICAgICAgaXNSb290OiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudAogICAgICB9LAogICAgICBpc01vdW50cG9pbnQ6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgcmV0dXJuICEhbm9kZS5tb3VudGVkCiAgICAgIH0sCiAgICAgIGlzRmlsZTogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDMyNzY4CiAgICAgIH0sCiAgICAgIGlzRGlyOiBmdW5jdGlvbiAobW9kZSkgewogICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQKICAgICAgfSwKICAgICAgaXNMaW5rOiBmdW5jdGlvbiAobW9kZSkgewogICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjAKICAgICAgfSwKICAgICAgaXNDaHJkZXY6IGZ1bmN0aW9uIChtb2RlKSB7CiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA4MTkyCiAgICAgIH0sCiAgICAgIGlzQmxrZGV2OiBmdW5jdGlvbiAobW9kZSkgewogICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzYKICAgICAgfSwKICAgICAgaXNGSUZPOiBmdW5jdGlvbiAobW9kZSkgewogICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NgogICAgICB9LAogICAgICBpc1NvY2tldDogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA0OTE1MikgPT09IDQ5MTUyCiAgICAgIH0sCiAgICAgIGZsYWdNb2RlczogewogICAgICAgIHI6IDAsCiAgICAgICAgcnM6IDEwNTI2NzIsCiAgICAgICAgJ3IrJzogMiwKICAgICAgICB3OiA1NzcsCiAgICAgICAgd3g6IDcwNSwKICAgICAgICB4dzogNzA1LAogICAgICAgICd3Kyc6IDU3OCwKICAgICAgICAnd3grJzogNzA2LAogICAgICAgICd4dysnOiA3MDYsCiAgICAgICAgYTogMTA4OSwKICAgICAgICBheDogMTIxNywKICAgICAgICB4YTogMTIxNywKICAgICAgICAnYSsnOiAxMDkwLAogICAgICAgICdheCsnOiAxMjE4LAogICAgICAgICd4YSsnOiAxMjE4LAogICAgICB9LAogICAgICBtb2RlU3RyaW5nVG9GbGFnczogZnVuY3Rpb24gKHN0cikgewogICAgICAgIHZhciBmbGFncyA9IEZTLmZsYWdNb2Rlc1tzdHJdOwogICAgICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZmlsZSBvcGVuIG1vZGU6ICcgKyBzdHIpCiAgICAgICAgfQogICAgICAgIHJldHVybiBmbGFncwogICAgICB9LAogICAgICBmbGFnc1RvUGVybWlzc2lvblN0cmluZzogZnVuY3Rpb24gKGZsYWcpIHsKICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTsKICAgICAgICBpZiAoZmxhZyAmIDUxMikgewogICAgICAgICAgcGVybXMgKz0gJ3cnOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcGVybXMKICAgICAgfSwKICAgICAgbm9kZVBlcm1pc3Npb25zOiBmdW5jdGlvbiAobm9kZSwgcGVybXMpIHsKICAgICAgICBpZiAoRlMuaWdub3JlUGVybWlzc2lvbnMpIHsKICAgICAgICAgIHJldHVybiAwCiAgICAgICAgfQogICAgICAgIGlmIChwZXJtcy5pbmRleE9mKCdyJykgIT09IC0xICYmICEobm9kZS5tb2RlICYgMjkyKSkgewogICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFUwogICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5kZXhPZigndycpICE9PSAtMSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHsKICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FQUNDRVMKICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluZGV4T2YoJ3gnKSAhPT0gLTEgJiYgIShub2RlLm1vZGUgJiA3MykpIHsKICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FQUNDRVMKICAgICAgICB9CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSwKICAgICAgbWF5TG9va3VwOiBmdW5jdGlvbiAoZGlyKSB7CiAgICAgICAgdmFyIGVyciA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd4Jyk7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycgogICAgICAgIGlmICghZGlyLm5vZGVfb3BzLmxvb2t1cCkgcmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFUwogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIG1heUNyZWF0ZTogZnVuY3Rpb24gKGRpciwgbmFtZSkgewogICAgICAgIHRyeSB7CiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTsKICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FRVhJU1QKICAgICAgICB9IGNhdGNoIChlKSB7fQogICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKQogICAgICB9LAogICAgICBtYXlEZWxldGU6IGZ1bmN0aW9uIChkaXIsIG5hbWUsIGlzZGlyKSB7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIGUuZXJybm8KICAgICAgICB9CiAgICAgICAgdmFyIGVyciA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHJldHVybiBlcnIKICAgICAgICB9CiAgICAgICAgaWYgKGlzZGlyKSB7CiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHsKICAgICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVOT1RESVIKICAgICAgICAgIH0KICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkgfHwgRlMuZ2V0UGF0aChub2RlKSA9PT0gRlMuY3dkKCkpIHsKICAgICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVCVVNZCiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FSVNESVIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSwKICAgICAgbWF5T3BlbjogZnVuY3Rpb24gKG5vZGUsIGZsYWdzKSB7CiAgICAgICAgaWYgKCFub2RlKSB7CiAgICAgICAgICByZXR1cm4gRVJSTk9fQ09ERVMuRU5PRU5UCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkgewogICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVMT09QCiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSAncicgfHwgZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVJU0RJUgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSkKICAgICAgfSwKICAgICAgTUFYX09QRU5fRkRTOiA0MDk2LAogICAgICBuZXh0ZmQ6IGZ1bmN0aW9uIChmZF9zdGFydCwgZmRfZW5kKSB7CiAgICAgICAgZmRfc3RhcnQgPSBmZF9zdGFydCB8fCAwOwogICAgICAgIGZkX2VuZCA9IGZkX2VuZCB8fCBGUy5NQVhfT1BFTl9GRFM7CiAgICAgICAgZm9yICh2YXIgZmQgPSBmZF9zdGFydDsgZmQgPD0gZmRfZW5kOyBmZCsrKSB7CiAgICAgICAgICBpZiAoIUZTLnN0cmVhbXNbZmRdKSB7CiAgICAgICAgICAgIHJldHVybiBmZAogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTUZJTEUpCiAgICAgIH0sCiAgICAgIGdldFN0cmVhbTogZnVuY3Rpb24gKGZkKSB7CiAgICAgICAgcmV0dXJuIEZTLnN0cmVhbXNbZmRdCiAgICAgIH0sCiAgICAgIGNyZWF0ZVN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgewogICAgICAgIGlmICghRlMuRlNTdHJlYW0pIHsKICAgICAgICAgIEZTLkZTU3RyZWFtID0gZnVuY3Rpb24gKCkge307CiAgICAgICAgICBGUy5GU1N0cmVhbS5wcm90b3R5cGUgPSB7fTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTU3RyZWFtLnByb3RvdHlwZSwgewogICAgICAgICAgICBvYmplY3Q6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgewogICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gdmFsOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzUmVhZDogewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDEKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgICBpc1dyaXRlOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzQXBwZW5kOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbGFncyAmIDEwMjQKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHZhciBuZXdTdHJlYW0gPSBuZXcgRlMuRlNTdHJlYW0oKTsKICAgICAgICBmb3IgKHZhciBwIGluIHN0cmVhbSkgewogICAgICAgICAgbmV3U3RyZWFtW3BdID0gc3RyZWFtW3BdOwogICAgICAgIH0KICAgICAgICBzdHJlYW0gPSBuZXdTdHJlYW07CiAgICAgICAgdmFyIGZkID0gRlMubmV4dGZkKGZkX3N0YXJ0LCBmZF9lbmQpOwogICAgICAgIHN0cmVhbS5mZCA9IGZkOwogICAgICAgIEZTLnN0cmVhbXNbZmRdID0gc3RyZWFtOwogICAgICAgIHJldHVybiBzdHJlYW0KICAgICAgfSwKICAgICAgY2xvc2VTdHJlYW06IGZ1bmN0aW9uIChmZCkgewogICAgICAgIEZTLnN0cmVhbXNbZmRdID0gbnVsbDsKICAgICAgfSwKICAgICAgY2hyZGV2X3N0cmVhbV9vcHM6IHsKICAgICAgICBvcGVuOiBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgICAgICAgICB2YXIgZGV2aWNlID0gRlMuZ2V0RGV2aWNlKHN0cmVhbS5ub2RlLnJkZXYpOwogICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMgPSBkZXZpY2Uuc3RyZWFtX29wczsKICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7CiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGxsc2VlazogZnVuY3Rpb24gKCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKQogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIG1ham9yOiBmdW5jdGlvbiAoZGV2KSB7CiAgICAgICAgcmV0dXJuIGRldiA+PiA4CiAgICAgIH0sCiAgICAgIG1pbm9yOiBmdW5jdGlvbiAoZGV2KSB7CiAgICAgICAgcmV0dXJuIGRldiAmIDI1NQogICAgICB9LAogICAgICBtYWtlZGV2OiBmdW5jdGlvbiAobWEsIG1pKSB7CiAgICAgICAgcmV0dXJuIChtYSA8PCA4KSB8IG1pCiAgICAgIH0sCiAgICAgIHJlZ2lzdGVyRGV2aWNlOiBmdW5jdGlvbiAoZGV2LCBvcHMpIHsKICAgICAgICBGUy5kZXZpY2VzW2Rldl0gPSB7IHN0cmVhbV9vcHM6IG9wcyB9OwogICAgICB9LAogICAgICBnZXREZXZpY2U6IGZ1bmN0aW9uIChkZXYpIHsKICAgICAgICByZXR1cm4gRlMuZGV2aWNlc1tkZXZdCiAgICAgIH0sCiAgICAgIGdldE1vdW50czogZnVuY3Rpb24gKG1vdW50KSB7CiAgICAgICAgdmFyIG1vdW50cyA9IFtdOwogICAgICAgIHZhciBjaGVjayA9IFttb3VudF07CiAgICAgICAgd2hpbGUgKGNoZWNrLmxlbmd0aCkgewogICAgICAgICAgdmFyIG0gPSBjaGVjay5wb3AoKTsKICAgICAgICAgIG1vdW50cy5wdXNoKG0pOwogICAgICAgICAgY2hlY2sucHVzaC5hcHBseShjaGVjaywgbS5tb3VudHMpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbW91bnRzCiAgICAgIH0sCiAgICAgIHN5bmNmczogZnVuY3Rpb24gKHBvcHVsYXRlLCBjYWxsYmFjaykgewogICAgICAgIGlmICh0eXBlb2YgcG9wdWxhdGUgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgIGNhbGxiYWNrID0gcG9wdWxhdGU7CiAgICAgICAgICBwb3B1bGF0ZSA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrOwogICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKAogICAgICAgICAgICAnd2FybmluZzogJyArIEZTLnN5bmNGU1JlcXVlc3RzICsgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJwogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTsKICAgICAgICB2YXIgY29tcGxldGVkID0gMDsKICAgICAgICBmdW5jdGlvbiBkb0NhbGxiYWNrKGVycikgewogICAgICAgICAgYXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzID4gMCk7CiAgICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cy0tOwogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycikKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHsKICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHsKICAgICAgICAgICAgICBkb25lLmVycm9yZWQgPSB0cnVlOwogICAgICAgICAgICAgIHJldHVybiBkb0NhbGxiYWNrKGVycikKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7CiAgICAgICAgICAgIGRvQ2FsbGJhY2sobnVsbCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIG1vdW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtb3VudCkgewogICAgICAgICAgaWYgKCFtb3VudC50eXBlLnN5bmNmcykgewogICAgICAgICAgICByZXR1cm4gZG9uZShudWxsKQogICAgICAgICAgfQogICAgICAgICAgbW91bnQudHlwZS5zeW5jZnMobW91bnQsIHBvcHVsYXRlLCBkb25lKTsKICAgICAgICB9KTsKICAgICAgfSwKICAgICAgbW91bnQ6IGZ1bmN0aW9uICh0eXBlLCBvcHRzLCBtb3VudHBvaW50KSB7CiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSAnLyc7CiAgICAgICAgdmFyIHBzZXVkbyA9ICFtb3VudHBvaW50OwogICAgICAgIHZhciBub2RlOwogICAgICAgIGlmIChyb290ICYmIEZTLnJvb3QpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKQogICAgICAgIH0gZWxzZSBpZiAoIXJvb3QgJiYgIXBzZXVkbykgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pOwogICAgICAgICAgbW91bnRwb2ludCA9IGxvb2t1cC5wYXRoOwogICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSkKICAgICAgICAgIH0KICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URElSKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgbW91bnQgPSB7IHR5cGU6IHR5cGUsIG9wdHM6IG9wdHMsIG1vdW50cG9pbnQ6IG1vdW50cG9pbnQsIG1vdW50czogW10gfTsKICAgICAgICB2YXIgbW91bnRSb290ID0gdHlwZS5tb3VudChtb3VudCk7CiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7CiAgICAgICAgbW91bnQucm9vdCA9IG1vdW50Um9vdDsKICAgICAgICBpZiAocm9vdCkgewogICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDsKICAgICAgICB9IGVsc2UgaWYgKG5vZGUpIHsKICAgICAgICAgIG5vZGUubW91bnRlZCA9IG1vdW50OwogICAgICAgICAgaWYgKG5vZGUubW91bnQpIHsKICAgICAgICAgICAgbm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBtb3VudFJvb3QKICAgICAgfSwKICAgICAgdW5tb3VudDogZnVuY3Rpb24gKG1vdW50cG9pbnQpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7CiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7CiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkOwogICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMobW91bnQpOwogICAgICAgIE9iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkgewogICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07CiAgICAgICAgICB3aGlsZSAoY3VycmVudCkgewogICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0OwogICAgICAgICAgICBpZiAobW91bnRzLmluZGV4T2YoY3VycmVudC5tb3VudCkgIT09IC0xKSB7CiAgICAgICAgICAgICAgRlMuZGVzdHJveU5vZGUoY3VycmVudCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgbm9kZS5tb3VudGVkID0gbnVsbDsKICAgICAgICB2YXIgaWR4ID0gbm9kZS5tb3VudC5tb3VudHMuaW5kZXhPZihtb3VudCk7CiAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpOwogICAgICAgIG5vZGUubW91bnQubW91bnRzLnNwbGljZShpZHgsIDEpOwogICAgICB9LAogICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsIG5hbWUpCiAgICAgIH0sCiAgICAgIG1rbm9kOiBmdW5jdGlvbiAocGF0aCwgbW9kZSwgZGV2KSB7CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7CiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlOwogICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTsKICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gJy4nIHx8IG5hbWUgPT09ICcuLicpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgdmFyIGVyciA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICB9CiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMubWtub2QpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KQogICAgICB9LAogICAgICBjcmVhdGU6IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7CiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0Mzg7CiAgICAgICAgbW9kZSAmPSA0MDk1OwogICAgICAgIG1vZGUgfD0gMzI3Njg7CiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApCiAgICAgIH0sCiAgICAgIG1rZGlyOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkgewogICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNTExOwogICAgICAgIG1vZGUgJj0gNTExIHwgNTEyOwogICAgICAgIG1vZGUgfD0gMTYzODQ7CiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApCiAgICAgIH0sCiAgICAgIG1rZGlyVHJlZTogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHsKICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTsKICAgICAgICB2YXIgZCA9ICcnOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7ICsraSkgewogICAgICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZQogICAgICAgICAgZCArPSAnLycgKyBkaXJzW2ldOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgRlMubWtkaXIoZCwgbW9kZSk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmIChlLmVycm5vICE9IEVSUk5PX0NPREVTLkVFWElTVCkgdGhyb3cgZQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgbWtkZXY6IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBkZXYpIHsKICAgICAgICBpZiAodHlwZW9mIGRldiA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIGRldiA9IG1vZGU7CiAgICAgICAgICBtb2RlID0gNDM4OwogICAgICAgIH0KICAgICAgICBtb2RlIHw9IDgxOTI7CiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIGRldikKICAgICAgfSwKICAgICAgc3ltbGluazogZnVuY3Rpb24gKG9sZHBhdGgsIG5ld3BhdGgpIHsKICAgICAgICBpZiAoIVBBVEgucmVzb2x2ZShvbGRwYXRoKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIH0KICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTsKICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7CiAgICAgICAgaWYgKCFwYXJlbnQpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCkKICAgICAgICB9CiAgICAgICAgdmFyIG5ld25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld3BhdGgpOwogICAgICAgIHZhciBlcnIgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKQogICAgICB9LAogICAgICByZW5hbWU6IGZ1bmN0aW9uIChvbGRfcGF0aCwgbmV3X3BhdGgpIHsKICAgICAgICB2YXIgb2xkX2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUob2xkX3BhdGgpOwogICAgICAgIHZhciBuZXdfZGlybmFtZSA9IFBBVEguZGlybmFtZShuZXdfcGF0aCk7CiAgICAgICAgdmFyIG9sZF9uYW1lID0gUEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7CiAgICAgICAgdmFyIG5ld19uYW1lID0gUEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7CiAgICAgICAgdmFyIGxvb2t1cCwgb2xkX2RpciwgbmV3X2RpcjsKICAgICAgICB0cnkgewogICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChvbGRfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7CiAgICAgICAgICBvbGRfZGlyID0gbG9va3VwLm5vZGU7CiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld19wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTsKICAgICAgICAgIG5ld19kaXIgPSBsb29rdXAubm9kZTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSkKICAgICAgICB9CiAgICAgICAgaWYgKCFvbGRfZGlyIHx8ICFuZXdfZGlyKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgaWYgKG9sZF9kaXIubW91bnQgIT09IG5ld19kaXIubW91bnQpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVYREVWKQogICAgICAgIH0KICAgICAgICB2YXIgb2xkX25vZGUgPSBGUy5sb29rdXBOb2RlKG9sZF9kaXIsIG9sZF9uYW1lKTsKICAgICAgICB2YXIgcmVsYXRpdmUgPSBQQVRILnJlbGF0aXZlKG9sZF9wYXRoLCBuZXdfZGlybmFtZSk7CiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIHJlbGF0aXZlID0gUEFUSC5yZWxhdGl2ZShuZXdfcGF0aCwgb2xkX2Rpcm5hbWUpOwogICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVEVNUFRZKQogICAgICAgIH0KICAgICAgICB2YXIgbmV3X25vZGU7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7CiAgICAgICAgfSBjYXRjaCAoZSkge30KICAgICAgICBpZiAob2xkX25vZGUgPT09IG5ld19ub2RlKSB7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgdmFyIGlzZGlyID0gRlMuaXNEaXIob2xkX25vZGUubW9kZSk7CiAgICAgICAgdmFyIGVyciA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICB9CiAgICAgICAgZXJyID0gbmV3X25vZGUgPyBGUy5tYXlEZWxldGUobmV3X2RpciwgbmV3X25hbWUsIGlzZGlyKSA6IEZTLm1heUNyZWF0ZShuZXdfZGlyLCBuZXdfbmFtZSk7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgIH0KICAgICAgICBpZiAoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSkgfHwgKG5ld19ub2RlICYmIEZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSkKICAgICAgICB9CiAgICAgICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHsKICAgICAgICAgIGVyciA9IEZTLm5vZGVQZXJtaXNzaW9ucyhvbGRfZGlyLCAndycpOwogICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbE1vdmVQYXRoJ10pIHsKICAgICAgICAgICAgRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbE1vdmVQYXRoJ10ob2xkX3BhdGgsIG5ld19wYXRoKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgICAgIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxNb3ZlUGF0aCddKCciICsgb2xkX3BhdGggKyAiJywgJyIgKyBuZXdfcGF0aCArICInKSB0aHJldyBhbiBleGNlcHRpb246ICIgKyBlLm1lc3NhZ2UKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTsKICAgICAgICB0cnkgewogICAgICAgICAgb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICB0aHJvdyBlCiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIEZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKTsKICAgICAgICB9CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChGUy50cmFja2luZ0RlbGVnYXRlWydvbk1vdmVQYXRoJ10pIEZTLnRyYWNraW5nRGVsZWdhdGVbJ29uTW92ZVBhdGgnXShvbGRfcGF0aCwgbmV3X3BhdGgpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKAogICAgICAgICAgICAiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25Nb3ZlUGF0aCddKCciICsgb2xkX3BhdGggKyAiJywgJyIgKyBuZXdfcGF0aCArICInKSB0aHJldyBhbiBleGNlcHRpb246ICIgKyBlLm1lc3NhZ2UKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICB9LAogICAgICBybWRpcjogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTsKICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7CiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpOwogICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpOwogICAgICAgIHZhciBlcnIgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCB0cnVlKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnJtZGlyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpCiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXSkgewogICAgICAgICAgICBGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKHBhdGgpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKCciICsgcGF0aCArICInKSB0aHJldyBhbiBleGNlcHRpb246ICIgKyBlLm1lc3NhZ2UpOwogICAgICAgIH0KICAgICAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTsKICAgICAgICBGUy5kZXN0cm95Tm9kZShub2RlKTsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKEZTLnRyYWNraW5nRGVsZWdhdGVbJ29uRGVsZXRlUGF0aCddKSBGUy50cmFja2luZ0RlbGVnYXRlWydvbkRlbGV0ZVBhdGgnXShwYXRoKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIgKyBwYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICB9LAogICAgICByZWFkZGlyOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pOwogICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7CiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpCiAgICAgICAgfQogICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSkKICAgICAgfSwKICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTsKICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7CiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7CiAgICAgICAgdmFyIGVyciA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnVubGluaykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKQogICAgICAgIH0KICAgICAgICB0cnkgewogICAgICAgICAgaWYgKEZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxEZWxldGVQYXRoJ10pIHsKICAgICAgICAgICAgRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXShwYXRoKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXSgnIiArIHBhdGggKyAiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpOwogICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10pIEZTLnRyYWNraW5nRGVsZWdhdGVbJ29uRGVsZXRlUGF0aCddKHBhdGgpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbkRlbGV0ZVBhdGgnXSgnIiArIHBhdGggKyAiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHJlYWRsaW5rOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgpOwogICAgICAgIHZhciBsaW5rID0gbG9va3VwLm5vZGU7CiAgICAgICAgaWYgKCFsaW5rKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfQogICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICByZXR1cm4gUEFUSC5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLCBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspKQogICAgICB9LAogICAgICBzdGF0OiBmdW5jdGlvbiAocGF0aCwgZG9udEZvbGxvdykgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTsKICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIGlmICghbm9kZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSkKICAgICAgfSwKICAgICAgbHN0YXQ6IGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSkKICAgICAgfSwKICAgICAgY2htb2Q6IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBkb250Rm9sbG93KSB7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pOwogICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBub2RlID0gcGF0aDsKICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwgeyBtb2RlOiAobW9kZSAmIDQwOTUpIHwgKG5vZGUubW9kZSAmIH40MDk1KSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0pOwogICAgICB9LAogICAgICBsY2htb2Q6IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7CiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSwgdHJ1ZSk7CiAgICAgIH0sCiAgICAgIGZjaG1vZDogZnVuY3Rpb24gKGZkLCBtb2RlKSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7CiAgICAgICAgaWYgKCFzdHJlYW0pIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7CiAgICAgIH0sCiAgICAgIGNob3duOiBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGRvbnRGb2xsb3cpIHsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7CiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG5vZGUgPSBwYXRoOwogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTsKICAgICAgfSwKICAgICAgbGNob3duOiBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQpIHsKICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7CiAgICAgIH0sCiAgICAgIGZjaG93bjogZnVuY3Rpb24gKGZkLCB1aWQsIGdpZCkgewogICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpOwogICAgICAgIGlmICghc3RyZWFtKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgRlMuY2hvd24oc3RyZWFtLm5vZGUsIHVpZCwgZ2lkKTsKICAgICAgfSwKICAgICAgdHJ1bmNhdGU6IGZ1bmN0aW9uIChwYXRoLCBsZW4pIHsKICAgICAgICBpZiAobGVuIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICB2YXIgbm9kZTsKICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTsKICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbm9kZSA9IHBhdGg7CiAgICAgICAgfQogICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUikKICAgICAgICB9CiAgICAgICAgaWYgKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICB2YXIgZXJyID0gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsICd3Jyk7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgIH0KICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwgeyBzaXplOiBsZW4sIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTsKICAgICAgfSwKICAgICAgZnRydW5jYXRlOiBmdW5jdGlvbiAoZmQsIGxlbikgewogICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpOwogICAgICAgIGlmICghc3RyZWFtKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICBGUy50cnVuY2F0ZShzdHJlYW0ubm9kZSwgbGVuKTsKICAgICAgfSwKICAgICAgdXRpbWU6IGZ1bmN0aW9uIChwYXRoLCBhdGltZSwgbXRpbWUpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTsKICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7IHRpbWVzdGFtcDogTWF0aC5tYXgoYXRpbWUsIG10aW1lKSB9KTsKICAgICAgfSwKICAgICAgb3BlbjogZnVuY3Rpb24gKHBhdGgsIGZsYWdzLCBtb2RlLCBmZF9zdGFydCwgZmRfZW5kKSB7CiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfQogICAgICAgIGZsYWdzID0gdHlwZW9mIGZsYWdzID09PSAnc3RyaW5nJyA/IEZTLm1vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzOwogICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PT0gJ3VuZGVmaW5lZCcgPyA0MzggOiBtb2RlOwogICAgICAgIGlmIChmbGFncyAmIDY0KSB7CiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtb2RlID0gMDsKICAgICAgICB9CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JykgewogICAgICAgICAgbm9kZSA9IHBhdGg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKSB9KTsKICAgICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgfSBjYXRjaCAoZSkge30KICAgICAgICB9CiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTsKICAgICAgICBpZiAoZmxhZ3MgJiA2NCkgewogICAgICAgICAgaWYgKG5vZGUpIHsKICAgICAgICAgICAgaWYgKGZsYWdzICYgMTI4KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUVYSVNUKQogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBub2RlID0gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7CiAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHsKICAgICAgICAgIGZsYWdzICY9IH41MTI7CiAgICAgICAgfQogICAgICAgIGlmIChmbGFncyAmIDY1NTM2ICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URElSKQogICAgICAgIH0KICAgICAgICBpZiAoIWNyZWF0ZWQpIHsKICAgICAgICAgIHZhciBlcnIgPSBGUy5tYXlPcGVuKG5vZGUsIGZsYWdzKTsKICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZmxhZ3MgJiA1MTIpIHsKICAgICAgICAgIEZTLnRydW5jYXRlKG5vZGUsIDApOwogICAgICAgIH0KICAgICAgICBmbGFncyAmPSB+KDEyOCB8IDUxMik7CiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbSgKICAgICAgICAgIHsKICAgICAgICAgICAgbm9kZTogbm9kZSwKICAgICAgICAgICAgcGF0aDogRlMuZ2V0UGF0aChub2RlKSwKICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLAogICAgICAgICAgICBzZWVrYWJsZTogdHJ1ZSwKICAgICAgICAgICAgcG9zaXRpb246IDAsCiAgICAgICAgICAgIHN0cmVhbV9vcHM6IG5vZGUuc3RyZWFtX29wcywKICAgICAgICAgICAgdW5nb3R0ZW46IFtdLAogICAgICAgICAgICBlcnJvcjogZmFsc2UsCiAgICAgICAgICB9LAogICAgICAgICAgZmRfc3RhcnQsCiAgICAgICAgICBmZF9lbmQKICAgICAgICApOwogICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7CiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7CiAgICAgICAgfQogICAgICAgIGlmIChNb2R1bGVbJ2xvZ1JlYWRGaWxlcyddICYmICEoZmxhZ3MgJiAxKSkgewogICAgICAgICAgaWYgKCFGUy5yZWFkRmlsZXMpIEZTLnJlYWRGaWxlcyA9IHt9OwogICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7CiAgICAgICAgICAgIEZTLnJlYWRGaWxlc1twYXRoXSA9IDE7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgncmVhZCBmaWxlOiAnICsgcGF0aCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25PcGVuRmlsZSddKSB7CiAgICAgICAgICAgIHZhciB0cmFja2luZ0ZsYWdzID0gMDsKICAgICAgICAgICAgaWYgKChmbGFncyAmIDIwOTcxNTUpICE9PSAxKSB7CiAgICAgICAgICAgICAgdHJhY2tpbmdGbGFncyB8PSBGUy50cmFja2luZy5vcGVuRmxhZ3MuUkVBRDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoKGZsYWdzICYgMjA5NzE1NSkgIT09IDApIHsKICAgICAgICAgICAgICB0cmFja2luZ0ZsYWdzIHw9IEZTLnRyYWNraW5nLm9wZW5GbGFncy5XUklURTsKICAgICAgICAgICAgfQogICAgICAgICAgICBGUy50cmFja2luZ0RlbGVnYXRlWydvbk9wZW5GaWxlJ10ocGF0aCwgdHJhY2tpbmdGbGFncyk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uT3BlbkZpbGUnXSgnIiArIHBhdGggKyAiJywgZmxhZ3MpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHJlYW0KICAgICAgfSwKICAgICAgY2xvc2U6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMpIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSkgewogICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5jbG9zZShzdHJlYW0pOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHRocm93IGUKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgRlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTsKICAgICAgICB9CiAgICAgICAgc3RyZWFtLmZkID0gbnVsbDsKICAgICAgfSwKICAgICAgaXNDbG9zZWQ6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICByZXR1cm4gc3RyZWFtLmZkID09PSBudWxsCiAgICAgIH0sCiAgICAgIGxsc2VlazogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHsKICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSkKICAgICAgICB9CiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpOwogICAgICAgIHN0cmVhbS51bmdvdHRlbiA9IFtdOwogICAgICAgIHJldHVybiBzdHJlYW0ucG9zaXRpb24KICAgICAgfSwKICAgICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpCiAgICAgICAgfQogICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMucmVhZCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCc7CiAgICAgICAgaWYgKCFzZWVraW5nKSB7CiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjsKICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSkKICAgICAgICB9CiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IHN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7CiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNSZWFkOwogICAgICAgIHJldHVybiBieXRlc1JlYWQKICAgICAgfSwKICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHsKICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpCiAgICAgICAgfQogICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgaWYgKHN0cmVhbS5mbGFncyAmIDEwMjQpIHsKICAgICAgICAgIEZTLmxsc2VlayhzdHJlYW0sIDAsIDIpOwogICAgICAgIH0KICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCc7CiAgICAgICAgaWYgKCFzZWVraW5nKSB7CiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjsKICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSkKICAgICAgICB9CiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bik7CiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNXcml0dGVuOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoc3RyZWFtLnBhdGggJiYgRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25Xcml0ZVRvRmlsZSddKSBGUy50cmFja2luZ0RlbGVnYXRlWydvbldyaXRlVG9GaWxlJ10oc3RyZWFtLnBhdGgpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbldyaXRlVG9GaWxlJ10oJyIgKyBwYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBieXRlc1dyaXR0ZW4KICAgICAgfSwKICAgICAgYWxsb2NhdGU6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpCiAgICAgICAgfQogICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVPUE5PVFNVUFApCiAgICAgICAgfQogICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpOwogICAgICB9LAogICAgICBtbWFwOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpIHsKICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQUNDRVMpCiAgICAgICAgfQogICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKQogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykKICAgICAgfSwKICAgICAgbXN5bmM6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykgewogICAgICAgIGlmICghc3RyZWFtIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5tc3luYykgewogICAgICAgICAgcmV0dXJuIDAKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKQogICAgICB9LAogICAgICBtdW5tYXA6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICByZXR1cm4gMAogICAgICB9LAogICAgICBpb2N0bDogZnVuY3Rpb24gKHN0cmVhbSwgY21kLCBhcmcpIHsKICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9UVFkpCiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKQogICAgICB9LAogICAgICByZWFkRmlsZTogZnVuY3Rpb24gKHBhdGgsIG9wdHMpIHsKICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTsKICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAncic7CiAgICAgICAgb3B0cy5lbmNvZGluZyA9IG9wdHMuZW5jb2RpbmcgfHwgJ2JpbmFyeSc7CiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5JykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHR5cGUgIicgKyBvcHRzLmVuY29kaW5nICsgJyInKQogICAgICAgIH0KICAgICAgICB2YXIgcmV0OwogICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MpOwogICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTsKICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdC5zaXplOwogICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOwogICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7CiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4JykgewogICAgICAgICAgcmV0ID0gVVRGOEFycmF5VG9TdHJpbmcoYnVmLCAwKTsKICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7CiAgICAgICAgICByZXQgPSBidWY7CiAgICAgICAgfQogICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9LAogICAgICB3cml0ZUZpbGU6IGZ1bmN0aW9uIChwYXRoLCBkYXRhLCBvcHRzKSB7CiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307CiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgJ3cnOwogICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MsIG9wdHMubW9kZSk7CiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgewogICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDEpOwogICAgICAgICAgdmFyIGFjdHVhbE51bUJ5dGVzID0gc3RyaW5nVG9VVEY4QXJyYXkoZGF0YSwgYnVmLCAwLCBidWYubGVuZ3RoKTsKICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7CiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHsKICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKQogICAgICAgIH0KICAgICAgICBGUy5jbG9zZShzdHJlYW0pOwogICAgICB9LAogICAgICBjd2Q6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRlMuY3VycmVudFBhdGgKICAgICAgfSwKICAgICAgY2hkaXI6IGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7CiAgICAgICAgaWYgKGxvb2t1cC5ub2RlID09PSBudWxsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfQogICAgICAgIGlmICghRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpCiAgICAgICAgfQogICAgICAgIHZhciBlcnIgPSBGUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsICd4Jyk7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgIH0KICAgICAgICBGUy5jdXJyZW50UGF0aCA9IGxvb2t1cC5wYXRoOwogICAgICB9LAogICAgICBjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXM6IGZ1bmN0aW9uICgpIHsKICAgICAgICBGUy5ta2RpcignL3RtcCcpOwogICAgICAgIEZTLm1rZGlyKCcvaG9tZScpOwogICAgICAgIEZTLm1rZGlyKCcvaG9tZS93ZWJfdXNlcicpOwogICAgICB9LAogICAgICBjcmVhdGVEZWZhdWx0RGV2aWNlczogZnVuY3Rpb24gKCkgewogICAgICAgIEZTLm1rZGlyKCcvZGV2Jyk7CiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLCAzKSwgewogICAgICAgICAgcmVhZDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gMAogICAgICAgICAgfSwKICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHsKICAgICAgICAgICAgcmV0dXJuIGxlbmd0aAogICAgICAgICAgfSwKICAgICAgICB9KTsKICAgICAgICBGUy5ta2RldignL2Rldi9udWxsJywgRlMubWFrZWRldigxLCAzKSk7CiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwgMCksIFRUWS5kZWZhdWx0X3R0eV9vcHMpOwogICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7CiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5JywgRlMubWFrZWRldig1LCAwKSk7CiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5MScsIEZTLm1ha2VkZXYoNiwgMCkpOwogICAgICAgIHZhciByYW5kb21fZGV2aWNlOwogICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEpOwogICAgICAgICAgcmFuZG9tX2RldmljZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CdWZmZXIpOwogICAgICAgICAgICByZXR1cm4gcmFuZG9tQnVmZmVyWzBdCiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkgewogICAgICAgICAgcmFuZG9tX2RldmljZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ2NyeXB0bycpWydyYW5kb21CeXRlcyddKDEpWzBdCiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByYW5kb21fZGV2aWNlID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAyNTYpIHwgMAogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3JhbmRvbScsIHJhbmRvbV9kZXZpY2UpOwogICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICd1cmFuZG9tJywgcmFuZG9tX2RldmljZSk7CiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htJyk7CiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htL3RtcCcpOwogICAgICB9LAogICAgICBjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXM6IGZ1bmN0aW9uICgpIHsKICAgICAgICBGUy5ta2RpcignL3Byb2MnKTsKICAgICAgICBGUy5ta2RpcignL3Byb2Mvc2VsZicpOwogICAgICAgIEZTLm1rZGlyKCcvcHJvYy9zZWxmL2ZkJyk7CiAgICAgICAgRlMubW91bnQoCiAgICAgICAgICB7CiAgICAgICAgICAgIG1vdW50OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKCcvcHJvYy9zZWxmJywgJ2ZkJywgMTYzODQgfCA1MTEsIDczKTsKICAgICAgICAgICAgICBub2RlLm5vZGVfb3BzID0gewogICAgICAgICAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lOwogICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTsKICAgICAgICAgICAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gewogICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCwKICAgICAgICAgICAgICAgICAgICBtb3VudDogeyBtb3VudHBvaW50OiAnZmFrZScgfSwKICAgICAgICAgICAgICAgICAgICBub2RlX29wczogewogICAgICAgICAgICAgICAgICAgICAgcmVhZGxpbms6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5wYXRoCiAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7CiAgICAgICAgICAgICAgICAgIHJldHVybiByZXQKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICByZXR1cm4gbm9kZQogICAgICAgICAgICB9LAogICAgICAgICAgfSwKICAgICAgICAgIHt9LAogICAgICAgICAgJy9wcm9jL3NlbGYvZmQnCiAgICAgICAgKTsKICAgICAgfSwKICAgICAgY3JlYXRlU3RhbmRhcmRTdHJlYW1zOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKE1vZHVsZVsnc3RkaW4nXSkgewogICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGluJywgTW9kdWxlWydzdGRpbiddKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgRlMuc3ltbGluaygnL2Rldi90dHknLCAnL2Rldi9zdGRpbicpOwogICAgICAgIH0KICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkgewogICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZG91dCcsIG51bGwsIE1vZHVsZVsnc3Rkb3V0J10pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpOwogICAgICAgIH0KICAgICAgICBpZiAoTW9kdWxlWydzdGRlcnInXSkgewogICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eTEnLCAnL2Rldi9zdGRlcnInKTsKICAgICAgICB9CiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbignL2Rldi9zdGRpbicsICdyJyk7CiAgICAgICAgYXNzZXJ0KHN0ZGluLmZkID09PSAwLCAnaW52YWxpZCBoYW5kbGUgZm9yIHN0ZGluICgnICsgc3RkaW4uZmQgKyAnKScpOwogICAgICAgIHZhciBzdGRvdXQgPSBGUy5vcGVuKCcvZGV2L3N0ZG91dCcsICd3Jyk7CiAgICAgICAgYXNzZXJ0KHN0ZG91dC5mZCA9PT0gMSwgJ2ludmFsaWQgaGFuZGxlIGZvciBzdGRvdXQgKCcgKyBzdGRvdXQuZmQgKyAnKScpOwogICAgICAgIHZhciBzdGRlcnIgPSBGUy5vcGVuKCcvZGV2L3N0ZGVycicsICd3Jyk7CiAgICAgICAgYXNzZXJ0KHN0ZGVyci5mZCA9PT0gMiwgJ2ludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCcgKyBzdGRlcnIuZmQgKyAnKScpOwogICAgICB9LAogICAgICBlbnN1cmVFcnJub0Vycm9yOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKEZTLkVycm5vRXJyb3IpIHJldHVybgogICAgICAgIEZTLkVycm5vRXJyb3IgPSBmdW5jdGlvbiBFcnJub0Vycm9yKGVycm5vLCBub2RlKSB7CiAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlOwogICAgICAgICAgdGhpcy5zZXRFcnJubyA9IGZ1bmN0aW9uIChlcnJubykgewogICAgICAgICAgICB0aGlzLmVycm5vID0gZXJybm87CiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBFUlJOT19DT0RFUykgewogICAgICAgICAgICAgIGlmIChFUlJOT19DT0RFU1trZXldID09PSBlcnJubykgewogICAgICAgICAgICAgICAgdGhpcy5jb2RlID0ga2V5OwogICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICB0aGlzLnNldEVycm5vKGVycm5vKTsKICAgICAgICAgIHRoaXMubWVzc2FnZSA9IEVSUk5PX01FU1NBR0VTW2Vycm5vXTsKICAgICAgICAgIGlmICh0aGlzLnN0YWNrKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2ssIHdyaXRhYmxlOiB0cnVlIH0pOwogICAgICAgIH07CiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsKICAgICAgICBGUy5FcnJub0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZTLkVycm5vRXJyb3IKICAgICAgICA7W0VSUk5PX0NPREVTLkVOT0VOVF0uZm9yRWFjaChmdW5jdGlvbiAoY29kZSkgewogICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXSA9IG5ldyBGUy5FcnJub0Vycm9yKGNvZGUpOwogICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjayA9ICc8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+JzsKICAgICAgICB9KTsKICAgICAgfSwKICAgICAgc3RhdGljSW5pdDogZnVuY3Rpb24gKCkgewogICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTsKICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7CiAgICAgICAgRlMubW91bnQoTUVNRlMsIHt9LCAnLycpOwogICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpOwogICAgICAgIEZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7CiAgICAgICAgRlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7CiAgICAgICAgRlMuZmlsZXN5c3RlbXMgPSB7IE1FTUZTOiBNRU1GUywgSURCRlM6IElEQkZTLCBOT0RFRlM6IE5PREVGUywgV09SS0VSRlM6IFdPUktFUkZTIH07CiAgICAgIH0sCiAgICAgIGluaXQ6IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0LCBlcnJvcikgewogICAgICAgIGFzc2VydCgKICAgICAgICAgICFGUy5pbml0LmluaXRpYWxpemVkLAogICAgICAgICAgJ0ZTLmluaXQgd2FzIHByZXZpb3VzbHkgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byBpbml0aWFsaXplIGxhdGVyIHdpdGggY3VzdG9tIHBhcmFtZXRlcnMsIHJlbW92ZSBhbnkgZWFybGllciBjYWxscyAobm90ZSB0aGF0IG9uZSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBnZW5lcmF0ZWQgY29kZSknCiAgICAgICAgKTsKICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gdHJ1ZTsKICAgICAgICBGUy5lbnN1cmVFcnJub0Vycm9yKCk7CiAgICAgICAgTW9kdWxlWydzdGRpbiddID0gaW5wdXQgfHwgTW9kdWxlWydzdGRpbiddOwogICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTsKICAgICAgICBNb2R1bGVbJ3N0ZGVyciddID0gZXJyb3IgfHwgTW9kdWxlWydzdGRlcnInXTsKICAgICAgICBGUy5jcmVhdGVTdGFuZGFyZFN0cmVhbXMoKTsKICAgICAgfSwKICAgICAgcXVpdDogZnVuY3Rpb24gKCkgewogICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSBmYWxzZTsKICAgICAgICB2YXIgZmZsdXNoID0gTW9kdWxlWydfZmZsdXNoJ107CiAgICAgICAgaWYgKGZmbHVzaCkgZmZsdXNoKDApOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRlMuc3RyZWFtcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07CiAgICAgICAgICBpZiAoIXN0cmVhbSkgewogICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgfQogICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGdldE1vZGU6IGZ1bmN0aW9uIChjYW5SZWFkLCBjYW5Xcml0ZSkgewogICAgICAgIHZhciBtb2RlID0gMDsKICAgICAgICBpZiAoY2FuUmVhZCkgbW9kZSB8PSAyOTIgfCA3MzsKICAgICAgICBpZiAoY2FuV3JpdGUpIG1vZGUgfD0gMTQ2OwogICAgICAgIHJldHVybiBtb2RlCiAgICAgIH0sCiAgICAgIGpvaW5QYXRoOiBmdW5jdGlvbiAocGFydHMsIGZvcmNlUmVsYXRpdmUpIHsKICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbi5hcHBseShudWxsLCBwYXJ0cyk7CiAgICAgICAgaWYgKGZvcmNlUmVsYXRpdmUgJiYgcGF0aFswXSA9PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigxKTsKICAgICAgICByZXR1cm4gcGF0aAogICAgICB9LAogICAgICBhYnNvbHV0ZVBhdGg6IGZ1bmN0aW9uIChyZWxhdGl2ZSwgYmFzZSkgewogICAgICAgIHJldHVybiBQQVRILnJlc29sdmUoYmFzZSwgcmVsYXRpdmUpCiAgICAgIH0sCiAgICAgIHN0YW5kYXJkaXplUGF0aDogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aCkKICAgICAgfSwKICAgICAgZmluZE9iamVjdDogZnVuY3Rpb24gKHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspIHsKICAgICAgICB2YXIgcmV0ID0gRlMuYW5hbHl6ZVBhdGgocGF0aCwgZG9udFJlc29sdmVMYXN0TGluayk7CiAgICAgICAgaWYgKHJldC5leGlzdHMpIHsKICAgICAgICAgIHJldHVybiByZXQub2JqZWN0CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIF9fX3NldEVyck5vKHJldC5lcnJvcik7CiAgICAgICAgICByZXR1cm4gbnVsbAogICAgICAgIH0KICAgICAgfSwKICAgICAgYW5hbHl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTsKICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDsKICAgICAgICB9IGNhdGNoIChlKSB7fQogICAgICAgIHZhciByZXQgPSB7CiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLAogICAgICAgICAgZXhpc3RzOiBmYWxzZSwKICAgICAgICAgIGVycm9yOiAwLAogICAgICAgICAgbmFtZTogbnVsbCwKICAgICAgICAgIHBhdGg6IG51bGwsCiAgICAgICAgICBvYmplY3Q6IG51bGwsCiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLAogICAgICAgICAgcGFyZW50UGF0aDogbnVsbCwKICAgICAgICAgIHBhcmVudE9iamVjdDogbnVsbCwKICAgICAgICB9OwogICAgICAgIHRyeSB7CiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTsKICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlOwogICAgICAgICAgcmV0LnBhcmVudFBhdGggPSBsb29rdXAucGF0aDsKICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTsKICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTsKICAgICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pOwogICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7CiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoOwogICAgICAgICAgcmV0Lm9iamVjdCA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lOwogICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0LmVycm9yID0gZS5lcnJubzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9LAogICAgICBjcmVhdGVGb2xkZXI6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIGNhblJlYWQsIGNhbldyaXRlKSB7CiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTsKICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpOwogICAgICAgIHJldHVybiBGUy5ta2RpcihwYXRoLCBtb2RlKQogICAgICB9LAogICAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbiAocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkgewogICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpOwogICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCk7CiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkgewogICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5wb3AoKTsKICAgICAgICAgIGlmICghcGFydCkgY29udGludWUKICAgICAgICAgIHZhciBjdXJyZW50ID0gUEFUSC5qb2luMihwYXJlbnQsIHBhcnQpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgRlMubWtkaXIoY3VycmVudCk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7fQogICAgICAgICAgcGFyZW50ID0gY3VycmVudDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGN1cnJlbnQKICAgICAgfSwKICAgICAgY3JlYXRlRmlsZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpIHsKICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7CiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZShwYXRoLCBtb2RlKQogICAgICB9LAogICAgICBjcmVhdGVEYXRhRmlsZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgZGF0YSwgY2FuUmVhZCwgY2FuV3JpdGUsIGNhbk93bikgewogICAgICAgIHZhciBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpIDogcGFyZW50OwogICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7CiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7CiAgICAgICAgaWYgKGRhdGEpIHsKICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7CiAgICAgICAgICAgIGRhdGEgPSBhcnI7CiAgICAgICAgICB9CiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlIHwgMTQ2KTsKICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKG5vZGUsICd3Jyk7CiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pOwogICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTsKICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbm9kZQogICAgICB9LAogICAgICBjcmVhdGVEZXZpY2U6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIGlucHV0LCBvdXRwdXQpIHsKICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7CiAgICAgICAgaWYgKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpIEZTLmNyZWF0ZURldmljZS5tYWpvciA9IDY0OwogICAgICAgIHZhciBkZXYgPSBGUy5tYWtlZGV2KEZTLmNyZWF0ZURldmljZS5tYWpvcisrLCAwKTsKICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIHsKICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7CiAgICAgICAgICB9LAogICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBvdXRwdXQuYnVmZmVyICYmIG91dHB1dC5idWZmZXIubGVuZ3RoKSB7CiAgICAgICAgICAgICAgb3V0cHV0KDEwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgewogICAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIHZhciByZXN1bHQ7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0KCk7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQUdBSU4pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrCiAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7CiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gcmVzdWx0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHsKICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQKICAgICAgICAgIH0sCiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgb3V0cHV0KGJ1ZmZlcltvZmZzZXQgKyBpXSk7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAobGVuZ3RoKSB7CiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gaQogICAgICAgICAgfSwKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KQogICAgICB9LAogICAgICBjcmVhdGVMaW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCB0YXJnZXQsIGNhblJlYWQsIGNhbldyaXRlKSB7CiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTsKICAgICAgICByZXR1cm4gRlMuc3ltbGluayh0YXJnZXQsIHBhdGgpCiAgICAgIH0sCiAgICAgIGZvcmNlTG9hZEZpbGU6IGZ1bmN0aW9uIChvYmopIHsKICAgICAgICBpZiAob2JqLmlzRGV2aWNlIHx8IG9iai5pc0ZvbGRlciB8fCBvYmoubGluayB8fCBvYmouY29udGVudHMpIHJldHVybiB0cnVlCiAgICAgICAgdmFyIHN1Y2Nlc3MgPSB0cnVlOwogICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICdMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC4nCiAgICAgICAgICApCiAgICAgICAgfSBlbHNlIGlmIChNb2R1bGVbJ3JlYWQnXSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gaW50QXJyYXlGcm9tU3RyaW5nKE1vZHVsZVsncmVhZCddKG9iai51cmwpLCB0cnVlKTsKICAgICAgICAgICAgb2JqLnVzZWRCeXRlcyA9IG9iai5jb250ZW50cy5sZW5ndGg7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4nKQogICAgICAgIH0KICAgICAgICBpZiAoIXN1Y2Nlc3MpIF9fX3NldEVyck5vKEVSUk5PX0NPREVTLkVJTyk7CiAgICAgICAgcmV0dXJuIHN1Y2Nlc3MKICAgICAgfSwKICAgICAgY3JlYXRlTGF6eUZpbGU6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUpIHsKICAgICAgICBmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpIHsKICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTsKICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107CiAgICAgICAgfQogICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7CiAgICAgICAgICBpZiAoaWR4ID4gdGhpcy5sZW5ndGggLSAxIHx8IGlkeCA8IDApIHsKICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgICAgICAgfQogICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaWR4ICUgdGhpcy5jaHVua1NpemU7CiAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpIHwgMDsKICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdCiAgICAgICAgfTsKICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuc2V0RGF0YUdldHRlciA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7CiAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjsKICAgICAgICB9OwogICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aCA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkgewogICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOwogICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTsKICAgICAgICAgIHhoci5zZW5kKG51bGwpOwogICAgICAgICAgaWYgKCEoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCkpCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ291bGRuJ3QgbG9hZCAiICsgdXJsICsgJy4gU3RhdHVzOiAnICsgeGhyLnN0YXR1cykKICAgICAgICAgIHZhciBkYXRhbGVuZ3RoID0gTnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1sZW5ndGgnKSk7CiAgICAgICAgICB2YXIgaGVhZGVyOwogICAgICAgICAgdmFyIGhhc0J5dGVTZXJ2aW5nID0gKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQWNjZXB0LVJhbmdlcycpKSAmJiBoZWFkZXIgPT09ICdieXRlcyc7CiAgICAgICAgICB2YXIgdXNlc0d6aXAgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUVuY29kaW5nJykpICYmIGhlYWRlciA9PT0gJ2d6aXAnOwogICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0OwogICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDsKICAgICAgICAgIHZhciBkb1hIUiA9IGZ1bmN0aW9uIChmcm9tLCB0bykgewogICAgICAgICAgICBpZiAoZnJvbSA+IHRvKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmFuZ2UgKCcgKyBmcm9tICsgJywgJyArIHRvICsgJykgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIScpCiAgICAgICAgICAgIGlmICh0byA+IGRhdGFsZW5ndGggLSAxKSB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgJyArIGRhdGFsZW5ndGggKyAnIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEnKQogICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTsKICAgICAgICAgICAgaWYgKGRhdGFsZW5ndGggIT09IGNodW5rU2l6ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBmcm9tICsgJy0nICsgdG8pOwogICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT0gJ3VuZGVmaW5lZCcpIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInOwogICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHsKICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpOwogICAgICAgICAgICBpZiAoISgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGxvYWQgIiArIHVybCArICcuIFN0YXR1czogJyArIHhoci5zdGF0dXMpCiAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UgfHwgW10pCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0IHx8ICcnLCB0cnVlKQogICAgICAgICAgICB9CiAgICAgICAgICB9OwogICAgICAgICAgdmFyIGxhenlBcnJheSA9IHRoaXM7CiAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcihmdW5jdGlvbiAoY2h1bmtOdW0pIHsKICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7CiAgICAgICAgICAgIHZhciBlbmQgPSAoY2h1bmtOdW0gKyAxKSAqIGNodW5rU2l6ZSAtIDE7CiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aCAtIDEpOwogICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID0gZG9YSFIoc3RhcnQsIGVuZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZG9YSFIgZmFpbGVkIScpCiAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXQogICAgICAgICAgfSk7CiAgICAgICAgICBpZiAodXNlc0d6aXAgfHwgIWRhdGFsZW5ndGgpIHsKICAgICAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aCA9IDE7CiAgICAgICAgICAgIGRhdGFsZW5ndGggPSB0aGlzLmdldHRlcigwKS5sZW5ndGg7CiAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWQnKTsKICAgICAgICAgIH0KICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGRhdGFsZW5ndGg7CiAgICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7CiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTsKICAgICAgICB9OwogICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICBpZiAoIUVOVklST05NRU5UX0lTX1dPUktFUikKICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MnCiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gbmV3IExhenlVaW50OEFycmF5KCk7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5QXJyYXksIHsKICAgICAgICAgICAgbGVuZ3RoOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNodW5rU2l6ZTogewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1NpemUKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIHVybDogdXJsIH07CiAgICAgICAgfQogICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTsKICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykgewogICAgICAgICAgbm9kZS5jb250ZW50cyA9IHByb3BlcnRpZXMuY29udGVudHM7CiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnVybCkgewogICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7CiAgICAgICAgICBub2RlLnVybCA9IHByb3BlcnRpZXMudXJsOwogICAgICAgIH0KICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLCB7CiAgICAgICAgICB1c2VkQnl0ZXM6IHsKICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMubGVuZ3RoCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9LAogICAgICAgIH0pOwogICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307CiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnN0cmVhbV9vcHMpOwogICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTsKICAgICAgICAgIHN0cmVhbV9vcHNba2V5XSA9IGZ1bmN0aW9uIGZvcmNlTG9hZExhenlGaWxlKCkgewogICAgICAgICAgICBpZiAoIUZTLmZvcmNlTG9hZEZpbGUobm9kZSkpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gZnVuY3Rpb24gc3RyZWFtX29wc19yZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgIGlmICghRlMuZm9yY2VMb2FkRmlsZShub2RlKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50czsKICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpIHJldHVybiAwCiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKGNvbnRlbnRzLmxlbmd0aCAtIHBvc2l0aW9uLCBsZW5ndGgpOwogICAgICAgICAgYXNzZXJ0KHNpemUgPj0gMCk7CiAgICAgICAgICBpZiAoY29udGVudHMuc2xpY2UpIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgewogICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzLmdldChwb3NpdGlvbiArIGkpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2l6ZQogICAgICAgIH07CiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gc3RyZWFtX29wczsKICAgICAgICByZXR1cm4gbm9kZQogICAgICB9LAogICAgICBjcmVhdGVQcmVsb2FkZWRGaWxlOiBmdW5jdGlvbiAoCiAgICAgICAgcGFyZW50LAogICAgICAgIG5hbWUsCiAgICAgICAgdXJsLAogICAgICAgIGNhblJlYWQsCiAgICAgICAgY2FuV3JpdGUsCiAgICAgICAgb25sb2FkLAogICAgICAgIG9uZXJyb3IsCiAgICAgICAgZG9udENyZWF0ZUZpbGUsCiAgICAgICAgY2FuT3duLAogICAgICAgIHByZUZpbmlzaAogICAgICApIHsKICAgICAgICBCcm93c2VyLmluaXQoKTsKICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSC5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7CiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSB7CiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KSB7CiAgICAgICAgICAgIGlmIChwcmVGaW5pc2gpIHByZUZpbmlzaCgpOwogICAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7CiAgICAgICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBieXRlQXJyYXksIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChvbmxvYWQpIG9ubG9hZCgpOwogICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaGFuZGxlZCA9IGZhbHNlOwogICAgICAgICAgTW9kdWxlWydwcmVsb2FkUGx1Z2lucyddLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgewogICAgICAgICAgICBpZiAoaGFuZGxlZCkgcmV0dXJuCiAgICAgICAgICAgIGlmIChwbHVnaW5bJ2NhbkhhbmRsZSddKGZ1bGxuYW1lKSkgewogICAgICAgICAgICAgIHBsdWdpblsnaGFuZGxlJ10oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcigpOwogICAgICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICghaGFuZGxlZCkgZmluaXNoKGJ5dGVBcnJheSk7CiAgICAgICAgfQogICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koKTsKICAgICAgICBpZiAodHlwZW9mIHVybCA9PSAnc3RyaW5nJykgewogICAgICAgICAgQnJvd3Nlci5hc3luY0xvYWQoCiAgICAgICAgICAgIHVybCwKICAgICAgICAgICAgZnVuY3Rpb24gKGJ5dGVBcnJheSkgewogICAgICAgICAgICAgIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uZXJyb3IKICAgICAgICAgICk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHByb2Nlc3NEYXRhKHVybCk7CiAgICAgICAgfQogICAgICB9LAogICAgICBpbmRleGVkREI6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCCiAgICAgIH0sCiAgICAgIERCX05BTUU6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUKICAgICAgfSwKICAgICAgREJfVkVSU0lPTjogMjAsCiAgICAgIERCX1NUT1JFX05BTUU6ICdGSUxFX0RBVEEnLAogICAgICBzYXZlRmlsZXNUb0RCOiBmdW5jdGlvbiAocGF0aHMsIG9ubG9hZCwgb25lcnJvcikgewogICAgICAgIG9ubG9hZCA9IG9ubG9hZCB8fCBmdW5jdGlvbiAoKSB7fTsKICAgICAgICBvbmVycm9yID0gb25lcnJvciB8fCBmdW5jdGlvbiAoKSB7fTsKICAgICAgICB2YXIgaW5kZXhlZERCID0gRlMuaW5kZXhlZERCKCk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKEZTLkRCX05BTUUoKSwgRlMuREJfVkVSU0lPTik7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSkKICAgICAgICB9CiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gb3BlblJlcXVlc3Rfb251cGdyYWRlbmVlZGVkKCkgewogICAgICAgICAgY29uc29sZS5sb2coJ2NyZWF0aW5nIGRiJyk7CiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7CiAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTsKICAgICAgICB9OwogICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIG9wZW5SZXF1ZXN0X29uc3VjY2VzcygpIHsKICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDsKICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpOwogICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7CiAgICAgICAgICB2YXIgb2sgPSAwLAogICAgICAgICAgICBmYWlsID0gMCwKICAgICAgICAgICAgdG90YWwgPSBwYXRocy5sZW5ndGg7CiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7CiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOwogICAgICAgICAgICBlbHNlIG9uZXJyb3IoKTsKICAgICAgICAgIH0KICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBmaWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLCBwYXRoKTsKICAgICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBwdXRSZXF1ZXN0X29uc3VjY2VzcygpIHsKICAgICAgICAgICAgICBvaysrOwogICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBwdXRSZXF1ZXN0X29uZXJyb3IoKSB7CiAgICAgICAgICAgICAgZmFpbCsrOwogICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpOwogICAgICAgICAgICB9OwogICAgICAgICAgfSk7CiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjsKICAgICAgICB9OwogICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yOwogICAgICB9LAogICAgICBsb2FkRmlsZXNGcm9tREI6IGZ1bmN0aW9uIChwYXRocywgb25sb2FkLCBvbmVycm9yKSB7CiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8IGZ1bmN0aW9uICgpIHt9OwogICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8IGZ1bmN0aW9uICgpIHt9OwogICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gb25lcnJvcihlKQogICAgICAgIH0KICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBvbmVycm9yOwogICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIG9wZW5SZXF1ZXN0X29uc3VjY2VzcygpIHsKICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWRvbmx5Jyk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIG9uZXJyb3IoZSk7CiAgICAgICAgICAgIHJldHVybgogICAgICAgICAgfQogICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7CiAgICAgICAgICB2YXIgb2sgPSAwLAogICAgICAgICAgICBmYWlsID0gMCwKICAgICAgICAgICAgdG90YWwgPSBwYXRocy5sZW5ndGg7CiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7CiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOwogICAgICAgICAgICBlbHNlIG9uZXJyb3IoKTsKICAgICAgICAgIH0KICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICAgICAgdmFyIGdldFJlcXVlc3QgPSBmaWxlcy5nZXQocGF0aCk7CiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gZ2V0UmVxdWVzdF9vbnN1Y2Nlc3MoKSB7CiAgICAgICAgICAgICAgaWYgKEZTLmFuYWx5emVQYXRoKHBhdGgpLmV4aXN0cykgewogICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBGUy5jcmVhdGVEYXRhRmlsZShQQVRILmRpcm5hbWUocGF0aCksIFBBVEguYmFzZW5hbWUocGF0aCksIGdldFJlcXVlc3QucmVzdWx0LCB0cnVlLCB0cnVlLCB0cnVlKTsKICAgICAgICAgICAgICBvaysrOwogICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpOwogICAgICAgICAgICB9OwogICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0X29uZXJyb3IoKSB7CiAgICAgICAgICAgICAgZmFpbCsrOwogICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpOwogICAgICAgICAgICB9OwogICAgICAgICAgfSk7CiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjsKICAgICAgICB9OwogICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yOwogICAgICB9LAogICAgfTsKICAgIHZhciBTWVNDQUxMUyA9IHsKICAgICAgREVGQVVMVF9QT0xMTUFTSzogNSwKICAgICAgbWFwcGluZ3M6IHt9LAogICAgICB1bWFzazogNTExLAogICAgICBjYWxjdWxhdGVBdDogZnVuY3Rpb24gKGRpcmZkLCBwYXRoKSB7CiAgICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJykgewogICAgICAgICAgdmFyIGRpcjsKICAgICAgICAgIGlmIChkaXJmZCA9PT0gLTEwMCkgewogICAgICAgICAgICBkaXIgPSBGUy5jd2QoKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBkaXJzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZGlyZmQpOwogICAgICAgICAgICBpZiAoIWRpcnN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgICAgIGRpciA9IGRpcnN0cmVhbS5wYXRoOwogICAgICAgICAgfQogICAgICAgICAgcGF0aCA9IFBBVEguam9pbjIoZGlyLCBwYXRoKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhdGgKICAgICAgfSwKICAgICAgZG9TdGF0OiBmdW5jdGlvbiAoZnVuYywgcGF0aCwgYnVmKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBzdGF0ID0gZnVuYyhwYXRoKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBpZiAoZSAmJiBlLm5vZGUgJiYgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSkpIHsKICAgICAgICAgICAgcmV0dXJuIC1FUlJOT19DT0RFUy5FTk9URElSCiAgICAgICAgICB9CiAgICAgICAgICB0aHJvdyBlCiAgICAgICAgfQogICAgICAgIEhFQVAzMltidWYgPj4gMl0gPSBzdGF0LmRldjsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDQpID4+IDJdID0gMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDgpID4+IDJdID0gc3RhdC5pbm87CiAgICAgICAgSEVBUDMyWyhidWYgKyAxMikgPj4gMl0gPSBzdGF0Lm1vZGU7CiAgICAgICAgSEVBUDMyWyhidWYgKyAxNikgPj4gMl0gPSBzdGF0Lm5saW5rOwogICAgICAgIEhFQVAzMlsoYnVmICsgMjApID4+IDJdID0gc3RhdC51aWQ7CiAgICAgICAgSEVBUDMyWyhidWYgKyAyNCkgPj4gMl0gPSBzdGF0LmdpZDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDI4KSA+PiAyXSA9IHN0YXQucmRldjsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDMyKSA+PiAyXSA9IDA7CiAgICAgICAgSEVBUDMyWyhidWYgKyAzNikgPj4gMl0gPSBzdGF0LnNpemU7CiAgICAgICAgSEVBUDMyWyhidWYgKyA0MCkgPj4gMl0gPSA0MDk2OwogICAgICAgIEhFQVAzMlsoYnVmICsgNDQpID4+IDJdID0gc3RhdC5ibG9ja3M7CiAgICAgICAgSEVBUDMyWyhidWYgKyA0OCkgPj4gMl0gPSAoc3RhdC5hdGltZS5nZXRUaW1lKCkgLyAxZTMpIHwgMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDUyKSA+PiAyXSA9IDA7CiAgICAgICAgSEVBUDMyWyhidWYgKyA1NikgPj4gMl0gPSAoc3RhdC5tdGltZS5nZXRUaW1lKCkgLyAxZTMpIHwgMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDYwKSA+PiAyXSA9IDA7CiAgICAgICAgSEVBUDMyWyhidWYgKyA2NCkgPj4gMl0gPSAoc3RhdC5jdGltZS5nZXRUaW1lKCkgLyAxZTMpIHwgMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDY4KSA+PiAyXSA9IDA7CiAgICAgICAgSEVBUDMyWyhidWYgKyA3MikgPj4gMl0gPSBzdGF0LmlubzsKICAgICAgICByZXR1cm4gMAogICAgICB9LAogICAgICBkb01zeW5jOiBmdW5jdGlvbiAoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzKSB7CiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KEhFQVBVOC5zdWJhcnJheShhZGRyLCBhZGRyICsgbGVuKSk7CiAgICAgICAgRlMubXN5bmMoc3RyZWFtLCBidWZmZXIsIDAsIGxlbiwgZmxhZ3MpOwogICAgICB9LAogICAgICBkb01rZGlyOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkgewogICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTsKICAgICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aCAtIDEpOwogICAgICAgIEZTLm1rZGlyKHBhdGgsIG1vZGUsIDApOwogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIGRvTWtub2Q6IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBkZXYpIHsKICAgICAgICBzd2l0Y2ggKG1vZGUgJiA2MTQ0MCkgewogICAgICAgICAgY2FzZSAzMjc2ODoKICAgICAgICAgIGNhc2UgODE5MjoKICAgICAgICAgIGNhc2UgMjQ1NzY6CiAgICAgICAgICBjYXNlIDQwOTY6CiAgICAgICAgICBjYXNlIDQ5MTUyOgogICAgICAgICAgICBicmVhawogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgcmV0dXJuIC1FUlJOT19DT0RFUy5FSU5WQUwKICAgICAgICB9CiAgICAgICAgRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTsKICAgICAgICByZXR1cm4gMAogICAgICB9LAogICAgICBkb1JlYWRsaW5rOiBmdW5jdGlvbiAocGF0aCwgYnVmLCBidWZzaXplKSB7CiAgICAgICAgaWYgKGJ1ZnNpemUgPD0gMCkgcmV0dXJuIC1FUlJOT19DT0RFUy5FSU5WQUwKICAgICAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7CiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTsKICAgICAgICB2YXIgZW5kQ2hhciA9IEhFQVA4W2J1ZiArIGxlbl07CiAgICAgICAgc3RyaW5nVG9VVEY4KHJldCwgYnVmLCBidWZzaXplICsgMSk7CiAgICAgICAgSEVBUDhbYnVmICsgbGVuXSA9IGVuZENoYXI7CiAgICAgICAgcmV0dXJuIGxlbgogICAgICB9LAogICAgICBkb0FjY2VzczogZnVuY3Rpb24gKHBhdGgsIGFtb2RlKSB7CiAgICAgICAgaWYgKGFtb2RlICYgfjcpIHsKICAgICAgICAgIHJldHVybiAtRVJSTk9fQ09ERVMuRUlOVkFMCiAgICAgICAgfQogICAgICAgIHZhciBub2RlOwogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pOwogICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICB2YXIgcGVybXMgPSAnJzsKICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7CiAgICAgICAgaWYgKGFtb2RlICYgMikgcGVybXMgKz0gJ3cnOwogICAgICAgIGlmIChhbW9kZSAmIDEpIHBlcm1zICs9ICd4JzsKICAgICAgICBpZiAocGVybXMgJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkgewogICAgICAgICAgcmV0dXJuIC1FUlJOT19DT0RFUy5FQUNDRVMKICAgICAgICB9CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSwKICAgICAgZG9EdXA6IGZ1bmN0aW9uIChwYXRoLCBmbGFncywgc3VnZ2VzdEZEKSB7CiAgICAgICAgdmFyIHN1Z2dlc3QgPSBGUy5nZXRTdHJlYW0oc3VnZ2VzdEZEKTsKICAgICAgICBpZiAoc3VnZ2VzdCkgRlMuY2xvc2Uoc3VnZ2VzdCk7CiAgICAgICAgcmV0dXJuIEZTLm9wZW4ocGF0aCwgZmxhZ3MsIDAsIHN1Z2dlc3RGRCwgc3VnZ2VzdEZEKS5mZAogICAgICB9LAogICAgICBkb1JlYWR2OiBmdW5jdGlvbiAoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7CiAgICAgICAgdmFyIHJldCA9IDA7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykgewogICAgICAgICAgdmFyIHB0ciA9IEhFQVAzMlsoaW92ICsgaSAqIDgpID4+IDJdOwogICAgICAgICAgdmFyIGxlbiA9IEhFQVAzMlsoaW92ICsgKGkgKiA4ICsgNCkpID4+IDJdOwogICAgICAgICAgdmFyIGN1cnIgPSBGUy5yZWFkKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpOwogICAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTEKICAgICAgICAgIHJldCArPSBjdXJyOwogICAgICAgICAgaWYgKGN1cnIgPCBsZW4pIGJyZWFrCiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQKICAgICAgfSwKICAgICAgZG9Xcml0ZXY6IGZ1bmN0aW9uIChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHsKICAgICAgICB2YXIgcmV0ID0gMDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7CiAgICAgICAgICB2YXIgcHRyID0gSEVBUDMyWyhpb3YgKyBpICogOCkgPj4gMl07CiAgICAgICAgICB2YXIgbGVuID0gSEVBUDMyWyhpb3YgKyAoaSAqIDggKyA0KSkgPj4gMl07CiAgICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuLCBvZmZzZXQpOwogICAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTEKICAgICAgICAgIHJldCArPSBjdXJyOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0sCiAgICAgIHZhcmFyZ3M6IDAsCiAgICAgIGdldDogZnVuY3Rpb24gKHZhcmFyZ3MpIHsKICAgICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDQ7CiAgICAgICAgdmFyIHJldCA9IEhFQVAzMlsoU1lTQ0FMTFMudmFyYXJncyAtIDQpID4+IDJdOwogICAgICAgIHJldHVybiByZXQKICAgICAgfSwKICAgICAgZ2V0U3RyOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIHJldCA9IFBvaW50ZXJfc3RyaW5naWZ5KFNZU0NBTExTLmdldCgpKTsKICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0sCiAgICAgIGdldFN0cmVhbUZyb21GRDogZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oU1lTQ0FMTFMuZ2V0KCkpOwogICAgICAgIGlmICghc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICByZXR1cm4gc3RyZWFtCiAgICAgIH0sCiAgICAgIGdldFNvY2tldEZyb21GRDogZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBzb2NrZXQgPSBTT0NLRlMuZ2V0U29ja2V0KFNZU0NBTExTLmdldCgpKTsKICAgICAgICBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgcmV0dXJuIHNvY2tldAogICAgICB9LAogICAgICBnZXRTb2NrZXRBZGRyZXNzOiBmdW5jdGlvbiAoYWxsb3dOdWxsKSB7CiAgICAgICAgdmFyIGFkZHJwID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBhZGRybGVuID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgaWYgKGFsbG93TnVsbCAmJiBhZGRycCA9PT0gMCkgcmV0dXJuIG51bGwKICAgICAgICB2YXIgaW5mbyA9IF9fcmVhZF9zb2NrYWRkcihhZGRycCwgYWRkcmxlbik7CiAgICAgICAgaWYgKGluZm8uZXJybm8pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGluZm8uZXJybm8pCiAgICAgICAgaW5mby5hZGRyID0gRE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcikgfHwgaW5mby5hZGRyOwogICAgICAgIHJldHVybiBpbmZvCiAgICAgIH0sCiAgICAgIGdldDY0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIGxvdyA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgaGlnaCA9IFNZU0NBTExTLmdldCgpOwogICAgICAgIGlmIChsb3cgPj0gMCkgYXNzZXJ0KGhpZ2ggPT09IDApOwogICAgICAgIGVsc2UgYXNzZXJ0KGhpZ2ggPT09IC0xKTsKICAgICAgICByZXR1cm4gbG93CiAgICAgIH0sCiAgICAgIGdldFplcm86IGZ1bmN0aW9uICgpIHsKICAgICAgICBhc3NlcnQoU1lTQ0FMTFMuZ2V0KCkgPT09IDApOwogICAgICB9LAogICAgfTsKICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGwxNDAod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLAogICAgICAgICAgb2Zmc2V0X2hpZ2ggPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIG9mZnNldF9sb3cgPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIHJlc3VsdCA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgd2hlbmNlID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldF9sb3c7CiAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpOwogICAgICAgIEhFQVAzMltyZXN1bHQgPj4gMl0gPSBzdHJlYW0ucG9zaXRpb247CiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOwogICAgICAgIHJldHVybiAwCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGwxNDUod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLAogICAgICAgICAgaW92ID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBpb3ZjbnQgPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX19zeXNjYWxsMTQ2KHdoaWNoLCB2YXJhcmdzKSB7CiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzOwogICAgICB0cnkgewogICAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKSwKICAgICAgICAgIGlvdiA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgaW92Y250ID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgcmV0dXJuIFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGwxODMod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIGJ1ZiA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgc2l6ZSA9IFNZU0NBTExTLmdldCgpOwogICAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLUVSUk5PX0NPREVTLkVJTlZBTAogICAgICAgIHZhciBjd2QgPSBGUy5jd2QoKTsKICAgICAgICB2YXIgY3dkTGVuZ3RoSW5CeXRlcyA9IGxlbmd0aEJ5dGVzVVRGOChjd2QpOwogICAgICAgIGlmIChzaXplIDwgY3dkTGVuZ3RoSW5CeXRlcyArIDEpIHJldHVybiAtRVJSTk9fQ09ERVMuRVJBTkdFCiAgICAgICAgc3RyaW5nVG9VVEY4KGN3ZCwgYnVmLCBzaXplKTsKICAgICAgICByZXR1cm4gYnVmCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGwxOTgod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIoKSwKICAgICAgICAgIG93bmVyID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBncm91cCA9IFNZU0NBTExTLmdldCgpOwogICAgICAgIEZTLmNob3duKHBhdGgsIG93bmVyLCBncm91cCk7CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgdmFyIFBST0NJTkZPID0geyBwcGlkOiAxLCBwaWQ6IDQyLCBzaWQ6IDQyLCBwZ2lkOiA0MiB9OwogICAgZnVuY3Rpb24gX19fc3lzY2FsbDIwKHdoaWNoLCB2YXJhcmdzKSB7CiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzOwogICAgICB0cnkgewogICAgICAgIHJldHVybiBQUk9DSU5GTy5waWQKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDYod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpOwogICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDYwKHdoaWNoLCB2YXJhcmdzKSB7CiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzOwogICAgICB0cnkgewogICAgICAgIHZhciBtYXNrID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgdmFyIG9sZCA9IFNZU0NBTExTLnVtYXNrOwogICAgICAgIFNZU0NBTExTLnVtYXNrID0gbWFzazsKICAgICAgICByZXR1cm4gb2xkCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGw4Myh3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgdGFyZ2V0ID0gU1lTQ0FMTFMuZ2V0U3RyKCksCiAgICAgICAgICBsaW5rcGF0aCA9IFNZU0NBTExTLmdldFN0cigpOwogICAgICAgIEZTLnN5bWxpbmsodGFyZ2V0LCBsaW5rcGF0aCk7CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDkxKHdoaWNoLCB2YXJhcmdzKSB7CiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzOwogICAgICB0cnkgewogICAgICAgIHZhciBhZGRyID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBsZW4gPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICB2YXIgaW5mbyA9IFNZU0NBTExTLm1hcHBpbmdzW2FkZHJdOwogICAgICAgIGlmICghaW5mbykgcmV0dXJuIDAKICAgICAgICBpZiAobGVuID09PSBpbmZvLmxlbikgewogICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShpbmZvLmZkKTsKICAgICAgICAgIFNZU0NBTExTLmRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGluZm8uZmxhZ3MpOwogICAgICAgICAgRlMubXVubWFwKHN0cmVhbSk7CiAgICAgICAgICBTWVNDQUxMUy5tYXBwaW5nc1thZGRyXSA9IG51bGw7CiAgICAgICAgICBpZiAoaW5mby5hbGxvY2F0ZWQpIHsKICAgICAgICAgICAgX2ZyZWUoaW5mby5tYWxsb2MpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gMAogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX191bmxvY2soKSB7fQogICAgdmFyIHN0cnVjdFJlZ2lzdHJhdGlvbnMgPSB7fTsKICAgIGZ1bmN0aW9uIHJ1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKSB7CiAgICAgIHdoaWxlIChkZXN0cnVjdG9ycy5sZW5ndGgpIHsKICAgICAgICB2YXIgcHRyID0gZGVzdHJ1Y3RvcnMucG9wKCk7CiAgICAgICAgdmFyIGRlbCA9IGRlc3RydWN0b3JzLnBvcCgpOwogICAgICAgIGRlbChwdHIpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgIHJldHVybiB0aGlzWydmcm9tV2lyZVR5cGUnXShIRUFQVTMyW3BvaW50ZXIgPj4gMl0pCiAgICB9CiAgICB2YXIgYXdhaXRpbmdEZXBlbmRlbmNpZXMgPSB7fTsKICAgIHZhciByZWdpc3RlcmVkVHlwZXMgPSB7fTsKICAgIHZhciB0eXBlRGVwZW5kZW5jaWVzID0ge307CiAgICB2YXIgY2hhcl8wID0gNDg7CiAgICB2YXIgY2hhcl85ID0gNTc7CiAgICBmdW5jdGlvbiBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSkgewogICAgICBpZiAodW5kZWZpbmVkID09PSBuYW1lKSB7CiAgICAgICAgcmV0dXJuICdfdW5rbm93bicKICAgICAgfQogICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csICckJyk7CiAgICAgIHZhciBmID0gbmFtZS5jaGFyQ29kZUF0KDApOwogICAgICBpZiAoZiA+PSBjaGFyXzAgJiYgZiA8PSBjaGFyXzkpIHsKICAgICAgICByZXR1cm4gJ18nICsgbmFtZQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBuYW1lCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGNyZWF0ZU5hbWVkRnVuY3Rpb24obmFtZSwgYm9keSkgewogICAgICBuYW1lID0gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpOwogICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKAogICAgICAgICdib2R5JywKICAgICAgICAncmV0dXJuIGZ1bmN0aW9uICcgKyBuYW1lICsgJygpIHtcbicgKyAnICAgICJ1c2Ugc3RyaWN0IjsnICsgJyAgICByZXR1cm4gYm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuJyArICd9O1xuJwogICAgICApKGJvZHkpCiAgICB9CiAgICBmdW5jdGlvbiBleHRlbmRFcnJvcihiYXNlRXJyb3JUeXBlLCBlcnJvck5hbWUpIHsKICAgICAgdmFyIGVycm9yQ2xhc3MgPSBjcmVhdGVOYW1lZEZ1bmN0aW9uKGVycm9yTmFtZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHsKICAgICAgICB0aGlzLm5hbWUgPSBlcnJvck5hbWU7CiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICAgICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7CiAgICAgICAgaWYgKHN0YWNrICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCkgKyAnXG4nICsgc3RhY2sucmVwbGFjZSgvXkVycm9yKDpbXlxuXSopP1xuLywgJycpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGVycm9yQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlRXJyb3JUeXBlLnByb3RvdHlwZSk7CiAgICAgIGVycm9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXJyb3JDbGFzczsKICAgICAgZXJyb3JDbGFzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlCiAgICAgICAgfQogICAgICB9OwogICAgICByZXR1cm4gZXJyb3JDbGFzcwogICAgfQogICAgdmFyIEludGVybmFsRXJyb3IgPSB1bmRlZmluZWQ7CiAgICBmdW5jdGlvbiB0aHJvd0ludGVybmFsRXJyb3IobWVzc2FnZSkgewogICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihtZXNzYWdlKQogICAgfQogICAgZnVuY3Rpb24gd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQobXlUeXBlcywgZGVwZW5kZW50VHlwZXMsIGdldFR5cGVDb252ZXJ0ZXJzKSB7CiAgICAgIG15VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgewogICAgICAgIHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0gPSBkZXBlbmRlbnRUeXBlczsKICAgICAgfSk7CiAgICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpIHsKICAgICAgICB2YXIgbXlUeXBlQ29udmVydGVycyA9IGdldFR5cGVDb252ZXJ0ZXJzKHR5cGVDb252ZXJ0ZXJzKTsKICAgICAgICBpZiAobXlUeXBlQ29udmVydGVycy5sZW5ndGggIT09IG15VHlwZXMubGVuZ3RoKSB7CiAgICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ01pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnQnKTsKICAgICAgICB9CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBteVR5cGVzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICByZWdpc3RlclR5cGUobXlUeXBlc1tpXSwgbXlUeXBlQ29udmVydGVyc1tpXSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciB0eXBlQ29udmVydGVycyA9IG5ldyBBcnJheShkZXBlbmRlbnRUeXBlcy5sZW5ndGgpOwogICAgICB2YXIgdW5yZWdpc3RlcmVkVHlwZXMgPSBbXTsKICAgICAgdmFyIHJlZ2lzdGVyZWQgPSAwOwogICAgICBkZXBlbmRlbnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChkdCwgaSkgewogICAgICAgIGlmIChyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkoZHQpKSB7CiAgICAgICAgICB0eXBlQ29udmVydGVyc1tpXSA9IHJlZ2lzdGVyZWRUeXBlc1tkdF07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHVucmVnaXN0ZXJlZFR5cGVzLnB1c2goZHQpOwogICAgICAgICAgaWYgKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHsKICAgICAgICAgICAgYXdhaXRpbmdEZXBlbmRlbmNpZXNbZHRdID0gW107CiAgICAgICAgICB9CiAgICAgICAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0ucHVzaChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHR5cGVDb252ZXJ0ZXJzW2ldID0gcmVnaXN0ZXJlZFR5cGVzW2R0XTsKICAgICAgICAgICAgKytyZWdpc3RlcmVkOwogICAgICAgICAgICBpZiAocmVnaXN0ZXJlZCA9PT0gdW5yZWdpc3RlcmVkVHlwZXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgb25Db21wbGV0ZSh0eXBlQ29udmVydGVycyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGlmICgwID09PSB1bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpIHsKICAgICAgICBvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0KHN0cnVjdFR5cGUpIHsKICAgICAgdmFyIHJlZyA9IHN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV07CiAgICAgIGRlbGV0ZSBzdHJ1Y3RSZWdpc3RyYXRpb25zW3N0cnVjdFR5cGVdOwogICAgICB2YXIgcmF3Q29uc3RydWN0b3IgPSByZWcucmF3Q29uc3RydWN0b3I7CiAgICAgIHZhciByYXdEZXN0cnVjdG9yID0gcmVnLnJhd0Rlc3RydWN0b3I7CiAgICAgIHZhciBmaWVsZFJlY29yZHMgPSByZWcuZmllbGRzOwogICAgICB2YXIgZmllbGRUeXBlcyA9IGZpZWxkUmVjb3JkcwogICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7CiAgICAgICAgICByZXR1cm4gZmllbGQuZ2V0dGVyUmV0dXJuVHlwZQogICAgICAgIH0pCiAgICAgICAgLmNvbmNhdCgKICAgICAgICAgIGZpZWxkUmVjb3Jkcy5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7CiAgICAgICAgICAgIHJldHVybiBmaWVsZC5zZXR0ZXJBcmd1bWVudFR5cGUKICAgICAgICAgIH0pCiAgICAgICAgKTsKICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW3N0cnVjdFR5cGVdLCBmaWVsZFR5cGVzLCBmdW5jdGlvbiAoZmllbGRUeXBlcykgewogICAgICAgIHZhciBmaWVsZHMgPSB7fTsKICAgICAgICBmaWVsZFJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHsKICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZC5maWVsZE5hbWU7CiAgICAgICAgICB2YXIgZ2V0dGVyUmV0dXJuVHlwZSA9IGZpZWxkVHlwZXNbaV07CiAgICAgICAgICB2YXIgZ2V0dGVyID0gZmllbGQuZ2V0dGVyOwogICAgICAgICAgdmFyIGdldHRlckNvbnRleHQgPSBmaWVsZC5nZXR0ZXJDb250ZXh0OwogICAgICAgICAgdmFyIHNldHRlckFyZ3VtZW50VHlwZSA9IGZpZWxkVHlwZXNbaSArIGZpZWxkUmVjb3Jkcy5sZW5ndGhdOwogICAgICAgICAgdmFyIHNldHRlciA9IGZpZWxkLnNldHRlcjsKICAgICAgICAgIHZhciBzZXR0ZXJDb250ZXh0ID0gZmllbGQuc2V0dGVyQ29udGV4dDsKICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gewogICAgICAgICAgICByZWFkOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGdldHRlclJldHVyblR5cGVbJ2Zyb21XaXJlVHlwZSddKGdldHRlcihnZXR0ZXJDb250ZXh0LCBwdHIpKQogICAgICAgICAgICB9LAogICAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gKHB0ciwgbykgewogICAgICAgICAgICAgIHZhciBkZXN0cnVjdG9ycyA9IFtdOwogICAgICAgICAgICAgIHNldHRlcihzZXR0ZXJDb250ZXh0LCBwdHIsIHNldHRlckFyZ3VtZW50VHlwZVsndG9XaXJlVHlwZSddKGRlc3RydWN0b3JzLCBvKSk7CiAgICAgICAgICAgICAgcnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpOwogICAgICAgICAgICB9LAogICAgICAgICAgfTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiByZWcubmFtZSwKICAgICAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgICAgICAgdmFyIHJ2ID0ge307CiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBmaWVsZHMpIHsKICAgICAgICAgICAgICAgIHJ2W2ldID0gZmllbGRzW2ldLnJlYWQocHRyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmF3RGVzdHJ1Y3RvcihwdHIpOwogICAgICAgICAgICAgIHJldHVybiBydgogICAgICAgICAgICB9LAogICAgICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbiAoZGVzdHJ1Y3RvcnMsIG8pIHsKICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzKSB7CiAgICAgICAgICAgICAgICBpZiAoIShmaWVsZE5hbWUgaW4gbykpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBmaWVsZCcpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBwdHIgPSByYXdDb25zdHJ1Y3RvcigpOwogICAgICAgICAgICAgIGZvciAoZmllbGROYW1lIGluIGZpZWxkcykgewogICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0ud3JpdGUocHRyLCBvW2ZpZWxkTmFtZV0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2gocmF3RGVzdHJ1Y3RvciwgcHRyKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgICAgICB9LAogICAgICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IHJhd0Rlc3RydWN0b3IsCiAgICAgICAgICB9LAogICAgICAgIF0KICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBnZXRTaGlmdEZyb21TaXplKHNpemUpIHsKICAgICAgc3dpdGNoIChzaXplKSB7CiAgICAgICAgY2FzZSAxOgogICAgICAgICAgcmV0dXJuIDAKICAgICAgICBjYXNlIDI6CiAgICAgICAgICByZXR1cm4gMQogICAgICAgIGNhc2UgNDoKICAgICAgICAgIHJldHVybiAyCiAgICAgICAgY2FzZSA4OgogICAgICAgICAgcmV0dXJuIDMKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biB0eXBlIHNpemU6ICcgKyBzaXplKQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBlbWJpbmRfaW5pdF9jaGFyQ29kZXMoKSB7CiAgICAgIHZhciBjb2RlcyA9IG5ldyBBcnJheSgyNTYpOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7CiAgICAgICAgY29kZXNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpOwogICAgICB9CiAgICAgIGVtYmluZF9jaGFyQ29kZXMgPSBjb2RlczsKICAgIH0KICAgIHZhciBlbWJpbmRfY2hhckNvZGVzID0gdW5kZWZpbmVkOwogICAgZnVuY3Rpb24gcmVhZExhdGluMVN0cmluZyhwdHIpIHsKICAgICAgdmFyIHJldCA9ICcnOwogICAgICB2YXIgYyA9IHB0cjsKICAgICAgd2hpbGUgKEhFQVBVOFtjXSkgewogICAgICAgIHJldCArPSBlbWJpbmRfY2hhckNvZGVzW0hFQVBVOFtjKytdXTsKICAgICAgfQogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICB2YXIgQmluZGluZ0Vycm9yID0gdW5kZWZpbmVkOwogICAgZnVuY3Rpb24gdGhyb3dCaW5kaW5nRXJyb3IobWVzc2FnZSkgewogICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG1lc3NhZ2UpCiAgICB9CiAgICBmdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSwgcmVnaXN0ZXJlZEluc3RhbmNlLCBvcHRpb25zKSB7CiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICBpZiAoISgnYXJnUGFja0FkdmFuY2UnIGluIHJlZ2lzdGVyZWRJbnN0YW5jZSkpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlJykKICAgICAgfQogICAgICB2YXIgbmFtZSA9IHJlZ2lzdGVyZWRJbnN0YW5jZS5uYW1lOwogICAgICBpZiAoIXJhd1R5cGUpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigndHlwZSAiJyArIG5hbWUgKyAnIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyJyk7CiAgICAgIH0KICAgICAgaWYgKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSkgewogICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpIHsKICAgICAgICAgIHJldHVybgogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyIgKyBuYW1lICsgIicgdHdpY2UiKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdID0gcmVnaXN0ZXJlZEluc3RhbmNlOwogICAgICBkZWxldGUgdHlwZURlcGVuZGVuY2llc1tyYXdUeXBlXTsKICAgICAgaWYgKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKSB7CiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdOwogICAgICAgIGRlbGV0ZSBhd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTsKICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsKICAgICAgICAgIGNiKCk7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wocmF3VHlwZSwgbmFtZSwgc2l6ZSwgdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlKSB7CiAgICAgIHZhciBzaGlmdCA9IGdldFNoaWZ0RnJvbVNpemUoc2l6ZSk7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICByZWdpc3RlclR5cGUocmF3VHlwZSwgewogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAod3QpIHsKICAgICAgICAgIHJldHVybiAhIXd0CiAgICAgICAgfSwKICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbiAoZGVzdHJ1Y3RvcnMsIG8pIHsKICAgICAgICAgIHJldHVybiBvID8gdHJ1ZVZhbHVlIDogZmFsc2VWYWx1ZQogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGZ1bmN0aW9uIChwb2ludGVyKSB7CiAgICAgICAgICB2YXIgaGVhcDsKICAgICAgICAgIGlmIChzaXplID09PSAxKSB7CiAgICAgICAgICAgIGhlYXAgPSBIRUFQODsKICAgICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikgewogICAgICAgICAgICBoZWFwID0gSEVBUDE2OwogICAgICAgICAgfSBlbHNlIGlmIChzaXplID09PSA0KSB7CiAgICAgICAgICAgIGhlYXAgPSBIRUFQMzI7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGJvb2xlYW4gdHlwZSBzaXplOiAnICsgbmFtZSkKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzWydmcm9tV2lyZVR5cGUnXShoZWFwW3BvaW50ZXIgPj4gc2hpZnRdKQogICAgICAgIH0sCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsLAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzQWxpYXNPZihvdGhlcikgewogICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xhc3NIYW5kbGUpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIH0KICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBDbGFzc0hhbmRsZSkpIHsKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICB2YXIgbGVmdENsYXNzID0gdGhpcy4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIGxlZnQgPSB0aGlzLiQkLnB0cjsKICAgICAgdmFyIHJpZ2h0Q2xhc3MgPSBvdGhlci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIHJpZ2h0ID0gb3RoZXIuJCQucHRyOwogICAgICB3aGlsZSAobGVmdENsYXNzLmJhc2VDbGFzcykgewogICAgICAgIGxlZnQgPSBsZWZ0Q2xhc3MudXBjYXN0KGxlZnQpOwogICAgICAgIGxlZnRDbGFzcyA9IGxlZnRDbGFzcy5iYXNlQ2xhc3M7CiAgICAgIH0KICAgICAgd2hpbGUgKHJpZ2h0Q2xhc3MuYmFzZUNsYXNzKSB7CiAgICAgICAgcmlnaHQgPSByaWdodENsYXNzLnVwY2FzdChyaWdodCk7CiAgICAgICAgcmlnaHRDbGFzcyA9IHJpZ2h0Q2xhc3MuYmFzZUNsYXNzOwogICAgICB9CiAgICAgIHJldHVybiBsZWZ0Q2xhc3MgPT09IHJpZ2h0Q2xhc3MgJiYgbGVmdCA9PT0gcmlnaHQKICAgIH0KICAgIGZ1bmN0aW9uIHNoYWxsb3dDb3B5SW50ZXJuYWxQb2ludGVyKG8pIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBjb3VudDogby5jb3VudCwKICAgICAgICBkZWxldGVTY2hlZHVsZWQ6IG8uZGVsZXRlU2NoZWR1bGVkLAogICAgICAgIHByZXNlcnZlUG9pbnRlck9uRGVsZXRlOiBvLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlLAogICAgICAgIHB0cjogby5wdHIsCiAgICAgICAgcHRyVHlwZTogby5wdHJUeXBlLAogICAgICAgIHNtYXJ0UHRyOiBvLnNtYXJ0UHRyLAogICAgICAgIHNtYXJ0UHRyVHlwZTogby5zbWFydFB0clR5cGUsCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZChvYmopIHsKICAgICAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VUeXBlTmFtZShoYW5kbGUpIHsKICAgICAgICByZXR1cm4gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLm5hbWUKICAgICAgfQogICAgICB0aHJvd0JpbmRpbmdFcnJvcihnZXRJbnN0YW5jZVR5cGVOYW1lKG9iaikgKyAnIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZCcpOwogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGVfY2xvbmUoKSB7CiAgICAgIGlmICghdGhpcy4kJC5wdHIpIHsKICAgICAgICB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHsKICAgICAgICB0aGlzLiQkLmNvdW50LnZhbHVlICs9IDE7CiAgICAgICAgcmV0dXJuIHRoaXMKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwgeyAkJDogeyB2YWx1ZTogc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIodGhpcy4kJCkgfSB9KTsKICAgICAgICBjbG9uZS4kJC5jb3VudC52YWx1ZSArPSAxOwogICAgICAgIGNsb25lLiQkLmRlbGV0ZVNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIHJldHVybiBjbG9uZQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBydW5EZXN0cnVjdG9yKGhhbmRsZSkgewogICAgICB2YXIgJCQgPSBoYW5kbGUuJCQ7CiAgICAgIGlmICgkJC5zbWFydFB0cikgewogICAgICAgICQkLnNtYXJ0UHRyVHlwZS5yYXdEZXN0cnVjdG9yKCQkLnNtYXJ0UHRyKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAkJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcy5yYXdEZXN0cnVjdG9yKCQkLnB0cik7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2RlbGV0ZSgpIHsKICAgICAgaWYgKCF0aGlzLiQkLnB0cikgewogICAgICAgIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTsKICAgICAgfQogICAgICBpZiAodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbicpOwogICAgICB9CiAgICAgIHRoaXMuJCQuY291bnQudmFsdWUgLT0gMTsKICAgICAgdmFyIHRvRGVsZXRlID0gMCA9PT0gdGhpcy4kJC5jb3VudC52YWx1ZTsKICAgICAgaWYgKHRvRGVsZXRlKSB7CiAgICAgICAgcnVuRGVzdHJ1Y3Rvcih0aGlzKTsKICAgICAgfQogICAgICBpZiAoIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpIHsKICAgICAgICB0aGlzLiQkLnNtYXJ0UHRyID0gdW5kZWZpbmVkOwogICAgICAgIHRoaXMuJCQucHRyID0gdW5kZWZpbmVkOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBDbGFzc0hhbmRsZV9pc0RlbGV0ZWQoKSB7CiAgICAgIHJldHVybiAhdGhpcy4kJC5wdHIKICAgIH0KICAgIHZhciBkZWxheUZ1bmN0aW9uID0gdW5kZWZpbmVkOwogICAgdmFyIGRlbGV0aW9uUXVldWUgPSBbXTsKICAgIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0RlbGV0ZXMoKSB7CiAgICAgIHdoaWxlIChkZWxldGlvblF1ZXVlLmxlbmd0aCkgewogICAgICAgIHZhciBvYmogPSBkZWxldGlvblF1ZXVlLnBvcCgpOwogICAgICAgIG9iai4kJC5kZWxldGVTY2hlZHVsZWQgPSBmYWxzZTsKICAgICAgICBvYmpbJ2RlbGV0ZSddKCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2RlbGV0ZUxhdGVyKCkgewogICAgICBpZiAoIXRoaXMuJCQucHRyKSB7CiAgICAgICAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpOwogICAgICB9CiAgICAgIGlmICh0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uJyk7CiAgICAgIH0KICAgICAgZGVsZXRpb25RdWV1ZS5wdXNoKHRoaXMpOwogICAgICBpZiAoZGVsZXRpb25RdWV1ZS5sZW5ndGggPT09IDEgJiYgZGVsYXlGdW5jdGlvbikgewogICAgICAgIGRlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyk7CiAgICAgIH0KICAgICAgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgPSB0cnVlOwogICAgICByZXR1cm4gdGhpcwogICAgfQogICAgZnVuY3Rpb24gaW5pdF9DbGFzc0hhbmRsZSgpIHsKICAgICAgQ2xhc3NIYW5kbGUucHJvdG90eXBlWydpc0FsaWFzT2YnXSA9IENsYXNzSGFuZGxlX2lzQWxpYXNPZjsKICAgICAgQ2xhc3NIYW5kbGUucHJvdG90eXBlWydjbG9uZSddID0gQ2xhc3NIYW5kbGVfY2xvbmU7CiAgICAgIENsYXNzSGFuZGxlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBDbGFzc0hhbmRsZV9kZWxldGU7CiAgICAgIENsYXNzSGFuZGxlLnByb3RvdHlwZVsnaXNEZWxldGVkJ10gPSBDbGFzc0hhbmRsZV9pc0RlbGV0ZWQ7CiAgICAgIENsYXNzSGFuZGxlLnByb3RvdHlwZVsnZGVsZXRlTGF0ZXInXSA9IENsYXNzSGFuZGxlX2RlbGV0ZUxhdGVyOwogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGUoKSB7fQogICAgdmFyIHJlZ2lzdGVyZWRQb2ludGVycyA9IHt9OwogICAgZnVuY3Rpb24gZW5zdXJlT3ZlcmxvYWRUYWJsZShwcm90bywgbWV0aG9kTmFtZSwgaHVtYW5OYW1lKSB7CiAgICAgIGlmICh1bmRlZmluZWQgPT09IHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpIHsKICAgICAgICB2YXIgcHJldkZ1bmMgPSBwcm90b1ttZXRob2ROYW1lXTsKICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGlmICghcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHMubGVuZ3RoKSkgewogICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigKICAgICAgICAgICAgICAiRnVuY3Rpb24gJyIgKwogICAgICAgICAgICAgICAgaHVtYW5OYW1lICsKICAgICAgICAgICAgICAgICInIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoIiArCiAgICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoICsKICAgICAgICAgICAgICAgICcpIC0gZXhwZWN0cyBvbmUgb2YgKCcgKwogICAgICAgICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSArCiAgICAgICAgICAgICAgICAnKSEnCiAgICAgICAgICAgICk7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgICAgICAgfTsKICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlID0gW107CiAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVtwcmV2RnVuYy5hcmdDb3VudF0gPSBwcmV2RnVuYzsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZXhwb3NlUHVibGljU3ltYm9sKG5hbWUsIHZhbHVlLCBudW1Bcmd1bWVudHMpIHsKICAgICAgaWYgKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgewogICAgICAgIGlmICgKICAgICAgICAgIHVuZGVmaW5lZCA9PT0gbnVtQXJndW1lbnRzIHx8CiAgICAgICAgICAodW5kZWZpbmVkICE9PSBNb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSAmJiB1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10pCiAgICAgICAgKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICciICsgbmFtZSArICInIHR3aWNlIik7CiAgICAgICAgfQogICAgICAgIGVuc3VyZU92ZXJsb2FkVGFibGUoTW9kdWxlLCBuYW1lLCBuYW1lKTsKICAgICAgICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KG51bUFyZ3VtZW50cykpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAnQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJyArIG51bUFyZ3VtZW50cyArICcpIScKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c10gPSB2YWx1ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBNb2R1bGVbbmFtZV0gPSB2YWx1ZTsKICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBudW1Bcmd1bWVudHMpIHsKICAgICAgICAgIE1vZHVsZVtuYW1lXS5udW1Bcmd1bWVudHMgPSBudW1Bcmd1bWVudHM7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkQ2xhc3MoCiAgICAgIG5hbWUsCiAgICAgIGNvbnN0cnVjdG9yLAogICAgICBpbnN0YW5jZVByb3RvdHlwZSwKICAgICAgcmF3RGVzdHJ1Y3RvciwKICAgICAgYmFzZUNsYXNzLAogICAgICBnZXRBY3R1YWxUeXBlLAogICAgICB1cGNhc3QsCiAgICAgIGRvd25jYXN0CiAgICApIHsKICAgICAgdGhpcy5uYW1lID0gbmFtZTsKICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yOwogICAgICB0aGlzLmluc3RhbmNlUHJvdG90eXBlID0gaW5zdGFuY2VQcm90b3R5cGU7CiAgICAgIHRoaXMucmF3RGVzdHJ1Y3RvciA9IHJhd0Rlc3RydWN0b3I7CiAgICAgIHRoaXMuYmFzZUNsYXNzID0gYmFzZUNsYXNzOwogICAgICB0aGlzLmdldEFjdHVhbFR5cGUgPSBnZXRBY3R1YWxUeXBlOwogICAgICB0aGlzLnVwY2FzdCA9IHVwY2FzdDsKICAgICAgdGhpcy5kb3duY2FzdCA9IGRvd25jYXN0OwogICAgICB0aGlzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zID0gW107CiAgICB9CiAgICBmdW5jdGlvbiB1cGNhc3RQb2ludGVyKHB0ciwgcHRyQ2xhc3MsIGRlc2lyZWRDbGFzcykgewogICAgICB3aGlsZSAocHRyQ2xhc3MgIT09IGRlc2lyZWRDbGFzcykgewogICAgICAgIGlmICghcHRyQ2xhc3MudXBjYXN0KSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiAnICsgZGVzaXJlZENsYXNzLm5hbWUgKyAnLCBnb3QgYW4gaW5zdGFuY2Ugb2YgJyArIHB0ckNsYXNzLm5hbWUpOwogICAgICAgIH0KICAgICAgICBwdHIgPSBwdHJDbGFzcy51cGNhc3QocHRyKTsKICAgICAgICBwdHJDbGFzcyA9IHB0ckNsYXNzLmJhc2VDbGFzczsKICAgICAgfQogICAgICByZXR1cm4gcHRyCiAgICB9CiAgICBmdW5jdGlvbiBjb25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7CiAgICAgIGlmIChoYW5kbGUgPT09IG51bGwpIHsKICAgICAgICBpZiAodGhpcy5pc1JlZmVyZW5jZSkgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ251bGwgaXMgbm90IGEgdmFsaWQgJyArIHRoaXMubmFtZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiAwCiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgIicgKyBfZW1iaW5kX3JlcHIoaGFuZGxlKSArICciIGFzIGEgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQucHRyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICcgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIHB0ciA9IHVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0ciwgaGFuZGxlQ2xhc3MsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTsKICAgICAgcmV0dXJuIHB0cgogICAgfQogICAgZnVuY3Rpb24gZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLCBoYW5kbGUpIHsKICAgICAgdmFyIHB0cjsKICAgICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkgewogICAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignbnVsbCBpcyBub3QgYSB2YWxpZCAnICsgdGhpcy5uYW1lKTsKICAgICAgICB9CiAgICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICAgIHB0ciA9IHRoaXMucmF3Q29uc3RydWN0b3IoKTsKICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICBkZXN0cnVjdG9ycy5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvciwgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwdHIKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIDAKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgIicgKyBfZW1iaW5kX3JlcHIoaGFuZGxlKSArICciIGFzIGEgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQucHRyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICcgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIGlmICghdGhpcy5pc0NvbnN0ICYmIGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3QpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigKICAgICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICcgKwogICAgICAgICAgICAoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA/IGhhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZSA6IGhhbmRsZS4kJC5wdHJUeXBlLm5hbWUpICsKICAgICAgICAgICAgJyB0byBwYXJhbWV0ZXIgdHlwZSAnICsKICAgICAgICAgICAgdGhpcy5uYW1lCiAgICAgICAgKTsKICAgICAgfQogICAgICB2YXIgaGFuZGxlQ2xhc3MgPSBoYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7CiAgICAgIHB0ciA9IHVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0ciwgaGFuZGxlQ2xhc3MsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTsKICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICBpZiAodW5kZWZpbmVkID09PSBoYW5kbGUuJCQuc21hcnRQdHIpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdQYXNzaW5nIHJhdyBwb2ludGVyIHRvIHNtYXJ0IHBvaW50ZXIgaXMgaWxsZWdhbCcpOwogICAgICAgIH0KICAgICAgICBzd2l0Y2ggKHRoaXMuc2hhcmluZ1BvbGljeSkgewogICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICBpZiAoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA9PT0gdGhpcykgewogICAgICAgICAgICAgIHB0ciA9IGhhbmRsZS4kJC5zbWFydFB0cjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigKICAgICAgICAgICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICcgKwogICAgICAgICAgICAgICAgICAoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZSA/IGhhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZSA6IGhhbmRsZS4kJC5wdHJUeXBlLm5hbWUpICsKICAgICAgICAgICAgICAgICAgJyB0byBwYXJhbWV0ZXIgdHlwZSAnICsKICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhawogICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBwdHIgPSBoYW5kbGUuJCQuc21hcnRQdHI7CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgIGlmIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzKSB7CiAgICAgICAgICAgICAgcHRyID0gaGFuZGxlLiQkLnNtYXJ0UHRyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBjbG9uZWRIYW5kbGUgPSBoYW5kbGVbJ2Nsb25lJ10oKTsKICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJhd1NoYXJlKAogICAgICAgICAgICAgICAgcHRyLAogICAgICAgICAgICAgICAgX19lbXZhbF9yZWdpc3RlcihmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIGNsb25lZEhhbmRsZVsnZGVsZXRlJ10oKTsKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICBpZiAoZGVzdHJ1Y3RvcnMgIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCBwdHIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhawogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ1Vuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeScpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcHRyCiAgICB9CiAgICBmdW5jdGlvbiBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycywgaGFuZGxlKSB7CiAgICAgIGlmIChoYW5kbGUgPT09IG51bGwpIHsKICAgICAgICBpZiAodGhpcy5pc1JlZmVyZW5jZSkgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ251bGwgaXMgbm90IGEgdmFsaWQgJyArIHRoaXMubmFtZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiAwCiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgIicgKyBfZW1iaW5kX3JlcHIoaGFuZGxlKSArICciIGFzIGEgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCFoYW5kbGUuJCQucHRyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICcgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIGlmIChoYW5kbGUuJCQucHRyVHlwZS5pc0NvbnN0KSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJyArIGhhbmRsZS4kJC5wdHJUeXBlLm5hbWUgKyAnIHRvIHBhcmFtZXRlciB0eXBlICcgKyB0aGlzLm5hbWUpOwogICAgICB9CiAgICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgdmFyIHB0ciA9IHVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0ciwgaGFuZGxlQ2xhc3MsIHRoaXMucmVnaXN0ZXJlZENsYXNzKTsKICAgICAgcmV0dXJuIHB0cgogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZ2V0UG9pbnRlZShwdHIpIHsKICAgICAgaWYgKHRoaXMucmF3R2V0UG9pbnRlZSkgewogICAgICAgIHB0ciA9IHRoaXMucmF3R2V0UG9pbnRlZShwdHIpOwogICAgICB9CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIFJlZ2lzdGVyZWRQb2ludGVyX2Rlc3RydWN0b3IocHRyKSB7CiAgICAgIGlmICh0aGlzLnJhd0Rlc3RydWN0b3IpIHsKICAgICAgICB0aGlzLnJhd0Rlc3RydWN0b3IocHRyKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZGVsZXRlT2JqZWN0KGhhbmRsZSkgewogICAgICBpZiAoaGFuZGxlICE9PSBudWxsKSB7CiAgICAgICAgaGFuZGxlWydkZWxldGUnXSgpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBkb3duY2FzdFBvaW50ZXIocHRyLCBwdHJDbGFzcywgZGVzaXJlZENsYXNzKSB7CiAgICAgIGlmIChwdHJDbGFzcyA9PT0gZGVzaXJlZENsYXNzKSB7CiAgICAgICAgcmV0dXJuIHB0cgogICAgICB9CiAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlc2lyZWRDbGFzcy5iYXNlQ2xhc3MpIHsKICAgICAgICByZXR1cm4gbnVsbAogICAgICB9CiAgICAgIHZhciBydiA9IGRvd25jYXN0UG9pbnRlcihwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MuYmFzZUNsYXNzKTsKICAgICAgaWYgKHJ2ID09PSBudWxsKSB7CiAgICAgICAgcmV0dXJuIG51bGwKICAgICAgfQogICAgICByZXR1cm4gZGVzaXJlZENsYXNzLmRvd25jYXN0KHJ2KQogICAgfQogICAgZnVuY3Rpb24gZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCgpIHsKICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRJbnN0YW5jZXMpLmxlbmd0aAogICAgfQogICAgZnVuY3Rpb24gZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcygpIHsKICAgICAgdmFyIHJ2ID0gW107CiAgICAgIGZvciAodmFyIGsgaW4gcmVnaXN0ZXJlZEluc3RhbmNlcykgewogICAgICAgIGlmIChyZWdpc3RlcmVkSW5zdGFuY2VzLmhhc093blByb3BlcnR5KGspKSB7CiAgICAgICAgICBydi5wdXNoKHJlZ2lzdGVyZWRJbnN0YW5jZXNba10pOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcnYKICAgIH0KICAgIGZ1bmN0aW9uIHNldERlbGF5RnVuY3Rpb24oZm4pIHsKICAgICAgZGVsYXlGdW5jdGlvbiA9IGZuOwogICAgICBpZiAoZGVsZXRpb25RdWV1ZS5sZW5ndGggJiYgZGVsYXlGdW5jdGlvbikgewogICAgICAgIGRlbGF5RnVuY3Rpb24oZmx1c2hQZW5kaW5nRGVsZXRlcyk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGluaXRfZW1iaW5kKCkgewogICAgICBNb2R1bGVbJ2dldEluaGVyaXRlZEluc3RhbmNlQ291bnQnXSA9IGdldEluaGVyaXRlZEluc3RhbmNlQ291bnQ7CiAgICAgIE1vZHVsZVsnZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcyddID0gZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlczsKICAgICAgTW9kdWxlWydmbHVzaFBlbmRpbmdEZWxldGVzJ10gPSBmbHVzaFBlbmRpbmdEZWxldGVzOwogICAgICBNb2R1bGVbJ3NldERlbGF5RnVuY3Rpb24nXSA9IHNldERlbGF5RnVuY3Rpb247CiAgICB9CiAgICB2YXIgcmVnaXN0ZXJlZEluc3RhbmNlcyA9IHt9OwogICAgZnVuY3Rpb24gZ2V0QmFzZXN0UG9pbnRlcihjbGFzc18sIHB0cikgewogICAgICBpZiAocHRyID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigncHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkJyk7CiAgICAgIH0KICAgICAgd2hpbGUgKGNsYXNzXy5iYXNlQ2xhc3MpIHsKICAgICAgICBwdHIgPSBjbGFzc18udXBjYXN0KHB0cik7CiAgICAgICAgY2xhc3NfID0gY2xhc3NfLmJhc2VDbGFzczsKICAgICAgfQogICAgICByZXR1cm4gcHRyCiAgICB9CiAgICBmdW5jdGlvbiBnZXRJbmhlcml0ZWRJbnN0YW5jZShjbGFzc18sIHB0cikgewogICAgICBwdHIgPSBnZXRCYXNlc3RQb2ludGVyKGNsYXNzXywgcHRyKTsKICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRJbnN0YW5jZXNbcHRyXQogICAgfQogICAgZnVuY3Rpb24gbWFrZUNsYXNzSGFuZGxlKHByb3RvdHlwZSwgcmVjb3JkKSB7CiAgICAgIGlmICghcmVjb3JkLnB0clR5cGUgfHwgIXJlY29yZC5wdHIpIHsKICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ21ha2VDbGFzc0hhbmRsZSByZXF1aXJlcyBwdHIgYW5kIHB0clR5cGUnKTsKICAgICAgfQogICAgICB2YXIgaGFzU21hcnRQdHJUeXBlID0gISFyZWNvcmQuc21hcnRQdHJUeXBlOwogICAgICB2YXIgaGFzU21hcnRQdHIgPSAhIXJlY29yZC5zbWFydFB0cjsKICAgICAgaWYgKGhhc1NtYXJ0UHRyVHlwZSAhPT0gaGFzU21hcnRQdHIpIHsKICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ0JvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZCcpOwogICAgICB9CiAgICAgIHJlY29yZC5jb3VudCA9IHsgdmFsdWU6IDEgfTsKICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG90eXBlLCB7ICQkOiB7IHZhbHVlOiByZWNvcmQgfSB9KQogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlKHB0cikgewogICAgICB2YXIgcmF3UG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlZShwdHIpOwogICAgICBpZiAoIXJhd1BvaW50ZXIpIHsKICAgICAgICB0aGlzLmRlc3RydWN0b3IocHRyKTsKICAgICAgICByZXR1cm4gbnVsbAogICAgICB9CiAgICAgIHZhciByZWdpc3RlcmVkSW5zdGFuY2UgPSBnZXRJbmhlcml0ZWRJbnN0YW5jZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcywgcmF3UG9pbnRlcik7CiAgICAgIGlmICh1bmRlZmluZWQgIT09IHJlZ2lzdGVyZWRJbnN0YW5jZSkgewogICAgICAgIGlmICgwID09PSByZWdpc3RlcmVkSW5zdGFuY2UuJCQuY291bnQudmFsdWUpIHsKICAgICAgICAgIHJlZ2lzdGVyZWRJbnN0YW5jZS4kJC5wdHIgPSByYXdQb2ludGVyOwogICAgICAgICAgcmVnaXN0ZXJlZEluc3RhbmNlLiQkLnNtYXJ0UHRyID0gcHRyOwogICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRJbnN0YW5jZVsnY2xvbmUnXSgpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBydiA9IHJlZ2lzdGVyZWRJbnN0YW5jZVsnY2xvbmUnXSgpOwogICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKHB0cik7CiAgICAgICAgICByZXR1cm4gcnYKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWFrZURlZmF1bHRIYW5kbGUoKSB7CiAgICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHsKICAgICAgICAgICAgcHRyVHlwZTogdGhpcy5wb2ludGVlVHlwZSwKICAgICAgICAgICAgcHRyOiByYXdQb2ludGVyLAogICAgICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsCiAgICAgICAgICAgIHNtYXJ0UHRyOiBwdHIsCiAgICAgICAgICB9KQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7IHB0clR5cGU6IHRoaXMsIHB0cjogcHRyIH0pCiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBhY3R1YWxUeXBlID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShyYXdQb2ludGVyKTsKICAgICAgdmFyIHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkID0gcmVnaXN0ZXJlZFBvaW50ZXJzW2FjdHVhbFR5cGVdOwogICAgICBpZiAoIXJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkKSB7CiAgICAgICAgcmV0dXJuIG1ha2VEZWZhdWx0SGFuZGxlLmNhbGwodGhpcykKICAgICAgfQogICAgICB2YXIgdG9UeXBlOwogICAgICBpZiAodGhpcy5pc0NvbnN0KSB7CiAgICAgICAgdG9UeXBlID0gcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQuY29uc3RQb2ludGVyVHlwZTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0b1R5cGUgPSByZWdpc3RlcmVkUG9pbnRlclJlY29yZC5wb2ludGVyVHlwZTsKICAgICAgfQogICAgICB2YXIgZHAgPSBkb3duY2FzdFBvaW50ZXIocmF3UG9pbnRlciwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MsIHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICBpZiAoZHAgPT09IG51bGwpIHsKICAgICAgICByZXR1cm4gbWFrZURlZmF1bHRIYW5kbGUuY2FsbCh0aGlzKQogICAgICB9CiAgICAgIGlmICh0aGlzLmlzU21hcnRQb2ludGVyKSB7CiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0b1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7CiAgICAgICAgICBwdHJUeXBlOiB0b1R5cGUsCiAgICAgICAgICBwdHI6IGRwLAogICAgICAgICAgc21hcnRQdHJUeXBlOiB0aGlzLAogICAgICAgICAgc21hcnRQdHI6IHB0ciwKICAgICAgICB9KQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwgeyBwdHJUeXBlOiB0b1R5cGUsIHB0cjogZHAgfSkKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW5pdF9SZWdpc3RlcmVkUG9pbnRlcigpIHsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlLmdldFBvaW50ZWUgPSBSZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlOwogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IFJlZ2lzdGVyZWRQb2ludGVyX2Rlc3RydWN0b3I7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsnYXJnUGFja0FkdmFuY2UnXSA9IDg7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsncmVhZFZhbHVlRnJvbVBvaW50ZXInXSA9IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyOwogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbJ2RlbGV0ZU9iamVjdCddID0gUmVnaXN0ZXJlZFBvaW50ZXJfZGVsZXRlT2JqZWN0OwogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGVbJ2Zyb21XaXJlVHlwZSddID0gUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlOwogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXIoCiAgICAgIG5hbWUsCiAgICAgIHJlZ2lzdGVyZWRDbGFzcywKICAgICAgaXNSZWZlcmVuY2UsCiAgICAgIGlzQ29uc3QsCiAgICAgIGlzU21hcnRQb2ludGVyLAogICAgICBwb2ludGVlVHlwZSwKICAgICAgc2hhcmluZ1BvbGljeSwKICAgICAgcmF3R2V0UG9pbnRlZSwKICAgICAgcmF3Q29uc3RydWN0b3IsCiAgICAgIHJhd1NoYXJlLAogICAgICByYXdEZXN0cnVjdG9yCiAgICApIHsKICAgICAgdGhpcy5uYW1lID0gbmFtZTsKICAgICAgdGhpcy5yZWdpc3RlcmVkQ2xhc3MgPSByZWdpc3RlcmVkQ2xhc3M7CiAgICAgIHRoaXMuaXNSZWZlcmVuY2UgPSBpc1JlZmVyZW5jZTsKICAgICAgdGhpcy5pc0NvbnN0ID0gaXNDb25zdDsKICAgICAgdGhpcy5pc1NtYXJ0UG9pbnRlciA9IGlzU21hcnRQb2ludGVyOwogICAgICB0aGlzLnBvaW50ZWVUeXBlID0gcG9pbnRlZVR5cGU7CiAgICAgIHRoaXMuc2hhcmluZ1BvbGljeSA9IHNoYXJpbmdQb2xpY3k7CiAgICAgIHRoaXMucmF3R2V0UG9pbnRlZSA9IHJhd0dldFBvaW50ZWU7CiAgICAgIHRoaXMucmF3Q29uc3RydWN0b3IgPSByYXdDb25zdHJ1Y3RvcjsKICAgICAgdGhpcy5yYXdTaGFyZSA9IHJhd1NoYXJlOwogICAgICB0aGlzLnJhd0Rlc3RydWN0b3IgPSByYXdEZXN0cnVjdG9yOwogICAgICBpZiAoIWlzU21hcnRQb2ludGVyICYmIHJlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3MgPT09IHVuZGVmaW5lZCkgewogICAgICAgIGlmIChpc0NvbnN0KSB7CiAgICAgICAgICB0aGlzWyd0b1dpcmVUeXBlJ10gPSBjb25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTsKICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpc1sndG9XaXJlVHlwZSddID0gbm9uQ29uc3ROb1NtYXJ0UHRyUmF3UG9pbnRlclRvV2lyZVR5cGU7CiAgICAgICAgICB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGw7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXNbJ3RvV2lyZVR5cGUnXSA9IGdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gcmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLCB2YWx1ZSwgbnVtQXJndW1lbnRzKSB7CiAgICAgIGlmICghTW9kdWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7CiAgICAgICAgdGhyb3dJbnRlcm5hbEVycm9yKCdSZXBsYWNpbmcgbm9uZXhpc3RhbnQgcHVibGljIHN5bWJvbCcpOwogICAgICB9CiAgICAgIGlmICh1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlICYmIHVuZGVmaW5lZCAhPT0gbnVtQXJndW1lbnRzKSB7CiAgICAgICAgTW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSA9IHZhbHVlOwogICAgICB9IGVsc2UgewogICAgICAgIE1vZHVsZVtuYW1lXSA9IHZhbHVlOwogICAgICAgIE1vZHVsZVtuYW1lXS5hcmdDb3VudCA9IG51bUFyZ3VtZW50czsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oc2lnbmF0dXJlLCByYXdGdW5jdGlvbikgewogICAgICBzaWduYXR1cmUgPSByZWFkTGF0aW4xU3RyaW5nKHNpZ25hdHVyZSk7CiAgICAgIGZ1bmN0aW9uIG1ha2VEeW5DYWxsZXIoZHluQ2FsbCkgewogICAgICAgIHZhciBhcmdzID0gW107CiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGFyZ3MucHVzaCgnYScgKyBpKTsKICAgICAgICB9CiAgICAgICAgdmFyIG5hbWUgPSAnZHluQ2FsbF8nICsgc2lnbmF0dXJlICsgJ18nICsgcmF3RnVuY3Rpb247CiAgICAgICAgdmFyIGJvZHkgPSAncmV0dXJuIGZ1bmN0aW9uICcgKyBuYW1lICsgJygnICsgYXJncy5qb2luKCcsICcpICsgJykge1xuJzsKICAgICAgICBib2R5ICs9ICcgICAgcmV0dXJuIGR5bkNhbGwocmF3RnVuY3Rpb24nICsgKGFyZ3MubGVuZ3RoID8gJywgJyA6ICcnKSArIGFyZ3Muam9pbignLCAnKSArICcpO1xuJzsKICAgICAgICBib2R5ICs9ICd9O1xuJzsKICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdkeW5DYWxsJywgJ3Jhd0Z1bmN0aW9uJywgYm9keSkoZHluQ2FsbCwgcmF3RnVuY3Rpb24pCiAgICAgIH0KICAgICAgdmFyIGZwOwogICAgICBpZiAoTW9kdWxlWydGVU5DVElPTl9UQUJMRV8nICsgc2lnbmF0dXJlXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgZnAgPSBNb2R1bGVbJ0ZVTkNUSU9OX1RBQkxFXycgKyBzaWduYXR1cmVdW3Jhd0Z1bmN0aW9uXTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRlVOQ1RJT05fVEFCTEUgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgZnAgPSBGVU5DVElPTl9UQUJMRVtyYXdGdW5jdGlvbl07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIGRjID0gTW9kdWxlWydhc20nXVsnZHluQ2FsbF8nICsgc2lnbmF0dXJlXTsKICAgICAgICBpZiAoZGMgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgZGMgPSBNb2R1bGVbJ2FzbSddWydkeW5DYWxsXycgKyBzaWduYXR1cmUucmVwbGFjZSgvZi9nLCAnZCcpXTsKICAgICAgICAgIGlmIChkYyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdObyBkeW5DYWxsIGludm9rZXIgZm9yIHNpZ25hdHVyZTogJyArIHNpZ25hdHVyZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZwID0gbWFrZUR5bkNhbGxlcihkYyk7CiAgICAgIH0KICAgICAgaWYgKHR5cGVvZiBmcCAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCd1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgJyArIHNpZ25hdHVyZSArICc6ICcgKyByYXdGdW5jdGlvbik7CiAgICAgIH0KICAgICAgcmV0dXJuIGZwCiAgICB9CiAgICB2YXIgVW5ib3VuZFR5cGVFcnJvciA9IHVuZGVmaW5lZDsKICAgIGZ1bmN0aW9uIGdldFR5cGVOYW1lKHR5cGUpIHsKICAgICAgdmFyIHB0ciA9IF9fX2dldFR5cGVOYW1lKHR5cGUpOwogICAgICB2YXIgcnYgPSByZWFkTGF0aW4xU3RyaW5nKHB0cik7CiAgICAgIF9mcmVlKHB0cik7CiAgICAgIHJldHVybiBydgogICAgfQogICAgZnVuY3Rpb24gdGhyb3dVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UsIHR5cGVzKSB7CiAgICAgIHZhciB1bmJvdW5kVHlwZXMgPSBbXTsKICAgICAgdmFyIHNlZW4gPSB7fTsKICAgICAgZnVuY3Rpb24gdmlzaXQodHlwZSkgewogICAgICAgIGlmIChzZWVuW3R5cGVdKSB7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgaWYgKHJlZ2lzdGVyZWRUeXBlc1t0eXBlXSkgewogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIGlmICh0eXBlRGVwZW5kZW5jaWVzW3R5cGVdKSB7CiAgICAgICAgICB0eXBlRGVwZW5kZW5jaWVzW3R5cGVdLmZvckVhY2godmlzaXQpOwogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIHVuYm91bmRUeXBlcy5wdXNoKHR5cGUpOwogICAgICAgIHNlZW5bdHlwZV0gPSB0cnVlOwogICAgICB9CiAgICAgIHR5cGVzLmZvckVhY2godmlzaXQpOwogICAgICB0aHJvdyBuZXcgVW5ib3VuZFR5cGVFcnJvcihtZXNzYWdlICsgJzogJyArIHVuYm91bmRUeXBlcy5tYXAoZ2V0VHlwZU5hbWUpLmpvaW4oWycsICddKSkKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzKAogICAgICByYXdUeXBlLAogICAgICByYXdQb2ludGVyVHlwZSwKICAgICAgcmF3Q29uc3RQb2ludGVyVHlwZSwKICAgICAgYmFzZUNsYXNzUmF3VHlwZSwKICAgICAgZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSwKICAgICAgZ2V0QWN0dWFsVHlwZSwKICAgICAgdXBjYXN0U2lnbmF0dXJlLAogICAgICB1cGNhc3QsCiAgICAgIGRvd25jYXN0U2lnbmF0dXJlLAogICAgICBkb3duY2FzdCwKICAgICAgbmFtZSwKICAgICAgZGVzdHJ1Y3RvclNpZ25hdHVyZSwKICAgICAgcmF3RGVzdHJ1Y3RvcgogICAgKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICBnZXRBY3R1YWxUeXBlID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSwgZ2V0QWN0dWFsVHlwZSk7CiAgICAgIGlmICh1cGNhc3QpIHsKICAgICAgICB1cGNhc3QgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbih1cGNhc3RTaWduYXR1cmUsIHVwY2FzdCk7CiAgICAgIH0KICAgICAgaWYgKGRvd25jYXN0KSB7CiAgICAgICAgZG93bmNhc3QgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkb3duY2FzdFNpZ25hdHVyZSwgZG93bmNhc3QpOwogICAgICB9CiAgICAgIHJhd0Rlc3RydWN0b3IgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLCByYXdEZXN0cnVjdG9yKTsKICAgICAgdmFyIGxlZ2FsRnVuY3Rpb25OYW1lID0gbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpOwogICAgICBleHBvc2VQdWJsaWNTeW1ib2wobGVnYWxGdW5jdGlvbk5hbWUsIGZ1bmN0aW9uICgpIHsKICAgICAgICB0aHJvd1VuYm91bmRUeXBlRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgJyArIG5hbWUgKyAnIGR1ZSB0byB1bmJvdW5kIHR5cGVzJywgW2Jhc2VDbGFzc1Jhd1R5cGVdKTsKICAgICAgfSk7CiAgICAgIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKAogICAgICAgIFtyYXdUeXBlLCByYXdQb2ludGVyVHlwZSwgcmF3Q29uc3RQb2ludGVyVHlwZV0sCiAgICAgICAgYmFzZUNsYXNzUmF3VHlwZSA/IFtiYXNlQ2xhc3NSYXdUeXBlXSA6IFtdLAogICAgICAgIGZ1bmN0aW9uIChiYXNlKSB7CiAgICAgICAgICBiYXNlID0gYmFzZVswXTsKICAgICAgICAgIHZhciBiYXNlQ2xhc3M7CiAgICAgICAgICB2YXIgYmFzZVByb3RvdHlwZTsKICAgICAgICAgIGlmIChiYXNlQ2xhc3NSYXdUeXBlKSB7CiAgICAgICAgICAgIGJhc2VDbGFzcyA9IGJhc2UucmVnaXN0ZXJlZENsYXNzOwogICAgICAgICAgICBiYXNlUHJvdG90eXBlID0gYmFzZUNsYXNzLmluc3RhbmNlUHJvdG90eXBlOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmFzZVByb3RvdHlwZSA9IENsYXNzSGFuZGxlLnByb3RvdHlwZTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24obGVnYWxGdW5jdGlvbk5hbWUsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gaW5zdGFuY2VQcm90b3R5cGUpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKCJVc2UgJ25ldycgdG8gY29uc3RydWN0ICIgKyBuYW1lKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcihuYW1lICsgJyBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvcicpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGJvZHkgPSByZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmd1bWVudHMubGVuZ3RoXTsKICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYm9keSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoCiAgICAgICAgICAgICAgICAnVHJpZWQgdG8gaW52b2tlIGN0b3Igb2YgJyArCiAgICAgICAgICAgICAgICAgIG5hbWUgKwogICAgICAgICAgICAgICAgICAnIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJyArCiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggKwogICAgICAgICAgICAgICAgICAnKSAtIGV4cGVjdGVkICgnICsKICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpLnRvU3RyaW5nKCkgKwogICAgICAgICAgICAgICAgICAnKSBwYXJhbWV0ZXJzIGluc3RlYWQhJwogICAgICAgICAgICAgICkKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBpbnN0YW5jZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogY29uc3RydWN0b3IgfSB9KTsKICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGluc3RhbmNlUHJvdG90eXBlOwogICAgICAgICAgdmFyIHJlZ2lzdGVyZWRDbGFzcyA9IG5ldyBSZWdpc3RlcmVkQ2xhc3MoCiAgICAgICAgICAgIG5hbWUsCiAgICAgICAgICAgIGNvbnN0cnVjdG9yLAogICAgICAgICAgICBpbnN0YW5jZVByb3RvdHlwZSwKICAgICAgICAgICAgcmF3RGVzdHJ1Y3RvciwKICAgICAgICAgICAgYmFzZUNsYXNzLAogICAgICAgICAgICBnZXRBY3R1YWxUeXBlLAogICAgICAgICAgICB1cGNhc3QsCiAgICAgICAgICAgIGRvd25jYXN0CiAgICAgICAgICApOwogICAgICAgICAgdmFyIHJlZmVyZW5jZUNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lLCByZWdpc3RlcmVkQ2xhc3MsIHRydWUsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICB2YXIgcG9pbnRlckNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lICsgJyonLCByZWdpc3RlcmVkQ2xhc3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UpOwogICAgICAgICAgdmFyIGNvbnN0UG9pbnRlckNvbnZlcnRlciA9IG5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lICsgJyBjb25zdConLCByZWdpc3RlcmVkQ2xhc3MsIGZhbHNlLCB0cnVlLCBmYWxzZSk7CiAgICAgICAgICByZWdpc3RlcmVkUG9pbnRlcnNbcmF3VHlwZV0gPSB7IHBvaW50ZXJUeXBlOiBwb2ludGVyQ29udmVydGVyLCBjb25zdFBvaW50ZXJUeXBlOiBjb25zdFBvaW50ZXJDb252ZXJ0ZXIgfTsKICAgICAgICAgIHJlcGxhY2VQdWJsaWNTeW1ib2wobGVnYWxGdW5jdGlvbk5hbWUsIGNvbnN0cnVjdG9yKTsKICAgICAgICAgIHJldHVybiBbcmVmZXJlbmNlQ29udmVydGVyLCBwb2ludGVyQ29udmVydGVyLCBjb25zdFBvaW50ZXJDb252ZXJ0ZXJdCiAgICAgICAgfQogICAgICApOwogICAgfQogICAgZnVuY3Rpb24gaGVhcDMyVmVjdG9yVG9BcnJheShjb3VudCwgZmlyc3RFbGVtZW50KSB7CiAgICAgIHZhciBhcnJheSA9IFtdOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHsKICAgICAgICBhcnJheS5wdXNoKEhFQVAzMlsoZmlyc3RFbGVtZW50ID4+IDIpICsgaV0pOwogICAgICB9CiAgICAgIHJldHVybiBhcnJheQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IoCiAgICAgIHJhd0NsYXNzVHlwZSwKICAgICAgYXJnQ291bnQsCiAgICAgIHJhd0FyZ1R5cGVzQWRkciwKICAgICAgaW52b2tlclNpZ25hdHVyZSwKICAgICAgaW52b2tlciwKICAgICAgcmF3Q29uc3RydWN0b3IKICAgICkgewogICAgICB2YXIgcmF3QXJnVHlwZXMgPSBoZWFwMzJWZWN0b3JUb0FycmF5KGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIpOwogICAgICBpbnZva2VyID0gZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oaW52b2tlclNpZ25hdHVyZSwgaW52b2tlcik7CiAgICAgIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtdLCBbcmF3Q2xhc3NUeXBlXSwgZnVuY3Rpb24gKGNsYXNzVHlwZSkgewogICAgICAgIGNsYXNzVHlwZSA9IGNsYXNzVHlwZVswXTsKICAgICAgICB2YXIgaHVtYW5OYW1lID0gJ2NvbnN0cnVjdG9yICcgKyBjbGFzc1R5cGUubmFtZTsKICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpIHsKICAgICAgICAgIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSA9IFtdOwogICAgICAgIH0KICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQgLSAxXSkgewogICAgICAgICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcigKICAgICAgICAgICAgJ0Nhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBjb25zdHJ1Y3RvcnMgd2l0aCBpZGVudGljYWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCcgKwogICAgICAgICAgICAgIChhcmdDb3VudCAtIDEpICsKICAgICAgICAgICAgICAiKSBmb3IgY2xhc3MgJyIgKwogICAgICAgICAgICAgIGNsYXNzVHlwZS5uYW1lICsKICAgICAgICAgICAgICAiJyEgT3ZlcmxvYWQgcmVzb2x1dGlvbiBpcyBjdXJyZW50bHkgb25seSBwZXJmb3JtZWQgdXNpbmcgdGhlIHBhcmFtZXRlciBjb3VudCwgbm90IGFjdHVhbCB0eXBlIGluZm8hIgogICAgICAgICAgKQogICAgICAgIH0KICAgICAgICBjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQgLSAxXSA9IGZ1bmN0aW9uIHVuYm91bmRUeXBlSGFuZGxlcigpIHsKICAgICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCAnICsgY2xhc3NUeXBlLm5hbWUgKyAnIGR1ZSB0byB1bmJvdW5kIHR5cGVzJywgcmF3QXJnVHlwZXMpOwogICAgICAgIH07CiAgICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIHJhd0FyZ1R5cGVzLCBmdW5jdGlvbiAoYXJnVHlwZXMpIHsKICAgICAgICAgIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudCAtIDFdID0gZnVuY3Rpb24gY29uc3RydWN0b3JfYm9keSgpIHsKICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IGFyZ0NvdW50IC0gMSkgewogICAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKGh1bWFuTmFtZSArICcgY2FsbGVkIHdpdGggJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cywgZXhwZWN0ZWQgJyArIChhcmdDb3VudCAtIDEpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgZGVzdHJ1Y3RvcnMgPSBbXTsKICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJnQ291bnQpOwogICAgICAgICAgICBhcmdzWzBdID0gcmF3Q29uc3RydWN0b3I7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJnQ291bnQ7ICsraSkgewogICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmdUeXBlc1tpXVsndG9XaXJlVHlwZSddKGRlc3RydWN0b3JzLCBhcmd1bWVudHNbaSAtIDFdKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgcHRyID0gaW52b2tlci5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICAgICAgcnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpOwogICAgICAgICAgICByZXR1cm4gYXJnVHlwZXNbMF1bJ2Zyb21XaXJlVHlwZSddKHB0cikKICAgICAgICAgIH07CiAgICAgICAgICByZXR1cm4gW10KICAgICAgICB9KTsKICAgICAgICByZXR1cm4gW10KICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBuZXdfKGNvbnN0cnVjdG9yLCBhcmd1bWVudExpc3QpIHsKICAgICAgaWYgKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgJyArIHR5cGVvZiBjb25zdHJ1Y3RvciArICcgd2hpY2ggaXMgbm90IGEgZnVuY3Rpb24nKQogICAgICB9CiAgICAgIHZhciBkdW1teSA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24oY29uc3RydWN0b3IubmFtZSB8fCAndW5rbm93bkZ1bmN0aW9uTmFtZScsIGZ1bmN0aW9uICgpIHt9KTsKICAgICAgZHVtbXkucHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlOwogICAgICB2YXIgb2JqID0gbmV3IGR1bW15KCk7CiAgICAgIHZhciByID0gY29uc3RydWN0b3IuYXBwbHkob2JqLCBhcmd1bWVudExpc3QpOwogICAgICByZXR1cm4gciBpbnN0YW5jZW9mIE9iamVjdCA/IHIgOiBvYmoKICAgIH0KICAgIGZ1bmN0aW9uIGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSwgYXJnVHlwZXMsIGNsYXNzVHlwZSwgY3BwSW52b2tlckZ1bmMsIGNwcFRhcmdldEZ1bmMpIHsKICAgICAgdmFyIGFyZ0NvdW50ID0gYXJnVHlwZXMubGVuZ3RoOwogICAgICBpZiAoYXJnQ291bnQgPCAyKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoImFyZ1R5cGVzIGFycmF5IHNpemUgbWlzbWF0Y2ghIE11c3QgYXQgbGVhc3QgZ2V0IHJldHVybiB2YWx1ZSBhbmQgJ3RoaXMnIHR5cGVzISIpOwogICAgICB9CiAgICAgIHZhciBpc0NsYXNzTWV0aG9kRnVuYyA9IGFyZ1R5cGVzWzFdICE9PSBudWxsICYmIGNsYXNzVHlwZSAhPT0gbnVsbDsKICAgICAgdmFyIG5lZWRzRGVzdHJ1Y3RvclN0YWNrID0gZmFsc2U7CiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHsKICAgICAgICBpZiAoYXJnVHlwZXNbaV0gIT09IG51bGwgJiYgYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgIG5lZWRzRGVzdHJ1Y3RvclN0YWNrID0gdHJ1ZTsKICAgICAgICAgIGJyZWFrCiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciByZXR1cm5zID0gYXJnVHlwZXNbMF0ubmFtZSAhPT0gJ3ZvaWQnOwogICAgICB2YXIgYXJnc0xpc3QgPSAnJzsKICAgICAgdmFyIGFyZ3NMaXN0V2lyZWQgPSAnJzsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudCAtIDI7ICsraSkgewogICAgICAgIGFyZ3NMaXN0ICs9IChpICE9PSAwID8gJywgJyA6ICcnKSArICdhcmcnICsgaTsKICAgICAgICBhcmdzTGlzdFdpcmVkICs9IChpICE9PSAwID8gJywgJyA6ICcnKSArICdhcmcnICsgaSArICdXaXJlZCc7CiAgICAgIH0KICAgICAgdmFyIGludm9rZXJGbkJvZHkgPQogICAgICAgICdyZXR1cm4gZnVuY3Rpb24gJyArCiAgICAgICAgbWFrZUxlZ2FsRnVuY3Rpb25OYW1lKGh1bWFuTmFtZSkgKwogICAgICAgICcoJyArCiAgICAgICAgYXJnc0xpc3QgKwogICAgICAgICcpIHtcbicgKwogICAgICAgICdpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gJyArCiAgICAgICAgKGFyZ0NvdW50IC0gMikgKwogICAgICAgICcpIHtcbicgKwogICAgICAgICJ0aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gIiArCiAgICAgICAgaHVtYW5OYW1lICsKICAgICAgICAiIGNhbGxlZCB3aXRoICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGV4cGVjdGVkICIgKwogICAgICAgIChhcmdDb3VudCAtIDIpICsKICAgICAgICAiIGFyZ3MhJyk7XG4iICsKICAgICAgICAnfVxuJzsKICAgICAgaWYgKG5lZWRzRGVzdHJ1Y3RvclN0YWNrKSB7CiAgICAgICAgaW52b2tlckZuQm9keSArPSAndmFyIGRlc3RydWN0b3JzID0gW107XG4nOwogICAgICB9CiAgICAgIHZhciBkdG9yU3RhY2sgPSBuZWVkc0Rlc3RydWN0b3JTdGFjayA/ICdkZXN0cnVjdG9ycycgOiAnbnVsbCc7CiAgICAgIHZhciBhcmdzMSA9IFsndGhyb3dCaW5kaW5nRXJyb3InLCAnaW52b2tlcicsICdmbicsICdydW5EZXN0cnVjdG9ycycsICdyZXRUeXBlJywgJ2NsYXNzUGFyYW0nXTsKICAgICAgdmFyIGFyZ3MyID0gW3Rocm93QmluZGluZ0Vycm9yLCBjcHBJbnZva2VyRnVuYywgY3BwVGFyZ2V0RnVuYywgcnVuRGVzdHJ1Y3RvcnMsIGFyZ1R5cGVzWzBdLCBhcmdUeXBlc1sxXV07CiAgICAgIGlmIChpc0NsYXNzTWV0aG9kRnVuYykgewogICAgICAgIGludm9rZXJGbkJvZHkgKz0gJ3ZhciB0aGlzV2lyZWQgPSBjbGFzc1BhcmFtLnRvV2lyZVR5cGUoJyArIGR0b3JTdGFjayArICcsIHRoaXMpO1xuJzsKICAgICAgfQogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50IC0gMjsgKytpKSB7CiAgICAgICAgaW52b2tlckZuQm9keSArPQogICAgICAgICAgJ3ZhciBhcmcnICsKICAgICAgICAgIGkgKwogICAgICAgICAgJ1dpcmVkID0gYXJnVHlwZScgKwogICAgICAgICAgaSArCiAgICAgICAgICAnLnRvV2lyZVR5cGUoJyArCiAgICAgICAgICBkdG9yU3RhY2sgKwogICAgICAgICAgJywgYXJnJyArCiAgICAgICAgICBpICsKICAgICAgICAgICcpOyAvLyAnICsKICAgICAgICAgIGFyZ1R5cGVzW2kgKyAyXS5uYW1lICsKICAgICAgICAgICdcbic7CiAgICAgICAgYXJnczEucHVzaCgnYXJnVHlwZScgKyBpKTsKICAgICAgICBhcmdzMi5wdXNoKGFyZ1R5cGVzW2kgKyAyXSk7CiAgICAgIH0KICAgICAgaWYgKGlzQ2xhc3NNZXRob2RGdW5jKSB7CiAgICAgICAgYXJnc0xpc3RXaXJlZCA9ICd0aGlzV2lyZWQnICsgKGFyZ3NMaXN0V2lyZWQubGVuZ3RoID4gMCA/ICcsICcgOiAnJykgKyBhcmdzTGlzdFdpcmVkOwogICAgICB9CiAgICAgIGludm9rZXJGbkJvZHkgKz0KICAgICAgICAocmV0dXJucyA/ICd2YXIgcnYgPSAnIDogJycpICsgJ2ludm9rZXIoZm4nICsgKGFyZ3NMaXN0V2lyZWQubGVuZ3RoID4gMCA/ICcsICcgOiAnJykgKyBhcmdzTGlzdFdpcmVkICsgJyk7XG4nOwogICAgICBpZiAobmVlZHNEZXN0cnVjdG9yU3RhY2spIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9ICdydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4nOwogICAgICB9IGVsc2UgewogICAgICAgIGZvciAodmFyIGkgPSBpc0NsYXNzTWV0aG9kRnVuYyA/IDEgOiAyOyBpIDwgYXJnVHlwZXMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBpID09PSAxID8gJ3RoaXNXaXJlZCcgOiAnYXJnJyArIChpIC0gMikgKyAnV2lyZWQnOwogICAgICAgICAgaWYgKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbiAhPT0gbnVsbCkgewogICAgICAgICAgICBpbnZva2VyRm5Cb2R5ICs9IHBhcmFtTmFtZSArICdfZHRvcignICsgcGFyYW1OYW1lICsgJyk7IC8vICcgKyBhcmdUeXBlc1tpXS5uYW1lICsgJ1xuJzsKICAgICAgICAgICAgYXJnczEucHVzaChwYXJhbU5hbWUgKyAnX2R0b3InKTsKICAgICAgICAgICAgYXJnczIucHVzaChhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocmV0dXJucykgewogICAgICAgIGludm9rZXJGbkJvZHkgKz0gJ3ZhciByZXQgPSByZXRUeXBlLmZyb21XaXJlVHlwZShydik7XG4nICsgJ3JldHVybiByZXQ7XG4nOwogICAgICB9CiAgICAgIGludm9rZXJGbkJvZHkgKz0gJ31cbic7CiAgICAgIGFyZ3MxLnB1c2goaW52b2tlckZuQm9keSk7CiAgICAgIHZhciBpbnZva2VyRnVuY3Rpb24gPSBuZXdfKEZ1bmN0aW9uLCBhcmdzMSkuYXBwbHkobnVsbCwgYXJnczIpOwogICAgICByZXR1cm4gaW52b2tlckZ1bmN0aW9uCiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbigKICAgICAgcmF3Q2xhc3NUeXBlLAogICAgICBtZXRob2ROYW1lLAogICAgICBhcmdDb3VudCwKICAgICAgcmF3QXJnVHlwZXNBZGRyLAogICAgICBpbnZva2VyU2lnbmF0dXJlLAogICAgICByYXdJbnZva2VyLAogICAgICBjb250ZXh0LAogICAgICBpc1B1cmVWaXJ0dWFsCiAgICApIHsKICAgICAgdmFyIHJhd0FyZ1R5cGVzID0gaGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCwgcmF3QXJnVHlwZXNBZGRyKTsKICAgICAgbWV0aG9kTmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobWV0aG9kTmFtZSk7CiAgICAgIHJhd0ludm9rZXIgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLCByYXdJbnZva2VyKTsKICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFtyYXdDbGFzc1R5cGVdLCBmdW5jdGlvbiAoY2xhc3NUeXBlKSB7CiAgICAgICAgY2xhc3NUeXBlID0gY2xhc3NUeXBlWzBdOwogICAgICAgIHZhciBodW1hbk5hbWUgPSBjbGFzc1R5cGUubmFtZSArICcuJyArIG1ldGhvZE5hbWU7CiAgICAgICAgaWYgKGlzUHVyZVZpcnR1YWwpIHsKICAgICAgICAgIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MucHVyZVZpcnR1YWxGdW5jdGlvbnMucHVzaChtZXRob2ROYW1lKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gdW5ib3VuZFR5cGVzSGFuZGxlcigpIHsKICAgICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcignQ2Fubm90IGNhbGwgJyArIGh1bWFuTmFtZSArICcgZHVlIHRvIHVuYm91bmQgdHlwZXMnLCByYXdBcmdUeXBlcyk7CiAgICAgICAgfQogICAgICAgIHZhciBwcm90byA9IGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7CiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW21ldGhvZE5hbWVdOwogICAgICAgIGlmICgKICAgICAgICAgIHVuZGVmaW5lZCA9PT0gbWV0aG9kIHx8CiAgICAgICAgICAodW5kZWZpbmVkID09PSBtZXRob2Qub3ZlcmxvYWRUYWJsZSAmJiBtZXRob2QuY2xhc3NOYW1lICE9PSBjbGFzc1R5cGUubmFtZSAmJiBtZXRob2QuYXJnQ291bnQgPT09IGFyZ0NvdW50IC0gMikKICAgICAgICApIHsKICAgICAgICAgIHVuYm91bmRUeXBlc0hhbmRsZXIuYXJnQ291bnQgPSBhcmdDb3VudCAtIDI7CiAgICAgICAgICB1bmJvdW5kVHlwZXNIYW5kbGVyLmNsYXNzTmFtZSA9IGNsYXNzVHlwZS5uYW1lOwogICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBlbnN1cmVPdmVybG9hZFRhYmxlKHByb3RvLCBtZXRob2ROYW1lLCBodW1hbk5hbWUpOwogICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmdDb3VudCAtIDJdID0gdW5ib3VuZFR5cGVzSGFuZGxlcjsKICAgICAgICB9CiAgICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIHJhd0FyZ1R5cGVzLCBmdW5jdGlvbiAoYXJnVHlwZXMpIHsKICAgICAgICAgIHZhciBtZW1iZXJGdW5jdGlvbiA9IGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSwgYXJnVHlwZXMsIGNsYXNzVHlwZSwgcmF3SW52b2tlciwgY29udGV4dCk7CiAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlKSB7CiAgICAgICAgICAgIG1lbWJlckZ1bmN0aW9uLmFyZ0NvdW50ID0gYXJnQ291bnQgLSAyOwogICAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IG1lbWJlckZ1bmN0aW9uOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZVthcmdDb3VudCAtIDJdID0gbWVtYmVyRnVuY3Rpb247CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gW10KICAgICAgICB9KTsKICAgICAgICByZXR1cm4gW10KICAgICAgfSk7CiAgICB9CiAgICB2YXIgZW12YWxfZnJlZV9saXN0ID0gW107CiAgICB2YXIgZW12YWxfaGFuZGxlX2FycmF5ID0gW3t9LCB7IHZhbHVlOiB1bmRlZmluZWQgfSwgeyB2YWx1ZTogbnVsbCB9LCB7IHZhbHVlOiB0cnVlIH0sIHsgdmFsdWU6IGZhbHNlIH1dOwogICAgZnVuY3Rpb24gX19lbXZhbF9kZWNyZWYoaGFuZGxlKSB7CiAgICAgIGlmIChoYW5kbGUgPiA0ICYmIDAgPT09IC0tZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0ucmVmY291bnQpIHsKICAgICAgICBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXSA9IHVuZGVmaW5lZDsKICAgICAgICBlbXZhbF9mcmVlX2xpc3QucHVzaChoYW5kbGUpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBjb3VudF9lbXZhbF9oYW5kbGVzKCkgewogICAgICB2YXIgY291bnQgPSAwOwogICAgICBmb3IgKHZhciBpID0gNTsgaSA8IGVtdmFsX2hhbmRsZV9hcnJheS5sZW5ndGg7ICsraSkgewogICAgICAgIGlmIChlbXZhbF9oYW5kbGVfYXJyYXlbaV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgKytjb3VudDsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIGNvdW50CiAgICB9CiAgICBmdW5jdGlvbiBnZXRfZmlyc3RfZW12YWwoKSB7CiAgICAgIGZvciAodmFyIGkgPSA1OyBpIDwgZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgaWYgKGVtdmFsX2hhbmRsZV9hcnJheVtpXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICByZXR1cm4gZW12YWxfaGFuZGxlX2FycmF5W2ldCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBudWxsCiAgICB9CiAgICBmdW5jdGlvbiBpbml0X2VtdmFsKCkgewogICAgICBNb2R1bGVbJ2NvdW50X2VtdmFsX2hhbmRsZXMnXSA9IGNvdW50X2VtdmFsX2hhbmRsZXM7CiAgICAgIE1vZHVsZVsnZ2V0X2ZpcnN0X2VtdmFsJ10gPSBnZXRfZmlyc3RfZW12YWw7CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtdmFsX3JlZ2lzdGVyKHZhbHVlKSB7CiAgICAgIHN3aXRjaCAodmFsdWUpIHsKICAgICAgICBjYXNlIHVuZGVmaW5lZDogewogICAgICAgICAgcmV0dXJuIDEKICAgICAgICB9CiAgICAgICAgY2FzZSBudWxsOiB7CiAgICAgICAgICByZXR1cm4gMgogICAgICAgIH0KICAgICAgICBjYXNlIHRydWU6IHsKICAgICAgICAgIHJldHVybiAzCiAgICAgICAgfQogICAgICAgIGNhc2UgZmFsc2U6IHsKICAgICAgICAgIHJldHVybiA0CiAgICAgICAgfQogICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgIHZhciBoYW5kbGUgPSBlbXZhbF9mcmVlX2xpc3QubGVuZ3RoID8gZW12YWxfZnJlZV9saXN0LnBvcCgpIDogZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsKICAgICAgICAgIGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdID0geyByZWZjb3VudDogMSwgdmFsdWU6IHZhbHVlIH07CiAgICAgICAgICByZXR1cm4gaGFuZGxlCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbChyYXdUeXBlLCBuYW1lKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICByZWdpc3RlclR5cGUocmF3VHlwZSwgewogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAoaGFuZGxlKSB7CiAgICAgICAgICB2YXIgcnYgPSBlbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS52YWx1ZTsKICAgICAgICAgIF9fZW12YWxfZGVjcmVmKGhhbmRsZSk7CiAgICAgICAgICByZXR1cm4gcnYKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgdmFsdWUpIHsKICAgICAgICAgIHJldHVybiBfX2VtdmFsX3JlZ2lzdGVyKHZhbHVlKQogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbCwKICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBfZW1iaW5kX3JlcHIodikgewogICAgICBpZiAodiA9PT0gbnVsbCkgewogICAgICAgIHJldHVybiAnbnVsbCcKICAgICAgfQogICAgICB2YXIgdCA9IHR5cGVvZiB2OwogICAgICBpZiAodCA9PT0gJ29iamVjdCcgfHwgdCA9PT0gJ2FycmF5JyB8fCB0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiAnJyArIHYKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCkgewogICAgICBzd2l0Y2ggKHNoaWZ0KSB7CiAgICAgICAgY2FzZSAyOgogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzWydmcm9tV2lyZVR5cGUnXShIRUFQRjMyW3BvaW50ZXIgPj4gMl0pCiAgICAgICAgICB9CiAgICAgICAgY2FzZSAzOgogICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzWydmcm9tV2lyZVR5cGUnXShIRUFQRjY0W3BvaW50ZXIgPj4gM10pCiAgICAgICAgICB9CiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZmxvYXQgdHlwZTogJyArIG5hbWUpCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0KHJhd1R5cGUsIG5hbWUsIHNpemUpIHsKICAgICAgdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlCiAgICAgICAgfSwKICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbiAoZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCAiJyArIF9lbWJpbmRfcmVwcih2YWx1ZSkgKyAnIiB0byAnICsgdGhpcy5uYW1lKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHZhbHVlCiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCksCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsLAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCwgc2lnbmVkKSB7CiAgICAgIHN3aXRjaCAoc2hpZnQpIHsKICAgICAgICBjYXNlIDA6CiAgICAgICAgICByZXR1cm4gc2lnbmVkCiAgICAgICAgICAgID8gZnVuY3Rpb24gcmVhZFM4RnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICAgICAgcmV0dXJuIEhFQVA4W3BvaW50ZXJdCiAgICAgICAgICAgICAgfQogICAgICAgICAgICA6IGZ1bmN0aW9uIHJlYWRVOEZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBIRUFQVThbcG9pbnRlcl0KICAgICAgICAgICAgICB9CiAgICAgICAgY2FzZSAxOgogICAgICAgICAgcmV0dXJuIHNpZ25lZAogICAgICAgICAgICA/IGZ1bmN0aW9uIHJlYWRTMTZGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gSEVBUDE2W3BvaW50ZXIgPj4gMV0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gcmVhZFUxNkZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBIRUFQVTE2W3BvaW50ZXIgPj4gMV0KICAgICAgICAgICAgICB9CiAgICAgICAgY2FzZSAyOgogICAgICAgICAgcmV0dXJuIHNpZ25lZAogICAgICAgICAgICA/IGZ1bmN0aW9uIHJlYWRTMzJGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gSEVBUDMyW3BvaW50ZXIgPj4gMl0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gcmVhZFUzMkZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBIRUFQVTMyW3BvaW50ZXIgPj4gMl0KICAgICAgICAgICAgICB9CiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gaW50ZWdlciB0eXBlOiAnICsgbmFtZSkKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcihwcmltaXRpdmVUeXBlLCBuYW1lLCBzaXplLCBtaW5SYW5nZSwgbWF4UmFuZ2UpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIGlmIChtYXhSYW5nZSA9PT0gLTEpIHsKICAgICAgICBtYXhSYW5nZSA9IDQyOTQ5NjcyOTU7CiAgICAgIH0KICAgICAgdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTsKICAgICAgdmFyIGZyb21XaXJlVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgIHJldHVybiB2YWx1ZQogICAgICB9OwogICAgICBpZiAobWluUmFuZ2UgPT09IDApIHsKICAgICAgICB2YXIgYml0c2hpZnQgPSAzMiAtIDggKiBzaXplOwogICAgICAgIGZyb21XaXJlVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuICh2YWx1ZSA8PCBiaXRzaGlmdCkgPj4+IGJpdHNoaWZ0CiAgICAgICAgfTsKICAgICAgfQogICAgICB2YXIgaXNVbnNpZ25lZFR5cGUgPSBuYW1lLmluZGV4T2YoJ3Vuc2lnbmVkJykgIT0gLTE7CiAgICAgIHJlZ2lzdGVyVHlwZShwcmltaXRpdmVUeXBlLCB7CiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZyb21XaXJlVHlwZSwKICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbiAoZGVzdHJ1Y3RvcnMsIHZhbHVlKSB7CiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCAiJyArIF9lbWJpbmRfcmVwcih2YWx1ZSkgKyAnIiB0byAnICsgdGhpcy5uYW1lKQogICAgICAgICAgfQogICAgICAgICAgaWYgKHZhbHVlIDwgbWluUmFuZ2UgfHwgdmFsdWUgPiBtYXhSYW5nZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICAgICAgICdQYXNzaW5nIGEgbnVtYmVyICInICsKICAgICAgICAgICAgICAgIF9lbWJpbmRfcmVwcih2YWx1ZSkgKwogICAgICAgICAgICAgICAgJyIgZnJvbSBKUyBzaWRlIHRvIEMvQysrIHNpZGUgdG8gYW4gYXJndW1lbnQgb2YgdHlwZSAiJyArCiAgICAgICAgICAgICAgICBuYW1lICsKICAgICAgICAgICAgICAgICciLCB3aGljaCBpcyBvdXRzaWRlIHRoZSB2YWxpZCByYW5nZSBbJyArCiAgICAgICAgICAgICAgICBtaW5SYW5nZSArCiAgICAgICAgICAgICAgICAnLCAnICsKICAgICAgICAgICAgICAgIG1heFJhbmdlICsKICAgICAgICAgICAgICAgICddIScKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGlzVW5zaWduZWRUeXBlID8gdmFsdWUgPj4+IDAgOiB2YWx1ZSB8IDAKICAgICAgICB9LAogICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBpbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSwgc2hpZnQsIG1pblJhbmdlICE9PSAwKSwKICAgICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcocmF3VHlwZSwgZGF0YVR5cGVJbmRleCwgbmFtZSkgewogICAgICB2YXIgdHlwZU1hcHBpbmcgPSBbCiAgICAgICAgSW50OEFycmF5LAogICAgICAgIFVpbnQ4QXJyYXksCiAgICAgICAgSW50MTZBcnJheSwKICAgICAgICBVaW50MTZBcnJheSwKICAgICAgICBJbnQzMkFycmF5LAogICAgICAgIFVpbnQzMkFycmF5LAogICAgICAgIEZsb2F0MzJBcnJheSwKICAgICAgICBGbG9hdDY0QXJyYXksCiAgICAgIF07CiAgICAgIHZhciBUQSA9IHR5cGVNYXBwaW5nW2RhdGFUeXBlSW5kZXhdOwogICAgICBmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSkgewogICAgICAgIGhhbmRsZSA9IGhhbmRsZSA+PiAyOwogICAgICAgIHZhciBoZWFwID0gSEVBUFUzMjsKICAgICAgICB2YXIgc2l6ZSA9IGhlYXBbaGFuZGxlXTsKICAgICAgICB2YXIgZGF0YSA9IGhlYXBbaGFuZGxlICsgMV07CiAgICAgICAgcmV0dXJuIG5ldyBUQShoZWFwWydidWZmZXInXSwgZGF0YSwgc2l6ZSkKICAgICAgfQogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKAogICAgICAgIHJhd1R5cGUsCiAgICAgICAgeyBuYW1lOiBuYW1lLCBmcm9tV2lyZVR5cGU6IGRlY29kZU1lbW9yeVZpZXcsIGFyZ1BhY2tBZHZhbmNlOiA4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjogZGVjb2RlTWVtb3J5VmlldyB9LAogICAgICAgIHsgaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczogdHJ1ZSB9CiAgICAgICk7CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nKHJhd1R5cGUsIG5hbWUpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgdmFyIGxlbmd0aCA9IEhFQVBVMzJbdmFsdWUgPj4gMl07CiAgICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShsZW5ndGgpOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgICBhW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShIRUFQVThbdmFsdWUgKyA0ICsgaV0pOwogICAgICAgICAgfQogICAgICAgICAgX2ZyZWUodmFsdWUpOwogICAgICAgICAgcmV0dXJuIGEuam9pbignJykKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgdmFsdWUpIHsKICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpOwogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZ2V0VEFFbGVtZW50KHRhLCBpbmRleCkgewogICAgICAgICAgICByZXR1cm4gdGFbaW5kZXhdCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBnZXRTdHJpbmdFbGVtZW50KHN0cmluZywgaW5kZXgpIHsKICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KQogICAgICAgICAgfQogICAgICAgICAgdmFyIGdldEVsZW1lbnQ7CiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7CiAgICAgICAgICAgIGdldEVsZW1lbnQgPSBnZXRUQUVsZW1lbnQ7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHsKICAgICAgICAgICAgZ2V0RWxlbWVudCA9IGdldFRBRWxlbWVudDsKICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHsKICAgICAgICAgICAgZ2V0RWxlbWVudCA9IGdldFRBRWxlbWVudDsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgewogICAgICAgICAgICBnZXRFbGVtZW50ID0gZ2V0U3RyaW5nRWxlbWVudDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nJyk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOwogICAgICAgICAgdmFyIHB0ciA9IF9tYWxsb2MoNCArIGxlbmd0aCk7CiAgICAgICAgICBIRUFQVTMyW3B0ciA+PiAyXSA9IGxlbmd0aDsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gZ2V0RWxlbWVudCh2YWx1ZSwgaSk7CiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+IDI1NSkgewogICAgICAgICAgICAgIF9mcmVlKHB0cik7CiAgICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ1N0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0cycpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIEhFQVBVOFtwdHIgKyA0ICsgaV0gPSBjaGFyQ29kZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICBkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLCBwdHIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogZnVuY3Rpb24gKHB0cikgewogICAgICAgICAgX2ZyZWUocHRyKTsKICAgICAgICB9LAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nKHJhd1R5cGUsIGNoYXJTaXplLCBuYW1lKSB7CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICB2YXIgZ2V0SGVhcCwgc2hpZnQ7CiAgICAgIGlmIChjaGFyU2l6ZSA9PT0gMikgewogICAgICAgIGdldEhlYXAgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gSEVBUFUxNgogICAgICAgIH07CiAgICAgICAgc2hpZnQgPSAxOwogICAgICB9IGVsc2UgaWYgKGNoYXJTaXplID09PSA0KSB7CiAgICAgICAgZ2V0SGVhcCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBIRUFQVTMyCiAgICAgICAgfTsKICAgICAgICBzaGlmdCA9IDI7CiAgICAgIH0KICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICB2YXIgSEVBUCA9IGdldEhlYXAoKTsKICAgICAgICAgIHZhciBsZW5ndGggPSBIRUFQVTMyW3ZhbHVlID4+IDJdOwogICAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkobGVuZ3RoKTsKICAgICAgICAgIHZhciBzdGFydCA9ICh2YWx1ZSArIDQpID4+IHNoaWZ0OwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgICBhW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShIRUFQW3N0YXJ0ICsgaV0pOwogICAgICAgICAgfQogICAgICAgICAgX2ZyZWUodmFsdWUpOwogICAgICAgICAgcmV0dXJuIGEuam9pbignJykKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgdmFsdWUpIHsKICAgICAgICAgIHZhciBIRUFQID0gZ2V0SGVhcCgpOwogICAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsKICAgICAgICAgIHZhciBwdHIgPSBfbWFsbG9jKDQgKyBsZW5ndGggKiBjaGFyU2l6ZSk7CiAgICAgICAgICBIRUFQVTMyW3B0ciA+PiAyXSA9IGxlbmd0aDsKICAgICAgICAgIHZhciBzdGFydCA9IChwdHIgKyA0KSA+PiBzaGlmdDsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgSEVBUFtzdGFydCArIGldID0gdmFsdWUuY2hhckNvZGVBdChpKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICBkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLCBwdHIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogZnVuY3Rpb24gKHB0cikgewogICAgICAgICAgX2ZyZWUocHRyKTsKICAgICAgICB9LAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdCgKICAgICAgcmF3VHlwZSwKICAgICAgbmFtZSwKICAgICAgY29uc3RydWN0b3JTaWduYXR1cmUsCiAgICAgIHJhd0NvbnN0cnVjdG9yLAogICAgICBkZXN0cnVjdG9yU2lnbmF0dXJlLAogICAgICByYXdEZXN0cnVjdG9yCiAgICApIHsKICAgICAgc3RydWN0UmVnaXN0cmF0aW9uc1tyYXdUeXBlXSA9IHsKICAgICAgICBuYW1lOiByZWFkTGF0aW4xU3RyaW5nKG5hbWUpLAogICAgICAgIHJhd0NvbnN0cnVjdG9yOiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihjb25zdHJ1Y3RvclNpZ25hdHVyZSwgcmF3Q29uc3RydWN0b3IpLAogICAgICAgIHJhd0Rlc3RydWN0b3I6IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3IpLAogICAgICAgIGZpZWxkczogW10sCiAgICAgIH07CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQoCiAgICAgIHN0cnVjdFR5cGUsCiAgICAgIGZpZWxkTmFtZSwKICAgICAgZ2V0dGVyUmV0dXJuVHlwZSwKICAgICAgZ2V0dGVyU2lnbmF0dXJlLAogICAgICBnZXR0ZXIsCiAgICAgIGdldHRlckNvbnRleHQsCiAgICAgIHNldHRlckFyZ3VtZW50VHlwZSwKICAgICAgc2V0dGVyU2lnbmF0dXJlLAogICAgICBzZXR0ZXIsCiAgICAgIHNldHRlckNvbnRleHQKICAgICkgewogICAgICBzdHJ1Y3RSZWdpc3RyYXRpb25zW3N0cnVjdFR5cGVdLmZpZWxkcy5wdXNoKHsKICAgICAgICBmaWVsZE5hbWU6IHJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKSwKICAgICAgICBnZXR0ZXJSZXR1cm5UeXBlOiBnZXR0ZXJSZXR1cm5UeXBlLAogICAgICAgIGdldHRlcjogZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0dGVyU2lnbmF0dXJlLCBnZXR0ZXIpLAogICAgICAgIGdldHRlckNvbnRleHQ6IGdldHRlckNvbnRleHQsCiAgICAgICAgc2V0dGVyQXJndW1lbnRUeXBlOiBzZXR0ZXJBcmd1bWVudFR5cGUsCiAgICAgICAgc2V0dGVyOiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzZXR0ZXJTaWduYXR1cmUsIHNldHRlciksCiAgICAgICAgc2V0dGVyQ29udGV4dDogc2V0dGVyQ29udGV4dCwKICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl92b2lkKHJhd1R5cGUsIG5hbWUpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgaXNWb2lkOiB0cnVlLAogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDAsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICAgICAgfSwKICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbiAoZGVzdHJ1Y3RvcnMsIG8pIHsKICAgICAgICAgIHJldHVybiB1bmRlZmluZWQKICAgICAgICB9LAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9hYm9ydCgpIHsKICAgICAgTW9kdWxlWydhYm9ydCddKCk7CiAgICB9CiAgICB2YXIgX2Vudmlyb24gPSBTVEFUSUNUT1A7CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICBmdW5jdGlvbiBfX19idWlsZEVudmlyb25tZW50KGVudikgewogICAgICB2YXIgTUFYX0VOVl9WQUxVRVMgPSA2NDsKICAgICAgdmFyIFRPVEFMX0VOVl9TSVpFID0gMTAyNDsKICAgICAgdmFyIHBvb2xQdHI7CiAgICAgIHZhciBlbnZQdHI7CiAgICAgIGlmICghX19fYnVpbGRFbnZpcm9ubWVudC5jYWxsZWQpIHsKICAgICAgICBfX19idWlsZEVudmlyb25tZW50LmNhbGxlZCA9IHRydWU7CiAgICAgICAgRU5WWydVU0VSJ10gPSBFTlZbJ0xPR05BTUUnXSA9ICd3ZWJfdXNlcic7CiAgICAgICAgRU5WWydQQVRIJ10gPSAnLyc7CiAgICAgICAgRU5WWydQV0QnXSA9ICcvJzsKICAgICAgICBFTlZbJ0hPTUUnXSA9ICcvaG9tZS93ZWJfdXNlcic7CiAgICAgICAgRU5WWydMQU5HJ10gPSAnQy5VVEYtOCc7CiAgICAgICAgRU5WWydfJ10gPSBNb2R1bGVbJ3RoaXNQcm9ncmFtJ107CiAgICAgICAgcG9vbFB0ciA9IHN0YXRpY0FsbG9jKFRPVEFMX0VOVl9TSVpFKTsKICAgICAgICBlbnZQdHIgPSBzdGF0aWNBbGxvYyhNQVhfRU5WX1ZBTFVFUyAqIDQpOwogICAgICAgIEhFQVAzMltlbnZQdHIgPj4gMl0gPSBwb29sUHRyOwogICAgICAgIEhFQVAzMltfZW52aXJvbiA+PiAyXSA9IGVudlB0cjsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbnZQdHIgPSBIRUFQMzJbX2Vudmlyb24gPj4gMl07CiAgICAgICAgcG9vbFB0ciA9IEhFQVAzMltlbnZQdHIgPj4gMl07CiAgICAgIH0KICAgICAgdmFyIHN0cmluZ3MgPSBbXTsKICAgICAgdmFyIHRvdGFsU2l6ZSA9IDA7CiAgICAgIGZvciAodmFyIGtleSBpbiBlbnYpIHsKICAgICAgICBpZiAodHlwZW9mIGVudltrZXldID09PSAnc3RyaW5nJykgewogICAgICAgICAgdmFyIGxpbmUgPSBrZXkgKyAnPScgKyBlbnZba2V5XTsKICAgICAgICAgIHN0cmluZ3MucHVzaChsaW5lKTsKICAgICAgICAgIHRvdGFsU2l6ZSArPSBsaW5lLmxlbmd0aDsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHRvdGFsU2l6ZSA+IFRPVEFMX0VOVl9TSVpFKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnZpcm9ubWVudCBzaXplIGV4Y2VlZGVkIFRPVEFMX0VOVl9TSVpFIScpCiAgICAgIH0KICAgICAgdmFyIHB0clNpemUgPSA0OwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgbGluZSA9IHN0cmluZ3NbaV07CiAgICAgICAgd3JpdGVBc2NpaVRvTWVtb3J5KGxpbmUsIHBvb2xQdHIpOwogICAgICAgIEhFQVAzMlsoZW52UHRyICsgaSAqIHB0clNpemUpID4+IDJdID0gcG9vbFB0cjsKICAgICAgICBwb29sUHRyICs9IGxpbmUubGVuZ3RoICsgMTsKICAgICAgfQogICAgICBIRUFQMzJbKGVudlB0ciArIHN0cmluZ3MubGVuZ3RoICogcHRyU2l6ZSkgPj4gMl0gPSAwOwogICAgfQogICAgdmFyIEVOViA9IHt9OwogICAgZnVuY3Rpb24gX2dldGVudihuYW1lKSB7CiAgICAgIGlmIChuYW1lID09PSAwKSByZXR1cm4gMAogICAgICBuYW1lID0gUG9pbnRlcl9zdHJpbmdpZnkobmFtZSk7CiAgICAgIGlmICghRU5WLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gMAogICAgICBpZiAoX2dldGVudi5yZXQpIF9mcmVlKF9nZXRlbnYucmV0KTsKICAgICAgX2dldGVudi5yZXQgPSBhbGxvY2F0ZVVURjgoRU5WW25hbWVdKTsKICAgICAgcmV0dXJuIF9nZXRlbnYucmV0CiAgICB9CiAgICBmdW5jdGlvbiBfZ2V0Z3JuYW0oKSB7CiAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnbWlzc2luZyBmdW5jdGlvbjogZ2V0Z3JuYW0nKTsKICAgICAgYWJvcnQoLTEpOwogICAgfQogICAgZnVuY3Rpb24gX2dldHB3bmFtKCkgewogICAgICB0aHJvdyAnZ2V0cHduYW06IFRPRE8nCiAgICB9CiAgICBmdW5jdGlvbiBfanNDbG9zZSgpIHsKICAgICAgcmV0dXJuIGpzQVBJLmNsb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0KICAgIGZ1bmN0aW9uIF9qc0NyZWF0ZShmaWxlbmFtZSkgewogICAgICByZXR1cm4ganNBUEkuY3JlYXRlLmNhbGwobnVsbCwgVVRGMzJUb1N0cmluZyhmaWxlbmFtZSkpCiAgICB9CiAgICBmdW5jdGlvbiBfanNPcGVuKGZpbGVuYW1lKSB7CiAgICAgIHJldHVybiBqc0FQSS5vcGVuLmNhbGwobnVsbCwgVVRGMzJUb1N0cmluZyhmaWxlbmFtZSkpCiAgICB9CiAgICBmdW5jdGlvbiBfanNSZWFkKCkgewogICAgICByZXR1cm4ganNBUEkucmVhZC5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9CiAgICBmdW5jdGlvbiBfanNTZWVrKGZkLCBvZmZzZXQsIG1ldGhvZCkgewogICAgICByZXR1cm4ganNBUEkuc2Vlay5jYWxsKG51bGwsIGZkLCBvZmZzZXQsIFVURjhUb1N0cmluZyhtZXRob2QpKQogICAgfQogICAgZnVuY3Rpb24gX2pzVGVsbCgpIHsKICAgICAgcmV0dXJuIGpzQVBJLnRlbGwuYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfQogICAgZnVuY3Rpb24gX2pzV3JpdGUoKSB7CiAgICAgIHJldHVybiBqc0FQSS53cml0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9CiAgICBmdW5jdGlvbiBfbGx2bV9laF90eXBlaWRfZm9yKHR5cGUpIHsKICAgICAgcmV0dXJuIHR5cGUKICAgIH0KICAgIHZhciBfX190bV9jdXJyZW50ID0gU1RBVElDVE9QOwogICAgU1RBVElDVE9QICs9IDQ4OwogICAgYWxsb2NhdGUoaW50QXJyYXlGcm9tU3RyaW5nKCdHTVQnKSwgJ2k4JywgQUxMT0NfU1RBVElDKTsKICAgIHZhciBfdHpuYW1lID0gU1RBVElDVE9QOwogICAgU1RBVElDVE9QICs9IDE2OwogICAgdmFyIF9kYXlsaWdodCA9IFNUQVRJQ1RPUDsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIHZhciBfdGltZXpvbmUgPSBTVEFUSUNUT1A7CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICBmdW5jdGlvbiBfdHpzZXQoKSB7CiAgICAgIGlmIChfdHpzZXQuY2FsbGVkKSByZXR1cm4KICAgICAgX3R6c2V0LmNhbGxlZCA9IHRydWU7CiAgICAgIEhFQVAzMltfdGltZXpvbmUgPj4gMl0gPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDsKICAgICAgdmFyIHdpbnRlciA9IG5ldyBEYXRlKDJlMywgMCwgMSk7CiAgICAgIHZhciBzdW1tZXIgPSBuZXcgRGF0ZSgyZTMsIDYsIDEpOwogICAgICBIRUFQMzJbX2RheWxpZ2h0ID4+IDJdID0gTnVtYmVyKHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpICE9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpKTsKICAgICAgZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkgewogICAgICAgIHZhciBtYXRjaCA9IGRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1woKFtBLVphLXogXSspXCkkLyk7CiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnR01UJwogICAgICB9CiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyKTsKICAgICAgdmFyIHN1bW1lck5hbWUgPSBleHRyYWN0Wm9uZShzdW1tZXIpOwogICAgICB2YXIgd2ludGVyTmFtZVB0ciA9IGFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZyh3aW50ZXJOYW1lKSwgJ2k4JywgQUxMT0NfTk9STUFMKTsKICAgICAgdmFyIHN1bW1lck5hbWVQdHIgPSBhbGxvY2F0ZShpbnRBcnJheUZyb21TdHJpbmcoc3VtbWVyTmFtZSksICdpOCcsIEFMTE9DX05PUk1BTCk7CiAgICAgIGlmIChzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpKSB7CiAgICAgICAgSEVBUDMyW190em5hbWUgPj4gMl0gPSB3aW50ZXJOYW1lUHRyOwogICAgICAgIEhFQVAzMlsoX3R6bmFtZSArIDQpID4+IDJdID0gc3VtbWVyTmFtZVB0cjsKICAgICAgfSBlbHNlIHsKICAgICAgICBIRUFQMzJbX3R6bmFtZSA+PiAyXSA9IHN1bW1lck5hbWVQdHI7CiAgICAgICAgSEVBUDMyWyhfdHpuYW1lICsgNCkgPj4gMl0gPSB3aW50ZXJOYW1lUHRyOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfbG9jYWx0aW1lX3IodGltZSwgdG1QdHIpIHsKICAgICAgX3R6c2V0KCk7CiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoSEVBUDMyW3RpbWUgPj4gMl0gKiAxZTMpOwogICAgICBIRUFQMzJbdG1QdHIgPj4gMl0gPSBkYXRlLmdldFNlY29uZHMoKTsKICAgICAgSEVBUDMyWyh0bVB0ciArIDQpID4+IDJdID0gZGF0ZS5nZXRNaW51dGVzKCk7CiAgICAgIEhFQVAzMlsodG1QdHIgKyA4KSA+PiAyXSA9IGRhdGUuZ2V0SG91cnMoKTsKICAgICAgSEVBUDMyWyh0bVB0ciArIDEyKSA+PiAyXSA9IGRhdGUuZ2V0RGF0ZSgpOwogICAgICBIRUFQMzJbKHRtUHRyICsgMTYpID4+IDJdID0gZGF0ZS5nZXRNb250aCgpOwogICAgICBIRUFQMzJbKHRtUHRyICsgMjApID4+IDJdID0gZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTkwMDsKICAgICAgSEVBUDMyWyh0bVB0ciArIDI0KSA+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7CiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7CiAgICAgIHZhciB5ZGF5ID0gKChkYXRlLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgLyAoMWUzICogNjAgKiA2MCAqIDI0KSkgfCAwOwogICAgICBIRUFQMzJbKHRtUHRyICsgMjgpID4+IDJdID0geWRheTsKICAgICAgSEVBUDMyWyh0bVB0ciArIDM2KSA+PiAyXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApOwogICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoMmUzLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpOwogICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTsKICAgICAgdmFyIGRzdCA9IChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpIHwgMDsKICAgICAgSEVBUDMyWyh0bVB0ciArIDMyKSA+PiAyXSA9IGRzdDsKICAgICAgdmFyIHpvbmVQdHIgPSBIRUFQMzJbKF90em5hbWUgKyAoZHN0ID8gNCA6IDApKSA+PiAyXTsKICAgICAgSEVBUDMyWyh0bVB0ciArIDQwKSA+PiAyXSA9IHpvbmVQdHI7CiAgICAgIHJldHVybiB0bVB0cgogICAgfQogICAgZnVuY3Rpb24gX2xvY2FsdGltZSh0aW1lKSB7CiAgICAgIHJldHVybiBfbG9jYWx0aW1lX3IodGltZSwgX19fdG1fY3VycmVudCkKICAgIH0KICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHsKICAgICAgSEVBUFU4LnNldChIRUFQVTguc3ViYXJyYXkoc3JjLCBzcmMgKyBudW0pLCBkZXN0KTsKICAgICAgcmV0dXJuIGRlc3QKICAgIH0KICAgIGZ1bmN0aW9uIF9ta3RpbWUodG1QdHIpIHsKICAgICAgX3R6c2V0KCk7CiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoCiAgICAgICAgSEVBUDMyWyh0bVB0ciArIDIwKSA+PiAyXSArIDE5MDAsCiAgICAgICAgSEVBUDMyWyh0bVB0ciArIDE2KSA+PiAyXSwKICAgICAgICBIRUFQMzJbKHRtUHRyICsgMTIpID4+IDJdLAogICAgICAgIEhFQVAzMlsodG1QdHIgKyA4KSA+PiAyXSwKICAgICAgICBIRUFQMzJbKHRtUHRyICsgNCkgPj4gMl0sCiAgICAgICAgSEVBUDMyW3RtUHRyID4+IDJdLAogICAgICAgIDAKICAgICAgKTsKICAgICAgdmFyIGRzdCA9IEhFQVAzMlsodG1QdHIgKyAzMikgPj4gMl07CiAgICAgIHZhciBndWVzc2VkT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpOwogICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpOwogICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoMmUzLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpOwogICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTsKICAgICAgdmFyIGRzdE9mZnNldCA9IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTsKICAgICAgaWYgKGRzdCA8IDApIHsKICAgICAgICBIRUFQMzJbKHRtUHRyICsgMzIpID4+IDJdID0gTnVtYmVyKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZHN0T2Zmc2V0ID09IGd1ZXNzZWRPZmZzZXQpOwogICAgICB9IGVsc2UgaWYgKGRzdCA+IDAgIT0gKGRzdE9mZnNldCA9PSBndWVzc2VkT2Zmc2V0KSkgewogICAgICAgIHZhciBub25Ec3RPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7CiAgICAgICAgdmFyIHRydWVPZmZzZXQgPSBkc3QgPiAwID8gZHN0T2Zmc2V0IDogbm9uRHN0T2Zmc2V0OwogICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICh0cnVlT2Zmc2V0IC0gZ3Vlc3NlZE9mZnNldCkgKiA2ZTQpOwogICAgICB9CiAgICAgIEhFQVAzMlsodG1QdHIgKyAyNCkgPj4gMl0gPSBkYXRlLmdldERheSgpOwogICAgICB2YXIgeWRheSA9ICgoZGF0ZS5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gKDFlMyAqIDYwICogNjAgKiAyNCkpIHwgMDsKICAgICAgSEVBUDMyWyh0bVB0ciArIDI4KSA+PiAyXSA9IHlkYXk7CiAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lKCkgLyAxZTMpIHwgMAogICAgfQogICAgdmFyIFBUSFJFQURfU1BFQ0lGSUMgPSB7fTsKICAgIGZ1bmN0aW9uIF9wdGhyZWFkX2dldHNwZWNpZmljKGtleSkgewogICAgICByZXR1cm4gUFRIUkVBRF9TUEVDSUZJQ1trZXldIHx8IDAKICAgIH0KICAgIHZhciBQVEhSRUFEX1NQRUNJRklDX05FWFRfS0VZID0gMTsKICAgIGZ1bmN0aW9uIF9wdGhyZWFkX2tleV9jcmVhdGUoa2V5LCBkZXN0cnVjdG9yKSB7CiAgICAgIGlmIChrZXkgPT0gMCkgewogICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FSU5WQUwKICAgICAgfQogICAgICBIRUFQMzJba2V5ID4+IDJdID0gUFRIUkVBRF9TUEVDSUZJQ19ORVhUX0tFWTsKICAgICAgUFRIUkVBRF9TUEVDSUZJQ1tQVEhSRUFEX1NQRUNJRklDX05FWFRfS0VZXSA9IDA7CiAgICAgIFBUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVkrKzsKICAgICAgcmV0dXJuIDAKICAgIH0KICAgIGZ1bmN0aW9uIF9wdGhyZWFkX29uY2UocHRyLCBmdW5jKSB7CiAgICAgIGlmICghX3B0aHJlYWRfb25jZS5zZWVuKSBfcHRocmVhZF9vbmNlLnNlZW4gPSB7fTsKICAgICAgaWYgKHB0ciBpbiBfcHRocmVhZF9vbmNlLnNlZW4pIHJldHVybgogICAgICBNb2R1bGVbJ2R5bkNhbGxfdiddKGZ1bmMpOwogICAgICBfcHRocmVhZF9vbmNlLnNlZW5bcHRyXSA9IDE7CiAgICB9CiAgICBmdW5jdGlvbiBfcHRocmVhZF9zZXRzcGVjaWZpYyhrZXksIHZhbHVlKSB7CiAgICAgIGlmICghKGtleSBpbiBQVEhSRUFEX1NQRUNJRklDKSkgewogICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FSU5WQUwKICAgICAgfQogICAgICBQVEhSRUFEX1NQRUNJRklDW2tleV0gPSB2YWx1ZTsKICAgICAgcmV0dXJuIDAKICAgIH0KICAgIGZ1bmN0aW9uIF90aW1lKHB0cikgewogICAgICB2YXIgcmV0ID0gKERhdGUubm93KCkgLyAxZTMpIHwgMDsKICAgICAgaWYgKHB0cikgewogICAgICAgIEhFQVAzMltwdHIgPj4gMl0gPSByZXQ7CiAgICAgIH0KICAgICAgcmV0dXJuIHJldAogICAgfQogICAgRlMuc3RhdGljSW5pdCgpOwogICAgX19BVElOSVRfXy51bnNoaWZ0KGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKCFNb2R1bGVbJ25vRlNJbml0J10gJiYgIUZTLmluaXQuaW5pdGlhbGl6ZWQpIEZTLmluaXQoKTsKICAgIH0pOwogICAgX19BVE1BSU5fXy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgRlMuaWdub3JlUGVybWlzc2lvbnMgPSBmYWxzZTsKICAgIH0pOwogICAgX19BVEVYSVRfXy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgRlMucXVpdCgpOwogICAgfSk7CiAgICBfX0FUSU5JVF9fLnVuc2hpZnQoZnVuY3Rpb24gKCkgewogICAgfSk7CiAgICBfX0FURVhJVF9fLnB1c2goZnVuY3Rpb24gKCkgewogICAgfSk7CiAgICBJbnRlcm5hbEVycm9yID0gTW9kdWxlWydJbnRlcm5hbEVycm9yJ10gPSBleHRlbmRFcnJvcihFcnJvciwgJ0ludGVybmFsRXJyb3InKTsKICAgIGVtYmluZF9pbml0X2NoYXJDb2RlcygpOwogICAgQmluZGluZ0Vycm9yID0gTW9kdWxlWydCaW5kaW5nRXJyb3InXSA9IGV4dGVuZEVycm9yKEVycm9yLCAnQmluZGluZ0Vycm9yJyk7CiAgICBpbml0X0NsYXNzSGFuZGxlKCk7CiAgICBpbml0X1JlZ2lzdGVyZWRQb2ludGVyKCk7CiAgICBpbml0X2VtYmluZCgpOwogICAgVW5ib3VuZFR5cGVFcnJvciA9IE1vZHVsZVsnVW5ib3VuZFR5cGVFcnJvciddID0gZXh0ZW5kRXJyb3IoRXJyb3IsICdVbmJvdW5kVHlwZUVycm9yJyk7CiAgICBpbml0X2VtdmFsKCk7CiAgICBfX19idWlsZEVudmlyb25tZW50KEVOVik7CiAgICBEWU5BTUlDVE9QX1BUUiA9IHN0YXRpY0FsbG9jKDQpOwogICAgU1RBQ0tfQkFTRSA9IFNUQUNLVE9QID0gYWxpZ25NZW1vcnkoU1RBVElDVE9QKTsKICAgIFNUQUNLX01BWCA9IFNUQUNLX0JBU0UgKyBUT1RBTF9TVEFDSzsKICAgIERZTkFNSUNfQkFTRSA9IGFsaWduTWVtb3J5KFNUQUNLX01BWCk7CiAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0gPSBEWU5BTUlDX0JBU0U7CiAgICBzdGF0aWNTZWFsZWQgPSB0cnVlOwogICAgZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHsKICAgICAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkgKyAxOwogICAgICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pOwogICAgICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpOwogICAgICBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuOwogICAgICByZXR1cm4gdThhcnJheQogICAgfQogICAgTW9kdWxlWyd3YXNtVGFibGVTaXplJ10gPSAzMTY7CiAgICBNb2R1bGVbJ3dhc21NYXhUYWJsZVNpemUnXSA9IDMxNjsKICAgIGZ1bmN0aW9uIGludm9rZV9pKGluZGV4KSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9pJ10oaW5kZXgpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LCBhMSkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfaWknXShpbmRleCwgYTEpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpaShpbmRleCwgYTEsIGEyKSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9paWknXShpbmRleCwgYTEsIGEyKQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV9paWlpKGluZGV4LCBhMSwgYTIsIGEzKSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9paWlpJ10oaW5kZXgsIGExLCBhMiwgYTMpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpaWlpKGluZGV4LCBhMSwgYTIsIGEzLCBhNCkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfaWlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpaWlpaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2lpaWlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfaWlpaWlpaWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfaWlpaWlpaWlpaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV9paWlpaWlqaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2lpaWlpaWppaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV9pamooaW5kZXgsIGExLCBhMiwgYTMsIGE0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9pamonXShpbmRleCwgYTEsIGEyLCBhMywgYTQpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2ppKGluZGV4LCBhMSkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfamknXShpbmRleCwgYTEpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3YoaW5kZXgpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdiddKGluZGV4KTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmkoaW5kZXgsIGExKSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpJ10oaW5kZXgsIGExKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpKGluZGV4LCBhMSwgYTIpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpJ10oaW5kZXgsIGExLCBhMik7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsIGExLCBhMiwgYTMpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpaSddKGluZGV4LCBhMSwgYTIsIGEzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0KTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpaWlpKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpaWlpaWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWlpaWlpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aWlpaWlpaWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwKSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpaWlpaWlpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3ZpaihpbmRleCwgYTEsIGEyLCBhMykgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWonXShpbmRleCwgYTEsIGEyLCBhMyk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3ZpamkoaW5kZXgsIGExLCBhMiwgYTMsIGE0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpamknXShpbmRleCwgYTEsIGEyLCBhMywgYTQpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIE1vZHVsZS5hc21HbG9iYWxBcmcgPSB7fTsKICAgIE1vZHVsZS5hc21MaWJyYXJ5QXJnID0gewogICAgICBhYm9ydDogYWJvcnQsCiAgICAgIGVubGFyZ2VNZW1vcnk6IGVubGFyZ2VNZW1vcnksCiAgICAgIGdldFRvdGFsTWVtb3J5OiBnZXRUb3RhbE1lbW9yeSwKICAgICAgYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnk6IGFib3J0T25DYW5ub3RHcm93TWVtb3J5LAogICAgICBpbnZva2VfaTogaW52b2tlX2ksCiAgICAgIGludm9rZV9paTogaW52b2tlX2lpLAogICAgICBpbnZva2VfaWlpOiBpbnZva2VfaWlpLAogICAgICBpbnZva2VfaWlpaTogaW52b2tlX2lpaWksCiAgICAgIGludm9rZV9paWlpaTogaW52b2tlX2lpaWlpLAogICAgICBpbnZva2VfaWlpaWlpaTogaW52b2tlX2lpaWlpaWksCiAgICAgIGludm9rZV9paWlpaWlpaWlpOiBpbnZva2VfaWlpaWlpaWlpaSwKICAgICAgaW52b2tlX2lpaWlpaWppaTogaW52b2tlX2lpaWlpaWppaSwKICAgICAgaW52b2tlX2lqajogaW52b2tlX2lqaiwKICAgICAgaW52b2tlX2ppOiBpbnZva2VfamksCiAgICAgIGludm9rZV92OiBpbnZva2VfdiwKICAgICAgaW52b2tlX3ZpOiBpbnZva2VfdmksCiAgICAgIGludm9rZV92aWk6IGludm9rZV92aWksCiAgICAgIGludm9rZV92aWlpOiBpbnZva2VfdmlpaSwKICAgICAgaW52b2tlX3ZpaWlpOiBpbnZva2VfdmlpaWksCiAgICAgIGludm9rZV92aWlpaWk6IGludm9rZV92aWlpaWksCiAgICAgIGludm9rZV92aWlpaWlpOiBpbnZva2VfdmlpaWlpaSwKICAgICAgaW52b2tlX3ZpaWlpaWlpaWk6IGludm9rZV92aWlpaWlpaWlpLAogICAgICBpbnZva2VfdmlpaWlpaWlpaWk6IGludm9rZV92aWlpaWlpaWlpaSwKICAgICAgaW52b2tlX3ZpajogaW52b2tlX3ZpaiwKICAgICAgaW52b2tlX3Zpamk6IGludm9rZV92aWppLAogICAgICBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uOiBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uLAogICAgICBfX19jeGFfYmVnaW5fY2F0Y2g6IF9fX2N4YV9iZWdpbl9jYXRjaCwKICAgICAgX19fY3hhX2VuZF9jYXRjaDogX19fY3hhX2VuZF9jYXRjaCwKICAgICAgX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMjogX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMiwKICAgICAgX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMzogX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMywKICAgICAgX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNDogX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNCwKICAgICAgX19fY3hhX2ZyZWVfZXhjZXB0aW9uOiBfX19jeGFfZnJlZV9leGNlcHRpb24sCiAgICAgIF9fX2N4YV90aHJvdzogX19fY3hhX3Rocm93LAogICAgICBfX19sb2NrOiBfX19sb2NrLAogICAgICBfX19tYXBfZmlsZTogX19fbWFwX2ZpbGUsCiAgICAgIF9fX3Jlc3VtZUV4Y2VwdGlvbjogX19fcmVzdW1lRXhjZXB0aW9uLAogICAgICBfX19zZXRFcnJObzogX19fc2V0RXJyTm8sCiAgICAgIF9fX3N5c2NhbGwxNDA6IF9fX3N5c2NhbGwxNDAsCiAgICAgIF9fX3N5c2NhbGwxNDU6IF9fX3N5c2NhbGwxNDUsCiAgICAgIF9fX3N5c2NhbGwxNDY6IF9fX3N5c2NhbGwxNDYsCiAgICAgIF9fX3N5c2NhbGwxODM6IF9fX3N5c2NhbGwxODMsCiAgICAgIF9fX3N5c2NhbGwxOTg6IF9fX3N5c2NhbGwxOTgsCiAgICAgIF9fX3N5c2NhbGwyMDogX19fc3lzY2FsbDIwLAogICAgICBfX19zeXNjYWxsNjogX19fc3lzY2FsbDYsCiAgICAgIF9fX3N5c2NhbGw2MDogX19fc3lzY2FsbDYwLAogICAgICBfX19zeXNjYWxsODM6IF9fX3N5c2NhbGw4MywKICAgICAgX19fc3lzY2FsbDkxOiBfX19zeXNjYWxsOTEsCiAgICAgIF9fX3VubG9jazogX19fdW5sb2NrLAogICAgICBfX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3Q6IF9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdCwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfYm9vbDogX19lbWJpbmRfcmVnaXN0ZXJfYm9vbCwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3M6IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcjogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbiwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfZW12YWw6IF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdDogX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI6IF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3OiBfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldywKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZzogX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZywKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc6IF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3Q6IF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdCwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0X2ZpZWxkOiBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ6IF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQsCiAgICAgIF9hYm9ydDogX2Fib3J0LAogICAgICBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLAogICAgICBfZ2V0ZW52OiBfZ2V0ZW52LAogICAgICBfZ2V0Z3JuYW06IF9nZXRncm5hbSwKICAgICAgX2dldHB3bmFtOiBfZ2V0cHduYW0sCiAgICAgIF9qc0Nsb3NlOiBfanNDbG9zZSwKICAgICAgX2pzQ3JlYXRlOiBfanNDcmVhdGUsCiAgICAgIF9qc09wZW46IF9qc09wZW4sCiAgICAgIF9qc1JlYWQ6IF9qc1JlYWQsCiAgICAgIF9qc1NlZWs6IF9qc1NlZWssCiAgICAgIF9qc1RlbGw6IF9qc1RlbGwsCiAgICAgIF9qc1dyaXRlOiBfanNXcml0ZSwKICAgICAgX2xsdm1fZWhfdHlwZWlkX2ZvcjogX2xsdm1fZWhfdHlwZWlkX2ZvciwKICAgICAgX2xvY2FsdGltZTogX2xvY2FsdGltZSwKICAgICAgX21rdGltZTogX21rdGltZSwKICAgICAgX3B0aHJlYWRfZ2V0c3BlY2lmaWM6IF9wdGhyZWFkX2dldHNwZWNpZmljLAogICAgICBfcHRocmVhZF9rZXlfY3JlYXRlOiBfcHRocmVhZF9rZXlfY3JlYXRlLAogICAgICBfcHRocmVhZF9vbmNlOiBfcHRocmVhZF9vbmNlLAogICAgICBfcHRocmVhZF9zZXRzcGVjaWZpYzogX3B0aHJlYWRfc2V0c3BlY2lmaWMsCiAgICAgIF90aW1lOiBfdGltZSwKICAgICAgRFlOQU1JQ1RPUF9QVFI6IERZTkFNSUNUT1BfUFRSLAogICAgICBTVEFDS1RPUDogU1RBQ0tUT1AsCiAgICB9OwogICAgdmFyIGFzbSA9IE1vZHVsZVsnYXNtJ10oTW9kdWxlLmFzbUdsb2JhbEFyZywgTW9kdWxlLmFzbUxpYnJhcnlBcmcsIGJ1ZmZlcik7CiAgICBNb2R1bGVbJ2FzbSddID0gYXNtOwogICAgdmFyIF9fR0xPQkFMX19zdWJfSV9iaW5kX2NwcCA9IChNb2R1bGVbJ19fR0xPQkFMX19zdWJfSV9iaW5kX2NwcCddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICB2YXIgX19HTE9CQUxfX3N1Yl9JX2JyaWRnZV9jcHAgPSAoTW9kdWxlWydfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX19HTE9CQUxfX3N1Yl9JX2JyaWRnZV9jcHAnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCA9IChNb2R1bGVbJ19fR0xPQkFMX19zdWJfSV9jcmNfY3BwJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIF9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwID0gKE1vZHVsZVsnX19HTE9CQUxfX3N1Yl9JX2dsb2JhbF9jcHAnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydfX19jeGFfY2FuX2NhdGNoJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX19jeGFfY2FuX2NhdGNoJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydfX19jeGFfaXNfcG9pbnRlcl90eXBlJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX19jeGFfaXNfcG9pbnRlcl90eXBlJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX19fZXJybm9fbG9jYXRpb24nXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBfX19nZXRUeXBlTmFtZSA9IChNb2R1bGVbJ19fX2dldFR5cGVOYW1lJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX19nZXRUeXBlTmFtZSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIF9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5ID0gKE1vZHVsZVsnX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5J10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICB2YXIgX2ZyZWUgPSAoTW9kdWxlWydfZnJlZSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX2ZyZWUnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBfbWFsbG9jID0gKE1vZHVsZVsnX21hbGxvYyddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX21hbGxvYyddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIHNldFRlbXBSZXQwID0gKE1vZHVsZVsnc2V0VGVtcFJldDAnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ3NldFRlbXBSZXQwJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydzZXRUaHJldyddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnc2V0VGhyZXcnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBzdGFja0FsbG9jID0gKE1vZHVsZVsnc3RhY2tBbGxvYyddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnc3RhY2tBbGxvYyddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9kaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfZGlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2knXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paWlpaWlpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpaWlpaWlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfaWlpaWlpamlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpaWlpaWppaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9pamonXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWpqJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2ppJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2ppJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3YnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdiddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaWQnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpZCddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWlpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpaWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlpaWlpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaWlpaWlpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWlpaWlpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaiddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWonXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlqaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWppJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICBNb2R1bGVbJ2FzbSddID0gYXNtOwogICAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHsKICAgICAgdGhpcy5uYW1lID0gJ0V4aXRTdGF0dXMnOwogICAgICB0aGlzLm1lc3NhZ2UgPSAnUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgnICsgc3RhdHVzICsgJyknOwogICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1czsKICAgIH0KICAgIEV4aXRTdGF0dXMucHJvdG90eXBlID0gbmV3IEVycm9yKCk7CiAgICBFeGl0U3RhdHVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4aXRTdGF0dXM7CiAgICB2YXIgaW5pdGlhbFN0YWNrVG9wOwogICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkgewogICAgICBpZiAoIU1vZHVsZVsnY2FsbGVkUnVuJ10pIHJ1bigpOwogICAgICBpZiAoIU1vZHVsZVsnY2FsbGVkUnVuJ10pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjsKICAgIH07CiAgICBmdW5jdGlvbiBydW4oYXJncykgewogICAgICBhcmdzID0gYXJncyB8fCBNb2R1bGVbJ2FyZ3VtZW50cyddOwogICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkgewogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIHByZVJ1bigpOwogICAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkgcmV0dXJuCiAgICAgIGlmIChNb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm4KICAgICAgZnVuY3Rpb24gZG9SdW4oKSB7CiAgICAgICAgaWYgKE1vZHVsZVsnY2FsbGVkUnVuJ10pIHJldHVybgogICAgICAgIE1vZHVsZVsnY2FsbGVkUnVuJ10gPSB0cnVlOwogICAgICAgIGlmIChBQk9SVCkgcmV0dXJuCiAgICAgICAgZW5zdXJlSW5pdFJ1bnRpbWUoKTsKICAgICAgICBwcmVNYWluKCk7CiAgICAgICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7CiAgICAgICAgcG9zdFJ1bigpOwogICAgICB9CiAgICAgIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7CiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpOwogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpOwogICAgICAgICAgfSwgMSk7CiAgICAgICAgICBkb1J1bigpOwogICAgICAgIH0sIDEpOwogICAgICB9IGVsc2UgewogICAgICAgIGRvUnVuKCk7CiAgICAgIH0KICAgIH0KICAgIE1vZHVsZVsncnVuJ10gPSBydW47CiAgICBmdW5jdGlvbiBleGl0KHN0YXR1cywgaW1wbGljaXQpIHsKICAgICAgaWYgKGltcGxpY2l0ICYmIE1vZHVsZVsnbm9FeGl0UnVudGltZSddICYmIHN0YXR1cyA9PT0gMCkgewogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGlmIChNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSkgOyBlbHNlIHsKICAgICAgICBBQk9SVCA9IHRydWU7CiAgICAgICAgU1RBQ0tUT1AgPSBpbml0aWFsU3RhY2tUb3A7CiAgICAgICAgZXhpdFJ1bnRpbWUoKTsKICAgICAgICBpZiAoTW9kdWxlWydvbkV4aXQnXSkgTW9kdWxlWydvbkV4aXQnXShzdGF0dXMpOwogICAgICB9CiAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7CiAgICAgICAgcHJvY2Vzc1snZXhpdCddKHN0YXR1cyk7CiAgICAgIH0KICAgICAgTW9kdWxlWydxdWl0J10oc3RhdHVzLCBuZXcgRXhpdFN0YXR1cyhzdGF0dXMpKTsKICAgIH0KICAgIE1vZHVsZVsnZXhpdCddID0gZXhpdDsKICAgIGZ1bmN0aW9uIGFib3J0KHdoYXQpIHsKICAgICAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7CiAgICAgICAgTW9kdWxlWydvbkFib3J0J10od2hhdCk7CiAgICAgIH0KICAgICAgaWYgKHdoYXQgIT09IHVuZGVmaW5lZCkgewogICAgICAgIE1vZHVsZS5wcmludCh3aGF0KTsKICAgICAgICBNb2R1bGUucHJpbnRFcnIod2hhdCk7CiAgICAgICAgd2hhdCA9IEpTT04uc3RyaW5naWZ5KHdoYXQpOwogICAgICB9IGVsc2UgewogICAgICAgIHdoYXQgPSAnJzsKICAgICAgfQogICAgICBBQk9SVCA9IHRydWU7CiAgICAgIHRocm93ICdhYm9ydCgnICsgd2hhdCArICcpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLicKICAgIH0KICAgIE1vZHVsZVsnYWJvcnQnXSA9IGFib3J0OwogICAgaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7CiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dOwogICAgICB3aGlsZSAoTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkgewogICAgICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7CiAgICAgIH0KICAgIH0KICAgIE1vZHVsZVsnbm9FeGl0UnVudGltZSddID0gdHJ1ZTsKICAgIHJ1bigpOwoKICAgIHJldHVybiB1bnBhY2sKICB9OwogIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKICAvKioKICAgKiBSZXR1cm5zIGEgUHJvbWlzZSBjb250YWluaW5nIHRoZSByYXIgZXh0cmFjdG9yIGZvciB0aGUgZ2l2ZW4gZmlsZW5hbWUuCiAgICogQHByaXZhdGUKICAgKi8KICBmdW5jdGlvbiBnZXRFeHRyYWN0b3IodXJsKSB7CiAgICByZXR1cm4gZmV0Y2gobmV3IFJlcXVlc3QodXJsKSkKICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7CiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKQogICAgICAgIGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc0MDQgRXJyb3I6IEZpbGUgbm90IGZvdW5kLicpCiAgICAgICAgfQogICAgICB9KQogICAgICAudGhlbigoYnVmZmVyKSA9PiB1bnBhY2tCcmlkZ2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoYnVmZmVyKSkKICB9CgogIC8qKgogICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZm9ybWF0dGVkIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBmaWxlLgogICAqIEBwcml2YXRlCiAgICovCiAgZnVuY3Rpb24gZXh0cmFjdCh7IHJlc291cmNlSWQsIHVybCB9KSB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgICBpZiAoIXVucGFja0JyaWRnZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigndW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCcpCiAgICAgIH0KICAgICAgaWYgKCF1bnBhY2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucGFjayBub3QgZGV0ZWN0ZWQnKQogICAgICB9CgogICAgICBnZXRFeHRyYWN0b3IodXJsKS50aGVuKAogICAgICAgIChleHRyYWN0b3IpID0+IHsKICAgICAgICAgIC8vIHJldHVybiBleHRyYWN0b3IuZXh0cmFjdEFsbCgpOwogICAgICAgICAgcmVzb2x2ZShleHRyYWN0b3IuZXh0cmFjdEFsbCgpKTsKICAgICAgICB9LAogICAgICAgIChlcnIpID0+IHsKICAgICAgICAgIHJlamVjdChlcnIpOwogICAgICAgIH0KICAgICAgKTsKICAgIH0pCiAgfQoKICAvKioKICAgKiBMaXN0ZW4gZm9yIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHdvcmtlci4KICAgKiBAcHJpdmF0ZQogICAqLwogIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZGF0YSwgcG9zdE1lc3NhZ2UpIHsKICAgIGlmIChkYXRhLnR5cGUgPT0gJ2luaXQnKSB7CiAgICAgIHVucGFjayA9IGluaXR1bnBhY2soZGF0YS5idWZmZXIpOwogICAgICB1bnBhY2sub25SdW50aW1lSW5pdGlhbGl6ZWQgPSAoKSA9PiB7CiAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiAnV0FTTV9MT0FERUQnIH0pOwogICAgICB9OwogICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gJ2ZldGNoJykgewogICAgICBleHRyYWN0KGRhdGEpLnRoZW4oCiAgICAgICAgKHVucGFja2VkKSA9PiB7CiAgICAgICAgICByZXR1cm5EYXRhKGRhdGEsIHVucGFja2VkLCBwb3N0TWVzc2FnZSk7CiAgICAgICAgfSwKICAgICAgICAoZXJyKSA9PiB7CiAgICAgICAgICBjb25zdCByZXN1bHQgPSB7CiAgICAgICAgICAgIHRhc2tJZDogZGF0YS50YXNrSWQsCiAgICAgICAgICAgIHR5cGU6ICdFUlJPUicsCiAgICAgICAgICAgIHJlc291cmNlSWQ6IGRhdGEucmVzb3VyY2VJZCwKICAgICAgICAgICAgdXJsOiBkYXRhLnVybCwKICAgICAgICAgIH07CiAgICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHQpOwogICAgICAgIH0KICAgICAgKTsKICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09ICd1bnBhY2snKSB7CiAgICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBkYXRhOwoKICAgICAgaWYgKCF1bnBhY2tCcmlkZ2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucGFja0JyaWRnZSBub3QgZGV0ZWN0ZWQnKQogICAgICB9CiAgICAgIGlmICghdW5wYWNrKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnBhY2sgbm90IGRldGVjdGVkJykKICAgICAgfQoKICAgICAgY29uc3QgZXh0cmFjdG9yID0gdW5wYWNrQnJpZGdlLmNyZWF0ZUV4dHJhY3RvckZyb21EYXRhKGJ1ZmZlcik7CiAgICAgIGNvbnN0IHVucGFja2VkID0gZXh0cmFjdG9yLmV4dHJhY3RBbGwoKTsKICAgICAgcmV0dXJuRGF0YShkYXRhLCB1bnBhY2tlZCwgcG9zdE1lc3NhZ2UpOwogICAgfQogIH0KCiAgZnVuY3Rpb24gcmV0dXJuRGF0YShkYXRhLCB1bnBhY2tlZCwgcG9zdE1lc3NhZ2UpIHsKICAgIGNvbnN0IFtzdGF0ZSwgbGlzdF0gPSB1bnBhY2tlZDsKICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSAnRkFJTCcpIHsKICAgICAgY29uc3QgcmVzdWx0ID0gewogICAgICAgIHRhc2tJZDogZGF0YS50YXNrSWQsCiAgICAgICAgdHlwZTogJ0VSUk9SJywKICAgICAgICByZWFzb246IHN0YXRlLnJlYXNvbiwKICAgICAgICBtc2c6IHN0YXRlLm1zZywKICAgICAgICByZXNvdXJjZUlkOiBkYXRhLnJlc291cmNlSWQsCiAgICAgICAgdXJsOiBkYXRhLnVybCwKICAgICAgfTsKICAgICAgcG9zdE1lc3NhZ2UocmVzdWx0KTsKICAgICAgcmV0dXJuCiAgICB9CiAgICBjb25zdCByZXN1bHQgPSB7CiAgICAgIHRhc2tJZDogZGF0YS50YXNrSWQsCiAgICAgIHR5cGU6ICdGSU5JU0hFRCcsCiAgICAgIHJlc291cmNlSWQ6IGRhdGEucmVzb3VyY2VJZCwKICAgICAgZW50cmllczoge30sCiAgICB9OwoKICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTsKICAgIGlmIChsaXN0ICYmIGxpc3QuZmlsZXMpIHsKICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGxpc3QuZmlsZXMpIHsKICAgICAgICByZXN1bHQuZW50cmllc1tmaWxlLmZpbGVIZWFkZXIubmFtZV0gPSBmaWxlLmV4dHJhY3RbMV07CiAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGZpbGUuZXh0cmFjdFsxXS5idWZmZXIpOwogICAgICB9CiAgICB9CiAgICBwb3N0TWVzc2FnZShyZXN1bHQsIHRyYW5zZmVyYWJsZXMpOwogIH0KCiAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGhhbmRsZU1lc3NhZ2UoZXZlbnQuZGF0YSwgc2VsZi5wb3N0TWVzc2FnZSk7CiAgfTsKCiAgLyoqCiAgICogV2hlbiB0aGUgV0FTTSBydW50aW1lIGhhcyBiZWVuIGluaXRpYWxpemVkIG9uIHRoZSB1bnBhY2suanMgbW9kdWxlLCBzZW5kIGEgbWVzc2FnZSBpbmRpY2F0aW5nCiAgICogdGhhdCB0aGUgbGlicmFyeSBpcyByZWFkeS4KICAgKi8KICAvLyA8IS0tIHByZXR0aWVyLWlnbm9yZS1lbmQgLS0+CgogIGV4cG9ydHMuaGFuZGxlTWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7CgogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7CgogIHJldHVybiBleHBvcnRzOwoKfSkoe30pOwoK', null, false);
  /* eslint-enable */

  // @ts-ignore
  class ArchiveUnpackerMainThread {
      constructor() {
          const buffer = Buffer.from(unpackBase64Str, 'base64');
          // This is a hack to get WebAssembly.instatiate to work.
          // WebAssembly.instatiate in the ArchiveUnpacker-worker.js
          // file started silently failing. i found if I pre-compile
          // then it would then succeed. I beleive we have some
          // kind of race condition on NodeJS.
          WebAssembly.compile(buffer).then((res) => {
              console.log('WebAssembly.compile', res);
          });
          handleMessage$1({
              type: 'init',
              buffer,
          }, () => {
              // console.log(results)
          });
      }
      addTask(taskData, transerables) {
          return new Promise((resolve) => {
              handleMessage$1(taskData, (results) => {
                  resolve(results);
              });
          });
      }
      terminate() { }
  }
  class ArchiveUnpackerWorkerPool extends WorkerPool {
      uint8Array;
      constructor() {
          super(true);
          this.uint8Array = Uint8Array.from(atob(unpackBase64Str), (c) => c.charCodeAt(0));
      }
      constructWorker() {
          return new Promise((resolve) => {
              const worker = new WorkerFactory$2();
              worker.onmessage = (event) => {
                  if (event.data.type == 'WASM_LOADED')
                      resolve(worker);
              };
              worker.postMessage({
                  type: 'init',
                  buffer: this.uint8Array.buffer,
              });
          });
      }
  }
  let threadPool;
  // In NodeJS, we don't use the workers to parse data.
  if (!globalThis.navigator) {
      threadPool = new ArchiveUnpackerMainThread();
  }
  else {
      threadPool = new ArchiveUnpackerWorkerPool();
  }
  /**
   * Archive unpacker plugin.
   */
  class ArchiveUnpackerPlugin extends ResourceLoaderPlugin {
      /**
       * The type of file this plugin handles.
       * @return The type of file.
       */
      getType() {
          return 'archive';
      }
      /**
       * Loads an archive file, returning a promise that resolves to the JSON data value.
       * Note: using the resource loader to centralize data loading enables progress to be tracked and displayed
       * @param url - The url of the data to load.
       * @return - The promise value.
       */
      async loadFile(url) {
          // const start = performance.now()
          try {
              const response = await fetch(url);
              if (!response?.ok) {
                  // make the promise be rejected if we didn't get a 2xx response
                  throw new Error(`ArchiveUnpackerPlugin.loadFile: ${response.status} - ${response.statusText} : ${url}`);
              }
              const buffer = await response.arrayBuffer();
              if (!buffer) {
                  throw new Error('Buffer is null');
              }
              // const start = performance.now()
              const result = await this.extractFile(buffer);
              // console.log('ArchiveUnpackerPlugin.extractFile:' + url, performance.now() - start)
              return result;
          }
          catch (err) {
              // Network error failed. (Not the same as a 404.)
              throw err;
          }
      }
      async extractFile(buffer) {
          const promise = new Promise((resolve, reject) => {
              const resourceId = buffer.byteLength;
              threadPool
                  .addTask({
                  type: 'unpack',
                  resourceId,
                  buffer,
              }, [buffer])
                  .then((data) => {
                  // @ts-ignore
                  // if (data.type == 'FINISHED') resolve(data.entries)
                  // else resolve(null)
                  if (data.type === 'FINISHED') {
                      // const data = data
                      // const text = [
                      //   '==================== ArchiveUnpackerWorker.js ====================',
                      //   `Filename: ${data.resourceId}`,
                      //   '------------------------------------------------------',
                      // ];
                      // for(const file in data.entries) {
                      //   text.push(`${file}:${data.entries[file].byteLength}`);
                      // }
                      // console.log(text.join('\n'))
                      // @ts-ignore
                      resolve(data.entries);
                      // @ts-ignore
                  }
                  else if (data.type === 'ERROR') {
                      // @ts-ignore
                      reject(new Error(`Unable to open archive. The file may be corrupt: ${resourceId}`));
                  }
              });
          });
          return promise;
      }
  }

  /**
   * JSON loader plugin.
   */
  class JsonLoaderPlugin extends ResourceLoaderPlugin {
      /**
       * The type of file this plugin handles.
       * @return The type of file.
       */
      getType() {
          return 'json';
      }
      async loadFile(url) {
          try {
              const response = await fetch(url);
              if (!response?.ok) {
                  // make the promise be rejected if we didn't get a 2xx response
                  throw new Error(`JsonLoaderPlugin.loadFile: ${response.status} - ${response.statusText} : ${url}`);
              }
              const json = await response.json();
              return json;
          }
          catch (err) {
              // Network error failed. (Not the same as a 404.)
              throw err;
          }
      }
  }

  /**
   * Text loader plugin.
   */
  class TextLoaderPlugin extends ResourceLoaderPlugin {
      /**
       * The type of file this plugin handles.
       * @return The type of file.
       */
      getType() {
          return 'text';
      }
      async loadFile(url) {
          try {
              const response = await fetch(url);
              if (!response?.ok) {
                  // make the promise be rejected if we didn't get a 2xx response
                  throw new Error(`TextLoaderPlugin.loadFile: ${response.status} - ${response.statusText} : ${url}`);
              }
              const text = await response.text();
              return text;
          }
          catch (err) {
              // Network error failed. (Not the same as a 404.)
              throw err;
          }
      }
  }

  /**
   * Binary loader plugin.
   */
  class BinaryLoaderPlugin extends ResourceLoaderPlugin {
      /**
       * The type of file this plugin handles.
       * @return The type of file.
       */
      getType() {
          return 'binary';
      }
      async loadFile(url) {
          try {
              const response = await fetch(url);
              if (!response?.ok) {
                  // make the promise be rejected if we didn't get a 2xx response
                  throw new Error(`BinaryLoaderPlugin.loadFile: ${response.status} - ${response.statusText} : ${url}`);
              }
              const arrayBuffer = await response.arrayBuffer();
              return arrayBuffer;
          }
          catch (err) {
              // Network error failed. (Not the same as a 404.)
              throw err;
          }
      }
  }

  /* eslint-disable require-jsdoc */
  // Note: browsers have a maximum number of resources they can load at once
  // before they start throwing errors.
  // The error from Chrome is: Failed to load resource: net::ERR_INSUFFICIENT_RESOURCES
  // We limit the number of concurrent resource loads here
  // by pushing loads into a queue.
  const MAX_LOAD_COUNT = 1000;
  /**
   * Class for delegating resource loading, enabling an abstraction of a cloud file system to be implemented.
   *
   * The resource loader can be used to load data, where it provides central tracking of loading progress and functionality to load various file types, including compressed archives.
   * The plugins script must be loaded along with the engine
   *
   * ```html
   *  <script crossorigin src="libs/zea-engine/dist/plugins.umd.js"></script>
   * ```
   *
   * To load a 'text' file.
   * ```javascript
   *   resourceLoader.loadFile('text', url).then((txt) =>{
   *      console.log(txt)
   *   })
   * ```
   *
   * To load a 'JSON' file.
   * ```javascript
   *   resourceLoader.loadFile('json', url).then((txt) =>{
   *      console.log(json)
   *   })
   * ```
   *
   * To load a 'binary' file.
   * ```javascript
   *   resourceLoader.loadFile('binary', url).then((arrayBuffer) =>{
   *      console.log(arrayBuffer.length)
   *   })
   * ```
   *
   * To load an 'archive' file that is a compressed archive containing multiple sub-files.
   * ```javascript
   *   resourceLoader.loadFile('archive', url).then((entries) =>{
   *      console.log(entries)
   *   })
   * ```
   * **Events**
   * * **loaded:** emitted when a file has finished loading
   * * **progressIncremented:** emitted when a loading of processing task has been incremented
   * * **allResourcesLoaded:** emitted when all outstanding resources are loaded. This event can be used to signal the completion of load.
   */
  class ResourceLoader extends EventEmitter {
      totalWork = 0;
      doneWork = 0;
      baseUrl = '';
      plugins = {};
      systemUrls = {};
      // Common resources are used by systems such at the renderer and VR controllers.
      // Any asset that will probably be used my multiple different independent objects
      // should be loaded here. (For now, it is being used to load VR Controller assets.)
      commonResources = {};
      loadCount = 0;
      queue = [];
      cache;
      /**
       * Create a resource loader.
       */
      constructor() {
          super();
          const baseUrl = 'https://storage.googleapis.com/zea-engine-resources';
          this.systemUrls['ZeaEngine/Vive.vla'] = baseUrl + '/Vive.vla';
          this.systemUrls['ZeaEngine/Oculus.vla'] = baseUrl + '/Oculus.vla';
      }
      // /////////////////////////////////////////////////
      // Register plugins.
      registerPlugin(plugin) {
          this.plugins[plugin.getType()] = plugin;
      }
      /**
       * Loads a file, returning a promise that resolves to the JSON data value.
       * Note: using the resource loader to centralize data loading enables progress to be tracked and displayed
       * @param url - The url of the data to load.
       * @return - The promise value.
       */
      async loadFile(type, url, incrementWorkload = true) {
          const plugin = this.plugins[type];
          if (!plugin) {
              throw new Error(`There's no plugin registered for the type of file "${type}". Did you add the plugins script? See: https://docs.zea.live/zea-engine/#/adding-default-plugins`);
          }
          if (incrementWorkload)
              this.incrementWorkload();
          if (this.cache) {
              const result = await this.cache.get(url);
              if (result) {
                  if (incrementWorkload)
                      this.incrementWorkDone();
                  return result;
              }
          }
          if (this.loadCount < MAX_LOAD_COUNT) {
              this.loadCount++;
              try {
                  const loadFilePromise = plugin.loadFile(url);
                  loadFilePromise.then((result) => {
                      if (this.cache)
                          this.cache.set(url, result);
                      this.loadCount--;
                      if (incrementWorkload)
                          this.incrementWorkDone();
                      this.emit('loaded', { url });
                      while (this.loadCount < MAX_LOAD_COUNT && this.queue.length > 0) {
                          const callback = this.queue.pop();
                          callback();
                      }
                  }, () => {
                      if (incrementWorkload)
                          this.incrementWorkDone();
                  });
                  return loadFilePromise;
              }
              catch (e) {
                  // Error
                  if (incrementWorkload)
                      this.incrementWorkDone();
                  throw e;
              }
          }
          else {
              const promise = new Promise((resolve, reject) => {
                  this.queue.push(() => {
                      this.loadCount++;
                      const loadFilePromise = plugin.loadFile(url);
                      loadFilePromise.then((data) => {
                          this.loadCount--;
                          if (incrementWorkload)
                              this.incrementWorkDone();
                          this.emit('loaded', { url });
                          while (this.loadCount < MAX_LOAD_COUNT && this.queue.length > 0) {
                              const callback = this.queue.pop();
                              callback();
                          }
                          resolve(data);
                      }, (e) => {
                          // Error
                          if (incrementWorkload)
                              this.incrementWorkDone();
                          reject(e);
                      });
                  });
              });
              return promise;
          }
      }
      /**
       * Returns a previously stored common resource. Typically this would be a VR asset.
       *
       * @param resourceId - The resourceId value.
       * @return - The common resource if it exists
       */
      getCommonResource(resourceId) {
          return this.commonResources[resourceId];
      }
      /**
       * Saves a common resource for reuse by other tools. Typically this would be a VR asset.
       *
       * @param resourceId - The resourceId value.
       * @param resource - The common resource to store
       */
      setCommonResource(resourceId, resource) {
          this.commonResources[resourceId] = resource;
      }
      // /////////////////////////////////////////////////
      // Work
      /**
       * Resets the progress counters back to zero. This must be done if a new asset needs to be
       * loaded after some preivous asset has already been loaded and a new load sequence is starting
       *
       * @param amount - The amount value.
       */
      resetProgress() {
          this.totalWork = 0;
          this.doneWork = 0;
      }
      /**
       * Increments the amount of work to be done causing a 'progressIncremented' event to be emitted.
       *
       * The progress bar is based on how much work there is to do Vs how much work has been done.
       * Before loading starts, we don't know how much work is coming because we don't know how many files
       * will be loaded, and how big those files will be. Big files are decompressed as a steam, which
       * involves many small increments.
       * Add we laod files, the work load is incrementened, and then as the work is done, we increment
       * the work done.
       * The ratio between work load and work done determines the percentage of load.
       *
       * @param amount - The amount value.
       */
      incrementWorkload(amount = 1) {
          this.totalWork += amount;
          const percent = (this.doneWork / this.totalWork) * 100;
          this.emit('progressIncremented', new ProgressEvent(percent));
      }
      /**
       * Increments the amount of work done causing a 'progressIncremented' event to be emitted.
       * If 5 items of work have been added using #incrementWorkload, and subsequently 3 items have
       * been completed and #incrementWorkDone called. The progress will be at 3/5, or 60%
       *
       * @param amount - The amount value.
       */
      incrementWorkDone(amount = 1) {
          this.doneWork += amount;
          const percent = (this.doneWork / this.totalWork) * 100;
          this.emit('progressIncremented', new ProgressEvent(percent));
          if (this.doneWork > this.totalWork) {
              console.warn('Mismatch between work loaded and work done.');
          }
      }
  }
  const resourceLoader = new ResourceLoader();
  const archiveUnpackerPlugin = new ArchiveUnpackerPlugin();
  resourceLoader.registerPlugin(archiveUnpackerPlugin);
  const jsonLoaderPlugin = new JsonLoaderPlugin();
  resourceLoader.registerPlugin(jsonLoaderPlugin);
  const textLoaderPlugin = new TextLoaderPlugin();
  resourceLoader.registerPlugin(textLoaderPlugin);
  const binaryLoaderPlugin = new BinaryLoaderPlugin();
  resourceLoader.registerPlugin(binaryLoaderPlugin);

  class IndexDBCache {
      name;
      objStoreName;
      version;
      db;
      constructor(name, objStoreName, version) {
          this.name = name;
          this.objStoreName = objStoreName;
          this.version = version;
      }
      async init() {
          return new Promise((resolve) => {
              const request = globalThis.indexedDB.open(this.name, this.version);
              request.onerror = () => {
                  console.error('IndexedDB Failed');
              };
              request.onsuccess = () => {
                  this.db = request.result;
                  resolve();
              };
              request.onupgradeneeded = () => {
                  this.db = request.result;
                  this.db.createObjectStore(this.objStoreName, {
                      keyPath: 'key',
                  });
              };
          });
      }
      /**
       * Gets a value from the Cache.
       * @param key the unique key to use. This is typically the URL
       * @returns the cached value, or null if the value is not in the Cache
       */
      get(key) {
          return new Promise((resolve, reject) => {
              const tx = this.db.transaction(this.objStoreName, 'readonly');
              const store = tx.objectStore(this.objStoreName);
              const request = store.get(key);
              request.onerror = (event) => {
                  reject(event);
              };
              request.onsuccess = () => {
                  if (request.result)
                      resolve(request.result.value);
                  else
                      resolve(null);
              };
          });
      }
      /**
       * Stores a value in the Cache.
       * @param key the unique key to use. This is typically the URL
       * @param value this can be any object or value.
       */
      set(key, value) {
          return new Promise((resolve, reject) => {
              const tx = this.db.transaction(this.objStoreName, 'readwrite');
              const store = tx.objectStore(this.objStoreName);
              const request = store.put({ key, value });
              request.onsuccess = () => {
                  resolve();
              };
              request.onerror = (event) => {
                  reject(event);
              };
          });
      }
  }

  /**
   * Class designed to store version data. Widely used in the zea engine for backwards compatibility.
   */
  class Version {
      major = 0;
      minor = 0;
      patch = 0;
      branch = '';
      /**
       * Creates a version.
       * The version string should have the following structure:
       * major, minor and patch separated by a dot(`.`) and parts separated by a dash(`-`).
       *
       * @param arg - The version string value, or an array of version numbers.
       */
      constructor(arg) {
          if (typeof arg == 'string') {
              const parts = arg.split('-');
              const numbers = parts[0].split('.');
              this.major = parseInt(numbers[0]);
              this.minor = numbers.length > 1 ? parseInt(numbers[1]) : 0;
              this.patch = numbers.length > 2 ? parseInt(numbers[2]) : 0;
              if (parts.length == 2)
                  this.branch = parts[1];
          }
          else if (Array.isArray(arg)) {
              const numbers = arg;
              this.major = numbers[0];
              this.minor = numbers.length > 1 ? numbers[1] : 0;
              this.patch = numbers.length > 2 ? numbers[2] : 0;
          }
      }
      /**
       * Compare a version object against a version numbers array.
       *
       * @param numbers - An array containing 3 version numbers. [Major, Minor, Patch]
       * @return - return positive: v1 > v2, zero:v1 == v2, negative: v1 < v2
       */
      compare(numbers) {
          // https://stackoverflow.com/questions/6832596/how-to-compare-software-version-number-using-js-only-number
          // 2nd answer.
          const v1 = [this.major, this.minor, this.patch];
          for (let i = 0; i < 3; i++) {
              if (v1[i] !== numbers[i])
                  return v1[i] - numbers[i];
          }
          return 0;
      }
      /**
       * Converts the Version class instance back to an array for comparisons with other version class instances.
       * e.g.
       * ```
       *   const version1 = new Version([1, 2, 3])
       *   const version2 = new Version([1, 2, 4])
       *   const res = version1.compare(version2.asArray())
       * ```
       * @returns an array containing the major, minor and patch version numbers.
       */
      asArray() {
          return [this.major, this.minor, this.patch];
      }
      toString() {
          return `v${this.major}.${this.minor}.${this.patch}` + (this.branch != '' ? `-${this.branch}` : '');
      }
  }

  /* eslint-disable no-unused-vars */
  /**
   * Reads binary data in a specific encoding. Used in loading binary data such as zcad files.
   */
  class BinReader {
      __data;
      __byteOffset;
      __dataView;
      __isMobileDevice;
      utf8decoder;
      /**
       * Create a bin reader.
       *
       * @param data - The data buffer.
       * @param byteOffset - The byte offset value to start reading the buffer.
       * @param isMobileDevice - The isMobileDevice value.
       */
      constructor(data, byteOffset = 0, isMobileDevice = true) {
          this.__data = data;
          this.__byteOffset = byteOffset;
          this.__dataView = new DataView(this.__data);
          this.__isMobileDevice = isMobileDevice;
          this.utf8decoder = new TextDecoder();
      }
      /**
       * Returns state of whether or not the `BinReader` object was instantiated from a mobile device.
       *
       * @return - Returns true is a mobile device is detected.
       */
      get isMobileDevice() {
          return this.__isMobileDevice;
      }
      /**
       * Returns the data buffer we're reading from.
       *
       * @return - The data buffer we are reading from,
       */
      get data() {
          return this.__data;
      }
      /**
       * Returns the length of the buffer.
       *
       * @return - The total length of the buffer
       */
      get byteLength() {
          return this.__dataView.byteLength;
      }
      /**
       * Returns remaining length of the buffer to read.
       *
       * @return - The remaining length of the buffer to read.
       */
      get remainingByteLength() {
          return this.__dataView.byteLength - this.__byteOffset;
      }
      /**
       * Returns current byte offset in the buffer.
       * @return - The current offset in the binary buffer
       */
      pos() {
          return this.__byteOffset;
      }
      /**
       * Sets the byte offset value.
       * @param byteOffset - The byteOffset param.
       */
      seek(byteOffset) {
          this.__byteOffset = byteOffset;
      }
      /**
       * Adds offset bytes to current offset value.
       *
       * @param byteOffset - The byte Offset amount.
       */
      advance(byteOffset) {
          this.__byteOffset += byteOffset;
      }
      /**
       * Returns the unsigned Uint8 value at current byte offset position,
       * and adds one byte to the offset.
       *
       * @return - The return value.
       */
      loadUInt8() {
          const result = this.__dataView.getUint8(this.__byteOffset);
          this.__byteOffset += 1;
          return result;
      }
      /**
       * Returns the unsigned Uint16 value at current byte offset position,
       * and adds two bytes to the offset.
       *
       * @return - The return value.
       */
      loadUInt16() {
          const result = this.__dataView.getUint16(this.__byteOffset, true);
          this.__byteOffset += 2;
          return result;
      }
      /**
       * Returns the unsigned Uint32 value at current byte offset position,
       * and adds four bytes to the offset.
       *
       * @return - The return value.
       */
      loadUInt32() {
          const result = this.__dataView.getUint32(this.__byteOffset, true);
          this.__byteOffset += 4;
          return result;
      }
      /**
       * Returns the signed Int32 value at current byte offset position,
       * and adds four bytes to the offset.
       *
       * @return - The return value.
       */
      loadSInt32() {
          const result = this.__dataView.getInt32(this.__byteOffset, true);
          this.__byteOffset += 4;
          return result;
      }
      /**
       * Returns the Float16 value at current byte offset position,
       * and adds four bytes to the offset.
       *
       * @return - The return value.
       */
      loadFloat16() {
          const uint16 = this.loadUInt16();
          return MathFunctions.decode16BitFloat(uint16);
      }
      /**
       * Returns the Float16 value at current byte offset position,
       * and adds two bytes to the offset.
       *
       * @return - The return value.
       */
      loadUFloat16() {
          const result = this.loadFloat16();
          if (result < 0.0) {
              return 2048.0 - result; // Note: subtract a negative number to add it.
          }
          else {
              return result;
          }
      }
      /**
       * Returns a single signed Float16 value at current byte offset position from 2 unsigned Int8 values,
       * and adds two bytes to the offset.
       *
       * @return - The return value.
       */
      loadFloat16From2xUInt8() {
          throw Error('loadFloat16From2xUInt8 not implemented!');
          // const result = this.__dataView.getFloat16(this.__byteOffset, true)
          // const uint8s = this.loadUInt8Array(2);
          // return Math.decode16BitFloat(uint8s);
          // this.__byteOffset += 2
          // return result
      }
      /**
       * Loads and returns a single Signed integer value from 2 Unsigned Float16 values.
       * @return - The return value.
       */
      loadUInt32From2xUFloat16() {
          const partA = this.loadUFloat16();
          const partB = this.loadUFloat16();
          return partA + partB * 4096;
      }
      /**
       * Loads and returns a single Signed integer value from 2 signed Float16 values.
       * @return - The return value.
       */
      loadSInt32From2xFloat16() {
          const partA = this.loadFloat16();
          const partB = this.loadFloat16();
          return partA + partB * 2048;
      }
      /**
       * Returns the Float32 value at current byte offset position,
       * and adds four bytes to the offset.
       *
       * @return - The return value.
       */
      loadFloat32() {
          const result = this.__dataView.getFloat32(this.__byteOffset, true);
          this.__byteOffset += 4;
          return result;
      }
      /**
       * Reads buffer and return a signed Int8 array with the specified size,
       * starting from current byte offset.
       * Byte offset is increased by the specified byte size.
       *
       * @param size - The size param.
       * @param clone - The clone param.
       * @return - The return value.
       */
      loadInt8Array(size, clone = true) {
          if (size == undefined)
              size = this.loadUInt32();
          let result;
          if (clone) {
              result = new Int8Array(this.__data.slice(this.__byteOffset, this.__byteOffset + size));
              if (result.length != size)
                  console.log('broken');
          }
          else {
              result = new Int8Array(this.__data, this.__byteOffset, size);
          }
          this.__byteOffset += size;
          return result;
      }
      /**
       * Reads buffer and return an unsigned Int8 array with the specified size,
       * starting from current byte offset.
       * Byte offset is increased by the specified byte size.
       *
       * @param size - The size param.
       * @param clone - The clone param.
       * @return - The return value.
       */
      loadUInt8Array(size, clone = true) {
          if (size == undefined)
              size = this.loadUInt32();
          let result;
          if (clone) {
              result = new Uint8Array(this.__data.slice(this.__byteOffset, this.__byteOffset + size));
              if (result.length != size)
                  console.log('broken');
          }
          else {
              result = new Uint8Array(this.__data, this.__byteOffset, size);
          }
          this.__byteOffset += size;
          return result;
      }
      /**
       * Reads buffer and return an unsigned Int16 array with the specified size,
       * starting from current byte offset.
       * Byte offset is increased by the specified byte size x 2.
       *
       * @param size - The size param.
       * @param clone - The clone param.
       * @return - The return value.
       */
      loadUInt16Array(size, clone = true) {
          if (size == undefined)
              size = this.loadUInt32();
          if (size == 0)
              return new Uint16Array();
          this.readPad(2);
          let result;
          if (this.__isMobileDevice) {
              result = new Uint16Array(size);
              for (let i = 0; i < size; i++) {
                  result[i] = this.__dataView.getUint16(this.__byteOffset, true);
                  this.__byteOffset += 2;
              }
          }
          else {
              if (clone) {
                  result = new Uint16Array(this.__data.slice(this.__byteOffset, this.__byteOffset + size * 2));
                  if (result.length != size)
                      console.log('broken');
              }
              else {
                  result = new Uint16Array(this.__data, this.__byteOffset, size);
              }
              this.__byteOffset += size * 2;
          }
          return result;
      }
      /**
       * Reads buffer and return an unsigned Int32 array with the specified size,
       * starting from current byte offset.
       * Byte offset is increased by the specified byte size x 4.
       *
       * @param size - The size param.
       * @param clone - The clone param.
       * @return - The return value.
       */
      loadUInt32Array(size, clone = true) {
          if (size == undefined)
              size = this.loadUInt32();
          if (size == 0)
              return new Uint32Array();
          this.readPad(4);
          let result;
          if (this.__isMobileDevice) {
              result = new Uint32Array(size);
              for (let i = 0; i < size; i++) {
                  result[i] = this.__dataView.getUint32(this.__byteOffset, true);
                  this.__byteOffset += 4;
              }
          }
          else {
              if (clone) {
                  result = new Uint32Array(this.__data.slice(this.__byteOffset, this.__byteOffset + size * 4));
                  if (result.length != size)
                      console.log('broken');
              }
              else {
                  result = new Uint32Array(this.__data, this.__byteOffset, size);
              }
              this.__byteOffset += size * 4;
          }
          return result;
      }
      /**
       * Reads buffer and return a Float32 array with the specified size,
       * starting from current byte offset.
       * Byte offset is increased by the specified byte size x 4.
       *
       * @param size - The size param.
       * @param clone - The clone param.
       * @return - The return value.
       */
      loadFloat32Array(size, clone = true) {
          if (size == undefined)
              size = this.loadUInt32();
          if (size == 0)
              return new Float32Array();
          this.readPad(4);
          let result;
          if (this.__isMobileDevice) {
              result = new Float32Array(size);
              for (let i = 0; i < size; i++) {
                  result[i] = this.__dataView.getFloat32(this.__byteOffset, true);
                  this.__byteOffset += 4;
              }
          }
          else {
              if (clone) {
                  result = new Float32Array(this.__data.slice(this.__byteOffset, this.__byteOffset + size * 4));
              }
              else {
                  result = new Float32Array(this.__data, this.__byteOffset, size);
              }
              this.__byteOffset += size * 4;
          }
          return result;
      }
      /**
       * Returns next string.
       * First looks for the string length description in the next four bytes in the buffer(Starting from byte offset).
       *
       * @return - The return value.
       */
      loadStr() {
          const numChars = this.loadUInt32();
          const chars = new Uint8Array(this.__data, this.__byteOffset, numChars);
          this.__byteOffset += numChars;
          return this.utf8decoder.decode(chars);
      }
      /**
       * Returns an array of strings.
       * First reading the size of the array then reading each string.
       *
       * @return - The return value.
       */
      loadStrArray() {
          const size = this.loadUInt32();
          const result = [];
          for (let i = 0; i < size; i++) {
              result[i] = this.loadStr();
          }
          return result;
      }
      /**
       * Creates and returns a `Vec2` object with the next two signed Int32 values in the buffer.
       *
       * @return - Returns a Vec2.
       */
      loadSInt32Vec2() {
          const x = this.loadSInt32();
          const y = this.loadSInt32();
          return new Vec2(x, y);
      }
      /**
       * Creates and returns a `Vec2` object with the next two unsigned Int32 values in the buffer.
       * @return - Returns a Vec2.
       */
      loadUInt32Vec2() {
          const x = this.loadUInt32();
          const y = this.loadUInt32();
          return new Vec2(x, y);
      }
      /**
       * Creates and returns a `Vec2` object with the next two Float16 values in the buffer.
       *
       * @return - Returns a Vec2.
       */
      loadFloat16Vec2() {
          const x = this.loadFloat16();
          const y = this.loadFloat16();
          return new Vec2(x, y);
      }
      /**
       * Creates and returns a `Vec2` object with the next two Float32 values in the buffer.
       * @return - Returns a Vec2.
       */
      loadFloat32Vec2() {
          const x = this.loadFloat32();
          const y = this.loadFloat32();
          return new Vec2(x, y);
      }
      /**
       * Creates and returns a `Vec3` object with the next three Float16 values in the buffer.
       *
       * @return - Returns a Vec3.
       */
      loadFloat16Vec3() {
          const x = this.loadFloat16();
          const y = this.loadFloat16();
          const z = this.loadFloat16();
          return new Vec3(x, y, z);
      }
      /**
       * Creates and returns a `Vec3` object with the next three Float32 values in the buffer.
       *
       * @return - Returns a Vec3.
       */
      loadFloat32Vec3() {
          const x = this.loadFloat32();
          const y = this.loadFloat32();
          const z = this.loadFloat32();
          return new Vec3(x, y, z);
      }
      /**
       * Creates and returns a `Quat` object with the next four Float16 values in the buffer.
       *
       * @return - Returns a Quat.
       */
      loadFloat16Quat() {
          const x = this.loadFloat16();
          const y = this.loadFloat16();
          const z = this.loadFloat16();
          const w = this.loadFloat16();
          return new Quat(x, y, z, w);
      }
      /**
       * Creates and returns a `Quat` object with the next four Float32 values in the buffer.
       * @return - Returns a Quat.
       */
      loadFloat32Quat() {
          const x = this.loadFloat32();
          const y = this.loadFloat32();
          const z = this.loadFloat32();
          const w = this.loadFloat32();
          return new Quat(x, y, z, w);
      }
      /**
       * Creates and returns a `Color` object with the next three Float32 values in the buffer.
       *
       * @return - Returns a Color.
       */
      loadRGBFloat32Color() {
          const r = this.loadFloat32();
          const g = this.loadFloat32();
          const b = this.loadFloat32();
          return new Color(r, g, b);
      }
      /**
       * Creates and returns a RGBA `Color` object with the next four Float32 values in the buffer.
       * @return - Returns a Color.
       */
      loadRGBAFloat32Color() {
          const r = this.loadFloat32();
          const g = this.loadFloat32();
          const b = this.loadFloat32();
          const a = this.loadFloat32();
          return new Color(r, g, b, a);
      }
      /**
       * Creates and returns a `Color` object with the next three unsigned Int8 values in the buffer.
       * @return - Returns a Color.
       */
      loadRGBUInt8Color() {
          const r = this.loadUInt8();
          const g = this.loadUInt8();
          const b = this.loadUInt8();
          return new Color(r / 255, g / 255, b / 255);
      }
      /**
       * Creates and returns a RGBA `Color` object with the next four unsigned Int8 values in the buffer.
       * @return - Returns a Color.
       */
      loadRGBAUInt8Color() {
          const r = this.loadUInt8();
          const g = this.loadUInt8();
          const b = this.loadUInt8();
          const a = this.loadUInt8();
          return new Color(r / 255, g / 255, b / 255, a / 255);
      }
      /**
       * Creates and returns a `Box2` object with the next four Float32 values in the buffer.
       * Next four because it creates two Vec2.
       *
       * @return - Returns a Box2.
       */
      loadBox2() {
          return new Box2(this.loadFloat32Vec2(), this.loadFloat32Vec2());
      }
      /**
       * Creates and returns a `Box2` object with the next six Float32 values in the buffer.
       * Next four because it creates two Vec3.
       *
       * @return - Returns a Box3.
       */
      loadBox3() {
          return new Box3(this.loadFloat32Vec3(), this.loadFloat32Vec3());
      }
      /**
       * Given a stridee value, advance the pointer to the end of the current stride.
       * @param stride - The stride param.
       */
      readPad(stride) {
          const pad = this.__byteOffset % stride;
          if (pad != 0)
              this.__byteOffset += stride - pad;
      }
  }

  /**
   * Writes `TypedArray` types in binary using a specific encoding.
   */
  class BinWriter {
      __data;
      __byteOffset;
      __reserved;
      __dataView;
      /**
       * Create a bin writer.
       * @param dataSize - The dataSize value.
       */
      constructor(dataSize = 0) {
          this.__data = new ArrayBuffer(dataSize);
          this.__byteOffset = 0;
          this.__reserved = dataSize;
          this.__dataView = new DataView(this.__data);
      }
      /**
       * Returns the byte offset position.
       *
       * @return - The return value.
       */
      pos() {
          return this.__byteOffset;
      }
      /**
       * Sets byte offset value.
       *
       * @param byteOffset - The byteOffset value.
       */
      seek(byteOffset) {
          this.__byteOffset = byteOffset;
      }
      /**
       * The seekEnd method.
       */
      seekEnd() {
          this.__byteOffset = this.__reserved;
      }
      /**
       * Returns written buffer data to current point.
       *
       * @return - Returns an array buffer.
       */
      getBuffer() {
          if (this.__data.byteLength == this.__byteOffset) {
              return this.__data;
          }
          else {
              const unit8Array = new Uint8Array(this.__data);
              return unit8Array.slice(0, this.__byteOffset).buffer;
          }
      }
      /**
       * The __grow method.
       * @private
       */
      __grow() {
          const newSize = (this.__reserved > 0 ? this.__reserved : 1) * 2;
          const data = new ArrayBuffer(newSize);
          const unit8Array = new Uint8Array(data);
          const old_unit8Array = new Uint8Array(this.__data);
          unit8Array.set(old_unit8Array);
          this.__data = data;
          this.__dataView = new DataView(this.__data);
          this.__reserved = newSize;
      }
      /**
       * The __reserve method.
       * @param offset - The offset value.
       * @private
       */
      __reserve(offset) {
          if (this.__byteOffset + offset > this.__reserved) {
              this.__grow();
          }
      }
      /**
       * The __offset method.
       * @param byteCount - The byteCount value.
       * @private
       */
      __offset(byteCount) {
          this.__byteOffset += byteCount;
          if (this.__byteOffset > this.__reserved) {
              this.__grow();
          }
      }
      /**
       * Writes an unsigned Int8 value in current byte offset.
       *
       * @param value - The value param.
       */
      writeUInt8(value) {
          this.__reserve(1);
          this.__dataView.setUint8(this.__byteOffset, value);
          this.__offset(1);
      }
      /**
       * Writes an unsigned Int16 value in current byte offset.
       * @param value - The value param.
       */
      writeUInt16(value) {
          this.__reserve(2);
          this.__dataView.setUint16(this.__byteOffset, value, true);
          this.__offset(2);
      }
      /**
       * Writes an unsigned Int32 value in current byte offset.
       * @param value - The value param.
       */
      writeUInt32(value) {
          this.__reserve(4);
          this.__dataView.setUint32(this.__byteOffset, value, true);
          this.__offset(4);
      }
      /**
       * Writes a signed Int32 value in current byte offset.
       * @param value - The value param.
       */
      writeSInt32(value) {
          this.__reserve(4);
          this.__dataView.setInt32(this.__byteOffset, value, true);
          this.__offset(4);
      }
      /**
       * Writes a Float16 value in current byte offset.
       *
       * @param value - The value param.
       */
      writeFloat16(value) {
          const uint16 = MathFunctions.encode16BitFloat(value);
          this.writeUInt16(uint16);
      }
      /**
       * Writes a Float32 value in current byte offset.
       *
       * @param value - The value param.
       */
      writeFloat32(value) {
          this.__reserve(4);
          this.__dataView.setFloat32(this.__byteOffset, value, true);
          this.__offset(4);
      }
      /**
       * Writes an unsigned Int8 array value from current byte offset.
       *
       * @param value - The value param.
       * @param writeSize - The writeSize value.
       */
      writeUInt8Array(value, writeSize = true) {
          const count = value.length ? value.length : value.length;
          this.__reserve(count + (writeSize ? 4 : 0));
          if (writeSize)
              this.writeUInt32(count);
          for (let i = 0; i < count; i++) {
              this.writeUInt8(value[i]);
          }
      }
      /**
       * Writes an unsigned Int16 array value from current byte offset.
       *
       * @param value - The value param.
       * @param writeSize - The writeSize value.
       */
      writeUInt16Array(value, writeSize = true) {
          const count = value.length ? value.length : value.length;
          this.__reserve(count * 2 + (writeSize ? 4 : 0));
          if (writeSize)
              this.writeUInt32(count);
          for (let i = 0; i < count; i++) {
              this.writeUInt16(value[i]);
          }
      }
      /**
       * Writes an unsigned Int32 array value from current byte offset.
       *
       * @param value - The value param.
       * @param writeSize - The writeSize value.
       */
      writeUInt32Array(value, writeSize = true) {
          const count = value.length ? value.length : value.length;
          this.__reserve(count * 4 + (writeSize ? 4 : 0));
          if (writeSize)
              this.writeUInt32(count);
          for (let i = 0; i < count; i++) {
              this.writeUInt32(value[i]);
          }
      }
      /**
       * Writes a Float32 array value from current byte offset.
       *
       * @param value - The value param.
       * @param writeSize - The writeSize value.
       */
      writeFloat32Array(value, writeSize = true) {
          const count = value.length ? value.length : value.length;
          this.__reserve(count * 4 + (writeSize ? 4 : 0));
          if (writeSize)
              this.writeUInt32(count);
          for (let i = 0; i < count; i++) {
              this.writeFloat32(value[i]);
          }
      }
      /**
       * Writes string value in current position, first writing an unsigned Int32 describing its length, then adding the string in Float32 values.
       *
       * @param str - The str value.
       * @param writeSize - The writeSize value.
       */
      writeStr(str, writeSize = true) {
          const count = str.length;
          this.__reserve(count * 4 + (writeSize ? 4 : 0));
          if (writeSize)
              this.writeUInt32(count);
          for (let i = 0; i < count; i++) {
              this.writeFloat32(str.charCodeAt(i));
          }
      }
      /**
       * Writes a `Vec2` in the buffer using signed Int32 values(In `x,y` order).
       * @param value - The Vec2 to write.
       */
      writeSInt32Vec2(value) {
          this.writeSInt32(value.x);
          this.writeSInt32(value.y);
      }
      /**
       * Writes a `Vec2` in the buffer using unsigned Int32 values(In `x,y` order).
       *
       * @param value - The Vec2 to write.
       */
      writeUInt32Vec2(value) {
          this.writeUInt32(value.x);
          this.writeUInt32(value.y);
      }
      /**
       * Writes a `Vec2` in the buffer using Float16 values(In `x,y` order).
       * @param value - The Vec2 to write.
       */
      writeFloat16Vec2(value) {
          this.writeFloat16(value.x);
          this.writeFloat16(value.y);
      }
      /**
       * Writes a `Vec2` in the buffer using Float32 values(In `x,y` order).
       *
       * @param value - The Vec2 to write.
       */
      writeFloat32Vec2(value) {
          this.writeFloat32(value.x);
          this.writeFloat32(value.y);
      }
      /**
       * Writes a `Vec3` in the buffer using Float16 values(In `x,y,z` order).
       *
       * @param value - The Vec3 to write.
       */
      writeFloat16Vec3(value) {
          this.writeFloat16(value.x);
          this.writeFloat16(value.y);
          this.writeFloat16(value.z);
      }
      /**
       * Writes a `Vec3` in the buffer using Float32 values(In `x,y,z` order).
       * @param value - The Vec3 to write.
       */
      writeFloat32Vec3(value) {
          this.writeFloat32(value.x);
          this.writeFloat32(value.y);
          this.writeFloat32(value.z);
      }
      /**
       * Writes a `Quat` in the buffer using Float16 values(In `x,y,z,w` order).
       *
       * @param value - The Quat to write.
       */
      writeFloat16Quat(value) {
          this.writeFloat16(value.x);
          this.writeFloat16(value.y);
          this.writeFloat16(value.z);
          this.writeFloat16(value.w);
      }
      /**
       * Writes a `Quat` in the buffer using Float32 values(In `x,y,z,w` order).
       *
       * @param value - The Quat to write.
       */
      writeFloat32Quat(value) {
          this.writeFloat32(value.x);
          this.writeFloat32(value.y);
          this.writeFloat32(value.z);
          this.writeFloat32(value.w);
      }
      /**
       * Writes a RGB `Color` in the buffer using Float32 values(In `r,g,b` order).
       *
       * @param value - The Color to write.
       */
      writeRGBFloat32Color(value) {
          this.writeFloat32(value.r);
          this.writeFloat32(value.g);
          this.writeFloat32(value.b);
      }
      /**
       * Writes a RGBA `Color` in the buffer using Float32 values(In `r,g,b,a` order).
       *
       * @param value - The Color to write.
       */
      writeRGBAFloat32Color(value) {
          this.writeFloat32(value.r);
          this.writeFloat32(value.g);
          this.writeFloat32(value.b);
          this.writeFloat32(value.a);
      }
      /**
       * Writes a RGB `Color` in the buffer using unsigned Int8 values(In `r,g,b` order).
       *
       * @param value - The Color to write.
       */
      writeRGBUInt8Color(value) {
          this.writeUInt8(value.r);
          this.writeUInt8(value.g);
          this.writeUInt8(value.b);
      }
      /**
       * Writes a RGBA `Color` in the buffer using unsigned Int8 values(In `r,g,b,a` order).
       *
       * @param value - The Color to write.
       */
      writeRGBAUInt8Color(value) {
          this.writeUInt8(value.r);
          this.writeUInt8(value.g);
          this.writeUInt8(value.b);
          this.writeUInt8(value.a);
      }
      /**
       * Writes a `Box2` in the buffer using Floar32 values(In `p0,p1` order).
       *
       * @param value - The Box2 to write.
       */
      writeBox2(value) {
          this.writeFloat32Vec2(value.p0);
          this.writeFloat32Vec2(value.p1);
      }
      /**
       * Writes a `Box3` in the buffer using Floar32 values(In `p0,p1` order).
       *
       * @param value - The Box3 to write.
       */
      writeBox3(value) {
          this.writeFloat32Vec3(value.p0);
          this.writeFloat32Vec3(value.p1);
      }
      /**
       * The writePadd method.
       * @param size - The size value.
       */
      writePadd(size) {
          const bytes = size - this.__byteOffset;
          this.__reserve(bytes);
          this.__offset(bytes);
      }
      /**
       * The writeAlignment method.
       * @param numBytes - The numBytes value.
       */
      writeAlignment(numBytes) {
          const bytes = this.__byteOffset % numBytes;
          if (bytes != 0) {
              this.__reserve(numBytes - bytes);
              this.__offset(numBytes - bytes);
          }
      }
  }

  exports.OperatorOutputMode = void 0;
  (function (OperatorOutputMode) {
      OperatorOutputMode[OperatorOutputMode["OP_WRITE"] = 0] = "OP_WRITE";
      OperatorOutputMode[OperatorOutputMode["OP_READ_WRITE"] = 1] = "OP_READ_WRITE";
  })(exports.OperatorOutputMode || (exports.OperatorOutputMode = {}));

  /**
   * Represents a reactive type of attribute that can be owned by a `ParameterOwner` class.
   *
   * **Events**
   * * **nameChanged:** Triggered when the name of the parameter changes.
   * * **valueChanged:** Triggered when the value of the parameter changes.
   */
  class Parameter extends BaseItem {
      dirty = false;
      boundInputs = [];
      boundOutputs = [];
      cleaning = false;
      dirtyOpIndex = 0;
      firstOP_WRITE = 0;
      __value;
      dataType;
      ownerItem;
      /**
       * When initializing a new parameter, the passed in value could be anything.
       * If it is a new type of value, just ensure you register it in the `Registry`.
       *
       * How to use it:
       *
       * ```javascript
       *  // Creating a parameter object
       *  const param = new Parameter('Title', 'Awesome Parameter Value', 'String')
       *
       *   // Capturing events
       *  param.on('valueChanged', (...params) => console.log('Value changed!'))
       *
       *  // Changing parameter's value will cause `valueChanged` event to trigger.
       *  param.setValue('A New Awesome Parameter Value')
       *  // As result the console log code will execute: Value Changed!
       * ```
       *
       * @param name - The name of the parameter.
       * @param value - The value of the parameter.
       * @param dataType - The data type of the parameter.
       */
      constructor(name = '', value, dataType) {
          super(name);
          this.__value = value;
          this.dataType = dataType;
      }
      /**
       * Returns the owner item of the current parameter.
       *
       * @return - The return value.
       */
      getOwner() {
          return this.ownerItem;
      }
      /**
       * Sets the owner item of the current parameter.
       *
       * @param ownerItem - The ownerItem value.
       */
      setOwner(ownerItem) {
          this.ownerItem = ownerItem;
      }
      /**
       * Returns parameter's data type.
       *
       * @return - The return value.
       */
      getDataType() {
          return this.dataType;
      }
      // ////////////////////////////////////////////////
      // Operator bindings
      /**
       * When an Operator is reading from a parameter, it must be dirtied when the parameter value
       * changes. The Parameter maintains a list of bound inputs and will propagate dirty to
       * them explicitly.
       *
       * @param operatorInput - The output that we are unbinding from the Parameter
       * @param index - The index(optional) that the output is being bound at.
       * @return - The index of the bound output.
       */
      bindOperatorInput(operatorInput) {
          this.boundInputs.push(operatorInput);
      }
      /**
       * When an operator is being removed from reading from a Parameter, the Input is removed
       * This means the operator will no longer receive updates when the operator changes.
       *
       * @param operatorInput - The output that we are unbinding from the Parameter
       * @return - The return value.
       */
      unbindOperatorInput(operatorInput) {
          const index = this.boundInputs.indexOf(operatorInput);
          this.boundInputs.splice(index, 1);
      }
      /**
       * When an Operator writes to a parameter, it binds its outputs to the parameter at a given
       * index. Then when the operator is dirtied by one of its inputs, it explicitly dirties
       * the output parameters.
       *
       * @param operatorOutput - The output that we are unbinding from the Parameter
       * @param index - The index(optional) that the output is being bound at.
       * @return - The index of the bound output.
       */
      bindOperatorOutput(operatorOutput, index = -1) {
          if (index == -1)
              index = this.boundOutputs.length;
          this.boundOutputs.splice(index, 0, operatorOutput);
          // Update the remaining binding indices
          for (let i = index; i < this.boundOutputs.length; i++) {
              this.boundOutputs[i].setParamBindIndex(i);
          }
          // If we weren't already dirty, make sure to emit a 'valueChanged' anyway.
          this.__findFirstOP_WRITE();
          // This ensures that the operator stack is considered 'clean'
          // and then we call set dirty to force it to become dirty from the insertion point down.
          // Without this line, the operator is considered already 'dirty', and so won't propagate.
          this.dirtyOpIndex = this.boundOutputs.length;
          this.setDirty(index);
          return index;
      }
      /**
       * When an operator is unbinding from a parameter, it removes its self from the list maintained
       * by the parameter.
       *
       * @param operatorOutput - The output that we are unbinding from the Parameter
       * @return - The return value.
       */
      unbindOperatorOutput(operatorOutput) {
          const index = operatorOutput.getParamBindIndex();
          this.boundOutputs.splice(index, 1);
          // Update the remaining binding indices
          for (let i = index; i < this.boundOutputs.length; i++) {
              this.boundOutputs[i].setParamBindIndex(i);
          }
          this.__findFirstOP_WRITE();
          this.dirtyOpIndex = this.boundOutputs.length;
          this.setDirty(Math.max(0, index - 1));
          return index;
      }
      /**
       * Find the first operator in our stack which writes using an OP_WRITE connection.
       * All operators before this op can be ignored during dirty propagation.
       * @private
       */
      __findFirstOP_WRITE() {
          this.firstOP_WRITE = this.boundOutputs.length;
          if (this.boundOutputs.length > 0) {
              for (this.firstOP_WRITE--; this.firstOP_WRITE > 0; this.firstOP_WRITE--) {
                  // Find the first OP_WRITE binding. (Note: we could cache this)
                  if (this.boundOutputs[this.firstOP_WRITE].getMode() == exports.OperatorOutputMode.OP_WRITE)
                      break;
              }
          }
      }
      isDrivenByOperator() {
          return this.firstOP_WRITE == 0 && this.boundOutputs.length > 0;
      }
      /**
       * Dirties this Parameter so subsequent calls to `getValue` will cause an evaluation of its bound operators.
       *
       * @param index - Index of the operator
       * @return - `true` if the Parameter was made dirty, else `false` if it was already dirty.
       */
      setDirty(index) {
          // Determine the first operator in the stack that must evaluate to clean the parameter.
          // Note: if a READ_WRITE op is becoming dirty, then we dirty back up to that op.
          if (index < this.dirtyOpIndex) {
              // If we must dirty all operators in the stack from the last OP_WRITE to the end.
              // Note: If a setDirty call comes from an op that precedes an OP_WRITE operator, we
              // can safely discard it, as its output will have no effect on the value of this parameter.
              let newDirtyIndex = this.firstOP_WRITE;
              if (newDirtyIndex <= index) {
                  this.dirtyOpIndex = newDirtyIndex;
                  for (newDirtyIndex++; newDirtyIndex < this.boundOutputs.length; newDirtyIndex++) {
                      // Dirty all the other bound ops from the OP_WRITE to the top of the stack.
                      if (newDirtyIndex != index) {
                          // This will cause the other outputs of the operator to become dirty.
                          this.boundOutputs[newDirtyIndex].getOperator().setDirty();
                      }
                  }
                  for (let i = 0; i < this.boundInputs.length; i++) {
                      this.boundInputs[i].setDirty();
                  }
                  this.emit('valueChanged');
                  return true;
              }
          }
          return false;
      }
      /**
       * Returns true if this parameter is currently dirty and will evaluate its bound
       * operators if its value is requested by a call to getValue.
       *
       * @return - Returns a boolean.
       */
      isDirty() {
          return this.dirtyOpIndex < this.boundOutputs.length;
      }
      /**
       * Returns the index of the first 'dirty' binding in the stack. This will be the index of the
       * first operator that will evaluate when the parameter needs to be cleaned.
       *
       * @return - The index of the dirty binding in the binding stack.
       */
      getDirtyBindingIndex() {
          return this.dirtyOpIndex;
      }
      /**
       * The setCleanFromOp method.
       * @param value - The computed value to be stored in the Parameter.
       * @param index - The index of the bound OperatorOutput.
       */
      setCleanFromOp(value, index) {
          if (index != this.dirtyOpIndex) {
              if (index < this.dirtyOpIndex) {
                  // This can happen when an operator in the following case.
                  // ParamA [OpC, OpB, OpA]
                  // ParamB [OpC, OpA]
                  // When OpB dirties ParamA, and is evaluated, ParamB is considered clean because OpA was never dirtied
                  // We see this message when parameters are evaluated as soon as a change is detected instead of
                  // in batches. Now that all rendering code is pulling data only during the render cycle, we ara
                  // not seeing it anymore. However, maybe with a UI open, it will start emitting this warning.
                  // Note: this would be caused, if a Parameter is already cleaned by an Operator, and yet the Operator
                  // is re-evaluating. I am not sure how this can occur.
                  // const op = operatorOutput.getOperator()
                  // console.log(
                  //   `Operator:: ${
                  //     op.constructor.name
                  //   } with name: ${op.getName()} is being cleaned immediately, instead of lazily.`
                  // )
                  console.log(`Parameter is cleaned when it was already clean to that point in the stack:`, this.getPath());
              }
              else if (this.boundOutputs[index].getMode() != exports.OperatorOutputMode.OP_WRITE) {
                  // A parameter can become dirty (so __dirtyOpIndex == 0), and then another operator bound on top.
                  // if the next op is a WRITE op, then we can fast forward the dirty index.
                  const thisClassName = this.getClassName();
                  const op = this.boundOutputs[index].getOperator();
                  const opClassName = op.getClassName();
                  throw new Error(`Parameter: ${thisClassName} with name: ${this.getName()} is not cleaning all outputs during evaluation of op: ${opClassName} with name: ${op.getName()}`);
              }
          }
          this.__value = value;
          // As each operator writes its value, the dirty value is incremented
          this.dirtyOpIndex = index + 1;
      }
      /**
       * During operator evaluation, operators can use this method to retrieve the existing
       * value of one of their outputs.
       * @param index - The index of the bound OperatorOutput to evaluate up to.
       * @return - The return value.
       */
      getValueFromOp(index) {
          // Note: during evaluation of an Operator that writes to multiple outputs,
          // it can write to an output with an IO setting, which means it retrieves
          // the previous value while calculating the next.
          if (this.dirtyOpIndex < index) {
              this._clean(index);
          }
          return this.__value;
      }
      /**
       * Cleans the parameter up tp the index of the specified index of the bound OperatorOutput
       *
       * @param index - The index of the bound OperatorOutput to evaluate up to.
       */
      _clean(index) {
          if (this.cleaning) {
              throw new Error(`Cycle detected when cleaning: ${this.getPath()}. Operators need to be rebound to fix errors`);
          }
          this.cleaning = true;
          while (this.dirtyOpIndex < index) {
              const tmp = this.dirtyOpIndex;
              const operatorOutput = this.boundOutputs[this.dirtyOpIndex];
              // The op can get the current value and modify it in place
              // and set the output to clean.
              operatorOutput.getOperator().evaluate();
              if (tmp == this.dirtyOpIndex) {
                  // During initial configuration of an operator, cleaning outputs might be disabled.
                  const op = this.boundOutputs[this.dirtyOpIndex].getOperator();
                  const opClassName = op.getClassName();
                  console.warn(`Operator: ${opClassName} with name: ${op.getName()} is not cleaning its outputs during evaluation`);
                  this.dirtyOpIndex++;
              }
          }
          this.cleaning = false;
      }
      /**
       * Returns parameter's value.
       * @return - The return value.
       */
      getValue() {
          if (this.dirtyOpIndex < this.boundOutputs.length) {
              this._clean(this.boundOutputs.length);
          }
          return this.__value;
      }
      /**
       * Sets value of the parameter.
       *
       * @param value - The value param.
       */
      setValue(value) {
          if (value == undefined) {
              // eslint-disable-next-line no-throw-literal
              throw 'undefined was passed into the set value for param:' + this.getName();
          }
          if (this.boundOutputs.length > 0) {
              for (let i = this.boundOutputs.length - 1; i >= 0; i--) {
                  const operatorOutput = this.boundOutputs[i];
                  value = operatorOutput.backPropagateValue(value);
                  if (operatorOutput.getMode() == 0 /* OP_WRITE */)
                      return;
              }
          }
          if (typeof value !== 'object') {
              // Note: equality tests on anything but simple values is going to be super expensive.
              if (this.__value == value)
                  return;
          }
          this.__value = value;
          // Note: only users call 'setValue'. Operators call 'setCleanFromOp'
          for (let i = 0; i < this.boundInputs.length; i++) {
              this.boundInputs[i].paramValueChanged();
          }
          this.emit('valueChanged');
      }
      get value() {
          return this.getValue();
      }
      set value(value) {
          this.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The loadValue is used to change the value of a parameter, without triggering a
       * valueChanges.
       *
       * @param value - The context value.
       */
      loadValue(value) {
          this.__value = value;
      }
      copyFrom(src, context) {
          this.loadValue(src.__value);
      }
      /**
       * The readBinary method.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          console.warn(`TODO: Parameter: ${this.constructor.name} with name: ${this.__name} does not implement readBinary`);
      }
      /**
       * Returns the parameter's path as an array of strings.
       * Includes owner's path in case it is owned by a `ParameterOwner`.
       *
       * @return - The return value.
       */
      getPath() {
          if (this.ownerItem instanceof BaseItem) {
              return [...this.ownerItem.getPath(), this.__name];
          }
          else {
              return [this.__name];
          }
      }
      resolvePath(path, index = 0) {
          if (index == 0) {
              if (path[0] == '.' || path[0] == this.__name)
                  index++;
          }
          if (path[index] == '..') {
              if (this.__ownerItem) {
                  return this.__ownerItem.resolvePath(path, index + 1);
              }
              else {
                  throw Error('this.__ownerItem is undefined');
              }
          }
          if (index == path.length) {
              return this;
          }
          if (path[index] == 'value') {
              // The path to the parameter, assumes that the next item will be a sub-param
              // of the value of the parameter.
              if (this.value instanceof BaseItem)
                  return this.value.resolvePath(path, index + 1);
          }
          throw new Error('Invalid path:' + path + '[' + index + ']. Path does not resolve to a BaseItem');
      }
      /**
       * The readBinary method.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      destroy() {
          console.warn('nothing destroyed. This method was not overwritten in subclass');
      }
  }

  /**
   * Represents a specific type of parameter, that only stores numeric values.
   *
   * ```javascript
   * const numberParam = new NumberParameter('MyNumber', 15)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(numberParam)
   * ```
   *
   * @extends Parameter
   */
  class NumberParameter extends Parameter {
      range; // TODO: should create type with two fields for range. Must change how range is used.
      step;
      /**
       * Create a number parameter.
       * @param name - The name of the number parameter.
       * @param value - The value of the parameter.
       * @param range - An array with two numbers. If defined, the parameter value will be clamped.
       * @param step - The step value. If defined, the parameter value will be rounded to the nearest integer.
       */
      constructor(name = '', value = 0, range, step) {
          super(name, value, 'Number');
          this.range = range;
          this.step = step;
      }
      /**
       * Returns the range to which the parameter is restrained.
       *
       * @return - The return value.
       */
      getRange() {
          return this.range;
      }
      /**
       * Sets the range to which the parameter is restrained.
       *
       * @param range - The range value.
       */
      setRange(range) {
          this.range = range;
      }
      /**
       * Returns the step number, which is the one used for rounding.
       *
       * @return - The return value.
       */
      getStep() {
          return this.step;
      }
      /**
       * Returns step value.
       *
       * @param step - The step value.
       */
      setStep(step) {
          this.step = step;
      }
      setValue(value) {
          if (typeof value != 'number') {
              throw new Error(`value provided is not a number. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          this.__value = j.value;
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value = reader.loadFloat32();
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new number parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new number parameter.
       */
      clone() {
          return new NumberParameter(this.name, this.__value, this.range, this.step);
      }
  }
  // eslint-disable-next-line require-jsdoc
  class Float32Parameter extends NumberParameter {
      // eslint-disable-next-line require-jsdoc
      readBinary(reader, context) {
          this.__value = reader.loadFloat32();
      }
  }
  // eslint-disable-next-line require-jsdoc
  class SInt32Parameter extends NumberParameter {
      // eslint-disable-next-line require-jsdoc
      readBinary(reader, context) {
          this.__value = reader.loadSInt32();
      }
  }
  // eslint-disable-next-line require-jsdoc
  class UInt32Parameter extends NumberParameter {
      // eslint-disable-next-line require-jsdoc
      readBinary(reader, context) {
          this.__value = reader.loadUInt32();
      }
  }
  // eslint-disable-next-line require-jsdoc
  class AngleParameter extends Float32Parameter {
  }
  Registry.register('NumberParameter', NumberParameter);
  Registry.register('Property_SInt32', SInt32Parameter);
  Registry.register('Property_UInt32', UInt32Parameter);
  Registry.register('Property_Float32', Float32Parameter);
  Registry.register('AngleParameter', AngleParameter);

  /**
   * Represents a specific type of parameter, that stores multiple choice(array) values.
   *
   * i.e.:
   * ```javascript
   * const multiChoiceParameter =  new MultiChoiceParameter('InitialXfoMode', GROUP_INITIAL_XFO_MODES.average, [
   *                                  'manual',
   *                                  'first',
   *                                  'average',
   *                                  'global',
   *                                ])
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(multiChoiceParameter)
   * ```
   * @extends NumberParameter
   */
  class MultiChoiceParameter extends NumberParameter {
      choices;
      /**
       * Create a multi choice parameter.
       * @param name - The name of the multi choice parameter.
       * @param index - The index value.
       * @param choices - The choices value.
       */
      constructor(name, index, choices = []) {
          super(name, index, [0, choices.length], 1);
          this.choices = choices;
      }
      /**
       * Returns choices array.
       *
       * @return - The return value.
       */
      getChoices() {
          return this.choices;
      }
      /**
       * Sets parameter index value.
       *
       * @param value - The value param.
       */
      setValue(value) {
          if (typeof value === 'string') {
              super.setValue(this.choices.indexOf(value));
          }
          else {
              super.setValue(value);
          }
      }
      clone() {
          return new MultiChoiceParameter(this.name, this.__value, this.choices);
      }
  }
  Registry.register('MultiChoiceParameter', MultiChoiceParameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * Represents a specific type of parameter, that only stores `boolean` values.
   *
   * i.e.:
   * ```javascript
   * const booleanParam = new BooleanParameter('MyBoolean', true)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(booleanParam)
   * ```
   * @extends Parameter
   */
  class BooleanParameter extends Parameter {
      /**
       * Creates a new parameter with `Boolean` data type.
       *
       * @param name - The name of the boolean parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value != undefined ? value : false, 'Boolean');
      }
      setValue(value) {
          if (typeof value != 'boolean') {
              throw new Error(`value provided is not a boolean. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Loads the boolean values from the binary buffer.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          const newValue = reader.loadUInt8() != 0;
          if (this.__value != newValue) {
              this.__value = newValue;
              // Note: the BooleanParameter is used in Visiblity
              // If it changes, we listen and update visiility of entire assemblies.
              this.emit('valueChanged');
          }
      }
      /**
       * The toJSON method serializes this instance as a JSON.
       * It can be used for persistence, data transfer, etc.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value };
      }
      /**
       * The fromJSON method takes a JSON and deserializes into an instance of this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (this.__value != j.value) {
              this.__value = j.value;
              // Note: the BooleanParameter is used in Visiblity
              // If it changes, we listen and update visiility of entire assemblies.
              this.emit('valueChanged');
          }
      }
      /**
       * The clone method constructs a new parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new cloned parameter.
       */
      clone() {
          return new BooleanParameter(this.name, this.__value);
      }
  }
  Registry.register('BooleanParameter', BooleanParameter);
  Registry.register('Property_Boolean', BooleanParameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores Vec2(two-dimensional coordinate) values.
   *
   * i.e.:
   * ```javascript
   * const vec2Param = new Vec2Parameter('MyVec2', new Vec2(1.2, 3.4))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(vec2Param)
   * ```
   *
   * **Events**
   * * **rangeChanged:** Triggered when rage array changes.
   *
   * @extends Parameter
   */
  class Vec2Parameter extends Parameter {
      range;
      /**
       * Create a Vec2 parameter.
       *
       * @param name - The name of the Vec2 parameter.
       * @param value - The value of the parameter.
       * @param range - The range value is an array of two `Vec2` objects.
       */
      constructor(name = '', value, range) {
          super(name, value ? value : new Vec2(), 'Vec2');
          this.range = range;
      }
      /**
       * Returns the range of values in which current parameter can be.
       *
       * @return - The return value.
       */
      getRange() {
          // Range should be an array of 2 vec2s. [min(x,y), max(x,y)]
          return this.range;
      }
      /**
       * The __setRange method.
       * @param range - The range value.
       * @private
       */
      setRange(range) {
          // Should be an array [0, 20]
          this.range = range;
          this.emit('rangeChanged', { range });
      }
      setValue(value) {
          if (!(value instanceof Vec2)) {
              throw new Error(`value provided is not an instance of a 'Vec2' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          const vec2 = new Vec2();
          vec2.fromJSON(j.value);
          this.__value = vec2;
          if (j.name)
              this.name = j.name;
      }
      /**
       * The clone method constructs a new Vec2 parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new Vec2 parameter.
       */
      clone() {
          const clonedParam = new Vec2Parameter(this.name, this.__value?.clone());
          if (this.range)
              clonedParam.setRange(this.range);
          return clonedParam;
      }
  }
  Registry.register('Vec2Parameter', Vec2Parameter);
  Registry.register('Property_Vec2_32f', Vec2Parameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores Vec3(three-dimensional coordinate) values.
   *
   * i.e.:
   * ```javascript
   * const vec3Param = new Vec3Parameter('MyVec3', new Vec3(1.2, 3.4, 1))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(vec3Param)
   * ```
   * @extends Parameter
   */
  class Vec3Parameter extends Parameter {
      range;
      /**
       * Create a Vec3 parameter.
       *
       * @param name - The name of the Vec3 parameter.
       * @param value - The value of the parameter.
       * @param range - The range value is an array of two `Vec3` objects.
       */
      constructor(name = '', value, range) {
          super(name, value ? value : new Vec3(), 'Vec3');
          this.range = range;
      }
      setValue(value) {
          if (!(value instanceof Vec3)) {
              throw new Error(`value provided is not an instance of a 'Vec2' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          const vec4 = new Vec3();
          vec4.fromJSON(j.value);
          this.__value = vec4;
          if (j.name)
              this.name = j.name;
      }
      /**
       * The clone method constructs a new Vec3 parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new Vec3 parameter.
       */
      clone() {
          const clonedParam = new Vec3Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Vec3Parameter', Vec3Parameter);
  Registry.register('Property_Vec3_32f', Vec3Parameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores Vec4(four-dimensional coordinate) values.
   *
   * i.e.:
   * ```javascript
   * const vec4Param = new Vec4Parameter('MyVec4', new Vec4(1.2, 3.4, 1, 4.2))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(vec4Param)
   * ```
   *
   * @extends Parameter
   */
  class Vec4Parameter extends Parameter {
      /**
       * Create a Vec4 parameter.
       * @param name - The name of the Vec4 parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Vec4(), 'Vec4');
      }
      setValue(value) {
          if (!(value instanceof Vec4)) {
              throw new Error(`value provided is not an instance of a 'Vec4' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value?.toJSON() };
      }
      fromJSON(j, context) {
          const vec4 = new Vec4();
          vec4.fromJSON(j.value);
          this.__value = vec4;
          if (j.name)
              this.name = j.name;
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new Vec4 parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new Vec4 parameter.
       */
      clone() {
          const clonedParam = new Vec4Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Vec4Parameter', Vec4Parameter);
  Registry.register('Property_Vec4_32f', Vec4Parameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * @extends Parameter
   */
  class Box2Parameter extends Parameter {
      /**
       * Create a Box2 parameter.
       * @param name - The name of the Box2 parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Box2(), 'Box2');
      }
      setValue(value) {
          if (!(value instanceof Box2)) {
              throw new Error(`value provided is not an instance of a 'Box2' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value.p0.readBinary(reader);
          this.__value.p1.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: {
                  p0: this.__value.p0.toJSON(),
                  p1: this.__value.p1.toJSON(),
              },
          };
      }
      fromJSON(j, context) {
          this.__value.p0.fromJSON(j.p0);
          this.__value.p1.fromJSON(j.p1);
      }
      /**
       * The clone method constructs a new Box2 parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned Box2 parameter.
       */
      clone() {
          const clonedParam = new Box2Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Box2Parameter', Box2Parameter);
  Registry.register('Property_Box2_32f', Box2Parameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * @extends Parameter
   */
  class Box3Parameter extends Parameter {
      /**
       * Create a Box3 parameter.
       * @param name - The name of the Box3 parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Box3(), 'Box3');
      }
      setValue(value) {
          if (!(value instanceof Box3)) {
              throw new Error(`value provided is not an instance of a 'Box3' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value.p0.readBinary(reader);
          this.__value.p1.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value.toJSON(),
          };
      }
      fromJSON(j, context) {
          if (j.value) {
              // @ts-ignore
              this.__value.fromJSON(j.value);
          }
      }
      /**
       * The clone method constructs a new Box3 parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned Box3 parameter.
       */
      clone() {
          const clonedParam = new Box3Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Box3Parameter', Box3Parameter);
  Registry.register('Property_Box3_32f', Box3Parameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores `Color` values.
   *
   * i.e.:
   * ```javascript
   * const colorParam = new ColorParameter('MyColor', new Color(0, 254, 2))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(colorParam)
   * ```
   *
   * @extends Parameter
   */
  class ColorParameter extends Parameter {
      /**
       * Create a color parameter.
       * @param name - The name of the color parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Color(), 'Color');
      }
      setValue(value) {
          if (!(value instanceof Color)) {
              throw new Error(`value provided is not an instance of a 'Color' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts `Color` values from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          const value = reader.loadRGBAFloat32Color();
          // If the value is in linear space, then we should convert it to gamma space.
          // Note: !! this should always be done in preprocessing...
          value.applyGamma(2.2);
          this.__value = value;
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          // if (j.value.type) this.__value = Registry.constructClass('Color') as Color // TODO: commented out Registry.constructClass
          this.__value?.fromJSON(j.value);
      }
      /**
       * The clone method constructs a new color parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned color parameter.
       */
      clone() {
          const clonedParam = new ColorParameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('ColorParameter', ColorParameter);
  Registry.register('Property_Color_32f', ColorParameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores Vec3(four-dimensional coordinate) values.
   *
   * i.e.:
   * ```javascript
   * const quatParam = new QuatParameter('MyQuat', new Quat(1.2, 3.4, 1, 4.2))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(quatParam)
   * ```
   *
   * @extends Parameter
   */
  class QuatParameter extends Parameter {
      /**
       * Create a Quat parameter.
       * @param name - The name of the Quat parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Quat(), 'Quat');
      }
      setValue(value) {
          if (!(value instanceof Quat)) {
              throw new Error(`value provided is not an instance of a 'Quat' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          const quat = new Quat();
          quat.fromJSON(j.value);
          this.__value = quat;
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new Quat parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new Quat parameter.
       */
      clone() {
          const clonedParam = new QuatParameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('QuatParameter', QuatParameter);
  Registry.register('Property_Quat_32f', QuatParameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * Represents a specific type of parameter, that only stores Mat3(3x3 matrix) values.
   *
   * i.e.:
   * ```javascript
   * const mat3Param = new Ma3Parameter('MyMat3', new Mat3(...args))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(mat3Param)
   * ```
   *
   * @extends Parameter
   */
  class Mat3Parameter extends Parameter {
      /**
       * Create a Mat3 parameter.
       * @param name - The name of the Mat3 parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Mat3(), 'Mat3');
      }
      setValue(value) {
          if (!(value instanceof Mat3)) {
              throw new Error(`value provided is not an instance of a 'Mat3' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          const mat3 = new Mat3();
          mat3.fromJSON(j.value);
          this.__value = mat3;
      }
      /**
       * The clone method constructs a new Mat3 parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned Mat3 parameter.
       */
      clone() {
          const clonedParam = new Mat3Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Mat3Parameter', Mat3Parameter);
  Registry.register('Property_Mat3_32f', Mat3Parameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores Mat4(4x4 matrix) values.
   *
   * i.e.:
   * ```javascript
   * const mat4Param = new Ma3Parameter('MyMat4', new Mat4(...args))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(mat4Param)
   * ```
   *
   * @extends Parameter
   */
  class Mat4Parameter extends Parameter {
      /**
       * Create a Mat4 parameter.
       *
       * @param name - The name of the Mat4 parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Mat4(), 'Mat4');
      }
      setValue(value) {
          if (!(value instanceof Mat4)) {
              throw new Error(`value provided is not an instance of a 'Mat4' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value?.readBinary(reader);
      }
      toJSON(context) {
          return {
              type: this.getClassName(),
              value: this.__value?.toJSON(),
          };
      }
      fromJSON(j, context) {
          const mat4 = new Mat4();
          mat4.fromJSON(j.value);
          this.__value = mat4;
      }
      /**
       * The clone method constructs a new Mat4 parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned Mat4 parameter.
       */
      clone() {
          const clonedParam = new Mat4Parameter(this.name, this.__value?.clone());
          return clonedParam;
      }
  }
  Registry.register('Mat4Parameter', Mat4Parameter);
  Registry.register('Property_Mat4_32f', Mat4Parameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores `Xfo` transform values.
   *
   * ```javascript
   * const xfoParam = new XfoParameter('MyXfo', new Xfo(new Vec3(1.2, 3.4, 1)))
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(xfoParam)
   * ```
   *
   * @extends Parameter
   */
  class XfoParameter extends Parameter {
      /**
       * Create a Xfo parameter.
       * @param name - The name of the Xfo parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value ? value : new Xfo(), 'Xfo');
      }
      setValue(value) {
          if (!(value instanceof Xfo)) {
              throw new Error(`value provided is not an instance of a 'Xfo' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Extracts a number value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value.readBinary(reader);
      }
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value.toJSON() };
      }
      fromJSON(j, context) {
          const xfo = new Xfo();
          xfo.fromJSON(j.value);
          this.__value = xfo;
          if (j.name)
              this.name = j.name;
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new Xfo parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new Xfo parameter.
       */
      clone() {
          const clonedParam = new XfoParameter(this.name, this.__value.clone());
          return clonedParam;
      }
  }
  Registry.register('XfoParameter', XfoParameter);
  Registry.register('Property_Xfo_32f', XfoParameter);

  /**
   * Represents a 2D image item, containing width and height.
   *
   * **Events**
   * * **updated:** Triggered when the value of any of the parameters listed above changes.
   *
   * @extends ParameterOwner
   */
  class BaseImage extends ParameterOwner {
      width = 0;
      height = 0;
      format = 'RGB';
      type = 'UNSIGNED_BYTE';
      loaded = false;
      mipMapped = true;
      wrapS = 'REPEAT';
      wrapT = 'REPEAT';
      minFilter = 'LINEAR';
      magFilter = 'LINEAR';
      alphaFromLuminance = false;
      /**
       * Creates an instance of BaseImage.
       * @param name - name of the item
       */
      constructor(name = 'Image') {
          super(name);
          this.on('parameterValueChanged', () => {
              this.emit('updated');
          });
      }
      /**
       * Returns true if loaded.
       * @private
       * @return - Returns a boolean.
       */
      isLoaded() {
          return this.loaded;
      }
      /**
       * Returns all parameters and class state values.
       *
       * @return - The return value.
       */
      getParams() {
          return {
              type: this.type,
              format: this.format,
              width: this.width,
              height: this.height,
              wrapS: this.wrapS,
              wrapT: this.wrapT,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              mipMapped: this.mipMapped,
              alphaFromLuminance: this.alphaFromLuminance,
          };
      }
  }

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * Represents a specific type of parameter, that only stores `BaseImage` values.
   *
   * i.e.:
   * ```javascript
   * // Since `Label` is a `BaseImage` implementation, it helps us with the example.
   * const label = new Label('My awesome label', 'LabelPack')
   * const imageParam = new ImageParameter('MyImage', label)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(imageParam)
   * ```
   *
   * @extends Parameter
   */
  class ImageParameter extends Parameter {
      /**
       * Create an image parameter.
       *
       * @param name - The name of the image parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value) {
          super(name, value, 'BaseImage');
      }
      setValue(value) {
          if (!(value instanceof BaseImage)) {
              throw new Error(`value provided is not an instance of 'BaseImage' class. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = {
              type: this.getClassName(),
              name: this.name,
          };
          if (this.__value) {
              j.imageType = this.__value.getClassName();
              j.value = this.__value.toJSON();
          }
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       * @return - Returns the json object.
       */
      fromJSON(j, context) {
          if (j.imageType) {
              this.__value = Registry.constructClass(j.imageType);
              if (j.value)
                  this.__value?.fromJSON(j.value, context);
          }
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new image parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned image parameter.
       */
      clone() {
          const clonedParam = new ImageParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('ImageParameter', ImageParameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * Represents a specific type of parameter, that only stores Mat4(4x4 matrix) values.
   *
   * i.e.:
   * ```javascript
   * const stringParam = new StringParameter('MyString', 'A String value goes here')
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(stringParam)
   * ```
   *
   * @extends Parameter
   */
  class StringParameter extends Parameter {
      multiLine;
      /**
       * Create a string parameter.
       * @param name - The name of the material color parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value = '') {
          super(name, value, 'String');
          this.multiLine = false;
      }
      /**
       * Sets flag that indicates if the string contains new line feeds.
       *
       * @param multiLine - The multiLine value.
       */
      setMultiLine(multiLine) {
          this.multiLine = multiLine;
      }
      /**
       * Returns multi-line flag value.
       *
       * @return - The return value.
       */
      getMultiLine() {
          return this.multiLine;
      }
      setValue(value) {
          if (typeof value != 'string') {
              throw new Error(`value provided is not a string. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts the string value from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          this.__value = reader.loadStr();
      }
      /**
       * The toJSON method serializes this instance as a JSON.
       * It can be used for persistence, data transfer, etc.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value };
      }
      /**
       * The fromJSON method takes a JSON and deserializes into an instance of this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          const newValue = j.value ?? '';
          if (this.__value != newValue) {
              this.__value = newValue;
              // Note: the BooleanParameter is used in Visiblity
              // If it changes, we listen and update visiility of entire assemblies.
              this.emit('valueChanged');
          }
      }
      /**
       * The clone method constructs a new string parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new string parameter.
       */
      clone() {
          return new StringParameter(this.name, this.__value);
      }
  }
  Registry.register('StringParameter', StringParameter);
  Registry.register('Property_String', StringParameter);

  /**
   * A parameter for storing an array of string values.
   *
   * @extends Parameter
   */
  class StringListParameter extends Parameter {
      /**
       * Create a string parameter.
       * @param {string} name - The name of the material color parameter.
       * @param {string} value - The value of the parameter.
       */
      constructor(name = '', value = []) {
          super(name, value, 'String[]');
      }
      setValue(value) {
          if (!Array.isArray(value)) {
              throw new Error(`value provided is not an array. Check the source of this value`);
          }
          super.setValue(value);
      }
      /**
       * Extracts the string value from a buffer, updating current parameter state.
       *
       * @param {BinReader} reader - The reader value.
       * @param {object} context - The context value.
       */
      readBinary(reader, context) {
          this.__value = reader.loadStrArray();
      }
      /**
       * The toJSON method serializes this instance as a JSON.
       * It can be used for persistence, data transfer, etc.
       *
       * @param {Record<string, unknown>} context - The context value.
       * @return {Record<string, boolean | undefined>} - Returns the json object.
       */
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value };
      }
      /**
       * The fromJSON method takes a JSON and deserializes into an instance of this type.
       *
       * @param {Record<string, boolean | undefined>} j - The json object this item must decode.
       * @param {Record<string, unknown>} context - The context value.
       */
      fromJSON(j, context) {
          this.__value = j.value;
          this.emit('valueChanged');
      }
      /**
       * The clone method constructs a new string parameter, copies its values
       * from this parameter and returns it.
       *
       * @return {StringListParameter} - Returns a new string parameter.
       */
      clone() {
          const clonedParam = new StringListParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('StringListParameter', StringListParameter);
  Registry.register('Property_StringList', StringListParameter);

  /**
   * A parameter for storing an array of string values.
   *
   * @extends Parameter
   */
  class Float32ArrayParameter extends Parameter {
      /**
       * Create a string parameter.
       * @param {string} name - The name of the material color parameter.
       * @param {string} value - The value of the parameter.
       */
      constructor(name = '', value = new Float32Array()) {
          super(name, value, 'Float[]');
      }
      /**
       * Extracts the string value from a buffer, updating current parameter state.
       *
       * @param {BinReader} reader - The reader value.
       * @param {object} context - The context value.
       */
      readBinary(reader, context) {
          this.__value = reader.loadFloat32Array();
      }
      /**
       * The toJSON method serializes this instance as a JSON.
       * It can be used for persistence, data transfer, etc.
       *
       * @param {Record<string, unknown>} context - The context value.
       * @return {Record<string, boolean | undefined>} - Returns the json object.
       */
      toJSON(context) {
          return { type: this.getClassName(), name: this.name, value: this.__value };
      }
      /**
       * The fromJSON method takes a JSON and deserializes into an instance of this type.
       *
       * @param {Record<string, boolean | undefined>} j - The json object this item must decode.
       * @param {Record<string, unknown>} context - The context value.
       */
      fromJSON(j, context) {
          this.__value = j.value;
          this.emit('valueChanged');
      }
      /**
       * The clone method constructs a new string parameter, copies its values
       * from this parameter and returns it.
       *
       * @return {Float32ArrayParameter} - Returns a new string parameter.
       */
      clone() {
          const clonedParam = new Float32ArrayParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('Float32ArrayParameter', Float32ArrayParameter);
  Registry.register('Property_Float32Array', Float32ArrayParameter);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   * A Parameter for storing list(array) values.
   *
   * i.e.:
   * ```javascript
   * const listParam = new ListParameter('MyList', GearParameter)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(listParam)
   * ```
   *
   * **Events**
   * * **valueChanged:** Triggered when setting a value changes in the array(insert, add, remove).
   * * **elementAdded:** Triggered when an element is added to the array(add, insert).
   * * **elementRemoved:** Triggered when an element is removed from the array
   *
   * @extends Parameter
   */
  class ListParameter extends Parameter {
      /**
       * Create a list parameter.
       * @param name - The name of the list parameter.
       * @param dataType - The dataType value.
       */
      constructor(name = '', dataType) {
          super(name, [], dataType);
      }
      /**
       * The filter method.
       * @param item - The item value.
       * @return - The return value.
       *
       * @private
       */
      filter(item) {
          return true;
      }
      /**
       * Returns the count of items in the array.
       *
       * @return - The return value.
       */
      getCount() {
          return this.__value?.length || 0;
      }
      /**
       * Returns value from the array in the specified index.
       *
       * @param index - The index value.
       * @return - The return value.
       */
      getElement(index) {
          if (!this.__value)
              return;
          return this.__value[index];
      }
      /**
       * Sets a value in the specified array's index.
       *
       * @param index - The index value.
       * @param value - The value value.
       */
      setElement(index, value) {
          if (!this.__value)
              this.__value = [];
          this.__value[index] = value;
          this.emit('valueChanged');
      }
      /**
       * Adds a new element at the end of the array pile.
       *
       * @param elem - The elem value.
       * @return - The return value.
       */
      addElement(elem) {
          if ((!elem && elem != 0) || !this.filter(elem))
              return;
          if (!this.__value)
              this.__value = [];
          this.__value.push(elem);
          this.emit('elementAdded', { elem, index: this.__value.length - 1 });
          this.emit('valueChanged');
          return elem;
      }
      /**
       * Removes an array element from the specified index
       *
       * @param index - The index value.
       */
      removeElement(index) {
          if (!this.__value)
              this.__value = [];
          const elem = this.__value[index];
          this.__value.splice(index, 1);
          this.emit('elementRemoved', { elem, index });
          this.emit('valueChanged');
      }
      /**
       * Inserts a new element in the specified index.
       *
       * @param index - The index value.
       * @param elem - The elem value.
       */
      insertElement(index, elem) {
          if (!this.__value || !this.filter(elem))
              return;
          this.__value.splice(index, 0, elem);
          this.emit('elementAdded', { elem, index });
          this.emit('valueChanged');
      }
      setValue(value) {
          if (!Array.isArray(value)) {
              throw new Error(`value provided is not an array. Check the source of this value`);
          }
          super.setValue(value);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const items = [];
          if (this.__value) {
              for (const p of this.__value) {
                  if (typeof this.dataType === 'string')
                      items.push(p);
                  else
                      items.push(p.toJSON(context));
              }
          }
          return {
              type: this.getClassName(),
              name: this.name,
              value: items,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.items == undefined) {
              console.warn('Invalid Parameter JSON');
              return;
          }
          this.__value = [];
          for (let i = 0; i < j.items.length; i++) {
              let elem;
              if (typeof this.dataType === 'string') {
                  elem = j.items[i];
              }
              else {
                  if (!this.dataType)
                      throw 'No DataType';
                  elem = Registry.constructClass(this.dataType);
                  elem.fromJSON(j.items[i], context);
              }
              this.__value.push(elem);
              this.emit('elementAdded', { elem, index: this.__value.length - 1 });
          }
          this.emit('valueChanged');
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new list parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new list parameter.
       */
      clone() {
          const clonedValue = this.__value ? this.__value.slice(0) : [];
          if (!this.dataType)
              throw 'This parameter does not have a DataType';
          const clonedParam = new ListParameter(this.name, this.dataType);
          clonedParam.setValue(clonedValue);
          return clonedParam;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          if (!this.__value)
              return;
          for (let i = 0; i < this.__value.length; i++) {
              if (this.__value[i] instanceof Parameter)
                  this.__value[i].destroy();
              this.removeElement(i);
          }
      }
  }
  Registry.register('ListParameter', ListParameter);

  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  /**
   * Represents a specific type of parameter, that stores multiple parameters in object format.
   *
   * i.e.:
   * ```javascript
   * const structParam = new StructParameter('MyStructParam')
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(structParam)
   * ```
   *
   * **Events**
   * * **valueChanged:** Triggered whenever parameter's value changes.
   *
   * @extends Parameter
   */
  class StructParameter extends Parameter {
      members;
      /**
       * Create a struct parameter.
       * @param name - The name of the struct parameter.
       */
      constructor(name) {
          super(name, {}, 'Struct');
          this.members = [];
      }
      /**
       * The _addMember method.
       * @param parameter - The parameter value.
       * @return - The return value.
       * @private
       */
      addMember(parameter) {
          if (this.__value)
              this.__value[parameter.getName()] = parameter.value;
          parameter.on('valueChanged', () => {
              if (this.__value)
                  this.__value[parameter.getName()] = parameter.value;
          });
          this.members.push(parameter);
          this.emit('valueChanged');
          return parameter;
      }
      /**
       * The getParameter method.
       *
       * @private
       * @param name - The parameter name.
       * @return - The return value.
       */
      getParameter(name) {
          for (const p of this.members) {
              if (p.getName() == name)
                  return p;
          }
          return undefined;
      }
      /**
       * Looks for a member parameter with the specified name and returns it.
       *
       * @param name - The parameter name.
       * @return - The return value.
       */
      getMember(name) {
          return this.getParameter(name);
      }
      /**
       * Returns the name of all parameters in StructParameter.
       *
       * @return - The return value.
       */
      getMemberNames() {
          const names = [];
          for (let i = 0; i < this.members.length; i++) {
              const member = this.members[i];
              if (member != null)
                  names[i] = member.getName();
          }
          return names;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const members = [];
          for (const p of this.members)
              members.push(p.toJSON(context));
          return { type: this.getClassName(), name: this.name, members };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.members == undefined) {
              console.warn('Invalid Parameter JSON');
              return;
          }
          for (let i = 0; i < j.members.length; i++) {
              if (j.members[i]) {
                  this.members[i].fromJSON(j.members[i], context);
              }
          }
          this.name = j.name;
      }
      clone() {
          const clonedParam = new StructParameter(this.name);
          return clonedParam;
      }
      // ////////////////////////////////////////
      // Destroy
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          for (const p of this.members) {
              // TODO: not sure about this. I added a do-nothing destroy method in Parameter<T> to be overwritten
              // since only some subclasses use destroy.
              p.destroy();
          }
      }
  }
  Registry.register('StructParameter', StructParameter);

  /** Class representing an operator output.
   * @extends EventEmitter
   */
  class OperatorOutput extends EventEmitter {
      __name;
      _mode;
      _op = null;
      _param;
      _paramBindIndex;
      detached;
      /**
       * Create an operator output.
       * @param name - The name value.
       * @param operatorOutputMode - The mode which the OperatorOutput uses to bind to its target parameter.
       */
      constructor(name, operatorOutputMode = exports.OperatorOutputMode.OP_WRITE) {
          super();
          this.__name = name;
          this._mode = operatorOutputMode;
          this._param = undefined;
          this._paramBindIndex = -1;
          this.detached = false;
      }
      /**
       * Returns name of the output.
       * @return - The name string.
       */
      getName() {
          return this.__name;
      }
      /**
       * Sets operator that owns this output. Called by the operator when adding outputs
       * @param op - The operator object.
       */
      setOperator(op) {
          this._op = op;
      }
      /**
       * Returns operator that owns this output.
       * @return - The operator object.
       */
      getOperator() {
          return this._op;
      }
      /**
       * Returns mode that the output writes to be parameter. Must be a number from OperatorOutputMode
       * @return - The mode value.
       */
      getMode() {
          return this._mode;
      }
      /**
       * Returns true if this output is connected to a parameter.
       * @return - The return value.
       */
      isConnected() {
          return this._param != undefined;
      }
      /**
       * The getParam method.
       * @return - The return value.
       */
      getParam() {
          return this._param;
      }
      /**
       * Sets the Parameter for this output to write to.
       * @param param - The param value.
       * @param index - The index to bind at in the Parameter.
       */
      setParam(param, index = -1) {
          if (this._param) {
              this._param.unbindOperatorOutput(this);
          }
          this._param = param;
          if (this._param) {
              this._paramBindIndex = this._param.bindOperatorOutput(this, index);
          }
          this.emit('paramSet', { param: this._param });
      }
      /**
       * Returns the index of the binding on the parameter of this OperatorOutput
       * up to date.
       * @return index - The index of the binding on the parameter.
       */
      getParamBindIndex() {
          return this._paramBindIndex;
      }
      /**
       * If bindings change on a Parameter, it will call this method to ensure the output index is
       * up to date.
       * @param index - The index of the binding on the parameter.
       */
      setParamBindIndex(index) {
          this._paramBindIndex = index;
      }
      /**
       * Propagates dirty to the connected parameter.
       */
      setDirty() {
          if (this._param) {
              this._param.setDirty(this._paramBindIndex);
          }
      }
      /**
       * The getValue method.
       * @return - The return value.
       */
      getValue() {
          if (this._param) {
              return this._param.getValueFromOp(this._paramBindIndex);
          }
          else {
              // @ts-expect-error ts-migrate(2554) FIXME: Expected 0-1 arguments, but got 2.
              throw new Error('Cannot call getValue on OperatorOutput that is not connected:', this.__name);
          }
      }
      /**
       * When the value on a Parameter is modified by a user by calling 'setValue,
       * then if any operators are bound, the value of the Parameter cannot be modified
       * directly as it is the result of a computation. Instead, the Parameter calls
       * 'backPropagateValue' on the Operator to cause the Operator to handle propagating
       * the value to one or more of its inputs.
       * to its inputs.
       * @param value - The value param.
       * @return - The modified value.
       */
      backPropagateValue(value) {
          if (this._op) {
              value = this._op.backPropagateValue(value);
          }
          return value;
      }
      /**
       * The setClean method.
       * @param value - The value param.
       */
      setClean(value) {
          if (this._param) {
              this._param.setCleanFromOp(value, this._paramBindIndex);
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const paramPath = this._param ? this._param.getPath() : '';
          return {
              name: this.__name,
              paramPath: context && context.makeRelative ? context.makeRelative(paramPath) : paramPath,
              paramBindIndex: this._paramBindIndex,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.paramPath) {
              // Note: the tree should have fully loaded by the time we are loading operators
              // even new items and groups should have been created. Operators and state machines
              // are loaded last.
              context?.resolvePath(j.paramPath, (param) => {
                  this.setParam(param, j.paramBindIndex);
              }, (reason) => {
                  console.warn("OperatorOutput: '" + this.getName() + "'. Unable to connect to:" + j.paramPath);
              });
          }
      }
      /**
       * The detach method is called when an operator is being removed from the scene tree.
       * It removes all connections to parameters in the scene.
       */
      detach() {
          // This function is called when we want to suspend an operator
          // from functioning because it is deleted and on the undo stack.
          // Once operators have persistent connections,
          // we will simply uninstall the output from the parameter.
          this.detached = true;
          this._paramBindIndex = this._param ? this._param.unbindOperatorOutput(this) : -1;
      }
      /**
       * The reattach method can be called when re-instating an operator in the scene.
       */
      reattach() {
          this.detached = false;
          if (this._param) {
              this._paramBindIndex = this._param.bindOperatorOutput(this, this._paramBindIndex);
          }
      }
      /**
       * The rebind rebinds the outputs to be at the top of the stack for its parameter.
       */
      rebind() {
          if (this._param) {
              this._param.unbindOperatorOutput(this);
              this._paramBindIndex = this._param.bindOperatorOutput(this);
          }
      }
  }
  class BooleanOperatorOutput extends OperatorOutput {
  }
  class NumberOperatorOutput extends OperatorOutput {
  }
  class Vec2OperatorOutput extends OperatorOutput {
  }
  class Vec3OperatorOutput extends OperatorOutput {
  }
  class Vec4OperatorOutput extends OperatorOutput {
  }
  class ColorOperatorOutput extends OperatorOutput {
  }
  class QuatOperatorOutput extends OperatorOutput {
  }
  class XfoOperatorOutput extends OperatorOutput {
  }
  class Mat3OperatorOutput extends OperatorOutput {
  }
  class Mat4OperatorOutput extends OperatorOutput {
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Class representing an operator.
   *
   * @extends ParameterOwner
   */
  class Operator extends ParameterOwner {
      __inputs;
      __outputs;
      /**
       * Create an operator.
       * @param name - The name value.
       */
      constructor(name = '') {
          super(name);
          this.__inputs = new Map();
          this.__outputs = new Map();
      }
      /**
       * This method sets the state of the operator to dirty which propagates
       * to the outputs of this operator, and which may then propagate to other
       * operators. When the scene is cleaned, which usually is caused by rendering
       * then the chain of operators are cleaned by triggering evaluation.
       * @private
       */
      setDirty() {
          this.__outputs.forEach((output) => output.setDirty());
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       *
       * @param event
       * @private
       */
      parameterValueChanged(event) {
          super.parameterValueChanged(event);
          this.setDirty();
      }
      /**
       * The addInput method.
       * @param input - The name of the input, or the input object
       * @return - The return value.
       */
      addInput(input) {
          input.setOperator(this);
          this.__inputs.set(input.getName(), input);
          this.setDirty();
          return input;
      }
      /**
       * The removeInput method.
       * @param input - The name of the input, or the input object
       */
      removeInput(input) {
          if (typeof input == 'string')
              input = this.getInput(input);
          if (input.getParam())
              input.setParam(undefined);
          this.__inputs.delete(input.getName());
      }
      /**
       * Getter for the number of inputs in this operator.
       * @return - Returns the number of inputs.
       */
      getNumInputs() {
          return this.__inputs.size;
      }
      /**
       * The getInputByIndex method.
       * @param index - The index value.
       * @return - The return value.
       */
      getInputByIndex(index) {
          return Array.from(this.__inputs.values())[index];
      }
      /**
       * The getInput method.
       * @param name - The name value.
       * @return - The return value.
       */
      getInput(name) {
          const input = this.__inputs.get(name);
          if (!input)
              throw `Couldn't find an Input with the name of '${name}'`;
          return input;
      }
      /**
       * The addOutput method.
       * @param output - The name of the output, or the output object
       * @return - The return value.
       */
      addOutput(output) {
          output.setOperator(this);
          // if (this.getOutput(output.getName())) throw new Error(`Operator output already exists ${output.getName()}`)
          this.__outputs.set(output.getName(), output);
          this.setDirty();
          return output;
      }
      /**
       * The removeOutput method.
       * @param output - The name of the output, or the output object
       */
      removeOutput(output) {
          if (typeof output == 'string')
              output = this.getOutput(output);
          if (!(output instanceof OperatorOutput)) {
              throw new Error(`removeOutput only accepts string or OperatorInput`);
          }
          if (output.getParam())
              output.setParam();
          this.__outputs.delete(output.getName());
      }
      /**
       * Getter for the number of outputs in this operator.
       * @return - Returns the number of outputs.
       */
      getNumOutputs() {
          return this.__outputs.size;
      }
      /**
       * The getOutputByIndex method.
       * @param index - The index value.
       * @return - The return value.
       */
      getOutputByIndex(index) {
          return Array.from(this.__outputs.values())[index];
      }
      /**
       * The getOutput method.
       * @param name - The name value.
       * @return - The return value.
       */
      getOutput(name) {
          const output = this.__outputs.get(name);
          if (!output)
              throw new Error(`Couldn't find an Output with the name of '${name}'`);
          return output;
      }
      /**
       * The evaluate method.
       * Computes the values of each of the outputs based on the values of the inputs
       * and the values of outputs with mode OP_READ_WRITE.
       * This method must be implemented by all Operators.
       */
      evaluate() {
          throw new Error('Not yet implemented');
      }
      /**
       * When the value on a Parameter is modified by a user by calling 'setValue,
       * then if any operators are bound, the value of the Parameter cannot be modified
       * directly as it is the result of a computation. Instead, the Parameter calls
       * 'backPropagateValue' on the Operator to cause the Operator to handle propagating
       * the value to one or more of its inputs.
       * to its inputs.
       * @param value - The value param.
       * @return - The modified value.
       */
      backPropagateValue(value) {
          // TODO: Implement me for custom manipulations.
          return value;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = super.toJSON(context);
          j.type = this.getClassName();
          const inputs = [];
          this.__inputs.forEach((input) => {
              inputs.push(input.toJSON(context));
          });
          j.inputs = inputs;
          const outputs = [];
          this.__outputs.forEach((output) => {
              outputs.push(output.toJSON(context));
          });
          j.outputs = outputs;
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          super.fromJSON(j, context);
          if (j.inputs) {
              j.inputs.forEach((inputJson, index) => {
                  let input;
                  if (inputJson.name) {
                      input = this.getInput(inputJson.name);
                      if (!input) {
                          input = this.addInput(inputJson.name);
                      }
                  }
                  else {
                      input = this.getInputByIndex(index);
                  }
                  input.fromJSON(inputJson, context);
              });
          }
          if (j.outputs) {
              j.outputs.forEach((outputJson, index) => {
                  let output;
                  if (outputJson.name) {
                      output = this.getOutput(outputJson.name);
                      if (!output) {
                          output = this.addOutput(outputJson.name);
                      }
                  }
                  else {
                      output = this.getOutputByIndex(index);
                  }
                  output.fromJSON(outputJson, context);
              });
          }
      }
      /**
       * The detach method.
       */
      detach() {
          this.__inputs.forEach((input) => input.detach());
          this.__outputs.forEach((output) => output.detach());
      }
      /**
       * The reattach method.
       */
      reattach() {
          this.__inputs.forEach((input) => input.reattach());
          this.__outputs.forEach((output) => output.reattach());
      }
      /**
       * The rebind method.
       */
      rebind() {
          this.__outputs.forEach((output) => output.rebind());
      }
  }

  /** Class representing an operator input.
   * @extends EventEmitter
   */
  class OperatorInput extends EventEmitter {
      name;
      _op;
      param;
      detached = false;
      /**
       * Create an operator input.
       * @param name - The name value.
       */
      constructor(name) {
          super();
          this.name = name;
      }
      /**
       * The getName method.
       * @return - The return value.
       */
      getName() {
          return this.name;
      }
      /**
       * Sets operator that owns this input. Called by the operator when adding inputs
       * @param op - The operator object.
       */
      setOperator(op) {
          this._op = op;
      }
      /**
       * Returns operator that owns this input.
       * @return - The operator object.
       */
      getOperator() {
          return this._op;
      }
      /**
       * Returns true if this input is connected to a parameter.
       * @return - The return value.
       */
      isConnected() {
          return this.param != null;
      }
      /**
       * The getParam method.
       * @return - The return value.
       */
      getParam() {
          return this.param;
      }
      /**
       * @private
       * The handler function for when the input paramter changes.
       * @param event - The event object.
       */
      paramValueChanged() {
          if (this._op)
              this._op.setDirty();
      }
      /**
       * Assigns the Paramter to be used to provide the input value.
       * @param param - The param value.
       */
      setParam(param) {
          if (this.param) {
              this.param.unbindOperatorInput(this);
          }
          this.param = param;
          if (this.param) {
              this.param.bindOperatorInput(this);
          }
          // When an input param is assigned, the op should
          // propagate dirty to its outputs.
          if (this._op)
              this._op.setDirty();
          this.emit('paramSet', { param: this.param });
      }
      /**
       * The getValue method.
       * @return - The return value.
       */
      getValue() {
          if (this.param)
              return this.param.value;
          throw new Error('Unable to getValue');
      }
      /**
       * The setValue method.
       * @param value - The value param.
       */
      setValue(value) {
          if (this.param) {
              this.param.setValue(value);
          }
      }
      /**
       * Propagates from the upstream parameter to the connected operator.
       */
      setDirty() {
          if (this._op) {
              this._op.setDirty();
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const absPath = this.param ? this.param.getPath() : [];
          const paramPath = (context && context.makeRelative ? context.makeRelative(absPath) : absPath);
          return {
              name: this.name,
              paramPath: paramPath,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.paramPath) {
              // Note: the tree should have fully loaded by the time we are loading operators
              // even new items and groups should have been created. Operators and state machines
              // are loaded last.
              context?.resolvePath(j.paramPath, (param) => {
                  this.setParam(param);
              }, () => {
                  console.warn("OperatorInput: '" + this.getName() + "'. Unable to connect to:" + j.paramPath);
              });
          }
      }
      /**
       * The detach method is called when an operator is being removed from the scene tree.
       * It removes all connections to parameters in the scene.
       */
      detach() {
          // This function is called when we want to suspend an operator
          // from functioning because it is deleted and on the undo stack.
          // Once operators have persistent connections,
          // we will simply uninstall the output from the parameter.
          if (this.param) {
              this.param.unbindOperatorInput(this);
          }
      }
      /**
       * The reattach method can be called when re-instating an operator in the scene.
       */
      reattach() {
          this.detached = false;
          if (this.param) {
              this.param.bindOperatorInput(this);
          }
      }
  }
  class BooleanOperatorInput extends OperatorInput {
  }
  class NumberOperatorInput extends OperatorInput {
  }
  class Vec2OperatorInput extends OperatorInput {
  }
  class Vec3OperatorInput extends OperatorInput {
  }
  class Vec4OperatorInput extends OperatorInput {
  }
  class ColorOperatorInput extends OperatorInput {
  }
  class QuatOperatorInput extends OperatorInput {
  }
  class XfoOperatorInput extends OperatorInput {
  }
  class Mat3OperatorInput extends OperatorInput {
  }
  class Mat4OperatorInput extends OperatorInput {
  }

  /** The operator the calculates the global Xfo of a TreeItem based on its parents GlobalXfo and its own LocalXfo
   * @extends Operator
   * @private
   */
  class CalcGlobalXfoOperator extends Operator {
      parentGlobal = new XfoOperatorInput('ParentGlobal');
      localXfo = new XfoOperatorInput('LocalXfo');
      globalXfo = new XfoOperatorOutput('GlobalXfo');
      /**
       * Create a CalcGlobalXfoOperator operator.
       *
       * @param groupGlobalXfoParam - The GlobalXfo param found on the Group.
       * @param cuttingPlaneParam - The parameter on the Group which defines the displacement to apply to the members.
       */
      // TODO: adding new XfoP... to make inheritence work
      constructor(globalXfoParam, localXfoParam) {
          super('CalcGlobalXfoOperator');
          this.localXfo.setParam(localXfoParam);
          this.globalXfo.setParam(globalXfoParam);
          this.addInput(this.parentGlobal);
          this.addInput(this.localXfo);
          this.addOutput(this.globalXfo);
      }
      /**
       * The backPropagateValue method inverts the mathematics of the 'evaluate'
       * method so it can propagate the value backwards to its inputs.
       * @param value - the new value being set on the output GlobalXfo
       */
      backPropagateValue(value) {
          if (this.parentGlobal.isConnected()) {
              const parentGlobalXfo = this.parentGlobal.getValue();
              this.localXfo.setValue(parentGlobalXfo.inverse().multiply(value));
          }
          else {
              this.localXfo.setValue(value);
          }
      }
      /**
       * The evaluate method calculates a new global Xfo based on the parents Global Xfo,
       * and the local Xfo value.
       */
      evaluate() {
          const localXfo = this.localXfo.getValue();
          if (this.parentGlobal.isConnected()) {
              const parentGlobalXfo = this.parentGlobal.getValue();
              this.globalXfo.setClean(parentGlobalXfo.multiply(localXfo));
          }
          else {
              this.globalXfo.setClean(localXfo);
          }
      }
  }
  Registry.register('CalcGlobalXfoOperator', CalcGlobalXfoOperator);

  /**
   * Represents a specific type of parameter, that only stores `Box3` values.
   *
   * i.e.:
   * ```javascript
   * const boundingBox = new BoundingBoxParameter('MyBBox', new TreeItem())
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(boundingBox)
   * ```
   * @extends Parameter
   */
  class BoundingBoxParameter extends Box3Parameter {
      // protected dirty: boolean, value, name
      treeItem;
      dirty = true;
      /**
       * Creates an instance of BoundingBoxParameter.
       * @param name - Name of the parameter
       * @param treeItem - `TreeItem` that contains `Box3` representing the Bounding Box
       */
      constructor(name = '', treeItem) {
          super(name);
          this.treeItem = treeItem;
      }
      /**
       * Makes parameter value be dirty, so when `getValue` is called,
       * an evaluation is then executed to re-calculate the BoundingBox
       *
       * @memberof BoundingBoxParameter
       */
      setDirty(index) {
          if (!this.dirty) {
              this.dirty = true;
              this.emit('valueChanged');
          }
          return true;
      }
      /**
       * Returns bounding box value
       *
       * @return - The return value.
       */
      getValue() {
          if (this.dirty) {
              this.__value = this.treeItem._cleanBoundingBox();
              this.dirty = false;
          }
          return this.__value;
      }
      clone() {
          const bBox3Clone = new BoundingBoxParameter(this.name, this.treeItem);
          bBox3Clone.value = this.__value?.clone();
          return bBox3Clone;
      }
      /**
       * We do not want this parameter serialized.
       */
      isDrivenByOperator() {
          return true;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The loadValue is used to change the value of a parameter, without triggering a
       * valueChanges, or setting the USER_EDITED state.
       *
       * @param value - The context value.
       */
      loadValue(value) {
          this.__value = value.clone();
      }
  }
  Registry.register('BoundingBoxParameter', BoundingBoxParameter);

  /**
   * Class representing an Item in the scene tree with hierarchy capabilities (has children).
   * It has the capability to add and remove children.
   * **Parameters**
   * * **Visible(`BooleanParameter`):** Shows/Hides the item.
   * * **LocalXfo(`XfoParameter`):** Specifies the offset of this tree item from its parent.
   * * **GlobalXfo(`XfoParameter`):** Provides the computed world Xfo of this tree item.
   * * **BoundingBox(`BoundingBox`):** Provides the bounding box for the tree item and all of its children in the 3d scene.
   *
   * **Events**
   * * **globalXfoChanged:** Emitted when the value of GlobalXfo parameter changes.
   * * **visibilityChanged:** Emitted when the visibility on the tree item changes.
   * * **highlightChanged:** Emitted when the highlight on the tree item changes.
   * * **childAdded:** Emitted when a item is added as a child.
   * * **childRemoved:** Emitted when an item is removed from the child nodes.
   * * **pointerDown:** Emitted when a pointerDown event happens in an item.
   * * **pointerUp:** Emitted when a pointerUp event happens in an item.
   * * **pointerMove:** Emitted when a pointerMove event happens in an item.
   * * **pointerEnter:** Emitted when a pointerEnter event happens in an item.
   * * **pointerClick:** Emitted when a pointer is clicked on an item.
   * * **pointerDoubleClick:** Emitted when a pointer is double-clicked on an item.
   * * **pointerLongPress:** Emitted when a pointer is clicked and held on an item for a long time.
   *
   *
   * @extends {ParameterOwner}
   */
  class TreeItem extends ParameterOwner {
      // Controls if this TreeItem or its children contribute to the bounding boxes
      // in the scene. If set to false, Camera framing will ignore this item,
      disableBoundingBox = false;
      __childItems = [];
      __childItemsEventHandlers = [];
      childItemsMapping = {};
      childItemsMappingCorrupt = false;
      /**
       * @member globalXfoParam - Stores the global Xfo for this tree item.
       * global xfos are calculated from the localXfo and parentXfo.
       */
      globalXfoParam = new XfoParameter('GlobalXfo', new Xfo());
      /**
       * @member localXfoParam - Stores the local Xfo for this tree item.
       * local Xfos are the offset from the parent's coordinate frame.
       */
      localXfoParam = new XfoParameter('LocalXfo', new Xfo());
      /**
       * @member boundingBoxParam - Stores the bounding box for this tree item
       */
      boundingBoxParam = new BoundingBoxParameter('BoundingBox', this);
      /**
       * @member visibleParam - Whether this tree item is visible or not.
       * Any given tree item is also is affected by parent's visibility.
       */
      visibleParam = new BooleanParameter('Visible', true);
      /**
       * @member opacityParam - Controls, in combination with Material transparency,
       * the opacity of this item and its children.
       */
      opacityParam = new NumberParameter('Opacity', 1, [0, 1]);
      highlightMapping = {};
      highlights = [];
      __visible = true;
      visibleCounter = 1; // Visible by Default.
      opacity = 1; // Opaque by Default.
      inheritedOpacityValues = new Map();
      globalXfoOp;
      /**
       * Creates a tree item with the specified name.
       *
       * @param name - The name of the tree item. It's the identifier of the tree item.
       * It's an identifier intended to be human readable.
       * It's included in the path that we use to access a particular item.
       * It's used to display it in the tree.
       */
      constructor(name) {
          super(name);
          // /////////////////////////////////////
          // Add parameters.
          this.addParameter(this.visibleParam);
          this.addParameter(this.opacityParam);
          this.addParameter(this.localXfoParam);
          this.addParameter(this.globalXfoParam);
          this.addParameter(this.boundingBoxParam);
          this.globalXfoOp = new CalcGlobalXfoOperator(this.globalXfoParam, this.localXfoParam);
          this.globalXfoParam.on('valueChanged', (event) => {
              this.setBoundingBoxDirty();
              // Note: deprecate this event.
              this.emit('globalXfoChanged', event);
          });
          this.visibleParam.on('valueChanged', () => {
              this.visibleCounter += this.visibleParam.value ? 1 : -1;
              this.updateVisibility();
          });
          this.opacityParam.on('valueChanged', () => {
              this.updateOpacity();
          });
      }
      /**
       * Sets the owner (another TreeItem) of the current TreeItem.
       * @param parentItem - The parent item.
       */
      setOwner(parentItem) {
          if (this.__ownerItem) {
              if (this.__ownerItem instanceof TreeItem) {
                  // The effect of the invisible owner is removed.
                  if (!this.__ownerItem.isVisible())
                      this.visibleCounter++;
                  const index = this.__ownerItem.getChildIndex(this);
                  if (index >= 0)
                      this.__ownerItem.unbindChild(index, this);
              }
          }
          super.setOwner(parentItem);
          if (this.__ownerItem) {
              if (this.__ownerItem instanceof TreeItem) {
                  // The effect of the invisible owner is added.
                  if (!this.__ownerItem.isVisible())
                      this.visibleCounter--;
                  this.globalXfoOp.getInput('ParentGlobal').setParam(this.__ownerItem.globalXfoParam);
              }
          }
          else {
              this.globalXfoOp.getInput('ParentGlobal').setParam(undefined);
          }
          this.updateVisibility();
      }
      /**
       * Returns the parent of current TreeItem.
       *
       * @return - Returns the parent item.
       */
      getParentItem() {
          return this.getOwner();
      }
      /**
       * Sets the parent of current TreeItem.
       *
       * @param parentItem - The parent item.
       */
      setParentItem(parentItem) {
          this.setOwner(parentItem);
      }
      get parent() {
          return this.getOwner();
      }
      set parent(treeItem) {
          this.setOwner(treeItem);
      }
      // ////////////////////////////////////////
      // Visibility
      /**
       * Returns visible parameter value for current TreeItem.
       *
       * @return - The visible param value.
       */
      isVisible() {
          // Should never be more than 1, but can be less than 0.
          return this.visibleCounter > 0;
      }
      /**
       * Sets visible parameter value.
       *
       * @param val - The val param.
       */
      setVisible(visible) {
          this.visibleParam.value = visible;
      }
      /**
       * Updates current TreeItem visible state and propagates its value to children elements.
       *
       * @param val - The val param.
       */
      propagateVisibility(val) {
          this.visibleCounter += val;
          this.updateVisibility();
      }
      /**
       * The updateVisibility method.
       * @return - Returns a boolean.
       */
      updateVisibility() {
          const visible = this.visibleCounter > 0;
          if (visible != this.__visible) {
              this.__visible = visible;
              for (const childItem of this.__childItems) {
                  childItem.propagateVisibility(this.__visible ? 1 : -1);
              }
              this.emit('visibilityChanged', new VisibilityChangedEvent(visible));
              // Note: we used to handle this by listening to a 'valueChanged' event on the
              // parameter.
              if (this.__ownerItem instanceof TreeItem) {
                  this.__ownerItem.setBoundingBoxDirty();
              }
              return true;
          }
          return false;
      }
      // ////////////////////////////////////////
      // Opacity
      /**
       * Returns the current status of the opacity value.
       *
       * @return - Returns true if the opacity value is less than 1.
       */
      isOpaque() {
          return this.opacity > 0.999;
      }
      /**
       * Set the value of opacity inherited by a given tree item.
       */
      setInheritedOpacity(parent, value) {
          this.inheritedOpacityValues.set(parent, value);
          this.updateOpacity();
      }
      /**
       * Calculates the new opacity value based on the opacityParam value
       * and the lowest of the inherited opacity values.
       */
      updateOpacity() {
          let inheritedOpacityValue = 1;
          this.inheritedOpacityValues.forEach((value) => {
              if (value < inheritedOpacityValue)
                  inheritedOpacityValue = value;
          });
          const wasOpaque = this.opacity > 0.999;
          this.opacity = this.opacityParam.value * inheritedOpacityValue;
          // else this.opacity = this.opacityParam.value
          for (const childItem of this.__childItems) {
              childItem.setInheritedOpacity(this, this.opacity);
          }
          const isOpaque = this.opacity > 0.999;
          this.emit('opacityChanged', new OpacityStateChangedEvent(isOpaque, wasOpaque != isOpaque));
      }
      // ////////////////////////////////////////
      // Highlights
      /**
       * Adds a highlight to the tree item.
       *
       * @param name - The name of the tree item.
       * @param color - The color of the highlight.
       * @param propagateToChildren - A boolean indicating whether to propagate to children.
       */
      addHighlight(name, color, propagateToChildren = true) {
          // If the highlight was already in the list,
          // remove it and put it at the top.
          if (name in this.highlightMapping) {
              if (this.highlights[this.highlights.length - 1] != name) {
                  // The highlight was already in the list, but not at the top. Move it to the top.
                  const id = this.highlights.indexOf(name);
                  this.highlights.splice(id, 1);
                  this.highlights.push(name);
                  this.emit('highlightChanged', { name, color });
              }
              else {
                  // This item is already highlighted with this highlight
                  if (!this.highlightMapping[name].isEqual(color)) {
                      this.highlightMapping[name] = color;
                      this.emit('highlightChanged', { name, color });
                  }
              }
          }
          else {
              this.highlights.push(name);
              this.highlightMapping[name] = color;
              this.emit('highlightChanged', { name, color });
          }
          if (propagateToChildren) {
              this.__childItems.forEach((childItem) => {
                  childItem.addHighlight(name, color, propagateToChildren);
              });
          }
      }
      /**
       * Removes a highlight to the tree item.
       *
       * @param name - The name of the tree item.
       * @param propagateToChildren - A boolean indicating whether to propagate to children.
       */
      removeHighlight(name, propagateToChildren = true) {
          if (name in this.highlightMapping) {
              if (this.highlights[this.highlights.length - 1] == name) {
                  this.highlights.pop();
                  delete this.highlightMapping[name];
                  if (this.highlights.length > 0) {
                      const nextName = this.highlights[this.highlights.length - 1];
                      const nextColor = this.highlightMapping[nextName];
                      this.emit('highlightChanged', { name: nextName, color: nextColor });
                  }
                  else {
                      // The last highlight was removed, so emit an event saying we are no longer highlighted.
                      this.emit('highlightChanged');
                  }
              }
              else {
                  // The removed highlight was not the current highlight, so no change needs to be shown.
                  const id = this.highlights.indexOf(name);
                  this.highlights.splice(id, 1);
                  delete this.highlightMapping[name];
              }
              if (propagateToChildren) {
                  this.__childItems.forEach((childItem) => {
                      childItem.removeHighlight(name, propagateToChildren);
                  });
              }
          }
      }
      /**
       * Returns the color of the current highlight.
       *
       * @return - The color value.
       */
      getHighlight() {
          if (this.highlights.length == 0) {
              return null;
          }
          return this.highlightMapping[this.highlights[this.highlights.length - 1]];
      }
      /**
       * Returns the name of the current highlight.
       *
       * @return - The color value.
       */
      getHighlightName() {
          if (this.highlights.length == 0) {
              return null;
          }
          return this.highlights[this.highlights.length - 1];
      }
      /**
       * Returns `true` if this items has a highlight color assigned.
       *
       * @return - `True` if this item is highlighted.
       */
      isHighlighted() {
          return this.highlights.length > 0;
      }
      // ////////////////////////////////////////
      // Bounding Box
      /**
       * The _cleanBoundingBox method.
       * @param bbox - The bounding box value.
       * @return - The return value.
       * @private
       */
      _cleanBoundingBox() {
          const bbox = new Box3();
          this.__childItems.forEach((childItem) => {
              if (childItem.isVisible() && childItem.isSelectable()) {
                  // console.log(" - ", childItem.constructor.name, childItem.getName(), childItem.globalXfoParam.value.sc.x, childItem.getBoundingBox().toString())
                  const box3 = childItem.boundingBoxParam.value;
                  if (box3)
                      bbox.addBox3(box3);
              }
          });
          // console.log(this.getName(), bbox.toString())
          return bbox;
      }
      /**
       * The setBoundingBoxDirty method.
       * @private
       */
      setBoundingBoxDirty() {
          if (this.boundingBoxParam) {
              // Will cause boundingChanged to emit
              this.boundingBoxParam.setDirty(-1);
          }
          // Note: we used to handle this by listening to a 'valueChanged' event on the
          // parameter.
          if (this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.setBoundingBoxDirty();
          }
      }
      // ////////////////////////////////////////
      // Children
      /**
       * Returns children list, but children are not required to have hierarchy structure(`TreeItem`).
       * Meaning that it could be another kind of item than `TreeItem`.
       *
       * i.e. **BaseImage**
       *
       * @return - List of `TreeItem` owned by current TreeItem.
       */
      getChildren() {
          return this.__childItems;
      }
      /**
       * Returns the number of child tree items.
       */
      getNumChildren() {
          return this.__childItems.length;
      }
      /**
       * Returns the number of child tree items.
       */
      get numChildren() {
          return this.__childItems.length;
      }
      /**
       * Apply an index to the name if name exists within this item's children.
       *
       * @param name - The name value.
       * @return - Returns a unique name.
       */
      generateUniqueName(name) {
          while (this.childItemsMapping[name.toLocaleLowerCase()] != undefined) {
              const indexRegexp = /(\d+)$/i;
              const indexMatches = name.match(indexRegexp);
              let newIndex = 1;
              if (indexMatches) {
                  newIndex = parseInt(indexMatches[1]) + 1;
                  name = name.replace(indexRegexp, ''); // remove old index
              }
              name += `${newIndex}`.padStart(2, '0');
          }
          return name;
      }
      /**
       * Updates the internal acceleration structure that speeds up looking up children by name.
       * @param start - The start value.
       * @private
       */
      updateChildNameMapping(start) {
          // If a child has been added or removed from the
          // tree item, we need to update the acceleration structure.
          for (let i = start; i < this.__childItems.length; i++) {
              const name = this.__childItems[i].name.toLocaleLowerCase();
              this.childItemsMapping[name] = i;
          }
      }
      /**
       * When a child's name changed, we update our acceleration structure.
       * @param event - The start value.
       * @private
       */
      childNameChanged(event) {
          // Update the acceleration structure.
          if (this.childItemsMappingCorrupt) {
              this.updateChildNameMapping(0);
              this.childItemsMappingCorrupt = false;
          }
          else {
              const oldName = event.oldName.toLocaleLowerCase();
              const newName = event.newName.toLocaleLowerCase();
              const index = this.childItemsMapping[oldName];
              if (this.childItemsMapping[newName] != undefined)
                  this.childItemsMappingCorrupt = true;
              delete this.childItemsMapping[oldName];
              this.childItemsMapping[newName] = index;
          }
      }
      /**
       * Inserts a child. It accepts all kind of `TreeItem`, not only `TreeItem`.
       *
       * @param childItem - The child TreeItem to insert.
       * @param index - The index to add the child item.
       * @param maintainXfo - Boolean that determines if the Xfo value is maintained.
       * @param fixCollisions - Modify the name of the item to avoid name collisions.
       * If false, an exception wll be thrown instead if a name collision occurs.
       * @return - The index of the child item in this items children array.
       */
      insertChild(childItem, index, maintainXfo = false, fixCollisions = true) {
          let name = childItem.name;
          let nameLc = name.toLocaleLowerCase();
          if (nameLc in this.childItemsMapping) {
              if (fixCollisions) {
                  name = this.generateUniqueName(name);
                  nameLc = name.toLocaleLowerCase();
                  childItem.setName(name);
              }
              else {
                  throw new Error("Item '" + name + "' is already a child of :" + this.getPath());
              }
          }
          if (!(childItem instanceof TreeItem)) {
              throw new Error('Object is is not a tree item :' + childItem); // TODO: need better output here+ childItem.constructor.name)
          }
          const listenerIDs = {};
          listenerIDs['nameChanged'] = childItem.on('nameChanged', (event) => {
              this.childNameChanged(event);
          });
          let prevGlobal;
          if (maintainXfo) {
              prevGlobal = childItem.globalXfoParam.value;
          }
          this.setBoundingBoxDirty();
          this.highlights.forEach((name) => {
              childItem.addHighlight(name, this.highlightMapping[name], true);
          });
          childItem.setInheritedOpacity(this, this.opacity);
          this.__childItems.splice(index, 0, childItem);
          this.__childItemsEventHandlers.splice(index, 0, listenerIDs);
          // If we have non-unique names, we need to regenerate this mapping.
          if (this.childItemsMapping[nameLc])
              this.childItemsMappingCorrupt = true;
          this.childItemsMapping[nameLc] = index;
          this.updateChildNameMapping(index + 1);
          childItem.setOwner(this);
          if (maintainXfo) {
              // Mainain the previous global Xfo.
              childItem.globalXfoParam.value = prevGlobal;
          }
          this.emit('childAdded', new ChildAddedEvent(index, childItem));
          return childItem;
      }
      /**
       * Adds a child.
       *
       * @param childItem - The child TreeItem to add.
       * @param maintainXfo - Boolean that determines if
       * the Global Xfo value is maintained. If true, when moving
       * items in the hierarchy from one parent to another, the local Xfo
       * of the item will be modified to maintain and the Global Xfo.
       * Note: this option defaults to false because we expect that is the
       * behavior users would expect when manipulating the tree in code.
       * To be safe and unambiguous, always try to specify this value.
       * @param fixCollisions - Modify the name of the item to avoid
       * name collisions with other children of the same parent.
       * If false, an exception wll be thrown instead if a name collision occurs.
       * @return childItem - The child TreeItem that was added.
       */
      addChild(childItem, maintainXfo = true, fixCollisions = true) {
          const index = this.__childItems.length;
          this.insertChild(childItem, index, maintainXfo, fixCollisions);
          return childItem;
      }
      /**
       * Returns child element in the specified index.
       *
       * @param index - The index to remove the child TreeItem.
       * @return - Return the child TreeItem.
       */
      getChild(index) {
          return this.__childItems[index];
      }
      /**
       * Returns child element with the specified name.
       *
       * @param name - The name value.
       * @return - Return the child TreeItem.
       */
      getChildByName(name) {
          const index = this.childItemsMapping[name.toLocaleLowerCase()];
          if (index != undefined) {
              return this.__childItems[index];
          }
          return null;
      }
      /**
       * Returns children names as an array of strings.
       *
       * @return - An array of names for each child.
       */
      getChildNames() {
          const names = [];
          for (let i = 0; i < this.__childItems.length; i++) {
              const childItem = this.__childItems[i];
              if (childItem != null)
                  names[i] = childItem.getName();
          }
          return names;
      }
      /**
       * UnBind an item from the group. This method is called
       * automatically when an item is removed from the group.
       * @param index - The index value.
       * @param childItem - item to unbind.
       * @private
       */
      unbindChild(index, childItem) {
          const listenerIDs = this.__childItemsEventHandlers[index];
          childItem.off('nameChanged', listenerIDs['nameChanged']);
          this.__childItems.splice(index, 1);
          this.__childItemsEventHandlers.splice(index, 1);
          delete this.childItemsMapping[childItem.name.toLocaleLowerCase()];
          this.updateChildNameMapping(index);
          this.setBoundingBoxDirty();
          this.emit('childRemoved', { childItem, index });
      }
      /**
       * Removes a child TreeItem by specifying its index.
       *
       * @param index - The index value.
       */
      removeChild(index) {
          const childItem = this.__childItems[index];
          if (!childItem) {
              return;
          }
          this.unbindChild(index, childItem);
          childItem.setOwner(undefined);
      }
      /**
       * Removes a child TreeItem by specifying its name.
       *
       * @param name - The name param.
       * @return - Return the child TreeItem.
       */
      removeChildByName(name) {
          const index = this.childItemsMapping[name.toLocaleLowerCase()];
          if (index != undefined) {
              return this.removeChild(index);
          }
      }
      /**
       * Removes the provided item from this TreeItem if it is one of its children.
       * An exception is thrown if the item is not a child of this tree item.
       *
       * @param childItem - The child TreeItem to remove.
       */
      removeChildByHandle(childItem) {
          const index = this.__childItems.indexOf(childItem);
          if (index == -1)
              throw new Error('Error in removeChildByHandle. Child not found:' + childItem.getName());
          this.removeChild(index);
      }
      /**
       * Removes all children Items.
       */
      removeAllChildren() {
          let index = this.__childItems.length;
          while (index--) {
              this.removeChild(index);
          }
          this.setBoundingBoxDirty();
      }
      /**
       * Returns index position of the specified item.
       *
       * @param childItem - The child TreeItem value.
       * @return - Child index in children array.
       */
      getChildIndex(childItem) {
          return this.__childItems.indexOf(childItem);
      }
      // ////////////////////////////////////////
      // Path Traversal
      // Note: Path resolution starts at the root of the
      // tree the path was generated from (so index=1, because we don't resolve root).
      // Note: When a path is made relative to an item in its tree, the path
      // starts with the child elements.
      /**
       * The resolvePath method traverses the subtree from this item down
       * matching each name in the path with a child until it reaches the
       * end of the path.
       *
       * @param path - The path value.
       * @param index - The index value.
       * @return - The return value.
       */
      resolvePath(path, index = 0) {
          if (index == 0) {
              if (path[0] == '.' || path[0] == this.__name)
                  index++;
          }
          if (path[index] == '..') {
              if (this.__ownerItem) {
                  return this.__ownerItem.resolvePath(path, index + 1);
              }
              else {
                  throw Error('this.__ownerItem is undefined');
              }
          }
          if (index == path.length) {
              return this;
          }
          const childName = path[index];
          const childItem = this.getChildByName(childName);
          if (childItem) {
              return childItem.resolvePath(path, index + 1);
          }
          return super.resolvePath(path, index);
      }
      /**
       * Traverse the tree structure from this point down
       * and fire the callback for each visited item.
       * Note: Depth only used by selection sets for now.
       *
       * @param callback - The callback value.
       * @param includeThis - Fire the callback for this item.
       */
      traverse(callback, includeThis = true) {
          const __c = (treeItem, depth) => {
              const children = treeItem.getChildren();
              for (const childItem of children) {
                  if (childItem)
                      __t(childItem, depth + 1);
              }
          };
          const __t = (treeItem, depth) => {
              if (callback(treeItem, depth) == false)
                  return;
              __c(treeItem, depth);
          };
          if (includeThis) {
              __t(this, 1);
          }
          else {
              __c(this, 0);
          }
      }
      // ///////////////////////
      // Events
      /**
       * Called by the Viewport when events are received by the canvas element.
       * The event is propagated to a TreeItem if it is under the pointer at the time.
       * The ZeaPointerEvent abstracts the Mouse, touch and our custom XR events.
       * This method emits the ZeaPointerEvent with the key 'pointerDown', and
       * propagates it up to the TreeItem's owner.
       *
       * @param event - The event value
       */
      onPointerDown(event) {
          this.emit('pointerDown', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerDown(event);
          }
      }
      /**
       * Called by the Viewport when events are received by the canvas element.
       * The event is propagated to a TreeItem if it is under the pointer at the time.
       * The ZeaPointerEvent abstracts the Mouse, touch and our custom XR events.
       * This method emits the ZeaPointerEvent with the key 'pointerDown', and
       * propagates it up to the TreeItem's owner.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerUp(event) {
          this.emit('pointerUp', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerUp(event);
          }
      }
      /**
       * Called by the Viewport when events are received by the canvas element.
       * The event is propagated to a TreeItem if it is under the pointer at the time.
       * The ZeaPointerEvent abstracts the Mouse, touch and our custom XR events.
       * This method emits the ZeaPointerEvent with the key 'pointerMove', and
       * propagates it up to the TreeItem's owner.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerMove(event) {
          this.emit('pointerMove', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerMove(event);
          }
      }
      /**
       * Called by the Viewport when the mouse or other pointer enters the canvas element.
       * The event is propagated to a TreeItem if it is under the pointer at the time.
       * The ZeaPointerEvent abstracts the Mouse, touch and our custom XR events.
       * This method emits the ZeaPointerEvent with the key 'pointerEnter', and
       * propagates it up to the TreeItem's owner.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerEnter(event) {
          this.emit('pointerEnter', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerEnter(event);
          }
      }
      /**
       * Called by the Viewport when the mouse or other pointer leaves the canvas element.
       * The event is propagated to a TreeItem if it is under the pointer at the time.
       * The ZeaPointerEvent abstracts the Mouse, touch and our custom XR events.
       * This method emits the ZeaPointerEvent with the key 'pointerLeave', and
       * propagates it up to the TreeItem's owner.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerLeave(event) {
          this.emit('pointerLeave', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerLeave(event);
          }
      }
      /**
       * Called by the Viewport when the mouse or other pointer is clicked on this item.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerClick(event) {
          this.emit('pointerClick', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerClick(event);
          }
      }
      /**
       * Called by the Viewport when the mouse or other pointer is double-clicked on this item.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerDoubleClick(event) {
          this.emit('pointerDoubleClick', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerDoubleClick(event);
          }
      }
      /**
       * Called by the Viewport when the mouse or other pointer is double-clicked on this item.
       *
       * @param event - The pointer event that was generated from the user interaction
       */
      onPointerLongPress(event) {
          this.emit('pointerLongPress', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onPointerLongPress(event);
          }
      }
      /**
       * Called by the Viewport when the mouse wheel event is received by the canvas element.
       * Emits the ZeaWheelEvent with the key 'mouseWheel', and Propagates is up to the TreeItem's owner.
       *
       * @param event - The wheel event that occurs.
       */
      onWheel(event) {
          this.emit('mouseWheel', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onWheel(event);
          }
      }
      /**
       * Called by the Viewport when the touch cancel event is received by the canvas element.
       * Emits the ZeaTouchEvent with the key 'touchCancel', and Propagates is up to the TreeItem's owner.
       *
       * @param event - The wheel event that occurs.
       */
      onTouchCancel(event) {
          this.emit('touchCancel', event);
          if (event.propagating && this.__ownerItem instanceof TreeItem) {
              this.__ownerItem.onTouchCancel(event);
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method serializes this instance as a JSON.
       * It can be used for persistence, data transfer, etc.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          let j = super.toJSON(context);
          // Some Items, such as the SliderSceneWidget do not need their children
          // to be saved.
          const childItemsJSON = {};
          for (const childItem of this.__childItems) {
              if (childItem) {
                  const childJSON = childItem.toJSON(context);
                  if (childJSON)
                      childItemsJSON[childItem.getName()] = childJSON;
              }
          }
          if (Object.keys(childItemsJSON).length > 0) {
              if (j) {
                  j.children = childItemsJSON;
              }
              else {
                  j = {
                      name: this.__name,
                      children: childItemsJSON,
                  };
              }
          }
          return j;
      }
      /**
       * The fromJSON method takes a JSON and deserializes into an instance of this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context, onDone) {
          super.fromJSON(j, context);
          // if ('bbox' in j){
          //     let box = new Box3();
          //     box.fromJSON(j.bbox);
          //     this.boundingBoxParam.value = box)
          // }
          if (j.children != null) {
              const childrenJson = j.children;
              if (Array.isArray(childrenJson)) {
                  for (const childJson of childrenJson) {
                      // Note: During loading of asset trees, we have an
                      // existing tree generated by loading a bin data file.
                      let childItem = this.getChildByName(childJson.name);
                      if (childItem) {
                          childItem.fromJSON(childJson, context);
                      }
                      else {
                          if (childJson.type) {
                              childItem = Registry.constructClass(childJson.type);
                              if (childItem) {
                                  // Note: we should load the json first, as it
                                  // may contain the unique name of the item.
                                  childItem.fromJSON(childJson, context);
                                  this.addChild(childItem, false, false);
                              }
                          }
                      }
                  }
              }
              else {
                  // eslint-disable-next-line guard-for-in
                  for (const childName in childrenJson) {
                      const childJson = childrenJson[childName];
                      // Note: During loading of asset trees, we have an
                      // existing tree generated by loading a bin data file.
                      let childItem = this.getChildByName(childName);
                      if (childItem) {
                          childItem.fromJSON(childJson, context);
                      }
                      else if (childJson.type) {
                          childItem = Registry.constructClass(childJson.type);
                          if (childItem) {
                              // Note: we add the child now before loading.
                              // This is because certain items. (e.g. Groups)
                              // Calculate their global Xfo, and use it to modify
                              // the transform of their members.
                              // Note: Groups bind to items in the scene which are
                              // already added as children, and so have global Xfos.
                              // We prefer to add a child after its loaded, because sometimes
                              // In the tree is asset items, who will only toggled as
                              // unloaded once they are loaded(else they are considered inline assets.)
                              childItem.fromJSON(childJson, context);
                              this.addChild(childItem, false, false);
                          }
                      }
                      else ;
                  }
              }
          }
          // if (j.components) {
          //   for (const cj of j.components) {
          //     const component = Registry.constructClass(cj.type ? cj.type : cj.name)
          //     if (component) {
          //       component.fromJSON(cj, context)
          //       this.addComponent(component)
          //     }
          //   }
          // }
      }
      /**
       * Sets state of current Item(Including parameters & children) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          const itemFlags = reader.loadUInt8();
          const visibilityFlag = 1 << 1;
          // Note: XRef loads a visiblity setting for itself when loading in the parent assembly tree,
          // then it loads the zcad file which contains a visibility setting for the CADAssset. This
          // visibility setting would override the XRef. Ideally the zcad file would not store a visiblity
          // setting for the CADAsset, as that should be set by the loading context.
          // Visible is true by default, so only set it to false. This is to work around the above conflict.
          if ((itemFlags & visibilityFlag) == 0)
              this.setVisible(false);
          // Note: to save space, some values are skipped if they are identity values
          const localXfoFlag = 1 << 2;
          const localXfoIndependentScFlag = 1 << 5;
          if (itemFlags & localXfoFlag) {
              const xfo = new Xfo();
              xfo.tr = reader.loadFloat32Vec3();
              xfo.ori = reader.loadFloat32Quat();
              if (itemFlags & localXfoIndependentScFlag) {
                  xfo.sc = reader.loadFloat32Vec3();
              }
              else {
                  const sc = reader.loadFloat32();
                  xfo.sc.set(sc, sc, sc);
              }
              this.localXfoParam.value = xfo;
          }
          const bboxFlag = 1 << 3;
          if (itemFlags & bboxFlag) {
              this.boundingBoxParam.loadValue(new Box3(reader.loadFloat32Vec3(), reader.loadFloat32Vec3()));
          }
          const numChildren = reader.loadUInt32();
          if (numChildren > 0) {
              const toc = reader.loadUInt32Array(numChildren);
              for (let i = 0; i < numChildren; i++) {
                  try {
                      reader.seek(toc[i]); // Reset the pointer to the start of the item data.
                      let childType = reader.loadStr();
                      const childItem = Registry.constructClass(childType);
                      if (!childItem) {
                          const childName = reader.loadStr();
                          console.warn('Unable to construct child:' + childName + ' of type:' + childType);
                          continue;
                      }
                      reader.seek(toc[i]); // Reset the pointer to the start of the item data.
                      childItem.readBinary(reader, context);
                      this.addChild(childItem, false, true);
                  }
                  catch (e) {
                      console.warn('Error loading tree item: ', e);
                  }
              }
          }
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new tree item, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned tree item.
       */
      clone(context) {
          const cloned = new TreeItem('');
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Copies current TreeItem with all its children.
       *
       * @param src - The tree item to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          super.copyFrom(src, context);
          // Note: configure visiblity and opacity before adding children. They will
          // inherit these settings as they are added.
          this.visibleCounter = this.visibleParam.value ? 1 : 0;
          this.updateVisibility();
          this.updateOpacity();
          // Note: If a tree item already had children, we must clear them before adding from the src.
          // An XRef stored in an assembly may contain a cache of its subtree.
          // If the XRef url does resolve to a file, we must clear this cache before loading the actual data.
          this.removeAllChildren();
          src.getChildren().forEach((srcChildItem) => {
              if (srcChildItem)
                  this.addChild(srcChildItem.clone(context), false, false);
          });
      }
  }
  Registry.register('TreeItem', TreeItem);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores `TreeItem` values.
   *
   * i.e.:
   * ```javascript
   * const treeItem = new TreeItem('tree1')
   * const treeItemParam = new TreeItemParameter('MyTreeItem', treeItem)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(treeItemParam)
   * ```
   *
   * **Events**
   * * **treeItemGlobalXfoChanged:** Triggered when computed world Xfo of parameter's `TreeItem` changes.
   * * **valueChanged:** Triggered when parameter's value changes.
   *
   * @extends Parameter
   */
  class TreeItemParameter extends Parameter {
      filterFn;
      owner;
      listenerIDs = {};
      /**
       * Create a tree item parameter.
       * @param name - The name of the tree item parameter.
       * @param filterFn - The filterFn value.
       */
      constructor(name = '', filterFn) {
          super(name, null, 'TreeItem');
          this.owner = new TreeItem(''); // TODO:(review) should this be initialize by arguments or is this ok?
          this.filterFn = filterFn;
      }
      emitTreeItemGlobalXfoChanged(event) {
          this.emit('treeItemGlobalXfoChanged', event);
      }
      /**
       * Sets parameter value's owner `TreeItem`.
       *
       * @param owner - The owner value.
       */
      setOwner(owner) {
          this.owner = owner;
      }
      /**
       * Returns parameter value's owner `TreeItem`.
       *
       * @return - The return value.
       */
      getOwner() {
          return this.owner;
      }
      /**
       * The setFilterFn method.
       * @param filterFn - The filterFn value.
       */
      setFilterFn(filterFn) {
          this.filterFn = filterFn;
      }
      /**
       * The getFilterFn method.
       * @return - The return value.
       */
      getFilterFn() {
          return this.filterFn;
      }
      /**
       * Sets parameter's `TreeItem` value.
       *
       * @param value - The treeItem value
       * @return - The return value.
       */
      setValue(value) {
          if (!(value instanceof TreeItem)) {
              throw new Error(`value provided is not an instance of a 'TreeItem' class. Check the source of this value`);
          }
          // 0 == normal set. 1 = changed via cleaner fn, 2=change by loading/cloning code.
          if (this.filterFn && !this.filterFn(value))
              return;
          if (this.__value !== value) {
              if (this.__value) {
                  this.__value.off('globalXfoChanged', this.listenerIDs['globalXfoChanged']);
              }
              this.__value = value;
              if (this.__value) {
                  this.listenerIDs['globalXfoChanged'] = this.__value.on('globalXfoChanged', (event) => {
                      this.emitTreeItemGlobalXfoChanged(event);
                  });
              }
              this.emit('valueChanged');
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          return {
              type: this.getClassName(),
              name: this.name,
              value: context.makeRelative(this.__value?.getPath()),
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.value == null) {
              console.warn('Invalid Parameter JSON');
              return;
          }
          context.resolvePath(j.value, (treeItem) => {
              this.setValue(treeItem);
          }, () => {
              console.warn('Unable to resolve tree item parameter value:' + j.paramPath);
          });
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new tree item parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new tree item parameter.
       */
      clone(context) {
          const clonedParam = new TreeItemParameter(this.name, this.filterFn);
          if (this.__value)
              clonedParam.setValue(this.__value.clone(context));
          return clonedParam;
      }
  }
  Registry.register('TreeItemParameter', TreeItemParameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  class ItemEvent extends BaseEvent {
      item;
      index;
      constructor(item, index) {
          super();
          this.index = index;
          this.item = item;
      }
  }
  /** Class representing an item set parameter.
   * @extends Parameter
   * @private
   */
  class ItemSetParameter extends Parameter {
      filterFn;
      /**
       * Create an item set parameter.
       * @param name - The name of the item set parameter.
       * @param filterFn - The filterFn value.
       */
      constructor(name = '', filterFn) {
          super(name, new Set(), 'TreeItem');
          this.filterFn = filterFn; // Note: the filter Fn indicates that users will edit the set.
      }
      /**
       * The setFilterFn method.
       * @param filterFn - The filterFn value.
       */
      setFilterFn(filterFn) {
          this.filterFn = filterFn;
      }
      /**
       * The getFilterFn method.
       * @return - The return value.
       */
      getFilterFn() {
          return this.filterFn;
      }
      /**
       * The getItem method.
       * @param index - The index param.
       * @return - The return value.
       */
      getItem(index) {
          // if (!this.__items) return undefined
          return Array.from(this.__value)[index];
      }
      /**
       * The addItem method.
       * @param item - The item value.
       * @param emitValueChanged - The emit value.
       * @return - The return value.
       */
      addItem(item, emitValueChanged = true) {
          if (this.filterFn && !this.filterFn(item)) {
              console.warn('ItemSet __filterFn rejecting item:', item.getPath());
              return;
          }
          if (!this.__value.has(item)) {
              this.__value.add(item);
              const index = Array.from(this.__value).indexOf(item);
              this.emit('itemAdded', new ItemEvent(item, index));
              if (emitValueChanged)
                  this.emit('valueChanged');
              return index;
          }
          else {
              return -1;
          }
      }
      /**
       * Adds items to the parameter value
       *
       * @param items - list of items to add to the parameter
       * @param emitValueChanged
       * @memberof ItemSetParameter
       */
      addItems(items, emitValueChanged = true) {
          items.forEach((item) => this.addItem(item, false));
          if (emitValueChanged)
              this.emit('valueChanged');
      }
      /**
       * The removeItem method.
       * @param index - The index value.
       * @param emitValueChanged - The emit param.
       * @return - The return value.
       */
      removeItem(index, emitValueChanged = true) {
          const item = Array.from(this.__value)[index];
          this.__value.delete(item);
          this.emit('itemRemoved', new ItemEvent(item, index));
          if (emitValueChanged)
              this.emit('valueChanged');
          return item;
      }
      /**
       * The setItems method.
       * @param items - The item param.
       * @param emit - The emit param.
       */
      setItems(items, emit = true) {
          const values = Array.from(this.__value);
          for (let i = values.length - 1; i >= 0; i--) {
              const item = values[i];
              if (!items.has(item)) {
                  this.removeItem(i, false);
              }
          }
          for (const item of items) {
              if (!this.__value.has(item)) {
                  this.addItem(item, false);
              }
          }
          if (emit)
              this.emit('valueChanged');
      }
      /**
       * The clearItems method.
       * @param emit - The emit value.
       */
      clearItems(emitValueChanged = true) {
          this.__value.clear();
          if (emitValueChanged)
              this.emit('valueChanged');
      }
      /**
       * The getNumItems method.
       * @return - The return value.
       */
      getNumItems() {
          return this.__value.size; // might be faster
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       * @param context - The context value.
       * @return - The return value.
       */
      toJSON(context) {
          if (!this.__value)
              this.__value = new Set();
          const paths = [];
          for (const item of this.__value) {
              const path = item.getPath();
              paths.push(context && context.makeRelative ? context.makeRelative(path) : path);
          }
          return {
              type: this.getClassName(),
              name: this.name,
              value: paths,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (!context || !context.resolvePath) {
              throw new Error('Unable to load JSON on a ItemSetParameter without a load context');
          }
          const paths = j.value;
          paths.forEach((path) => {
              context.resolvePath(path, (treeItem) => {
                  this.addItem(treeItem, false);
              }, () => {
                  console.warn("BaseGroup: '" + this.getName() + "'. Unable to load item:" + path);
              });
          });
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a item set new parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new item set parameter.
       */
      clone() {
          const clonedParam = new ItemSetParameter(this.name, this.filterFn);
          return clonedParam;
      }
  }
  Registry.register('ItemSetParameter', ItemSetParameter);

  /**
   * Represents a specific type of parameter, that stores `number` and `BaseImage` texture values.
   *
   * i.e.:
   * ```javascript
   * const image = new LDRImage();
   * image.load("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
   *
   * const numberParam = new MaterialFloatParam('MyMaterialFloat', 15.5)
   * numberParam.setImage(image)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(numberParam)
   * ```
   *
   * * **Events**
   * * **valueChanged:** Triggered every time the Image value changes
   * * **textureDisconnected:** Triggered when Image value is cleaned/removed.
   * * **textureConnected:** Triggered when the Image value is set.
   *
   * @extends NumberParameter
   */
  class MaterialFloatParam extends NumberParameter {
      image;
      /**
       * Create a material float parameter.
       * @param name - The name of the material color parameter.
       * @param value - The value of the parameter.
       * @param range - An array with two numbers. If defined, the parameter value will be clamped.
       */
      constructor(name = '', value, range) {
          super(name, value, range);
      }
      /**
       * Returns `BaseImage` texture of the Material.
       *
       * @return - The return value.
       */
      getImage() {
          return this.image;
      }
      /**
       * Sets `BaseImage` texture value in parameter.
       *
       * @param value - The value value.
       */
      setImage(value) {
          const disconnectImage = () => {
              this.emit('textureDisconnected');
          };
          if (value) {
              if (this.image != undefined && this.image !== value) {
                  disconnectImage();
              }
              this.image = value;
              this.emit('textureConnected');
              this.emit('valueChanged');
          }
          else {
              if (this.image != undefined) {
                  disconnectImage();
                  this.image = undefined;
                  this.emit('textureDisconnected');
              }
          }
      }
      /**
       * Sets `number` or the `BaseImage` texture value in parameter.
       *
       * @param value - The value param.
       */
      setValue(value) {
          if (typeof value != 'number' && !(value instanceof BaseImage)) {
              throw new Error(`value provided is not of type number of an instance of 'BaseImage' class. Check the source of this value`);
          }
          if (value instanceof BaseImage) {
              this.setImage(value);
          }
          else {
              super.setValue(value);
          }
      }
      /**
       * Extracts `number` and `Image` values from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          const textureName = reader.loadStr();
          if (textureName != '') {
              console.log('Load Texture');
              this.setImage(context.assetItem.materialLibrary.getImage(textureName));
          }
      }
      /**
       * The clone method constructs a new material float parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned material float parameter.
       */
      clone() {
          const clonedParam = new MaterialFloatParam(this.name, this.__value, this.range);
          return clonedParam;
      }
  }
  Registry.register('MaterialFloatParam', MaterialFloatParam);

  exports.ColorSpace = void 0;
  (function (ColorSpace) {
      ColorSpace["Gamma"] = "Gamma";
      ColorSpace["Linear"] = "Linear";
  })(exports.ColorSpace || (exports.ColorSpace = {}));
  /**
   * Represents a specific type of parameter, that stores `Color` and `BaseImage` texture values.
   *
   * i.e.:
   * ```javascript
   * const image = new LDRImage();
   * image.load("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
   *
   * const matColorParam = new MaterialColorParam('MyMaterialColor', new Color(0, 254, 2))
   * matColorParam.setImage(image)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(matColorParam)
   * ```
   *
   * **Events**
   * * **valueChanged:** Triggered every time the Image value changes
   * * **textureDisconnected:** Triggered when Image value is cleaned/removed.
   * * **textureConnected:** Triggered when the Image value is set.
   *
   * @extends ColorParameter
   */
  // TODO: should MaterialColorParam have these parameters below? I'm assuming no.
  // class MaterialColorParam extends Parameter {
  //   constructor() {
  //     super()
  //     this.__shaderName = 'StandardSurfaceShader'
  //     this.addParameter('BaseColor', new MaterialColorParam(1.0, 1, 0.5))
  //     this.addParameter('AmbientOcclusion', new MaterialFloatParam(1, [0, 1]))
  //     this.addParameter('Metallic', new MaterialFloatParam(0.5, [0, 1]))
  //     this.addParameter('Reflectance', new NumberParameter(0.5, [0, 1]))
  //     this.addParameter('Normal', new MaterialColorParam(1.0, 1, 0.5))
  //     this.addParameter('EmissiveStrength', new NumberParameter(0.5, [0, 1]))
  //     this.addParameter('Opacity', new MaterialFloatParam(0.5, [0, 1]))
  //   }
  //   get value() : Color {
  //     return this.__value
  //   }
  //   set value() : Color {
  //     return this.__value
  //   }
  // }
  class MaterialColorParam extends ColorParameter {
      listenerIDs = {};
      image;
      // Color values default to gamma space, but when loaded
      // from a file such as zcad or GLTF, we set this value to ColorSpace.Linear
      colorSpace = exports.ColorSpace.Gamma;
      /**
       * Create a material color parameter.
       * @param name - The name of the material color parameter.
       * @param value - The value of the parameter.
       */
      constructor(name, value) {
          super(name, value);
      }
      /**
       * Returns `BaseImage` texture of the Material.
       *
       * @return - The return value.
       */
      getImage() {
          return this.image;
      }
      /**
       * The imageUpdated method.
       * @private
       */
      imageUpdated() {
          this.emit('valueChanged');
      }
      /**
       * Sets `BaseImage` texture value in parameter.
       *
       * @param value - The value param.
       */
      setImage(value) {
          const disconnectImage = () => {
              if (this.image) {
                  this.image.off('updated', this.listenerIDs['updated']);
                  this.image = undefined;
              }
              this.emit('textureDisconnected');
          };
          if (value) {
              if (this.image != undefined && this.image !== value) {
                  disconnectImage();
              }
              this.image = value;
              this.listenerIDs['updated'] = this.image.on('updated', () => {
                  this.imageUpdated();
              });
              this.emit('textureConnected');
              this.emit('valueChanged');
          }
          else {
              if (this.image != undefined) {
                  disconnectImage();
                  this.image = undefined;
                  this.emit('textureDisconnected');
              }
          }
      }
      /**
       * Sets `Color` or the `BaseImage` texture value in parameter.
       *
       * @param value - The value param.
       */
      setValue(value) {
          if (!(value instanceof BaseImage) && !(value instanceof Color)) {
              throw new Error(`value provided is not an instance of a 'Color' or 'BaseImage' class. Check the source of this value`);
          }
          if (value instanceof BaseImage) {
              this.setImage(value);
          }
          else {
              super.setValue(value);
          }
      }
      /**
       * Retrieves `Color` and `Image` values from a buffer, updating current parameter state.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          const textureName = reader.loadStr();
          if (textureName != '') {
              this.setImage(context.assetItem.materialLibrary.getImage(textureName));
          }
          this.colorSpace = exports.ColorSpace.Linear;
      }
      toJSON(context) {
          const j = super.toJSON(context);
          j.colorSpace = this.colorSpace;
          return j;
      }
      fromJSON(j, context) {
          super.fromJSON(j, context);
          this.colorSpace = exports.ColorSpace[j.colorSpace] ?? exports.ColorSpace.Gamma;
      }
      /**
       * The clone method constructs a new material color parameter,
       * copies its values from this parameter and returns it.
       *
       * @return - Returns a new cloned material color parameter.
       */
      clone() {
          const clonedParam = new MaterialColorParam(this.name, this.__value?.clone());
          clonedParam.colorSpace = this.colorSpace;
          return clonedParam;
      }
  }
  Registry.register('MaterialColorParam', MaterialColorParam);

  /* eslint-disable require-jsdoc */
  /**
   * Represents a type of `ParameterOwner` class that holds material configuration.
   * Use this to apply materials to your assets or item parts.
   *
   * **Events**
   * * **shaderNameChanged:** Triggered when the shader's name is set through `setShaderName` method.
   *
   * @extends ParameterOwner
   */
  class Material extends ParameterOwner {
      __isOpaque = true;
      __isTextured = false;
      __shaderName = '';
      libraryIndex = -1;
      /**
       * Create a material
       * @param name - The name of the material.
       * @param shaderName - Shader's class name.
       */
      constructor(name, shaderName) {
          super(name);
          if (shaderName)
              this.setShaderName(shaderName);
      }
      /**
       * Getter for the shader name.
       * @return - Returns the shader name.
       */
      getShaderName() {
          return this.__shaderName;
      }
      /**
       * Sets shader by using the name of the class with the script.
       * It is important that the shader is registered in `Registry`, otherwise it will error.
       * See all classes that extend from `GLShader`.
       *
       * @param shaderName - The shader name.
       */
      setShaderName(shaderName) {
          if (this.__shaderName == shaderName)
              return;
          this.__shaderName = shaderName;
          const shaderClass = Registry.getClassDefinition(shaderName);
          const materialTemplate = shaderClass.getMaterialTemplate();
          if (!materialTemplate)
              throw new Error('Error setting Shader. Material template not registered found:' + shaderName);
          const paramMap = {};
          let i = materialTemplate.getNumParameters();
          while (i--) {
              const srcParam = materialTemplate.getParameterByIndex(i);
              const param = this.getParameter(srcParam.getName());
              if (param) ;
              else {
                  this.addParameter(srcParam.clone());
              }
              paramMap[srcParam.getName()] = true;
          }
          // Remove redundant Params.
          for (const param of this.params) {
              if (!paramMap[param.getName()]) {
                  this.removeParameter(param.getName());
              }
          }
          this.__shaderName = shaderName;
          this.__checkOpacity({});
          const event = new ShaderNameChangedEvent(shaderName);
          this.emit('shaderNameChanged', event);
      }
      /**
       * Remove all textures from Material's parameters.
       */
      removeAllTextures() {
          for (const param of this.params) {
              if (param instanceof MaterialColorParam) {
                  if (param.getImage())
                      param.setImage(null);
              }
              else if (param instanceof MaterialFloatParam) {
                  if (param.getImage())
                      param.setImage(null);
              }
          }
      }
      // /////////////////////////////
      // Parameters
      /**
       * Returns the current path of the item in the tree as an array of names.
       *
       * @return - Returns an array.
       */
      getPath() {
          if (this.__ownerItem == undefined)
              return [this.__name];
          else if (this.__ownerItem instanceof Parameter) {
              return [...this.__ownerItem.getPath(), 'value'];
          }
          else {
              return [...this.__ownerItem.getPath(), this.__name];
          }
      }
      /**
       * Returns all texture parameters in current Material.
       *
       * @return - The return value.
       */
      getParamTextures() {
          const textures = {};
          for (const param of this.params) {
              if (param instanceof MaterialColorParam) {
                  if (param.getImage())
                      textures[param.getName()] = param.getImage();
              }
              else if (param instanceof MaterialFloatParam) {
                  if (param.getImage())
                      textures[param.getName()] = param.getImage();
              }
          }
          return textures;
      }
      /**
       * Checks if the material is transparent by checking the `Opacity` parameter.
       *
       * @return - Returns true if the material is transparent.
       */
      isOpaque() {
          return this.__isOpaque;
      }
      __checkOpacity(event) {
          let isOpaque = true;
          try {
              const shaderClass = this.getShaderClass();
              if (!shaderClass.isOpaque()) {
                  isOpaque = false;
              }
          }
          catch (e) { }
          if (isOpaque) {
              const opacity = this.getParameter('Opacity');
              if (opacity && (opacity.value < 0.99 || (opacity instanceof MaterialFloatParam && opacity.getImage()))) {
                  isOpaque = false;
              }
              else {
                  const baseColorParam = this.getParameter('BaseColor');
                  if (baseColorParam) {
                      if (baseColorParam instanceof MaterialColorParam) {
                          const image = baseColorParam.getImage();
                          if (image && image.format == 'RGBA') {
                              isOpaque = false;
                          }
                      }
                      if (isOpaque && baseColorParam.value) {
                          const color_val = baseColorParam.value;
                          if (color_val.a < 1)
                              isOpaque = false;
                      }
                  }
              }
          }
          if (isOpaque != this.__isOpaque) {
              this.__isOpaque = isOpaque;
              const event = new OpacityStateChangedEvent(isOpaque, true);
              this.emit('opacityChanged', event);
              this.emit('transparencyChanged', event); // For legacy listeners
          }
      }
      /**
       * Checks if the material has a texture applied. The renderer can use this to optimize rendering of non-textured objects
       *
       * @return - Returns true if the material is textured.
       */
      isTextured() {
          return this.__isTextured;
      }
      __checkTextures(event) {
          // console.log('__checkTextures')
          const param = event ? event : {};
          let isTextured = false;
          for (const param of this.params) {
              if (param instanceof MaterialColorParam) {
                  if (param.getImage()) {
                      isTextured = true;
                      break;
                  }
              }
              else if (param instanceof MaterialFloatParam) {
                  if (param.getImage()) {
                      isTextured = true;
                      break;
                  }
              }
          }
          if (isTextured != this.__isTextured) {
              this.__isTextured = isTextured;
              let event = new TexturedChangedEvent(isTextured, param);
              this.emit('texturedChanged', event);
          }
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       * @param event - The event object emitted by the parameter.
       * @private
       */
      parameterValueChanged(event) {
          this.__checkOpacity(event);
          this.__checkTextures(event);
          super.parameterValueChanged(event);
      }
      /**
       * Returns shaders class of current material, if set. Otherwise it returns `undefined`
       *
       * @return - The return value.
       */
      getShaderClass() {
          return Registry.getClassDefinition(this.getShaderName());
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes the current object as a json object.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = super.toJSON(context);
          j.shader = this.__shaderName;
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context = {}) {
          if (!j.shader) {
              console.warn('Invalid Material JSON');
              return;
          }
          this.setShaderName(j.shader);
          super.fromJSON(j, context);
          this.__checkOpacity();
          this.__checkTextures();
      }
      /**
       * Sets state of current Item(Including Shaders and Materials) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          let shaderName = reader.loadStr();
          if (shaderName == 'StandardMaterial') {
              shaderName = 'StandardSurfaceShader';
          }
          if (shaderName == 'TransparentMaterial') {
              shaderName = 'StandardSurfaceShader';
          }
          this.setShaderName(shaderName);
          super.readBinary(reader, context);
          this.__checkOpacity();
          this.__checkTextures();
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new material, copies its values
       * from this material and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new Material('clone', ''); // TODO: what should the arguemnts be here?
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * When a Material is copied, first runs `BaseItem` copyFrom method, then sets shader.
       *
       * @param src - The material to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          this.setShaderName(src.getShaderName());
          super.copyFrom(src, context);
      }
  }
  Registry.register('Material', Material);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Represents a specific type of parameter, that only stores `Material` values.
   *
   * i.e.:
   * ```javascript
   * const material = new Material('itemMaterial', 'SimpleSurfaceShader')
   * material.getParameter('BaseColor').setValue(new Color(89 / 255, 182 / 255, 92 / 255))
   *
   * const materialParam = new MaterialParameter('MyMaterial', material)
   * //'myParameterOwnerItem' is an instance of a 'ParameterOwner' class.
   * // Remember that only 'ParameterOwner' and classes that extend from it can host 'Parameter' objects.
   * myParameterOwnerItem.addParameter(materialParam)
   * ```
   * **Events**
   * * **valueParameterValueChanged:** Triggered when parameter's value changes.
   * * **valueChanged:** Triggered when parameter's value changes, except on cleaning processes.
   *
   * @extends Parameter
   */
  class MaterialParameter extends Parameter {
      listenerIDs = {};
      /**
       * Create a material parameter.
       * @param name - The name of the material parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value = null) {
          super(name, null, 'Material');
          if (value)
              this.setValue(value);
      }
      valueParameterValueChanged(event) {
          this.emit('valueParameterValueChanged', event);
      }
      /**
       * Sets `Material` value of the parameter.
       *
       * @param value - The material value.
       */
      setValue(value) {
          if (value != null && !(value instanceof Material)) {
              throw new Error(`value provided is not an instance of a 'Material' class. Check the source of this value`);
          }
          // 0 == normal set. 1 = changed via cleaner fn, 2 = change by loading/cloning code.
          if (this.__value !== value) {
              if (this.__value) {
                  this.__value.setOwner(null);
                  this.__value.off('parameterValueChanged', this.listenerIDs['parameterValueChanged']);
              }
              this.__value = value;
              if (this.__value) {
                  this.__value.setOwner(this);
                  this.listenerIDs['parameterValueChanged'] = this.__value.on('parameterValueChanged', (event) => {
                      this.valueParameterValueChanged(event);
                  });
              }
              // During the cleaning process, we don't want notifications.
              this.emit('valueChanged');
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The loadValue is used to change the value of a parameter, without triggering a
       * valueChanges.
       *
       * @param value - The context value.
       */
      loadValue(value) {
          if (this.__value) {
              this.__value.setOwner(null);
              this.__value.off('parameterValueChanged', this.listenerIDs['parameterValueChanged']);
          }
          this.__value = value;
          if (this.__value) {
              this.__value.setOwner(this);
              this.listenerIDs['parameterValueChanged'] = this.__value.on('parameterValueChanged', (event) => {
                  this.valueParameterValueChanged(event);
              });
          }
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = {
              type: this.getClassName(),
              name: this.name,
          };
          if (this.__value) {
              if (this.__value.libraryIndex >= 0) {
                  j.libraryIndex = this.__value.libraryIndex;
              }
              else {
                  j.value = this.__value.toJSON(context);
              }
          }
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.libraryIndex != undefined) {
              if (context && context.assetItem) {
                  const materialLibrary = context.assetItem.getMaterialLibrary();
                  const material = materialLibrary.getMaterial(j.libraryIndex);
                  if (material) {
                      this.setValue(material);
                  }
              }
          }
          else if (j.value) {
              if (this.__value && this.__value.getClassName() == j.value.type) {
                  this.__value.fromJSON(j.value);
              }
              else {
                  const material = Registry.constructClass(j.value.type);
                  if (j.value)
                      material.fromJSON(j.value, context);
                  this.setValue(material);
              }
          }
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new material parameter, copies its values
       * from this parameter and returns it.
       *
       * @return - Returns a new material parameter.
       */
      clone() {
          const clonedParam = new MaterialParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('MaterialParameter', MaterialParameter);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  function approxEqual(a, b) {
      for (let i = 0; i < a.length; i++) {
          if (Math.abs(b[i] - a[i]) > 0.001)
              return true;
      }
      return false;
  }
  const resizeArray = (inArray, newSize) => {
      if (inArray instanceof Uint8Array) {
          const newArray = new Uint8Array(newSize);
          newArray.set(inArray);
          return newArray;
      }
      else if (inArray instanceof Int8Array) {
          const newArray = new Int8Array(newSize);
          newArray.set(inArray);
          return newArray;
      }
      else if (inArray instanceof Uint16Array) {
          const newArray = new Uint16Array(newSize);
          newArray.set(inArray);
          return newArray;
      }
      else {
          const newArray = new Float32Array(newSize);
          newArray.set(inArray);
          return newArray;
      }
  };
  class Attribute extends BaseClass {
      dataTypeName;
      stride;
      initValue = Number.NaN;
      normalized;
      data;
      mesh;
      splitValues = [];
      splits = {};
      constructor(dataTypeName, stride, initValue = Number.NaN) {
          super();
          this.dataTypeName = dataTypeName;
          this.stride = stride;
          this.initValue = initValue;
          this.init();
      }
      init() {
          this.data = new Float32Array(0);
          this.initRange(0);
      }
      /**
       * Sets the Mesh reference to the VertexAttribute. This is needed for attributes
       * assigned to meshes, and is used to calculate face vertex indices.
       * > Note: the mesh automatically calls this method when a vertex attribute is assigned.
       *
       * @param mesh - The mesh object
       */
      setMesh(mesh) {
          this.mesh = mesh;
      }
      /**
       * Returns the backing array for this attribute
       *
       * @return - The return value.
       */
      asArray() {
          return this.data;
      }
      /**
       * Returns the name of the math type this attribute stores.
       *
       * @return - The return value.
       */
      getDataTypeName() {
          return this.dataTypeName;
      }
      /**
       * Returns the count of attribute values in the data.
       *
       * @return - The return value.
       */
      getCount() {
          return this.data.length / this.stride;
      }
      /**
       * Returns the count of attribute values in the data.
       *
       * @return - The return value.
       */
      get count() {
          return this.data.length / this.stride;
      }
      /**
       * Sets the count of attribute values in the data.
       *
       * @param size - The size value.
       */
      setCount(count) {
          const prevLength = this.data.length;
          const newLength = count * this.stride;
          if (newLength > prevLength) {
              this.data = resizeArray(this.data, newLength);
              this.initRange(prevLength);
          }
          else if (newLength < prevLength) {
              this.data = this.data.slice(0, newLength);
          }
          else ;
          this.splits = {};
          this.splitValues = [];
      }
      /**
       * Fills up data values with default ones starting from the specified index.
       *
       * @param start - The start value.
       */
      initRange(start) {
          // Initialize the values to invalid values.
          for (let i = start; i < this.data.length; i++) {
              this.data[i] = this.initValue;
          }
      }
      isInitialized(a) {
          for (let i = 0; i < a.length; i++) {
              if (a[i] != this.initValue)
                  return true;
          }
          return false;
      }
      /**
       * Returns the number of elements stored in each `T`.
       *
       * @return - The return value.
       */
      get numElements() {
          return this.stride;
      }
      /**
       * Returns data value of the specified index.
       *
       * @param index - The index value.
       * @return - The return value.
       */
      getFloat32Value(index) {
          return this.data[index];
      }
      /**
       * Sets data value in the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setFloat32Value(index, value) {
          this.data[index] = value;
      }
      /**
       * Sets data values in the specified index.
       */
      getValues(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / this.stride);
          const offset = index * this.stride;
          return this.data.subarray(offset, offset + this.stride);
      }
      /**
       * Sets data values in the specified index.
       */
      setValues(index, values) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / this.stride);
          const offset = index * this.stride;
          this.data.set(values, offset);
      }
      merge(other, xfo = new Xfo()) {
          const prevNumValues = this.data.length;
          const addedValues = other.data.length;
          const newLength = prevNumValues + addedValues;
          const data = new Float32Array(newLength);
          data.set(this.data, 0);
          for (let i = 0; i < addedValues; i++) {
              data[prevNumValues + i] = other.data[i];
          }
          this.data = data;
          this.splitValues = [...this.splitValues, ...other.splitValues];
      }
      // //////////////////////////////////////////////////
      // Face Vertex Values
      /**
       * The getSplits method.
       * @return - The return value.
       */
      getSplits() {
          return this.splits;
      }
      /**
       * Gets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue_array(face, faceVertex) {
          const vertex = this.mesh.getFaceVertexIndex(face, faceVertex);
          if (vertex in this.splits && face in this.splits[vertex]) {
              return this.splitValues[this.splits[vertex][face]];
          }
          return this.data.subarray(vertex * this.stride, (vertex + 1) * this.stride);
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue_array(face, faceVertex, value) {
          const vertex = this.mesh.getFaceVertexIndex(face, faceVertex);
          this.setFaceVertexValue_ByVertexIndex(face, vertex, value);
      }
      /**
       * The setFaceVertexValue_ByVertexIndex method.
       * @param face - The face index.
       * @param vertex - The vertex value.
       * @param value - The value value.
       */
      setFaceVertexValue_ByVertexIndex(face, vertex, value) {
          const currValue = this.data.subarray(vertex * this.stride, (vertex + 1) * this.stride);
          if (!this.isInitialized(currValue)) {
              // the value is uninitialized. Initialize it.
              currValue.set(value);
          }
          else if (approxEqual(currValue, value)) ;
          else {
              // The new value is different from the existing value
              if (vertex in this.splits) {
                  // Now check if any existing splits for this vertex match the value being set.
                  // i.e. for faces around a vertex, there will often be a seam along 2 edges
                  // where the values differ. On each side of the seam, all faces can use the same
                  // value. We should see then only one split value for the vertex.
                  const vertexSplitIds = this.splits[vertex];
                  for (const fid in vertexSplitIds) {
                      const splitId = vertexSplitIds[fid];
                      if (approxEqual(this.splitValues[splitId], value)) {
                          // re-use this split value
                          vertexSplitIds[face] = splitId;
                          return;
                      }
                  }
                  // If a split already exists for this face, re-use it.
                  if (face in this.splits[vertex]) {
                      this.splitValues[this.splits[vertex][face]] = value;
                      return;
                  }
              }
              else {
                  this.splits[vertex] = {};
              }
              this.splits[vertex][face] = this.splitValues.length;
              this.splitValues.push(value);
          }
      }
      /**
       * The setSplitVertexValue method.
       * @param vertex - The vertex value.
       * @param face - The face index.
       * @param value - The value value.
       */
      setSplitVertexValue_array(vertex, face, value) {
          if (!(vertex in this.splits))
              this.splits[vertex] = {};
          if (face in this.splits[vertex]) {
              const currValue = this.splitValues[this.splits[vertex][face]];
              if (approxEqual(currValue, value))
                  return;
              console.warn('Face Vertex Already Split with different value');
          }
          this.splits[vertex][face] = this.splitValues.length;
          this.splitValues.push(value);
      }
      /**
       * The setSplitVertexValues method.
       * @param vertex - The vertex value.
       * @param faceGroup - The faceGroup value.
       * @param value - The value value.
       */
      setSplitVertexValues(vertex, faceGroup, values) {
          if (!(vertex in this.splits))
              this.splits[vertex] = {};
          const splitIndex = this.splitValues.length;
          this.splitValues.push(values);
          for (const face of faceGroup) {
              // if (face in this.splits[vertex]) {
              //     let currValue = this.splitValues[this.splits[vertex][face]];
              //     if (currValue.approxEqual(value))
              //         return;
              //     console.warn("Face Vertex Already Split with different value");
              // }
              this.splits[vertex][face] = splitIndex;
          }
      }
      /**
       * The generateSplitValues method.
       * @param splitIndices - The splitIndices value.
       * @param splitCount - The splitCount value.
       * @return - The return value.
       */
      generateSplitValues(splitIndices, splitCount) {
          if (splitCount == 0)
              return this.data;
          const numUnSplitValues = this.getCount();
          const data = resizeArray(this.data, (numUnSplitValues + splitCount) * this.stride);
          // Now duplicate the split values to generate an attributes array
          // using the shared splits across all attributes.
          // eslint-disable-next-line guard-for-in
          for (const vertex in splitIndices) {
              const faces = splitIndices[vertex];
              // eslint-disable-next-line guard-for-in
              for (const face in faces) {
                  const tgt = numUnSplitValues + faces[face];
                  if (vertex in this.splits && face in this.splits[vertex]) {
                      // this attribute has a split value in its array.
                      // we must use that value...
                      const src = this.splits[vertex][face];
                      const srcArray = this.splitValues[src];
                      for (let i = 0; i < srcArray.length; i++) {
                          data[tgt * this.stride + i] = srcArray[i];
                      }
                  }
                  else {
                      // Copy each scalar value to the new place in the array.
                      const src = parseInt(vertex);
                      for (let e = 0; e < this.stride; e++) {
                          data[tgt * this.stride + e] = this.data[src * this.stride + e];
                      }
                  }
              }
          }
          return data;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          return {
              data: Array.from(this.data),
              dataType: this.dataTypeName,
              length: this.data.length / this.stride,
          };
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       */
      fromJSON(j) {
          const data = j.data;
          for (let i = 0; i < data.length; i++) {
              this.data[i] = data[i];
          }
      }
      /**
       * The loadSplitValues method.
       * @param reader - The reader value.
       */
      loadSplitValues(reader) {
          const splitIndices = reader.loadUInt32Array();
          if (splitIndices.length == 0)
              return;
          let offset = 0;
          let numSplitValues = 0;
          while (true) {
              const vertexId = splitIndices[offset++];
              const numSplits = splitIndices[offset++];
              const splits = {};
              for (let i = 0; i < numSplits; i++) {
                  const faceId = splitIndices[offset++];
                  const splitId = splitIndices[offset++];
                  splits[faceId] = splitId;
                  if (splitId >= numSplitValues)
                      numSplitValues = splitId + 1;
              }
              this.splits[vertexId] = splits;
              if (offset >= splitIndices.length)
                  break;
          }
          const dim = this.stride;
          const splitValues = reader.loadFloat32Array(numSplitValues * dim);
          this.splitValues = [];
          for (let i = 0; i < numSplitValues; i++) {
              const val = splitValues.slice(i * dim, i * dim + dim);
              this.splitValues.push(val);
          }
      }
      /**
       * Returns the string representation of the object's state.
       *
       * @return - The return value.
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }
      // ////////////////////////////////////////
      // Memory
      /**
       * Returns vertex attributes buffers and its count.
       *
       * @return - The return value.
       */
      genBuffer() {
          return {
              values: this.data,
              count: this.getCount(),
              dimension: this.stride,
              dataType: this.dataTypeName,
              normalized: this.normalized,
          };
      }
  }

  /**
   * Class representing an attribute.
   */
  class Vec2Attribute extends Attribute {
      /**
       * Create a Vec2Attribute.
       */
      constructor(dataTypeName = 'Vec2') {
          super(dataTypeName, 2);
          this.normalized = false;
      }
      /**
       * Returns the Vec2 from the specified index.
       *
       * @param index - The index value.
       * @return Vec2 - The return value.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec2(this.data[offset], this.data[offset + 1]);
      }
      /**
       * Sets Vec2 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          this.data.set(value.asArray(), offset);
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec2(array[0], array[1]);
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          this.setFaceVertexValue_array(face, faceVertex, Float32Array.from(value.asArray()));
      }
      /**
       * The setSplitVertexValue method.
       * @param vertex - The vertex value.
       * @param face - The face index.
       * @param value - The value value.
       */
      setSplitVertexValue(vertex, face, value) {
          this.setSplitVertexValue_array(vertex, face, Float32Array.from(value.asArray()));
      }
      merge(other, xfo = new Xfo()) {
          const prevNumValues = this.getCount();
          const addedValues = other.getCount();
          this.setCount(prevNumValues + addedValues);
          for (let i = 0; i < addedValues; i++) {
              this.setValue(prevNumValues + i, other.getValue(i));
          }
          this.splitValues = [...this.splitValues, ...other.splitValues];
      }
  }
  Registry.register('Vec2Attribute', Vec2Attribute);

  const mapIn$2 = (value) => {
      return MathFunctions.encode16BitFloat(value);
  };
  const mapOut$2 = (value) => {
      return MathFunctions.decode16BitFloat(value);
  };
  /**
   * Class representing an attribute.
   */
  class Vec2f16Attribute extends Vec2Attribute {
      /**
       * Create a Vec3f8Attribute.
       */
      constructor() {
          super('Vec2f16');
      }
      init() {
          this.data = new Uint16Array(0);
          this.initRange(0);
      }
      initRange(start) {
          // Initialize the values to invalid values.
          for (let i = start; i < this.data.length; i++) {
              this.data[i] = mapIn$2(Number.NaN);
          }
      }
      isInitialized(a) {
          for (let i = 0; i < a.length; i++) {
              if (Number.isFinite(mapOut$2(a[i])))
                  return true;
          }
          return false;
      }
      /**
       * Returns a copy of the Vec2 value at the specified index.
       *
       * @param index - The index value.
       * @return Vec2 - The value at the specified index.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          return new Vec2(mapOut$2(valueData[0]), mapOut$2(valueData[1]));
      }
      /**
       * Sets Vec2 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          valueData[0] = mapIn$2(value.x);
          valueData[1] = mapIn$2(value.y);
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec2(mapOut$2(array[0]), mapOut$2(array[1]));
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          const valueData = new Uint16Array(2);
          valueData[0] = mapIn$2(value.x);
          valueData[1] = mapIn$2(value.y);
          this.setFaceVertexValue_array(face, faceVertex, valueData);
      }
  }

  class Vec3Ref {
      data;
      constructor(data) {
          this.data = data;
      }
      get x() {
          return this.data[0];
      }
      set x(value) {
          this.data[0] = value;
      }
      get y() {
          return this.data[1];
      }
      set y(value) {
          this.data[1] = value;
      }
      get z() {
          return this.data[2];
      }
      set z(value) {
          this.data[2] = value;
      }
      set(x, y, z) {
          this.data[0] = x;
          this.data[1] = y;
          this.data[2] = z;
      }
  }
  /**
   * Class representing an attribute.
   */
  class Vec3Attribute extends Attribute {
      /**
       * Create a Vec3Attribute.
       */
      constructor(dataTypeName = 'Vec3') {
          super(dataTypeName, 3);
          this.normalized = false;
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @param index - The index value.
       * @return Vec3 - The value at the specified index.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec3(this.data[offset + 0], this.data[offset + 1], this.data[offset + 2]);
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @deprecated - This method will soon be removed.
       * @return Vec3 - The value at the specified index.
       */
      getValueRef(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec3Ref(this.data.subarray(offset, offset + 3));
      }
      /**
       * Sets Vec3 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          this.setValues(index, value.asArray());
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec3(array[0], array[1], array[2]);
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          this.setFaceVertexValue_array(face, faceVertex, Float32Array.from(value.asArray()));
      }
      /**
       * The setSplitVertexValue method.
       * @param vertex - The vertex value.
       * @param face - The face index.
       * @param value - The value value.
       */
      setSplitVertexValue(vertex, face, value) {
          this.setSplitVertexValue_array(vertex, face, Float32Array.from(value.asArray()));
      }
      merge(other, xfo = new Xfo()) {
          const prevNumValues = this.getCount();
          const addedValues = other.getCount();
          // We cached these values before calling 'setCount'.
          // Maybe 'setCount' shoulnd't clear the splits. It seems heavy, but I don't want to change anything.
          // We should just re-write the system without splits anyway.
          // const splitValues = [...this.splitValues, ...other.splitValues]
          // const splits = [...this.splits, ...other.splits]
          this.setCount(prevNumValues + addedValues);
          for (let i = 0; i < addedValues; i++) {
              this.setValue(prevNumValues + i, xfo.transformVec3(other.getValue(i)));
          }
          // this.splitValues = [...this.splitValues, ...other.splitValues]
      }
  }
  Registry.register('Vec3Attribute', Vec3Attribute);

  class Vec3f8Ref {
      data;
      constructor(data) {
          this.data = data;
      }
      get x() {
          return MathFunctions.decode16BitFloat(this.data[0]);
      }
      set x(value) {
          this.data[0] = MathFunctions.encode16BitFloat(value);
      }
      get y() {
          return MathFunctions.decode16BitFloat(this.data[1]);
      }
      set y(value) {
          this.data[1] = MathFunctions.encode16BitFloat(value);
      }
      get z() {
          return MathFunctions.decode16BitFloat(this.data[2]);
      }
      set z(value) {
          this.data[2] = MathFunctions.encode16BitFloat(value);
      }
      set(x, y, z) {
          this.data[0] = MathFunctions.encode16BitFloat(x);
          this.data[1] = MathFunctions.encode16BitFloat(y);
          this.data[2] = MathFunctions.encode16BitFloat(z);
      }
  }
  const mapIn$1 = (value, valueRange) => {
      return MathFunctions.remap(value, valueRange[0], valueRange[1], -127, 127);
  };
  const mapOut$1 = (value, valueRange) => {
      return MathFunctions.remap(value, -127, 127, valueRange[0], valueRange[1]);
  };
  /**
   * Class representing an attribute.
   */
  class Vec3f8Attribute extends Vec3Attribute {
      valueRange;
      /**
       * Create a Vec3f8Attribute.
       */
      constructor(valueRange = [-1, 1]) {
          super('Vec3f8');
          this.valueRange = valueRange;
      }
      init() {
          this.data = new Int8Array(0);
          this.initRange(0);
      }
      initRange(start) {
          // Initialize the values to invalid values.
          for (let i = start; i < this.data.length; i++) {
              this.data[i] = mapIn$1(Number.NaN, this.valueRange);
          }
      }
      isInitialized(a) {
          for (let i = 0; i < a.length; i++) {
              if (Number.isFinite(mapOut$1(a[i], this.valueRange)))
                  return true;
          }
          return false;
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @param index - The index value.
       * @return Vec3 - The value at the specified index.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          return new Vec3(mapOut$1(valueData[0], this.valueRange), mapOut$1(valueData[1], this.valueRange), mapOut$1(valueData[2], this.valueRange));
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @deprecated - This method will soon be removed.
       * @return Vec3 - The value at the specified index.
       */
      getValueRef(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec3f8Ref(this.data.subarray(offset, offset + 3));
      }
      /**
       * Sets Vec3 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          valueData[0] = mapIn$1(value.x, this.valueRange);
          valueData[1] = mapIn$1(value.y, this.valueRange);
          valueData[2] = mapIn$1(value.z, this.valueRange);
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec3(mapOut$1(array[0], this.valueRange), mapOut$1(array[1], this.valueRange), mapOut$1(array[2], this.valueRange));
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          const valueData = new Int8Array(3);
          valueData[0] = mapIn$1(value.x, this.valueRange);
          valueData[1] = mapIn$1(value.y, this.valueRange);
          valueData[2] = mapIn$1(value.z, this.valueRange);
          this.setFaceVertexValue_array(face, faceVertex, valueData);
      }
      /**
       * The setSplitVertexValues method.
       * @param vertex - The vertex value.
       * @param faceGroup - The faceGroup value.
       * @param value - The value value.
       */
      setSplitVertexValues(vertex, faceGroup, values) {
          super.setSplitVertexValues(vertex, faceGroup, values.map((v) => mapIn$1(v, this.valueRange), this.valueRange));
      }
  }

  const mapIn = (value) => {
      return MathFunctions.encode16BitFloat(value);
  };
  const mapOut = (value) => {
      return MathFunctions.decode16BitFloat(value);
  };
  class Vec3f16Ref {
      data;
      constructor(data) {
          this.data = data;
      }
      get x() {
          return mapOut(this.data[0]);
      }
      set x(value) {
          this.data[0] = mapIn(value);
      }
      get y() {
          return mapOut(this.data[1]);
      }
      set y(value) {
          this.data[1] = mapIn(value);
      }
      get z() {
          return mapOut(this.data[2]);
      }
      set z(value) {
          this.data[2] = mapIn(value);
      }
      set(x, y, z) {
          this.data[0] = mapIn(x);
          this.data[1] = mapIn(y);
          this.data[2] = mapIn(z);
      }
  }
  /**
   * Class representing an attribute.
   */
  class Vec3f16Attribute extends Vec3Attribute {
      /**
       * Create a Vec3f8Attribute.
       */
      constructor() {
          super('Vec3f16');
      }
      init() {
          this.data = new Uint16Array(0);
          this.initRange(0);
      }
      initRange(start) {
          // Initialize the values to invalid values.
          for (let i = start; i < this.data.length; i++) {
              this.data[i] = mapIn(Number.NaN);
          }
      }
      isInitialized(a) {
          for (let i = 0; i < a.length; i++) {
              if (Number.isFinite(mapOut(a[i])))
                  return true;
          }
          return false;
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @param index - The index value.
       * @return Vec3 - The value at the specified index.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          return new Vec3(mapOut(valueData[0]), mapOut(valueData[1]), mapOut(valueData[2]));
      }
      /**
       * Returns a copy of the Vec3 value at the specified index.
       *
       * @deprecated - This method will soon be removed.
       * @return Vec3 - The value at the specified index.
       */
      getValueRef(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec3f16Ref(this.data.subarray(offset, offset + 3));
      }
      /**
       * Sets Vec3 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          const valueData = this.data.subarray(offset, offset + this.stride);
          valueData[0] = mapIn(value.x);
          valueData[1] = mapIn(value.y);
          valueData[2] = mapIn(value.z);
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec3(mapOut(array[0]), mapOut(array[1]), mapOut(array[2]));
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          const valueData = new Uint16Array(3);
          valueData[0] = mapIn(value.x);
          valueData[1] = mapIn(value.y);
          valueData[2] = mapIn(value.z);
          this.setFaceVertexValue_array(face, faceVertex, valueData);
      }
      /**
       * The setSplitVertexValues method.
       * @param vertex - The vertex value.
       * @param faceGroup - The faceGroup value.
       * @param value - The value value.
       */
      setSplitVertexValues(vertex, faceGroup, values) {
          super.setSplitVertexValues(vertex, faceGroup, values.map((v) => mapIn(v)));
      }
  }

  /**
   * Class representing an attribute.
   */
  class ColorAttribute extends Attribute {
      /**
       * Create a ColorAttribute.
       */
      constructor() {
          super('Color', 4);
          this.normalized = false;
      }
      /**
       * Returns a copy of the Color value at the specified index.
       *
       * @param index - The index value.
       * @return Color - The return value.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Color(this.data[offset + 0], this.data[offset + 1], this.data[offset + 2], this.data[offset + 3]);
      }
      /**
       * Sets Color at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          this.setValues(index, value.asArray());
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Color(array[0], array[1], array[2], array[3]);
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          this.setFaceVertexValue_array(face, faceVertex, Float32Array.from(value.asArray()));
      }
      /**
       * The setSplitVertexValue method.
       * @param vertex - The vertex value.
       * @param face - The face index.
       * @param value - The value value.
       */
      setSplitVertexValue(vertex, face, value) {
          this.setSplitVertexValue_array(vertex, face, Float32Array.from(value.asArray()));
      }
      merge(other, xfo = new Xfo()) {
          const prevNumValues = this.getCount();
          const addedValues = other.getCount();
          this.setCount(prevNumValues + addedValues);
          for (let i = 0; i < addedValues; i++) {
              this.setValue(prevNumValues + i, other.getValue(i));
          }
          this.splitValues = [...this.splitValues, ...other.splitValues];
      }
  }
  Registry.register('ColorAttribute', ColorAttribute);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  const parse8BitPositionsArray = (range, offset, sclVec, positions_quantized, positionsAttr) => {
      for (let i = range[0]; i < range[1]; i++) {
          const pos = new Vec3(positions_quantized[i * 3 + 0] / 255.0, positions_quantized[i * 3 + 1] / 255.0, positions_quantized[i * 3 + 2] / 255.0);
          pos.multiplyInPlace(sclVec);
          pos.addInPlace(offset);
          positionsAttr.setValue(i, pos);
      }
  };
  const parse16BitPositionsArray = (range, offset, sclVec, positions_quantized, positionsAttr) => {
      for (let i = range[0]; i < range[1]; i++) {
          const pos = new Vec3(positions_quantized[i * 3 + 0] / 65535.0, positions_quantized[i * 3 + 1] / 65535.0, positions_quantized[i * 3 + 2] / 65535.0);
          pos.multiplyInPlace(sclVec);
          pos.addInPlace(offset);
          positionsAttr.setValue(i, pos);
      }
  };
  const parse8BitNormalsArray = (range, offset, sclVec, normals_quantized, normalsAttr) => {
      if (sclVec.isNull())
          sclVec.set(1, 1, 1);
      for (let i = range[0]; i < range[1]; i++) {
          const normal = new Vec3(normals_quantized[i * 3 + 0] / 255.0, normals_quantized[i * 3 + 1] / 255.0, normals_quantized[i * 3 + 2] / 255.0);
          normal.multiplyInPlace(sclVec);
          normal.addInPlace(offset);
          normal.normalizeInPlace();
          normalsAttr.setValue(i, normal);
      }
  };
  const parse8BitTextureCoordsArray = (range, offset, sclVec, texCoords_quantized, texCoordsAttr) => {
      // if (sclVec.isNull())
      //     sclVec.set(1, 1, 1);
      for (let i = range[0]; i < range[1]; i++) {
          const textureCoord = new Vec2(texCoords_quantized[i * 2 + 0] / 255.0, texCoords_quantized[i * 2 + 1] / 255.0);
          textureCoord.multiplyInPlace(sclVec);
          textureCoord.addInPlace(offset);
          texCoordsAttr.setValue(i, textureCoord);
      }
  };
  const parse16BitTextureCoordsArray = (range, offset, sclVec, texCoords_quantized, texCoordsAttr) => {
      // if (sclVec.isNull())
      //     sclVec.set(1, 1, 1);
      for (let i = range[0]; i < range[1]; i++) {
          const textureCoord = new Vec2(texCoords_quantized[i * 2 + 0] / 65535.0, texCoords_quantized[i * 2 + 1] / 65535.0);
          textureCoord.multiplyInPlace(sclVec);
          textureCoord.addInPlace(offset);
          texCoordsAttr.setValue(i, textureCoord);
      }
  };
  /**
   * Represents a base class for 3D geometry items.
   *
   * **Events**
   * * **boundingBoxChanged:** Triggered when the bounding box changes.
   * * **geomDataChanged:** Emitted when the geometry attributes have changed. The topology did not change. The Renderer will upload the new attributes to the GPU.
   * * **geomDataTopologyChanged:** Emitted when the geometry attributes and topology have changed.  The Renderer will upload the new attributes and topology to the GPU.
   *
   * @extends ParameterOwner
   */
  class BaseGeom extends ParameterOwner {
      boundingBox = new Box3();
      boundingBoxDirty = true;
      __metaData = new Map();
      #numVertices = 0;
      __vertexAttributes = new Map();
      debugColor = new Color(1, 0, 0, 1);
      /**
       * Create a base geom.
       */
      constructor() {
          super();
          this.addVertexAttribute('positions', new Vec3f16Attribute());
      }
      /**
       * Returns the current path of the item in the tree as an array of names.
       *
       * @return - Returns an array.
       */
      getPath() {
          if (this.__ownerItem == undefined)
              return [this.__name];
          else if (this.__ownerItem instanceof Parameter) {
              return [...this.__ownerItem.getPath(), 'value'];
          }
          else {
              return [...this.__ownerItem.getPath(), this.__name];
          }
      }
      /**
       * The clear method.
       */
      clear() {
          this.setNumVertices(0);
      }
      /**
       * Adds a new vertex attribute to the geometry.
       *
       * @param name - The name of the vertex attribute.
       * @param dataType - The dataType value. // TODO: is any ok vs. AttrValue | number. Unsure about how dataType is used
       * @return - Returns an attribute.
       */
      addVertexAttribute(name, attr) {
          attr.setCount(this.#numVertices);
          this.__vertexAttributes.set(name, attr);
      }
      /**
       * Checks if the the geometry has an attribute with the specified name.
       *
       * @param name - The name of the vertex attribute.
       * @return - The return value.
       */
      hasVertexAttribute(name) {
          return this.__vertexAttributes.has(name);
      }
      /**
       * Returns vertex attribute with the specified name.
       *
       * @param name - The name of the vertex attribute.
       * @return - The return value.
       */
      getVertexAttribute(name) {
          return this.__vertexAttributes.get(name);
      }
      /**
       * Returns all vertex attributes in an object with their names.
       *
       * @return - The return value.
       */
      getVertexAttributes() {
          const vertexAttributes = {};
          for (const [key, attr] of this.__vertexAttributes.entries())
              vertexAttributes[key] = attr;
          return vertexAttributes;
      }
      /**
       * Returns 'positions' vertex attribute.
       */
      get positions() {
          return this.__vertexAttributes.get('positions');
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      numVertices() {
          return this.#numVertices;
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      getNumVertices() {
          return this.#numVertices;
      }
      /**
       * Sets the number of vertices the geometry has.
       *
       * @param count - The count value.
       */
      setNumVertices(count) {
          this.#numVertices = count;
          // Resizes each of the vertex attributes to match the new count.
          this.__vertexAttributes.forEach((attr) => attr.setCount(this.#numVertices));
          this.setBoundingBoxDirty();
      }
      // ////////////////////////////////////////
      // BoundingBox
      /**
       * Returns the bounding box for geometry.
       * @return - The return value.
       */
      getBoundingBox() {
          if (this.boundingBoxDirty)
              this.updateBoundingBox();
          return this.boundingBox;
      }
      /**
       * The setBoundingBoxDirty method.
       */
      setBoundingBoxDirty() {
          this.boundingBoxDirty = true;
          this.emit('boundingBoxChanged');
      }
      /**
       * The updateBoundingBox method.
       */
      updateBoundingBox() {
          const positions = this.positions;
          const bbox = new Box3();
          if (positions) {
              const numVerts = positions.getCount();
              for (let i = 0; i < numVerts; i++)
                  bbox.addPoint(positions.getValue(i));
          }
          this.boundingBox = bbox;
          this.boundingBoxDirty = false;
      }
      /**
       * Merges a separate geometry into this one. Similar to a 'union' boolean operation.
       * @param other the other geom that will be merged into this one
       * @param xfo the transformation to be applied to the other geom as it is merged in.
       */
      merge(other, xfo = new Xfo()) {
          const prevNumVerts = this.getNumVertices();
          const addedVerts = other.getNumVertices();
          for (const [attrName, attr] of this.__vertexAttributes) {
              const otherAttr = other.getVertexAttribute(attrName);
              if (otherAttr) {
                  if (attrName == 'positions')
                      attr.merge(otherAttr, xfo);
                  else if (attrName == 'normals')
                      attr.merge(otherAttr, new Xfo(new Vec3(), xfo.ori));
              }
          }
          // Note: all the attributes have already been resized, so
          // this is just a final check.
          this.setNumVertices(prevNumVerts + addedVerts);
          this.updateBoundingBox();
      }
      // ////////////////////////////////////////
      // Metadata
      /**
       * Returns metadata value of the specified name.
       *
       * @param key - The key value.
       * @return - The return value.
       */
      getMetadata(key) {
          return this.__metaData.get(key);
      }
      /**
       * Verifies if geometry's metadata contains a value with the specified key.
       *
       * @param key - The key value.
       * @return - The return value.
       */
      hasMetadata(key) {
          return this.__metaData.has(key);
      }
      /**
       * Sets metadata value to the geometry.
       *
       * @param key - The key value.
       * @param metaData - The metaData value.
       */
      setMetadata(key, metaData) {
          this.__metaData.set(key, metaData);
      }
      /**
       * Removes metadata value from the geometry with the specified key.
       *
       * @param key - The key value.
       */
      deleteMetadata(key) {
          this.__metaData.delete(key);
      }
      // ////////////////////////////////////////
      // Memory
      /**
       * Returns vertex attributes buffers and its count.
       * @return - The return value.
       */
      genBuffers(opts) {
          const attrBuffers = {};
          for (const [attrName, attr] of this.__vertexAttributes) {
              attrBuffers[attrName] = attr.genBuffer();
          }
          return {
              numVertices: this.numVertices(),
              attrBuffers,
          };
      }
      /**
       * Once the buffers have been uploaded to the GPU, we are free to release them.
       * The GLGeomLibrary may call this function to let the geometry know it can release any handles.
       */
      freeBuffers() { }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current Geometry(Including Vertices and Bounding Box) using a binary reader object.
       *
       * @param reader - The reader value.
       */
      loadBaseGeomBinary(reader, context) {
          this.name = reader.loadStr();
          const flags = reader.loadUInt8();
          this.debugColor = reader.loadRGBFloat32Color();
          const numVerts = reader.loadUInt32();
          this.boundingBox.set(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
          let normalsAttr;
          let texCoordsAttr;
          if (flags & (1 << 1)) {
              normalsAttr = this.getVertexAttribute('normals');
              if (!normalsAttr) {
                  normalsAttr = new Vec3f8Attribute();
                  this.addVertexAttribute('normals', normalsAttr);
              }
          }
          if (flags & (1 << 2)) {
              texCoordsAttr = this.getVertexAttribute('texCoords');
              if (!texCoordsAttr) {
                  texCoordsAttr = new Vec2f16Attribute();
                  this.addVertexAttribute('texCoords', texCoordsAttr);
              }
          }
          const numClusters = reader.loadUInt32();
          if (numClusters == 0) {
              const positionsAttr = this.positions;
              // From 3.12.0, vertex data is a mix of 16bit and 8 bit quanitization
              // without any k-means clustering.
              // @ts-ignore
              positionsAttr.data = reader.loadUInt16Array(numVerts * 3);
              if (normalsAttr) {
                  // @ts-ignore
                  normalsAttr.data = reader.loadInt8Array(numVerts * 3);
              }
              if (texCoordsAttr) {
                  // @ts-ignore
                  texCoordsAttr.data = reader.loadUInt16Array(numVerts * 2);
              }
              // This should be a no-op in each of the attributes as they already have
              // arrays of the appropriate size..
              this.setNumVertices(numVerts);
          }
          else if (numClusters == 1) {
              // Older zcad files store 32 bit floats. The renderer may convert these to 16bit.
              this.addVertexAttribute('positions', new Vec3Attribute());
              this.setNumVertices(numVerts);
              const positionsAttr = this.positions;
              {
                  const box3 = this.boundingBox;
                  // From 3.9.1, vertex data is a mix of 16bit and 8 bit quanitization
                  if (context.versions['zea-engine'].compare([3, 9, 1]) >= 0) {
                      const positions_quantized = reader.loadUInt16Array(numVerts * 3, false);
                      parse16BitPositionsArray([0, numVerts], box3.p0, box3.diagonal(), positions_quantized, positionsAttr);
                  }
                  else {
                      const positions_quantized = reader.loadUInt8Array(numVerts * 3, false);
                      parse8BitPositionsArray([0, numVerts], box3.p0, box3.diagonal(), positions_quantized, positionsAttr);
                  }
              }
              if (normalsAttr) {
                  const box3 = new Box3(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
                  const normals_quantized = reader.loadUInt8Array(numVerts * 3, false);
                  parse8BitNormalsArray([0, numVerts], box3.p0, box3.diagonal(), normals_quantized, normalsAttr);
                  normalsAttr.loadSplitValues(reader);
              }
              if (texCoordsAttr) {
                  const box2 = new Box2(reader.loadFloat32Vec2(), reader.loadFloat32Vec2());
                  // From 3.9.1, vertex data is a mix of 16bit and 8 bit quanitization
                  if (context.versions['zea-engine'].compare([3, 9, 1]) >= 0) {
                      const texCoords_quantized = reader.loadUInt16Array(numVerts * 2, false);
                      parse16BitTextureCoordsArray([0, numVerts], box2.p0, box2.diagonal(), texCoords_quantized, texCoordsAttr);
                  }
                  else {
                      const texCoords_quantized = reader.loadUInt8Array(numVerts * 2, false);
                      parse8BitTextureCoordsArray([0, numVerts], box2.p0, box2.diagonal(), texCoords_quantized, texCoordsAttr);
                  }
                  texCoordsAttr.loadSplitValues(reader);
              }
          }
          else {
              // Older zcad files store 32 bit floats. The renderer may convert these to 16bit.
              this.addVertexAttribute('positions', new Vec3Attribute());
              this.setNumVertices(numVerts);
              const positionsAttr = this.positions;
              const clusters = [];
              let offset = 0;
              for (let i = 0; i < numClusters; i++) {
                  const count = reader.loadUInt32();
                  const clusterData = {
                      range: [offset, offset + count],
                      bbox: new Box3(reader.loadFloat32Vec3(), reader.loadFloat32Vec3()),
                      normalsRange: new Box3(),
                      texCoordsRange: new Box2(),
                  };
                  if (normalsAttr) {
                      clusterData.normalsRange.set(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
                  }
                  if (texCoordsAttr) {
                      clusterData.texCoordsRange.set(reader.loadFloat32Vec2(), reader.loadFloat32Vec2());
                  }
                  clusters.push(clusterData);
                  offset += count;
              }
              // From 3.9.1, vertex data is a mix of 16bit and 8 bit quanitization
              let positions_quantized;
              if (context.versions['zea-engine'].compare([3, 9, 1]) >= 0) {
                  positions_quantized = reader.loadUInt16Array(numVerts * 3, false);
              }
              else {
                  positions_quantized = reader.loadUInt8Array(numVerts * 3, false);
              }
              let normals_quantized = null;
              let texCoords_quantized = null;
              if (normalsAttr) {
                  normals_quantized = reader.loadUInt8Array(numVerts * 3, false);
              }
              if (texCoordsAttr) {
                  texCoords_quantized = reader.loadUInt8Array(numVerts * 2, false);
              }
              for (let i = 0; i < numClusters; i++) {
                  {
                      const box3 = clusters[i].bbox;
                      // From 3.9.1, vertex data is a mix of 16bit and 8 bit quanitization
                      if (context.versions['zea-engine'].compare([3, 9, 1]) >= 0) {
                          parse16BitPositionsArray(clusters[i].range, box3.p0, box3.diagonal(), positions_quantized, positionsAttr);
                      }
                      else {
                          parse8BitPositionsArray(clusters[i].range, box3.p0, box3.diagonal(), positions_quantized, positionsAttr);
                      }
                  }
                  if (normals_quantized) {
                      const box3 = clusters[i].normalsRange;
                      parse8BitNormalsArray(clusters[i].range, box3.p0, box3.diagonal(), normals_quantized, normalsAttr);
                  }
                  if (texCoords_quantized) {
                      const box2 = clusters[i].texCoordsRange;
                      if (context.versions['zea-engine'].compare([3, 9, 1]) >= 0) {
                          parse16BitTextureCoordsArray([0, numVerts], box2.p0, box2.diagonal(), texCoords_quantized, texCoordsAttr);
                      }
                      else {
                          parse8BitTextureCoordsArray(clusters[i].range, box2.p0, box2.diagonal(), texCoords_quantized, texCoordsAttr);
                      }
                  }
              }
              if (normalsAttr) {
                  normalsAttr.loadSplitValues(reader);
              }
              if (texCoordsAttr) {
                  texCoordsAttr.loadSplitValues(reader);
              }
          }
          // Loading the attributes may have dirtied the bounding box.
          // we konw we already loaded the bbox, so force it to be valid.
          this.boundingBoxDirty = false;
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = super.toJSON(context);
          if (!context || !context.skipTopology) {
              json.numVertices = this.#numVertices || 0;
          }
          const vertexAttributes = {};
          for (const [key, attr] of this.__vertexAttributes.entries()) {
              if (!context || !('skipAttributes' in context) || !context.skipAttributes.includes(key))
                  vertexAttributes[key] = attr.toJSON(context);
          }
          json.vertexAttributes = vertexAttributes;
          return json;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          this.clear();
          super.fromJSON(json, context);
          this.setNumVertices(json.numVertices);
          for (const name in json.vertexAttributes) {
              let attr = this.__vertexAttributes.get(name);
              const attrJSON = json.vertexAttributes[name];
              if (!attr || attr.dataTypeName != attrJSON.dataType) {
                  switch (attrJSON.dataType) {
                      case 'Vec2':
                          attr = new Vec2Attribute();
                          break;
                      case 'Vec2f16':
                          attr = new Vec2f16Attribute();
                          break;
                      case 'Vec3':
                          attr = new Vec3Attribute();
                          break;
                      case 'Vec3f16':
                          attr = new Vec3f16Attribute();
                          break;
                      case 'Vec3f8':
                          attr = new Vec3f8Attribute();
                          break;
                      case 'Color':
                          attr = new ColorAttribute();
                          break;
                      default:
                          throw 'Invalid Vectex Type: ' + attr.dataTypeName;
                  }
                  attr.setCount(this.#numVertices);
                  this.addVertexAttribute(name, attr);
              }
              if (attr) {
                  attr.fromJSON(attrJSON);
              }
              else {
                  console.warn('attr undefined, cannot execute fromJSON()');
              }
          }
          this.emit('geomDataTopologyChanged');
      }
      /**
       * Returns geometry data value in json format.
       *
       * @return - The return value.
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }
  }

  /**
   * Class representing an attribute.
   */
  class Vec4Attribute extends Attribute {
      /**
       * Create a Vec4Attribute.
       */
      constructor() {
          super('Vec4', 4);
          this.normalized = false;
      }
      /**
       * Returns a copy of the Vec4 value at the specified index.
       *
       * @param index - The index value.
       * @return Vec4 - The value at the specified index.
       */
      getValue(index) {
          if (index >= this.data.length / this.stride)
              throw new Error('Invalid vertex index:' + index + '. Num Vertices:' + this.data.length / 3);
          const offset = index * this.stride;
          return new Vec4(this.data[offset + 0], this.data[offset + 1], this.data[offset + 2], this.data[offset + 3]);
      }
      /**
       * Sets Vec4 at the specified index.
       *
       * @param index - The index value.
       * @param value - The value param.
       */
      setValue(index, value) {
          this.setValues(index, value.asArray());
      }
      /**
       * Gets the value of a corner vertex of a face.
       * > Note: 'Ref' means that the value contains a reference to the data in the attribute.
       * > The components of the value can be changed causing the attributes data is changed.
       * > No need to call 'setFaceVertexValue'.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @return - The return value.
       */
      getFaceVertexValue(face, faceVertex) {
          const array = this.getFaceVertexValue_array(face, faceVertex);
          return new Vec4(array[0], array[1], array[2], array[3]);
      }
      /**
       * Sets the value of a corner vertex of a face.
       * @param face - The face index.
       * @param faceVertex - The index of vertex within the face. [0... num face vertices]
       * @param value - The value value.
       */
      setFaceVertexValue(face, faceVertex, value) {
          this.setFaceVertexValue_array(face, faceVertex, Float32Array.from(value.asArray()));
      }
      /**
       * The setSplitVertexValue method.
       * @param vertex - The vertex value.
       * @param face - The face index.
       * @param value - The value value.
       */
      setSplitVertexValue(vertex, face, value) {
          this.setSplitVertexValue_array(vertex, face, Float32Array.from(value.asArray()));
      }
      merge(other, xfo = new Xfo()) {
          const prevNumValues = this.getCount();
          const addedValues = other.getCount();
          this.setCount(prevNumValues + addedValues);
          for (let i = 0; i < addedValues; i++) {
              this.setValue(prevNumValues + i, other.getValue(i));
          }
          this.splitValues = [...this.splitValues, ...other.splitValues];
      }
  }
  Registry.register('Vec4Attribute', Vec4Attribute);

  /**
   * Class representing a point primitive drawing type, every vertex specified is a point.
   *
   * ```
   * const points = new Points()
   * ```
   *
   * * **Events**
   * * **boundingBoxChanged:** Triggered when the bounding box changes.
   *
   * @extends BaseGeom
   */
  class Points extends BaseGeom {
      /**
       * Create points.
       */
      constructor() {
          super();
      }
      /**
       * The clear method.
       */
      clear() {
          this.setNumVertices(0);
          this.emit('geomDataTopologyChanged');
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current geometry(Including line segments) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.loadBaseGeomBinary(reader, context);
          // this.computeVertexNormals();
          this.emit('geomDataChanged');
      }
  }
  Registry.register('Points', Points);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  class ImageArrayParameter extends Parameter {
      constructor(name = '', value = []) {
          super(name, value, 'BaseImage[]');
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = {
              type: this.getClassName(),
              name: this.name,
              images: this.__value.map((image) => {
                  return {
                      imageType: image?.getClassName(),
                      value: image?.toJSON(),
                  };
              }),
          };
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       * @return - Returns the json object.
       */
      fromJSON(j, context) {
          if (j.images) {
              const images = j.images;
              this.__value = images.map((imageJson) => {
                  const image = Registry.constructClass(imageJson.imageType);
                  if (image && imageJson.value)
                      image.fromJSON(imageJson.value, context);
                  return image;
              });
          }
      }
      clone() {
          const clonedParam = new ImageArrayParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('ImageArrayParameter', ImageArrayParameter);

  /**
   * @extends Points
   */
  class FatPoints extends Points {
      sprites = new ImageArrayParameter('Sprites');
      /**
       * Create points.
       */
      constructor() {
          super();
          this.addVertexAttribute('sizes', new Attribute('Float32', 1, 1));
          this.addVertexAttribute('colors', new ColorAttribute());
          this.addVertexAttribute('spriteIndices', new Attribute('Float32', 1, -1));
          this.addParameter(this.sprites);
      }
  }
  Registry.register('FatPoints', FatPoints);

  /* eslint-disable @typescript-eslint/no-unused-vars */
  /**
   *
   * Class representing lines primitive drawing type, connecting vertices using the specified indices.
   * i.e. We have 4 points(vertices) but we don't know how they connect to each other,
   * and that's why we need indices(Numbers indicating which vertex connects to which).
   * In this case if we say that `indices` is `[0,1,2,3]`, it would connect the first vertex to the second,
   * and the third to the fourth.
   *
   * ```
   * const lines = new Lines()
   * ```
   *
   * **Events**
   * * **geomDataChanged:** Triggered when the data value of the geometry is set(This includes reading binary)
   *
   * @extends BaseGeom
   */
  class Lines extends BaseGeom {
      __indices;
      /**
       * Create lines.
       */
      constructor() {
          super();
          this.__indices = new Uint32Array();
      }
      /**
       * The clear method.
       */
      clear() {
          this.setNumSegments(0);
          this.setNumVertices(0);
          this.emit('geomDataTopologyChanged');
      }
      /**
       * Returns the specified indices(Vertex connectors)
       *
       * @return - The indices index array.
       */
      getIndices() {
          return this.__indices;
      }
      /**
       * Returns the number of line segments.
       *
       * @return - Returns the number of segments.
       */
      getNumSegments() {
          return this.__indices.length / 2;
      }
      /**
       * Returns the number of line segments.
       *
       * @return - Returns the number of segments.
       */
      getNumLineSegments() {
          return this.__indices.length / 2;
      }
      /**
       * Sets the number of line segments in the lines geometry.
       * **Important:** It resets indices values.
       *
       * @param numOfSegments - The count value.
       */
      setNumSegments(numOfSegments) {
          if (numOfSegments > this.getNumSegments()) {
              const indices = new Uint32Array(numOfSegments * 2);
              indices.set(this.__indices);
              this.__indices = indices;
          }
          else {
              this.__indices = this.__indices.slice(0, numOfSegments * 2);
          }
      }
      /**
       * Sets segment values in the specified index.
       *
       * @param index - The index value.
       * @param p0 - The p0 value.
       * @param p1 - The p1 value.
       */
      setSegmentVertexIndices(index, p0, p1) {
          if (index >= this.__indices.length / 2)
              throw new Error('Invalid line index:' + index + '. Num Segments:' + this.__indices.length / 2);
          this.__indices[index * 2 + 0] = p0;
          this.__indices[index * 2 + 1] = p1;
      }
      /**
       * The getSegmentVertexIndex method.
       *
       * @param line - The line value.
       * @param lineVertex - The lineVertex value.
       * @return - The return value.
       * @private
       */
      getSegmentVertexIndex(line, lineVertex) {
          const numSegments = this.getNumSegments();
          if (line < numSegments)
              return this.__indices[line * 2 + lineVertex];
          return -1;
      }
      /**
       * Merges a separate geometry into this one. Similar to a 'union' boolean operation.
       * @param other the other geom that will be merged into this one
       * @param xfo the transformation to be applied to the other geom as it is merged in.
       */
      merge(other, xfo = new Xfo()) {
          const prevNumVerts = this.getNumVertices();
          super.merge(other, xfo);
          const otheIndices = other.__indices;
          const indices = new Uint32Array(this.__indices.length + otheIndices.length);
          indices.set(this.__indices, 0);
          indices.set(otheIndices.map((index) => index + prevNumVerts), this.__indices.length);
          this.__indices = indices;
      }
      // ////////////////////////////////////////
      // Memory
      /**
       * Returns vertex attributes buffers and its count.
       *
       * @return - The return value.
       */
      genBuffers(opts) {
          const buffers = super.genBuffers();
          let indices;
          if (buffers.numVertices < Math.pow(2, 8)) {
              indices = new Uint8Array(this.__indices);
          }
          else if (buffers.numVertices < Math.pow(2, 16)) {
              indices = new Uint16Array(this.__indices);
          }
          else {
              indices = this.__indices;
          }
          buffers.indices = indices;
          return buffers;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current geometry(Including line segments) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.loadBaseGeomBinary(reader, context);
          this.setNumSegments(reader.loadUInt32());
          const bytes = reader.loadUInt8();
          if (bytes == 1)
              this.__indices = reader.loadUInt8Array();
          else if (bytes == 2)
              this.__indices = reader.loadUInt16Array();
          else if (bytes == 4)
              this.__indices = reader.loadUInt32Array();
          this.emit('geomDataChanged');
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = super.toJSON(context);
          if (!context || !context.skipTopology)
              j.indices = Array.from(this.__indices);
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          super.fromJSON(j, context);
          if (j.indices)
              this.__indices = Uint32Array.from(j.indices);
      }
  }
  Registry.register('Lines', Lines);

  /* eslint-disable prefer-rest-params */
  /**
   * The Mesh class provides a flexible and fast polygon mesh representation. It supports polygons of arbitrary complexity,
   * from basic triangles and quads to pentagons more.
   * It supports storing per face attributes, and per edge attributes.
   * The Mesh class handles converting its internal representation of polygons into a simpler triangles representation for rendering.
   *
   * ```
   * const mesh = new Mesh()
   * ```
   *
   * **Events**
   * * **geomDataTopologyChanged:** Triggered when the topology of the mesh has been changed.
   * * **geomDataChanged:** Triggered when the vertices of the mesh have changed, but not necessarily the topology.
   *
   * @extends BaseGeom
   */
  class Mesh extends BaseGeom {
      faceCounts;
      faceVertexIndices;
      __logTopologyWarnings;
      __edgeAttributes;
      __faceAttributes;
      numEdges;
      edgeVerts;
      edgeAngles;
      edgeVecs;
      edgeFaces;
      faceEdges;
      vertexEdges;
      /**
       * Creates an instance of Mesh.
       */
      constructor() {
          super();
          this.edgeFaces = [];
          this.faceEdges = [[]];
          this.faceCounts = [];
          this.faceVertexIndices = new Uint32Array();
          this.__logTopologyWarnings = false;
          this.__edgeAttributes = new Map();
          this.__faceAttributes = new Map();
          this.numEdges = 0;
          this.edgeVerts = [];
          this.vertexEdges = [];
          this.edgeAngles = new Float32Array();
          this.edgeVecs = [];
      }
      /**
       * The clear method.
       */
      clear() {
          super.clear();
          //this.init()
          //this.setNumVertices(0)
          // clear edge and face normals.
          this.edgeVerts = [];
          this.vertexEdges = [];
          this.numEdges = 0;
          this.edgeAngles = new Float32Array();
          this.emit('geomDataTopologyChanged');
      }
      /**
       * Adds a new vertex attribute to the geometry.
       *
       * @param name - The name of the vertex attribute.
       * @param attr - The attribute to add to the geometry
       */
      addVertexAttribute(name, attr) {
          super.addVertexAttribute(name, attr);
          attr.setMesh(this);
      }
      /**
       * The getFaceCounts method.
       * @return - The return value.
       */
      getFaceCounts() {
          return this.faceCounts;
      }
      /**
       * The getNumFaces method.
       * @return - The return value.
       */
      getNumFaces() {
          return this.faceCounts.length == 0 ? 0 : this.faceCounts.reduce((numFaces, fc) => (numFaces += fc));
      }
      /**
       * The getNumTriangles method.
       * @return {number} - The return value.
       */
      getNumTriangles() {
          let numTriangles = 0;
          let numTrisPerFace = 1;
          for (const fc of this.faceCounts) {
              numTriangles += fc * numTrisPerFace;
              numTrisPerFace++;
          }
          return numTriangles;
      }
      /**
       * Sets the number of faces on the mesh using an array specifying the counts per polygon size.
       * The first item in the array specifies the number of triangles, the second, the number of quads, the 3rd, the number of 5 sided polygons etc..
       * e.g. to specify 2 triangles, and 7 quads, we would pass [2, 7]
       * @param faceCounts - The faceCounts value.
       */
      setFaceCounts(faceCounts) {
          // let numFaces = 0
          let numFacesVertices = 0;
          let numVertsPerFace = 3;
          for (const fc of faceCounts) {
              // numFaces += fc
              numFacesVertices += fc * numVertsPerFace;
              numVertsPerFace++;
          }
          const prevNumFaces = this.getNumFaces();
          if (prevNumFaces == 0) {
              this.faceVertexIndices = new Uint32Array(numFacesVertices);
          }
          else {
              const faceVertexIndices = new Uint32Array(numFacesVertices);
              // Now we preserve the existing indices if they fit within the new faceVertexIndices array.
              let startSrc = 0;
              let startTgt = 0;
              numFacesVertices = 0;
              numVertsPerFace = 3;
              faceCounts.forEach((fc, index) => {
                  const endSrc = startSrc + Math.min(fc, this.faceCounts[index]) * numVertsPerFace;
                  faceVertexIndices.set(this.faceVertexIndices.slice(startSrc, endSrc), startTgt);
                  startSrc += this.faceCounts[index] * numVertsPerFace;
                  startTgt += fc * numVertsPerFace;
                  numVertsPerFace++;
              });
              this.faceVertexIndices = faceVertexIndices;
          }
          this.faceCounts = faceCounts;
      }
      /**
       * Returns the number of face vertices
       * @return - The return value.
       */
      getNumFaceVertices() {
          let numFaceVerts = 0;
          this.faceCounts.forEach((fc, index) => {
              numFaceVerts += fc * (index + 3);
          });
          return numFaceVerts;
      }
      /**
       * Returns the number of vertices indexed by this face
       * @param faceIndex - The faceIndex value.
       * @return - The return value.
       */
      getFaceVertexCount(faceIndex) {
          let idx = 0;
          let count = 0;
          this.faceCounts.some((fc, index) => {
              idx += fc;
              if (idx > faceIndex) {
                  count = index + 3;
                  return true;
              }
              return false;
          });
          return count;
      }
      getFaceVertexOffset(faceIndex) {
          let idx = 0;
          let offset = 0;
          this.faceCounts.some((fc, index) => {
              if (idx + fc > faceIndex) {
                  offset += (faceIndex - idx) * (index + 3);
                  return true;
              }
              idx += fc;
              offset += fc * (index + 3);
              return false;
          });
          return offset;
      }
      /**
       * The setFaceVertexIndices method.
       * @param faceIndex - The faceIndex value.
       * @param vertexIndices - The array of vertex indices for this face value.
       */
      setFaceVertexIndices(faceIndex, vertexIndices) {
          const faceVertexCount = this.getFaceVertexCount(faceIndex);
          if (vertexIndices.length != faceVertexCount) {
              throw new Error(`Invalid indices for face:${faceIndex} vertexIndices:${vertexIndices}. Expected ${faceVertexCount} indices`);
          }
          const offset = this.getFaceVertexOffset(faceIndex);
          this.faceVertexIndices.set(vertexIndices, offset);
      }
      /**
       * Adds a new face to the mesh
       * @param vertexIndices - The vertex indices of the face.
       * @return - The index of the face in the mesh.
       */
      addFace(vertexIndices) {
          const faceCounts = [...this.faceCounts];
          if (faceCounts.length <= vertexIndices.length - 3) {
              for (let i = faceCounts.length; i < vertexIndices.length - 3; i++)
                  faceCounts[i] = 0;
              faceCounts[vertexIndices.length - 3] = 1;
          }
          else {
              faceCounts[vertexIndices.length - 3]++;
          }
          this.setFaceCounts(faceCounts);
          // Calculate the offset in the faceVertexIndices of this new face.
          let faceIndex = 0;
          let offset = 0;
          this.faceCounts.some((fc, index) => {
              if (index + 3 == vertexIndices.length) {
                  faceIndex += fc - 1;
                  offset += (fc - 1) * (index + 3);
                  return true;
              }
              faceIndex += fc;
              offset += fc * (index + 3);
              return false;
          });
          this.faceVertexIndices.set(vertexIndices, offset);
          return faceIndex;
      }
      /**
       * Returns the vertex indices of the specified face.
       * @param faceIndex - The index of the specified face
       * @return - An array of indices into the vertex attributes
       */
      getFaceVertexIndices(faceIndex) {
          const vertexIndices = [];
          const offset = this.getFaceVertexOffset(faceIndex);
          const count = this.getFaceVertexCount(faceIndex);
          for (let i = 0; i < count; i++) {
              vertexIndices.push(this.faceVertexIndices[offset + i]);
          }
          return vertexIndices;
      }
      /**
       * Returns a single vertex index for a given face and faceVertex.
       * @param faceIndex - The faceIndex value.
       * @param faceVertex - The face vertex is the index within the face. So the first vertex index is 0.
       * @return - The vertex index
       */
      getFaceVertexIndex(faceIndex, faceVertex) {
          const offset = this.getFaceVertexOffset(faceIndex);
          return this.faceVertexIndices[offset + faceVertex];
      }
      // ///////////////////////////
      // Face Attributes
      /**
       * The addFaceAttribute method.
       * @param name - The name of the face attribute to add.
       * @param attr - The attr value
       */
      addFaceAttribute(name, attr) {
          attr.setCount(this.getNumFaces());
          this.__faceAttributes.set(name, attr);
          return attr;
      }
      /**
       * The hasFaceAttribute method.
       * @param name - The name of the face attribute.
       * @return - The return value.
       */
      hasFaceAttribute(name) {
          return this.__faceAttributes.has(name);
      }
      /**
       * The getFaceAttribute method.
       * @param name - The name of the face attribute.
       * @return - The return value.
       */
      getFaceAttribute(name) {
          return this.__faceAttributes.get(name);
      }
      // /////////////////////////
      // Edge Attributes
      /**
       * The addEdgeAttribute method.
       * @param name - The name of the edge attribute to add.
       * @param attr - The attr value
       */
      addEdgeAttribute(name, attr) {
          attr.setCount(this.numEdges);
          this.__edgeAttributes.set(name, attr);
      }
      /**
       * The hasEdgeAttribute method.
       * @param name - The name of the edge attribute.
       * @return - The return value.
       */
      hasEdgeAttribute(name) {
          return this.__edgeAttributes.has(name);
      }
      /**
       * The getEdgeAttribute method.
       * @param name - The name of the edge attribute.
       * @return - The return value.
       */
      getEdgeAttribute(name) {
          return this.__edgeAttributes.get(name);
      }
      // ///////////////////////////
      /**
       * The genTopologyInfo method.
       */
      genTopologyInfo() {
          let connectedVertices = {}; // acceleration structure.
          this.vertexEdges = []; // 2d array of vertex to edges.
          // this.vertexFaces = []; // 2d array of vertex to faces.
          this.edgeFaces = []; // flat array of 2 face indices per edge
          this.edgeVerts = []; // flat array of 2 vert indices per edge
          this.faceEdges = []; // the edges bordering each face.
          this.numEdges = 0;
          const positions = this.positions;
          const getEdgeIndex = (v0, v1) => {
              let tmp0 = v0;
              let tmp1 = v1;
              if (tmp1 < tmp0) {
                  const tmp = tmp0;
                  tmp0 = tmp1;
                  tmp1 = tmp;
              }
              const key = tmp0 + '>' + tmp1;
              if (key in connectedVertices) {
                  // console.log(key + ':' + connectedVertices[key] + " face:" + ( v0 < v1 ? 0 : 1) );
                  return connectedVertices[key];
              }
              const p0 = positions.getValue(tmp0);
              const p1 = positions.getValue(tmp1);
              const edgeVec = p1.subtract(p0);
              const edgeIndex = this.edgeFaces.length / 2;
              const edgeData = {
                  edgeIndex: edgeIndex,
                  edgeVec: edgeVec,
              };
              connectedVertices[key] = edgeData;
              this.edgeFaces.push(-1);
              this.edgeFaces.push(-1);
              this.edgeVerts.push(tmp0);
              this.edgeVerts.push(tmp1);
              // console.log(key + ':' + connectedVertices[key] + " face:" + ( v0 < v1 ? 0 : 1));
              this.numEdges++;
              return edgeData;
          };
          const addEdge = (v0, v1, faceIndex) => {
              // console.log('addEdge:' + v0 + " :" + v1 + " faceIndex:" + faceIndex );
              const edgeData = getEdgeIndex(v0, v1);
              const edgeIndex = edgeData.edgeIndex;
              if (v1 < v0) {
                  const edgeFaceIndex = edgeIndex * 2 + 0;
                  if (this.__logTopologyWarnings && this.edgeFaces[edgeFaceIndex] != -1)
                      console.warn('Edge poly 0 already set. Mesh is non-manifold.');
                  this.edgeFaces[edgeFaceIndex] = faceIndex;
              }
              else {
                  const edgeFaceIndex = edgeIndex * 2 + 1;
                  if (this.__logTopologyWarnings && this.edgeFaces[edgeFaceIndex] != -1)
                      console.warn('Edge poly 1 already set. Mesh is non-manifold.');
                  this.edgeFaces[edgeFaceIndex] = faceIndex;
              }
              if (!(faceIndex in this.faceEdges))
                  this.faceEdges[faceIndex] = [];
              this.faceEdges[faceIndex].push(edgeIndex);
              // Push the edge index onto both vertex edge lists.
              // We use Sets to avoid adding the same edge 2x to the same vertex.
              if (this.vertexEdges[v0] == undefined) {
                  this.vertexEdges[v0] = new Set();
              }
              if (this.vertexEdges[v1] == undefined) {
                  this.vertexEdges[v1] = new Set();
              }
              this.vertexEdges[v0].add(edgeIndex);
              this.vertexEdges[v1].add(edgeIndex);
              // if (this.vertexFaces[v0] == undefined) {
              //     this.vertexFaces[v0] = [];
              // }
              // this.vertexFaces[v0].push(faceIndex);
          };
          const numFaces = this.getNumFaces();
          for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
              const faceVerts = this.getFaceVertexIndices(faceIndex);
              for (let j = 0; j < faceVerts.length; j++) {
                  const v0 = faceVerts[j];
                  const v1 = faceVerts[(j + 1) % faceVerts.length];
                  addEdge(v0, v1, faceIndex);
              }
          }
      }
      /**
       * Computes a normal value per face by averaging the triangle normals of the face.
       */
      computeFaceNormals() {
          const positions = this.positions;
          const faceNormals = new Vec3f8Attribute();
          this.addFaceAttribute('normals', faceNormals);
          const numFaces = this.getNumFaces();
          for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
              const faceVerts = this.getFaceVertexIndices(faceIndex);
              const p0 = positions.getValue(faceVerts[0]);
              const p1 = positions.getValue(faceVerts[1]);
              let prev = p1;
              const faceNormal = new Vec3();
              for (let j = 2; j < faceVerts.length; j++) {
                  const pn = positions.getValue(faceVerts[j]);
                  const v0 = prev.subtract(p0);
                  const v1 = pn.subtract(p0);
                  faceNormal.addInPlace(v0.cross(v1).normalize());
                  prev = pn;
              }
              if (faceNormal.lengthSquared() < Number.EPSILON) ;
              else {
                  faceNormals.setValue(faceIndex, faceNormal.normalize());
              }
          }
      }
      /**
       * Calculates the angles at each edge between the adjoining faces
       */
      calculateEdgeAngles() {
          if (this.vertexEdges.length == 0)
              this.genTopologyInfo();
          this.computeFaceNormals();
          const positions = this.positions;
          const faceNormals = this.getFaceAttribute('normals');
          this.edgeVecs = [];
          this.edgeAngles = new Float32Array(this.numEdges);
          for (let i = 0; i < this.edgeFaces.length; i += 2) {
              const v0 = this.edgeVerts[i];
              const v1 = this.edgeVerts[i + 1];
              const edgeVec = positions.getValue(v1).subtract(positions.getValue(v0));
              edgeVec.normalizeInPlace();
              this.edgeVecs.push(edgeVec);
              const p0 = this.edgeFaces[i];
              const p1 = this.edgeFaces[i + 1];
              if (p0 == -1 || p1 == -1) {
                  // Flag the edge as a border edge....
                  this.edgeAngles[i / 2] = Math.PI * 2.0;
                  continue;
              }
              const n0 = faceNormals.getValue(p0);
              const n1 = faceNormals.getValue(p1);
              this.edgeAngles[i / 2] = n0.angleTo(n1);
          }
      }
      /**
       * Compute vertex normals.
       * @param hardAngle - The hardAngle value in radians.
       * @return - The return value.
       */
      computeVertexNormals(hardAngle = 1.0 /* radians */) {
          this.calculateEdgeAngles();
          const faceNormals = this.getFaceAttribute('normals');
          const normalsAttr = new Vec3f8Attribute();
          this.addVertexAttribute('normals', normalsAttr);
          // these methods are faster versions than using the methods
          // provided on the attributes. We cache values and use hard coded constants.
          // const faceNormalsBuffer = faceNormals.data.buffer
          const getFaceNormal = (index) => {
              return faceNormals.getValue(index);
          };
          const setVertexNormal = (index, value) => {
              normalsAttr.setValue(index, value);
          };
          const getConnectedEdgeVecs = (faceIndex, vertexIndex) => {
              let e0;
              let e1;
              const faceEdges = this.faceEdges[faceIndex];
              for (const e of faceEdges) {
                  if (this.edgeVerts[e * 2] == vertexIndex) {
                      if (!e0)
                          e0 = this.edgeVecs[e];
                      else
                          e1 = this.edgeVecs[e];
                  }
                  else if (this.edgeVerts[e * 2 + 1] == vertexIndex) {
                      if (!e0)
                          e0 = this.edgeVecs[e];
                      else
                          e1 = this.edgeVecs[e];
                  }
              }
              return [e0, e1];
          };
          for (let i = 0; i < this.vertexEdges.length; i++) {
              // If this face indexing doesn't start at 0, then the vertexEdges don't either.
              if (this.vertexEdges[i] == undefined)
                  continue;
              const edges = this.vertexEdges[i];
              // Groups of faces having a smooth normal at the current vertex.
              const faceGroups = [];
              const addFaceToGroup = (face) => {
                  let inGroup = false;
                  for (const faceGroup of faceGroups) {
                      inGroup = faceGroup.includes(face);
                      if (inGroup)
                          break;
                  }
                  if (!inGroup)
                      faceGroups.push([face]);
              };
              for (const e of edges) {
                  const f0 = this.edgeFaces[e * 2];
                  const f1 = this.edgeFaces[e * 2 + 1];
                  if (f0 != -1 && f1 != -1 && this.edgeAngles[e] < hardAngle) {
                      // if (f0 != -1 && f1 == -1 && this.edgeAngles[e] < hardAngle) {
                      let f0groupIndex = -1;
                      let f1groupIndex = -1;
                      for (let groupIndex = 0; groupIndex < faceGroups.length; groupIndex++) {
                          if (f0groupIndex == -1 && faceGroups[groupIndex].includes(f0))
                              f0groupIndex = groupIndex;
                          if (f1groupIndex == -1 && faceGroups[groupIndex].includes(f1))
                              f1groupIndex = groupIndex;
                      }
                      if (f0groupIndex == -1 && f1groupIndex == -1) {
                          faceGroups.push([f0, f1]);
                      }
                      else if (f0groupIndex != -1 && f1groupIndex != -1) {
                          if (f0groupIndex != f1groupIndex) {
                              // Merge the 2 groups that the smooth edge joins.
                              faceGroups[f0groupIndex] = faceGroups[f0groupIndex].concat(faceGroups[f1groupIndex]);
                              faceGroups.splice(f1groupIndex, 1);
                          }
                      }
                      else {
                          if (f0groupIndex == -1) {
                              faceGroups[f1groupIndex].push(f0);
                          }
                          if (f1groupIndex == -1) {
                              faceGroups[f0groupIndex].push(f1);
                          }
                      }
                      continue;
                  }
                  // This is a hard edge or a border edge... Add faces separately group.
                  if (f0 != -1)
                      addFaceToGroup(f0);
                  if (f1 != -1)
                      addFaceToGroup(f1);
              }
              // Sort the groups to have the biggest group first.
              faceGroups.sort((a, b) => (a.length < b.length ? 1 : a.length > b.length ? -1 : 0));
              let firstVertex = true;
              for (const faceGroup of faceGroups) {
                  const normal = new Vec3();
                  for (const faceIndex of faceGroup) {
                      const faceEdges = getConnectedEdgeVecs(faceIndex, i);
                      let weight;
                      if (faceEdges[0] && faceEdges[1]) {
                          weight = faceEdges[0].angleTo(faceEdges[1]);
                          normal.addInPlace(getFaceNormal(faceIndex).scale(weight));
                      }
                      else {
                          console.warn('variable weight is undefined because faceEdges[0] or faceEdges[1] is undefined');
                      }
                      // if (i == 1)
                      //     console.log("FaceNormal:" + faceIndex + ":" + getFaceNormal(faceIndex).toString());
                  }
                  normal.normalizeInPlace();
                  if (firstVertex) {
                      setVertexNormal(i, normal);
                      firstVertex = false;
                  }
                  else {
                      normalsAttr.setSplitVertexValues(i, faceGroup, normal.asArray());
                  }
              }
          }
          return normalsAttr;
      }
      /**
       * The computeHardEdgesIndices method.
       * @param hardAngle - The hardAngle value in radians.
       * @return - The return value.
       */
      computeHardEdgesIndices(hardAngle = 1.0) {
          if (this.edgeVerts.length == 0)
              this.calculateEdgeAngles();
          const hardEdges = [];
          const addEdge = (index) => {
              hardEdges.push(this.edgeVerts[index]);
              hardEdges.push(this.edgeVerts[index + 1]);
          };
          for (let i = 0; i < this.edgeAngles.length; i++) {
              if (this.edgeAngles[i] > hardAngle) {
                  addEdge(i * 2);
              }
          }
          return Uint32Array.from(hardEdges);
      }
      /**
       * Merges a separate geometry into this one. Similar to a 'union' boolean operation.
       * @param other the other geom that will be merged into this one
       * @param xfo the transformation to be applied to the other geom as it is merged in.
       */
      merge(other, xfo = new Xfo()) {
          const prevNumVerts = this.getNumVertices();
          super.merge(other, xfo);
          const otherFaceVertexIndices = other.faceVertexIndices;
          const faceVertexIndices = new Uint32Array(this.faceVertexIndices.length + otherFaceVertexIndices.length);
          const otherFaceCounts = other.getFaceCounts();
          let indexOffset = 0;
          let otherIndexOffset = 0;
          let mergedIndexOffset = 0;
          const numCounts = Math.max(this.faceCounts.length, otherFaceCounts.length);
          for (let i = 0; i < numCounts; i++) {
              if (this.faceCounts.length > i) {
                  // Add 'this' indices
                  const numIndicesThis = this.faceCounts[i] * (i + 3);
                  faceVertexIndices.set(this.faceVertexIndices.slice(indexOffset, indexOffset + numIndicesThis), mergedIndexOffset);
                  indexOffset += numIndicesThis;
                  mergedIndexOffset += numIndicesThis;
              }
              if (otherFaceCounts.length > i) {
                  // Add the 'other' indices
                  const numIndicesOther = otherFaceCounts[i] * (i + 3);
                  faceVertexIndices.set(otherFaceVertexIndices
                      .slice(otherIndexOffset, otherIndexOffset + numIndicesOther)
                      .map((index) => index + prevNumVerts), mergedIndexOffset);
                  otherIndexOffset += numIndicesOther;
                  mergedIndexOffset += numIndicesOther;
                  if (this.faceCounts.length == i)
                      this.faceCounts[i] = 0;
                  this.faceCounts[i] += otherFaceCounts[i];
              }
          }
          this.faceVertexIndices = faceVertexIndices;
          // Note: the merge does not correctly merge split values, as it is quite complex
          // and we don't have time now. We can come back to this, but the splits system is overly complex
          // and we can probably re-write.
          // for (const [attrName, attr] of this.__vertexAttributes) {
          //   const otherAttr = other.getVertexAttribute(attrName)
          //   if (otherAttr) {
          //     const thisSplits = attr.getSplits()
          //     const otherSplits = otherAttr.getSplits()
          //     // for (let key in otherSplits) {
          //     //   thisSplits[key] = otherSplits[key]
          //     // }
          //   }
          // }
      }
      // ////////////////////////////////////////
      // Rendering
      /**
       * The genBuffers method.
       * @param opts - The opts value.
       * @return - The return value.
       */
      genBuffers(opts) {
          // Compute the normals on demand.
          // if (!('normals' in this.__vertexAttributes)) {
          //     // this.geom.computeVertexNormals();
          //     this.addVertexAttribute("normals", Vec3, 0.0);
          // }
          const splitIndices = {};
          let splitCount = 0;
          for (const [, attr] of this.__vertexAttributes) {
              const attrSplits = attr.getSplits();
              for (const polygon in attrSplits) {
                  if (!(polygon in splitIndices))
                      splitIndices[polygon] = {};
                  const vertices = attrSplits[polygon];
                  for (const v in vertices) {
                      const vertex = parseInt(v);
                      if (!(vertex in splitIndices[polygon])) {
                          splitIndices[polygon][vertex] = splitCount;
                          splitCount++;
                      }
                  }
              }
          }
          const positions = this.positions;
          const numUnSplitVertices = positions.getCount();
          const totalNumVertices = numUnSplitVertices + splitCount;
          let indices;
          if (!opts || opts.includeIndices != false) {
              indices = this.generateTriangulatedIndices(totalNumVertices, numUnSplitVertices, splitIndices);
          }
          // let maxIndex;
          // if (debugAttrValues)
          //     maxIndex = Math.max(...indices);
          const attrBuffers = {};
          for (const [attrName, attr] of this.__vertexAttributes) {
              let values;
              if (splitCount == 0)
                  values = attr.asArray();
              else
                  values = attr.generateSplitValues(splitIndices, splitCount);
              const dimension = attr.stride;
              const count = values.length / dimension;
              // if (debugAttrValues) {
              //     if (count <= maxIndex)
              //         console.warn("Invalid indexing. Attr value is insufficient for indexing:" + attrName + ". Max Index:" + maxIndex + " Attr Size:" + count);
              // }
              attrBuffers[attrName] = {
                  values: values,
                  count: count,
                  dimension: dimension,
                  normalized: attrName == 'normals',
                  dataType: attr.getDataTypeName(),
              };
          }
          const result = {
              numVertices: this.numVertices(),
              numRenderVerts: totalNumVertices,
              indices,
              attrBuffers,
          };
          /* Disabled during TS migration.
          if (opts && opts.includeVertexNeighbors) {
            if (this.vertexEdges == undefined) this.genTopologyInfo()
      
            let count = 0
            for (let i = 0; i < this.vertexEdges.length; i++) {
              // If this face indexing doesn't start at 0, then the vertexEdges don't either.
              if (this.vertexEdges[i]) count += this.vertexEdges[i].size
            }
            // The array will be structured as a start+offset for each vertex, followed
            // by a 2d array of neighbor indices.
            const vertexNeighbors = new Uint32Array(this.vertexEdges.length * 2 + count)
            const sortFanEdges = (fanEdges: any) => {
              for (let i = 0; i < fanEdges.length; i++) {
                const feA = fanEdges[i]
                for (let j = 0; j < i; j++) {
                  const feB = fanEdges[j]
                  if (feA[0] != -1 && feA[0] == feB[1]) {
                    //  move feA after feB;
                    if (i != j + 1) {
                      fanEdges.splice(i, 1)
                      fanEdges.splice(j + 1, 0, feA)
                    }
                    break
                  }
                  if (feA[1] != -1 && feA[1] == feB[0]) {
                    //  move feA before feB;
                    fanEdges.splice(i, 1)
                    fanEdges.splice(j, 0, feA)
                    break
                  }
                }
              }
            }
            const checkFanEdges = (fanEdges: any) => {
              // now check that the faces all build a fan. Maybe starting and ending with -1
              if (fanEdges[0][0] == -1 || fanEdges[fanEdges.length - 1][1] == -1) {
                if (fanEdges[0][0] != -1 || fanEdges[fanEdges.length - 1][1] != -1) {
                  throw new Error('If fan starts with -1, it must also end with -1')
                }
              }
              for (let i = 0; i < fanEdges.length; i++) {
                const fe = fanEdges[i]
                if (fe[0] == -1 || fe[1] == -1) {
                  if (i != 0 && i != fanEdges.length - 1) {
                    throw new Error('-1 only allowed at the beginning and end of a fan.')
                  }
                }
                if (fe[0] != -1) {
                  let prev = i - 1
                  if (prev < 0) prev += fanEdges.length
                  if (fe[0] != fanEdges[prev][1]) {
                    throw new Error('Faces are not sequential')
                  }
                }
                if (fe[1] != -1) {
                  const next = (i + 1) % fanEdges.length
                  if (fe[1] != fanEdges[next][0]) {
                    throw new Error('Faces are not sequential')
                  }
                }
              }
            }
      
            // Populate the start and offset values.
            let offset = this.vertexEdges.length * 2
            for (let i = 0; i < this.vertexEdges.length; i++) {
              if (this.vertexEdges[i] == undefined) continue
              const edges = this.vertexEdges[i]
      
              // Build a sorted list of faces based on a fan around
              // the vertex.
              const fanEdges = []
              for (const e of edges) {
                const v0 = this.edgeVerts[e * 2]
                const v1 = this.edgeVerts[e * 2 + 1]
                let f0 = this.edgeFaces[e * 2]
                let f1 = this.edgeFaces[e * 2 + 1]
                let neigVert
                if (v0 == i) {
                  neigVert = v1
                } else if (v1 == i) {
                  neigVert = v0
                  // swap the faces
                  const tmp = f0
                  f0 = f1
                  f1 = tmp
                } else {
                  throw new Error('Invalid topology')
                }
                fanEdges.push([f0, f1, neigVert])
              }
              sortFanEdges(fanEdges)
              checkFanEdges(fanEdges)
              const closed = fanEdges[0][0] != -1 || fanEdges[fanEdges.length - 1][1] != -1
              let flags = 0
              if (closed) flags += 1
              vertexNeighbors[i * 2] = offset
              vertexNeighbors[i * 2 + 1] = edges.size + (flags << 8)
              for (const fe of fanEdges) {
                vertexNeighbors[offset] = fe[2]
                offset++
              }
            }
            ;(result as any).vertexNeighbors = vertexNeighbors
          }
          */
          return result;
      }
      /**
       * Compute the number of triangles. For higher degree polygons, they are divided into multiple triangles for rendering.
       * @return - Returns the number of triangles.
       */
      computeNumTriangles() {
          let numVertsPerFace = 3;
          let trisCount = 0;
          for (const fc of this.faceCounts) {
              trisCount += fc * (numVertsPerFace - 2);
              numVertsPerFace++;
          }
          return trisCount;
      }
      /**
       * To prepare data for rendering, the indices for the polygons is used to compute a new index buffer based on
       * only triangles. This is used during rendering and the resulting indices uploaded ot the GPU  by GLMesh class.
       *
       * @param totalNumVertices - The total number of vertices.
       * @param numUnSplitVertices - The total number of un-split vertices.
       * @param splitIndices - The splitIndices value.
       * @return - Returns a typed array containing the triangulated indices.
       */
      generateTriangulatedIndices(totalNumVertices, numUnSplitVertices, splitIndices) {
          const trisCount = this.computeNumTriangles();
          let triangulatedIndices;
          if (totalNumVertices < Math.pow(2, 8))
              triangulatedIndices = new Uint8Array(trisCount * 3);
          else if (totalNumVertices < Math.pow(2, 16))
              triangulatedIndices = new Uint16Array(trisCount * 3);
          else
              triangulatedIndices = new Uint32Array(trisCount * 3);
          let triangleVertex = 0;
          const addTriangleVertexIndex = function (vertex, faceIndex) {
              if (vertex in splitIndices && faceIndex in splitIndices[vertex])
                  vertex = numUnSplitVertices + splitIndices[vertex][faceIndex];
              triangulatedIndices[triangleVertex] = vertex;
              triangleVertex++;
          };
          const numFaces = this.getNumFaces();
          for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
              const faceVerts = this.getFaceVertexIndices(faceIndex);
              for (let j = 0; j < faceVerts.length; j++) {
                  if (j >= 3) {
                      // For each additional triangle, we have to add 2 indices.
                      addTriangleVertexIndex(faceVerts[0], faceIndex);
                      addTriangleVertexIndex(faceVerts[j - 1], faceIndex);
                  }
                  addTriangleVertexIndex(faceVerts[j], faceIndex);
              }
          }
          return triangulatedIndices;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Restores mesh properties from a binary reader.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.loadBaseGeomBinary(reader, context);
          this.setFaceCounts(Array.from(reader.loadUInt32Array()));
          const numFaces = this.getNumFaces();
          // Note: we can remove this. We can infer this from the above faceCounts array.
          // Do not clone the data, as its 'scratch memory' in any case.
          // We can avoid a lot of unnecessary temporary allocaiton by using shared buffers.
          const faceVertexCounts = reader.loadUInt8Array(numFaces, false);
          const offsetRange = reader.loadSInt32Vec2();
          const bytes = reader.loadUInt8();
          let faceVertexIndexDeltas;
          if (bytes == 1)
              faceVertexIndexDeltas = reader.loadUInt8Array(undefined, false);
          else if (bytes == 2)
              faceVertexIndexDeltas = reader.loadUInt16Array(undefined, false);
          else if (bytes == 4)
              faceVertexIndexDeltas = reader.loadUInt32Array(undefined, false);
          else {
              throw Error('faceVertexIndexDeltas undefined');
          }
          // ///////////////////////////////////////////////////
          // Note: The Mesh compression system needs a thorough review.
          // The C++ classes are not storing face indices in a sorted manner.
          // So quads precede triangles in the indexing, which isn't supposed to happen.
          // We should force the C++ code to store quads and triangles in order.
          // e.g. implement the 'addFace' method in C++ so it automatically does this.
          let numFaceVerts = 3;
          let offset = 0;
          const faceOffsetsByCount = this.faceCounts.map((fc, index) => {
              const result = offset;
              offset += fc * numFaceVerts;
              numFaceVerts++;
              return result;
          });
          let srcOffset = 0;
          let prevCount = 0;
          const faceOffsets = [];
          for (let faceIndex = 0; faceIndex < numFaces; faceIndex++) {
              const fc = faceVertexCounts[faceIndex];
              const offset = faceOffsetsByCount[fc];
              const count = fc + 3;
              faceOffsets[faceIndex] = offset;
              for (let j = 0; j < count; j++) {
                  const srcFaceVertex = srcOffset + j;
                  const faceVertex = offset + j;
                  const delta = faceVertexIndexDeltas[srcFaceVertex] + offsetRange.x;
                  if (faceIndex == 0)
                      this.faceVertexIndices[faceVertex] = delta;
                  else {
                      let prevFaceVertex = faceOffsets[faceIndex - 1];
                      prevFaceVertex += j < prevCount ? j : prevCount - 1;
                      this.faceVertexIndices[faceVertex] = this.faceVertexIndices[prevFaceVertex] + delta;
                  }
              }
              srcOffset += count;
              faceOffsetsByCount[fc] += count;
              prevCount = count;
          }
          if (!this.hasVertexAttribute('normals')) {
              this.computeVertexNormals();
          }
          // this.computeVertexNormals();
          this.emit('geomDataChanged');
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = super.toJSON(context);
          if (!context || !context.skipTopology) {
              j.faceCounts = Array.from(this.faceCounts);
              j.faceVertexIndices = Array.from(this.faceVertexIndices);
          }
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * e.g. to load data into the mesh class, provide a json structure similar to the following.
       * Note: faceCounts is an array of count values, starting with the number of triangles, then the number of quads. See #setFaceCounts
       * The faceVertexIndices array should also be sorted to contain all the triangles first, followed by the quads, and then the pentagons etc..
       * ```json
       * // This code will define a mesh made up of 2 triangles and then a quad.
       * const mesh = new Mesh()
       * mesh.fromJSON({
       *   faceCounts:[2, 1],
       *   faceVertexIndices: [0, 1, 2, 0, 2, 3, 3, 2, 4, 5],
       *   numVertices: 6,
       *   vertexAttributes: {
       *     positions: {
       *       dataType: 'Vec3'
       *       defaultScalarValue: 0.0,
       *       data: [0,0,0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 2, 1, 0, 2, 0, 0]
       *     }
       *   }
       * }
       * ```
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          super.fromJSON(j, context);
          if (j.faceCounts)
              this.faceCounts = j.faceCounts;
          if (j.faceVertexIndices)
              this.faceVertexIndices = Uint32Array.from(j.faceVertexIndices);
      }
  }
  Registry.register('Mesh', Mesh);

  /** ProxyGeometries are pupulated from data unpacked using a webworker while loading zcad files.
   * These geometries represent readonly geometries with very basic topologies.
   * @extends EventEmitter
   * @private
   */
  class BaseProxy extends EventEmitter {
      name;
      buffers;
      boundingBox;
      numVertices = 0;
      libraryIndex = -1;
      /**
       * Create a base proxy.
       * @param data - The data value.
       */
      constructor(data) {
          super();
          if (data) {
              this.name = data.name;
              this.buffers = data.geomBuffers;
              this.boundingBox = new Box3();
              this.boundingBox.p0.fromJSON(data.bbox.p0);
              this.boundingBox.p1.fromJSON(data.bbox.p1);
              this.numVertices = this.buffers.numVertices;
          }
      }
      get positions() {
          return this.buffers.attrBuffers['positions'];
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      getNumVertices() {
          return this.numVertices;
      }
      /**
       * Returns the bounding box for geometry.
       * @return - The return value.
       */
      getBoundingBox() {
          return this.boundingBox;
      }
      /**
       * The genBuffers method.
       * @return - The return value.
       */
      genBuffers() {
          return this.buffers;
      }
      /**
       * Once the buffers have been uploaded to the GPU, we are free to release them.
       * The GLGeomLibrary may call this function to let the geometry know it can release any handles.
       */
      freeBuffers() {
          for (const attrName in this.buffers.attrBuffers) {
              const attrData = this.buffers.attrBuffers[attrName];
              attrData.values = null;
          }
          if (this.buffers.indices) {
              this.buffers.indices = null;
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = {
              geomBuffers: this.buffers,
          };
          return json;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          this.buffers = json.geomBuffers;
      }
  }
  /** Class representing a points proxy.
   * @extends BaseProxy
   * @private
   */
  class PointsProxy extends BaseProxy {
      /**
       * Create a points proxy.
       * @param data - The data value.
       */
      constructor(data) {
          super(data);
      }
  }
  /** Class representing a lines proxy.
   * @extends BaseProxy
   * @private
   */
  class LinesProxy extends BaseProxy {
      numLineSegments = 0;
      /**
       * Create a lines proxy.
       * @param data - The data value.
       */
      constructor(data) {
          super(data);
          this.numLineSegments = this.buffers.indices.length / 2;
      }
      /**
       * Returns the number line segments in this lines proxy geometry
       *
       * @return - The return value.
       */
      getNumLineSegments() {
          return this.numLineSegments;
      }
  }
  /** Class representing a mesh proxy.
   * @extends BaseProxy
   * @private
   */
  class MeshProxy extends BaseProxy {
      numTriangles = 0;
      /**
       * Create a mesh proxy.
       * @param data - The data value.
       */
      constructor(data) {
          super(data);
          this.numTriangles = this.buffers.indices.length / 3;
      }
      /**
       * Returns the number of triangles in this mesh proxy geometry.
       *
       * @return - The return value.
       */
      getNumTriangles() {
          return this.numTriangles;
      }
  }

  class SubGeom extends ParameterOwner {
  }
  Registry.register('SubGeom', SubGeom);
  /**
   * Class representing a point primitive drawing type, every vertex specified is a point.
   *
   * ```
   * const compoundGeom = new CompoundGeom()
   * ```
   *
   * * **Events**
   * * **boundingBoxChanged:** Triggered when the bounding box changes.
   *
   * @extends BaseProxy
   */
  class CompoundGeom extends BaseProxy {
      materials = [];
      subGeoms = [];
      counts;
      materialGroupsDirty = false;
      /**
       * Create points.
       */
      constructor(data, materialLibrary) {
          super(data);
          if (data) {
              this.counts = data.geomBuffers.counts;
              // Now use the indices in the geom to look up the actual materials
              // that will be used in rendering.
              const materials = materialLibrary.getMaterials();
              data.geomBuffers.materialLibraryIndices.forEach((materialIndex, index) => {
                  this.materials[index] = materials[materialIndex];
              });
              delete data.geomBuffers.materialLibraryIndices;
              this.buffers.materials = this.materials;
          }
      }
      /**
       * Returns the number of faces, edges and point sub-geoms in this compound geom.
       *
       * @return - The return value.
       */
      getNumSubGeoms() {
          return this.buffers.numSubGeoms;
      }
      /**
       * Returns the number of Face sub-geoms in this compound geom.
       *
       * @return - The return value.
       */
      getNumFaces() {
          return this.buffers.subGeomCounts['TRIANGLES'].length;
      }
      /**
       * Returns the number of Edge sub-geoms in this compound geom.
       *
       * @return - The return value.
       */
      getNumEdges() {
          return this.buffers.subGeomCounts['LINES'].length;
      }
      /**
       * Returns the number of triangles in this compound geom.
       *
       * @return - The return value.
       */
      getNumTriangles() {
          return this.counts['TRIANGLES'] / 3;
      }
      /**
       * Returns the number line segments in this lines proxy geometry
       *
       * @return - The return value.
       */
      getNumLineSegments() {
          return this.counts['LINES'] / 2;
      }
      /**
       * Returns the number line segments in this lines proxy geometry
       *
       * @return - The return value.
       */
      getNumPoints() {
          return this.counts['POINTS'];
      }
      // ////////////////////////////////////////
      // Materials
      getSubGeomMaterial(subGeomId) {
          // Note: subGeomMaterialIndices is Uint8Array, and 0 means no custom
          // material is assigned to the subGeom.
          // Subtract 1 to get the actual material id.
          const materialIndex = this.buffers.subGeomMaterialIndices[subGeomId] - 1;
          if (materialIndex == -1)
              return undefined;
          return this.materials[materialIndex];
      }
      /**
       * Assigns a material to a sub-geom by ID;
       * @param subGeomId - The ID of the sub-geom to assign the material.
       * @param material - The material to assign.
       */
      setSubGeomMaterial(subGeomId, material) {
          if (!material) {
              if (this.buffers.subGeomMaterialIndices && this.buffers.subGeomMaterialIndices[subGeomId])
                  this.buffers.subGeomMaterialIndices[subGeomId] = 0;
          }
          else {
              let materialIndex = this.materials.indexOf(material);
              if (materialIndex == -1) {
                  materialIndex = this.materials.length;
                  this.materials[materialIndex] = material;
              }
              if (this.buffers.subGeomMaterialIndices.length == 0) {
                  this.buffers.subGeomMaterialIndices = new Uint8Array(this.buffers.numSubGeoms);
              }
              // Note: subGeomMaterialIndices is Uint8Array, and 0 means no custom
              // material is assigned to the subGeom.
              // Subtract 1 to get the actual material id.
              this.buffers.subGeomMaterialIndices[subGeomId] = materialIndex + 1;
          }
          this.materialGroupsDirty = true;
          this.emit('materialsChanged');
      }
      /**
       * Assigns a material to a sub-geom by ID;
       * @deprecated
       * Please use: setSubGeomMaterial
       * @param subGeomId - The ID of the sub-geom to assign the material.
       * @param material - The material to assign.
       */
      assignSubGeomMaterial(subGeomId, material) {
          this.setSubGeomMaterial(subGeomId, material);
      }
      /**
       * Clears all sub--geom material assignments. This means the geometry will be drawn
       * using only the material of the GeomItem or CADBody.
       */
      clearMaterials() {
          this.materials.splice(0, this.materials.length);
          this.buffers.subGeomMaterialIndices = this.buffers.subGeomMaterialIndices.map(() => 0);
          this.emit('materialsChanged');
      }
      /**
       * Each subgeom may be a assigned a different material.
       *
       * We calculate groups that enable multiple subgeoms to
       * be rendered at once using the same material id.
       * Note: this is an optimization that only applies when
       * rendering geoms in non-shattered mode.
       */
      calcMaterialGroups() {
          const materialSubGeoms = {};
          if (this.buffers.subGeomMaterialIndices.length == 0) {
              this.buffers.materialSubGeoms = {};
              let offset = 0;
              for (let key in this.buffers.counts) {
                  const count = this.buffers.counts[key];
                  if (count > 0) {
                      this.buffers.materialSubGeoms[key] = [
                          {
                              materialId: -1,
                              offset,
                              count,
                          },
                      ];
                  }
                  offset += count;
              }
              return;
          }
          // /////////////////////////////////
          // Material Groups
          let offset = 0;
          let currMaterial = -99;
          let currMaterialSubGeom = null;
          for (let i = 0; i < this.buffers.numSubGeoms; i++) {
              let key;
              let subGeomOffset = 0;
              if (i < this.buffers.subGeomCounts.TRIANGLES.length) {
                  if (!materialSubGeoms.TRIANGLES)
                      materialSubGeoms.TRIANGLES = [];
                  key = 'TRIANGLES';
              }
              else if (i < this.buffers.subGeomCounts.TRIANGLES.length + this.buffers.subGeomCounts.LINES.length) {
                  subGeomOffset = this.buffers.subGeomCounts.TRIANGLES.length;
                  key = 'LINES';
                  if (!materialSubGeoms.LINES)
                      materialSubGeoms.LINES = [];
              }
              else {
                  subGeomOffset = this.buffers.subGeomCounts.TRIANGLES.length + this.buffers.subGeomCounts.LINES.length;
                  key = 'POINTS';
                  if (!materialSubGeoms.POINTS)
                      materialSubGeoms.POINTS = [];
              }
              const materialId = this.buffers.subGeomMaterialIndices[i];
              if (currMaterial != materialId) {
                  currMaterial = materialId;
                  // Note: subGeomMaterialIndices is Uint8Array, and 0 means no custom
                  // material is assigned to the subGeom.
                  // Subtract 1 to get the actual material id.
                  currMaterialSubGeom = {
                      materialId: materialId - 1,
                      offset,
                      count: 0,
                  };
                  for (; i < this.buffers.numSubGeoms; i++) {
                      if (currMaterial != this.buffers.subGeomMaterialIndices[i]) {
                          break;
                      }
                      // When we get to the end og this geom type (e.g .TRIANGLES)
                      // start a new subgeom.
                      if (i - subGeomOffset == this.buffers.subGeomCounts[key].length) {
                          // Force the material index to be reset on line 162 above.
                          currMaterial = -99;
                          break;
                      }
                      currMaterialSubGeom.count += this.buffers.subGeomCounts[key][i - subGeomOffset];
                  }
                  offset += currMaterialSubGeom.count;
                  materialSubGeoms[key].push(currMaterialSubGeom);
                  i--;
              }
          }
          this.buffers.materialSubGeoms = materialSubGeoms;
      }
      /**
       * The genBuffers method.
       * @return - The return value.
       */
      genBuffers() {
          if (this.materialGroupsDirty)
              this.calcMaterialGroups();
          return this.buffers;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = {
              // geomBuffers: this.buffers,
              materialPaths: this.materials.map((material) => material.path),
          };
          return json;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          this.counts = json.geomBuffers.counts;
          // this.buffers = json.geomBuffers
          if (json.materialPaths && context) {
              const materialPaths = json.materialPaths;
              this.materials = [];
              materialPaths.forEach((path, index) => {
                  context.resolvePath(path, (result) => {
                      if (result instanceof Material)
                          this.materials[index] = result;
                  }, () => { });
              });
          }
          this.buffers.materials = this.materials;
          this.materialGroupsDirty = true;
      }
      /**
       * Sets state of current geometry(Including line segments) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      loadMetadata(metadataReader, context) {
          const toc = metadataReader.loadUInt32Array();
          toc.forEach((offset, index) => {
              const subGeom = new SubGeom();
              metadataReader.seek(offset);
              subGeom.readBinary(metadataReader, context);
              this.subGeoms[index] = subGeom;
          });
      }
  }
  Registry.register('CompoundGeom', CompoundGeom);

  /**
   * Base Class for procedural points generated by mathematical functions.
   *
   * @extends {Points}
   */
  class ProceduralPoints extends Points {
      dirtyTopology;
      dirtyVertices;
      topologyParams;
      /**
       * Creates an instance of ProceduralPoints.
       */
      constructor() {
          super();
          this.dirtyTopology = true;
          this.dirtyVertices = true;
          // Parameters that specify topology settings.
          // Add parameters to this list to ensure the topology is recomputed.
          // All other param changes will only trigger a resize
          this.topologyParams = [];
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       * @param event - The event object emitted by the parameter.
       * @private
       */
      parameterValueChanged(event) {
          this.setBoundingBoxDirty();
          if (this.topologyParams.includes(event.param.getName())) {
              this.dirtyTopology = true;
              this.emit('geomDataTopologyChanged');
          }
          else {
              this.dirtyVertices = true;
              this.setBoundingBoxDirty();
              // Let the renderer know that the geometry has changed and must be re-uploaded to the GPU.
              this.emit('geomDataChanged');
          }
          super.parameterValueChanged(event);
      }
      /**
       * If the Procedural geometry is out of date, for example if a parameter has been changed,
       * this method explicitly forces the geometry to be recomputed.
       */
      update() {
          if (this.dirtyTopology) {
              this.rebuild();
              this.dirtyTopology = false;
              this.dirtyVertices = false;
              this.rebuild();
          }
          else if (this.dirtyVertices) {
              this.dirtyVertices = false;
              this.resize();
              this.dirtyVertices = false;
          }
      }
      /**
       * Returns the bounding box for geometry.
       * @return - The return value.
       */
      getBoundingBox() {
          this.update();
          return super.getBoundingBox();
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      getNumVertices() {
          this.update();
          return super.getNumVertices();
      }
      // ////////////////////////////////////////
      // Rendering
      /**
       * The genBuffers method.
       * @param opts - The opts value.
       * @return - The return value.
       */
      genBuffers(opts) {
          this.update();
          return super.genBuffers(opts);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          if (!context)
              context = {};
          context.skipTopology = true;
          context.skipAttributes = ['positions', 'normals', 'texCoords'];
          const j = super.toJSON(context);
          context.skipTopology = false;
          context.skipAttributes = [];
          return j;
      }
  }

  /**
   * Base Class for procedural lines generated by mathematical functions.
   *
   * @extends {Lines}
   */
  class ProceduralLines extends Lines {
      dirtyTopology;
      dirtyVertices;
      topologyParams;
      /**
       * Creates an instance of ProceduralLines.
       */
      constructor() {
          super();
          this.dirtyTopology = true;
          this.dirtyVertices = true;
          // Parameters that specify topology settings.
          // Add parameters to this list to ensure the topology is recomputed.
          // All other param changes will only trigger a resize
          this.topologyParams = [];
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       * @param event - The event object emitted by the parameter.
       * @private
       */
      parameterValueChanged(event) {
          this.setBoundingBoxDirty();
          if (this.topologyParams.includes(event.param.getName())) {
              this.dirtyTopology = true;
              this.emit('geomDataTopologyChanged');
          }
          else {
              this.dirtyVertices = true;
              this.setBoundingBoxDirty();
              // Let the renderer know that the geometry has changed and must be re-uploaded to the GPU.
              this.emit('geomDataChanged');
          }
          super.parameterValueChanged(event);
      }
      /**
       * If the Procedural geometry is out of date, for example if a parameter has been changed,
       * this method explicitly forces the geometry to be recomputed.
       */
      update() {
          if (this.dirtyTopology) {
              this.rebuild();
              this.dirtyTopology = false;
              this.dirtyVertices = false;
              this.rebuild();
          }
          else if (this.dirtyVertices) {
              this.resize();
              this.dirtyVertices = false;
              this.resize();
          }
      }
      /**
       * Returns the bounding box for geometry.
       * @return - The return value.
       */
      getBoundingBox() {
          this.update();
          return super.getBoundingBox();
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      getNumVertices() {
          this.update();
          return super.getNumVertices();
      }
      // ////////////////////////////////////////
      // Rendering
      /**
       * The genBuffers method.
       * @param opts - The opts value.
       * @return - The return value.
       */
      genBuffers(opts) {
          this.update();
          return super.genBuffers();
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          if (!context)
              context = {};
          context.skipTopology = true;
          context.skipAttributes = ['positions', 'normals', 'texCoords'];
          const j = super.toJSON(context);
          context.skipTopology = false;
          context.skipAttributes = [];
          return j;
      }
  }

  /**
   * Base Class for procedural meshes generated by mathematical functions.
   *
   * @extends {Mesh}
   */
  class ProceduralMesh extends Mesh {
      dirtyTopology;
      dirtyVertices;
      topologyParams;
      /**
       * Creates an instance of ProceduralMesh.
       */
      constructor() {
          super();
          this.dirtyTopology = true;
          this.dirtyVertices = true;
          // Parameters that specify topology settings.
          // Add parameters to this list to ensure the topology is recomputed.
          // All other param changes will only trigger a resize
          this.topologyParams = [];
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       * @param event - The event object emitted by the parameter.
       * @private
       */
      parameterValueChanged(event) {
          this.setBoundingBoxDirty();
          if (this.topologyParams.includes(event.param.getName())) {
              this.dirtyTopology = true;
              this.emit('geomDataTopologyChanged');
          }
          else {
              this.dirtyVertices = true;
              this.setBoundingBoxDirty();
              // Let the renderer know that the geometry has changed and must be re-uploaded to the GPU.
              this.emit('geomDataChanged');
          }
          super.parameterValueChanged(event);
      }
      /**
       * If the Procedural geometry is out of date, for example if a parameter has been changed,
       * this method explicitly forces the geometry to be recomputed.
       */
      update() {
          if (this.dirtyTopology) {
              // Clear the topology so that vertex normals can be recomputed.
              this.vertexEdges = [];
              this.dirtyTopology = false;
              this.dirtyVertices = false;
              this.rebuild();
          }
          else if (this.dirtyVertices) {
              this.dirtyVertices = false;
              this.resize();
          }
      }
      /**
       * Returns the bounding box for geometry.
       * @return - The return value.
       */
      getBoundingBox() {
          this.update();
          return super.getBoundingBox();
      }
      /**
       * Returns the number of vertex attributes.
       *
       * @return - The return value.
       */
      getNumVertices() {
          this.update();
          return super.getNumVertices();
      }
      /**
       * Compute vertex normals.
       * @param hardAngle - The hardAngle value in radians.
       * @return - The return value.
       */
      computeVertexNormals(hardAngle = 1.0 /* radians */) {
          this.update();
          return super.computeVertexNormals(hardAngle);
      }
      /**
       * The computeHardEdgesIndices method.
       * @param hardAngle - The hardAngle value in radians.
       * @return - The return value.
       */
      computeHardEdgesIndices(hardAngle = 1.0) {
          this.update();
          return super.computeHardEdgesIndices(hardAngle);
      }
      // ////////////////////////////////////////
      // Rendering
      /**
       * The genBuffers method.
       * @param opts - The opts value.
       * @return - The return value.
       */
      genBuffers(opts) {
          this.update();
          return super.genBuffers(opts);
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          if (!context)
              context = {};
          context.skipTopology = true;
          context.skipAttributes = ['positions', 'normals', 'texCoords'];
          const j = super.toJSON(context);
          context.skipTopology = false;
          context.skipAttributes = [];
          return j;
      }
  }

  /**
   * Represents an ordered grid of points along `X` and `Y` axes.
   *
   * ```
   * const pointGrid = new PointGrid(2.2, 1.5, 12, 12)
   * ```
   *
   * **Parameters**
   * * **X(`NumberParameter`):** Length of the grid along the `X` axis.
   * * **Y(`NumberParameter`):** Length of the grid along the `Y` axis.
   * * **XDivisions(`NumberParameter`):** Number of divisions along `X` axis
   * * **YDivisions(`NumberParameter`):** Number of divisions along `Y` axis
   * @extends {ProceduralPoints}
   */
  class PointGrid extends ProceduralPoints {
      /**
       * @member sizeXParam - Length of the grid along the `X` axis.
       */
      sizeXParam = new NumberParameter('SizeX', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Length of the grid along the `Y` axis.
       */
      sizeYParam = new NumberParameter('SizeY', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member divisionsXParam - Number of divisions along `X` axis
       */
      divisionsXParam = new NumberParameter('XDivisions', 1, [0, Number.MAX_VALUE], 1);
      /**
       * @member divisionsYParam - Number of divisions along `Y` axis
       */
      divisionsYParam = new NumberParameter('YDivisions', 1, [0, Number.MAX_VALUE], 1);
      /**
       * Creates an instance of PointGrid.
       *
       * @param x - The length of the point grid along the X axis.
       * @param y - The length of the point grid along the Y axis.
       * @param xDivisions - The number of divisions along the X axis.
       * @param yDivisions - The number of divisions along the Y axis.
       * @param addTextureCoords - The addTextureCoords value.
       */
      constructor(x = 1.0, y = 1.0, xDivisions = 1, yDivisions = 1) {
          super();
          this.topologyParams = [];
          if (isNaN(x) || isNaN(y) || isNaN(xDivisions) || isNaN(yDivisions))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.addParameter(this.divisionsXParam);
          this.addParameter(this.divisionsYParam);
          this.sizeXParam.value = x;
          this.sizeYParam.value = y;
          this.divisionsXParam.value = xDivisions;
          this.divisionsYParam.value = yDivisions;
          this.topologyParams.push('XDivisions');
          this.topologyParams.push('YDivisions');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const xDivisions = Math.round(this.divisionsXParam.value);
          const yDivisions = Math.round(this.divisionsYParam.value);
          this.setNumVertices(xDivisions * yDivisions);
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              for (let i = 0; i < yDivisions; i++) {
                  const y = i / (yDivisions - 1);
                  for (let j = 0; j < xDivisions; j++) {
                      const x = j / (xDivisions - 1);
                      texCoords.setValue(i * xDivisions + j, new Vec2(x, y));
                  }
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const xDivisions = Math.round(this.divisionsXParam.value);
          const yDivisions = Math.round(this.divisionsYParam.value);
          const x = this.sizeXParam.value;
          const y = this.sizeYParam.value;
          const positions = this.positions;
          if (!positions)
              return;
          for (let i = 0; i < yDivisions; i++) {
              const newY = (i / (yDivisions - 1) - 0.5) * y;
              for (let j = 0; j < xDivisions; j++) {
                  const newX = (j / (xDivisions - 1) - 0.5) * x;
                  positions.setValue(i * xDivisions + j, new Vec3(newX, newY, 0.0));
              }
          }
      }
  }
  Registry.register('PointGrid', PointGrid);

  /**
   * A class for generating a rectangle shape.
   *
   * ```
   * const rect = new Rect(1.5, 2.0)
   * ```
   *
   * **Parameters**
   * * **X(`NumberParameter`):** Length of the rectangle along the `X` axis.
   * * **Y(`NumberParameter`):** Length of the rectangle along the `Y` axis.
   *
   *
   * @extends {ProceduralLines}
   */
  class Rect extends ProceduralLines {
      /**
       * @member sizeXParam - Length of the rectangle along the `X` axis.
       */
      sizeXParam = new NumberParameter('SizeX', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Length of the rectangle along the `Y` axis.
       */
      sizeYParam = new NumberParameter('SizeY', 1.0, [0, Number.MAX_VALUE]);
      /**
       * Create a rect.
       * @param x - The length of the rect along the `X` axis.
       * @param y - The length of the rect along the `Y` axis.
       */
      constructor(x = 1.0, y = 1.0) {
          super();
          if (isNaN(x) || isNaN(y))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.sizeXParam.value = x;
          this.sizeYParam.value = y;
          this.rebuild();
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          this.setNumVertices(4);
          this.setNumSegments(4);
          this.setSegmentVertexIndices(0, 0, 1);
          this.setSegmentVertexIndices(1, 1, 2);
          this.setSegmentVertexIndices(2, 2, 3);
          this.setSegmentVertexIndices(3, 3, 0);
          // @ts-expect-error ts-migrate(2554) FIXME: Expected 0 arguments, but got 1.
          this.resize(false);
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const x = this.sizeXParam.value;
          const y = this.sizeYParam.value;
          const positions = this.positions;
          if (!positions)
              return;
          positions.setValue(0, new Vec3(-0.5 * x, -0.5 * y, 0.0));
          positions.setValue(1, new Vec3(0.5 * x, -0.5 * y, 0.0));
          positions.setValue(2, new Vec3(0.5 * x, 0.5 * y, 0.0));
          positions.setValue(3, new Vec3(-0.5 * x, 0.5 * y, 0.0));
      }
  }
  Registry.register('Rect', Rect);

  /**
   * A class for generating a circle shape using line segments.
   *
   * ```
   * const circle = new Circle(2.2, 12)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Radius of the circle.
   * * **Angle(`NumberParameter`):** Number of segments used to build the circle.
   * * **Sides(`NumberParameter`):** Segments angle in radiants.
   *
   * @extends {ProceduralLines}
   */
  class Circle extends ProceduralLines {
      /**
       * @member angleParam - TODO
       */
      angleParam = new AngleParameter('Angle', Math.PI * 2, [0, Math.PI * 2]);
      /**
       * @member sidesParam - The number of sides that compose the circle (e.g. 3 creates a triangle)
       */
      sidesParam = new NumberParameter('Sides', 6, [0, Number.MAX_VALUE], 1);
      /**
       * @member radiusParam - The radius of the circle
       */
      radiusParam = new NumberParameter('Radius', 1, [0, Number.MAX_VALUE]);
      /**
       * Creates an instance of Circle.
       * @param radius - The radius of the circle.
       * @param sides - The number of segments.
       * @param angle - Arc segments angle(radians)
       */
      constructor(radius = 1.0, sides = 32, angle = Math.PI * 2) {
          super();
          this.topologyParams = [];
          if (isNaN(radius) || isNaN(sides))
              throw new Error('Invalid geom args');
          this.radiusParam.value = radius;
          this.sidesParam.value = sides;
          this.angleParam.value = angle;
          this.addParameter(this.radiusParam);
          this.addParameter(this.angleParam);
          this.addParameter(this.sidesParam);
          // Note: Changes in Angle can cause the Topoloty to become closed/unclosed.
          this.topologyParams.push('Angle');
          this.topologyParams.push('Sides');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const angle = this.angleParam.value;
          const sides = Math.round(this.sidesParam.value);
          const arc = angle < Math.PI * 2;
          const numVerts = arc ? sides + 1 : sides;
          this.setNumVertices(numVerts);
          this.setNumSegments(sides);
          for (let i = 0; i < sides; i++)
              this.setSegmentVertexIndices(i, i, (i + 1) % numVerts);
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const radius = this.radiusParam.value;
          const angle = this.angleParam.value;
          const arc = angle < Math.PI * 2;
          const step = angle / (arc ? this.positions.count - 1 : this.positions.count);
          for (let i = 0; i < this.positions.count; i++) {
              this.positions.setValue(i, new Vec3(Math.cos(step * i) * radius, Math.sin(step * i) * radius, 0.0));
          }
      }
  }
  Registry.register('Circle', Circle);

  /**
   * A class for generating a cross shape, drawing a line on the `X,Y,Z` axes.
   * The axis line length is the `size` you specify, but the middle of the line is positioned in the coordinate `(0, 0, 0)` .
   * Meaning that half of the line goes negative and half goes positive.
   *
   * ```
   * const cross = new Cross(1.5)
   * ```
   *
   * **Parameters**
   * * **Size(`NumberParameter`):** Specifies the size of the cross.
   *
   * @extends {ProceduralLines}
   */
  class Cross extends ProceduralLines {
      /**
       * @member sizeParam - Specifies the size of the cross.
       */
      sizeParam = new NumberParameter('Size', 1.0, [0, Number.MAX_VALUE]);
      /**
       * Create a cross.
       * @param size - The size of the cross.
       */
      constructor(size = 1.0) {
          super();
          if (isNaN(size))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeParam);
          this.sizeParam.value = size;
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          this.setNumVertices(6);
          this.setNumSegments(3);
          this.setSegmentVertexIndices(0, 0, 1);
          this.setSegmentVertexIndices(1, 2, 3);
          this.setSegmentVertexIndices(2, 4, 5);
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const size = this.sizeParam.value;
          const positions = this.positions;
          if (!positions)
              return;
          positions.setValue(0, new Vec3(-0.5 * size, 0, 0));
          positions.setValue(1, new Vec3(0.5 * size, 0, 0));
          positions.setValue(2, new Vec3(0, 0.5 * size, 0));
          positions.setValue(3, new Vec3(0, -0.5 * size, 0));
          positions.setValue(4, new Vec3(0, 0, 0.5 * size));
          positions.setValue(5, new Vec3(0, 0, -0.5 * size));
      }
  }
  Registry.register('Cross', Cross);

  /**
   * A class for generating a lines cuboid shape(Without faces).
   *
   * **Parameters**
   * * **X(`NumberParameter`):** Length of the line cuboid along the `X` axis
   * * **Y(`NumberParameter`):** Length of the line cuboid along the `Y` axis
   * * **Z(`NumberParameter`):** Length of the line cuboid along the `Z` axis
   * * **BaseZAtZero(`NumberParameter`):** Property to start or not `Z` axis from position `0.
   *
   * @extends {ProceduralLines}
   */
  class LinesCuboid extends ProceduralLines {
      /**
       * @member baseZAtZeroParam - Property to start or not `Z` axis from position `0.
       */
      baseZAtZeroParam = new BooleanParameter('BaseZAtZero', false);
      /**
       * @member sizeXParam - Length of the line cuboid along the `X` axis
       */
      sizeXParam = new NumberParameter('SizeX', 1, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Length of the line cuboid along the `Y` axis
       */
      sizeYParam = new NumberParameter('SizeY', 1, [0, Number.MAX_VALUE]);
      /**
       * @member sizeZParam - Length of the line cuboid along the `Z` axis
       */
      sizeZParam = new NumberParameter('SizeZ', 1, [0, Number.MAX_VALUE]);
      /**
       * Create a lines cuboid.
       * @param x - The length of the line cuboid along the X axis.
       * @param y - The length of the line cuboid along the Y axis.
       * @param z - The length of the line cuboid along the Z axis.
       * @param baseZAtZero - The baseZAtZero value.
       */
      constructor(x = 1.0, y = 1.0, z = 1.0, baseZAtZero = false) {
          super();
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.addParameter(this.sizeZParam);
          this.addParameter(this.baseZAtZeroParam);
          this.sizeXParam.value = x;
          this.sizeYParam.value = y;
          this.sizeZParam.value = z;
          this.baseZAtZeroParam.value = baseZAtZero;
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          this.setNumVertices(8);
          this.setNumSegments(12);
          this.setSegmentVertexIndices(0, 0, 1);
          this.setSegmentVertexIndices(1, 1, 2);
          this.setSegmentVertexIndices(2, 2, 3);
          this.setSegmentVertexIndices(3, 3, 0);
          this.setSegmentVertexIndices(4, 4, 5);
          this.setSegmentVertexIndices(5, 5, 6);
          this.setSegmentVertexIndices(6, 6, 7);
          this.setSegmentVertexIndices(7, 7, 4);
          this.setSegmentVertexIndices(8, 0, 4);
          this.setSegmentVertexIndices(9, 1, 5);
          this.setSegmentVertexIndices(10, 2, 6);
          this.setSegmentVertexIndices(11, 3, 7);
          this.resize();
      }
      /**
       * The resize method.
       *
       * @private
       */
      resize() {
          const x = this.sizeXParam.value;
          const y = this.sizeYParam.value;
          const z = this.sizeZParam.value;
          const baseZAtZero = this.baseZAtZeroParam.value;
          const positions = this.positions;
          if (positions) {
              let zoff = 0.5;
              if (baseZAtZero)
                  zoff = 1.0;
              positions.setValue(0, new Vec3(0.5 * x, -0.5 * y, zoff * z));
              positions.setValue(1, new Vec3(0.5 * x, 0.5 * y, zoff * z));
              positions.setValue(2, new Vec3(-0.5 * x, 0.5 * y, zoff * z));
              positions.setValue(3, new Vec3(-0.5 * x, -0.5 * y, zoff * z));
              zoff = -0.5;
              if (baseZAtZero)
                  zoff = 0.0;
              positions.setValue(4, new Vec3(0.5 * x, -0.5 * y, zoff * z));
              positions.setValue(5, new Vec3(0.5 * x, 0.5 * y, zoff * z));
              positions.setValue(6, new Vec3(-0.5 * x, 0.5 * y, zoff * z));
              positions.setValue(7, new Vec3(-0.5 * x, -0.5 * y, zoff * z));
          }
      }
  }
  Registry.register('LinesCuboid', LinesCuboid);

  /**
   * A class for generating a sphere made up of 3 circles, one on each plane: XY, YZ, XZ.
   *
   * ```
   * const linesSphere = new LinesSphere(2.2, 12)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Radius of the circle.
   * * **Sides(`NumberParameter`):** Segments angle in radiants.
   *
   * @extends {ProceduralLines}
   */
  class LinesSphere extends ProceduralLines {
      /**
       * @member radiusParam - The radius of the circle
       */
      radiusParam = new NumberParameter('Radius', 6, [0, Number.MAX_VALUE]);
      /**
       * @member sidesParam - The number of sides that compose the circle (e.g. 3 creates a triangle)
       */
      sidesParam = new NumberParameter('Sides', 12, [0, Number.MAX_VALUE], 1);
      /**
       * Creates an instance of LinesSphere.
       * @param radius - The radius of the circle.
       * @param sides - The number of segments.
       * @param angle - Arc segments angle(radians)
       */
      constructor(radius = 1.0, sides = 32) {
          super();
          this.topologyParams = [];
          if (isNaN(radius) || isNaN(sides))
              throw new Error('Invalid geom args');
          this.addParameter(this.radiusParam);
          this.addParameter(this.sidesParam);
          this.radiusParam.value = radius;
          this.sidesParam.value = sides;
          this.topologyParams.push('Sides');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const segs = this.sidesParam.value;
          const numCirces = 3;
          this.setNumVertices(segs * numCirces);
          this.setNumSegments(segs * numCirces);
          const addSegments = (off) => {
              for (let i = 0; i < segs; i++)
                  this.setSegmentVertexIndices(i + off, i + off, ((i + 1) % segs) + off);
          };
          addSegments(0);
          addSegments(segs);
          addSegments(segs * 2);
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const radius = this.radiusParam.value;
          const segs = this.sidesParam.value;
          const angle = Math.PI * 2;
          const step = angle / segs;
          const positions = this.positions;
          if (positions) {
              for (let i = 0; i < segs; i++) {
                  positions.setValue(i, new Vec3(Math.cos(step * i) * radius, Math.sin(step * i) * radius, 0.0));
                  positions.setValue(i + segs, new Vec3(Math.cos(step * i) * radius, 0.0, Math.sin(step * i) * radius));
                  positions.setValue(i + segs * 2, new Vec3(0.0, Math.cos(step * i) * radius, Math.sin(step * i) * radius));
              }
          }
      }
  }
  Registry.register('LinesSphere', LinesSphere);

  /**
   * Represents a network of lines that cross each other to form a series of squares or rectangles.
   *
   * ```
   * const grid = new Grid(5, 5, 50, 50, true)
   * ```
   *
   * **Parameters**
   * * **X(`NumberParameter`):** Length of the grid along the `X` axis.
   * * **Y(`NumberParameter`):** Length of the grid along the `Y` axis.
   * * **XDivisions(`NumberParameter`):** Number of divisions along `X` axis
   * * **YDivisions(`NumberParameter`):** Number of divisions along `Y` axis
   * * **SkipCenterLines(`BooleanParameter`):** Property that indicates whether to display the center grid lines or not
   *
   * @extends {ProceduralLines}
   */
  class Grid extends ProceduralLines {
      /**
       * @member sizeXParam - Length of the grid along the `X` axis.
       */
      sizeXParam = new NumberParameter('SizeX', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Length of the grid along the `Y` axis.
       */
      sizeYParam = new NumberParameter('SizeY', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member divisionsXParam - Number of divisions along `X` axis
       */
      divisionsXParam = new NumberParameter('XDivisions', 1, [0, Number.MAX_VALUE], 1);
      /**
       * @member divisionsYParam - Number of divisions along `Y` axis
       */
      divisionsYParam = new NumberParameter('YDivisions', 1, [0, Number.MAX_VALUE], 1);
      /**
       * @member skipCenterLinesParam - Property that indicates whether to display the center grid lines or not
       */
      skipCenterLinesParam = new BooleanParameter('SkipCenterLines', false);
      /**
       * Create a grid.
       * @param x - The length of the grid along the `X` axis.
       * @param y - The length of the grid along the `Y` axis.
       * @param xDivisions - The number of divisions along `X` axis.
       * @param yDivisions - The number of divisions along `Y` axis.
       * @param skipCenterLines - A boolean indicating whether to display the center grid lines or not.
       */
      constructor(x = 1.0, y = 1.0, xDivisions = 10, yDivisions = 10, skipCenterLines = false) {
          super();
          this.topologyParams = [];
          if (isNaN(x) || isNaN(y) || isNaN(xDivisions) || isNaN(yDivisions))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.addParameter(this.divisionsXParam);
          this.addParameter(this.divisionsYParam);
          this.addParameter(this.skipCenterLinesParam);
          this.sizeXParam.value = x;
          this.sizeYParam.value = y;
          this.divisionsXParam.value = xDivisions;
          this.divisionsYParam.value = yDivisions;
          this.skipCenterLinesParam.value = skipCenterLines;
          this.topologyParams.push('XDivisions');
          this.topologyParams.push('YDivisions');
          this.topologyParams.push('SkipCenterLines');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const xDivisions = this.divisionsXParam.value;
          const yDivisions = this.divisionsYParam.value;
          const skipCenterLines = this.skipCenterLinesParam.value && xDivisions % 2 == 0 && yDivisions % 2 == 0;
          this.setNumVertices((xDivisions + yDivisions + 2 - (skipCenterLines ? 1 : 0)) * 2);
          this.setNumSegments(xDivisions + yDivisions + 2 - (skipCenterLines ? 1 : 0));
          let idx = 0;
          for (let i = 0; i <= xDivisions; i++) {
              if (skipCenterLines && i == xDivisions / 2)
                  continue;
              const v0 = idx * 2;
              const v1 = idx * 2 + 1;
              this.setSegmentVertexIndices(idx, v0, v1);
              idx++;
          }
          for (let i = 0; i <= yDivisions; i++) {
              if (skipCenterLines && i == xDivisions / 2)
                  continue;
              const v0 = idx * 2;
              const v1 = idx * 2 + 1;
              this.setSegmentVertexIndices(idx, v0, v1);
              idx++;
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const positions = this.positions;
          const xDivisions = this.divisionsXParam.value;
          const yDivisions = this.divisionsYParam.value;
          const xSize = this.sizeXParam.value;
          const ySize = this.sizeYParam.value;
          const skipCenterLines = this.skipCenterLinesParam.value && xDivisions % 2 == 0 && yDivisions % 2 == 0;
          let idx = 0;
          for (let i = 0; i <= xDivisions; i++) {
              if (skipCenterLines && i == xDivisions / 2)
                  continue;
              const v0 = idx * 2;
              const v1 = idx * 2 + 1;
              const x = (i / xDivisions - 0.5) * xSize;
              if (positions) {
                  positions.setValue(v0, new Vec3(x, -0.5 * ySize, 0.0));
                  positions.setValue(v1, new Vec3(x, 0.5 * ySize, 0.0));
              }
              idx++;
          }
          for (let i = 0; i <= yDivisions; i++) {
              if (skipCenterLines && i == xDivisions / 2)
                  continue;
              const v0 = idx * 2;
              const v1 = idx * 2 + 1;
              const y = (i / yDivisions - 0.5) * ySize;
              if (positions) {
                  positions.setValue(v0, new Vec3(-0.5 * xSize, y, 0.0));
                  positions.setValue(v1, new Vec3(0.5 * xSize, y, 0.0));
              }
              idx++;
          }
      }
  }
  Registry.register('Grid', Grid);

  /* eslint-disable no-unused-vars */
  /**
   * Represents a cone geometry.
   *
   * ```
   * const cone = new Cone(1.2, 4.0)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Specifies the radius of the base of the cone.
   * * **Height(`NumberParameter`):** Specifies the height of the cone.
   * * **Detail(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
   * * **Cap(`BooleanParameter`):** Specifies whether the base of the cone is capped or open.
   *
   * @extends {ProceduralMesh}
   */
  class Cone extends ProceduralMesh {
      /**
       * @member capParam - Specifies whether the base of the cone is capped or open.
       */
      capParam = new BooleanParameter('Cap', true);
      /**
       * @member detailParam - Specifies the number of subdivisions around the `Z` axis.
       */
      detailParam = new NumberParameter('Detail', 6, [0, Number.MAX_VALUE], 1);
      /**
       * @member heightParam - Specifies the height of the cone.
       */
      heightParam = new NumberParameter('Height', 1, [0, Number.MAX_VALUE]);
      /**
       * @member radiusParam - Specifies the radius of the base of the cone.
       */
      radiusParam = new NumberParameter('Radius', 6, [0, Number.MAX_VALUE]);
      /**
       * Create a cone.
       * @param radius - The radius of the base of the cone.
       * @param height - The height of the cone.
       * @param detail - The detail of the cone.
       * @param cap -  A boolean indicating whether the base of the cone is capped or open.
       * @param addNormals - Compute vertex normals for the geometry
       * @param addTextureCoords - Compute texture coordinates for the geometry
       */
      constructor(radius = 0.5, height = 1.0, detail = 32, cap = true, addNormals = true, addTextureCoords = true) {
          super();
          this.topologyParams = [];
          if (isNaN(radius) || isNaN(height) || isNaN(detail))
              throw new Error('Invalid geom args');
          this.radiusParam.value = radius;
          this.heightParam.value = height;
          this.detailParam.value = detail;
          this.capParam.value = cap;
          this.addParameter(this.radiusParam);
          this.addParameter(this.heightParam);
          this.addParameter(this.detailParam);
          this.addParameter(this.capParam);
          if (addNormals)
              this.addVertexAttribute('normals', new Vec3f8Attribute());
          if (addTextureCoords)
              this.addVertexAttribute('texCoords', new Vec2f16Attribute());
          this.topologyParams.push('Detail');
          this.topologyParams.push('Cap');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const nbSides = Math.round(this.detailParam.value);
          const radius = this.radiusParam.value;
          const height = this.heightParam.value;
          const cap = this.capParam.value;
          let numVertices = nbSides + 1;
          if (cap) {
              numVertices += 1;
          }
          this.setNumVertices(numVertices);
          const tipPoint = nbSides;
          const basePoint = nbSides + 1;
          // ////////////////////////////
          // Set Vertex Positions
          const positions = this.positions;
          if (positions) {
              positions.setValue(tipPoint, new Vec3(0.0, 0.0, height));
              for (let i = 0; i < nbSides; i++) {
                  const theta = -((i / nbSides) * 2.0 * Math.PI);
                  positions.setValue(i, new Vec3(radius * Math.cos(theta), radius * Math.sin(theta), 0.0));
              }
              if (cap) {
                  positions.setValue(basePoint, new Vec3(0.0, 0.0, 0.0));
              }
          }
          // ////////////////////////////
          // Build the topology
          this.setFaceCounts([nbSides + (cap ? nbSides : 0)]);
          for (let i = 0; i < nbSides; i++) {
              const j = (i + 1) % nbSides;
              this.setFaceVertexIndices(i, [j, i, tipPoint]);
          }
          if (cap) {
              for (let i = 0; i < nbSides; i++) {
                  const j = (i + 1) % nbSides;
                  this.setFaceVertexIndices(nbSides + i, [i, j, basePoint]);
              }
          }
          // ////////////////////////////
          // setUVs
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              // Now set the attrbute values
              let tri = 0;
              for (let i = 0; i < nbSides; i++) {
                  if ('setFaceVertexValue' in texCoords) {
                      texCoords.setFaceVertexValue(tri, 0, new Vec2((i + 1) / nbSides, 0.0));
                      texCoords.setFaceVertexValue(tri, 1, new Vec2(i / nbSides, 0.0));
                      texCoords.setFaceVertexValue(tri, 2, new Vec2((i + 0.5) / nbSides, 1.0));
                  }
              }
              if (cap) {
                  for (let i = 0; i < nbSides; i++) {
                      texCoords.setFaceVertexValue(tri, 0, new Vec2(i / nbSides, 0.0));
                      texCoords.setFaceVertexValue(tri, 1, new Vec2((i + 1) / nbSides, 0.0));
                      texCoords.setFaceVertexValue(tri, 2, new Vec2((i + 0.5) / nbSides, 1.0));
                      tri++;
                  }
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const nbSides = Math.round(this.detailParam.value);
          const radius = this.radiusParam.value;
          const height = this.heightParam.value;
          const tipPoint = nbSides;
          const basePoint = nbSides + 1;
          const positions = this.positions;
          if (positions) {
              positions.setValue(tipPoint, new Vec3(0.0, 0.0, height));
              for (let i = 0; i < nbSides; i++) {
                  const theta = -((i / nbSides) * 2.0 * Math.PI);
                  positions.setValue(i, new Vec3(radius * Math.cos(theta), radius * Math.sin(theta), 0.0));
              }
              if (this.capParam.value) {
                  positions.setValue(basePoint, new Vec3(0.0, 0.0, 0.0));
              }
          }
          // Note: this breaks an infinite loop where computeVertexNormals calls update which calls rebuild.
          this.dirtyTopology = false;
          this.dirtyVertices = false;
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              this.computeVertexNormals();
          }
      }
  }
  Registry.register('Cone', Cone);

  // import { Vec2 } from '../../../Math/Vec2'
  // import { Vec2Attribute } from '../Vec2Attribute'
  /**
   * A class for generating a cuboid geometry.
   *
   * **Parameters**
   * * **x(`NumberParameter`):** Length of the line cuboid along the `X` axis
   * * **y(`NumberParameter`):** Length of the line cuboid along the `Y` axis
   * * **z(`NumberParameter`):** Length of the line cuboid along the `Z` axis
   * * **BaseZAtZero(`NumberParameter`):** Property to start or not `Z` axis from position `0.
   *
   * @extends {ProceduralMesh}
   */
  class Cuboid extends ProceduralMesh {
      /**
       * @member baseZAtZeroParam - Property to start or not `Z` axis from position `0.
       */
      baseZAtZeroParam = new BooleanParameter('BaseZAtZero', false);
      /**
       * @member sizeXParam - Length of the line cuboid along the `X` axis
       */
      sizeXParam = new NumberParameter('SizeX', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Length of the line cuboid along the `Y` axis
       */
      sizeYParam = new NumberParameter('SizeY', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeZParam - Length of the line cuboid along the `Z` axis
       */
      sizeZParam = new NumberParameter('SizeZ', 1.0, [0, Number.MAX_VALUE]);
      /**
       * Create a cuboid.
       * @param x - The length of the cuboid along the X axis.
       * @param y - The length of the cuboid along the Y axis.
       * @param z - The length of the cuboid along the Z axis.
       * @param baseZAtZero - The baseZAtZero value.
       */
      constructor(x = 1.0, y = 1.0, z = 1.0, baseZAtZero = false) {
          super();
          if (isNaN(x) || isNaN(y) || isNaN(z))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.addParameter(this.sizeZParam);
          this.addParameter(this.baseZAtZeroParam);
          this.sizeXParam.value = x;
          this.sizeYParam.value = y;
          this.sizeZParam.value = z;
          this.baseZAtZeroParam.value = baseZAtZero;
          this.setFaceCounts([0, 6]);
          this.setFaceVertexIndices(0, [0, 1, 2, 3]);
          this.setFaceVertexIndices(1, [7, 6, 5, 4]);
          this.setFaceVertexIndices(2, [1, 0, 4, 5]);
          this.setFaceVertexIndices(3, [3, 2, 6, 7]);
          this.setFaceVertexIndices(4, [0, 3, 7, 4]);
          this.setFaceVertexIndices(5, [2, 1, 5, 6]);
          this.setNumVertices(8);
          this.addVertexAttribute('normals', new Vec3f8Attribute());
          // this.addVertexAttribute('texCoords', new Vec2f16Attribute())
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              for (let i = 0; i < 6; i++) {
                  let normal;
                  switch (i) {
                      case 0:
                          normal = new Vec3(0, 0, 1);
                          break;
                      case 1:
                          normal = new Vec3(0, 0, -1);
                          break;
                      case 2:
                          normal = new Vec3(1, 0, 0);
                          break;
                      case 3:
                          normal = new Vec3(-1, 0, 0);
                          break;
                      case 4:
                          normal = new Vec3(0, -1, 0);
                          break;
                      //case 5:
                      default:
                          normal = new Vec3(0, 1, 0);
                          break;
                  }
                  normals.setFaceVertexValue(i, 0, normal);
                  normals.setFaceVertexValue(i, 1, normal);
                  normals.setFaceVertexValue(i, 2, normal);
                  normals.setFaceVertexValue(i, 3, normal);
              }
          } /*
          const texCoords = <Vec2Attribute>this.getVertexAttribute('texCoords')
          if (texCoords) {
            for (let i = 0; i < 6; i++) {
              texCoords.setFaceVertexValue(i, 0, new Vec2(0, 0))
              texCoords.setFaceVertexValue(i, 1, new Vec2(1, 0))
              texCoords.setFaceVertexValue(i, 2, new Vec2(1, 1))
              texCoords.setFaceVertexValue(i, 3, new Vec2(0, 1))
            }
          }
          */
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const x = this.sizeXParam.value;
          const y = this.sizeYParam.value;
          const z = this.sizeZParam.value;
          const baseZAtZero = this.baseZAtZeroParam.value;
          let zoff = 0.5;
          const positions = this.positions;
          if (baseZAtZero)
              zoff = 1.0;
          if (!positions)
              return;
          positions.setValue(0, new Vec3(0.5 * x, -0.5 * y, zoff * z));
          positions.setValue(1, new Vec3(0.5 * x, 0.5 * y, zoff * z));
          positions.setValue(2, new Vec3(-0.5 * x, 0.5 * y, zoff * z));
          positions.setValue(3, new Vec3(-0.5 * x, -0.5 * y, zoff * z));
          zoff = -0.5;
          if (baseZAtZero)
              zoff = 0.0;
          positions.setValue(4, new Vec3(0.5 * x, -0.5 * y, zoff * z));
          positions.setValue(5, new Vec3(0.5 * x, 0.5 * y, zoff * z));
          positions.setValue(6, new Vec3(-0.5 * x, 0.5 * y, zoff * z));
          positions.setValue(7, new Vec3(-0.5 * x, -0.5 * y, zoff * z));
      }
  }
  Registry.register('Cuboid', Cuboid);

  /**
   * A class for generating a cylinder geometry. It is very much like a cuboid but with `N` number of sides.
   *
   * ```
   * const cylinder = new Cylinder(1.5, 2.0, 6)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Specifies the radius of the cylinder.
   * * **Height(`NumberParameter`):** Specifies the height of the cone.
   * * **Sides(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
   * * **Loops(`NumberParameter`):** Specifies the number of subdivisions(stacks) on the `Z` axis.
   * * **Caps(`BooleanParameter`):** Specifies whether the ends of the cylinder are capped or open.
   * * **BaseZAtZero(`BooleanParameter`):** Property to start or not `Z` axis from position `0.
   *
   * @extends {ProceduralMesh}
   */
  class Cylinder extends ProceduralMesh {
      /**
       * @member baseZAtZeroParam - Property to start or not `Z` axis from position `0.
       */
      baseZAtZeroParam = new BooleanParameter('BaseZAtZero', true);
      /**
       * @member capsParam - Specifies whether the ends of the cylinder are capped or open.
       */
      capsParam = new BooleanParameter('Caps', true);
      /**
       * @member heightParam - Specifies the height of the cone.
       */
      heightParam = new NumberParameter('Height', 1, [0, Number.MAX_VALUE]);
      /**
       * @member radiusParam - Specifies the radius of the cylinder.
       */
      radiusParam = new NumberParameter('Radius', 6, [0, Number.MAX_VALUE]);
      /**
       * @member loopsParam - Specifies the number of subdivisions(stacks) on the `Z` axis.
       */
      loopsParam = new NumberParameter('Loops', 6, [0, Number.MAX_VALUE], 1);
      /**
       * @member sidesParam - Specifies the number of subdivisions around the `Z` axis.
       */
      sidesParam = new NumberParameter('Sides', 12, [0, Number.MAX_VALUE], 1);
      /**
       * Create a cylinder.
       * @param radius - The radius of the cylinder.
       * @param height - The height of the cylinder.
       * @param sides - The number of sides.
       * @param loops - The number of loops.
       * @param caps - A boolean indicating whether the ends of the cylinder are capped or open.
       * @param baseZAtZero - The baseZAtZero value.
       */
      constructor(radius = 0.5, height = 1.0, sides = 32, loops = 2, caps = true, baseZAtZero = false, addNormals = true, addTextureCoords = true) {
          super();
          this.topologyParams = [];
          if (isNaN(radius) || isNaN(height) || isNaN(sides) || isNaN(loops))
              throw new Error('Invalid geom args');
          this.radiusParam.value = radius;
          this.heightParam.value = height;
          this.sidesParam.value = sides >= 3 ? sides : 3;
          this.loopsParam.value = loops >= 2 ? loops : 2;
          this.capsParam.value = caps;
          this.baseZAtZeroParam.value = baseZAtZero;
          this.addParameter(this.radiusParam);
          this.addParameter(this.heightParam);
          this.addParameter(this.sidesParam);
          this.addParameter(this.loopsParam);
          this.addParameter(this.capsParam);
          this.addParameter(this.baseZAtZeroParam);
          if (addNormals)
              this.addVertexAttribute('normals', new Vec2f16Attribute()); // TODO: review args/params.
          if (addTextureCoords)
              this.addVertexAttribute('texCoords', new Vec3f8Attribute());
          this.topologyParams.push('Sides');
          this.topologyParams.push('Loops');
          this.topologyParams.push('Caps');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const nbSides = Math.round(this.sidesParam.value);
          const nbLoops = Math.round(this.loopsParam.value);
          const caps = this.capsParam.value;
          let numVertices = nbSides * nbLoops;
          if (caps) {
              numVertices += 2;
          }
          this.setNumVertices(numVertices);
          if (caps)
              this.setFaceCounts([nbSides * 2, nbSides]);
          else
              this.setFaceCounts([0, nbSides]);
          // ////////////////////////////
          // Build the topology
          let faceIndex = 0;
          if (caps) {
              // Bottom caps topology
              for (let j = 0; j < nbSides; j++) {
                  const v0 = numVertices - 1;
                  const v1 = j;
                  const v2 = (j + 1) % nbSides;
                  this.setFaceVertexIndices(faceIndex++, [v0, v1, v2]);
              }
              // Top caps topology
              for (let j = 0; j < nbSides; j++) {
                  const v0 = nbSides * (nbLoops - 1) + j;
                  const v1 = numVertices - 2;
                  const v2 = nbSides * (nbLoops - 1) + ((j + 1) % nbSides);
                  this.setFaceVertexIndices(faceIndex++, [v0, v1, v2]);
              }
          }
          // build the topology for the body of the cylinder
          for (let i = 0; i < nbLoops - 1; i++) {
              for (let j = 0; j < nbSides; j++) {
                  const v0 = nbSides * i + ((j + 1) % nbSides);
                  const v1 = nbSides * i + j;
                  const v2 = nbSides * (i + 1) + j;
                  const v3 = nbSides * (i + 1) + ((j + 1) % nbSides);
                  this.setFaceVertexIndices(faceIndex++, [v0, v1, v2, v3]);
              }
          }
          // ////////////////////////////
          // setNormals
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              // Now set the attribute values
              faceIndex = 0;
              if (caps) {
                  const normal = new Vec3(0.0, 0.0, -1.0);
                  for (let i = 0; i < nbSides; i++) {
                      normals.setFaceVertexValue(faceIndex, 0, normal);
                      normals.setFaceVertexValue(faceIndex, 1, normal);
                      normals.setFaceVertexValue(faceIndex, 2, normal);
                      faceIndex++;
                  }
                  normal.set(0.0, 0.0, 1.0);
                  for (let i = 0; i < nbSides; i++) {
                      normals.setFaceVertexValue(faceIndex, 0, normal);
                      normals.setFaceVertexValue(faceIndex, 1, normal);
                      normals.setFaceVertexValue(faceIndex, 2, normal);
                      faceIndex++;
                  }
              }
              for (let i = 0; i < nbLoops - 1; i++) {
                  for (let j = 0; j < nbSides; j++) {
                      let phi = (j / nbSides) * 2.0 * Math.PI;
                      const normal1 = new Vec3(Math.sin(phi), Math.cos(phi), 0.0);
                      normals.setFaceVertexValue(faceIndex, 0, normal1);
                      normals.setFaceVertexValue(faceIndex, 1, normal1);
                      phi = ((j + 1) / nbSides) * 2.0 * Math.PI;
                      const normal2 = new Vec3(Math.sin(phi), Math.cos(phi), 0.0);
                      normals.setFaceVertexValue(faceIndex, 2, normal2);
                      normals.setFaceVertexValue(faceIndex, 3, normal2);
                      faceIndex++;
                  }
              }
          }
          // ////////////////////////////
          // setUVs
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              // Now set the attrbute values
              faceIndex = 0;
              if (caps) {
                  for (let i = 0; i < nbSides; i++) {
                      texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbSides, 0.0));
                      texCoords.setFaceVertexValue(faceIndex, 1, new Vec2((i + 1) / nbSides, 0.0));
                      texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 0.5) / nbSides, 1.0));
                      faceIndex++;
                  }
                  for (let i = 0; i < nbSides; i++) {
                      texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbSides, 0.0));
                      texCoords.setFaceVertexValue(faceIndex, 1, new Vec2((i + 1) / nbSides, 0.0));
                      texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 0.5) / nbSides, 1.0));
                      faceIndex++;
                  }
              }
              for (let i = 0; i < nbSides; i++) {
                  texCoords.setFaceVertexValue(faceIndex, 0, new Vec2((i + 1) / nbSides, 0.0));
                  texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 1) / nbSides, 1.0));
                  texCoords.setFaceVertexValue(faceIndex, 1, new Vec2(i / nbSides, 0.0));
                  texCoords.setFaceVertexValue(faceIndex, 3, new Vec2(i / nbSides, 1.0));
                  faceIndex++;
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const nbSides = Math.round(this.sidesParam.value);
          const nbLoops = Math.round(this.loopsParam.value);
          const radius = this.radiusParam.value;
          const height = this.heightParam.value;
          const caps = this.capsParam.value;
          const baseZAtZero = this.baseZAtZeroParam.value;
          let numVertices = nbSides * nbLoops;
          if (caps) {
              numVertices += 2;
          }
          let vertex = 0;
          let zoff = 0.5;
          if (baseZAtZero)
              zoff = 0.0;
          const positions = this.positions;
          if (positions) {
              for (let i = 0; i < nbLoops; i++) {
                  const z = (i / (nbLoops - 1)) * height - height * zoff;
                  for (let j = 0; j < nbSides; j++) {
                      const phi = (j / nbSides) * 2.0 * Math.PI;
                      positions.setValue(vertex, new Vec3(Math.sin(phi) * radius, Math.cos(phi) * radius, z));
                      vertex++;
                  }
              }
              if (caps) {
                  positions.setValue(numVertices - 1, new Vec3(0.0, 0.0, height * (baseZAtZero ? 0.0 : -0.5)));
                  positions.setValue(numVertices - 2, new Vec3(0.0, 0.0, height * (baseZAtZero ? 1.0 : 0.5)));
              }
          }
          this.dirtyTopology = false;
          this.dirtyVertices = false;
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              this.computeVertexNormals();
          }
      }
  }
  Registry.register('Cylinder', Cylinder);

  /**
   * A class for generating a disc geometry.
   *
   * ```
   * const disc = new Disc(2.0, 22)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Specifies the radius of the disc.
   * * **Sides(`NumberParameter`):** Specifies the resolution, or the disc subdivisions around `Z` axis.
   *
   * @extends {ProceduralMesh}
   */
  class Disc extends ProceduralMesh {
      /**
       * @member radiusParam - Specifies the radius of the disc.
       */
      radiusParam = new NumberParameter('Radius', 6, [0, Number.MAX_VALUE]);
      /**
       * @member sidesParam - Specifies the resolution, or the disc subdivisions around `Z` axis.
       */
      sidesParam = new NumberParameter('Sides', 12, [0, Number.MAX_VALUE], 1);
      /**
       * Creates an instance of Disc.
       *
       * @param radius - The radius of the disc.
       * @param sides - The number of sides.
       */
      constructor(radius = 0.5, sides = 32) {
          super();
          this.topologyParams = [];
          if (isNaN(radius) || isNaN(sides))
              throw new Error('Invalid geom args');
          this.addParameter(this.radiusParam);
          this.addParameter(this.sidesParam);
          this.radiusParam.value = radius;
          this.sidesParam.value = sides;
          this.addVertexAttribute('texCoords', new Vec2f16Attribute());
          this.addVertexAttribute('normals', new Vec3f8Attribute());
          this.topologyParams.push('Sides');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const nbSides = Math.round(this.sidesParam.value);
          this.setNumVertices(nbSides + 1);
          this.setFaceCounts([nbSides]);
          // ////////////////////////////
          // Set Vertex Positions
          const positions = this.positions;
          if (positions)
              positions.setValue(0, new Vec3(0.0, 0.0, 0.0));
          // ////////////////////////////
          // Build the topology
          for (let j = 0; j < nbSides; j++) {
              const v1 = (j % nbSides) + 1;
              const v2 = ((j + 1) % nbSides) + 1;
              this.setFaceVertexIndices(j, [0, v1, v2]);
          }
          // ////////////////////////////
          // setNormals
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              // Now set the attrbute values
              const normal = new Vec3(0, 0, 1);
              normals.setValue(0, normal);
              for (let i = 0; i < nbSides; i++) {
                  normals.setValue(i + 1, normal);
              }
          }
          // ////////////////////////////
          // setUVs
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              texCoords.setValue(0, new Vec2(0.5, 0.5));
              for (let i = 0; i < nbSides; i++) {
                  const phi = (i / nbSides) * 2.0 * Math.PI;
                  texCoords.setValue(i + 1, new Vec2(Math.sin(phi) * 0.5 + 0.5, Math.cos(phi) * 0.5 + 0.5));
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const nbSides = Math.round(this.sidesParam.value);
          const radius = this.radiusParam.value;
          const positions = this.positions;
          if (positions) {
              for (let i = 0; i < nbSides; i++) {
                  const phi = (i / nbSides) * 2.0 * Math.PI;
                  positions.setValue(i + 1, new Vec3(Math.sin(phi) * radius, Math.cos(phi) * radius, 0.0));
              }
          }
      }
  }
  Registry.register('Disc', Disc);

  /**
   * A class for generating a plane geometry.
   *
   * ```
   * const plane = new Plane(2.0, 1.5, 10, 10)
   * ```
   *
   * **Parameters**
   * * **SizeX(`NumberParameter`):** Length of the plane along `X` axis.
   * * **SizeY(`NumberParameter`):** Length of the plane along `Y` axis.
   * * **DetailX(`NumberParameter`):** Number of divisions along `X`axis.
   * * **DetailY(`NumberParameter`):** Number of divisions along `Y`axis.
   *
   * @extends {ProceduralMesh}
   */
  class Plane extends ProceduralMesh {
      /**
       * @member sizeXParam - Number of divisions along `X`axis.
       */
      sizeXParam = new NumberParameter('SizeX', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sizeYParam - Number of divisions along `Y`axis.
       */
      sizeYParam = new NumberParameter('SizeY', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member detailXParam - Length of the plane along `X` axis.
       */
      detailXParam = new NumberParameter('DetailX', 1, [0, Number.MAX_VALUE], 1);
      /**
       * @member detailYParam - Length of the plane along `Y` axis.
       */
      detailYParam = new NumberParameter('DetailY', 1, [0, Number.MAX_VALUE], 1);
      /**
       * Create a plane.
       * @param SizeX - The length of the plane along the X axis.
       * @param SizeY - The length of the plane along the Y axis.
       * @param DetailX - The number of divisions along the X axis.
       * @param DetailY - The number of divisions along the Y axis.
       * @param addNormals - The addNormals value.
       * @param addTextureCoords - The addTextureCoords value.
       */
      constructor(SizeX = 1.0, SizeY = 1.0, DetailX = 1, DetailY = 1, addNormals = true, addTextureCoords = true) {
          super();
          this.topologyParams = [];
          if (isNaN(SizeX) || isNaN(SizeY) || isNaN(DetailX) || isNaN(DetailY))
              throw new Error('Invalid geom args');
          this.addParameter(this.sizeXParam);
          this.addParameter(this.sizeYParam);
          this.addParameter(this.detailXParam);
          this.addParameter(this.detailYParam);
          this.sizeXParam.value = SizeX;
          this.sizeYParam.value = SizeY;
          this.detailXParam.value = DetailX;
          this.detailYParam.value = DetailY;
          if (addNormals)
              this.addVertexAttribute('normals', new Vec3f8Attribute());
          if (addTextureCoords)
              this.addVertexAttribute('texCoords', new Vec2f16Attribute());
          this.topologyParams.push('DetailX');
          this.topologyParams.push('DetailY');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const detailX = this.detailXParam.value;
          const detailY = this.detailYParam.value;
          this.setNumVertices((detailX + 1) * (detailY + 1));
          this.setFaceCounts([0, detailX * detailY]);
          let quadId = 0;
          for (let i = 0; i < detailY; i++) {
              for (let j = 0; j < detailX; j++) {
                  const v0 = (detailX + 1) * (i + 1) + j;
                  const v1 = (detailX + 1) * i + j;
                  const v2 = (detailX + 1) * i + (j + 1);
                  const v3 = (detailX + 1) * (i + 1) + (j + 1);
                  this.setFaceVertexIndices(quadId, [v0, v1, v2, v3]);
                  quadId = quadId + 1;
              }
          }
          let voff = 0;
          const normals = this.getVertexAttribute('normals');
          if (normals) {
              for (let i = 0; i <= detailY; i++) {
                  for (let j = 0; j <= detailX; j++) {
                      normals.setValue(voff, new Vec3(0, 0, 1));
                      voff++;
                  }
              }
          }
          voff = 0;
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              for (let i = 0; i <= detailY; i++) {
                  const y = i / detailY;
                  for (let j = 0; j <= detailX; j++) {
                      const x = j / detailX;
                      texCoords.setValue(voff, new Vec2(x, y));
                      voff++;
                  }
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       *
       * @private
       */
      resize() {
          const sizeX = this.sizeXParam.value;
          const sizeY = this.sizeYParam.value;
          const detailX = this.detailXParam.value;
          const detailY = this.detailYParam.value;
          const positions = this.positions;
          if (!positions)
              return;
          let voff = 0;
          for (let i = 0; i <= detailY; i++) {
              const y = (i / detailY - 0.5) * sizeY;
              for (let j = 0; j <= detailX; j++) {
                  const x = (j / detailX - 0.5) * sizeX;
                  positions.setValue(voff, new Vec3(x, y, 0.0));
                  voff++;
              }
          }
      }
  }
  Registry.register('Plane', Plane);

  /**
   * A class for generating a sphere geometry.
   *
   * ```
   * const sphere = new Sphere(1.4, 13)
   * ```
   *
   * **Parameters**
   * * **Radius(`NumberParameter`):** Radius of the sphere.
   * * **Sides(`NumberParameter`):** Specifies the number of subdivisions around the `Z` axis.
   * * **Loops(`NumberParameter`):** Specifies the number of subdivisions(stacks) along the `Z` axis.
   *
   * @extends {ProceduralMesh}
   */
  class Sphere extends ProceduralMesh {
      /**
       * @member radiusParam - Radius of the sphere.
       */
      radiusParam = new NumberParameter('Radius', 1.0, [0, Number.MAX_VALUE]);
      /**
       * @member sidesParam - Specifies the number of subdivisions around the `Z` axis.
       */
      sidesParam = new NumberParameter('Sides', 12, [0, Number.MAX_VALUE], 1);
      /**
       * @member loopsParam - Specifies the number of subdivisions(stacks) along the `Z` axis.
       */
      loopsParam = new NumberParameter('Loops', 6, [0, Number.MAX_VALUE], 1);
      /**
       * Creates an instance of Sphere.
       * @param radius - The radius of the sphere.
       * @param sides - The number of sides.
       * @param loops - The number of loops.
       * @param addNormals - Compute vertex normals for the geometry
       * @param addTextureCoords - Compute texture coordinates for the geometry
       */
      constructor(radius = 1.0, sides = 12, loops = 12, addNormals = true, addTextureCoords = true) {
          super();
          if (isNaN(radius) || isNaN(sides) || isNaN(loops))
              throw new Error('Invalid geom args');
          this.addParameter(this.radiusParam);
          this.addParameter(this.sidesParam);
          this.addParameter(this.loopsParam);
          this.radiusParam.value = radius;
          this.sidesParam.value = sides;
          this.loopsParam.value = loops;
          if (addNormals)
              this.addVertexAttribute('normals', new Vec3f8Attribute());
          if (addTextureCoords)
              this.addVertexAttribute('texCoords', new Vec2f16Attribute());
          this.topologyParams.push('Sides');
          this.topologyParams.push('Loops');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const radius = this.radiusParam.value;
          const nbSides = Math.round(this.sidesParam.value);
          const nbLoops = Math.round(this.loopsParam.value);
          const numVertices = 2 + nbSides * nbLoops;
          const numTris = nbSides * 2;
          const numQuads = nbSides * nbLoops;
          this.setNumVertices(numVertices);
          this.setFaceCounts([numTris, numQuads]);
          // ////////////////////////////
          // Set Vertex Positions
          const positions = this.positions;
          const normals = this.getVertexAttribute('normals');
          const normal = new Vec3(0.0, 0.0, 1.0);
          let vertex = 0;
          if (!positions)
              return;
          positions.setValue(vertex, new Vec3(0.0, 0.0, radius));
          if (normals)
              normals.setValue(vertex, new Vec3(0.0, 0.0, 1.0));
          vertex++;
          for (let i = 0; i < nbLoops; i++) {
              const theta = ((i + 1) / (nbLoops + 1)) * Math.PI;
              for (let j = 0; j < nbSides; j++) {
                  const phi = -((j / nbSides) * 2.0 * Math.PI);
                  normal.set(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));
                  // Set positions and normals at the same time.
                  positions.setValue(vertex, normal.scale(radius));
                  if (normals)
                      normals.setValue(vertex, normal);
                  vertex++;
              }
          }
          positions.setValue(vertex, new Vec3(0.0, 0.0, -radius));
          if (normals)
              normals.setValue(vertex, new Vec3(0.0, 0.0, -1.0));
          vertex++;
          // ////////////////////////////
          // Build the topology
          const texCoords = this.getVertexAttribute('texCoords');
          // build the fan at the first pole.
          let faceIndex = 0;
          for (let j = 0; j < nbSides; j++) {
              const v0 = 0;
              const v1 = ((j + 1) % nbSides) + 1;
              const v2 = j + 1;
              this.setFaceVertexIndices(faceIndex, [v0, v1, v2]);
              if (texCoords) {
                  const uv0 = new Vec2(0.5, 0.0);
                  const uv1 = new Vec2((j + 1) / (nbSides - 1), 1 / (nbLoops + 1));
                  const uv2 = new Vec2(j / (nbSides - 1), 1 / (nbLoops + 1));
                  texCoords.setFaceVertexValue(faceIndex, 0, uv0);
                  texCoords.setFaceVertexValue(faceIndex, 1, uv1);
                  texCoords.setFaceVertexValue(faceIndex, 2, uv2);
              }
              faceIndex++;
          }
          // Build the fan at the second pole.
          for (let j = 0; j < nbSides; j++) {
              const v0 = numVertices - 1;
              const v2 = nbSides * (nbLoops - 1) + ((j + 1) % nbSides) + 1;
              const v1 = nbSides * (nbLoops - 1) + j + 1;
              this.setFaceVertexIndices(faceIndex, [v0, v1, v2]);
              if (texCoords) {
                  const uv0 = new Vec2(0.5, 1.0);
                  const uv1 = new Vec2((j + 1) / (nbSides - 1), 1 - 1 / (nbLoops + 1));
                  const uv2 = new Vec2(j / (nbSides - 1), 1 - 1 / (nbLoops + 1));
                  texCoords.setFaceVertexValue(faceIndex, 0, uv0);
                  texCoords.setFaceVertexValue(faceIndex, 1, uv1);
                  texCoords.setFaceVertexValue(faceIndex, 2, uv2);
              }
              faceIndex++;
          }
          for (let i = 0; i < nbLoops - 1; i++) {
              for (let j = 0; j < nbSides; j++) {
                  const v0 = nbSides * i + j + 1;
                  const v1 = nbSides * i + ((j + 1) % nbSides) + 1;
                  const v2 = nbSides * (i + 1) + ((j + 1) % nbSides) + 1;
                  const v3 = nbSides * (i + 1) + j + 1;
                  this.setFaceVertexIndices(faceIndex, [v0, v1, v2, v3]);
                  if (texCoords) {
                      texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(j / nbSides, (i + 1) / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 1, new Vec2((j + 1) / nbSides, (i + 1) / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((j + 1) / nbSides, (i + 2) / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 3, new Vec2(j / nbSides, (i + 2) / nbLoops));
                  }
                  faceIndex++;
              }
          }
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const radius = this.radiusParam.value;
          const nbSides = Math.round(this.sidesParam.value);
          const nbLoops = Math.round(this.loopsParam.value);
          if (!nbSides || !nbLoops) {
              console.warn('resize() failed');
              return;
          }
          // ////////////////////////////
          // Set Vertex Positions
          const positions = this.positions;
          const normals = this.getVertexAttribute('normals');
          let vertex = 0;
          const normal = new Vec3(0.0, 0.0, 1.0);
          positions.setValue(vertex, new Vec3(0.0, 0.0, radius));
          if (normals)
              normals.setValue(vertex, new Vec3(0.0, 0.0, 1.0));
          vertex++;
          for (let i = 0; i < nbLoops; i++) {
              const theta = ((i + 1) / (nbLoops + 1)) * Math.PI;
              for (let j = 0; j < nbSides; j++) {
                  const phi = -((j / nbSides) * 2.0 * Math.PI);
                  normal.set(Math.sin(theta) * Math.cos(phi), Math.sin(theta) * Math.sin(phi), Math.cos(theta));
                  // Set positions and normals at the same time.
                  positions.setValue(vertex, normal.scale(radius));
                  if (normals)
                      normals.setValue(vertex, normal);
                  vertex++;
              }
          }
          positions.setValue(vertex, new Vec3(0.0, 0.0, -radius));
          if (normals)
              normals.setValue(vertex, new Vec3(0.0, 0.0, -1.0));
          vertex++;
      }
  }
  Registry.register('Sphere', Sphere);

  /**
   * A class for generating a torus geometry.
   *
   * ```
   * const torus = new Torus(0.4, 1.3)
   * ```
   *
   * @extends ProceduralMesh
   */
  class Torus extends ProceduralMesh {
      innerRadiusParam = new NumberParameter('InnerRadius', 1, [0, Number.MAX_VALUE]);
      outerRadiusParam = new NumberParameter('OuterRadius', 1, [0, Number.MAX_VALUE]);
      arcAngleParam = new AngleParameter('ArcAngle', Math.PI * 2, [0, Math.PI * 2]);
      detailParam = new NumberParameter('Detail', 12, [0, Number.MAX_VALUE], 1);
      /**
       * Creates an instance of Torus.
       *
       * @param innerRadius - The inner radius of the torus.
       * @param outerRadius - The outer radius of the torus.
       * @param detail - The detail of the cone.
       * @param arcAngle - The angle of the arc.
       */
      constructor(innerRadius = 0.5, outerRadius = 3, detail = 32, arcAngle = Math.PI * 2.0) {
          super();
          if (isNaN(innerRadius) || isNaN(outerRadius) || isNaN(detail))
              throw new Error('Invalid geom args');
          this.addParameter(this.innerRadiusParam);
          this.addParameter(this.outerRadiusParam);
          this.addParameter(this.arcAngleParam);
          this.addParameter(this.detailParam);
          this.innerRadiusParam.value = innerRadius;
          this.outerRadiusParam.value = outerRadius;
          this.detailParam.value = detail >= 3 ? detail : 33;
          this.arcAngleParam.value = arcAngle;
          this.addVertexAttribute('texCoords', new Vec2f16Attribute());
          this.addVertexAttribute('normals', new Vec3f8Attribute());
          this.topologyParams.push('Detail');
          this.topologyParams.push('ArcAngle');
      }
      /**
       * The rebuild method.
       * @private
       */
      rebuild() {
          const arcAngle = this.arcAngleParam.value;
          const open = arcAngle < 2.0 * Math.PI;
          const detail = Math.round(this.detailParam.value);
          const nbSlices = detail;
          const nbLoops = detail * 2 + (open ? 1 : 0);
          const numVertices = nbSlices * nbLoops;
          this.setNumVertices(numVertices);
          this.setFaceCounts([0, nbSlices * nbLoops]);
          // ////////////////////////////
          // Build the topology and texCoords
          const texCoords = this.getVertexAttribute('texCoords');
          if (texCoords) {
              let faceIndex = 0;
              for (let i = 0; i < (open ? nbLoops - 1 : nbLoops); i++) {
                  for (let j = 0; j < nbSlices; j++) {
                      const ip = (i + 1) % nbLoops;
                      const jp = (j + 1) % nbSlices;
                      const v0 = nbSlices * i + j;
                      const v1 = nbSlices * i + jp;
                      const v2 = nbSlices * ip + jp;
                      const v3 = nbSlices * ip + j;
                      this.setFaceVertexIndices(faceIndex, [v0, v1, v2, v3]);
                      texCoords.setFaceVertexValue(faceIndex, 0, new Vec2(i / nbLoops, j / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 1, new Vec2(i / nbLoops, (j + 1) / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 2, new Vec2((i + 1) / nbLoops, (j + 1) / nbLoops));
                      texCoords.setFaceVertexValue(faceIndex, 3, new Vec2((i + 1) / nbLoops, j / nbLoops));
                      faceIndex++;
                  }
              }
          }
          this.resize();
      }
      /**
       * The resize method.
       * @private
       */
      resize() {
          const innerRadius = this.innerRadiusParam.value;
          const outerRadius = this.outerRadiusParam.value;
          const arcAngle = this.arcAngleParam.value;
          const detail = Math.round(this.detailParam.value);
          const open = arcAngle < 2.0 * Math.PI;
          const nbSlices = detail;
          const nbLoops = detail * 2 + (open ? 1 : 0);
          const positions = this.positions;
          const normals = this.getVertexAttribute('normals');
          if (!positions || !normals)
              return;
          let vertex = 0;
          for (let i = 0; i < nbLoops; i++) {
              // const theta = (i / nbLoops) * arcAngle
              const theta = -((i / (open ? nbLoops - 1 : nbLoops)) * arcAngle);
              const ctheta = Math.cos(theta);
              const stheta = Math.sin(theta);
              for (let j = 0; j < nbSlices; j++) {
                  const phi = (j / nbSlices) * 2.0 * Math.PI;
                  const sphi = Math.sin(phi);
                  const cphi = Math.cos(phi);
                  const d = outerRadius + cphi * innerRadius;
                  // Set positions and normals at the same time.
                  positions.setValue(vertex, new Vec3(ctheta * d, stheta * d, innerRadius * sphi));
                  normals.setValue(vertex, new Vec3(ctheta * cphi, stheta * cphi, sphi));
                  vertex++;
              }
          }
      }
  }
  Registry.register('Torus', Torus);

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /** Class representing a geometry parameter.
   * @extends Parameter
   * @private
   */
  class GeometryParameter extends Parameter {
      listenerIDs = {};
      /**
       * Create a geometry parameter.
       * @param name - The name of the color parameter.
       * @param value - The value of the parameter.
       */
      constructor(name = '', value = null) {
          super(name, null, 'Geometry');
          if (value)
              this.setValue(value);
      }
      emitBoundingBoxDirtied(event) {
          this.emit('boundingBoxChanged', event);
      }
      /**
       * The setValue method.
       * @param value - The geom value.
       */
      setValue(value) {
          if (value != null && !(value instanceof BaseGeom) && !(value instanceof BaseProxy)) {
              throw new Error(`value provided is not an instance of a 'BaseGeom' or 'BaseProxy' class. Check the source of this value`);
          }
          // 0 == normal set. 1 = changed via cleaner fn, 2 = change by loading/cloning code.
          if (this.__value !== value) {
              if (this.__value) {
                  if (this.__value instanceof BaseGeom)
                      this.__value.setOwner(null);
                  this.__value.off('boundingBoxChanged', this.listenerIDs['boundingBoxChanged']);
              }
              this.__value = value;
              if (this.__value instanceof BaseGeom)
                  this.__value.setOwner(this);
              this.listenerIDs['boundingBoxChanged'] = this.__value.on('boundingBoxChanged', (event) => {
                  this.emitBoundingBoxDirtied(event);
              });
              this.emit('valueChanged');
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The loadValue is used to change the value of a parameter, without triggering a
       * valueChanges, or setting the USER_EDITED state.
       *
       * @param value - The context value.
       */
      loadValue(value) {
          this.setValue(value);
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const j = {
              type: this.getClassName(),
              name: this.name,
          };
          const geom = this.__value;
          if (geom instanceof BaseProxy) {
              j.libraryIndex = geom.libraryIndex;
          }
          else {
              j.value = geom?.toJSON(context);
          }
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context) {
          if (j.name)
              this.name = j.name;
          if (j.libraryIndex != undefined) {
              const geomLibrary = context.assetItem.geomLibrary;
              const newGeom = geomLibrary.getGeom(j.libraryIndex);
              this.setValue(newGeom);
          }
          else if (j.value != undefined) {
              if (!this.value || this.value.getClassName() != j.value.type) {
                  const newGeom = Registry.constructClass(j.value.type);
                  newGeom.fromJSON(j.value, context);
                  this.setValue(newGeom);
              }
              else {
                  this.value.fromJSON(j.value, context);
                  this.emit('valueChanged');
              }
          }
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new geometry parameter, copies its values
       * from this parameter and returns it.
       * @return - Returns a new geometry parameter.
       */
      clone() {
          const clonedParam = new GeometryParameter(this.name, this.__value);
          return clonedParam;
      }
  }
  Registry.register('GeometryParameter', GeometryParameter);

  // let ResourceLoaderWorker = require("worker-loader?inline!./ResourceLoaderWorker.js");
  /**
   * Represents a BaseImage with the ability to load data.
   *
   * **Events**
   * * **loaded:** Triggered when the data is loaded.
   * * **updated:** Triggered when the data is updated.
   * @extends BaseImage
   */
  class DataImage extends BaseImage {
      __data = new Uint8Array(4);
      /**
       * Create a data image.
       * @param name - The name value.
       */
      constructor(name) {
          super(name);
          this.format = 'RGBA';
          this.type = 'UNSIGNED_BYTE';
          // this.__data = new Uint8Array(4);
          this.width = 1;
          this.height = 1;
      }
      /**
       * Returns an indicator of current item's loaded state.
       * @return - `true` if bytes data is fully loaded, `false` otherwise.
       */
      isLoaded() {
          return this.loaded;
      }
      // TODO: video / webcam will return true.
      /**
       * Images are static content, so the value for this method is always going to be `false`
       *
       * @return - The return value.
       */
      isStream() {
          return false;
      }
      /**
       * Sets Image's data by recieving an bytes array.
       *
       * @param width - The width value.
       * @param height - The height value.
       * @param data - The data value.
       */
      setData(width, height, data) {
          if (this.__data == data)
              return;
          this.width = width;
          this.height = height;
          this.__data = data;
          if (!this.loaded) {
              this.loaded = true;
              this.emit('loaded');
          }
          else
              this.emit('updated');
      }
      /**
       * Returns all parameters and class state values(Including data).
       *
       * @return - The return value.
       */
      getParams() {
          const params = super.getParams();
          params['data'] = this.__data;
          return params;
      }
  }
  Registry.register('DataImage2D', DataImage);
  Registry.register('DataImage', DataImage);

  // Cache of any images already loaded.
  const imageDataLibrary$1 = {};
  /** Class representing a file image.
   * @extends BaseImage
   */
  class FileImage extends BaseImage {
      crossOrigin;
      url;
      __data = null;
      /**
       * Create a file image.
       * @param name - The name value.
       * @param filePath - The filePath value.
       * @param params - The params value.
       */
      constructor(name, filePath = '', params = {}) {
          super(name);
          this.type = 'UNSIGNED_BYTE';
          this.crossOrigin = 'anonymous';
          if (filePath && filePath != '')
              this.load(filePath);
      }
      /**
       * Defines how to handle cross origin request.
       *
       * **Possible values:**
       * * **anonymous** - CORS requests for this element will have the credentials flag set to 'same-origin'.
       * * **use-credentials** - CORS requests for this element will have the credentials flag set to 'include'.
       * * **""** - Setting the attribute name to an empty value, like crossorigin or crossorigin="", is the same as anonymous.
       *
       * @default anonymous
       * @param crossOrigin - The crossOrigin value.
       */
      setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
      }
      /**
       * Returns the HTML DOM element used to load the image file.
       * Be
       * @returns { HTMLImageElement | null }
       */
      getDOMElement() {
          return this.__data;
      }
      /**
       * Uses the specify url to load an Image element and adds it to the data library.
       * Sets the state of the current object.
       *
       * @param url - The url value.
       * @param format - The format value.
       * @return Returns a promise that resolves once the image is loaded.
       */
      load(url, format = 'RGB') {
          return new Promise((resolve, reject) => {
              if (!format) {
                  // Try to guess the format from the
                  const suffixSt = url.lastIndexOf('.');
                  if (suffixSt != -1) {
                      const ext = url.substring(suffixSt).toLowerCase();
                      if (ext == '.png') {
                          // TODO: Check webp for alpha channel..
                          format = 'RGBA';
                      }
                  }
              }
              this.format = format;
              this.loaded = false;
              const loaded = () => {
                  this.url = url;
                  this.width = this.__data.width;
                  this.height = this.__data.height;
                  this.loaded = true;
                  this.emit('loaded');
                  resolve();
              };
              if (url in imageDataLibrary$1) {
                  this.__data = imageDataLibrary$1[url];
                  if (this.__data.complete) {
                      loaded();
                  }
                  else {
                      this.__data.addEventListener('load', loaded);
                      this.__data.addEventListener('error', reject);
                  }
              }
              else {
                  this.__data = new Image();
                  this.__data.crossOrigin = this.crossOrigin;
                  this.__data.src = url;
                  this.__data.addEventListener('load', loaded);
                  this.__data.addEventListener('error', reject);
                  imageDataLibrary$1[url] = this.__data;
              }
          });
      }
      /**
       * Loads in Image file using the given URL
       *
       * @param url - The url value.
       * @param format - The format value. Can be 'RGB' or 'RGBA' for files that contain an alpha channel. This will cause objects to be drawn using the Transparent pass.
       */
      setImageURL(url, format = 'RGB') {
          this.load(url, format);
      }
      /**
       * The getParams method.
       * @return - The return value.
       */
      getParams() {
          const params = super.getParams();
          if (this.loaded) {
              params['data'] = this.__data;
          }
          return params;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The readBinary method.
       * @param reader - The reader param.
       * @param context - The context param.
       */
      readBinary(reader, context) {
          // super.readBinary(reader, context);
          this.setName(reader.loadStr());
          const filePath = reader.loadStr();
          if (typeof filePath === 'string' && filePath != '') {
              const basePath = context.url.substring(0, context.url.lastIndexOf('/'));
              this.load(basePath + '/' + filePath);
          }
      }
  }
  /** Class representing a 2D file image.
   * @extends FileImage
   */
  class FileImage2D extends FileImage {
      /**
       * Create a file image 2D.
       * @param filePath - The filePath value.
       * @param params - The params value.
       */
      constructor(filePath, params = {}) {
          console.warn('FileImage2D is becoming deprecated in favor of simple FileImage');
          super(filePath, params);
      }
  }
  Registry.register('FileImage2D', FileImage);
  Registry.register('FileImage', FileImage);

  /* eslint-disable require-jsdoc */
  /**
   * Class representing a LDR (low dynamic range) image.
   *
   * ```
   * const image = new LDRImage()
   * image.load("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.png")
   * ```
   *
   * **Parameters**
   * * **PreferredSize(`NumberParameter`):** _todo_
   *
   * **Events:**
   * * **loaded:** Triggered when image data is loaded.
   *
   * **File Types:** jpg, jpeg, png
   *
   * @extends FileImage
   */
  class LDRImage extends FileImage {
      /**
       * Create a LDR image.
       * @param name - The name value.
       * @param filePath - The filePath value.
       * @param params - The params value.
       */
      constructor(name, filePath, params) {
          super(name, filePath, params);
      }
  }
  Registry.register('LDRImage', LDRImage);

  /**
   * Class representing a VLH image.
   *
   * **Events**
   * * **loaded:** Triggered when image data is loaded.
   * * **updated:** Triggered when image data is updated.
   *
   * @extends BaseImage
   */
  class HDRImage extends BaseImage {
      exposure = 1.0;
      hdrTint = new Color(1, 1, 1, 1);
      __data;
      /**
       * Create a VLH image.
       * @param name - The name value.
       * @param params - The params value.
       */
      constructor(name, params = {}) {
          super(name); // TODO: used to be: super(name, params)
          let filepath;
          if (name != undefined && name.includes('.')) {
              filepath = name;
              this.setName(name.substring(name.lastIndexOf('/') + 1, name.lastIndexOf('.')));
          }
          this.type = 'HDR';
          if (filepath) {
              this.load(filepath);
          }
      }
      /**
       * The __decodeData method.
       * @param entries - The entries value.
       * @private
       */
      __decodeData(entries) {
          return new Promise((resolve, reject) => {
              const ldr = entries.ldr;
              const cdm = entries.cdm;
              // ///////////////////////////////
              // Parse the data.
              const blob = new Blob([ldr.buffer]);
              const ldrPic = new Image();
              ldrPic.onload = () => {
                  this.width = ldrPic.width;
                  this.height = ldrPic.height;
                  // console.log(resourcePath + ": [" + this.width + ", " + this.height + "]");
                  this.__data = {
                      ldr: ldrPic,
                      cdm: cdm,
                  };
                  if (!this.loaded) {
                      this.loaded = true;
                      this.emit('loaded');
                  }
                  else {
                      this.emit('updated');
                  }
                  resolve();
              };
              ldrPic.src = URL.createObjectURL(blob);
          });
      }
      /**
       * Loads a vlh file given a URL.
       * @param url - The URL of the vlh file to load
       * @return - Returns a promise that resolves once the initial load is complete
       */
      load(url) {
          this.loaded = false;
          return new Promise((resolve, reject) => {
              const filename = url.lastIndexOf('/') > -1 ? url.substring(url.lastIndexOf('/') + 1) : '';
              const stem = filename.substring(0, filename.lastIndexOf('.'));
              if (this.getName() == '') {
                  this.setName(stem);
              }
              this.type = 'FLOAT';
              resourceLoader.loadFile('archive', url).then((entries) => {
                  if (!entries.ldr || !entries.cdm) {
                      for (const name in entries) {
                          if (name.endsWith('.jpg')) {
                              entries.ldr = entries[name];
                              delete entries[name];
                          }
                          else if (name.endsWith('.bin')) {
                              entries.cdm = entries[name];
                              delete entries[name];
                          }
                      }
                  }
                  this.__decodeData(entries).then(() => {
                      resolve();
                  });
              }, (error) => {
                  this.emit('error', error);
                  reject(error);
              });
          });
      }
      /**
       * Returns if the data is a stream or not.
       *
       * @return - The return value.
       */
      isStream() {
          return false;
      }
      /**
       * Returns all parameters and class state values.
       *
       * @return - The return value.
       */
      getParams() {
          const params = super.getParams();
          if (this.loaded) {
              params['data'] = this.__data;
              params['exposure'] = this.exposure;
          }
          return params;
      }
      /**
       * The setHDRTint method.
       * @private
       * @param hdrTint - The hdrTint value.
       */
      setHDRTint(hdrTint) {
          this.hdrTint = hdrTint;
      }
      /**
       * The getHDRTint method.
       * @private
       * @return - The return value.
       */
      getHDRTint() {
          return this.hdrTint;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current Image using a binary reader object, and adds it to the resource loader.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          // super.readBinary(reader, context);
          this.setName(reader.loadStr());
          let url = reader.loadStr();
          if (typeof url === 'string' && url != '') {
              this.load(url);
          }
      }
  }
  Registry.register('HDRImage', HDRImage);

  /**
   * Class representing a LDR (low dynamic range) video.
   *
   * ```
   * const video = new LDRVideo()
   * video.load("https://storage.googleapis.com/zea-playground-assets/zea-engine/video.mp4")
   * ```
   *
   * **Parameters**
   * * **Mute(`BooleanParameter`):** Mutes video volume.
   * * **Loop(`BooleanParameter`):** Repeats video over and over again.
   * * **Gain(`NumberParameter`):** Sets loudness of the video before going through any processing.
   * * **SpatializeAudio(`BooleanParameter`):** Enables/Disables spatial(Surrounding) audio.
   * * **refDistance(`NumberParameter`):** _todo_
   * * **maxDistance(`NumberParameter`):** _todo_
   * * **rolloffFactor(`NumberParameter`):** _todo_
   * * **coneInnerAngle(`NumberParameter`):** _todo_
   * * **coneOuterAngle(`NumberParameter`):** _todo_
   * * **coneOuterGain(`NumberParameter`):** _todo_
   *
   * **File Types:** mp4, ogg
   *
   * @extends FileImage
   */
  class LDRVideo extends FileImage {
      videoElem = new HTMLVideoElement();
      muteParam = new BooleanParameter('Mute', false);
      loopParam = new BooleanParameter('Loop', true);
      spatializeAudioParam = new BooleanParameter('SpatializeAudio', true);
      refDistanceParam = new NumberParameter('refDistance', 2);
      maxDistanceParam = new NumberParameter('maxDistance', 10000);
      rolloffFactorParam = new NumberParameter('rolloffFactor', 1);
      coneInnerAngleParam = new NumberParameter('coneInnerAngle', 360);
      coneOuterAngleParam = new NumberParameter('coneOuterAngle', 0);
      coneOuterGainParam = new NumberParameter('coneOuterGain', 1);
      gainParam = new NumberParameter('Gain', 2.0);
      /**
       * Create a LDR video.
       * @param name - The name value.
       * @param filePath - The filePath value.
       * @param params - The params value.
       */
      constructor(name, filePath, params) {
          super(name, filePath, params);
          this.format = 'RGB';
          this.type = 'UNSIGNED_BYTE';
          this.addParameter(this.muteParam);
          this.addParameter(this.loopParam);
          this.addParameter(this.spatializeAudioParam);
          this.addParameter(this.refDistanceParam);
          this.addParameter(this.maxDistanceParam);
          this.addParameter(this.rolloffFactorParam);
          this.addParameter(this.coneInnerAngleParam);
          this.addParameter(this.coneOuterAngleParam);
          this.addParameter(this.coneOuterGainParam);
          this.addParameter(this.gainParam).setRange([0, 5]);
      }
      getAudioSource() {
          return this.videoElem;
      }
      /**
       * Uses the specify url to load an Image element and adds it to the data library.
       * Sets the state of the current object.
       *
       * @param url - The url value.
       * @param format - The format value.
       * @return Returns a promise that resolves once the image is loaded.
       */
      load(url, format = 'RGB') {
          return new Promise((resolve, reject) => {
              resourceLoader.incrementWorkload(1);
              // TODO - confirm its necessary to add to DOM
              this.videoElem.style.display = 'none';
              this.videoElem.preload = 'auto';
              this.videoElem.crossOrigin = 'anonymous';
              // videoElem.crossorigin = true;
              document.body.appendChild(this.videoElem);
              this.videoElem.addEventListener('loadedmetadata', () => {
                  // videoElem.play();
                  this.videoElem.muted = this.muteParam.value;
                  this.muteParam.on('valueChanged', () => {
                      this.videoElem.muted = this.muteParam.value;
                  });
                  this.videoElem.loop = this.loopParam.value;
                  this.loopParam.on('valueChanged', () => {
                      this.videoElem.loop = this.loopParam.value;
                  });
                  this.width = this.videoElem.videoHeight;
                  this.height = this.videoElem.videoWidth;
                  this.loaded = true;
                  resourceLoader.incrementWorkDone(1);
                  this.emit('loaded');
                  resolve(promise);
                  let prevFrame = 0;
                  const frameRate = 29.97;
                  const timerCallback = () => {
                      if (this.videoElem.paused || this.videoElem.ended) {
                          return;
                      }
                      // Check to see if the video has progressed to the next frame.
                      // If so, then we emit and update, which will cause a redraw.
                      const currentFrame = Math.floor(this.videoElem.currentTime * frameRate);
                      if (prevFrame != currentFrame) {
                          this.emit('updated');
                          prevFrame = currentFrame;
                      }
                      setTimeout(timerCallback, 20); // Sample at 50fps.
                  };
                  timerCallback();
              }, false);
              this.videoElem.src = url;
              // this.videoElem.load();
              const promise = this.videoElem.play();
              if (promise !== undefined) {
                  promise
                      .then((_) => {
                      console.log('Autoplay started!');
                      // Autoplay started!
                  })
                      .catch(() => {
                      console.log('Autoplay was prevented.');
                      // Autoplay was prevented.
                      // Show a "Play" button so that user can start playback.
                  });
              }
          });
      }
      /**
       * The getParams method.
       * @return - The return value.
       */
      getParams() {
          const params = super.getParams();
          if (this.loaded) {
              params['data'] = this.videoElem;
          }
          return params;
      }
  }
  Registry.register('LDRVideo', LDRVideo);

  //@ts-nocheck
  // Stream object for reading off bytes from a byte array
  function ByteStream(data) {
      this.data = data;
      this.pos = 0;
  }
  // read the next byte off the stream
  ByteStream.prototype.readByte = function () {
      return this.data[this.pos++];
  };
  // look at the next byte in the stream without updating the stream position
  ByteStream.prototype.peekByte = function () {
      return this.data[this.pos];
  };
  // read an array of bytes
  ByteStream.prototype.readBytes = function (n) {
      var bytes = new Array(n);
      for (var i = 0; i < n; i++) {
          bytes[i] = this.readByte();
      }
      return bytes;
  };
  // peek at an array of bytes without updating the stream position
  ByteStream.prototype.peekBytes = function (n) {
      var bytes = new Array(n);
      for (var i = 0; i < n; i++) {
          bytes[i] = this.data[this.pos + i];
      }
      return bytes;
  };
  // read a string from a byte set
  ByteStream.prototype.readString = function (len) {
      var str = '';
      for (var i = 0; i < len; i++) {
          str += String.fromCharCode(this.readByte());
      }
      return str;
  };
  // read a single byte and return an array of bit booleans
  ByteStream.prototype.readBitArray = function () {
      var arr = [];
      var bite = this.readByte();
      for (var i = 7; i >= 0; i--) {
          arr.push(!!(bite & (1 << i)));
      }
      return arr;
  };
  // read an unsigned int with endian option
  ByteStream.prototype.readUnsigned = function (littleEndian) {
      var a = this.readBytes(2);
      if (littleEndian) {
          return (a[1] << 8) + a[0];
      }
      else {
          return (a[0] << 8) + a[1];
      }
  };
  function DataParser(data) {
      //@ts-ignore
      this.stream = new ByteStream(data);
      // the final parsed object from the data
      this.output = {};
  }
  DataParser.prototype.parse = function (schema) {
      // the top level schema is just the top level parts array
      this.parseParts(this.output, schema);
      return this.output;
  };
  // parse a set of hierarchy parts providing the parent object, and the subschema
  DataParser.prototype.parseParts = function (obj, schema) {
      for (var i = 0; i < schema.length; i++) {
          var part = schema[i];
          this.parsePart(obj, part);
      }
  };
  DataParser.prototype.parsePart = function (obj, part) {
      var name = part.label;
      var value;
      // make sure the part meets any parse requirements
      if (part.requires && !part.requires(this.stream, this.output, obj)) {
          return;
      }
      if (part.loop) {
          // create a parse loop over the parts
          var items = [];
          while (part.loop(this.stream)) {
              var item = {};
              this.parseParts(item, part.parts);
              items.push(item);
          }
          obj[name] = items;
      }
      else if (part.parts) {
          // process any child parts
          value = {};
          this.parseParts(value, part.parts);
          obj[name] = value;
      }
      else if (part.parser) {
          // parse the value using a parser
          value = part.parser(this.stream, this.output, obj);
          if (!part.skip) {
              obj[name] = value;
          }
      }
      else if (part.bits) {
          // convert the next byte to a set of bit fields
          obj[name] = this.parseBits(part.bits);
      }
  };
  // combine bits to calculate value
  function bitsToNum(bitArray) {
      return bitArray.reduce(function (s, n) {
          return s * 2 + n;
      }, 0);
  }
  // parse a byte as a bit set (flags and values)
  DataParser.prototype.parseBits = function (details) {
      var out = {};
      var bits = this.stream.readBitArray();
      for (var key in details) {
          var item = details[key];
          if (item.length) {
              // convert the bit set to value
              out[key] = bitsToNum(bits.slice(item.index, item.index + item.length));
          }
          else {
              out[key] = bits[item.index];
          }
      }
      return out;
  };
  // a set of common parsers used with DataParser
  var Parsers = {
      // read a byte
      readByte: function () {
          return function (stream) {
              return stream.readByte();
          };
      },
      // read an array of bytes
      readBytes: function (length) {
          return function (stream) {
              return stream.readBytes(length);
          };
      },
      // read a string from bytes
      readString: function (length) {
          return function (stream) {
              return stream.readString(length);
          };
      },
      // read an unsigned int (with endian)
      readUnsigned: function (littleEndian) {
          return function (stream) {
              return stream.readUnsigned(littleEndian);
          };
      },
      // read an array of byte sets
      readArray: function (size, countFunc) {
          return function (stream, obj, parent) {
              var count = countFunc(stream, obj, parent);
              var arr = new Array(count);
              for (var i = 0; i < count; i++) {
                  arr[i] = stream.readBytes(size);
              }
              return arr;
          };
      },
  };
  // object used to represent array buffer data for a gif file
  // a set of 0x00 terminated subblocks
  var subBlocks = {
      label: 'blocks',
      parser: function (stream) {
          var out = [];
          var terminator = 0x00;
          for (var size = stream.readByte(); size !== terminator; size = stream.readByte()) {
              out = out.concat(stream.readBytes(size));
          }
          return out;
      },
  };
  // global control extension
  var gce = {
      label: 'gce',
      requires: function (stream) {
          // just peek at the top two bytes, and if true do this
          var codes = stream.peekBytes(2);
          return codes[0] === 0x21 && codes[1] === 0xf9;
      },
      parts: [
          { label: 'codes', parser: Parsers.readBytes(2), skip: true },
          { label: 'byteSize', parser: Parsers.readByte() },
          {
              label: 'extras',
              bits: {
                  future: { index: 0, length: 3 },
                  disposal: { index: 3, length: 3 },
                  userInput: { index: 6 },
                  transparentColorGiven: { index: 7 },
              },
          },
          { label: 'delay', parser: Parsers.readUnsigned(true) },
          { label: 'transparentColorIndex', parser: Parsers.readByte() },
          { label: 'terminator', parser: Parsers.readByte(), skip: true },
      ],
  };
  // image pipeline block
  var image = {
      label: 'image',
      requires: function (stream) {
          // peek at the next byte
          var code = stream.peekByte();
          return code === 0x2c;
      },
      parts: [
          { label: 'code', parser: Parsers.readByte(), skip: true },
          {
              label: 'descriptor',
              parts: [
                  { label: 'left', parser: Parsers.readUnsigned(true) },
                  { label: 'top', parser: Parsers.readUnsigned(true) },
                  { label: 'width', parser: Parsers.readUnsigned(true) },
                  { label: 'height', parser: Parsers.readUnsigned(true) },
                  {
                      label: 'lct',
                      bits: {
                          exists: { index: 0 },
                          interlaced: { index: 1 },
                          sort: { index: 2 },
                          future: { index: 3, length: 2 },
                          size: { index: 5, length: 3 },
                      },
                  },
              ],
          },
          {
              label: 'lct',
              requires: function (stream, obj, parent) {
                  return parent.descriptor.lct.exists;
              },
              parser: Parsers.readArray(3, function (stream, obj, parent) {
                  return Math.pow(2, parent.descriptor.lct.size + 1);
              }),
          },
          {
              label: 'data',
              parts: [{ label: 'minCodeSize', parser: Parsers.readByte() }, subBlocks],
          },
      ],
  };
  // plain text block
  var text = {
      label: 'text',
      requires: function (stream) {
          // just peek at the top two bytes, and if true do this
          var codes = stream.peekBytes(2);
          return codes[0] === 0x21 && codes[1] === 0x01;
      },
      parts: [
          { label: 'codes', parser: Parsers.readBytes(2), skip: true },
          { label: 'blockSize', parser: Parsers.readByte() },
          {
              label: 'preData',
              parser: function (stream, obj, parent) {
                  return stream.readBytes(parent.text.blockSize);
              },
          },
          subBlocks,
      ],
  };
  // application block
  var application = {
      label: 'application',
      requires: function (stream, obj, parent) {
          // make sure this frame doesn't already have a gce, text, comment, or image
          // as that means this block should be attached to the next frame
          //if(parent.gce || parent.text || parent.image || parent.comment){ return false; }
          // peek at the top two bytes
          var codes = stream.peekBytes(2);
          return codes[0] === 0x21 && codes[1] === 0xff;
      },
      parts: [
          { label: 'codes', parser: Parsers.readBytes(2), skip: true },
          { label: 'blockSize', parser: Parsers.readByte() },
          {
              label: 'id',
              parser: function (stream, obj, parent) {
                  return stream.readString(parent.blockSize);
              },
          },
          subBlocks,
      ],
  };
  // comment block
  var comment = {
      label: 'comment',
      requires: function (stream, obj, parent) {
          // make sure this frame doesn't already have a gce, text, comment, or image
          // as that means this block should be attached to the next frame
          //if(parent.gce || parent.text || parent.image || parent.comment){ return false; }
          // peek at the top two bytes
          var codes = stream.peekBytes(2);
          return codes[0] === 0x21 && codes[1] === 0xfe;
      },
      parts: [{ label: 'codes', parser: Parsers.readBytes(2), skip: true }, subBlocks],
  };
  // frames of ext and image data
  var frames = {
      label: 'frames',
      parts: [gce, application, comment, image, text],
      loop: function (stream) {
          var nextCode = stream.peekByte();
          // rather than check for a terminator, we should check for the existence
          // of an ext or image block to avoid infinite loops
          //var terminator = 0x3B;
          //return nextCode !== terminator;
          return nextCode === 0x21 || nextCode === 0x2c;
      },
  };
  // main GIF schema
  var schemaGIF = [
      {
          label: 'header',
          parts: [
              { label: 'signature', parser: Parsers.readString(3) },
              { label: 'version', parser: Parsers.readString(3) },
          ],
      },
      {
          label: 'lsd',
          parts: [
              { label: 'width', parser: Parsers.readUnsigned(true) },
              { label: 'height', parser: Parsers.readUnsigned(true) },
              {
                  label: 'gct',
                  bits: {
                      exists: { index: 0 },
                      resolution: { index: 1, length: 3 },
                      sort: { index: 4 },
                      size: { index: 5, length: 3 },
                  },
              },
              { label: 'backgroundColorIndex', parser: Parsers.readByte() },
              { label: 'pixelAspectRatio', parser: Parsers.readByte() },
          ],
      },
      {
          label: 'gct',
          requires: function (stream, obj) {
              return obj.lsd.gct.exists;
          },
          parser: Parsers.readArray(3, function (stream, obj) {
              return Math.pow(2, obj.lsd.gct.size + 1);
          }),
      },
      frames, // content frames
  ];
  var gifSchema = schemaGIF;
  function GIF(arrayBuffer) {
      // convert to byte array
      var byteData = new Uint8Array(arrayBuffer);
      //@ts-ignore
      var parser = new DataParser(byteData);
      // parse the data
      this.raw = parser.parse(gifSchema);
      // set a flag to make sure the gif contains at least one image
      this.raw.hasImages = false;
      for (var f = 0; f < this.raw.frames.length; f++) {
          if (this.raw.frames[f].image) {
              this.raw.hasImages = true;
              break;
          }
      }
  }
  // process a single gif image frames data, decompressing it using LZW
  // if buildPatch is true, the returned image will be a clamped 8 bit image patch
  // for use directly with a canvas.
  GIF.prototype.decompressFrame = function (index, buildPatch) {
      // make sure a valid frame is requested
      if (index >= this.raw.frames.length) {
          return null;
      }
      var frame = this.raw.frames[index];
      if (frame.image) {
          // get the number of pixels
          var totalPixels = frame.image.descriptor.width * frame.image.descriptor.height;
          // do lzw decompression
          var pixels = lzw(frame.image.data.minCodeSize, frame.image.data.blocks, totalPixels);
          // deal with interlacing if necessary
          if (frame.image.descriptor.lct.interlaced) {
              pixels = deinterlace(pixels, frame.image.descriptor.width);
          }
          // setup usable image object
          var image = {
              pixels: pixels,
              dims: {
                  top: frame.image.descriptor.top,
                  left: frame.image.descriptor.left,
                  width: frame.image.descriptor.width,
                  height: frame.image.descriptor.height,
              },
          };
          // color table
          if (frame.image.descriptor.lct && frame.image.descriptor.lct.exists) {
              image.colorTable = frame.image.lct;
          }
          else {
              image.colorTable = this.raw.gct;
          }
          // add per frame relevant gce information
          if (frame.gce) {
              image.delay = (frame.gce.delay || 10) * 10; // convert to ms
              image.disposalType = frame.gce.extras.disposal;
              // transparency
              if (frame.gce.extras.transparentColorGiven) {
                  image.transparentIndex = frame.gce.transparentColorIndex;
              }
          }
          // create canvas usable imagedata if desired
          if (buildPatch) {
              image.patch = generatePatch(image);
          }
          return image;
      }
      // frame does not contains image
      return null;
      /**
       * javascript port of java LZW decompression
       * Original java author url: https://gist.github.com/devunwired/4479231
       */
      function lzw(minCodeSize, data, pixelCount) {
          var MAX_STACK_SIZE = 4096;
          var nullCode = -1;
          var npix = pixelCount;
          var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
          var dstPixels = new Array(pixelCount);
          var prefix = new Array(MAX_STACK_SIZE);
          var suffix = new Array(MAX_STACK_SIZE);
          var pixelStack = new Array(MAX_STACK_SIZE + 1);
          // Initialize GIF data stream decoder.
          data_size = minCodeSize;
          clear = 1 << data_size;
          end_of_information = clear + 1;
          available = clear + 2;
          old_code = nullCode;
          code_size = data_size + 1;
          code_mask = (1 << code_size) - 1;
          for (code = 0; code < clear; code++) {
              prefix[code] = 0;
              suffix[code] = code;
          }
          // Decode GIF pixel stream.
          datum = bits = first = top = pi = bi = 0;
          for (i = 0; i < npix;) {
              if (top === 0) {
                  if (bits < code_size) {
                      // get the next byte
                      datum += data[bi] << bits;
                      bits += 8;
                      bi++;
                      continue;
                  }
                  // Get the next code.
                  code = datum & code_mask;
                  datum >>= code_size;
                  bits -= code_size;
                  // Interpret the code
                  if (code > available || code == end_of_information) {
                      break;
                  }
                  if (code == clear) {
                      // Reset decoder.
                      code_size = data_size + 1;
                      code_mask = (1 << code_size) - 1;
                      available = clear + 2;
                      old_code = nullCode;
                      continue;
                  }
                  if (old_code == nullCode) {
                      pixelStack[top++] = suffix[code];
                      old_code = code;
                      first = code;
                      continue;
                  }
                  in_code = code;
                  if (code == available) {
                      pixelStack[top++] = first;
                      code = old_code;
                  }
                  while (code > clear) {
                      pixelStack[top++] = suffix[code];
                      code = prefix[code];
                  }
                  first = suffix[code] & 0xff;
                  pixelStack[top++] = first;
                  // add a new string to the table, but only if space is available
                  // if not, just continue with current table until a clear code is found
                  // (deferred clear code implementation as per GIF spec)
                  if (available < MAX_STACK_SIZE) {
                      prefix[available] = old_code;
                      suffix[available] = first;
                      available++;
                      if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
                          code_size++;
                          code_mask += available;
                      }
                  }
                  old_code = in_code;
              }
              // Pop a pixel off the pixel stack.
              top--;
              dstPixels[pi++] = pixelStack[top];
              i++;
          }
          for (i = pi; i < npix; i++) {
              dstPixels[i] = 0; // clear missing pixels
          }
          return dstPixels;
      }
      // deinterlace function from https://github.com/shachaf/jsgif
      function deinterlace(pixels, width) {
          var newPixels = new Array(pixels.length);
          var rows = pixels.length / width;
          var cpRow = function (toRow, fromRow) {
              var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
              newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
          };
          // See appendix E.
          var offsets = [0, 4, 2, 1];
          var steps = [8, 8, 4, 2];
          var fromRow = 0;
          for (var pass = 0; pass < 4; pass++) {
              for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                  cpRow(toRow, fromRow);
                  fromRow++;
              }
          }
          return newPixels;
      }
      // create a clamped byte array patch for the frame image to be used directly with a canvas
      // TODO: could potentially squeeze some performance by doing a direct 32bit write per iteration
      function generatePatch(image) {
          var totalPixels = image.pixels.length;
          var patchData = new Uint8ClampedArray(totalPixels * 4);
          for (var i = 0; i < totalPixels; i++) {
              var pos = i * 4;
              var colorIndex = image.pixels[i];
              var color = image.colorTable[colorIndex];
              patchData[pos] = color[0];
              patchData[pos + 1] = color[1];
              patchData[pos + 2] = color[2];
              patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
          }
          return patchData;
      }
  };
  // returns all frames decompressed
  GIF.prototype.decompressFrames = function (buildPatch) {
      var frames = [];
      for (var i = 0; i < this.raw.frames.length; i++) {
          var frame = this.raw.frames[i];
          if (frame.image) {
              frames.push(this.decompressFrame(i, buildPatch));
          }
      }
      return frames;
  };

  /* eslint-disable prefer-promise-reject-errors */
  const imageDataLibrary = {};
  /**
   * Class representing a GIF image.
   *
   * ```
   * const image = new GIFImage()
   * image.load("https://storage.googleapis.com/zea-playground-assets/zea-engine/texture.gif")
   * ```
   *
   * **Parameters**
   * * **StreamAtlasDesc:**
   * * **StreamAtlasIndex:**
   *
   * **Events**
   * * **loaded:** Triggered when the gif data is loaded.
   *
   * **File Types:** gif
   *
   * @extends FileImage
   */
  class GIFImage extends FileImage {
      __streamAtlas;
      play;
      stop;
      __resourcePromise;
      __unpackedData;
      streamAtlasDescParam = new Vec4Parameter('StreamAtlasDesc');
      streamAtlasIndexParam = new NumberParameter('StreamAtlasIndex', 0);
      /**
       * Create a GIF image.
       * @param name - The name value.
       * @param filePath - The filePath value.
       * @param params - The params value.
       */
      constructor(name, filePath = '', params = {}) {
          super(name, filePath, params);
          this.format = 'RGBA';
          this.type = 'UNSIGNED_BYTE';
          this.__streamAtlas = true;
          this.addParameter(this.streamAtlasDescParam);
          this.addParameter(this.streamAtlasIndexParam);
          const frameParam = this.streamAtlasIndexParam;
          frameParam.setRange([0, 1]);
          let playing;
          let frame = 0;
          const incrementFrame = (numFrames) => {
              frameParam.value = frame;
              if (playing)
                  setTimeout(() => incrementFrame(numFrames), this.getFrameDelay(frame));
              frame = (frame + 1) % numFrames;
          };
          this.play = () => {
              this.__resourcePromise.then(() => {
                  playing = true;
                  let frameParam_check = frameParam.getRange();
                  if (!frameParam_check) {
                      // should range be always be intialized?
                      console.warn('numFrames is null');
                      return;
                  }
                  const numFrames = frameParam_check[1];
                  incrementFrame(numFrames);
              });
          };
          this.stop = () => {
              playing = false;
          };
      }
      /**
       * The getFrameDelay method.
       * @param index - The index value.
       * @return - The return value.
       */
      getFrameDelay(index) {
          // Note: Frame delays are in centisecs (not millisecs which the timers will require.)
          return this.__unpackedData.frameDelays[index] * 10;
      }
      /**
       * Uses the specify url to load an Image element and adds it to the data library.
       * Sets the state of the current object.
       *
       * @param url - The url value.
       * @param format - The format value.
       * @return Returns a promise that resolves once the image is loaded.
       */
      load(url, format = 'RGB') {
          // this.__streamAtlasDesc = new Vec4();
          if (url in imageDataLibrary) {
              this.__resourcePromise = imageDataLibrary[url];
              return this.__resourcePromise;
          }
          else {
              this.__resourcePromise = new Promise((resolve, reject) => {
                  resourceLoader.incrementWorkload(1);
                  // if (fileDesc.assets && fileDesc.assets.atlas) {
                  //   const imageElem = new Image()
                  //   imageElem.crossOrigin = 'anonymous'
                  //   imageElem.src = fileDesc.assets.atlas.url
                  //   imageElem.addEventListener('load', () => {
                  //     resolve({
                  //       width: fileDesc.assets.atlas.width,
                  //       height: fileDesc.assets.atlas.height,
                  //       atlasSize: fileDesc.assets.atlas.atlasSize,
                  //       frameDelays: fileDesc.assets.atlas.frameDelays,
                  //       frameRange: [0, fileDesc.assets.atlas.frameDelays.length],
                  //       imageData: imageElem,
                  //     })
                  //     resourceLoader.incrementWorkDone(1)
                  //   })
                  //   return
                  // }
                  loadBinfile(url, (data) => {
                      console.warn('Unpacking Gif client side:' + url);
                      const start = performance.now();
                      // Decompressing using: https://github.com/matt-way/gifuct-js
                      //@ts-ignore
                      const gif = new GIF(data);
                      const frames = gif.decompressFrames(true);
                      // do something with the frame data
                      const sideLength = Math.sqrt(frames.length);
                      const atlasSize = [sideLength, sideLength];
                      if (MathFunctions.fract(sideLength) > 0.0) {
                          atlasSize[0] = Math.floor(atlasSize[0] + 1);
                          if (MathFunctions.fract(sideLength) > 0.5) {
                              atlasSize[1] = Math.floor(atlasSize[1] + 1);
                          }
                          else {
                              atlasSize[1] = Math.floor(atlasSize[1]);
                          }
                      }
                      const width = frames[0].dims.width;
                      const height = frames[0].dims.height;
                      // gif patch canvas
                      const tempCanvas = document.createElement('canvas');
                      const tempCtx = tempCanvas.getContext('2d');
                      // full gif canvas
                      const gifCanvas = document.createElement('canvas');
                      const gifCtx = gifCanvas.getContext('2d');
                      gifCanvas.width = width;
                      gifCanvas.height = height;
                      // The atlas for all the frames.
                      const atlasCanvas = document.createElement('canvas');
                      const atlasCtx = atlasCanvas.getContext('2d');
                      atlasCanvas.width = atlasSize[0] * width;
                      atlasCanvas.height = atlasSize[1] * height;
                      let frameImageData;
                      const frameDelays = [];
                      const renderFrame = (frame, index) => {
                          const dims = frame.dims;
                          // Note: the server side library returns centisecs (1/100 second) for
                          // frame delays, so normalize here so that client and servers
                          // valueus are in the
                          frameDelays.push(frame.delay / 10);
                          if (!frameImageData || dims.width != frameImageData.width || dims.height != frameImageData.height) {
                              tempCanvas.width = dims.width;
                              tempCanvas.height = dims.height;
                              frameImageData = tempCtx?.createImageData(dims.width, dims.height);
                          }
                          // set the patch data as an override
                          frameImageData.data.set(frame.patch);
                          tempCtx?.putImageData(frameImageData, 0, 0);
                          // Note: undocumented disposal method.
                          // See Ids here: https://github.com/theturtle32/Flash-Animated-GIF-Library/blob/master/AS3GifPlayer/src/com/worlize/gif/constants/DisposalType.as
                          // From what I can gather, 2 means we should clear the background first.
                          // this seems to work with Gifs featuring moving transparency.
                          // For fully opaque gifs, we should avoid this.
                          if (frame.disposalType == 2)
                              gifCtx?.clearRect(0, 0, gifCanvas.width, gifCanvas.height);
                          gifCtx?.drawImage(tempCanvas, dims.left, dims.top);
                          atlasCtx?.drawImage(gifCanvas, (index % atlasSize[0]) * width, Math.floor(index / atlasSize[0]) * height);
                      };
                      for (let i = 0; i < frames.length; i++) {
                          // console.log(frame);
                          renderFrame(frames[i], i);
                      }
                      resourceLoader.incrementWorkDone(1);
                      const imageData = atlasCtx?.getImageData(0, 0, atlasCanvas.width, atlasCanvas.height);
                      const ms = performance.now() - start;
                      console.log(`Decode GIF '${url}' time:` + ms);
                      resolve({
                          width: atlasCanvas.width,
                          height: atlasCanvas.height,
                          atlasSize,
                          frameRange: [0, frames.length],
                          frameDelays,
                          imageData,
                      });
                  }, (statusText) => {
                      const msg = 'Unable to Load URL:' + statusText + ':' + url;
                      console.warn(msg);
                      reject(msg);
                  });
              });
              imageDataLibrary[url] = this.__resourcePromise;
          }
          this.__resourcePromise.then((unpackedData) => {
              this.width = unpackedData.width;
              this.height = unpackedData.height;
              this.streamAtlasDescParam.value = new Vec4(unpackedData.atlasSize[0], unpackedData.atlasSize[1], 0, 0);
              this.streamAtlasIndexParam.setRange(unpackedData.frameRange);
              this.__unpackedData = unpackedData;
              this.__data = unpackedData.imageData;
              // ////////////////////////
              // Playback
              this.loaded = true;
              this.emit('loaded');
          });
          return this.__resourcePromise;
      }
  }
  Registry.register('GIFImage', GIFImage);

  /* eslint-disable new-cap */
  /**
   * An EnvMap can load High Dynamic Range environment map images, necessary for high quality PBR lighting.
   *
   *
   * **Parameters**
   * * **HeadLightMode(`BooleanParameter`):** Enables Headlight mode so that the environment lighting is aligned with the camera.
   * With Headlight mode on, the top of the env map is aligned with the direction of the camera, so a the view is generally well lit.
   *
   * @extends HDRImage
   */
  class EnvMap extends HDRImage {
      utf8decoder;
      shCoeffs;
      luminanceData;
      headlightModeParam = new BooleanParameter('HeadLightMode', false);
      /**
       * Create an env map.
       * @param name - The name value.
       * @param params - The params value.
       */
      constructor(name, params = {}) {
          super(name, params);
          this.addParameter(this.headlightModeParam);
          this.utf8decoder = new TextDecoder();
          this.shCoeffs = [];
      }
      /**
       * The __decodeData method.
       * @param entries - The entries value.
       * @return
       * @private
       */
      __decodeData(entries) {
          const samples = entries.samples;
          if (samples) {
              this.luminanceData = JSON.parse(this.utf8decoder.decode(samples));
              if (this.luminanceData.shCoeffs) {
                  for (let i = 0; i < 9; i++) {
                      this.shCoeffs[i] = new Color(this.luminanceData.shCoeffs[i * 3 + 0], this.luminanceData.shCoeffs[i * 3 + 1], this.luminanceData.shCoeffs[i * 3 + 2]);
                  }
              }
          }
          return super.__decodeData(entries);
      }
      /**
       * Calculate the luminance of the Environment in the direction.
       *
       * @param dir - The dir value.
       * @return - The return value.
       */
      dirToLuminance(dir) {
          // normal is assumed to have unit length
          const x = dir.x;
          const y = dir.y;
          const z = dir.z;
          // band 0
          const result = this.shCoeffs[0].scale(0.886227);
          // band 1
          result.addInPlace(this.shCoeffs[1].scale(2.0 * 0.511664 * y));
          result.addInPlace(this.shCoeffs[2].scale(2.0 * 0.511664 * z));
          result.addInPlace(this.shCoeffs[3].scale(2.0 * 0.511664 * x));
          // band 2
          result.addInPlace(this.shCoeffs[4].scale(2.0 * 0.429043 * x * y));
          result.addInPlace(this.shCoeffs[5].scale(2.0 * 0.429043 * y * z));
          result.addInPlace(this.shCoeffs[6].scale(0.743125 * z * z - 0.247708));
          result.addInPlace(this.shCoeffs[7].scale(2.0 * 0.429043 * x * z));
          result.addInPlace(this.shCoeffs[8].scale(0.429043 * (x * x - y * y)));
          return result.luminance();
      }
  }
  Registry.register('EnvMap', EnvMap);

  // eslint-disable-next-line require-jsdoc
  function getLanguage() {
      if (!globalThis.navigator)
          return 'en';
      // Check if a language is explicitly selected.
      const searchParams = new URLSearchParams(globalThis.location.search);
      if (searchParams.has('lang'))
          return searchParams.get('lang');
      const nav = globalThis.navigator;
      let i;
      let language;
      const clean = (language) => {
          if (language.startsWith('en'))
              return 'En';
          else if (language.startsWith('es'))
              return 'Es';
          else if (language.startsWith('fr'))
              return 'Fr';
          else if (language.startsWith('gb') || language.startsWith('de'))
              return 'Gb';
          return language;
      };
      // support for HTML 5.1 "navigator.languages"
      if (Array.isArray(nav.languages)) {
          for (i = 0; i < nav.languages.length; i++) {
              language = nav.languages[i];
              if (language && language.length) {
                  return clean(language);
              }
          }
      }
      // support for other well known properties in browsers
      // const browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage']
      // for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
      //   language = nav[browserLanguagePropertyKeys[i]]
      //   if (language && language.length) {
      //     return clean(language)
      //   }
      // }
      return null;
  }
  /** Class representing a label manager.
   * @private
   */
  class LabelManager extends EventEmitter {
      __language;
      __foundLabelLibraries;
      __labelLibraries;
      /**
       * Create a label manager.
       */
      constructor() {
          super();
          this.__labelLibraries = {};
          this.__language = getLanguage();
          this.__foundLabelLibraries = {};
      }
      /**
       * Load a label library into the manager.
       * @param name - The name of the library.
       * @param url- The json data of of the library.
       */
      loadLibrary(name, url) {
          const stem = name.substring(0, name.lastIndexOf('.'));
          this.__foundLabelLibraries[stem] = url;
          if (name.endsWith('.labels')) {
              loadTextfile(url, (text) => {
                  this.__labelLibraries[stem] = JSON.parse(text);
                  this.emit('labelLibraryLoaded', { library: stem });
              });
          }
          else if (name.endsWith('.xlsx')) {
              // @ts-ignore
              const XLSX = globalThis.XLSX;
              // Note: example taken from here..
              // https://stackoverflow.com/questions/8238407/how-to-parse-excel-file-in-javascript-html5
              // and here:
              // https://github.com/SheetJS/js-xlsx/tree/master/demos/xhr
              loadBinfile(url, (data) => {
                  const unit8array = new Uint8Array(data);
                  // @ts-ignore
                  const workbook = XLSX.read(unit8array, {
                      type: 'array',
                  });
                  const json = {};
                  workbook.SheetNames.forEach(function (sheetName) {
                      // Here is your object
                      // @ts-ignore
                      const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], {});
                      // @ts-ignore
                      rows.forEach(function (row) {
                          const identifier = row.Identifier;
                          delete row.Identifier;
                          json[identifier] = row;
                      });
                  });
                  this.__labelLibraries[stem] = json;
                  this.emit('labelLibraryLoaded', { library: stem });
              });
          }
      }
      /**
       * Checks if the library is found.
       * @param name - The name of the library.
       * @return - Returns true if the library is found.
       */
      isLibraryFound(name) {
          return name in this.__foundLabelLibraries;
      }
      /**
       * Checks if the library is loaded.
       * @param name - The name of the library.
       * @return - Returns true if the library is loaded.
       */
      isLibraryLoaded(name) {
          return name in this.__labelLibraries;
      }
      /**
       * The getLabelText method.
       * @param libraryName - The name of the library.
       * @param labelName - The name of the label.
       * @return - The return value.
       */
      getLabelText(libraryName, labelName) {
          const library = this.__labelLibraries[libraryName];
          if (!library) {
              throw new Error("LabelLibrary: '" +
                  libraryName +
                  "' not found in LabelManager. Found: [" +
                  Object.keys(this.__labelLibraries) +
                  ']');
          }
          const label = library[labelName];
          if (!label) {
              throw new Error("Label: '" +
                  labelName +
                  "' not found in LabelLibrary: '" +
                  libraryName +
                  "'. Found: [" +
                  Object.keys(library) +
                  ']');
          }
          const labelText = label[this.__language];
          if (!labelText) {
              if (label['En'])
                  return label['En'];
              throw new Error("labelText: '" + this.__language + "' not found in Label. Found: [" + Object.keys(label) + ']');
          }
          return labelText;
      }
      /**
       * The setLabelText method.
       * @param libraryName - The name of the library.
       * @param labelName - The name of the label.
       * @param labelText - The text of the label.
       */
      setLabelText(libraryName, labelName, labelText) {
          let library = this.__labelLibraries[libraryName];
          if (!library) {
              library = {};
              this.__labelLibraries[libraryName] = library;
          }
          let label = library[labelName];
          if (!label) {
              label = {};
              library[labelName] = label;
          }
          label[this.__language] = labelText;
          // TODO: Push to server.
      }
      setLanguage(ln) {
          this.__language = ln;
      }
  }
  const labelManager = new LabelManager();

  /* eslint-disable guard-for-in */
  // http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
  /**
   * Draws a rounded rectangle using the current state of the canvas.
   * If you omit the last three params, it will draw a rectangle
   * outline with a 5 pixel border radius
   * @param ctx
   * @param x - The top left x coordinate
   * @param y - The top left y coordinate
   * @param width - The width of the rectangle
   * @param height - The height of the rectangle
   *
   * @param radius - The corner radius; It can also be an object to specify different radii for corners
   * @param radius.tl - Top left
   * @param radius.tr - Top right
   * @param radius.br - Bottom right
   * @param radius.bl - Bottom left
   *
   * @param fill - Whether to fill the rectangle.
   * @param stroke - Whether to stroke the rectangle.
   * @param strokeWidth - The strokeWidth param.
   * @private
   */
  function roundRect(ctx, x, y, width, height, radius, fill = false, stroke = true, strokeWidth) {
      if (typeof stroke == 'undefined') {
          stroke = true;
      }
      if (typeof radius === 'undefined') {
          radius = 5;
      }
      if (typeof radius === 'number') {
          radius = {
              tl: radius,
              tr: radius,
              br: radius,
              bl: radius,
          };
      }
      else {
          const defaultRadius = {
              tl: 0,
              tr: 0,
              br: 0,
              bl: 0,
          };
          for (const side in defaultRadius) {
              radius[side] = radius[side] || defaultRadius[side];
          }
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) {
          ctx.fill();
      }
      if (stroke) {
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
      }
  }
  // TODO: rewrite
  /**
   * Represents a 2D label item the scene.
   * Since displaying text in the scene is not an easy task,
   * we've abstracted the complicated logic behind this class, transforming any text into a 2D image(`DataImage`).
   *
   * **Library List**
   * * LabelPack
   *
   * **Parameters**
   * * **Library(`StringParameter`):** Library you wan to use for your label, see **Library List** above.
   * * **Text(`StringParameter`):**
   * * **FontColor(`ColorParameter`):**
   * * **Margin(`NumberParameter`):**
   * * **BorderWidth(`NumberParameter`):**
   * * **BorderRadius(`NumberParameter`):**
   * * **Outline(`BooleanParameter`):**
   * * **OutlineColor(`BooleanParameter`):**
   * * **Background(`BooleanParameter`):**
   * * **ColorParameter(`BackgroundColor`):**
   * * **FillBackground(`BooleanParameter`):**
   * * **StrokeBackgroundOutline(`BooleanParameter`):**
   * * **FontSize(`NumberParameter`):** Represents FontSize of the label
   * * **Font(`StringParameter`):**
   *
   * **Events**
   * * **loaded:** Triggered when label's data is loaded.
   * * **updated:** Triggered when label's data changes.
   * * **labelRendered:** Triggered when the text image is rendered. Contains `width`, `height` and data of the image.
   *
   * @extends DataImage
   */
  class Label extends DataImage {
      needsRender;
      canvasElem;
      requestedReRender = false;
      /**
       * Creates a label instance. Creating a canvas element that hosts the specified text.
       *
       * @param name - The name value.
       * @param library - The library value.
       */
      marginParam;
      borderRadiusParam;
      /**
       * @member libraryParam - Library you wan to use for your label, see **Library List** above.
       */
      libraryParam = new StringParameter('Library');
      /**
       * @member textParam - text to display on the label
       */
      textParam = new StringParameter('Text', '');
      /**
       * @member fontColorParam - TODO
       */
      fontColorParam = new ColorParameter('FontColor', new Color(0, 0, 0));
      /**
       * @member - TODO
       */
      fontSizeParam = new NumberParameter('FontSize', 22);
      /**
       * @member fontParam - TODO
       */
      fontParam = new StringParameter('Font', 'Helvetica');
      /**
       * @member borderWidthParam - Border around the label
       */
      borderWidthParam = new NumberParameter('BorderWidth', 2);
      /**
       * @member outlineParam - TODO
       */
      outlineParam = new BooleanParameter('Outline', false);
      /**
       * @member outlineColorParam - TODO
       */
      outlineColorParam = new ColorParameter('OutlineColor', new Color(0, 0, 0));
      /**
       * @member backgroundParam - TODO
       */
      backgroundParam = new BooleanParameter('Background', true);
      /**
       * @member backgroundColorParam - TODO
       */
      backgroundColorParam = new ColorParameter('BackgroundColor', new Color('#FBC02D'));
      /**
       * @member fillBackgroundParam - TODO
       */
      fillBackgroundParam = new BooleanParameter('FillBackground', true);
      /**
       * @member strokeBackgroundOutlineParam - TODO
       */
      strokeBackgroundOutlineParam = new BooleanParameter('StrokeBackgroundOutline', true);
      constructor(name, library) {
          super(name);
          this.canvasElem = document.createElement('canvas');
          const fontSize = 22;
          this.marginParam = new NumberParameter('Margin', fontSize * 0.5);
          this.borderRadiusParam = new NumberParameter('BorderRadius', fontSize * 0.5);
          this.addParameter(this.marginParam);
          this.addParameter(this.borderRadiusParam);
          this.addParameter(this.libraryParam);
          this.addParameter(this.textParam);
          this.addParameter(this.fontColorParam);
          this.addParameter(this.fontSizeParam);
          this.addParameter(this.fontParam);
          this.addParameter(this.borderWidthParam);
          this.addParameter(this.outlineParam);
          this.addParameter(this.outlineColorParam);
          this.addParameter(this.backgroundParam);
          this.addParameter(this.backgroundColorParam);
          this.addParameter(this.fillBackgroundParam);
          this.addParameter(this.strokeBackgroundOutlineParam);
          const reload = () => {
              this.loadLabelData();
          };
          this.on('nameChanged', reload);
          if (library)
              this.libraryParam.value = library;
          this.requestedReRender = false;
          this.needsRender = false;
          this.loadLabelData();
      }
      /**
       * This method can be overridden in derived classes
       * to perform general updates (see GLPass or BaseItem).
       *
       * @param event - The event object.
       * @private
       */
      __parameterValueChanged(event) {
          super.parameterValueChanged(event);
          if (!this.requestedReRender) {
              this.requestedReRender = true;
              this.loadLabelData();
          }
      }
      /**
       * Method in charge of basically do everything, set text, load/update it, get the library, load the font, etc.
       */
      loadLabelData() {
          const onLoaded = () => {
              this.requestedReRender = false;
              this.needsRender = true;
              if (!this.loaded) {
                  this.loaded = true;
                  this.emit('loaded');
              }
              else {
                  this.emit('updated');
              }
          };
          const loadText = () => {
              return new Promise((resolve) => {
                  const library = this.libraryParam.value;
                  if (library == '') {
                      resolve();
                      return;
                  }
                  if (!labelManager.isLibraryFound(library)) {
                      console.warn('Label Library not found:', library);
                      resolve();
                      return;
                  }
                  const getLibraryText = () => {
                      try {
                          const name = this.getName();
                          // console.log("Text Loaded:" + name);
                          const text = labelManager.getLabelText(library, name);
                          this.textParam.value = text;
                      }
                      catch (e) {
                          // Note: if the text is not found in the labels pack
                          // an exception is thrown, and we catch it here.
                          console.warn(e);
                      }
                      resolve();
                  };
                  if (!labelManager.isLibraryLoaded(library)) {
                      labelManager.on('labelLibraryLoaded', (event) => {
                          const loadedLibrary = event.library;
                          if (loadedLibrary == library)
                              getLibraryText();
                      });
                  }
                  else {
                      getLibraryText();
                  }
              });
          };
          const loadFont = () => {
              return new Promise((resolve) => {
                  if (document.fonts != undefined) {
                      const font = this.fontParam.value;
                      const fontSize = this.fontSizeParam.value;
                      document.fonts.load(fontSize + 'px "' + font + '"').then(() => {
                          // console.log("Font Loaded:" + font);
                          resolve();
                      });
                  }
                  else {
                      resolve();
                  }
              });
          };
          Promise.all([loadText(), loadFont()]).then(onLoaded);
      }
      /**
       * Renders the label text to a canvas element ready to display.
       * Here is where all parameters are applied to the canvas containing the text,
       * then the image data is extracted from the canvas context.
       */
      renderLabelToImage() {
          // console.log("renderLabelToImage")
          const ctx2d = this.canvasElem.getContext('2d', {
              alpha: true,
          });
          let text = this.textParam.value;
          if (text == '')
              text = this.getName();
          const font = this.fontParam.value;
          const fontColor = this.fontColorParam.value;
          const textAlign = 'left'; // this.textAlignParam.value
          const fontSize = this.fontSizeParam.value;
          const margin = this.marginParam.value;
          const borderWidth = this.borderWidthParam.value;
          const borderRadius = this.borderRadiusParam.value;
          const outline = this.outlineParam.value;
          const outlineColor = this.outlineColorParam.value;
          const background = this.backgroundParam.value;
          const backgroundColor = this.backgroundColorParam.value;
          const fillBackground = this.fillBackgroundParam.value;
          const strokeBackgroundOutline = this.strokeBackgroundOutlineParam.value;
          // let ratio = devicePixelRatio / backingStoreRatio;
          const marginAndBorder = margin + borderWidth;
          const lines = text.split('\n');
          ctx2d.font = fontSize + 'px "' + font + '"';
          // console.log("renderLabelToImage:" + ctx2d.font);
          let width = 0;
          lines.forEach((line) => {
              width = Math.max(ctx2d.measureText(line).width, width);
          });
          const fontHeight = fontSize; // parseInt(fontSize)
          this.width = Math.ceil(width + marginAndBorder * 2);
          this.height = Math.ceil(fontHeight * lines.length + marginAndBorder * 2);
          ctx2d.canvas.width = this.width;
          ctx2d.canvas.height = this.height;
          this.canvasElem.width = this.width;
          this.canvasElem.height = this.height;
          // ctx2d.clearRect(0, 0, this.width, this.height);
          ctx2d.fillStyle = 'rgba(0, 0, 0, 0.0)';
          ctx2d.fillRect(0, 0, this.width, this.height);
          if (background) {
              ctx2d.fillStyle = backgroundColor.toHex();
              ctx2d.strokeStyle = outlineColor.toHex();
              roundRect(ctx2d, borderWidth, borderWidth, this.width - borderWidth * 2, this.height - borderWidth * 2, borderRadius, fillBackground, strokeBackgroundOutline, borderWidth);
          }
          ctx2d.font = fontSize + 'px "' + font + '"';
          ctx2d.textAlign = textAlign;
          ctx2d.fillStyle = fontColor.toHex();
          ctx2d.textBaseline = 'hanging';
          lines.forEach((line, index) => {
              ctx2d.fillText(line, marginAndBorder, marginAndBorder + index * fontHeight);
          });
          if (outline) {
              ctx2d.strokeStyle = outlineColor.toHex();
              ctx2d.lineWidth = 1.5;
              ctx2d.strokeText(text, marginAndBorder, marginAndBorder);
          }
          this.__data = ctx2d.getImageData(0, 0, this.width, this.height);
          this.needsRender = false;
          this.emit('labelRendered', {
              width: this.width,
              height: this.height,
              data: this.__data,
          });
      }
      /**
       *  Returns all parameters and class state values(Including data).
       *
       * @return - The return value.
       */
      getParams() {
          if (this.needsRender)
              this.renderLabelToImage();
          return super.getParams();
      }
  }
  Registry.register('Label', Label);

  /** Class representing a 2D video stream image.
   * @private
   * @extends BaseImage
   */
  class VideoStreamImage2D extends BaseImage {
      __data;
      __intervalId;
      /**
       * Create a 2D video stream image.
       */
      constructor() {
          super('');
      }
      /**
       * The connectWebcam method.
       * @param width - The width of the video.
       * @param height - The height of the video.
       * @param rearCamera - Boolean determining if it is a rear camera or not.
       */
      connectWebcam(width, height, rearCamera = false) {
          const video = {
              width,
              height,
              frameRate: {
                  ideal: 60,
                  max: 60,
              },
          };
          if (rearCamera) {
              video.facingMode = {
                  exact: 'environment',
              };
          }
          else {
              video.facingMode = {
                  facingMode: 'user',
              };
          }
          const domElement = document.createElement('video');
          // TODO - confirm its necessary to add to DOM
          domElement.style.display = 'none';
          domElement.preload = 'auto';
          domElement.crossOrigin = 'anonymous';
          // domElement.crossorigin = true;
          document.body.appendChild(domElement);
          // List cameras and microphones.
          // navigator.mediaDevices.enumerateDevices()
          //     .then((devices)=>{
          //         // devices.forEach((device)=>{
          //         //     if (device.kind == "videoinput") {
          //         //         console.log(device.kind + ": " + device.label + " id = " + device.deviceId);
          //         //         videoinputs.push(device);
          //         //     }
          //         // });
          //     })
          //     .catch(function(err) {
          //         console.log(err.name + ": " + err.message);
          //     });
          navigator.mediaDevices
              .getUserMedia({
              audio: false,
              video,
          })
              .then((mediaStream) => {
              domElement.srcObject = mediaStream;
              domElement.onloadedmetadata = (e) => {
                  domElement.play();
                  this.width = domElement.videoWidth;
                  this.height = domElement.videoHeight;
                  console.log('Webcam:[' + this.width + ', ' + this.height + ']');
                  this.__data = domElement;
                  this.loaded = true;
                  this.emit('loaded');
                  let prevFrame = 0;
                  const frameRate = 60;
                  const timerCallback = () => {
                      if (domElement.paused || domElement.ended) {
                          return;
                      }
                      // Check to see if the video has progressed to the next frame.
                      // If so, then we emit and update, which will cause a redraw.
                      const currentFrame = Math.floor(domElement.currentTime * frameRate);
                      if (prevFrame != currentFrame) {
                          this.emit('updated');
                          prevFrame = currentFrame;
                      }
                      setTimeout(timerCallback, 20); // Sample at 50fps.
                  };
                  timerCallback();
              };
          })
              .catch(function (err) {
              /* handle the error */
          });
      }
      /**
       * The setVideoStream method.
       * @param video - The video value.
       */
      setVideoStream(video) {
          this.loaded = false;
          this.width = video.videoWidth;
          this.height = video.videoHeight;
          this.start();
          this.__data = video;
          this.loaded = true;
          this.emit('loaded');
      }
      // getAudioSource() {
      //     return this.__data;
      // }
      /**
       * The stop method.
       */
      stop() {
          clearInterval(this.__intervalId);
      }
      /**
       * The start method.
       */
      start() {
          // @ts-ignore
          this.__intervalId = setInterval(() => {
              this.emit('updated');
          }, 20); // Sample at 50fps.
      }
      /**
       * The isLoaded method.
       * @return - The return value.
       */
      isLoaded() {
          return this.loaded;
      }
      /**
       * The getParams method.
       * @return - The return value.
       */
      getParams() {
          return {
              type: this.type,
              format: this.format,
              width: this.width,
              height: this.height,
              data: this.__data,
              flipY: true,
          };
      }
  }
  Registry.register('VideoStreamImage2D', VideoStreamImage2D);

  class FatLinesMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      opacityParam = new NumberParameter('Opacity', 1.0);
      lineThicknessParam = new NumberParameter('LineThickness', 0.01);
      overlayParam = new NumberParameter('Overlay', 0.0);
      constructor(name) {
          super(name);
          this.__shaderName = 'FatLinesShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.opacityParam);
          this.addParameter(this.overlayParam);
          this.addParameter(this.lineThicknessParam);
      }
      isTextured() {
          // Note: this is to force the generation of the MaterialShaderBinding
          // see GLShaderMaterials.addGLGeomItem
          return true;
      }
  }
  Registry.register('FatLinesMaterial', FatLinesMaterial);

  class FatPointsMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1, 1, 1));
      pointSizeParam = new NumberParameter('PointSize', 1);
      borderWidthParam = new NumberParameter('BorderWidth', 0.2);
      overlayParam = new NumberParameter('Overlay', 0.0);
      constructor(name) {
          super(name);
          this.__shaderName = 'FatPointsShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.pointSizeParam);
          this.addParameter(this.borderWidthParam);
          this.addParameter(this.overlayParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new FatPointsMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('FatPointsMaterial', FatPointsMaterial);

  class FlatSurfaceMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      overlayParam = new MaterialFloatParam('Overlay', 0.0);
      constructor(name) {
          super(name);
          this.__shaderName = 'FlatSurfaceShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.overlayParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new FlatSurfaceMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('FlatSurfaceMaterial', FlatSurfaceMaterial);

  class LinesMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      opacityParam = new MaterialFloatParam('Opacity', 0.7, [0, 1]);
      overlayParam = new MaterialFloatParam('Overlay', 0.000001); // Provide a slight overlay so lines draw over meshes
      constructor(name) {
          super(name);
          this.__shaderName = 'LinesShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.opacityParam);
          this.addParameter(this.overlayParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new LinesMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('LinesMaterial', LinesMaterial);

  class PointsMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      pointSizeParam = new MaterialFloatParam('PointSize', 2);
      overlayParam = new MaterialFloatParam('Overlay', 0.00002); // Provide a slight overlay so lines draw over meshes
      constructor(name) {
          super(name);
          this.__shaderName = 'PointsShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.pointSizeParam);
          this.addParameter(this.overlayParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new PointsMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('PointsMaterial', PointsMaterial);

  class ScreenSpaceMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      constructor(name) {
          super(name);
          this.__shaderName = 'ScreenSpaceShader';
          this.addParameter(this.baseColorParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new ScreenSpaceMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('ScreenSpaceMaterial', ScreenSpaceMaterial);

  class SimpleSurfaceMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      opacityParam = new MaterialFloatParam('Opacity', 1, [0, 1]);
      emissiveStrengthParam = new MaterialFloatParam('EmissiveStrength', 0, [0, 1]);
      constructor(name) {
          super(name);
          this.__shaderName = 'SimpleSurfaceShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.opacityParam);
          this.addParameter(this.emissiveStrengthParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new SimpleSurfaceMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('SimpleSurfaceMaterial', SimpleSurfaceMaterial);

  class StandardSurfaceMaterial extends Material {
      baseColorParam = new MaterialColorParam('BaseColor', new Color(1.0, 1, 0.5));
      normalParam = new MaterialColorParam('Normal', new Color(1.0, 1, 0.5));
      ambientOcclusion = new MaterialFloatParam('AmbientOcclusion', 1, [0, 1]);
      metallicParam = new MaterialFloatParam('Metallic', 0.05, [0, 1]);
      roughnessParam = new MaterialFloatParam('Roughness', 0.5, [0, 1]);
      reflectanceParam = new MaterialFloatParam('Reflectance', 0.5, [0, 1]);
      emissiveStrengthParam = new MaterialFloatParam('EmissiveStrength', 0, [0, 1]);
      opacityParam = new MaterialFloatParam('Opacity', 1, [0, 1]);
      edgeWeightParam = new MaterialFloatParam('EdgeWeight', 0.7, [0, 1]);
      overlayParam = new MaterialFloatParam('Overlay', 0, [0, 1]);
      edgeColorParam = new MaterialColorParam('EdgeColor', new Color(0.1, 0.1, 0.1, 0.8));
      pointColorParam = new MaterialColorParam('PointColor', new Color(0.1, 0.1, 0.1));
      pointSizeParam = new MaterialFloatParam('PointSize', 4, [0, Number.MAX_VALUE]);
      constructor(name) {
          super(name);
          this.__shaderName = 'StandardSurfaceShader';
          this.addParameter(this.baseColorParam);
          this.addParameter(this.normalParam);
          this.addParameter(this.ambientOcclusion);
          this.addParameter(this.metallicParam);
          this.addParameter(this.roughnessParam);
          this.addParameter(this.reflectanceParam);
          this.addParameter(this.emissiveStrengthParam);
          this.addParameter(this.opacityParam);
          this.addParameter(this.edgeWeightParam);
          this.addParameter(this.overlayParam);
          this.addParameter(this.edgeColorParam);
          this.addParameter(this.pointColorParam);
          this.addParameter(this.pointSizeParam);
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new StandardSurfaceMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('StandardSurfaceMaterial', StandardSurfaceMaterial);

  class VertexColorMaterial extends Material {
      constructor(name) {
          super(name);
          this.__shaderName = 'VertexColorShader';
      }
      /**
       * The clone method constructs a new material, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned material.
       */
      clone(context) {
          const cloned = new VertexColorMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return false;
      }
  }
  Registry.register('VertexColorMaterial', VertexColorMaterial);

  class MaskMaterial extends SimpleSurfaceMaterial {
      constructor(name) {
          super(name);
          this.baseColorParam.value = new Color(1.0, 0.0, 0.0, 0.2);
      }
      clone(context) {
          const cloned = new MaskMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('MaskMaterial', MaskMaterial);

  class EnvProjectionMaterial extends Material {
      projectionCenter = new Vec3Parameter('projectionCenter', new Vec3(0.0, 0, 1.7));
      constructor(name) {
          super(name);
          this.__shaderName = 'EnvProjectionShader';
          this.addParameter(this.projectionCenter);
      }
      clone(context) {
          const cloned = new EnvProjectionMaterial();
          cloned.copyFrom(this, context);
          return cloned;
      }
      isTextured() {
          // Note: this is to force the generation of the MaterialShaderBinding
          // see GLShaderMaterials.addGLGeomItem
          return true;
      }
  }
  Registry.register('EnvProjectionMaterial', EnvProjectionMaterial);

  /**
   * Provides a context for loading assets. This context can provide the units of the loading scene.
   * E.g. you can specify the scene units as 'millimeters' in the context object.
   * To load external references, you can also provide a dictionary that maps filenames to URLs that are used
   * to resolve the URL of an external reference that a given asset is expecting to find.
   */
  class CloneContext extends EventEmitter {
      assetItem;
      /**
       * Create a AssetLoadContext
       * @param context The source context to base this context on.
       */
      constructor() {
          super();
          this.assetItem = null;
      }
  }

  /* eslint-disable no-unused-vars */
  /**
   * TreeItem type of class designed for making duplications of parts of the tree.
   *
   * @extends {TreeItem}
   */
  class InstanceItem extends TreeItem {
      srcTreePath = [];
      srcTree = null;
      /**
       * Create an instance item.
       * @param name - The name of the instance item.
       */
      constructor(name) {
          super(name);
      }
      /**
       * Clones passed in `TreeItem` all the way down and adds it as a child of current item.
       *
       * @param treeItem - The treeItem value.
       */
      setSrcTree(treeItem) {
          this.srcTree = treeItem;
          const clonedContext = new CloneContext();
          const clonedTree = this.srcTree.clone(clonedContext);
          clonedTree.localXfoParam.value = new Xfo();
          this.addChild(clonedTree, false, false);
      }
      /**
       * Returns the last `TreeItem` cloned.
       *
       * @return - The return value.
       */
      getSrcTree() {
          return this.srcTree;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current Item(Including cloned item) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          this.srcTreePath = reader.loadStrArray();
          if (this.srcTreePath.length > 0) {
              context.resolvePath(this.srcTreePath, (treeItem) => {
                  this.setSrcTree(treeItem);
              }, (error) => {
                  console.warn(`Error loading InstanceItem: ${this.getPath()}, unable to resolve: ${this.srcTreePath}. ` + error.message);
              });
          }
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new instance item, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned geom item.
       */
      clone(context) {
          const cloned = new InstanceItem();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Copies current TreeItem with all its children.
       *
       * @param src - The tree item to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          super.copyFrom(src, context);
          this.srcTreePath = src.srcTreePath;
          if (this.srcTreePath.length > 0 && this.getNumChildren() == 0) {
              src.once('childAdded', (event) => {
                  const childAddedEvent = event;
                  const childItem = childAddedEvent.childItem;
                  this.setSrcTree(childItem);
              });
          }
      }
  }
  Registry.register('InstanceItem', InstanceItem);

  /**
   * Base class that represents geometry items with layering, overlaying and cut away features.
   *
   * **Events**
   * * **cutAwayChanged:** Triggered when the cutaway variables change(if enabled or not, the vector and the distance).
   * @extends TreeItem
   */
  class BaseGeomItem extends TreeItem {
      overlay;
      cutAway;
      cutAwayVector;
      cutAwayDist;
      layers;
      /**
       * @member materialParam - The Material to use when rendering this GeomItem
       */
      materialParam = new MaterialParameter('Material');
      /**
       * Create a base geometry item.
       * @param name - The name of the base geom item.
       */
      constructor(name) {
          super(name);
          this.addParameter(this.materialParam);
          this.overlay = false;
          this.cutAway = false;
          this.cutAwayVector = new Vec3(0, 0, 0);
          this.cutAwayDist = 0;
          this.layers = [];
      }
      /**
       * Sets overlay value.
       *
       * @todo Need to find the layer and add this item to it.
       * @param val - `true` to enable it.
       */
      setOverlay(val) {
          // TODO: need to find the layer and add this item to it.
          this.overlay = val;
      }
      /**
       * Returns `true` if overlay is enabled for current item.
       *
       * @return - The return value.
       */
      isOverlay() {
          return this.overlay;
      }
      /**
       * Adds a layer to current item.
       *
       * @todo Need to find the layer and add this item to it.
       * @param name - The name of the layer.
       */
      addLayer(name) {
          // TODO: need to find the layer and add this item to it.
          this.layers.push(name);
      }
      /**
       * Returns all layers in current item.
       *
       * @return - The return value.
       */
      getLayers() {
          return this.layers;
      }
      // ////////////////////////////////////////
      // Cutaways
      /**
       * Checks if cutaway is enabled.
       *
       * @return - Returns `true` if enabled.
       */
      isCutawayEnabled() {
          return this.cutAway;
      }
      /**
       * Sets cutaway state.
       *
       * @param state - `true` to enable it, otherwise `false`.
       */
      setCutawayEnabled(state) {
          this.cutAway = state;
          this.emit('cutAwayChanged');
      }
      /**
       * Returns cutaway vector value.
       *
       * @return - `Vec3` when it is set, `false` on default.
       */
      getCutVector() {
          return this.cutAwayVector;
      }
      /**
       * Sets cutaway vector value.
       *
       * @param cutAwayVector - The cutAwayVector value.
       */
      setCutVector(cutAwayVector) {
          this.cutAwayVector = cutAwayVector;
          this.emit('cutAwayChanged');
      }
      /**
       * Getter for the cutaway distance.
       *
       * @return - The return value.
       */
      getCutDist() {
          return this.cutAwayDist;
      }
      /**
       * Sets cutaway distance value.
       *
       * @param cutAwayDist - The cutAwayDist value.
       */
      setCutDist(cutAwayDist) {
          this.cutAwayDist = cutAwayDist;
          this.emit('cutAwayChanged');
      }
      // ///////////////////////////
      // Persistence
      /**
       * Sets state of current Item(Including layers & material) using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          if (context.versions['zea-engine'].compare([0, 0, 4]) >= 0) {
              const materialName = reader.loadStr();
              // const materialName = 'Material' + this.__bodyDescId;
              const materialLibrary = context.assetItem.getMaterialLibrary();
              let material = materialLibrary.getMaterial(materialName);
              if (!material) {
                  // console.warn("BaseGeomItem :'" + this.name + "' Material not found:" + materialName);
                  // material = materialLibrary.getMaterial('DefaultMaterial');
                  material = new Material(materialName, 'SimpleSurfaceShader');
                  material.getParameter('BaseColor').loadValue(Color.random(0.25));
                  context.assetItem.getMaterialLibrary().addMaterial(material);
              }
              this.materialParam.loadValue(material);
              this.layers = reader.loadStrArray();
              if (this.layers.length > 0) {
                  // console.log("Layers:", this.layers)
                  for (const layer of this.layers)
                      context.addGeomToLayer(this, layer);
              }
          }
      }
  }

  let calculatePreciseBoundingBoxes = false;
  /** The operator the calculates the global Xfo of a TreeItem based on its parents GlobalXfo and its own LocalXfo
   * @extends Operator
   * @private
   */
  class CalcGeomMatOperator extends Operator {
      globalXfo = new XfoOperatorInput('GlobalXfo');
      geomOffsetXfo = new XfoOperatorInput('GeomOffsetXfo');
      geomMat = new Mat4OperatorOutput('GeomMat');
      /**
       *Creates an instance of CalcGeomMatOperator.
       *
       * @param globalXfoParam
       * @param geomOffsetXfoParam
       * @param geomMatParam
       * @memberof CalcGeomMatOperator
       */
      constructor(globalXfoParam, geomOffsetXfoParam, geomMatParam) {
          super('CalcGeomMatOperator');
          this.globalXfo.setParam(globalXfoParam);
          this.geomOffsetXfo.setParam(geomOffsetXfoParam);
          this.geomMat.setParam(geomMatParam);
          this.addInput(this.globalXfo);
          this.addInput(this.geomOffsetXfo);
          this.addOutput(this.geomMat);
      }
      /**
       * The evaluate method.
       */
      evaluate() {
          const globalMat4 = this.globalXfo.getValue().toMat4();
          const geomOffsetMat4 = this.geomOffsetXfo.getValue().toMat4();
          this.geomMat.setClean(globalMat4.multiply(geomOffsetMat4));
      }
  }
  /**
   * Class representing a geometry item in a scene tree.
   *
   * **Parameters**
   * * **Geometry(`GeometryParameter`):** The geometry to be rendered for this GeomItem
   * * **Material(`MaterialParameter`):** The Material to use when rendering this GeomItem
   * * **GeomOffsetXfo(`XfoParameter`):** Provides an offset transformation that is applied only to the geometry and not inherited by child items.
   * * **GeomMat(`Mat4Parameter`):** Calculated from the GlobalXfo and the GeomOffsetXfo, this matrix is provided to the renderer for rendering.
   *
   * @extends BaseGeomItem
   */
  class GeomItem extends BaseGeomItem {
      listenerIDs = {};
      geomBBox;
      geomIndex = -1;
      assetItem = null;
      calcGeomMatOperator;
      cullable = true;
      /**
       * @member geomOffsetXfoParam - Provides an offset transformation that is applied only to the geometry and not inherited by child items.
       */
      geomOffsetXfoParam = new XfoParameter('GeomOffsetXfo');
      /**
       * @member geomParam - The geometry to be rendered for this GeomItem
       */
      geomParam = new GeometryParameter('Geometry');
      /**
       * @member geomMatParam - Calculated from the GlobalXfo and the GeomOffsetXfo, this matrix is provided to the renderer for rendering.
       */
      geomMatParam = new Mat4Parameter('GeomMat');
      /**
       * Creates a geometry item.
       * @param name - The name of the geom item.
       * @param geometry - The geometry value.
       * @param material - The material value.
       * @param xfo - The initial Xfo of the new GeomItem.
       */
      constructor(name, geometry, material, xfo) {
          super(name);
          this.addParameter(this.geomParam);
          this.addParameter(this.geomOffsetXfoParam);
          this.addParameter(this.geomMatParam);
          const geomChanged = () => {
              this.setBoundingBoxDirty();
          };
          this.geomParam.on('valueChanged', geomChanged);
          this.geomParam.on('boundingBoxChanged', geomChanged);
          this.calcGeomMatOperator = new CalcGeomMatOperator(this.globalXfoParam, this.geomOffsetXfoParam, this.geomMatParam);
          if (geometry)
              this.geomParam.loadValue(geometry);
          if (material)
              this.materialParam.loadValue(material);
          if (xfo)
              this.localXfoParam.value = xfo;
      }
      /**
       * The _cleanBoundingBox method.
       * @private
       */
      _cleanBoundingBox() {
          if (this.disableBoundingBox)
              return new Box3();
          const bbox = super._cleanBoundingBox();
          if (this.geomBBox) {
              // Note: this bbox is the global bounding box of the geomItem
              // transformed into the space of the geometry. We reapply
              // the geom matrix to get back the points in global space.
              const mat4 = this.geomMatParam.value;
              bbox.addPoint(mat4.transformVec3(this.geomBBox.p0));
              bbox.addPoint(mat4.transformVec3(this.geomBBox.p1));
          }
          else {
              const geom = this.geomParam.value;
              if (geom) {
                  if (calculatePreciseBoundingBoxes) {
                      // Note: compting the precise bounding box is much slower and
                      // can make loading big scenes take a bit longer.
                      const mat4 = this.geomMatParam.value;
                      const buffers = geom.genBuffers();
                      if (geom instanceof BaseProxy) {
                          const positions = buffers.attrBuffers['positions'].values;
                          const getVertex = (index) => {
                              const start = index * 3;
                              const value = new Vec3();
                              value.fromArray(positions.subarray(start, start + 3));
                              return value;
                          };
                          for (let i = 0; i < geom.getNumVertices(); i++) {
                              bbox.addPoint(mat4.transformVec3(getVertex(i)));
                          }
                      }
                      else {
                          const positions = geom.getVertexAttribute('positions');
                          for (let i = 0; i < geom.getNumVertices(); i++) {
                              bbox.addPoint(mat4.transformVec3(positions.getValue(i)));
                          }
                      }
                  }
                  else {
                      bbox.addBox3(geom.getBoundingBox(), this.geomMatParam.value);
                  }
              }
          }
          return bbox;
      }
      // ///////////////////////////
      // Debugging
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          super.fromJSON(json, context);
      }
      /**
       * Loads state of the Item from a binary object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          const itemFlags = reader.loadUInt8();
          const geomIndex = reader.loadUInt32();
          const geomLibrary = context.assetItem.getGeometryLibrary();
          this.geomIndex = geomIndex;
          this.assetItem = context.assetItem;
          const geom = geomLibrary.getGeom(geomIndex);
          if (geom) {
              this.geomParam.loadValue(geom);
          }
          else {
              const onGeomLoaded = (event) => {
                  const { range } = event;
                  if (geomIndex >= range[0] && geomIndex < range[1]) {
                      const geom = geomLibrary.getGeom(geomIndex);
                      if (geom)
                          this.geomParam.value = geom;
                      else
                          console.warn('Geom not loaded:', this.getName());
                      geomLibrary.off('rangeLoaded', onGeomLoadedListenerID);
                  }
              };
              const onGeomLoadedListenerID = geomLibrary.on('rangeLoaded', onGeomLoaded);
          }
          // this.setVisibility(j.visibility);
          // Note: to save space, some values are skipped if they are identity values
          const geomOffsetXfoFlag = 1 << 2;
          if (itemFlags & geomOffsetXfoFlag) {
              this.geomOffsetXfoParam.value = new Xfo(reader.loadFloat32Vec3(), reader.loadFloat32Quat(), reader.loadFloat32Vec3());
          }
          // BaseGeomItem now handles loading materials.
          if (context.versions['zea-engine'].compare([0, 0, 4]) < 0) {
              const materialFlag = 1 << 3;
              if (itemFlags & materialFlag) {
                  const materialLibrary = context.assetItem.getMaterialLibrary();
                  const materialName = reader.loadStr();
                  let material = materialLibrary.getMaterial(materialName);
                  if (!material) {
                      console.warn("Geom :'" + this.__name + "' Material not found:" + materialName);
                      material = materialLibrary.getMaterial('Default');
                  }
                  this.materialParam.loadValue(material);
              }
              else {
                  // Force nodes to have a material so we can see them.
                  this.materialParam.loadValue(context.assetItem.getMaterialLibrary().getMaterial('Default'));
              }
          }
          // Note: deprecated value. Not sure if we need to load this here.
          // I think not, but need to test first.
          if (context.versions['zea-engine'].compare([3, 0, 0]) < 0) {
              // Load the 'lightmapCoordOffset' value which we no longer use.
              // Note: we need to load it to increment the file pointer.
              reader.loadFloat32Vec2();
          }
          else {
              this.geomBBox = new Box3(reader.loadFloat32Vec3(), reader.loadFloat32Vec3());
          }
      }
      /**
       * Returns string representation of current object's state.
       * @param context
       * @return - The return value.
       */
      toString(context) {
          return JSON.stringify(this.toJSON(context), null, 2);
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new geom item, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned geom item.
       */
      clone(context) {
          const cloned = new GeomItem();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Copies current GeomItem with all its children.
       *
       * @param src - The geom item to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          super.copyFrom(src, context);
          this.geomOffsetXfoParam.value = src.geomOffsetXfoParam.value;
          if (!src.geomParam.value && src.geomIndex != -1) {
              const geomLibrary = src.assetItem.getGeometryLibrary();
              this.assetItem = src.assetItem;
              this.geomIndex = src.geomIndex;
              this.geomBBox = src.geomBBox;
              const onGeomLoaded = (event) => {
                  const { range } = event;
                  if (this.geomIndex >= range[0] && this.geomIndex < range[1]) {
                      const geom = geomLibrary.getGeom(this.geomIndex);
                      // Note: we need the 'valueChanged' event to be received by the
                      // renderer to then load the geometry into the GPU.
                      // @ts-ignore
                      if (geom)
                          this.geomParam.value = geom;
                      else
                          console.warn('Geom not loaded:', this.getName());
                      geomLibrary.off('rangeLoaded', this.listenerIDs['rangeLoaded']);
                  }
              };
              this.listenerIDs['rangeLoaded'] = geomLibrary.on('rangeLoaded', onGeomLoaded);
          }
          // Geom Xfo should be dirty after cloning.
          // Note: this might not be necessary. It should
          // always be dirty after cloning.
          this.geomMatParam.setDirty(0);
      }
      /**
       * Sets the global boolean that controls if GeomItems calculate precise bounding boxes
       * or use the approximate bounding boxes that are much faster to generate.
       * Note: computing the precise bounding box is much slower and can make loading
       * big scenes take a bit longer. This setting is only relevant to geometries loaded
       * from zcad files.
       * @deprecated
       * zcad files from version 3.11.0 contain precise bounding boxes by default.
       * @param value - true for precise bounding boxes, else false for faster approximate bounding boxes.
       */
      static setCalculatePreciseBoundingBoxes(value) {
          calculatePreciseBoundingBoxes = value;
      }
  }
  Registry.register('GeomItem', GeomItem);

  /**
   * @private
   * @extends BaseGeom
   */
  class CompoundGeomLoader extends BaseGeom {
      numSubGeoms = 0;
      indices = new Uint8Array(0);
      offsets = {};
      counts = {};
      // For each type of geom (TRIANGLES, LINES)
      // A material id, and each start and end of the block
      materialSubGeoms = {};
      subGeomOffsets = {};
      subGeomCounts = {};
      materialLibraryIndices = new Uint32Array(0);
      subGeomMaterialIndices = new Uint8Array(0);
      /**
       * Create points.
       */
      constructor() {
          super();
      }
      genBuffers() {
          const attrBuffers = {};
          for (const [attrName, attr] of this.__vertexAttributes) {
              attrBuffers[attrName] = attr.genBuffer();
          }
          const numVertices = this.numVertices();
          const result = {
              numVertices,
              numRenderVerts: numVertices,
              indices: this.indices,
              attrBuffers,
              offsets: this.offsets,
              counts: this.counts,
              numSubGeoms: this.numSubGeoms,
              subGeomOffsets: this.subGeomOffsets,
              subGeomCounts: this.subGeomCounts,
              materialLibraryIndices: this.materialLibraryIndices,
              subGeomMaterialIndices: this.subGeomMaterialIndices,
              materialSubGeoms: this.materialSubGeoms,
          };
          return result;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current geometry(Including line segments) using a binary reader object.
       *
       * @param {BinReader} reader - The reader value.
       * @param {Record<string, unknown>} context - The context value.
       */
      readBinary(reader, context) {
          super.loadBaseGeomBinary(reader, context);
          const geomCountsByType = reader.loadUInt32Array(3);
          this.offsets['TRIANGLES'] = 0;
          this.counts['TRIANGLES'] = geomCountsByType[0];
          this.offsets['LINES'] = geomCountsByType[0];
          this.counts['LINES'] = geomCountsByType[1];
          this.offsets['POINTS'] = geomCountsByType[0] + geomCountsByType[1];
          this.counts['POINTS'] = geomCountsByType[2];
          const bytes = reader.loadUInt8();
          // Note: do not clone the source arrays as we will transfer the
          // entire buffer back to the main thread where it will be freed once
          // the data is uploaded to the GPU.
          if (bytes == 1)
              this.indices = reader.loadUInt8Array();
          else if (bytes == 2)
              this.indices = reader.loadUInt16Array();
          else if (bytes == 4)
              this.indices = reader.loadUInt32Array();
          // /////////////////////////////////
          // TRIANGLES subgeoms
          const bytesMeshSubGeoms = reader.loadUInt8();
          let subGeomCountsMesh;
          if (bytesMeshSubGeoms == 1)
              subGeomCountsMesh = reader.loadUInt8Array();
          else if (bytesMeshSubGeoms == 2)
              subGeomCountsMesh = reader.loadUInt16Array();
          else if (bytesMeshSubGeoms == 4)
              subGeomCountsMesh = reader.loadUInt32Array();
          else {
              throw Error('subGeomOffsets undefined');
          }
          const subGeomOffsetsMesh = new Uint32Array(subGeomCountsMesh.length);
          let offset = 0;
          for (let i = 0; i < subGeomCountsMesh.length; i++) {
              subGeomOffsetsMesh[i] = offset;
              offset += subGeomCountsMesh[i];
          }
          this.subGeomOffsets['TRIANGLES'] = subGeomOffsetsMesh;
          this.subGeomCounts['TRIANGLES'] = subGeomCountsMesh;
          // /////////////////////////////////
          // LINES subgeoms
          const bytesLinesSubGeoms = reader.loadUInt8();
          let subGeomCountsLines;
          if (bytesLinesSubGeoms == 1)
              subGeomCountsLines = reader.loadUInt8Array();
          else if (bytesLinesSubGeoms == 2)
              subGeomCountsLines = reader.loadUInt16Array();
          else if (bytesLinesSubGeoms == 4)
              subGeomCountsLines = reader.loadUInt32Array();
          else {
              throw Error('subGeomOffsets undefined');
          }
          const subGeomOffsetsLines = new Uint32Array(subGeomCountsLines.length);
          for (let i = 0; i < subGeomCountsLines.length; i++) {
              subGeomOffsetsLines[i] = offset;
              offset += subGeomCountsLines[i];
          }
          this.subGeomOffsets['LINES'] = subGeomOffsetsLines;
          this.subGeomCounts['LINES'] = subGeomCountsLines;
          // /////////////////////////////////
          // POINTS subgeoms
          const numPointsSubGeoms = reader.loadUInt32();
          const subGeomOffsetsPoints = new Uint32Array(numPointsSubGeoms);
          const subGeomCountsPoints = new Uint8Array(numPointsSubGeoms);
          for (let i = 0; i < numPointsSubGeoms; i++) {
              subGeomOffsetsPoints[i] = offset;
              subGeomCountsPoints[i] = 1;
              offset++;
          }
          this.subGeomOffsets['POINTS'] = subGeomOffsetsPoints;
          this.subGeomCounts['POINTS'] = subGeomCountsPoints;
          if (context.versions['zea-engine'].compare([3, 11, 0]) > 0) {
              // Points sub-geoms were not being exported before this release.
              this.numSubGeoms = subGeomCountsMesh.length + subGeomCountsLines.length + numPointsSubGeoms;
          }
          else {
              this.numSubGeoms = subGeomCountsMesh.length + subGeomCountsLines.length;
          }
          // /////////////////////////////////
          // Materials
          const numMaterials = reader.loadUInt32();
          if (numMaterials > 0) {
              this.materialLibraryIndices = reader.loadUInt32Array(numMaterials);
              this.subGeomMaterialIndices = reader.loadUInt8Array(this.numSubGeoms);
              // /////////////////////////////////
              // Material Groups
              let offset = 0;
              let currMaterial = -99;
              let currMaterialSubGeom = null;
              for (let i = 0; i < this.numSubGeoms; i++) {
                  let key;
                  let subGeomOffset = 0;
                  if (i < this.subGeomCounts.TRIANGLES.length) {
                      if (!this.materialSubGeoms.TRIANGLES)
                          this.materialSubGeoms.TRIANGLES = [];
                      key = 'TRIANGLES';
                  }
                  else if (i < this.subGeomCounts.TRIANGLES.length + this.subGeomCounts.LINES.length) {
                      subGeomOffset = this.subGeomCounts.TRIANGLES.length;
                      key = 'LINES';
                      if (!this.materialSubGeoms.LINES)
                          this.materialSubGeoms.LINES = [];
                  }
                  else {
                      subGeomOffset = this.subGeomCounts.TRIANGLES.length + this.subGeomCounts.LINES.length;
                      key = 'POINTS';
                      if (!this.materialSubGeoms.POINTS)
                          this.materialSubGeoms.POINTS = [];
                  }
                  const materialId = this.subGeomMaterialIndices[i];
                  if (currMaterial != materialId) {
                      currMaterial = materialId;
                      // Note: subGeomMaterialIndices is Uint8Array, and 0 means no custom
                      // material is assigned to the subGeom.
                      // Subtract 1 to get the actual material id.
                      currMaterialSubGeom = {
                          materialId: materialId - 1,
                          offset,
                          count: 0,
                      };
                      for (; i < this.numSubGeoms; i++) {
                          if (currMaterial != this.subGeomMaterialIndices[i]) {
                              break;
                          }
                          // When we get to the end og this geom type (e.g .TRIANGLES)
                          // start a new subgeom.
                          if (i - subGeomOffset == this.subGeomCounts[key].length) {
                              // Force the material index to be reset on line 162 above.
                              currMaterial = -99;
                              break;
                          }
                          currMaterialSubGeom.count += this.subGeomCounts[key][i - subGeomOffset];
                      }
                      offset += currMaterialSubGeom.count;
                      this.materialSubGeoms[key].push(currMaterialSubGeom);
                      i--;
                  }
              }
              // Note: older version of zcad files would list materials for TRIANGLES and LINES,
              // but not points, leaving the points unrendered.
              if (this.subGeomCounts.POINTS.length > 0 && !this.materialSubGeoms.POINTS) {
                  this.materialSubGeoms.POINTS = [
                      {
                          materialId: -1,
                          offset,
                          count: this.subGeomCounts.POINTS.length,
                      },
                  ];
              }
          }
          else {
              this.materialSubGeoms = {};
              let offset = 0;
              for (let key in this.counts) {
                  const count = this.counts[key];
                  if (count > 0) {
                      this.materialSubGeoms[key] = [
                          {
                              materialId: -1,
                              offset,
                              count,
                          },
                      ];
                  }
                  offset += count;
              }
          }
          this.emit('geomDataChanged', {});
      }
  }

  /* eslint-disable guard-for-in */
  // key, toc, geomIndexOffset, geomsRange, isMobileDevice, bufferSlice, genBuffersOpts, context
  const parseGeomsBinary = (data, callback) => {
      // eslint-disable-next-line guard-for-in
      for (const key in data.context.versions) {
          const v = data.context.versions[key];
          const version = new Version('');
          version.major = v.major;
          version.minor = v.minor;
          version.patch = v.patch;
          version.branch = v.branch;
          data.context.versions[key] = version;
      }
      const geomDatas = [];
      const byteOffset = data.byteOffset;
      // console.log('byteOffset:' + byteOffset, ' geomsRange:', data.geomsRange)
      const transferables = [];
      for (let i = data.geomsRange[0]; i < data.geomsRange[1]; i++) {
          const reader = new BinReader(data.bufferSlice, data.toc[i] - byteOffset, data.isMobileDevice);
          const className = reader.loadStr();
          const pos = reader.pos();
          // const name = reader.loadStr()
          // console.log(
          //   i +
          //     ':' +
          //     byteOffset +
          //     ' className:' +
          //     className +
          //     ' name:' +
          //     name /* + " pos:" + (data.toc[i] - byteOffset) + " bufferSlice.byteLength:" +  bufferSlice.byteLength*/
          // )
          let geom;
          switch (className) {
              case 'Points':
                  geom = new Points();
                  break;
              case 'Lines':
                  geom = new Lines();
                  break;
              case 'Mesh':
                  geom = new Mesh();
                  break;
              case 'CompoundGeom':
                  geom = new CompoundGeomLoader();
                  break;
              default:
                  throw new Error('Unsupported Geom type:' + className);
          }
          try {
              reader.seek(pos); // Reset the pointer to the start of the item data.
              geom.readBinary(reader, data.context);
          }
          catch (e) {
              console.warn('Error loading:' + geom.name + '\n:' + e);
              geomDatas.push({});
              continue;
          }
          const geomBuffers = geom.genBuffers(data.genBuffersOpts);
          // /////////////////////////////////
          // Transferables
          // Transfer all the attributes and indices back to the main thread.
          if (geomBuffers.indices)
              transferables.push(geomBuffers.indices.buffer);
          for (const attrName in geomBuffers.attrBuffers) {
              // Note: The type value assigned to the attribute can
              // not be transferred back to the main thread. Convert to
              // the type name here and send back as a string.
              const attrData = geomBuffers.attrBuffers[attrName];
              transferables.push(attrData.values.buffer);
          }
          // Compoound Geom buffers
          if (geomBuffers.materialLibraryIndices) {
              transferables.push(geomBuffers.materialLibraryIndices.buffer);
          }
          if (geomBuffers.subGeomMaterialIndices) {
              transferables.push(geomBuffers.subGeomMaterialIndices.buffer);
          }
          if (geomBuffers.subGeomOffsets) {
              for (let key in geomBuffers.subGeomOffsets) {
                  transferables.push(geomBuffers.subGeomOffsets[key].buffer);
              }
          }
          // if (geomBuffers.vertexNeighbors) {
          //   transferables.push(geomBuffers.vertexNeighbors.buffer)
          // }
          // /////////////////////////////////
          geomDatas.push({
              name: geom.name,
              type: className,
              geomBuffers,
              bbox: geom.getBoundingBox(),
          });
      }
      callback({
          taskId: data.taskId,
          geomLibraryId: data.geomLibraryId,
          geomFileID: data.geomFileID,
          geomIndexOffset: data.geomIndexOffset,
          geomsRange: data.geomsRange,
          geomDatas,
      }, transferables);
  };

  const handleMessage = function (srcData, postMessage) {
    parseGeomsBinary(srcData, (resultData, transferables) => {
      postMessage(resultData, transferables);
    });
  };

  // Check to see if we are running in the Worker before assigning onmessage
  if (globalThis.document === undefined) {
    globalThis.onmessage = function (event) {
      if (!event.data) {
        // Note: we see this occur when loading one large asset many times.
        // Like when loading the portafil.
        // It may be due to memory issues, but its not clear.
        console.warn('GeomLibrary worker.postMessage failed. data was lost on the way to the web worker.');
        return
      }
      // Our worker gets triggered
      if (!event.data.context) {
        return
      }
      handleMessage(event.data, self.postMessage);
    };
  }

  var WorkerFactory$1 = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAgICd1c2Ugc3RyaWN0JzsKCiAgICAvKioNCiAgICAgKiBTdHJpbmcgZnVuY3Rpb25zDQogICAgICoNCiAgICAgKi8NCiAgICBjbGFzcyBTdHJpbmdGdW5jdGlvbnMgew0KICAgICAgICAvKioNCiAgICAgICAgICogUmVwbGFjZXMgYWxsIG1hdGNoZXMgaW4gYSBzdHJpbmcuDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIHN0ciAtDQogICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuIC0NCiAgICAgICAgICogQHBhcmFtIHJlcGxhY2VtZW50IC0NCiAgICAgICAgICogQHJldHVybiAtDQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgcmVwbGFjZUFsbChzdHIsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7DQogICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpLCByZXBsYWNlbWVudCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgSlNPTiBvYmplY3QgYXMgYSBmb3JtYXR0ZWQgc3RyaW5nLCBidXQgdGhlIG51bWVyaWMgdmFsdWVzIGFyZSBmaXhlZCB0byB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gdmFsIC0NCiAgICAgICAgICogQHBhcmFtIHNwYWNlIC0NCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtDQogICAgICAgICAqIEByZXR1cm4gLQ0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIHN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odmFsLCBzcGFjZSA9IDAsIHByZWNpc2lvbiA9IDUpIHsNCiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwsIChfLCB2YWwpID0+IHsNCiAgICAgICAgICAgICAgICByZXR1cm4gdmFsID8gKHZhbC50b0ZpeGVkID8gTnVtYmVyKHZhbC50b0ZpeGVkKHByZWNpc2lvbikpIDogdmFsKSA6IHZhbDsNCiAgICAgICAgICAgIH0sIHNwYWNlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSBudW1lcmljIHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSBzdHIgLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBoYXNoU3RyKHN0cikgew0KICAgICAgICAgICAgbGV0IGhhc2ggPSAwOw0KICAgICAgICAgICAgbGV0IGk7DQogICAgICAgICAgICBsZXQgY2hyOw0KICAgICAgICAgICAgbGV0IGxlbjsNCiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKQ0KICAgICAgICAgICAgICAgIHJldHVybiBoYXNoOw0KICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7DQogICAgICAgICAgICAgICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7DQogICAgICAgICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjsNCiAgICAgICAgICAgICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlcg0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGhhc2gpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKg0KICAgICAqIFJlcHJlc2VudGluZyBhIFZlYzIodHdvLWRpbWVuc2lvbmFsIGZsb2F0aW5nIHBvaW50IHZlY3RvcikuIEEgVmVjMiBpcyBmb3IgcmVwcmVzZW50aW5nIDIgZGltZW5zaW9uYWwgdmFsdWVzLCBzdWNoIGFzIHNjcmVlbiBjb29yZGluYXRlcyBvciBwaXhlbCBjb29yZGluYXRlcyB3aXRoaW4gYW4gaW1hZ2UuDQogICAgICoNCiAgICAgKiBNYXRoIHR5cGVzIGludGVybmFsbHkgc3RvcmUgdmFsdWVzIGluIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSBhbmQNCiAgICAgKiBleHBvc2UgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhlIGNvbXBvbmVudCB2YWx1ZXMuDQogICAgICoNCiAgICAgKi8NCiAgICBjbGFzcyBWZWMyIHsNCiAgICAgICAgeDsNCiAgICAgICAgeTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICAgICAqICBjb25zdCBteVZlYzIgPSBuZXcgVmVjMigxLjIsIDMuNCkNCiAgICAgICAgICogYGBgDQogICAgICAgICAqDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHsNCiAgICAgICAgICAgIHRoaXMueCA9IHg7DQogICAgICAgICAgICB0aGlzLnkgPSB5Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4NCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgeCBjb21wb25lbnQuDQogICAgICAgICAqIEBwYXJhbSB5ICAtIFRoZSB5IGNvbXBvbmVudC4NCiAgICAgICAgICovDQogICAgICAgIHNldCh4LCB5KSB7DQogICAgICAgICAgICB0aGlzLnggPSB4Ow0KICAgICAgICAgICAgdGhpcy55ID0geTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmVwbGFjZXMgdGhpcyBWZWMyIGRhdGEgd2l0aCB0aGUgVmVjMiBkYXRhIHBhc3NlZCBhcyBwYXJhbWV0ZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHNldCBmcm9tLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU90aGVyKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggPSBvdGhlci54Ow0KICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBjb250YWlucyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIG90aGVyIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIGFyZSB0aGUgc2FtZSBWZWN0b3IsIG90aGVyd2lzZSwgYGZhbHNlYC4NCiAgICAgICAgICovDQogICAgICAgIGlzRXF1YWwob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0gb3RoZXIueCAmJiB0aGlzLnkgPT0gb3RoZXIueTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBWZWMycyBhcmUgZGlmZmVyZW50LCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAgICAgICAqLw0KICAgICAgICBub3RFcXVhbChvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBWZWMyIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgICAgICAgKi8NCiAgICAgICAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiYgTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCBwcmVjaXNpb247DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gYWRkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgYSBWZWMyIHRvIHRoaXMgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gYWRkLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkSW5QbGFjZShvdGhlcikgew0KICAgICAgICAgICAgdGhpcy54ICs9IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgKz0gb3RoZXIueTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIGEgVmVjMiBmcm9tIHRoaXMgVmVjMiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHN1YnRyYWN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgICAgICAgKi8NCiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIGEgVmVjMiBmcm9tIHRoaXMgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gc3VidHJhY3QuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAgICAgICAqLw0KICAgICAgICBzdWJ0cmFjdEluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMueCAtPSBvdGhlci54Ow0KICAgICAgICAgICAgdGhpcy55IC09IG90aGVyLnk7DQogICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2NhbGVzIHRoaXMgVmVjMiBieSBzY2FsYXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIHNjYWxlKHNjYWxhcikgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2NhbGVzIHRoaXMgVmVjMiBieSBzY2FsYXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjsNCiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsYXI7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEludmVydHMgdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGludmVydCgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMigxLjAgLyB0aGlzLngsIDEuMCAvIHRoaXMueSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEludmVydHMgdGhpcyBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGludmVydEluUGxhY2UoKSB7DQogICAgICAgICAgICB0aGlzLnggPSAxLjAgLyB0aGlzLng7DQogICAgICAgICAgICB0aGlzLnkgPSAxLjAgLyB0aGlzLnk7DQogICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTXVsdGlwbGllcyBhIFZlYzIgd2l0aCB0aGlzIFZlYzIgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBtdWx0aXBseSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLg0KICAgICAgICAgKi8NCiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggKiBvdGhlci54LCB0aGlzLnkgKiBvdGhlci55KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTXVsdGlwbGllcyBhIFZlYzIgd2l0aCB0aGlzIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqLw0KICAgICAgICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMueCAqPSBvdGhlci54Ow0KICAgICAgICAgICAgdGhpcy55ICo9IG90aGVyLnk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aCBzcXVhcmVkLg0KICAgICAgICAgKi8NCiAgICAgICAgbGVuZ3RoU3F1YXJlZCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgICAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAgICAgICAqLw0KICAgICAgICBsZW5ndGgoKSB7DQogICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgdG8gYW5vdGhlciB2ZWN0b3IuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9ycy4NCiAgICAgICAgICovDQogICAgICAgIGRpc3RhbmNlVG8ob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBvdGhlci54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIG90aGVyLnk7DQogICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBWZWMyIGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFZlYzIuDQogICAgICAgICAqIE11bHRpcGxpZXMgY29vcmRpbmF0ZXMgdmFsdWUgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBWZWMyIG5vcm1hbGl6ZWQuDQogICAgICAgICAqLw0KICAgICAgICBub3JtYWxpemUoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5Ow0KICAgICAgICAgICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBUT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT8NCiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4ICogbGVuLCB5ICogbGVuKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTm9ybWFsaXplcyB0aGlzIFZlYzIgbXVsdGlwbHlpbmcgY29vcmRpbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAgICAgICAqLw0KICAgICAgICBub3JtYWxpemVJblBsYWNlKCkgew0KICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnk7DQogICAgICAgICAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeTsNCiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIHRoaXMuc2V0KHggKiBsZW4sIHkgKiBsZW4pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzIgYWdhaW5zdCBhbm90aGVyIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgZG90KG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyBWZWMyIGFnYWluc3QgYW5vdGhlciBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgY3Jvc3Mob3RoZXIpIHsNCiAgICAgICAgICAgIC8vIGp1c3QgY2FsY3VsYXRlIHRoZSB6LWNvbXBvbmVudA0KICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIG90aGVyLnkgLSB0aGlzLnkgKiBvdGhlci54Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjMiBhbmQgb3RoZXIgYXNzdW1pbmcgYm90aCBhcmUgbm9ybWFsaXplZCB2ZWN0b3JzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLg0KICAgICAgICAgKi8NCiAgICAgICAgYW5nbGVUbyhvdGhlcikgew0KICAgICAgICAgICAgY29uc3QgY29zaW5lID0gdGhpcy5ub3JtYWxpemUoKS5kb3Qob3RoZXIubm9ybWFsaXplKCkpOw0KICAgICAgICAgICAgaWYgKGNvc2luZSA+IDEuMCkNCiAgICAgICAgICAgICAgICByZXR1cm4gMC4wOw0KICAgICAgICAgICAgZWxzZSBpZiAoY29zaW5lIDwgLTEuMCkNCiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5QSTsNCiAgICAgICAgICAgIGVsc2UNCiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBWZWMyIGFuZCBvdGhlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucy4NCiAgICAgICAgICovDQogICAgICAgIHNpZ25lZEFuZ2xlVG8ob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5hbmdsZVRvKG90aGVyKTsNCiAgICAgICAgICAgIGlmICh0aGlzLmNyb3NzKG90aGVyKSA8IDAuMCkNCiAgICAgICAgICAgICAgICByZXR1cm4gLWFuZ2xlOw0KICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICAgIHJldHVybiBhbmdsZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUm90YXRlcyBhIFZlYzIgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IHJvdGF0ZWQgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0b3IuDQogICAgICAgICAqLw0KICAgICAgICByb3RhdGUoYW5nbGUpIHsNCiAgICAgICAgICAgIGNvbnN0IGNvc0EgPSBNYXRoLmNvcyhhbmdsZSk7DQogICAgICAgICAgICBjb25zdCBzaW5BID0gTWF0aC5zaW4oYW5nbGUpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCAqIGNvc0EgLSB0aGlzLnkgKiBzaW5BLCB0aGlzLnggKiBzaW5BICsgdGhpcy55ICogY29zQSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGlzIFZlYzIgYW5kIG90aGVyIFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGludGVycG9sYXRlIGJldHdlZW4uDQogICAgICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGxlcnAob3RoZXIsIHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoYXggKyB0ICogKG90aGVyLnggLSBheCksIGF5ICsgdCAqIChvdGhlci55IC0gYXkpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNjYWxlIC0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWQuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0UmFuZG9tRGlyKHNjYWxlID0gMS4wKSB7DQogICAgICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUEk7DQogICAgICAgICAgICB0aGlzLnggPSBNYXRoLmNvcyhyKSAqIHNjYWxlOw0KICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5zaW4ocikgKiBzY2FsZTsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSYW5kb21pemVzIHRoZSBzY2FsZSBvZiB0aGlzIFZlYzIgY29vcmRpbmF0ZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsZSAtIFRoZSBzY2FsZSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRSYW5kb20oc2NhbGUgPSAxLjApIHsNCiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgKiBzY2FsZTsNCiAgICAgICAgICAgIHRoaXMueSA9IE1hdGgucmFuZG9tKCkgKiBzY2FsZTsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDbG9uZXMgdGhpcyBWZWMyIGFuZCByZXR1cm5zIGEgbmV3IFZlYzIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY3VycmVudCBWZWMyIGRhdGEgYXMgYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhcyBhbiBhcnJheS4NCiAgICAgICAgICovDQogICAgICAgIGFzQXJyYXkoKSB7DQogICAgICAgICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0dGVyIGZyb20gYW4gYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tQXJyYXkodmFscykgew0KICAgICAgICAgICAgdGhpcy54ID0gdmFsc1swXTsNCiAgICAgICAgICAgIHRoaXMueSA9IHZhbHNbMV07DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZlYzMgdG8gYSBzdHJpbmcgaW4gSlNPTiBmb3JtYXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9TdHJpbmcoKSB7DQogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFbmNvZGVzIFZlYzIgQ2xhc3MgYXMgYSBKU09OIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oKSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHg6IHRoaXMueCwNCiAgICAgICAgICAgICAgICB5OiB0aGlzLnksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIHRoaXMueCA9IGoueDsNCiAgICAgICAgICAgIHRoaXMueSA9IGoueTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgICAgICAgICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgMiAyZCBsaW5lcywgcmV0dXJuaW5nIHRoZSBwYXJhbWV0ZXJzIHZhbHVlcyBmb3IgZWFjaCBsaW5lLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcDAgLSBUaGUgcG9pbnQgb2YgdGhlIGZpcnN0IGxpbmUNCiAgICAgICAgICogQHBhcmFtIGQwIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgZmlyc3QgbGluZQ0KICAgICAgICAgKiBAcGFyYW0gcDEgLSBUaGUgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lDQogICAgICAgICAqIEBwYXJhbSBkMSAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlY29uZCBsaW5lDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgMiBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgMiBsaW5lcy4NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBpbnRlcnNlY3Rpb25PZkxpbmVzKHAxLCBwMiwgcDMsIHA0KSB7DQogICAgICAgICAgICAvLyBodHRwczovL2RpcmFzay5jb20vcG9zdHMvSmF2YVNjcmlwdC1ob3ctdG8tY2FsY3VsYXRlLWludGVyc2VjdGlvbi1wb2ludC1vZi10d28tbGluZXMtZm9yLWdpdmVuLTQtcG9pbnRzLVZqdm5Bag0KICAgICAgICAgICAgLy8gZG93biBwYXJ0IG9mIGludGVyc2VjdGlvbiBwb2ludCBmb3JtdWxhDQogICAgICAgICAgICBjb25zdCBkMSA9IChwMS54IC0gcDIueCkgKiAocDMueSAtIHA0LnkpOyAvLyAoeDEgLSB4MikgKiAoeTMgLSB5NCkNCiAgICAgICAgICAgIGNvbnN0IGQyID0gKHAxLnkgLSBwMi55KSAqIChwMy54IC0gcDQueCk7IC8vICh5MSAtIHkyKSAqICh4MyAtIHg0KQ0KICAgICAgICAgICAgY29uc3QgZCA9IGQxIC0gZDI7DQogICAgICAgICAgICBpZiAoZCA9PSAwKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyB1cHBlciBwYXJ0IG9mIGludGVyc2VjdGlvbiBwb2ludCBmb3JtdWxhDQogICAgICAgICAgICBjb25zdCB1MSA9IHAxLnggKiBwMi55IC0gcDEueSAqIHAyLng7IC8vICh4MSAqIHkyIC0geTEgKiB4MikNCiAgICAgICAgICAgIGNvbnN0IHU0ID0gcDMueCAqIHA0LnkgLSBwMy55ICogcDQueDsgLy8gKHgzICogeTQgLSB5MyAqIHg0KQ0KICAgICAgICAgICAgY29uc3QgdTJ4ID0gcDMueCAtIHA0Lng7IC8vICh4MyAtIHg0KQ0KICAgICAgICAgICAgY29uc3QgdTN4ID0gcDEueCAtIHAyLng7IC8vICh4MSAtIHgyKQ0KICAgICAgICAgICAgY29uc3QgdTJ5ID0gcDMueSAtIHA0Lnk7IC8vICh5MyAtIHk0KQ0KICAgICAgICAgICAgY29uc3QgdTN5ID0gcDEueSAtIHAyLnk7IC8vICh5MSAtIHkyKQ0KICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW9uIHBvaW50IGZvcm11bGENCiAgICAgICAgICAgIGNvbnN0IHB4ID0gKHUxICogdTJ4IC0gdTN4ICogdTQpIC8gZDsNCiAgICAgICAgICAgIGNvbnN0IHB5ID0gKHUxICogdTJ5IC0gdTN5ICogdTQpIC8gZDsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMihweCwgcHkpOw0KICAgICAgICB9DQogICAgICAgIGlzVmFsaWQoKSB7DQogICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5hc0FycmF5KCkpIHsNCiAgICAgICAgICAgICAgICBpZiAodiA9PSBJbmZpbml0eSB8fCBpc05hTih2KSkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHRocmVlIGRpbWVuc2lvbmFsIGNvb3JkaW5hdGUsIHN1Y2ggYXMgM0Qgc2NlbmUgdmFsdWVzLCBvciBtZXNoIHZlcnRleCBwb3NpdGlvbnMuDQogICAgICovDQogICAgY2xhc3MgVmVjMyB7DQogICAgICAgIHg7DQogICAgICAgIHk7DQogICAgICAgIHo7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGEgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDApIHsNCiAgICAgICAgICAgIHRoaXMueCA9IHg7DQogICAgICAgICAgICB0aGlzLnkgPSB5Ow0KICAgICAgICAgICAgdGhpcy56ID0gejsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0dGVyIGZvciBgeHlgIHN3aXp6ZWwuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB4eSBjb21wb25lbnRzIGFzIGEgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGdldCB4eSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmb3IgYHl6YCBzd2l6emVsLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgeXogY29tcG9uZW50cyBhcyBhIFZlYzIuDQogICAgICAgICAqLw0KICAgICAgICBnZXQgeXooKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy55LCB0aGlzLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgeCBjb21wb25lbnQuDQogICAgICAgICAqIEBwYXJhbSB5IC0gVGhlIHkgY29tcG9uZW50Lg0KICAgICAgICAgKiBAcGFyYW0geiAtIFRoZSB5IGNvbXBvbmVudC4NCiAgICAgICAgICovDQogICAgICAgIHNldCh4LCB5LCB6KSB7DQogICAgICAgICAgICB0aGlzLnggPSB4Ow0KICAgICAgICAgICAgdGhpcy55ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IHg7DQogICAgICAgICAgICB0aGlzLnogPSB6ICE9PSB1bmRlZmluZWQgPyB6IDogeDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgYSBWZWMzIE9iamVjdCBmcm9tIGFub3RoZXIgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gc2V0IGZyb20uDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tT3RoZXIob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ID0gb3RoZXIuejsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIFZlYzMgYXJlIDAgMCAwLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSgwLCAwLCAwKSwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgICAgICAgKi8NCiAgICAgICAgaXNOdWxsKCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnkpIDwgTnVtYmVyLkVQU0lMT04gJiYgTWF0aC5hYnModGhpcy56KSA8IE51bWJlci5FUFNJTE9OOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgVmVjMyBhcmUgMSAxIDEuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlKDEsIDEsIDEpLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAgICAgICAqLw0KICAgICAgICBpczExMSgpIHsNCiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoMS4wIC0gdGhpcy54KSA8IE51bWJlci5FUFNJTE9OICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnMoMS4wIC0gdGhpcy55KSA8IE51bWJlci5FUFNJTE9OICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnMoMS4wIC0gdGhpcy56KSA8IE51bWJlci5FUFNJTE9OKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMyBjb250YWlucyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIG90aGVyIFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIHRoZSBzYW1lLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAgICAgICAqLw0KICAgICAgICBpc0VxdWFsKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLno7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgVmVjM3MgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgICAgICAgKi8NCiAgICAgICAgbm90RXF1YWwob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnggIT0gb3RoZXIueCAmJiB0aGlzLnkgIT0gb3RoZXIueSAmJiB0aGlzLnogIT0gb3RoZXIuejsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgVmVjMiBpcyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICAgICAgICovDQogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHByZWNpc2lvbiAmJg0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb24pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgVmVjMyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gYWRkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBhZGQuDQogICAgICAgICAqLw0KICAgICAgICBhZGRJblBsYWNlKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggKz0gb3RoZXIueDsNCiAgICAgICAgICAgIHRoaXMueSArPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ICs9IG90aGVyLno7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjMyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIHN1YnRyYWN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWMzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBzdWJ0cmFjdC4NCiAgICAgICAgICovDQogICAgICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlcikgew0KICAgICAgICAgICAgdGhpcy54IC09IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgLT0gb3RoZXIueTsNCiAgICAgICAgICAgIHRoaXMueiAtPSBvdGhlci56Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWMzcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBtdWx0aXBseShvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCAqIG90aGVyLngsIHRoaXMueSAqIG90aGVyLnksIHRoaXMueiAqIG90aGVyLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWMzcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICAgICAgICovDQogICAgICAgIG11bHRpcGx5SW5QbGFjZShvdGhlcikgew0KICAgICAgICAgICAgdGhpcy54ICo9IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgKj0gb3RoZXIueTsNCiAgICAgICAgICAgIHRoaXMueiAqPSBvdGhlci56Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEaXZpZGVzIHR3byBWZWMzcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIG90aGVyIFZlYzMgdG8gZGl2aWRlIGJ5Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgZGl2aWRlKHZlYzMpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLyB2ZWMzLngsIHRoaXMueSAvIHZlYzMueSwgdGhpcy56IC8gdmVjMy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRGl2aWRlcyB0d28gVmVjM3MuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIG90aGVyIFZlYzMgdG8gZGl2aWRlIGJ5Lg0KICAgICAgICAgKi8NCiAgICAgICAgZGl2aWRlSW5QbGFjZSh2ZWMzKSB7DQogICAgICAgICAgICB0aGlzLnggLz0gdmVjMy54Ow0KICAgICAgICAgICAgdGhpcy55IC89IHZlYzMueTsNCiAgICAgICAgICAgIHRoaXMueiAvPSB2ZWMzLno7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzMgYnkgc2NhbGFyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBzY2FsZShzY2FsYXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2NhbGVzIHRoaXMgVmVjMyBieSBzY2FsYXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjsNCiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsYXI7DQogICAgICAgICAgICB0aGlzLnogKj0gc2NhbGFyOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBOZWdhdGVzIHRoaXMgVmVjMyAoeCA9IC14LCB5ID0gLXkgYW5kIHogPSAteiksIGJ1dCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIG5lZ2F0ZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGlzIFZlYzMsIGJ1dCByZXR1cm5zLiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMNCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGludmVyc2UoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoMS4wIC8gdGhpcy54LCAxLjAgLyB0aGlzLnksIDEuMCAvIHRoaXMueik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICAgICAgICovDQogICAgICAgIGxlbmd0aFNxdWFyZWQoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBWZWMzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbGVuZ3RoLg0KICAgICAgICAgKi8NCiAgICAgICAgbGVuZ3RoKCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0by4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9ycy4NCiAgICAgICAgICovDQogICAgICAgIGRpc3RhbmNlVG8ob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBvdGhlci54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIG90aGVyLnk7DQogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy56IC0gb3RoZXIuejsNCiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTm9ybWFsaXplcyB0aGUgVmVjMyBhbmQgcmV0dXJucyBpdCBhcyBhIG5ldyBWZWMzLg0KICAgICAgICAgKiBNdWx0aXBsaWVzIGNvb3JkaW5hdGVzIHZhbHVlIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgVmVjMyBub3JtYWxpemVkLg0KICAgICAgICAgKi8NCiAgICAgICAgbm9ybWFsaXplKCkgew0KICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejsNCiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/DQogICAgICAgICAgICBsZW4gPSAxLjAgLyBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKiBsZW4sIHRoaXMueSAqIGxlbiwgdGhpcy56ICogbGVuKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTm9ybWFsaXplcyB0aGlzIFZlYzMgbXVsdGlwbHlpbmcgY29vcmRpbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbm9ybWFsaXplSW5QbGFjZSgpIHsNCiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7DQogICAgICAgICAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICBsZW4gPSBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIGNvbnN0IHRtcCA9IDEuMCAvIGxlbjsNCiAgICAgICAgICAgIHRoaXMueCAqPSB0bXA7DQogICAgICAgICAgICB0aGlzLnkgKj0gdG1wOw0KICAgICAgICAgICAgdGhpcy56ICo9IHRtcDsNCiAgICAgICAgICAgIHJldHVybiBsZW47DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgVmVjMyB3aXRoIHRoZSBuZXcgY29vcmRpbmF0ZXMoY2FsY3VsYXRlZCB3aXRoIHRoaXMgVmVjMyBjb29yZGluYXRlcyBhbmQgdGhlIHNwZWNpZmllZCBsZW5ndGgpLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZXNpemUobGVuZ3RoKSB7DQogICAgICAgICAgICBjb25zdCBjdXJyTGVuID0gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56Ow0KICAgICAgICAgICAgaWYgKGN1cnJMZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IHNjbCA9IGxlbmd0aCAvIE1hdGguc3FydChjdXJyTGVuKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKiBzY2wsIHRoaXMueSAqIHNjbCwgdGhpcy56ICogc2NsKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTW9kaWZpZXMgY3VycmVudCBjb29yZGluYXRlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGxlbmd0aC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGxlbmd0aCAtIFRoZSBsZW5ndGggdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZXNpemVJblBsYWNlKGxlbmd0aCkgew0KICAgICAgICAgICAgY29uc3QgY3VyckxlbiA9IHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejsNCiAgICAgICAgICAgIGlmIChjdXJyTGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBzY2wgPSBsZW5ndGggLyBNYXRoLnNxcnQoY3Vyckxlbik7DQogICAgICAgICAgICB0aGlzLnggKj0gc2NsOw0KICAgICAgICAgICAgdGhpcy55ICo9IHNjbDsNCiAgICAgICAgICAgIHRoaXMueiAqPSBzY2w7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgVmVjMyBhZ2FpbnN0IGFub3RoZXIgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuDQogICAgICAgICAqLw0KICAgICAgICBkb3Qob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLno7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlYzNzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY2FsY3VsYXRlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBjcm9zcyhvdGhlcikgew0KICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCBheSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IGF6ID0gdGhpcy56Ow0KICAgICAgICAgICAgY29uc3QgYnggPSBvdGhlci54Ow0KICAgICAgICAgICAgY29uc3QgYnkgPSBvdGhlci55Ow0KICAgICAgICAgICAgY29uc3QgYnogPSBvdGhlci56Ow0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGF5ICogYnogLSBheiAqIGJ5LCBheiAqIGJ4IC0gYXggKiBieiwgYXggKiBieSAtIGF5ICogYngpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjMyBhbmQgYi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucy4NCiAgICAgICAgICovDQogICAgICAgIGFuZ2xlVG8ob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGNvc2luZSA9IHRoaXMuZG90KG90aGVyKTsNCiAgICAgICAgICAgIGlmIChjb3NpbmUgPiAxLjApIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gMDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgVmVjMyBhbmQgb3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGludGVycG9sYXRlIHRvd2FyZHMuDQogICAgICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiByYXRpby4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGxlcnAob3RoZXIsIHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgICAgICAgICBjb25zdCBheiA9IHRoaXMuejsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyhheCArIHQgKiAob3RoZXIueCAtIGF4KSwgYXkgKyB0ICogKG90aGVyLnkgLSBheSksIGF6ICsgdCAqIChvdGhlci56IC0gYXopKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIG5ldyBWZWMzIHdob3NlIGNvbXBvbmVudCB2YWx1ZXMgYXJlIHRoZSBhYnMgb2YgdGhpcyBWZWMzcyBjb21wb25lbnQgdmFsdWVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgYWJzKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKE1hdGguYWJzKHRoaXMueCksIE1hdGguYWJzKHRoaXMueSksIE1hdGguYWJzKHRoaXMueikpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSB2ZWN0b3IgYSByYW5kb20gdmVjdG9yIG9uIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIHdpdGggdGhlIHJhZGl1cyBvZiB0aGUgZ2l2ZW4gc2NhbGUgdmFsdWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsZSAtIFRoZSByYWRpdXMgb2YgdGhlIHN1cmZhY2Ugc3BoZXJlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJhbmRvbSBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0UmFuZG9tRGlyKHNjYWxlID0gMS4wKSB7DQogICAgICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUEk7DQogICAgICAgICAgICBjb25zdCB6ID0gTWF0aC5yYW5kb20oKSAqIDIuMCAtIDEuMDsNCiAgICAgICAgICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTsNCiAgICAgICAgICAgIHRoaXMueCA9IE1hdGguY29zKHIpICogelNjYWxlOw0KICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7DQogICAgICAgICAgICB0aGlzLnogPSB6ICogc2NhbGU7DQogICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciBhbnl3aGVyZSBpbiB0aGUgc3BoZXJlIGRlZmluZWQgYnkgdGhlIHByb3ZpZGVkIHNjYWxlIHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2NhbGUgLSBUaGUgcmFkaXVzIG9mIHRoZSBib3VuZGluZyBzcGhlcmUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmFuZG9tIFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBzZXRSYW5kb20oc2NhbGUgPSAxLjApIHsNCiAgICAgICAgICAgIHRoaXMueCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHNjYWxlOw0KICAgICAgICAgICAgdGhpcy55ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc2NhbGU7DQogICAgICAgICAgICB0aGlzLnogPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBzY2FsZTsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDbG9uZXMgdGhpcyBWZWMzIGFuZCByZXR1cm5zIGEgbmV3IFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgdHlwZSBhcyBhbiBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFzIGFuIGFycmF5Lg0KICAgICAgICAgKi8NCiAgICAgICAgYXNBcnJheSgpIHsNCiAgICAgICAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIGFuIGFycmF5Lg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUFycmF5KHZhbHMpIHsNCiAgICAgICAgICAgIHRoaXMueCA9IHZhbHNbMF07DQogICAgICAgICAgICB0aGlzLnkgPSB2YWxzWzFdOw0KICAgICAgICAgICAgdGhpcy56ID0gdmFsc1sxXTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEVuY29kZXMgVmVjMyBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgeDogdGhpcy54LA0KICAgICAgICAgICAgICAgIHk6IHRoaXMueSwNCiAgICAgICAgICAgICAgICB6OiB0aGlzLnosDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIHRoaXMueCA9IGoueDsNCiAgICAgICAgICAgIHRoaXMueSA9IGoueTsNCiAgICAgICAgICAgIHRoaXMueiA9IGouejsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlcikgew0KICAgICAgICAgICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHRoaXMueiA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgICAgICB9DQogICAgICAgIGlzVmFsaWQoKSB7DQogICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5hc0FycmF5KCkpIHsNCiAgICAgICAgICAgICAgICBpZiAodiA9PSBJbmZpbml0eSB8fCBpc05hTih2KSkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgIH0NCiAgICB9CgogICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBmb3VyLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUuDQogICAgICogTWF0aCB0eXBlcyBpbnRlcm5hbGx5IHN0b3JlIHZhbHVlcyBpbiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0gYW5kDQogICAgICogZXhwb3NlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIHRoZSBjb21wb25lbnQgdmFsdWVzLg0KICAgICAqDQogICAgICovDQogICAgY2xhc3MgVmVjNCB7DQogICAgICAgIHg7DQogICAgICAgIHk7DQogICAgICAgIHo7DQogICAgICAgIHc7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGEgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAwKSB7DQogICAgICAgICAgICB0aGlzLnggPSB4Ow0KICAgICAgICAgICAgdGhpcy55ID0geTsNCiAgICAgICAgICAgIHRoaXMueiA9IHo7DQogICAgICAgICAgICB0aGlzLncgPSB3Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXR0ZXIgZm9yIGB4eXpgIHN3aXp6ZWwuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB6IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IHh5eigpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0dGVyIGZyb20gc2NhbGFyIGNvbXBvbmVudHMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIHggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB5ICAtIFRoZSB5IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0geiAgLSBUaGUgeSB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHcgIC0gVGhlIHcgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXQoeCwgeSwgeiwgdykgew0KICAgICAgICAgICAgdGhpcy54ID0geDsNCiAgICAgICAgICAgIHRoaXMueSA9IHk7DQogICAgICAgICAgICB0aGlzLnogPSB6Ow0KICAgICAgICAgICAgdGhpcy53ID0gdzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgYSBWZWM0IE9iamVjdCBmcm9tIGFub3RoZXIgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gc2V0IGZyb20uDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tT3RoZXIob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ID0gb3RoZXIuejsNCiAgICAgICAgICAgIHRoaXMudyA9IG90aGVyLnc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgY29udGFpbnMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvdGhlciBWZWM0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAgICAgICAqLw0KICAgICAgICBpc0VxdWFsKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnogJiYgdGhpcy53ID09IG90aGVyLnc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWM0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAgICAgICAqLw0KICAgICAgICBub3RFcXVhbChvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55ICYmIHRoaXMueiAhPSBvdGhlci56ICYmIHRoaXMudyAhPSBvdGhlci53Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBWZWM0IGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHByZWNpc2lvbiAmJg0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb24gJiYNCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLncgLSBvdGhlci53KSA8IHByZWNpc2lvbik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWM0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gYWRkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWM0Lg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzQodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueiwgdGhpcy53ICsgb3RoZXIudyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWM0IG11dGF0aW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBpbnN0YW5jZQ0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBhZGQuDQogICAgICAgICAqLw0KICAgICAgICBhZGRJblBsYWNlKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggKz0gb3RoZXIueDsNCiAgICAgICAgICAgIHRoaXMueSArPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ICs9IG90aGVyLno7DQogICAgICAgICAgICB0aGlzLncgKz0gb3RoZXIudzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IGFuZCByZXR1cm5zIHRoZW4gcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIHN1YnRyYWN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWM0Lg0KICAgICAgICAgKi8NCiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56LCB0aGlzLncgLSBvdGhlci53KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IG11dGF0aW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBpbnN0YW5jZQ0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzdWJ0cmFjdC4NCiAgICAgICAgICovDQogICAgICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlcikgew0KICAgICAgICAgICAgdGhpcy54IC09IG90aGVyLng7DQogICAgICAgICAgICB0aGlzLnkgLT0gb3RoZXIueTsNCiAgICAgICAgICAgIHRoaXMueiAtPSBvdGhlci56Ow0KICAgICAgICAgICAgdGhpcy53IC09IG90aGVyLnc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIFZlYzRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gbXVsdGlwbHkgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjNC4NCiAgICAgICAgICovDQogICAgICAgIG11bHRpcGx5KG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzQodGhpcy54ICogb3RoZXIueCwgdGhpcy55ICogb3RoZXIueSwgdGhpcy56ICogb3RoZXIueiwgdGhpcy53ICogb3RoZXIudyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIFZlYzRzIG11dGF0aW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBpbnN0YW5jZQ0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBtdWx0aXBseSB3aXRoLg0KICAgICAgICAgKi8NCiAgICAgICAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggKj0gb3RoZXIueDsNCiAgICAgICAgICAgIHRoaXMueSAqPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ICo9IG90aGVyLno7DQogICAgICAgICAgICB0aGlzLncgKj0gb3RoZXIudzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRGl2aWRlcyB0d28gVmVjNHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBkaXZpZGUgYnkuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuDQogICAgICAgICAqLw0KICAgICAgICBkaXZpZGUob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLnggLyBvdGhlci54LCB0aGlzLnkgLyBvdGhlci55LCB0aGlzLnogLyBvdGhlci56LCB0aGlzLncgLyBvdGhlci53KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRGl2aWRlcyB0d28gVmVjNHMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGRpdmlkZSBieS4NCiAgICAgICAgICovDQogICAgICAgIGRpdmlkZUluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMueCAvPSBvdGhlci54Ow0KICAgICAgICAgICAgdGhpcy55IC89IG90aGVyLnk7DQogICAgICAgICAgICB0aGlzLnogLz0gb3RoZXIuejsNCiAgICAgICAgICAgIHRoaXMudyAvPSBvdGhlci53Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTY2FsZXMgdGhpcyBWZWM0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNjYWxlKHNjYWxhcikgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIsIHRoaXMudyAqIHNjYWxhcik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzQgYnkgc2NhbGFyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNjYWxlSW5QbGFjZShzY2FsYXIpIHsNCiAgICAgICAgICAgIHRoaXMuc2V0KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIsIHRoaXMudyAqIHNjYWxhcik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIFZlYzQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBsZW5ndGguDQogICAgICAgICAqLw0KICAgICAgICBsZW5ndGgoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICAgICAgICovDQogICAgICAgIGxlbmd0aFNxdWFyZWQoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgICAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBWZWM0IGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFZlYzQuDQogICAgICAgICAqIE11bHRpcGxpZXMgY29vcmRpbmF0ZXMgdmFsdWUgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBWZWM0IG5vcm1hbGl6ZWQuDQogICAgICAgICAqLw0KICAgICAgICBub3JtYWxpemUoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgICAgICAgICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3Ow0KICAgICAgICAgICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBUT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT8NCiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTm9ybWFsaXplcyB0aGlzIFZlYzQgbXVsdGlwbHlpbmcgY29vcmRpbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguDQogICAgICAgICAqLw0KICAgICAgICBub3JtYWxpemVJblBsYWNlKCkgew0KICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnk7DQogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy56Ow0KICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMudzsNCiAgICAgICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdzsNCiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsNCiAgICAgICAgICAgIHRoaXMuc2V0KHggKiBsZW4sIHkgKiBsZW4sIHogKiBsZW4sIHcgKiBsZW4pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzQgYWdhaW5zdCBhbm90aGVyIFZlYzQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgZG90KG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnkgKyB0aGlzLnogKiBvdGhlci56ICsgdGhpcy53ICogb3RoZXIudzsgLy8gVE9ETzogb3RoZXIudyB1c2VkIHRvIGJlIGIudz8NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gVmVjNHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjYWxjdWxhdGUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3QgYXMgYSBuZXcgVmVjNC4NCiAgICAgICAgICovDQogICAgICAgIGNyb3NzKG90aGVyKSB7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdCA9IHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IGJ4ID0gb3RoZXIueDsNCiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsNCiAgICAgICAgICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsNCiAgICAgICAgICAgIGNvbnN0IGJ0ID0gb3RoZXIudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNChheSAqIGJ6IC0gYXogKiBieSwgYXogKiBidCAtIGF0ICogYnosIGF0ICogYnggLSBheCAqIGJ0LCBheCAqIGJ5IC0gYXkgKiBieCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBWZWM0IGFuZCBiLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLg0KICAgICAgICAgKi8NCiAgICAgICAgYW5nbGVUbyhvdGhlcikgew0KICAgICAgICAgICAgY29uc3QgdGVtcEEgPSB0aGlzLm5vcm1hbGl6ZSgpOw0KICAgICAgICAgICAgY29uc3QgdGVtcEIgPSBvdGhlci5ub3JtYWxpemUoKTsNCiAgICAgICAgICAgIGNvbnN0IGNvc2luZSA9IHRlbXBBLmRvdCh0ZW1wQik7DQogICAgICAgICAgICBpZiAoY29zaW5lID4gMS4wKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIDA7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGlzIFZlYzQgYW5kIG90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLg0KICAgICAgICAgKiBAcGFyYW0gdyAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuDQogICAgICAgICAqLw0KICAgICAgICBsZXJwKG90aGVyLCB0KSB7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdCA9IHRoaXMudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNChheCArIHQgKiAob3RoZXIueCAtIGF4KSwgYXkgKyB0ICogKG90aGVyLnkgLSBheSksIGF6ICsgdCAqIChvdGhlci56IC0gYXopLCBhdCArIHQgKiAob3RoZXIudyAtIGF0KSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsZSAtIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIC8vIHJhbmRvbShzY2FsZSA9IDEuMCkgew0KICAgICAgICAvLyAgIGNvbnN0IHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEkNCiAgICAgICAgLy8gICBjb25zdCB6ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgLSAxLjANCiAgICAgICAgLy8gICBjb25zdCB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGUNCiAgICAgICAgLy8gICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZQ0KICAgICAgICAvLyAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlDQogICAgICAgIC8vICAgb3V0WzJdID0geiAqIHNjYWxlDQogICAgICAgIC8vICAgcmV0dXJuIG91dA0KICAgICAgICAvLyB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDbG9uZXMgdGhpcyBWZWM0IGFuZCByZXR1cm5zIGEgbmV3IFZlYzQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZlYzQgaW50byBhIFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB2YWx1ZSBhcyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9WZWMzKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIGFzIGFuIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYXMgYW4gYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBhc0FycmF5KCkgew0KICAgICAgICAgICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZnJvbSBhbiBhcnJheS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21BcnJheSh2YWxzKSB7DQogICAgICAgICAgICB0aGlzLnggPSB2YWxzWzBdOw0KICAgICAgICAgICAgdGhpcy55ID0gdmFsc1sxXTsNCiAgICAgICAgICAgIHRoaXMueiA9IHZhbHNbMV07DQogICAgICAgICAgICB0aGlzLncgPSB2YWxzWzFdOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdGhpcyBWZWMzIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvU3RyaW5nKCkgew0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXANCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oKSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHg6IHRoaXMueCwNCiAgICAgICAgICAgICAgICB5OiB0aGlzLnksDQogICAgICAgICAgICAgICAgejogdGhpcy56LA0KICAgICAgICAgICAgICAgIHc6IHRoaXMudywNCiAgICAgICAgICAgIH07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIERlY29kZXMgYSBKU09OIG9iamVjdCB0byBzZXQgdGhlIHN0YXRlIG9mIHRoaXMgY2xhc3MuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaikgew0KICAgICAgICAgICAgdGhpcy54ID0gai54Ow0KICAgICAgICAgICAgdGhpcy55ID0gai55Ow0KICAgICAgICAgICAgdGhpcy56ID0gai56Ow0KICAgICAgICAgICAgdGhpcy53ID0gai53Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyKSB7DQogICAgICAgICAgICB0aGlzLnggPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICB0aGlzLncgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVmVyaWZpZXMgaWYgdGhlIHZhbHVlcyBzdG9yZWQgaW4gdGhpcyBNYXRoIHR5cGUgYXJlIHZhbGlkIG51bWVyaWMgdmFsdWVzLg0KICAgICAgICAgKiBSZXR1cm5zIGBmYWxzZWAgSWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgaXMgZWl0aGVyIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9JbmZpbml0eXxJbmZpbml0eX0gb3INCiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNpYS9PYmpldG9zX2dsb2JhbGVzL05hTnxOYU59Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgYm9vbGVhbi4NCiAgICAgICAgICovDQogICAgICAgIGlzVmFsaWQoKSB7DQogICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5hc0FycmF5KCkpIHsNCiAgICAgICAgICAgICAgICBpZiAodiA9PSBJbmZpbml0eSB8fCBpc05hTih2KSkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgIH0NCiAgICB9CgogICAgbGV0IHJlZ2lzdGVyZWRDbGFzc2VzID0ge307DQogICAgbGV0IGNsYXNzTmFtZXMgPSB7fTsNCiAgICBsZXQgY2xhc3NEZWZpbml0aW9ucyA9IFtdOw0KICAgIC8qKg0KICAgICAqIFJlZ2lzdHJ5IGlzIGEgc3RhdGljIGZhY3RvcnkgdGhhdCBoYW5kbGVzIHJlZ2lzdHJhdGlvbi9yZWNvbnN0cnVjdGlvbiBvZg0KICAgICAqIGNsYXNzZXMgYmFzZXMgb24gQmFzZUNsYXNzLiBSZWdpc3RlcmVkIGNsYXNzZXMgY2FuIHRoZW4gYmUgY29uc3RydWN0ZWQgYnkgdGhlIFJlZ2lzdHJ5IGJ5IG5hbWUuDQogICAgICoNCiAgICAgKiBOb3RlOiBjbGFzc05hbWUgaXMgcmVxdWlyZWQgYmVjYXVzZSBvbiBtaW5pZmljYXRpb24gcHJvY2Vzcw0KICAgICAqIHRoZSBuYW1lIG9mIGNsYXNzZXMgY2hhbmdlIGFuZCB3ZSBjYW4ndCBzaW1wbHkgdXNlICcuLi4uY29uc3RydWN0b3IubmFtZScuDQogICAgICogU28sIHdlIG5lZWQgYSB3YXkgb2YgcmVsYXRpbmcgbWluaWZpZWQgY2xhc3MgbmFtZXMgdG8gdGhlIG9uZSBzdG9yZWQgZm9yIHBlcnNpc3RlbmN5Lg0KICAgICAqDQogICAgICogaS5lLg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiAvLyBJbXBvcnQgcmVnaXN0cnkgY2xhc3MNCiAgICAgKiBjbGFzcyBGb28oKSBleHRlbmRzIEJhc2VDbGFzcyB7fQ0KICAgICAqDQogICAgICogUmVnaXN0cnkucmVnaXN0ZXIoJ0ZvbycsIEZvbykNCiAgICAgKiAvLyBJbiBjYXNlICdGb28nIGNsYXNzIGdldHMgaXRzIG5hbWUgY2hhbmdlZCB0byAnYycgb24gbWluaWZpY2F0aW9uLA0KICAgICAqIC8vIGFuZCB0aGUgcGVyc2lzdGVkIGRhdGEgdHlwZSBpcyAnRm9vJywgd2Ugd291bGQga25vdyBob3cgdG8gcmVsYXRlIHRoZW0uDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAc3RhdGljDQogICAgICogQGNsYXNzIFJlZ2lzdHJ5DQogICAgICovDQogICAgY2xhc3MgUmVnaXN0cnkgew0KICAgICAgICAvKioNCiAgICAgICAgICogUmVnaXN0ZXJzIGEgbmV3IGNsYXNzIHRvIHRoZSBmYWN0b3J5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIC0gTmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBjbGFzcw0KICAgICAgICAgKiBAcGFyYW0gY2xhc3NEZWYgLSBDbGFzcyByZXByZXNlbnRhdGlvbihDbGFzcyBmdW5jdGlvbiwgdHlwZSkNCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyByZWdpc3RlcihjbGFzc05hbWUsIGNsYXNzRGVmKSB7DQogICAgICAgICAgICBpZiAoY2xhc3NOYW1lIGluIHJlZ2lzdGVyZWRDbGFzc2VzKSB7DQogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGVyZSdzIGEgY2xhc3MgcmVnaXN0ZXJlZCB3aXRoICcke2NsYXNzTmFtZX0nIG5hbWUuIFNlY29uZCByZWdpc3RyYXRpb24gZmFpbGVkLmApOw0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIE5vdGU6IFRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHNhbWUgY2xhc3NEZWYgY2FuIGJlIHN0b3JlZCB1bmRlciBtdWx0aXBsZSBuYW1lcy4NCiAgICAgICAgICAgIC8vIFRoYXRzIHRoZSByZWFzb24gYmVoaW5kIHVzaW5nIGluZGV4ZXMgaW5zdGVhZCBvZiB0aGUgY2xhc3NEZWYuDQogICAgICAgICAgICBjb25zdCBpbmRleCA9IGNsYXNzRGVmaW5pdGlvbnMubGVuZ3RoOw0KICAgICAgICAgICAgY2xhc3NEZWZpbml0aW9ucy5wdXNoKGNsYXNzRGVmKTsNCiAgICAgICAgICAgIGNsYXNzTmFtZXNbaW5kZXhdID0gY2xhc3NOYW1lOw0KICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzZXNbY2xhc3NOYW1lXSA9IGluZGV4Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGNsYXNzIGRlZmluaXRpb24gdXNpbmcgdGhlIG5hbWUgaXQgd2FzIHJlZ2lzdGVyZWQgd2l0aC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNsYXNzTmFtZSAtIE5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgY2xhc3MNCiAgICAgICAgICogQHJldHVybiAtIENsYXNzIHJlcHJlc2VudGF0aW9uKENsYXNzIGZ1bmN0aW9uLCB0eXBlKQ0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGdldENsYXNzRGVmaW5pdGlvbihjbGFzc05hbWUpIHsNCiAgICAgICAgICAgIGlmICghKGNsYXNzTmFtZSBpbiByZWdpc3RlcmVkQ2xhc3NlcykpDQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NsYXNzTmFtZX0gY2xhc3MgaXMgbm90IHJlZ2lzdGVyZWRgKTsNCiAgICAgICAgICAgIHJldHVybiBjbGFzc0RlZmluaXRpb25zW3JlZ2lzdGVyZWRDbGFzc2VzW2NsYXNzTmFtZV1dOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGNsYXNzIG5hbWUgcmVnaXN0ZXJlZCBmb3IgdGhlIGluc3RhbnRpYXRlZCBvYmplY3QuDQogICAgICAgICAqIEBwYXJhbSBjbGFzc0RlZmluaXRpb24gLSBDbGFzcyB0eXBlIGRlZmluaXRpb24uDQogICAgICAgICAqIEByZXR1cm4gLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNsYXNzDQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgZ2V0Q2xhc3NOYW1lKGNsYXNzRGVmaW5pdGlvbikgew0KICAgICAgICAgICAgY29uc3QgY2xhc3NJZCA9IGNsYXNzRGVmaW5pdGlvbnMuaW5kZXhPZihjbGFzc0RlZmluaXRpb24pOw0KICAgICAgICAgICAgaWYgKGNsYXNzSWQgPj0gMCAmJiBjbGFzc05hbWVzW2NsYXNzSWRdKQ0KICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVzW2NsYXNzSWRdOw0KICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjbGFzcyBpcyBub3QgcmVnaXN0ZXJlZGApOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdCB0aGUgY2xhc3MgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNsYXNzTmFtZSAtIE5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgY2xhc3MNCiAgICAgICAgICogQHJldHVybiAtIEluc3RhbnRpYXRlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBjbGFzcw0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGNvbnN0cnVjdENsYXNzKGNsYXNzTmFtZSkgew0KICAgICAgICAgICAgY29uc3QgY2xhc3NEZWZpbml0aW9uID0gY2xhc3NEZWZpbml0aW9uc1tyZWdpc3RlcmVkQ2xhc3Nlc1tjbGFzc05hbWVdXTsNCiAgICAgICAgICAgIGlmICghY2xhc3NEZWZpbml0aW9uKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjbGFzc05hbWV9IGNsYXNzIGlzIG5vdCByZWdpc3RlcmVkYCk7DQogICAgICAgICAgICByZXR1cm4gbmV3IGNsYXNzRGVmaW5pdGlvbigpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBGb3IgdGVzdGluZyBwdXJwb3NlIG9ubHksIG5ldmVyIGNhbGwgdGhpcyBvdXRzaWRlIG9mIHRoZSB0ZXN0IHNjb3BlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGZsdXNoKCkgew0KICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzZXMgPSB7fTsNCiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSB7fTsNCiAgICAgICAgICAgIGNsYXNzRGVmaW5pdGlvbnMgPSBbXTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgbGV0IGNvdW50ZXIgPSAwOw0KICAgIC8qKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhIEJhc2VDbGFzcy4NCiAgICAgKiBUaGUgQmFzZUNsYXNzIGlzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG9mIHRoZSBTY2VuZVRyZWUsIGFzIGFsbW9zdCBhbGwgY2xhc3NlcyBkZXJpdmUgZnJvbSBpdC4NCiAgICAgKi8NCiAgICBjbGFzcyBCYXNlQ2xhc3Mgew0KICAgICAgICBfX2lkOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGFuIEJhc2VDbGFzcy4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgdGhpcy5fX2lkID0gKytjb3VudGVyOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFdmVyeSBpbnN0YW5jZSBvZiBlYWNoIGNsYXNzIGJhc2VkIG9uIEJhc2VDbGFzcyBpcyBhc3NpZ25lZCBhIHVuaXF1ZSBudW1iZXIuDQogICAgICAgICAqIFRoaXMgbnVtYmVyIGlzIG5vdCBwZXJzaXN0ZW50IGluIGJldHdlZW4gZGlmZmVyZW50IGxvYWRzIG9mIGEgc2NlbmUuDQogICAgICAgICAqIFJldHVybnMgdGhlIHVuaXF1ZSBpZCBvZiB0aGUgb2JqZWN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIElkIG9mIHRoZSBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICBnZXRJZCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faWQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHVubWFuZ2xlZCBuYW1lIG9mIHRoZSBjbGFzcy4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyBkZWZpbml0aW9uLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0Q2xhc3NOYW1lKCkgew0KICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5LmdldENsYXNzTmFtZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBCYXNlRXZlbnQuICovDQogICAgY2xhc3MgQmFzZUV2ZW50IHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhbiBCYXNlRXZlbnQuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcigpIHsgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgLyoqDQogICAgICogUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlbWl0dGluZyBldmVudHMgdW5kZXIgZ2l2ZW4gbmFtZXMsIGFuZCByZWdpc3RlcmluZyBsaXN0ZW5lcnMgdG8gdGhvc2UgZXZlbnRzLg0KICAgICAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBtb3N0IGNsYXNzZXMgaW4gdGhlIFNjZW5lIFRyZWUgYW5kIFJlbmRlcmVyLCBlbmFibGluZyBvYnNlcnZlcnMgdG8gbGlzdGVuIHRvIGNoYW5nZXMgdGhyb3VnaG91dCB0aGUgc3lzdGVtLg0KICAgICAqIFRoZSBpbnRlcmZhY2UgZXhwb3NlZCBpcyBzaW1pbGFyIHRvIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcikgaW4gTm9kZS4NCiAgICAgKg0KICAgICAqIFNpbWlsYXIgdG8gaG93IHRoZSBET00gZXZlbnQgc3lzdGVtIGluIHRoZSBicm93c2VyIHdvcmtzLCBldmVudHMgYXJlIHJlZ2lzdGVyZWQgYnkgbmFtZS4NCiAgICAgKiBFeGFtcGxlOiBSZWdpc3RlcmluZyBhIGxpc3RlbmVyIGZvciBhIGN1c3RvbSBldmVudCwgYW5kIHRoZW4gZW1pdHRpbmcgdGhhdCBldmVudC4NCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogIGNvbnN0IGVlID0gbmV3IEV2ZW50RW1pdHRlcigpDQogICAgICoNCiAgICAgKiAgY29uc3QgZXZlbnRJRCA9IGVlLm9uKCdteUV2ZW50JywgKGV2ZW50KSA9PiB7DQogICAgICogICAgY29uc29sZS5sb2coJ015IEV2ZW50IHdhcyBlbWl0dGVkOicsIGV2ZW50KQ0KICAgICAqICB9KQ0KICAgICAqDQogICAgICogIGVlLmVtaXQoJ215RXZlbnQnLCB7IGRhdGE6IDQyIH0pDQogICAgICogIC8vIFdlIG5vIGxvbmdlciB3YW50IHRvIGxpc3RlbiB0byB0aGlzIGV2ZW50LCBzbyBsZXQncyByZW1vdmUgdGhlIGxpc3RlbmVyLg0KICAgICAqICBlZS5vZmYoJ215RXZlbnQnLCBldmVudElEKQ0KICAgICAqIGBgYA0KICAgICAqDQogICAgICoNCiAgICAgKi8NCiAgICBjbGFzcyBFdmVudEVtaXR0ZXIgZXh0ZW5kcyBCYXNlQ2xhc3Mgew0KICAgICAgICBsaXN0ZW5lcnMgPSB7fTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIEluaXRpYWxpemVzIGFuIGVtcHR5IGBsaXN0ZW5lcnNgIG1hcCB0aGF0IHdpbGwgaG9zdCBhbGwgdGhlIGV2ZW50cywNCiAgICAgICAgICogd2hpY2ggaW1wbGllcyB0aGF0IGl0IGRvZXNuJ3QgYWxsb3cgbXVsdGlwbGUgZXZlbnRzIHdpdGggdGhlIHNhbWUgbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZvciBhIGdpdmVuIGV2ZW50IG5hbWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuDQogICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbihjYWxsYmFjaykuDQogICAgICAgICAqIEByZXR1cm4gLSB0aGUgaWQgdGhhdCBjYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLg0KICAgICAgICAgKi8NCiAgICAgICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikgew0KICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBsaXN0ZW5lci4nKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkgew0KICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07DQogICAgICAgICAgICBpZiAobGlzdGVuZXJzLmluY2x1ZGVzKGxpc3RlbmVyKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdGVuZXIgIiR7bGlzdGVuZXIubmFtZX0iIGFscmVhZHkgY29ubmVjdGVkIHRvIGV2ZW50ICIke2V2ZW50TmFtZX0iLmApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gVE9ETzogRGVwcmVjYXRlIGFsb25nc2lkZSAjYWRkTGlzdGVuZXIuDQogICAgICAgICAgICBjb25zdCBpZCA9IGxpc3RlbmVycy5sZW5ndGg7DQogICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7DQogICAgICAgICAgICByZXR1cm4gaWQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNpbWlsYXIgdG8gdGhlIGBvbmAgbWV0aG9kIHdpdGggdGhlIGRpZmZlcmVuY2UgdGhhdCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsDQogICAgICAgICAqIGl0IGlzIGF1dG9tYXRpY2FsbHkgdW5yZWdpc3RlcmVkIG1lYW5pbmcgdGhhdCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmUgdGltZS4NCiAgICAgICAgICoNCiAgICAgICAgICogVXNlZnVsIGZvciBldmVudHMgdGhhdCB3ZSBleHBlY3QgdG8gdHJpZ2dlciBvbmUgdGltZSwgc3VjaCBhcyB3aGVuIGFzc2V0cyBsb2FkLg0KICAgICAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICAgICAqIGNvbnN0IGFzc2V0ID0gbmV3IEFzc2V0KCk7DQogICAgICAgICAqIGFzc2V0Lm9uY2UoJ2xvYWRlZCcsICgpID0+IHsNCiAgICAgICAgICogICBjb25zb2xlLmxvZygiWWF5ISB0aGUgYXNzZXQgaXMgbG9hZGVkIikNCiAgICAgICAgICogfSkNCiAgICAgICAgICogYGBgDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgZXZlbnROYW1lIHZhbHVlDQogICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciB2YWx1ZQ0KICAgICAgICAgKiBAcmV0dXJuIC0gdGhlIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci4NCiAgICAgICAgICovDQogICAgICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikgew0KICAgICAgICAgICAgY29uc3QgY2IgPSAoZXZlbnQpID0+IHsNCiAgICAgICAgICAgICAgICB0aGlzLm9mZihldmVudE5hbWUsIGNiKTsNCiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudCk7DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBjYik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHVzaW5nIGVpdGhlciB0aGUgZnVuY3Rpb24gb3IgdGhlIGluZGV4IGlkLiBEZXBlbmRzIG9uIHdoYXQgaXMgcGFzc2VkIGluLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50Lg0KICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXJPcklkIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIHRoZSBpZCBudW1iZXIgcmV0dXJuZWQgYnkgJ29uJy4NCiAgICAgICAgICovDQogICAgICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyT3JJZCkgew0KICAgICAgICAgICAgaWYgKGxpc3RlbmVyT3JJZCA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2sgZnVuY3Rpb24gKGxpc3RlbmVyKS4nKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107DQogICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyT3JJZCA9PSAnbnVtYmVyJykgew0KICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbGlzdGVuZXJPcklkOw0KICAgICAgICAgICAgICAgIC8vIE5vdGU6IGRvIG5vdCBzcGxpY2UgdGhlIGFycmF5IGFzIHRoYXQgd291bGQgY2hhbmdlIHRoZSBpbmRleGVzIG9mIGV4aXN0aW5nIGxpc3RlbmVycy4NCiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbnVsbDsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyT3JJZDsNCiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChlLCBpKSA9PiB7DQogICAgICAgICAgICAgICAgaWYgKGUgPT09IGxpc3RlbmVyKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGRvIG5vdCBzcGxpY2UgdGhlIGFycmF5IGFzIHRoYXQgd291bGQgY2hhbmdlIHRoZSBpbmRleGVzIG9mIGV4aXN0aW5nIGxpc3RlbmVycy4NCiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldID0gbnVsbDsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogcmVtb3ZlIGxpc3RlbmVyIGJ5IElEIHJldHVybmVkIGZyb20gI29uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuDQogICAgICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCByZXR1cm5lZCBieSBhZGRMaXN0ZW5lcg0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlTGlzdGVuZXJCeUlkKGV2ZW50TmFtZSwgaWQpIHsNCiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgaWQpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUcmlnZ2VycyBhbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGluIGFuIGV2ZW50Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50Lg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZGF0YSB5b3Ugd2FudCB0byBwYXNzIGRvd24gdG8gYWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBhcyBwYXJhbWV0ZXIuDQogICAgICAgICAqDQogICAgICAgICAqLw0KICAgICAgICBlbWl0KGV2ZW50TmFtZSwgZXZlbnQgPSBuZXcgQmFzZUV2ZW50KCkpIHsNCiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107DQogICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZm4pID0+IHsNCiAgICAgICAgICAgICAgICAvLyBTa2lwIGRpc2Nvbm5lY3RlZCBsaXN0ZW5lcnMuDQogICAgICAgICAgICAgICAgaWYgKGZuKSB7DQogICAgICAgICAgICAgICAgICAgIGZuKGV2ZW50KTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9KTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgLyoqDQogICAgICogTWF0aCBGdW5jdGlvbnMNCiAgICAgKi8NCiAgICBjbGFzcyBNYXRoRnVuY3Rpb25zIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIFJhZGlhbnMgdG8gRGVncmVlcw0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSByYWQgLSBSYWRpYW5zIHZhbHVlDQogICAgICAgICAqIEByZXR1cm4gLSBEZWdyZWVzIGVxdWl2YWxlbnQNCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyByYWRUb0RlZyhyYWQpIHsNCiAgICAgICAgICAgIHJldHVybiByYWQgLyAoTWF0aC5QSSAvIDE4MCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIERlZ3JlZXMgdG8gUmFkaWFudHMNCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gZGVnIC0gRGVncmVlcyB2YWx1ZQ0KICAgICAgICAgKiBAcmV0dXJuIC0gIFJhZGlhbnMgZXF1aXZhbGVudA0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGRlZ1RvUmFkKGRlZykgew0KICAgICAgICAgICAgcmV0dXJuIGRlZyAqIChNYXRoLlBJIC8gMTgwKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVmVyaWZpZXMgaWYgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgaXMgbnVtZXJpYy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gbnVtYmVyIC0gTnVtYmVyIHRvIHRlc3QNCiAgICAgICAgICogQHJldHVybiAtIGB0cnVlYCB3aGVuIGlzIGEgdmFsaWQgbnVtYmVyDQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgaXNOdW1lcmljKG51bWJlcikgew0KICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpICYmIGlzRmluaXRlKG51bWJlcik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSBtaW4gLSBMb3dlciB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS4NCiAgICAgICAgICogQHBhcmFtIG1heCAtIEhpZ2hlc3QgdmFsdWUgcmFuZG9tIGludCBjYW4gYmUuDQogICAgICAgICAqIEByZXR1cm4gLSBSYW5kb20gbnVtYmVyIGluc2lkZSByYW5nZS4NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyByYW5kb21JbnQobWluLCBtYXgpIHsNCiAgICAgICAgICAgIG1pbiA9IE1hdGguY2VpbChtaW4pOw0KICAgICAgICAgICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpOw0KICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyBhIGxpbmVhbCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIGlucHV0cyBmb3IgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIodCkuDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIHYwIC0NCiAgICAgICAgICogQHBhcmFtIHYxIC0NCiAgICAgICAgICogQHBhcmFtIHQgLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBsZXJwKHYwLCB2MSwgdCkgew0KICAgICAgICAgICAgcmV0dXJuIHYwICsgdCAqICh2MSAtIHYwKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmVzdHJpY3RzIHRoZSBzcGVjaWZpZWQgdmFsdWUgYmV0d2VlbiB0d28gbnVtYmVycw0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZQ0KICAgICAgICAgKiBAcGFyYW0gbWluDQogICAgICAgICAqIEBwYXJhbSBtYXgNCiAgICAgICAgICogQHJldHVybg0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBuZWFyZXN0IHBvdyBvZiB0d28gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0NCiAgICAgICAgICogQHJldHVybiAtDQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgbmVhcmVzdFBvdzIodmFsdWUpIHsNCiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLnJvdW5kKE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKDIpKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG5lYXJlc3QgcG93IG9mIHRlbiB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBuZWFyZXN0UG93MTAodmFsdWUpIHsNCiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChNYXRoLmxvZzEwKHZhbHVlKSAvIE1hdGgubG9nMTAoMTApKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG5leHQgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBuZXh0UG93Mih2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHRoaXMuZnJhY3QoTWF0aC5sb2cyKHZhbHVlKSkgPT0gMCkgew0KICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGxldCBleHAgPSAwOw0KICAgICAgICAgICAgd2hpbGUgKHZhbHVlID4gMCkgew0KICAgICAgICAgICAgICAgIGV4cCsrOw0KICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gMTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiAxIDw8IGV4cDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgZnJhY3Rpb25hbCBjb21wb25lbnQgb2YgYSBudW1iZXINCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBmcmFjdCh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHZhbHVlID09IDApDQogICAgICAgICAgICAgICAgcmV0dXJuIDA7DQogICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7DQogICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEuMCkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC12YWx1ZTsNCiAgICAgICAgICAgICAgICByZXR1cm4gLXZhbHVlICUgTWF0aC5mbG9vcigtdmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKHZhbHVlIDwgMS4wKQ0KICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsNCiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAlIE1hdGguZmxvb3IodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNb3ZlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIGZyb20gb25lIG51bWVyaWMgZG9tYWluKHJhbmdlKSB0byBhbm90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtDQogICAgICAgICAqIEBwYXJhbSBzdGFydDEgLQ0KICAgICAgICAgKiBAcGFyYW0gZW5kMSAtDQogICAgICAgICAqIEBwYXJhbSBzdGFydDIgLQ0KICAgICAgICAgKiBAcGFyYW0gZW5kMiAtDQogICAgICAgICAqIEByZXR1cm4gLQ0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIHJlbWFwKHZhbHVlLCBzdGFydDEsIGVuZDEsIHN0YXJ0MiwgZW5kMikgew0KICAgICAgICAgICAgcmV0dXJuIHN0YXJ0MiArIChlbmQyIC0gc3RhcnQyKSAqICgodmFsdWUgLSBzdGFydDEpIC8gKGVuZDEgLSBzdGFydDEpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybSBIZXJtaXRlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIGVkZ2UwIC0NCiAgICAgICAgICogQHBhcmFtIGVkZ2UxIC0NCiAgICAgICAgICogQHBhcmFtIHggLQ0KICAgICAgICAgKiBAcmV0dXJuIC0NCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBzbW9vdGhTdGVwKGVkZ2UwLCBlZGdlMSwgeCkgew0KICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKTsNCiAgICAgICAgICAgIHJldHVybiB0ICogdCAqICgzLjAgLSAyLjAgKiB0KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybXMgLSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZhbHVlcw0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSBlZGdlMCAtDQogICAgICAgICAqIEBwYXJhbSBlZGdlMSAtDQogICAgICAgICAqIEBwYXJhbSB4IC0NCiAgICAgICAgICogQHJldHVybiAtDQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgbGluU3RlcChlZGdlMCwgZWRnZTEsIHgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYW1wKCh4IC0gZWRnZTApIC8gKGVkZ2UxIC0gZWRnZTApLCAwLjAsIDEuMCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIERlY29kZXMgYSBGbG9hdDE2IGZyb20gdHdvIHVuc2lnbmVkIEludDgNCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gYyAtIEFycmF5IHdpdGggdGhlIHR3byBVSW50OA0KICAgICAgICAgKiBAcmV0dXJuIC0gRGVjb2RlZCBGbG9hdDE2DQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgZGVjb2RlMTZCaXRGbG9hdEZyb20yeFVJbnQ4KGMpIHsNCiAgICAgICAgICAgIGNvbnN0IGl4ID0gY1swXTsgLy8gMXN0IGJ5dGU6IDEgYml0IHNpZ25lZCBudW0sIDQgYml0cyBleHBvbmVudCwgMyBiaXRzIG1hbnRpc3NhIChNU0IpDQogICAgICAgICAgICBjb25zdCBpeSA9IGNbMV07IC8vIDJuZCBieXRlOiA4IGJpdCBtYW50aXNzYSAoTFNCKQ0KICAgICAgICAgICAgY29uc3QgcyA9IGl4ICYgMHg4MCA/IDEgOiAtMTsgLy8gZ2V0IGJpdCA4DQogICAgICAgICAgICBjb25zdCBpZXhwID0gKGl4ICYgMHg3OCkgPj4gMzsgLy8gbWFzayBiaXRzIDctNA0KICAgICAgICAgICAgY29uc3QgbXNiID0gaXggJiAweDc7IC8vIG1hc2sgYml0cyAzLTENCiAgICAgICAgICAgIGxldCBub3JtID0gaWV4cCA9PSAwID8gMCA6IDIwNDg7IC8vIGRpc3Rpbmd1aXNoIGJldHdlZW4gbm9ybWFsaXplZCBhbmQgc3ViLW5vcm1hbGl6ZWQgbnVtYmVycw0KICAgICAgICAgICAgY29uc3QgbWFudGlzc2EgPSBub3JtICsgKG1zYiA8PCA4KSArIGl5OyAvLyBpbXBsaWNpdCBwcmVjZWRpbmcgMSBvciAwIGFkZGVkIGhlcmUNCiAgICAgICAgICAgIG5vcm0gPSBpZXhwID09IDAgPyAxIDogMDsgLy8gbm9ybWFsaXphdGlvbiB0b2dnbGUNCiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gTWF0aC5wb3coMiwgaWV4cCArIG5vcm0gLSAxNik7IC8vIC01IGZvciB0aGUgdGhlIGV4cG9uZW50IGJpYXMgZnJvbSAyXi01IHRvIDJeMTAgcGx1cyBhbm90aGVyIC0xMSBmb3IgdGhlIG5vcm1hbGl6ZWQgMTIgYml0IG1hbnRpc3NhDQogICAgICAgICAgICBjb25zdCB2ID0gcyAqIG1hbnRpc3NhICogZXhwb25lbnQ7DQogICAgICAgICAgICByZXR1cm4gdjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0d28gdW5zaWduZWQgSW50OCB0byBhIEZsb2F0MTYNCiAgICAgICAgICoNCiAgICAgICAgICogQHN0YXRpYw0KICAgICAgICAgKiBAcGFyYW0gdiAtIEZsb2F0MTYgbnVtYmVyDQogICAgICAgICAqIEByZXR1cm4gLSBFbmNvZGVkIFVuc2lnbmVkIEludDggYXJyYXkNCiAgICAgICAgICovDQogICAgICAgIHN0YXRpYyBlbmNvZGUxNkJpdEZsb2F0SW50bzJ4VUludDgodikgew0KICAgICAgICAgICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KDIpOw0KICAgICAgICAgICAgLy8gY29uc3QgYyA9IFswLCAwXTsNCiAgICAgICAgICAgIGNvbnN0IHNpZ251bSA9IHYgPj0gMCA/IDEyOCA6IDA7DQogICAgICAgICAgICB2ID0gTWF0aC5hYnModik7DQogICAgICAgICAgICBsZXQgZXhwb25lbnQgPSAxNTsNCiAgICAgICAgICAgIGxldCBsaW1pdCA9IDEwMjQ7IC8vIGNvbnNpZGVyaW5nIHRoZSBiaWFzIGZyb20gMl4tNSB0byAyXjEwICg9PTEwMjQpDQogICAgICAgICAgICBmb3IgKGxldCBleHAgPSAxNTsgZXhwID4gMDsgZXhwLS0pIHsNCiAgICAgICAgICAgICAgICBpZiAodiA8IGxpbWl0KSB7DQogICAgICAgICAgICAgICAgICAgIGxpbWl0IC89IDI7DQogICAgICAgICAgICAgICAgICAgIGV4cG9uZW50LS07DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgbGV0IHJlc3Q7DQogICAgICAgICAgICBpZiAoZXhwb25lbnQgPT0gMCkgew0KICAgICAgICAgICAgICAgIHJlc3QgPSB2IC8gbGltaXQgLyAyOyAvLyAic3ViLW5vcm1hbGl6ZSIgaW1wbGljaXQgcHJlY2VkaW5nIDAuDQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICByZXN0ID0gKHYgLSBsaW1pdCkgLyBsaW1pdDsgLy8gbm9ybWFsaXplIGFjY29yZGluZ2x5IHRvIGltcGxpY2l0IHByZWNlZGluZyAxLg0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHJlc3QgKiAyMDQ4KTsgLy8gMjA0OCA9IDJeMTEgZm9yIHRoZSAoc3BsaXQpIDExIGJpdCBtYW50aXNzYQ0KICAgICAgICAgICAgY29uc3QgbXNiID0gbWFudGlzc2EgLyAyNTY7IC8vIHRoZSBtb3N0IHNpZ25pZmljYW50IDMgYml0cyBnbyBpbnRvIHRoZSBsb3dlciBwYXJ0IG9mIHRoZSBmaXJzdCBieXRlDQogICAgICAgICAgICBjb25zdCBsc2IgPSBtYW50aXNzYSAtIG1zYiAqIDI1NjsgLy8gdGhlcmUgZ28gdGhlIG90aGVyIDggYml0IG9mIHRoZSBsb3dlciBzaWduaWZpY2FuY2UNCiAgICAgICAgICAgIGNbMF0gPSBzaWdudW0gKyBleHBvbmVudCAqIDggKyBtc2I7IC8vIGNvbG9yIG5vcm1hbGl6YXRpb24gZm9yIHRleHR1cmUyRA0KICAgICAgICAgICAgY1sxXSA9IGxzYjsNCiAgICAgICAgICAgIGlmICh2ID49IDIwNDgpIHsNCiAgICAgICAgICAgICAgICBjWzBdID0gMjU1Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIGM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYW5zZm9ybXMgYSAxNiBiaXQgZmxvYXQgdG8gYW4gZW5jb2RlZCBpbnRlZ2VyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAc3RhdGljDQogICAgICAgICAqIEBwYXJhbSB2IC0gRmxvYXQxNiBudW1iZXIgdG8gZW5jb2RlDQogICAgICAgICAqIEByZXR1cm4gLSBFbmNvZGVkIG51bWJlcg0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGVuY29kZTE2Qml0RmxvYXQodikgew0KICAgICAgICAgICAgY29uc3QgZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTsNCiAgICAgICAgICAgIGZsb2F0MzJBcnJheVswXSA9IHY7DQogICAgICAgICAgICBjb25zdCBpbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyQXJyYXkuYnVmZmVyKTsNCiAgICAgICAgICAgIGNvbnN0IHRvVUludDE2ID0gKHgpID0+IHsNCiAgICAgICAgICAgICAgICBsZXQgYml0cyA9ICh4ID4+IDE2KSAmIDB4ODAwMDsgLyogR2V0IHRoZSBzaWduICovDQogICAgICAgICAgICAgICAgbGV0IG0gPSAoeCA+PiAxMikgJiAweDA3ZmY7IC8qIEtlZXAgb25lIGV4dHJhIGJpdCBmb3Igcm91bmRpbmcgKi8NCiAgICAgICAgICAgICAgICBjb25zdCBlID0gKHggPj4gMjMpICYgMHhmZjsgLyogVXNpbmcgaW50IGlzIGZhc3RlciBoZXJlICovDQogICAgICAgICAgICAgICAgLyogSWYgemVybywgb3IgZGUtbm9ybWFsLCBvciBleHBvbmVudCB1bmRlcmZsb3dzIHRvbyBtdWNoIGZvciBhIGRlLW5vcm1hbA0KICAgICAgICAgICAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi8NCiAgICAgICAgICAgICAgICBpZiAoZSA8IDEwMykgew0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gYml0czsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgLyogSWYgTmFOLCByZXR1cm4gTmFOLiBJZiBJbmYgb3IgZXhwb25lbnQgb3ZlcmZsb3csIHJldHVybiBJbmYuICovDQogICAgICAgICAgICAgICAgaWYgKGUgPiAxNDIpIHsNCiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAweDdjMDA7DQogICAgICAgICAgICAgICAgICAgIC8qIElmIGV4cG9uZW50IHdhcyAweGZmIGFuZCBvbmUgbWFudGlzc2EgYml0IHdhcyBzZXQsIGl0IG1lYW5zIE5hTiwNCiAgICAgICAgICAgICAgICAgICAgICogbm90IEluZiwgc28gbWFrZSBzdXJlIHdlIHNldCBvbmUgbWFudGlzc2EgYml0IHRvby4gKi8NCiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAoZSA9PSAyNTUgPyAwIDogMSkgJiYgeCAmIDB4MDA3ZmZmZmY7DQogICAgICAgICAgICAgICAgICAgIHJldHVybiBiaXRzOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAvKiBJZiBleHBvbmVudCB1bmRlcmZsb3dzIGJ1dCBub3QgdG9vIG11Y2gsIHJldHVybiBhIGRlLW5vcm1hbCAqLw0KICAgICAgICAgICAgICAgIGlmIChlIDwgMTEzKSB7DQogICAgICAgICAgICAgICAgICAgIG0gfD0gMHgwODAwOw0KICAgICAgICAgICAgICAgICAgICAvKiBFeHRyYSByb3VuZGluZyBtYXkgb3ZlcmZsb3cgYW5kIHNldCBtYW50aXNzYSB0byAwIGFuZCBleHBvbmVudA0KICAgICAgICAgICAgICAgICAgICAgKiB0byAxLCB3aGljaCBpcyBPSy4gKi8NCiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAobSA+PiAoMTE0IC0gZSkpICsgKChtID4+ICgxMTMgLSBlKSkgJiAxKTsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKTsNCiAgICAgICAgICAgICAgICAvKiBFeHRyYSByb3VuZGluZy4gQW4gb3ZlcmZsb3cgd2lsbCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgaW5jcmVtZW50DQogICAgICAgICAgICAgICAgICogdGhlIGV4cG9uZW50LCB3aGljaCBpcyBPSy4gKi8NCiAgICAgICAgICAgICAgICBiaXRzICs9IG0gJiAxOw0KICAgICAgICAgICAgICAgIHJldHVybiBiaXRzOw0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIHJldHVybiB0b1VJbnQxNihpbnQzMlZpZXdbMF0pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBcyBvcHBvc2l0ZSBvZiB0aGUgYGVuY29kZTE2Qml0RmxvYXRgIG1ldGhvZCwgdGhpcyB0YWtlcyBhbiBlbmNvZGVkIGludGVnZXIgdmFsdWUsDQogICAgICAgICAqIGFuZCByZXR1cm5zIHRoZSAxNiBiaXQgZmxvYXQuDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIGggLSBFbmNvZGVkIGludGVnZXINCiAgICAgICAgICogQHJldHVybiAtIERlY29kZWQgMTYgYml0IGZsb2F0Lg0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGRlY29kZTE2Qml0RmxvYXQoaCkgew0KICAgICAgICAgICAgY29uc3QgcyA9IChoICYgMHg4MDAwKSA+PiAxNTsNCiAgICAgICAgICAgIGNvbnN0IGUgPSAoaCAmIDB4N2MwMCkgPj4gMTA7DQogICAgICAgICAgICBjb25zdCBmID0gaCAmIDB4MDNmZjsNCiAgICAgICAgICAgIGlmIChlID09IDApIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogTWF0aC5wb3coMiwgLTE0KSAqIChmIC8gTWF0aC5wb3coMiwgMTApKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKGUgPT0gMHgxZikgew0KICAgICAgICAgICAgICAgIHJldHVybiBmID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogTWF0aC5wb3coMiwgZSAtIDE1KSAqICgxICsgZiAvIE1hdGgucG93KDIsIDEwKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgRmxvYXQgMzIgdG8gYW4gYXJyYXkgb2YgdW5zaWduZWQgSW50MTYuDQogICAgICAgICAqDQogICAgICAgICAqIEBzdGF0aWMNCiAgICAgICAgICogQHBhcmFtIGZsb2F0MzJBcnJheSAtDQogICAgICAgICAqIEByZXR1cm4gLSBVbnNpZ25lZCBJbnQxNiBhcnJheSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgRmxvYXQzMkFycmF5DQogICAgICAgICAqLw0KICAgICAgICBzdGF0aWMgY29udmVydEZsb2F0MzJBcnJheVRvVUludDE2QXJyYXkoZmxvYXQzMkFycmF5KSB7DQogICAgICAgICAgICBjb25zdCB1bml0MTZzID0gbmV3IFVpbnQxNkFycmF5KGZsb2F0MzJBcnJheS5sZW5ndGgpOw0KICAgICAgICAgICAgY29uc3QgaW50MzJWaWV3ID0gbmV3IEludDMyQXJyYXkoZmxvYXQzMkFycmF5LmJ1ZmZlcik7DQogICAgICAgICAgICBjb25zdCB0b1VJbnQxNiA9ICh4KSA9PiB7DQogICAgICAgICAgICAgICAgbGV0IGJpdHMgPSAoeCA+PiAxNikgJiAweDgwMDA7IC8qIEdldCB0aGUgc2lnbiAqLw0KICAgICAgICAgICAgICAgIGxldCBtID0gKHggPj4gMTIpICYgMHgwN2ZmOyAvKiBLZWVwIG9uZSBleHRyYSBiaXQgZm9yIHJvdW5kaW5nICovDQogICAgICAgICAgICAgICAgY29uc3QgZSA9ICh4ID4+IDIzKSAmIDB4ZmY7IC8qIFVzaW5nIGludCBpcyBmYXN0ZXIgaGVyZSAqLw0KICAgICAgICAgICAgICAgIC8qIElmIHplcm8sIG9yIGRlLW5vcm1hbCwgb3IgZXhwb25lbnQgdW5kZXJmbG93cyB0b28gbXVjaCBmb3IgYSBkZS1ub3JtYWwNCiAgICAgICAgICAgICAgICAgKiBoYWxmLCByZXR1cm4gc2lnbmVkIHplcm8uICovDQogICAgICAgICAgICAgICAgaWYgKGUgPCAxMDMpIHsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIC8qIElmIE5hTiwgcmV0dXJuIE5hTi4gSWYgSW5mIG9yIGV4cG9uZW50IG92ZXJmbG93LCByZXR1cm4gSW5mLiAqLw0KICAgICAgICAgICAgICAgIGlmIChlID4gMTQyKSB7DQogICAgICAgICAgICAgICAgICAgIGJpdHMgfD0gMHg3YzAwOw0KICAgICAgICAgICAgICAgICAgICAvKiBJZiBleHBvbmVudCB3YXMgMHhmZiBhbmQgb25lIG1hbnRpc3NhIGJpdCB3YXMgc2V0LCBpdCBtZWFucyBOYU4sDQogICAgICAgICAgICAgICAgICAgICAqIG5vdCBJbmYsIHNvIG1ha2Ugc3VyZSB3ZSBzZXQgb25lIG1hbnRpc3NhIGJpdCB0b28uICovDQogICAgICAgICAgICAgICAgICAgIGJpdHMgfD0gKGUgPT0gMjU1ID8gMCA6IDEpICYmIHggJiAweDAwN2ZmZmZmOw0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gYml0czsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgLyogSWYgZXhwb25lbnQgdW5kZXJmbG93cyBidXQgbm90IHRvbyBtdWNoLCByZXR1cm4gYSBkZS1ub3JtYWwgKi8NCiAgICAgICAgICAgICAgICBpZiAoZSA8IDExMykgew0KICAgICAgICAgICAgICAgICAgICBtIHw9IDB4MDgwMDsNCiAgICAgICAgICAgICAgICAgICAgLyogRXh0cmEgcm91bmRpbmcgbWF5IG92ZXJmbG93IGFuZCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgZXhwb25lbnQNCiAgICAgICAgICAgICAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovDQogICAgICAgICAgICAgICAgICAgIGJpdHMgfD0gKG0gPj4gKDExNCAtIGUpKSArICgobSA+PiAoMTEzIC0gZSkpICYgMSk7DQogICAgICAgICAgICAgICAgICAgIHJldHVybiBiaXRzOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBiaXRzIHw9ICgoZSAtIDExMikgPDwgMTApIHwgKG0gPj4gMSk7DQogICAgICAgICAgICAgICAgLyogRXh0cmEgcm91bmRpbmcuIEFuIG92ZXJmbG93IHdpbGwgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGluY3JlbWVudA0KICAgICAgICAgICAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovDQogICAgICAgICAgICAgICAgYml0cyArPSBtICYgMTsNCiAgICAgICAgICAgICAgICByZXR1cm4gYml0czsNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHVuaXQxNnNbaV0gPSB0b1VJbnQxNihpbnQzMlZpZXdbaV0pOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHVuaXQxNnM7DQogICAgICAgIH0NCiAgICB9CgogICAgY2xhc3MgQ2hpbGRBZGRlZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHsNCiAgICAgICAgaW5kZXg7DQogICAgICAgIGNoaWxkSXRlbTsNCiAgICAgICAgY29uc3RydWN0b3IoaW5kZXgsIGNoaWxkSXRlbSkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDsNCiAgICAgICAgICAgIHRoaXMuY2hpbGRJdGVtID0gY2hpbGRJdGVtOw0KICAgICAgICB9DQogICAgfQoKICAgIGNsYXNzIE5hbWVDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQgew0KICAgICAgICBvbGROYW1lOw0KICAgICAgICBuZXdOYW1lOw0KICAgICAgICBjb25zdHJ1Y3RvcihvbGROYW1lLCBuZXdOYW1lKSB7DQogICAgICAgICAgICBzdXBlcigpOw0KICAgICAgICAgICAgdGhpcy5vbGROYW1lID0gb2xkTmFtZTsNCiAgICAgICAgICAgIHRoaXMubmV3TmFtZSA9IG5ld05hbWU7DQogICAgICAgIH0NCiAgICB9CgogICAgY2xhc3MgT3BhY2l0eVN0YXRlQ2hhbmdlZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHsNCiAgICAgICAgaXNPcGFxdWU7DQogICAgICAgIGlzT3BhcXVlU3RhdGVDaGFuZ2VkOw0KICAgICAgICBjb25zdHJ1Y3Rvcihpc09wYXF1ZSwgaXNPcGFxdWVTdGF0ZUNoYW5nZWQpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLmlzT3BhcXVlID0gaXNPcGFxdWU7DQogICAgICAgICAgICB0aGlzLmlzT3BhcXVlU3RhdGVDaGFuZ2VkID0gaXNPcGFxdWVTdGF0ZUNoYW5nZWQ7DQogICAgICAgIH0NCiAgICB9CgogICAgY2xhc3MgUGFyYW1ldGVyQWRkZWRFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7DQogICAgICAgIG5hbWU7DQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOw0KICAgICAgICB9DQogICAgfQoKICAgIGNsYXNzIFBhcmFtZXRlclJlbW92ZWRFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7DQogICAgICAgIG5hbWU7DQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOw0KICAgICAgICB9DQogICAgfQoKICAgIGNsYXNzIFNlbGVjdGFiaWxpdHlDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQgew0KICAgICAgICB2YWx1ZTsNCiAgICAgICAgY29uc3RydWN0b3IodmFsdWUpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7DQogICAgICAgIH0NCiAgICB9CgogICAgY2xhc3MgU2VsZWN0ZWRFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7DQogICAgICAgIHNlbGVjdGVkOw0KICAgICAgICBjb25zdHJ1Y3RvcihzZWxlY3RlZCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsNCiAgICAgICAgfQ0KICAgIH0KCiAgICBjbGFzcyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHsNCiAgICAgICAgdmlzaWJsZTsNCiAgICAgICAgY29uc3RydWN0b3IodmlzaWJsZSkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGU7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY29sb3IgYXMgNCBmbG9hdGluZyBwb2ludCB2YWx1ZXMuDQogICAgICovDQogICAgY2xhc3MgQ29sb3Igew0KICAgICAgICByID0gMDsNCiAgICAgICAgZyA9IDA7DQogICAgICAgIGIgPSAwOw0KICAgICAgICBhID0gMjU1Ow0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhIGBDb2xvcmAgb2JqZWN0IHdpdGggYW4gUkdCQSBzdHJ1Y3R1cmUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByIC0gVGhlIHJlZCBjaGFubmVsIG9mIGEgY29sb3IuDQogICAgICAgICAqIEBwYXJhbSBnIC0gVGhlIGdyZWVuIGNoYW5uZWwgb2YgYSBjb2xvci4NCiAgICAgICAgICogQHBhcmFtIGIgLSBUaGUgYmx1ZSBjaGFubmVsIG9mIGEgY29sb3IuDQogICAgICAgICAqIEBwYXJhbSBhIC0gVGhlIGFscGhhICh0cmFuc3BhcmVuY3kpIGNoYW5uZWwgb2YgYSBjb2xvci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAxLjApIHsNCiAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PSAnc3RyaW5nJykgew0KICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0c1dpdGgoJyMnKSkgew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21IZXgocik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21DU1NDb2xvck5hbWUocik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5yID0gcjsNCiAgICAgICAgICAgICAgICB0aGlzLmcgPSBnOw0KICAgICAgICAgICAgICAgIHRoaXMuYiA9IGI7DQogICAgICAgICAgICAgICAgdGhpcy5hID0gYTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0dGVyIGZyb20gc2NhbGFyIGNvbXBvbmVudHMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByIC0gVGhlIHJlZCBjaGFubmVsLg0KICAgICAgICAgKiBAcGFyYW0gZyAgLSBUaGUgZ3JlZW4gY2hhbm5lbC4NCiAgICAgICAgICogQHBhcmFtIGIgIC0gVGhlIGJsdWUgY2hhbm5lbC4NCiAgICAgICAgICogQHBhcmFtIGEgIC0gVGhlIGFscGhhIGNoYW5uZWwuDQogICAgICAgICAqLw0KICAgICAgICBzZXQociwgZywgYiwgYSA9IDEuMCkgew0KICAgICAgICAgICAgdGhpcy5yID0gcjsNCiAgICAgICAgICAgIHRoaXMuZyA9IGc7DQogICAgICAgICAgICB0aGlzLmIgPSBiOw0KICAgICAgICAgICAgdGhpcy5hID0gYTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBjdXJyZW50IGNvbG9yIHN0YXRlIHdpdGggYW5vdGhlciBgQ29sb3JgIG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIHNldCBmcm9tLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU90aGVyKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnIgPSBvdGhlci5yOw0KICAgICAgICAgICAgdGhpcy5nID0gb3RoZXIuZzsNCiAgICAgICAgICAgIHRoaXMuYiA9IG90aGVyLmI7DQogICAgICAgICAgICB0aGlzLmEgPSBvdGhlci5hOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXR0ZXIgZnJvbSBhbiBSR0IgYXJyYXkuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0QXNSR0JBcnJheSgpIHsNCiAgICAgICAgICAgIHJldHVybiBbdGhpcy5yICogMjU1LCB0aGlzLmcgKiAyNTUsIHRoaXMuYiAqIDI1NV07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmcm9tIGFuIFJHQiBkaWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEFzUkdCRGljdCgpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgcjogdGhpcy5yICogMjU1LA0KICAgICAgICAgICAgICAgIGc6IHRoaXMuZyAqIDI1NSwNCiAgICAgICAgICAgICAgICBiOiB0aGlzLmIgKiAyNTUsDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZnJvbSBhIFJHQiB2YWx1ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHIgLSBUaGUgcmVkIGNoYW5uZWwuDQogICAgICAgICAqIEBwYXJhbSBnICAtIFRoZSBncmVlbiBjaGFubmVsLg0KICAgICAgICAgKiBAcGFyYW0gYiAgLSBUaGUgYmx1ZSBjaGFubmVsLg0KICAgICAgICAgKiBAcGFyYW0gYSAgLSBUaGUgYWxwaGEgY2hhbm5lbC4NCiAgICAgICAgICovDQogICAgICAgIHNldEZyb21SR0IociwgZywgYiwgYSkgew0KICAgICAgICAgICAgdGhpcy5yID0gciAvIDI1NTsNCiAgICAgICAgICAgIHRoaXMuZyA9IGcgLyAyNTU7DQogICAgICAgICAgICB0aGlzLmIgPSBiIC8gMjU1Ow0KICAgICAgICAgICAgdGhpcy5hID0gYSA/IGEgLyAyNTUgOiAxLjA7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIGFuIFJHQiBkaWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbVJHQkRpY3QodmFscykgew0KICAgICAgICAgICAgdGhpcy5yID0gdmFscy5yIC8gMjU1Ow0KICAgICAgICAgICAgdGhpcy5nID0gdmFscy5nIC8gMjU1Ow0KICAgICAgICAgICAgdGhpcy5iID0gdmFscy5iIC8gMjU1Ow0KICAgICAgICAgICAgdGhpcy5hID0gdmFscy5hID09IDQgPyB2YWxzLmEgLyAyNTUgOiAxLjA7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIGEgaGV4YWRlY2ltYWwgdmFsdWUuDQogICAgICAgICAqIEUuZy4gI2ZmMDAwMA0KICAgICAgICAgKiBAcGFyYW0gaGV4IC0gVGhlIGhleCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZyb21IZXgoaGV4KSB7DQogICAgICAgICAgICBmdW5jdGlvbiBoZXhUb1JnYihoZXgpIHsNCiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcZF17Mn0pKFthLWZcZF17Mn0pKFthLWZcZF17Mn0pJC9pLmV4ZWMoaGV4KTsNCiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0DQogICAgICAgICAgICAgICAgICAgID8gew0KICAgICAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksDQogICAgICAgICAgICAgICAgICAgICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSwNCiAgICAgICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpLA0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIDogbnVsbDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGhleFRvUmdiKGhleCk7DQogICAgICAgICAgICBpZiAoIXJnYikgew0KICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBoZXggY29kZTonICsgaGV4KTsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLnNldEZyb21SR0IocmdiLnIsIHJnYi5nLCByZ2IuYik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIENvbG9yIHZhbHVlcyBmcm9tIGEgQ1NTIGNvbG9yIG5hbWUuDQogICAgICAgICAqIEUuZy4gInJlZCINCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgQ1NTIGNvbG9yIG5hbWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tQ1NTQ29sb3JOYW1lKG5hbWUpIHsNCiAgICAgICAgICAgIGNvbnN0IGNvbG91ck5hbWVUb0hleCA9IChjb2xvdXIpID0+IHsNCiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcnMgPSB7DQogICAgICAgICAgICAgICAgICAgIGFsaWNlYmx1ZTogJyNmMGY4ZmYnLA0KICAgICAgICAgICAgICAgICAgICBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JywNCiAgICAgICAgICAgICAgICAgICAgYXF1YTogJyMwMGZmZmYnLA0KICAgICAgICAgICAgICAgICAgICBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsDQogICAgICAgICAgICAgICAgICAgIGF6dXJlOiAnI2YwZmZmZicsDQogICAgICAgICAgICAgICAgICAgIGJlaWdlOiAnI2Y1ZjVkYycsDQogICAgICAgICAgICAgICAgICAgIGJpc3F1ZTogJyNmZmU0YzQnLA0KICAgICAgICAgICAgICAgICAgICBibGFjazogJyMwMDAwMDAnLA0KICAgICAgICAgICAgICAgICAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLA0KICAgICAgICAgICAgICAgICAgICBibHVlOiAnIzAwMDBmZicsDQogICAgICAgICAgICAgICAgICAgIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJywNCiAgICAgICAgICAgICAgICAgICAgYnJvd246ICcjYTUyYTJhJywNCiAgICAgICAgICAgICAgICAgICAgYnVybHl3b29kOiAnI2RlYjg4NycsDQogICAgICAgICAgICAgICAgICAgIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLA0KICAgICAgICAgICAgICAgICAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsDQogICAgICAgICAgICAgICAgICAgIGNob2NvbGF0ZTogJyNkMjY5MWUnLA0KICAgICAgICAgICAgICAgICAgICBjb3JhbDogJyNmZjdmNTAnLA0KICAgICAgICAgICAgICAgICAgICBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLA0KICAgICAgICAgICAgICAgICAgICBjb3Juc2lsazogJyNmZmY4ZGMnLA0KICAgICAgICAgICAgICAgICAgICBjcmltc29uOiAnI2RjMTQzYycsDQogICAgICAgICAgICAgICAgICAgIGN5YW46ICcjMDBmZmZmJywNCiAgICAgICAgICAgICAgICAgICAgZGFya2JsdWU6ICcjMDAwMDhiJywNCiAgICAgICAgICAgICAgICAgICAgZGFya2N5YW46ICcjMDA4YjhiJywNCiAgICAgICAgICAgICAgICAgICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLA0KICAgICAgICAgICAgICAgICAgICBkYXJrZ3JheTogJyNhOWE5YTknLA0KICAgICAgICAgICAgICAgICAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJywNCiAgICAgICAgICAgICAgICAgICAgZGFya2toYWtpOiAnI2JkYjc2YicsDQogICAgICAgICAgICAgICAgICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsDQogICAgICAgICAgICAgICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsDQogICAgICAgICAgICAgICAgICAgIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJywNCiAgICAgICAgICAgICAgICAgICAgZGFya29yY2hpZDogJyM5OTMyY2MnLA0KICAgICAgICAgICAgICAgICAgICBkYXJrcmVkOiAnIzhiMDAwMCcsDQogICAgICAgICAgICAgICAgICAgIGRhcmtzYWxtb246ICcjZTk5NjdhJywNCiAgICAgICAgICAgICAgICAgICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsDQogICAgICAgICAgICAgICAgICAgIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJywNCiAgICAgICAgICAgICAgICAgICAgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLA0KICAgICAgICAgICAgICAgICAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsDQogICAgICAgICAgICAgICAgICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJywNCiAgICAgICAgICAgICAgICAgICAgZGVlcHBpbms6ICcjZmYxNDkzJywNCiAgICAgICAgICAgICAgICAgICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJywNCiAgICAgICAgICAgICAgICAgICAgZGltZ3JheTogJyM2OTY5NjknLA0KICAgICAgICAgICAgICAgICAgICBkb2RnZXJibHVlOiAnIzFlOTBmZicsDQogICAgICAgICAgICAgICAgICAgIGZpcmVicmljazogJyNiMjIyMjInLA0KICAgICAgICAgICAgICAgICAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLA0KICAgICAgICAgICAgICAgICAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLA0KICAgICAgICAgICAgICAgICAgICBmdWNoc2lhOiAnI2ZmMDBmZicsDQogICAgICAgICAgICAgICAgICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLA0KICAgICAgICAgICAgICAgICAgICBnaG9zdHdoaXRlOiAnI2Y4ZjhmZicsDQogICAgICAgICAgICAgICAgICAgIGdvbGQ6ICcjZmZkNzAwJywNCiAgICAgICAgICAgICAgICAgICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsDQogICAgICAgICAgICAgICAgICAgIGdyYXk6ICcjODA4MDgwJywNCiAgICAgICAgICAgICAgICAgICAgZ3JlZW46ICcjMDA4MDAwJywNCiAgICAgICAgICAgICAgICAgICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJywNCiAgICAgICAgICAgICAgICAgICAgaG9uZXlkZXc6ICcjZjBmZmYwJywNCiAgICAgICAgICAgICAgICAgICAgaG90cGluazogJyNmZjY5YjQnLA0KICAgICAgICAgICAgICAgICAgICAnaW5kaWFucmVkICc6ICcjY2Q1YzVjJywNCiAgICAgICAgICAgICAgICAgICAgaW5kaWdvOiAnIzRiMDA4MicsDQogICAgICAgICAgICAgICAgICAgIGl2b3J5OiAnI2ZmZmZmMCcsDQogICAgICAgICAgICAgICAgICAgIGtoYWtpOiAnI2YwZTY4YycsDQogICAgICAgICAgICAgICAgICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsDQogICAgICAgICAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JywNCiAgICAgICAgICAgICAgICAgICAgbGF3bmdyZWVuOiAnIzdjZmMwMCcsDQogICAgICAgICAgICAgICAgICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLA0KICAgICAgICAgICAgICAgICAgICBsaWdodGJsdWU6ICcjYWRkOGU2JywNCiAgICAgICAgICAgICAgICAgICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLA0KICAgICAgICAgICAgICAgICAgICBsaWdodGN5YW46ICcjZTBmZmZmJywNCiAgICAgICAgICAgICAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJywNCiAgICAgICAgICAgICAgICAgICAgbGlnaHRncmV5OiAnI2QzZDNkMycsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJywNCiAgICAgICAgICAgICAgICAgICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcjMjBiMmFhJywNCiAgICAgICAgICAgICAgICAgICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0c3RlZWxibHVlOiAnI2IwYzRkZScsDQogICAgICAgICAgICAgICAgICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsDQogICAgICAgICAgICAgICAgICAgIGxpbWU6ICcjMDBmZjAwJywNCiAgICAgICAgICAgICAgICAgICAgbGltZWdyZWVuOiAnIzMyY2QzMicsDQogICAgICAgICAgICAgICAgICAgIGxpbmVuOiAnI2ZhZjBlNicsDQogICAgICAgICAgICAgICAgICAgIG1hZ2VudGE6ICcjZmYwMGZmJywNCiAgICAgICAgICAgICAgICAgICAgbWFyb29uOiAnIzgwMDAwMCcsDQogICAgICAgICAgICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJywNCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtYmx1ZTogJyMwMDAwY2QnLA0KICAgICAgICAgICAgICAgICAgICBtZWRpdW1vcmNoaWQ6ICcjYmE1NWQzJywNCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkOCcsDQogICAgICAgICAgICAgICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsDQogICAgICAgICAgICAgICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJyM3YjY4ZWUnLA0KICAgICAgICAgICAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLA0KICAgICAgICAgICAgICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICcjNDhkMWNjJywNCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnI2M3MTU4NScsDQogICAgICAgICAgICAgICAgICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLA0KICAgICAgICAgICAgICAgICAgICBtaW50Y3JlYW06ICcjZjVmZmZhJywNCiAgICAgICAgICAgICAgICAgICAgbWlzdHlyb3NlOiAnI2ZmZTRlMScsDQogICAgICAgICAgICAgICAgICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsDQogICAgICAgICAgICAgICAgICAgIG5hdmFqb3doaXRlOiAnI2ZmZGVhZCcsDQogICAgICAgICAgICAgICAgICAgIG5hdnk6ICcjMDAwMDgwJywNCiAgICAgICAgICAgICAgICAgICAgb2xkbGFjZTogJyNmZGY1ZTYnLA0KICAgICAgICAgICAgICAgICAgICBvbGl2ZTogJyM4MDgwMDAnLA0KICAgICAgICAgICAgICAgICAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJywNCiAgICAgICAgICAgICAgICAgICAgb3JhbmdlOiAnI2ZmYTUwMCcsDQogICAgICAgICAgICAgICAgICAgIG9yYW5nZXJlZDogJyNmZjQ1MDAnLA0KICAgICAgICAgICAgICAgICAgICBvcmNoaWQ6ICcjZGE3MGQ2JywNCiAgICAgICAgICAgICAgICAgICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLA0KICAgICAgICAgICAgICAgICAgICBwYWxlZ3JlZW46ICcjOThmYjk4JywNCiAgICAgICAgICAgICAgICAgICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLA0KICAgICAgICAgICAgICAgICAgICBwYWxldmlvbGV0cmVkOiAnI2Q4NzA5MycsDQogICAgICAgICAgICAgICAgICAgIHBhcGF5YXdoaXA6ICcjZmZlZmQ1JywNCiAgICAgICAgICAgICAgICAgICAgcGVhY2hwdWZmOiAnI2ZmZGFiOScsDQogICAgICAgICAgICAgICAgICAgIHBlcnU6ICcjY2Q4NTNmJywNCiAgICAgICAgICAgICAgICAgICAgcGluazogJyNmZmMwY2InLA0KICAgICAgICAgICAgICAgICAgICBwbHVtOiAnI2RkYTBkZCcsDQogICAgICAgICAgICAgICAgICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JywNCiAgICAgICAgICAgICAgICAgICAgcHVycGxlOiAnIzgwMDA4MCcsDQogICAgICAgICAgICAgICAgICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JywNCiAgICAgICAgICAgICAgICAgICAgcmVkOiAnI2ZmMDAwMCcsDQogICAgICAgICAgICAgICAgICAgIHJvc3licm93bjogJyNiYzhmOGYnLA0KICAgICAgICAgICAgICAgICAgICByb3lhbGJsdWU6ICcjNDE2OWUxJywNCiAgICAgICAgICAgICAgICAgICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJywNCiAgICAgICAgICAgICAgICAgICAgc2FsbW9uOiAnI2ZhODA3MicsDQogICAgICAgICAgICAgICAgICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJywNCiAgICAgICAgICAgICAgICAgICAgc2VhZ3JlZW46ICcjMmU4YjU3JywNCiAgICAgICAgICAgICAgICAgICAgc2Vhc2hlbGw6ICcjZmZmNWVlJywNCiAgICAgICAgICAgICAgICAgICAgc2llbm5hOiAnI2EwNTIyZCcsDQogICAgICAgICAgICAgICAgICAgIHNpbHZlcjogJyNjMGMwYzAnLA0KICAgICAgICAgICAgICAgICAgICBza3libHVlOiAnIzg3Y2VlYicsDQogICAgICAgICAgICAgICAgICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLA0KICAgICAgICAgICAgICAgICAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJywNCiAgICAgICAgICAgICAgICAgICAgc25vdzogJyNmZmZhZmEnLA0KICAgICAgICAgICAgICAgICAgICBzcHJpbmdncmVlbjogJyMwMGZmN2YnLA0KICAgICAgICAgICAgICAgICAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JywNCiAgICAgICAgICAgICAgICAgICAgdGFuOiAnI2QyYjQ4YycsDQogICAgICAgICAgICAgICAgICAgIHRlYWw6ICcjMDA4MDgwJywNCiAgICAgICAgICAgICAgICAgICAgdGhpc3RsZTogJyNkOGJmZDgnLA0KICAgICAgICAgICAgICAgICAgICB0b21hdG86ICcjZmY2MzQ3JywNCiAgICAgICAgICAgICAgICAgICAgdHVycXVvaXNlOiAnIzQwZTBkMCcsDQogICAgICAgICAgICAgICAgICAgIHZpb2xldDogJyNlZTgyZWUnLA0KICAgICAgICAgICAgICAgICAgICB3aGVhdDogJyNmNWRlYjMnLA0KICAgICAgICAgICAgICAgICAgICB3aGl0ZTogJyNmZmZmZmYnLA0KICAgICAgICAgICAgICAgICAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsDQogICAgICAgICAgICAgICAgICAgIHllbGxvdzogJyNmZmZmMDAnLA0KICAgICAgICAgICAgICAgICAgICB5ZWxsb3dncmVlbjogJyM5YWNkMzInLA0KICAgICAgICAgICAgICAgIH07DQogICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV07DQogICAgICAgICAgICAgICAgLy8gIGlmICh0eXBlb2YgY29sb3JzW2NvbG91ci50b0xvd2VyQ2FzZSgpXSAhPSAndW5kZWZpbmVkJykgcmV0dXJuIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV0NCiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2UNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCcjJykpIHsNCiAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21IZXgobmFtZSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICBjb25zdCBoZXhDb2xvciA9IGNvbG91ck5hbWVUb0hleChuYW1lKTsNCiAgICAgICAgICAgICAgICBpZiAoaGV4Q29sb3IpDQogICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJvbUhleChoZXhDb2xvcik7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGhleGFkZWNpbWFsIHZhbHVlIG9mIHRoaXMgY29sb3IsIGluY2x1ZGluZyB0aGUgbGVhZGluZyAiIyIgY2hhcmFjdGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgaGV4IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9IZXgoKSB7DQogICAgICAgICAgICBmdW5jdGlvbiBjb21wb25lbnRUb0hleChjKSB7DQogICAgICAgICAgICAgICAgY29uc3QgaW50ID0gTWF0aC5yb3VuZChjICogMjU1KTsNCiAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBpbnQudG9TdHJpbmcoMTYpOw0KICAgICAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyAnMCcgKyBoZXggOiBoZXg7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gJyMnICsgY29tcG9uZW50VG9IZXgodGhpcy5yKSArIGNvbXBvbmVudFRvSGV4KHRoaXMuZykgKyBjb21wb25lbnRUb0hleCh0aGlzLmIpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDaGVja3MgaWYgdGhpcyBDb2xvciAgY29udGFpbnMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvdGhlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIENvbG9yIHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIHRoZSBzYW1lLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAgICAgICAqLw0KICAgICAgICBpc0VxdWFsKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5yID09IG90aGVyLnIgJiYgdGhpcy5nID09IG90aGVyLmcgJiYgdGhpcy5iID09IG90aGVyLmIgJiYgdGhpcy5hID09IG90aGVyLmE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbG9yIGlzIE5PVCBleGFjdGx5IHRoZSBzYW1lIGFzIG90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLg0KICAgICAgICAgKi8NCiAgICAgICAgbm90RXF1YWxzKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5yICE9IG90aGVyLnIgJiYgdGhpcy5nICE9IG90aGVyLmcgJiYgdGhpcy5iICE9IG90aGVyLmIgJiYgdGhpcy5hICE9IG90aGVyLmE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbG9yIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICAgICAgICovDQogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgew0KICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGlzLnIgLSBvdGhlci5yKSA8IHByZWNpc2lvbiAmJg0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZyAtIG90aGVyLmcpIDwgcHJlY2lzaW9uICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5iIC0gb3RoZXIuYikgPCBwcmVjaXNpb24gJiYNCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLmEgLSBvdGhlci5hKSA8IHByZWNpc2lvbik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgYSBuZXcgQ29sb3Igd2hpY2ggaXMgdGhpcyBDb2xvciBhZGRlZCB0byBvdGhlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGFkZC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAgICAgICAqLw0KICAgICAgICBhZGQob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yICsgb3RoZXIuciwgdGhpcy5nICsgb3RoZXIuZywgdGhpcy5iICsgb3RoZXIuYiwgdGhpcy5hICsgb3RoZXIuYSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFVwZGF0ZXMgdGhpcyBDb2xvciBieSBhZGRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBvdGhlciBjb2xvci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIGNvbG9yIHRvIGFkZC4NCiAgICAgICAgICovDQogICAgICAgIGFkZEluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMuciArPSBvdGhlci5yOw0KICAgICAgICAgICAgdGhpcy5nICs9IG90aGVyLmc7DQogICAgICAgICAgICB0aGlzLmIgKz0gb3RoZXIuYjsNCiAgICAgICAgICAgIHRoaXMuYSArPSBvdGhlci5hOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHdoaWNoIGlzIHRoaXMgY29sb3Igc3VidHJhY3RlZCBmcm9tIG90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gc3VidHJhY3QuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yIC0gb3RoZXIuciwgdGhpcy5nIC0gb3RoZXIuZywgdGhpcy5iIC0gb3RoZXIuYiwgdGhpcy5hIC0gb3RoZXIuYSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNjYWxlcyB0aGlzIGNvbG9yIGJ5IHNjYWxhciBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgc2NhbGUoc2NhbGFyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciAqIHNjYWxhciwgdGhpcy5nICogc2NhbGFyLCB0aGlzLmIgKiBzY2FsYXIsIHRoaXMuYSAqIHNjYWxhcik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNjYWxlcyB0aGlzIGNvbG9yIGJ5IHNjYWxhci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzY2FsZUluUGxhY2Uoc2NhbGFyKSB7DQogICAgICAgICAgICB0aGlzLnIgKj0gc2NhbGFyOw0KICAgICAgICAgICAgdGhpcy5nICo9IHNjYWxhcjsNCiAgICAgICAgICAgIHRoaXMuYiAqPSBzY2FsYXI7DQogICAgICAgICAgICB0aGlzLmEgKj0gc2NhbGFyOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBcHBseSBnYW1tYSBjb3JyZWN0aW9uIHRvIHRoaXMgY29sb3INCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgYXBwbHlHYW1tYShnYW1tYSkgew0KICAgICAgICAgICAgdGhpcy5zZXQoTWF0aC5wb3codGhpcy5yLCBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIGdhbW1hKSwgdGhpcy5hKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdG8gbGluZWFyIGNvbG9yIHNwYWNlIGFuZCByZXR1cm5zIGEgbmV3IGNvbG9yDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuDQogICAgICAgICAqLw0KICAgICAgICB0b0xpbmVhcihnYW1tYSA9IDIuMikgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihNYXRoLnBvdyh0aGlzLnIsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5nLCBnYW1tYSksIE1hdGgucG93KHRoaXMuYiwgZ2FtbWEpLCB0aGlzLmEpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiByZXR1cm5zIGEgbmV3IGNvbG9yIHZhbHVlIHZhbHVlIGlzIG1hcHBlZCBpbnRvIGEgZ2FtbWEgY3VydmUNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICAgICAgICovDQogICAgICAgIHRvR2FtbWEoZ2FtbWEgPSAyLjIpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5wb3codGhpcy5yLCAxLjAgLyBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgMS4wIC8gZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIDEuMCAvIGdhbW1hKSwgdGhpcy5hKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgbHVtaW5hbmNlIG9mIHRoZSBsaW5lYXIgUkdCIGNvbXBvbmVudHMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbHVtaW5hbmNlKCkgew0KICAgICAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHRoaXMuciArIDAuNzE1MiAqIHRoaXMuZyArIDAuMDcyMiAqIHRoaXMuYjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgY29sb3IgYW5kIG90aGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gaW50ZXJwb2xhdGUgYmV0d2Vlbi4NCiAgICAgICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBjb2xvci4NCiAgICAgICAgICovDQogICAgICAgIGxlcnAob3RoZXIsIHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGFyID0gdGhpcy5yOw0KICAgICAgICAgICAgY29uc3QgYWcgPSB0aGlzLmc7DQogICAgICAgICAgICBjb25zdCBhYiA9IHRoaXMuYjsNCiAgICAgICAgICAgIGNvbnN0IGFhID0gdGhpcy5hOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihhciArIHQgKiAob3RoZXIuciAtIGFyKSwgYWcgKyB0ICogKG90aGVyLmcgLSBhZyksIGFiICsgdCAqIChvdGhlci5iIC0gYWIpLCBhYSArIHQgKiAob3RoZXIuYSAtIGFhKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSByYW5kb20gY29sb3IuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBnYW1tYU9mZnNldCAtIFRoZSBnYW1tYSBvZmZzZXQuIFZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEgaW5jcmVhc2UgdGhlIGF2ZXJhZ2UgYnJpZ2h0bmVzcyBvZiB0aGUgZ2VuZXJhdGVkIGNvbG9yLiBWYWx1ZXMgYmV0d2VlbiAwIGFuZCAtMSBkYXJrZW4gdGhlIGdlbmVyYXRlZCBjb2xvciB2YWx1ZXMuDQogICAgICAgICAqIEBwYXJhbSByYW5kb21BbHBoYSAtIERldGVybWluZXMgd2hldGhlciB0aGUgYWxwaGEgY2hhbm5lbCBpcyByYW5kb20uIElmIG5vdCwgdGhlIGFscGhhIHZhbHVlcyB3aWxsIGJlIDEuMC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBuZXcgcmFuZG9tIGNvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIHJhbmRvbShnYW1tYU9mZnNldCA9IDAuMCwgcmFuZG9tQWxwaGEgPSBmYWxzZSkgew0KICAgICAgICAgICAgaWYgKGdhbW1hT2Zmc2V0ID4gMC4wKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLCBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLCBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpLCByYW5kb21BbHBoYSA/IGdhbW1hT2Zmc2V0ICsgTWF0aC5yYW5kb20oKSAqICgxLjAgLSBnYW1tYU9mZnNldCkgOiAxLjApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGdhbW1hT2Zmc2V0IDwgMC4wKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSwgTWF0aC5yYW5kb20oKSAqICgxLjAgKyBnYW1tYU9mZnNldCksIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLCByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpIDogMS4wKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgcmFuZG9tQWxwaGEgPyBNYXRoLnJhbmRvbSgpIDogMS4wKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2xvbmVzIHRoaXMgY29sb3IgYW5kIHJldHVybnMgYSBuZXcgY29sb3IuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xvbmUoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhcyBhbiBhcnJheS4NCiAgICAgICAgICovDQogICAgICAgIGFzQXJyYXkoKSB7DQogICAgICAgICAgICByZXR1cm4gW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIGFuIFJHQiBhcnJheS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZhbHMgLSBUaGUgdmFscyBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21BcnJheSh2YWxzKSB7DQogICAgICAgICAgICB0aGlzLnIgPSB2YWxzWzBdIC8gMjU1Ow0KICAgICAgICAgICAgdGhpcy5nID0gdmFsc1sxXSAvIDI1NTsNCiAgICAgICAgICAgIHRoaXMuYiA9IHZhbHNbMl0gLyAyNTU7DQogICAgICAgICAgICB0aGlzLmEgPSB2YWxzLmxlbmd0aCA9PSA0ID8gdmFsc1szXSAvIDI1NSA6IDEuMDsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgcjogdGhpcy5yLA0KICAgICAgICAgICAgICAgIGc6IHRoaXMuZywNCiAgICAgICAgICAgICAgICBiOiB0aGlzLmIsDQogICAgICAgICAgICAgICAgYTogdGhpcy5hLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqKSB7DQogICAgICAgICAgICB0aGlzLnIgPSBqLnI7DQogICAgICAgICAgICB0aGlzLmcgPSBqLmc7DQogICAgICAgICAgICB0aGlzLmIgPSBqLmI7DQogICAgICAgICAgICB0aGlzLmEgPSBqLmE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICAgICAgICAgIHRoaXMuciA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgdGhpcy5nID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICB0aGlzLmIgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHRoaXMuYSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBDU1MgcmdiYSBzdHJpbmcuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9DU1NTdHJpbmcoKSB7DQogICAgICAgICAgICByZXR1cm4gKCdyZ2JhKCcgKw0KICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5yICogMjU1KSArDQogICAgICAgICAgICAgICAgJywgJyArDQogICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpICsNCiAgICAgICAgICAgICAgICAnLCAnICsNCiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSkgKw0KICAgICAgICAgICAgICAgICcsICcgKw0KICAgICAgICAgICAgICAgIHRoaXMuYSArDQogICAgICAgICAgICAgICAgJyknKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdGhpcyBWZWMzIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvU3RyaW5nKCkgew0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXANCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICB2YXIgRXVsZXJBbmdsZXNBeGlzT3JkZXI7DQogICAgKGZ1bmN0aW9uIChFdWxlckFuZ2xlc0F4aXNPcmRlcikgew0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWFlaIl0gPSAwXSA9ICJYWVoiOw0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWVpYIl0gPSAxXSA9ICJZWlgiOw0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWlhZIl0gPSAyXSA9ICJaWFkiOw0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWFpZIl0gPSAzXSA9ICJYWlkiOw0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWllYIl0gPSA0XSA9ICJaWVgiOw0KICAgICAgICBFdWxlckFuZ2xlc0F4aXNPcmRlcltFdWxlckFuZ2xlc0F4aXNPcmRlclsiWVhaIl0gPSA1XSA9ICJZWFoiOw0KICAgIH0pKEV1bGVyQW5nbGVzQXhpc09yZGVyIHx8IChFdWxlckFuZ2xlc0F4aXNPcmRlciA9IHt9KSk7DQogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGV1bGVyIGFuZ2xlcy4gRXVsZXIgYW5nbGVzIGRlc2NyaWJlIHJvdGF0aW5nIGFuIG9iamVjdA0KICAgICAqIGFyb3VuZCBpdHMgdmFyaW91cyBheGlzIGluIGEgc3BlY2lmaWVkIGF4aXMgb3JkZXIuDQogICAgICoNCiAgICAgKi8NCiAgICBjbGFzcyBFdWxlckFuZ2xlcyB7DQogICAgICAgIHg7DQogICAgICAgIHk7DQogICAgICAgIHo7DQogICAgICAgIG9yZGVyOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgZXVsZXIgYW5nbGUuIFJlY2VpdmVzIHRoZSB4eXogdmFsdWVzIGluIHJhZGlhbnMgYW5kIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuDQogICAgICAgICAqDQogICAgICAgICAqIE9yZGVyIHBhcmFtZXRlciB2YWx1ZXM6IGBYWVo6IDBgLCBgWVpYOiAxYCwgYFpYWTogMmAsIGBYWlk6IDNgLCBgWllYOiA0YCwgYFlYWjogNWANCiAgICAgICAgICoNCiAgICAgICAgICogSXQgY291bGQgYmUgZWl0aGVyIHRoZSBgc3RyaW5nYCBvciB0aGUgYG51bWJlcmAgdmFsdWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy4gRGVmYXVsdCBpcyAwLg0KICAgICAgICAgKiBAcGFyYW0geSAtIFRoZSBhbmdsZSBvZiB0aGUgeSBheGlzIGluIHJhZGlhbnMuIERlZmF1bHQgaXMgMC4NCiAgICAgICAgICogQHBhcmFtIHogLSBUaGUgYW5nbGUgb2YgdGhlIHogYXhpcyBpbiByYWRpYW5zLiBEZWZhdWx0IGlzIDAuDQogICAgICAgICAqIEBwYXJhbSBvcmRlciAtIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSAwKSB7DQogICAgICAgICAgICB0aGlzLnggPSB4Ow0KICAgICAgICAgICAgdGhpcy55ID0geTsNCiAgICAgICAgICAgIHRoaXMueiA9IHo7DQogICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ob3JkZXIpKQ0KICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjsNCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHN3aXRjaCAob3JkZXIpIHsNCiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWFlaJzoNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSAwOw0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgIGNhc2UgJ1laWCc6DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gMTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgICAgICBjYXNlICdaWFknOg0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IDI7DQogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWFpZJzoNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSAzOw0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgIGNhc2UgJ1pZWCc6DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gNDsNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgICAgICBjYXNlICdZWFonOg0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IDU7DQogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoNCiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFdWxlciBBbmdsZXMgT3JkZXI6JyArIG9yZGVyKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIEV1bGVyQW5nbGVzDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIHggYXhpcyByb3RhdGlvbiBpbiByYWRpYW5zLg0KICAgICAgICAgKiBAcGFyYW0geSAtIFRoZSB5IGF4aXMgcm90YXRpb24gaW4gcmFkaWFucy4NCiAgICAgICAgICogQHBhcmFtIHogLSBUaGUgeiBheGlzIHJvdGF0aW9uIGluIHJhZGlhbnMuDQogICAgICAgICAqLw0KICAgICAgICBzZXQoeCwgeSwgeikgew0KICAgICAgICAgICAgdGhpcy54ID0geDsNCiAgICAgICAgICAgIHRoaXMueSA9IHk7DQogICAgICAgICAgICB0aGlzLnogPSB6Ow0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdGhpcyBWZWMzIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvU3RyaW5nKCkgew0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXANCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsNCiAgICAgICAgfQ0KICAgICAgICB0b0pTT04oKSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHg6IHRoaXMueCwNCiAgICAgICAgICAgICAgICB5OiB0aGlzLnksDQogICAgICAgICAgICAgICAgejogdGhpcy56LA0KICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tSlNPTihqc29uKSB7DQogICAgICAgICAgICB0aGlzLnggPSBqc29uLng7DQogICAgICAgICAgICB0aGlzLnkgPSBqc29uLnk7DQogICAgICAgICAgICB0aGlzLnogPSBqc29uLno7DQogICAgICAgICAgICB0aGlzLm9yZGVyID0ganNvbi5vcmRlcjsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovDQogICAgLyoqDQogICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSAzeDMgbWF0cml4Lg0KICAgICAqIFRoaXMgbWF0cml4IGNsYXNzIGlzIGJhc2VkIG9uIEdMTSwgYW5kIGlzIGNvbHVtbiBtYWpvci4NCiAgICAgKg0KICAgICAqLw0KICAgIGNsYXNzIE1hdDMgew0KICAgICAgICBtMDAgPSAxOw0KICAgICAgICBtMDEgPSAwOw0KICAgICAgICBtMDIgPSAwOw0KICAgICAgICBtMTAgPSAwOw0KICAgICAgICBtMTEgPSAxOw0KICAgICAgICBtMTIgPSAwOw0KICAgICAgICBtMjAgPSAwOw0KICAgICAgICBtMjEgPSAwOw0KICAgICAgICBtMjIgPSAxOw0KICAgICAgICAvKioNCiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hdDMgY2xhc3Mgd2l0aCBnaXZlbiBkYXRhLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbTAwIC0gUm93IDAsIGNvbHVtbiAwLg0KICAgICAgICAgKiBAcGFyYW0gbTAxIC0gUm93IDAsIGNvbHVtbiAxLg0KICAgICAgICAgKiBAcGFyYW0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLg0KICAgICAgICAgKiBAcGFyYW0gbTEwIC0gUm93IDEsIGNvbHVtbiAwLg0KICAgICAgICAgKiBAcGFyYW0gbTExIC0gUm93IDEsIGNvbHVtbiAxLg0KICAgICAgICAgKiBAcGFyYW0gbTEyIC0gUm93IDEsIGNvbHVtbiAyLg0KICAgICAgICAgKiBAcGFyYW0gbTIwIC0gUm93IDIsIGNvbHVtbiAwLg0KICAgICAgICAgKiBAcGFyYW0gbTIxIC0gUm93IDIsIGNvbHVtbiAxLg0KICAgICAgICAgKiBAcGFyYW0gbTIyIC0gUm93IDIsIGNvbHVtbiAyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSkgew0KICAgICAgICAgICAgaWYgKG0wMCBpbnN0YW5jZW9mIFZlYzMgJiYgbTAxIGluc3RhbmNlb2YgVmVjMyAmJiBtMDIgaW5zdGFuY2VvZiBWZWMzKSB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXQobTAwLngsIG0wMC55LCBtMDAueiwgbTAxLngsIG0wMS55LCBtMDEueiwgbTAyLngsIG0wMi55LCBtMDIueik7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aGlzLnNldChtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgYHhgIGF4aXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeGAgYXhpcyBhcyBhIFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBnZXQgeEF4aXMoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5tMDAsIHRoaXMubTAxLCB0aGlzLm0wMik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmb3IgdGhlIGB4YCBheGlzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0IHhBeGlzKHZlYzMpIHsNCiAgICAgICAgICAgIHRoaXMueEF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy4NCiAgICAgICAgICogKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYHlgIGF4aXMgYXMgYSBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IHlBeGlzKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMubTEwLCB0aGlzLm0xMSwgdGhpcy5tMTIpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy4NCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldCB5QXhpcyh2ZWMzKSB7DQogICAgICAgICAgICB0aGlzLnlBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAgICAgICAqICogQHJldHVybiAtIFJldHVybnMgdGhlIGB6YCBheGlzIGFzIGEgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGdldCB6QXhpcygpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLm0yMCwgdGhpcy5tMjEsIHRoaXMubTIyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXQgekF4aXModmVjMykgew0KICAgICAgICAgICAgdGhpcy56QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gU2V0dGVycw0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDMgY2xhc3MNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0wMiAtIFJvdyAwLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0xMiAtIFJvdyAxLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4NCiAgICAgICAgICovDQogICAgICAgIHNldChtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxKSB7DQogICAgICAgICAgICB0aGlzLm0wMCA9IG0wMDsNCiAgICAgICAgICAgIHRoaXMubTAxID0gbTAxOw0KICAgICAgICAgICAgdGhpcy5tMDIgPSBtMDI7DQogICAgICAgICAgICB0aGlzLm0xMCA9IG0xMDsNCiAgICAgICAgICAgIHRoaXMubTExID0gbTExOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBtMTI7DQogICAgICAgICAgICB0aGlzLm0yMCA9IG0yMDsNCiAgICAgICAgICAgIHRoaXMubTIxID0gbTIxOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBtMjI7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDMgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeA0KICAgICAgICAgKi8NCiAgICAgICAgc2V0SWRlbnRpdHkoKSB7DQogICAgICAgICAgICB0aGlzLnNldCgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIHRoZSBNYXQzIGZyb20gYW5vdGhlciBNYXQzDQogICAgICAgICAqDQogICAgICAgICAqIE5vdGU6IHdvcmtzIHdpdGggZWl0aGVyIE1hdDMgb3IgTWF0NC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG1hdCAtIFRoZSBtYXQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tTWF0KG1hdCkgew0KICAgICAgICAgICAgdGhpcy5tMDAgPSBtYXQubTAwOw0KICAgICAgICAgICAgdGhpcy5tMDEgPSBtYXQubTAxOw0KICAgICAgICAgICAgdGhpcy5tMDIgPSBtYXQubTAyOw0KICAgICAgICAgICAgdGhpcy5tMTAgPSBtYXQubTEwOw0KICAgICAgICAgICAgdGhpcy5tMTEgPSBtYXQubTExOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBtYXQubTEyOw0KICAgICAgICAgICAgdGhpcy5tMjAgPSBtYXQubTIwOw0KICAgICAgICAgICAgdGhpcy5tMjEgPSBtYXQubTIxOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBtYXQubTIyOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTY2FsZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIGBWZWMzYCBhbmQgc2V0cyB0aGUgcmVzdWx0IGluIHRoZSBNYXQzDQogICAgICAgICAqIE5vdGU6IHRoZSByZXN1bHRpbmcgbWF0cml4ICtaIGF4aXMgaXMgYWxpZ25lZCB3aXRoIHRoZSBwcm92aWRlZCBkaXJlY3Rpb24gdmFsdWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgZGlyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdXAgLSBUaGUgdXAgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IoZGlyLCB1cCkgew0KICAgICAgICAgICAgY29uc3QgekF4aXMgPSBkaXI7DQogICAgICAgICAgICBjb25zdCB6TGVuID0gekF4aXMubGVuZ3RoKCk7DQogICAgICAgICAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXRJZGVudGl0eSgpOw0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxIC8gekxlbik7DQogICAgICAgICAgICBjb25zdCB4QXhpcyA9IHVwLmNyb3NzKHpBeGlzKTsNCiAgICAgICAgICAgIGNvbnN0IHhMZW4gPSB4QXhpcy5sZW5ndGgoKTsNCiAgICAgICAgICAgIGlmICh4TGVuID4gTnVtYmVyLkVQU0lMT04pDQogICAgICAgICAgICAgICAgeEF4aXMuc2NhbGVJblBsYWNlKDEgLyB4TGVuKTsNCiAgICAgICAgICAgIGNvbnN0IHlBeGlzID0gekF4aXMuY3Jvc3MoeEF4aXMpOw0KICAgICAgICAgICAgY29uc3QgeUxlbiA9IHlBeGlzLmxlbmd0aCgpOw0KICAgICAgICAgICAgaWYgKHlMZW4gPiBOdW1iZXIuRVBTSUxPTikNCiAgICAgICAgICAgICAgICB5QXhpcy5zY2FsZUluUGxhY2UoMSAvIHlMZW4pOw0KICAgICAgICAgICAgdGhpcy5zZXQoeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgekF4aXMueCwgekF4aXMueSwgekF4aXMueik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEludmVydHMgYSBNYXQzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAgICAgICAqLw0KICAgICAgICBpbnZlcnNlKCkgew0KICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5tMDA7DQogICAgICAgICAgICBjb25zdCBhMDEgPSB0aGlzLm0wMTsNCiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMubTAyOw0KICAgICAgICAgICAgY29uc3QgYTEwID0gdGhpcy5tMTA7DQogICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLm0xMTsNCiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMubTEyOw0KICAgICAgICAgICAgY29uc3QgYTIwID0gdGhpcy5tMjA7DQogICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLm0yMTsNCiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMubTIyOw0KICAgICAgICAgICAgY29uc3QgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxOw0KICAgICAgICAgICAgY29uc3QgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDsNCiAgICAgICAgICAgIGNvbnN0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDsNCiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQNCiAgICAgICAgICAgIGxldCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7DQogICAgICAgICAgICBpZiAoIWRldCkgew0KICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQzJyk7DQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQzKCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7DQogICAgICAgICAgICByZXR1cm4gbmV3IE1hdDMoYjAxICogZGV0LCAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQsIChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0LCBiMTEgKiBkZXQsIChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0LCAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQsIGIyMSAqIGRldCwgKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0LCAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEludmVydHMgYSBNYXQzIGluIHBsYWNlIG1vZGlmeWluZyBpdHMgdmFsdWVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGludmVydEluUGxhY2UoKSB7DQogICAgICAgICAgICBjb25zdCBhMDAgPSB0aGlzLm0wMDsNCiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMubTAxOw0KICAgICAgICAgICAgY29uc3QgYTAyID0gdGhpcy5tMDI7DQogICAgICAgICAgICBjb25zdCBhMTAgPSB0aGlzLm0xMDsNCiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMubTExOw0KICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5tMTI7DQogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLm0yMDsNCiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMubTIxOw0KICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5tMjI7DQogICAgICAgICAgICBjb25zdCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7DQogICAgICAgICAgICBjb25zdCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwOw0KICAgICAgICAgICAgY29uc3QgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOw0KICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudA0KICAgICAgICAgICAgbGV0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTsNCiAgICAgICAgICAgIGlmICghZGV0KSB7DQogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDMnKTsNCiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7DQogICAgICAgICAgICB0aGlzLnNldChiMDEgKiBkZXQsICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldCwgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQsIGIxMSAqIGRldCwgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQsICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldCwgYjIxICogZGV0LCAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQsIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0KTsNCiAgICAgICAgICAgIHJldHVybiB0cnVlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUcmFuc3Bvc2VzIChleGNoYW5nZXMgY29sdW1ucyB3aXRoIHJvd3MpIHRoaXMgbWF0cml4DQogICAgICAgICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gYSBuZXcgdHJhbnNwb3NlZCBNYXQzLg0KICAgICAgICAgKi8NCiAgICAgICAgdHJhbnNwb3NlKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQzKHRoaXMubTAwLCB0aGlzLm0xMCwgdGhpcy5tMjAsIHRoaXMubTAxLCB0aGlzLm0xMSwgdGhpcy5tMjEsIHRoaXMubTAyLCB0aGlzLm0xMiwgdGhpcy5tMjIpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUcmFuc3Bvc2VzIChleGNoYW5nZXMgY29sdW1ucyB3aXRoIHJvd3MpIHRoaXMgbWF0cml4IG1vZGlmeWluZyBpdHMgdmFsdWVzLg0KICAgICAgICAgKi8NCiAgICAgICAgdHJhbnNwb3NlSW5QbGFjZSgpIHsNCiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXMNCiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMubTAxOw0KICAgICAgICAgICAgY29uc3QgYTAyID0gdGhpcy5tMDI7DQogICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLm0xMjsNCiAgICAgICAgICAgIHRoaXMubTAxID0gdGhpcy5tMTA7DQogICAgICAgICAgICB0aGlzLm0wMiA9IHRoaXMubTIwOw0KICAgICAgICAgICAgdGhpcy5tMTAgPSBhMDE7DQogICAgICAgICAgICB0aGlzLm0xMiA9IHRoaXMubTIxOw0KICAgICAgICAgICAgdGhpcy5tMjAgPSBhMDI7DQogICAgICAgICAgICB0aGlzLm0yMSA9IGExMjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgVmVjMyB3aXRoIGEgTWF0My4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICB0cmFuc2Zvcm1WZWMzKHZlYzMpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLm0wMCAqIHZlYzMueCArIHRoaXMubTAxICogdmVjMy55ICsgdGhpcy5tMDIgKiB2ZWMzLnosIHRoaXMubTEwICogdmVjMy54ICsgdGhpcy5tMTEgKiB2ZWMzLnkgKyB0aGlzLm0xMiAqIHZlYzMueiwgdGhpcy5tMjAgKiB2ZWMzLnggKyB0aGlzLm0yMSAqIHZlYzMueSArIHRoaXMubTIyICogdmVjMy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2xvbmVzIHRoaXMgTWF0MyByZXR1cm5pbmcgYSBuZXcgaW5zdGFuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzLm0wMCwgdGhpcy5tMDEsIHRoaXMubTAyLCB0aGlzLm0xMCwgdGhpcy5tMTEsIHRoaXMubTEyLCB0aGlzLm0yMCwgdGhpcy5tMjEsIHRoaXMubTIyKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIubG9hZEZsb2F0MzJBcnJheSg5KTsNCiAgICAgICAgICAgIHRoaXMuZnJvbUFycmF5KGRhdGEpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzQXJyYXkoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGpzb24gLSBUaGUganNvbiBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGpzb24pIHsNCiAgICAgICAgICAgIHRoaXMuZnJvbUFycmF5KGpzb24pOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBEZWJ1Z2dpbmcNCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY3VycmVudCBNYXRoIHR5cGUgZGF0YSBhcyBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBhc0FycmF5KCkgew0KICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm0wMCwgdGhpcy5tMDEsIHRoaXMubTAyLCB0aGlzLm0xMCwgdGhpcy5tMTEsIHRoaXMubTEyLCB0aGlzLm0yMCwgdGhpcy5tMjEsIHRoaXMubTIyXTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tQXJyYXkoYXJyYXkpIHsNCiAgICAgICAgICAgIHRoaXMubTAwID0gYXJyYXlbMF07DQogICAgICAgICAgICB0aGlzLm0wMSA9IGFycmF5WzFdOw0KICAgICAgICAgICAgdGhpcy5tMDIgPSBhcnJheVsyXTsNCiAgICAgICAgICAgIHRoaXMubTEwID0gYXJyYXlbM107DQogICAgICAgICAgICB0aGlzLm0xMSA9IGFycmF5WzRdOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBhcnJheVs1XTsNCiAgICAgICAgICAgIHRoaXMubTIwID0gYXJyYXlbNl07DQogICAgICAgICAgICB0aGlzLm0yMSA9IGFycmF5WzddOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBhcnJheVs4XTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKioNCiAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIDR4NCBtYXRyaXguDQogICAgICogVGhpcyBtYXRyaXggY2xhc3MgaXMgYmFzZWQgb24gR0xNLCBhbmQgaXMgY29sdW1uIG1ham9yLg0KICAgICAqDQogICAgICovDQogICAgY2xhc3MgTWF0NCB7DQogICAgICAgIG0wMDsNCiAgICAgICAgbTAxOw0KICAgICAgICBtMDI7DQogICAgICAgIG0wMzsNCiAgICAgICAgbTEwOw0KICAgICAgICBtMTE7DQogICAgICAgIG0xMjsNCiAgICAgICAgbTEzOw0KICAgICAgICBtMjA7DQogICAgICAgIG0yMTsNCiAgICAgICAgbTIyOw0KICAgICAgICBtMjM7DQogICAgICAgIG0zMDsNCiAgICAgICAgbTMxOw0KICAgICAgICBtMzI7DQogICAgICAgIG0zMzsNCiAgICAgICAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTAzID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTEzID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSwgbTIzID0gMCwgbTMwID0gMCwgbTMxID0gMCwgbTMyID0gMCwgbTMzID0gMSkgew0KICAgICAgICAgICAgdGhpcy5tMDAgPSBtMDA7DQogICAgICAgICAgICB0aGlzLm0wMSA9IG0wMTsNCiAgICAgICAgICAgIHRoaXMubTAyID0gbTAyOw0KICAgICAgICAgICAgdGhpcy5tMDMgPSBtMDM7DQogICAgICAgICAgICB0aGlzLm0xMCA9IG0xMDsNCiAgICAgICAgICAgIHRoaXMubTExID0gbTExOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBtMTI7DQogICAgICAgICAgICB0aGlzLm0xMyA9IG0xMzsNCiAgICAgICAgICAgIHRoaXMubTIwID0gbTIwOw0KICAgICAgICAgICAgdGhpcy5tMjEgPSBtMjE7DQogICAgICAgICAgICB0aGlzLm0yMiA9IG0yMjsNCiAgICAgICAgICAgIHRoaXMubTIzID0gbTIzOw0KICAgICAgICAgICAgdGhpcy5tMzAgPSBtMzA7DQogICAgICAgICAgICB0aGlzLm0zMSA9IG0zMTsNCiAgICAgICAgICAgIHRoaXMubTMyID0gbTMyOw0KICAgICAgICAgICAgdGhpcy5tMzMgPSBtMzM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmb3IgdGhlIGB4YCBheGlzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYHhgIGF4aXMgYXMgYSBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IHhBeGlzKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMubTAwLCB0aGlzLm0wMSwgdGhpcy5tMDIpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldCB4QXhpcyh2ZWMzKSB7DQogICAgICAgICAgICB0aGlzLnhBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgYHlgIGF4aXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeWAgYXhpcyBhcyBhIFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBnZXQgeUF4aXMoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5tMTAsIHRoaXMubTExLCB0aGlzLm0xMik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0IHlBeGlzKHZlYzMpIHsNCiAgICAgICAgICAgIHRoaXMueUF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgemAgYXhpcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGB6YCBheGlzIGFzIGEgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGdldCB6QXhpcygpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLm0yMCwgdGhpcy5tMjEsIHRoaXMubTIyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXQgekF4aXModmVjMykgew0KICAgICAgICAgICAgdGhpcy56QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmb3IgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBtYXRyaXguIEFzc3VtZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlcyBhcmUgMTIsIDEzLCAmIDE0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgdHJhbnNsYXRpb24uDQogICAgICAgICAqLw0KICAgICAgICBnZXQgdHJhbnNsYXRpb24oKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5tMzAsIHRoaXMubTMxLCB0aGlzLm0zMik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmb3IgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBtYXRyaXguIEFzc3VtZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlcyBhcmUgMTIsIDEzLCAmIDE0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB0cmFuc2xhdGlvbi4NCiAgICAgICAgICovDQogICAgICAgIHNldCB0cmFuc2xhdGlvbih2ZWMzKSB7DQogICAgICAgICAgICB0aGlzLm0zMCA9IHZlYzMueDsNCiAgICAgICAgICAgIHRoaXMubTMxID0gdmVjMy55Ow0KICAgICAgICAgICAgdGhpcy5tMzIgPSB2ZWMzLno7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gU2V0dGVycw0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3MNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0wMiAtIFJvdyAwLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0wMyAtIFJvdyAwLCBjb2x1bW4gMy4NCiAgICAgICAgICogQHBhcmFtIG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0xMiAtIFJvdyAxLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0xMyAtIFJvdyAxLCBjb2x1bW4gMy4NCiAgICAgICAgICogQHBhcmFtIG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0yMyAtIFJvdyAyLCBjb2x1bW4gMy4NCiAgICAgICAgICogQHBhcmFtIG0zMCAtIFJvdyAzLCBjb2x1bW4gMC4NCiAgICAgICAgICogQHBhcmFtIG0zMSAtIFJvdyAzLCBjb2x1bW4gMS4NCiAgICAgICAgICogQHBhcmFtIG0zMiAtIFJvdyAzLCBjb2x1bW4gMi4NCiAgICAgICAgICogQHBhcmFtIG0zMyAtIFJvdyAzLCBjb2x1bW4gMy4NCiAgICAgICAgICovDQogICAgICAgIHNldChtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMDMgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMTMgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxLCBtMjMgPSAwLCBtMzAgPSAwLCBtMzEgPSAwLCBtMzIgPSAwLCBtMzMgPSAxKSB7DQogICAgICAgICAgICB0aGlzLm0wMCA9IG0wMDsNCiAgICAgICAgICAgIHRoaXMubTAxID0gbTAxOw0KICAgICAgICAgICAgdGhpcy5tMDIgPSBtMDI7DQogICAgICAgICAgICB0aGlzLm0wMyA9IG0wMzsNCiAgICAgICAgICAgIHRoaXMubTEwID0gbTEwOw0KICAgICAgICAgICAgdGhpcy5tMTEgPSBtMTE7DQogICAgICAgICAgICB0aGlzLm0xMiA9IG0xMjsNCiAgICAgICAgICAgIHRoaXMubTEzID0gbTEzOw0KICAgICAgICAgICAgdGhpcy5tMjAgPSBtMjA7DQogICAgICAgICAgICB0aGlzLm0yMSA9IG0yMTsNCiAgICAgICAgICAgIHRoaXMubTIyID0gbTIyOw0KICAgICAgICAgICAgdGhpcy5tMjMgPSBtMjM7DQogICAgICAgICAgICB0aGlzLm0zMCA9IG0zMDsNCiAgICAgICAgICAgIHRoaXMubTMxID0gbTMxOw0KICAgICAgICAgICAgdGhpcy5tMzIgPSBtMzI7DQogICAgICAgICAgICB0aGlzLm0zMyA9IG0zMzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiB0aGUgTWF0NCB3aXRoIHRoZSBpZGVudGl0eSAgTWF0cml4DQogICAgICAgICAqLw0KICAgICAgICBzZXRJZGVudGl0eSgpIHsNCiAgICAgICAgICAgIHRoaXMuc2V0KCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgZnJvbSBhbm90aGVyIE1hdDQNCiAgICAgICAgICoNCiAgICAgICAgICogTm90ZTogd29ya3Mgd2l0aCBlaXRoZXIgTWF0MyBvciBNYXQ0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU1hdDQobWF0NCkgew0KICAgICAgICAgICAgdGhpcy5tMDAgPSBtYXQ0Lm0wMDsNCiAgICAgICAgICAgIHRoaXMubTAxID0gbWF0NC5tMDE7DQogICAgICAgICAgICB0aGlzLm0wMiA9IG1hdDQubTAyOw0KICAgICAgICAgICAgdGhpcy5tMDMgPSBtYXQ0Lm0wMzsNCiAgICAgICAgICAgIHRoaXMubTEwID0gbWF0NC5tMTA7DQogICAgICAgICAgICB0aGlzLm0xMSA9IG1hdDQubTExOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBtYXQ0Lm0xMjsNCiAgICAgICAgICAgIHRoaXMubTEzID0gbWF0NC5tMTM7DQogICAgICAgICAgICB0aGlzLm0yMCA9IG1hdDQubTIwOw0KICAgICAgICAgICAgdGhpcy5tMjEgPSBtYXQ0Lm0yMTsNCiAgICAgICAgICAgIHRoaXMubTIyID0gbWF0NC5tMjI7DQogICAgICAgICAgICB0aGlzLm0yMyA9IG1hdDQubTIzOw0KICAgICAgICAgICAgdGhpcy5tMzAgPSBtYXQ0Lm0zMDsNCiAgICAgICAgICAgIHRoaXMubTMxID0gbWF0NC5tMzE7DQogICAgICAgICAgICB0aGlzLm0zMiA9IG1hdDQubTMyOw0KICAgICAgICAgICAgdGhpcy5tMzMgPSBtYXQ0Lm0zMzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgYSBNYXQ0IHRvIGEgTWF0My4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0My4NCiAgICAgICAgICovDQogICAgICAgIHRvTWF0MygpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzLm0wMCwgdGhpcy5tMDEsIHRoaXMubTAyLCB0aGlzLm0xMCwgdGhpcy5tMTEsIHRoaXMubTEyLCB0aGlzLm0yMCwgdGhpcy5tMjEsIHRoaXMubTIyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVHJhbnNwb3NlcyAoZXhjaGFuZ2VzIGNvbHVtbnMgd2l0aCByb3dzKSB0aGlzIG1hdHJpeC4NCiAgICAgICAgICovDQogICAgICAgIHRyYW5zcG9zZUluUGxhY2UoKSB7DQogICAgICAgICAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzDQogICAgICAgICAgICBjb25zdCBhMDEgPSB0aGlzLm0wMTsNCiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMubTAyOw0KICAgICAgICAgICAgY29uc3QgYTAzID0gdGhpcy5tMDM7DQogICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLm0xMjsNCiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMubTEzOw0KICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5tMjM7DQogICAgICAgICAgICB0aGlzLm0wMSA9IHRoaXMubTEwOw0KICAgICAgICAgICAgdGhpcy5tMDIgPSB0aGlzLm0yMDsNCiAgICAgICAgICAgIHRoaXMubTAzID0gdGhpcy5tMzA7DQogICAgICAgICAgICB0aGlzLm0xMCA9IGEwMTsNCiAgICAgICAgICAgIHRoaXMubTEyID0gdGhpcy5tMjE7DQogICAgICAgICAgICB0aGlzLm0xMyA9IHRoaXMubTMxOw0KICAgICAgICAgICAgdGhpcy5tMjAgPSBhMDI7DQogICAgICAgICAgICB0aGlzLm0yMSA9IGExMjsNCiAgICAgICAgICAgIHRoaXMubTIzID0gdGhpcy5tMzI7DQogICAgICAgICAgICB0aGlzLm0zMCA9IGEwMzsNCiAgICAgICAgICAgIHRoaXMubTMxID0gYTEzOw0KICAgICAgICAgICAgdGhpcy5tMzIgPSBhMjM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYW5zcG9zZXMgKGV4Y2hhbmdlcyBjb2x1bW5zIHdpdGggcm93cykgdGhpcyBtYXRyaXgNCiAgICAgICAgICogYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBpbnN0YW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybiBhIG5ldyB0cmFuc3Bvc2VkIE1hdDQuDQogICAgICAgICAqLw0KICAgICAgICB0cmFuc3Bvc2UoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IE1hdDQodGhpcy5tMDAsIHRoaXMubTEwLCB0aGlzLm0yMCwgdGhpcy5tMzAsIHRoaXMubTAxLCB0aGlzLm0xMSwgdGhpcy5tMjEsIHRoaXMubTMxLCB0aGlzLm0wMiwgdGhpcy5tMTIsIHRoaXMubTIyLCB0aGlzLm0zMiwgdGhpcy5tMDMsIHRoaXMubTEzLCB0aGlzLm0yMywgdGhpcy5tMzMpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBJbnZlcnRzIGEgTWF0NCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IGluc3RhbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBNYXQ0Lg0KICAgICAgICAgKi8NCiAgICAgICAgaW52ZXJzZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGEwMCA9IHRoaXMubTAwOw0KICAgICAgICAgICAgY29uc3QgYTAxID0gdGhpcy5tMDE7DQogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLm0wMjsNCiAgICAgICAgICAgIGNvbnN0IGEwMyA9IHRoaXMubTAzOw0KICAgICAgICAgICAgY29uc3QgYTEwID0gdGhpcy5tMTA7DQogICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLm0xMTsNCiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMubTEyOw0KICAgICAgICAgICAgY29uc3QgYTEzID0gdGhpcy5tMTM7DQogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLm0yMDsNCiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMubTIxOw0KICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5tMjI7DQogICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLm0yMzsNCiAgICAgICAgICAgIGNvbnN0IGEzMCA9IHRoaXMubTMwOw0KICAgICAgICAgICAgY29uc3QgYTMxID0gdGhpcy5tMzE7DQogICAgICAgICAgICBjb25zdCBhMzIgPSB0aGlzLm0zMjsNCiAgICAgICAgICAgIGNvbnN0IGEzMyA9IHRoaXMubTMzOw0KICAgICAgICAgICAgY29uc3QgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwOw0KICAgICAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwOw0KICAgICAgICAgICAgY29uc3QgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwOw0KICAgICAgICAgICAgY29uc3QgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExOw0KICAgICAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExOw0KICAgICAgICAgICAgY29uc3QgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyOw0KICAgICAgICAgICAgY29uc3QgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwOw0KICAgICAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwOw0KICAgICAgICAgICAgY29uc3QgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwOw0KICAgICAgICAgICAgY29uc3QgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxOw0KICAgICAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxOw0KICAgICAgICAgICAgY29uc3QgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOw0KICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudA0KICAgICAgICAgICAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjsNCiAgICAgICAgICAgIGlmICghZGV0KSB7DQogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDQnKTsNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0NCgoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LCAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LCAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LCAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LCAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LCAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEludmVydHMgYSBNYXQ0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGludmVydEluUGxhY2UoKSB7DQogICAgICAgICAgICBjb25zdCBhMDAgPSB0aGlzLm0wMDsNCiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMubTAxOw0KICAgICAgICAgICAgY29uc3QgYTAyID0gdGhpcy5tMDI7DQogICAgICAgICAgICBjb25zdCBhMDMgPSB0aGlzLm0wMzsNCiAgICAgICAgICAgIGNvbnN0IGExMCA9IHRoaXMubTEwOw0KICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5tMTE7DQogICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLm0xMjsNCiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMubTEzOw0KICAgICAgICAgICAgY29uc3QgYTIwID0gdGhpcy5tMjA7DQogICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLm0yMTsNCiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMubTIyOw0KICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5tMjM7DQogICAgICAgICAgICBjb25zdCBhMzAgPSB0aGlzLm0zMDsNCiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMubTMxOw0KICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5tMzI7DQogICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLm0zMzsNCiAgICAgICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsNCiAgICAgICAgICAgIGNvbnN0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTsNCiAgICAgICAgICAgIGNvbnN0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjsNCiAgICAgICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsNCiAgICAgICAgICAgIGNvbnN0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTsNCiAgICAgICAgICAgIGNvbnN0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsNCiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQNCiAgICAgICAgICAgIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7DQogICAgICAgICAgICBpZiAoIWRldCkgew0KICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7DQogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0Ow0KICAgICAgICAgICAgdGhpcy5zZXQoKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQsIChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0LCAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldCwgKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQsIChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0LCAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldCwgKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQsIChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0LCAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldCwgKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQsIChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0LCAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldCwgKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQsIChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0LCAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldCwgKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQpOw0KICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhpcyBtYXRyaXggYXMgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIE1hdDQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBtYXQ0IC0gVGhlIG1hdDQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBJbiBjYXNlIHRoZSBgZGV0ZXJtaW5hbnRgIGNhbid0IGJlIGNhbGN1bGF0ZWQsIGEgYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSwgbm90aGluZyBpcyByZXR1cm5lZA0KICAgICAgICAgKi8NCiAgICAgICAgc2V0SW52ZXJzZShtYXQ0KSB7DQogICAgICAgICAgICBjb25zdCBhMDAgPSBtYXQ0Lm0wMDsNCiAgICAgICAgICAgIGNvbnN0IGEwMSA9IG1hdDQubTAxOw0KICAgICAgICAgICAgY29uc3QgYTAyID0gbWF0NC5tMDI7DQogICAgICAgICAgICBjb25zdCBhMDMgPSBtYXQ0Lm0wMzsNCiAgICAgICAgICAgIGNvbnN0IGExMCA9IG1hdDQubTEwOw0KICAgICAgICAgICAgY29uc3QgYTExID0gbWF0NC5tMTE7DQogICAgICAgICAgICBjb25zdCBhMTIgPSBtYXQ0Lm0xMjsNCiAgICAgICAgICAgIGNvbnN0IGExMyA9IG1hdDQubTEzOw0KICAgICAgICAgICAgY29uc3QgYTIwID0gbWF0NC5tMjA7DQogICAgICAgICAgICBjb25zdCBhMjEgPSBtYXQ0Lm0yMTsNCiAgICAgICAgICAgIGNvbnN0IGEyMiA9IG1hdDQubTIyOw0KICAgICAgICAgICAgY29uc3QgYTIzID0gbWF0NC5tMjM7DQogICAgICAgICAgICBjb25zdCBhMzAgPSBtYXQ0Lm0zMDsNCiAgICAgICAgICAgIGNvbnN0IGEzMSA9IG1hdDQubTMxOw0KICAgICAgICAgICAgY29uc3QgYTMyID0gbWF0NC5tMzI7DQogICAgICAgICAgICBjb25zdCBhMzMgPSBtYXQ0Lm0zMzsNCiAgICAgICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDsNCiAgICAgICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsNCiAgICAgICAgICAgIGNvbnN0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTsNCiAgICAgICAgICAgIGNvbnN0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjsNCiAgICAgICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDsNCiAgICAgICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsNCiAgICAgICAgICAgIGNvbnN0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTsNCiAgICAgICAgICAgIGNvbnN0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsNCiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQNCiAgICAgICAgICAgIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7DQogICAgICAgICAgICBpZiAoIWRldCkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7DQogICAgICAgICAgICB0aGlzLnNldCgoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LCAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LCAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LCAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LCAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LCAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIE1hdDRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBNYXQ0IHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAgICAgICAqLw0KICAgICAgICBtdWx0aXBseShvdGhlcikgew0KICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5tMDA7DQogICAgICAgICAgICBjb25zdCBhMDEgPSB0aGlzLm0wMTsNCiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMubTAyOw0KICAgICAgICAgICAgY29uc3QgYTAzID0gdGhpcy5tMDM7DQogICAgICAgICAgICBjb25zdCBhMTAgPSB0aGlzLm0xMDsNCiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMubTExOw0KICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5tMTI7DQogICAgICAgICAgICBjb25zdCBhMTMgPSB0aGlzLm0xMzsNCiAgICAgICAgICAgIGNvbnN0IGEyMCA9IHRoaXMubTIwOw0KICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5tMjE7DQogICAgICAgICAgICBjb25zdCBhMjIgPSB0aGlzLm0yMjsNCiAgICAgICAgICAgIGNvbnN0IGEyMyA9IHRoaXMubTIzOw0KICAgICAgICAgICAgY29uc3QgYTMwID0gdGhpcy5tMzA7DQogICAgICAgICAgICBjb25zdCBhMzEgPSB0aGlzLm0zMTsNCiAgICAgICAgICAgIGNvbnN0IGEzMiA9IHRoaXMubTMyOw0KICAgICAgICAgICAgY29uc3QgYTMzID0gdGhpcy5tMzM7DQogICAgICAgICAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXgNCiAgICAgICAgICAgIGNvbnN0IGIgPSBvdGhlci5hc0FycmF5KCk7DQogICAgICAgICAgICBsZXQgYjAgPSBiWzBdOw0KICAgICAgICAgICAgbGV0IGIxID0gYlsxXTsNCiAgICAgICAgICAgIGxldCBiMiA9IGJbMl07DQogICAgICAgICAgICBsZXQgYjMgPSBiWzNdOw0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdDQoKTsNCiAgICAgICAgICAgIHJlc3VsdC5tMDAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHJlc3VsdC5tMDEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICAgICAgICAgIHJlc3VsdC5tMDIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHJlc3VsdC5tMDMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIGIwID0gYls0XTsNCiAgICAgICAgICAgIGIxID0gYls1XTsNCiAgICAgICAgICAgIGIyID0gYls2XTsNCiAgICAgICAgICAgIGIzID0gYls3XTsNCiAgICAgICAgICAgIHJlc3VsdC5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHJlc3VsdC5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICAgICAgICAgIHJlc3VsdC5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHJlc3VsdC5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIGIwID0gYls4XTsNCiAgICAgICAgICAgIGIxID0gYls5XTsNCiAgICAgICAgICAgIGIyID0gYlsxMF07DQogICAgICAgICAgICBiMyA9IGJbMTFdOw0KICAgICAgICAgICAgcmVzdWx0Lm0yMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOw0KICAgICAgICAgICAgcmVzdWx0Lm0yMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxOw0KICAgICAgICAgICAgcmVzdWx0Lm0yMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgICAgICAgICAgcmVzdWx0Lm0yMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOw0KICAgICAgICAgICAgYjAgPSBiWzEyXTsNCiAgICAgICAgICAgIGIxID0gYlsxM107DQogICAgICAgICAgICBiMiA9IGJbMTRdOw0KICAgICAgICAgICAgYjMgPSBiWzE1XTsNCiAgICAgICAgICAgIHJlc3VsdC5tMzAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHJlc3VsdC5tMzEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsNCiAgICAgICAgICAgIHJlc3VsdC5tMzIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHJlc3VsdC5tMzMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIE1hdDRzIGluIHBsYWNlIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTUQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBNYXQ0IHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAgICAgICAqLw0KICAgICAgICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKTsNCiAgICAgICAgICAgIGNvbnN0IGEwMCA9IGFbMF07DQogICAgICAgICAgICBjb25zdCBhMDEgPSBhWzFdOw0KICAgICAgICAgICAgY29uc3QgYTAyID0gYVsyXTsNCiAgICAgICAgICAgIGNvbnN0IGEwMyA9IGFbM107DQogICAgICAgICAgICBjb25zdCBhMTAgPSBhWzRdOw0KICAgICAgICAgICAgY29uc3QgYTExID0gYVs1XTsNCiAgICAgICAgICAgIGNvbnN0IGExMiA9IGFbNl07DQogICAgICAgICAgICBjb25zdCBhMTMgPSBhWzddOw0KICAgICAgICAgICAgY29uc3QgYTIwID0gYVs4XTsNCiAgICAgICAgICAgIGNvbnN0IGEyMSA9IGFbOV07DQogICAgICAgICAgICBjb25zdCBhMjIgPSBhWzEwXTsNCiAgICAgICAgICAgIGNvbnN0IGEyMyA9IGFbMTFdOw0KICAgICAgICAgICAgY29uc3QgYTMwID0gYVsxMl07DQogICAgICAgICAgICBjb25zdCBhMzEgPSBhWzEzXTsNCiAgICAgICAgICAgIGNvbnN0IGEzMiA9IGFbMTRdOw0KICAgICAgICAgICAgY29uc3QgYTMzID0gYVsxNV07DQogICAgICAgICAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXgNCiAgICAgICAgICAgIGNvbnN0IGIgPSBvdGhlci5hc0FycmF5KCk7DQogICAgICAgICAgICBsZXQgYjAgPSBiWzBdOw0KICAgICAgICAgICAgbGV0IGIxID0gYlsxXTsNCiAgICAgICAgICAgIGxldCBiMiA9IGJbMl07DQogICAgICAgICAgICBsZXQgYjMgPSBiWzNdOw0KICAgICAgICAgICAgdGhpcy5tMDAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgICAgICAgICB0aGlzLm0wMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgICAgICAgICAgdGhpcy5tMDMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIGIwID0gYls0XTsNCiAgICAgICAgICAgIGIxID0gYls1XTsNCiAgICAgICAgICAgIGIyID0gYls2XTsNCiAgICAgICAgICAgIGIzID0gYls3XTsNCiAgICAgICAgICAgIHRoaXMubTEwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgICAgICAgICB0aGlzLm0xMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHRoaXMubTEzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQogICAgICAgICAgICBiMCA9IGJbOF07DQogICAgICAgICAgICBiMSA9IGJbOV07DQogICAgICAgICAgICBiMiA9IGJbMTBdOw0KICAgICAgICAgICAgYjMgPSBiWzExXTsNCiAgICAgICAgICAgIHRoaXMubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgICAgICAgICB0aGlzLm0yMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHRoaXMubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQogICAgICAgICAgICBiMCA9IGJbMTJdOw0KICAgICAgICAgICAgYjEgPSBiWzEzXTsNCiAgICAgICAgICAgIGIyID0gYlsxNF07DQogICAgICAgICAgICBiMyA9IGJbMTVdOw0KICAgICAgICAgICAgdGhpcy5tMzAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgICAgICAgICB0aGlzLm0zMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgICAgICAgICAgdGhpcy5tMzMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBQb3N0IG11bHRpcGxpZXMgdHdvIE1hdDRzIGluIHBsYWNlIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTUQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBNYXQ0IHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgTWF0NC4NCiAgICAgICAgICovDQogICAgICAgIHBvc3RNdWx0aXBseUluUGxhY2Uob3RoZXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGEgPSBvdGhlci5hc0FycmF5KCk7DQogICAgICAgICAgICBjb25zdCBhMDAgPSBhWzBdOw0KICAgICAgICAgICAgY29uc3QgYTAxID0gYVsxXTsNCiAgICAgICAgICAgIGNvbnN0IGEwMiA9IGFbMl07DQogICAgICAgICAgICBjb25zdCBhMDMgPSBhWzNdOw0KICAgICAgICAgICAgY29uc3QgYTEwID0gYVs0XTsNCiAgICAgICAgICAgIGNvbnN0IGExMSA9IGFbNV07DQogICAgICAgICAgICBjb25zdCBhMTIgPSBhWzZdOw0KICAgICAgICAgICAgY29uc3QgYTEzID0gYVs3XTsNCiAgICAgICAgICAgIGNvbnN0IGEyMCA9IGFbOF07DQogICAgICAgICAgICBjb25zdCBhMjEgPSBhWzldOw0KICAgICAgICAgICAgY29uc3QgYTIyID0gYVsxMF07DQogICAgICAgICAgICBjb25zdCBhMjMgPSBhWzExXTsNCiAgICAgICAgICAgIGNvbnN0IGEzMCA9IGFbMTJdOw0KICAgICAgICAgICAgY29uc3QgYTMxID0gYVsxM107DQogICAgICAgICAgICBjb25zdCBhMzIgPSBhWzE0XTsNCiAgICAgICAgICAgIGNvbnN0IGEzMyA9IGFbMTVdOw0KICAgICAgICAgICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4DQogICAgICAgICAgICBjb25zdCBiID0gdGhpcy5hc0FycmF5KCk7DQogICAgICAgICAgICBsZXQgYjAgPSBiWzBdOw0KICAgICAgICAgICAgbGV0IGIxID0gYlsxXTsNCiAgICAgICAgICAgIGxldCBiMiA9IGJbMl07DQogICAgICAgICAgICBsZXQgYjMgPSBiWzNdOw0KICAgICAgICAgICAgdGhpcy5tMDAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgICAgICAgICB0aGlzLm0wMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgICAgICAgICAgdGhpcy5tMDMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIGIwID0gYls0XTsNCiAgICAgICAgICAgIGIxID0gYls1XTsNCiAgICAgICAgICAgIGIyID0gYls2XTsNCiAgICAgICAgICAgIGIzID0gYls3XTsNCiAgICAgICAgICAgIHRoaXMubTEwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgICAgICAgICB0aGlzLm0xMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxOw0KICAgICAgICAgICAgdGhpcy5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHRoaXMubTEzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQogICAgICAgICAgICBiMCA9IGJbOF07DQogICAgICAgICAgICBiMSA9IGJbOV07DQogICAgICAgICAgICBiMiA9IGJbMTBdOw0KICAgICAgICAgICAgYjMgPSBiWzExXTsNCiAgICAgICAgICAgIHRoaXMubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7DQogICAgICAgICAgICB0aGlzLm0yMSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsNCiAgICAgICAgICAgIHRoaXMubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7DQogICAgICAgICAgICBiMCA9IGJbMTJdOw0KICAgICAgICAgICAgYjEgPSBiWzEzXTsNCiAgICAgICAgICAgIGIyID0gYlsxNF07DQogICAgICAgICAgICBiMyA9IGJbMTVdOw0KICAgICAgICAgICAgdGhpcy5tMzAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsNCiAgICAgICAgICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7DQogICAgICAgICAgICB0aGlzLm0zMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOw0KICAgICAgICAgICAgdGhpcy5tMzMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUcmFuc2xhdGUgYSBNYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igbm90IHVzaW5nIFNJTUQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2MyAtIFRoZSBnaXZlbiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGFsb25nLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRyYW5zbGF0ZUluUGxhY2UodjMpIHsNCiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKTsNCiAgICAgICAgICAgIGNvbnN0IHggPSB2My54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHYzLnk7DQogICAgICAgICAgICBjb25zdCB6ID0gdjMuejsNCiAgICAgICAgICAgIGFbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07DQogICAgICAgICAgICBhWzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdOw0KICAgICAgICAgICAgYVsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07DQogICAgICAgICAgICBhWzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTsNCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcG9zIC0gUG9zaXRpb24gb2YgdGhlIHZpZXdlci4NCiAgICAgICAgICogQHBhcmFtIHRhcmdldCAtIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdC4NCiAgICAgICAgICogQHBhcmFtIHVwIC0gVmVjMyBwb2ludGluZyB1cC4NCiAgICAgICAgICovDQogICAgICAgIHNldExvb2tBdChwb3MsIHRhcmdldCwgdXApIHsNCiAgICAgICAgICAgIGNvbnN0IHpBeGlzID0gcG9zLnN1YnRyYWN0KHRhcmdldCk7DQogICAgICAgICAgICBjb25zdCB6TGVuID0gekF4aXMubGVuZ3RoKCk7DQogICAgICAgICAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXRJZGVudGl0eSgpOw0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB6TGVuKTsNCiAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gdXAuY3Jvc3MoekF4aXMpOw0KICAgICAgICAgICAgY29uc3QgeExlbiA9IHhBeGlzLmxlbmd0aCgpOw0KICAgICAgICAgICAgaWYgKHhMZW4gPiBOdW1iZXIuRVBTSUxPTikNCiAgICAgICAgICAgICAgICB4QXhpcy5zY2FsZUluUGxhY2UoMS4wIC8geExlbik7DQogICAgICAgICAgICBjb25zdCB5QXhpcyA9IHpBeGlzLmNyb3NzKHhBeGlzKTsNCiAgICAgICAgICAgIGNvbnN0IHlMZW4gPSB5QXhpcy5sZW5ndGgoKTsNCiAgICAgICAgICAgIGlmICh5TGVuID4gTnVtYmVyLkVQU0lMT04pDQogICAgICAgICAgICAgICAgeUF4aXMuc2NhbGVJblBsYWNlKDEuMCAvIHlMZW4pOw0KICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICAgICAgdGhpcy5zZXQoeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCwgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgMCwgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCwgcG9zLngsIHBvcy55LCBwb3MueiwgMSk7DQogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpcy4NCiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6DQogICAgICAgICAqDQogICAgICAgICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpOw0KICAgICAgICAgKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTsNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyB0byByb3RhdGUgYXJvdW5kLg0KICAgICAgICAgKiBAcGFyYW0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFJvdGF0aW9uKGF4aXMsIHJhZCkgew0KICAgICAgICAgICAgY29uc3QgbGVuID0gYXhpcy5sZW5ndGgoKTsNCiAgICAgICAgICAgIGlmIChNYXRoLmFicyhsZW4pIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IHggPSBheGlzLnggLyBsZW47DQogICAgICAgICAgICBjb25zdCB5ID0gYXhpcy55IC8gbGVuOw0KICAgICAgICAgICAgY29uc3QgeiA9IGF4aXMueiAvIGxlbjsNCiAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyYWQpOw0KICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKHJhZCk7DQogICAgICAgICAgICBjb25zdCB0ID0gMSAtIGM7DQogICAgICAgICAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvbg0KICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYXNBcnJheSgpOw0KICAgICAgICAgICAgYVswXSA9IHggKiB4ICogdCArIGM7DQogICAgICAgICAgICBhWzFdID0geSAqIHggKiB0ICsgeiAqIHM7DQogICAgICAgICAgICBhWzJdID0geiAqIHggKiB0IC0geSAqIHM7DQogICAgICAgICAgICBhWzNdID0gMDsNCiAgICAgICAgICAgIGFbNF0gPSB4ICogeSAqIHQgLSB6ICogczsNCiAgICAgICAgICAgIGFbNV0gPSB5ICogeSAqIHQgKyBjOw0KICAgICAgICAgICAgYVs2XSA9IHogKiB5ICogdCArIHggKiBzOw0KICAgICAgICAgICAgYVs3XSA9IDA7DQogICAgICAgICAgICBhWzhdID0geCAqIHogKiB0ICsgeSAqIHM7DQogICAgICAgICAgICBhWzldID0geSAqIHogKiB0IC0geCAqIHM7DQogICAgICAgICAgICBhWzEwXSA9IHogKiB6ICogdCArIGM7DQogICAgICAgICAgICBhWzExXSA9IDA7DQogICAgICAgICAgICBhWzEyXSA9IDA7DQogICAgICAgICAgICBhWzEzXSA9IDA7DQogICAgICAgICAgICBhWzE0XSA9IDA7DQogICAgICAgICAgICBhWzE1XSA9IDE7DQogICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcy4NCiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6DQogICAgICAgICAqDQogICAgICAgICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpOw0KICAgICAgICAgKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7DQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByYWQgLSBUaGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnkuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0WFJvdGF0aW9uKHJhZCkgew0KICAgICAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKHJhZCk7DQogICAgICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MocmFkKTsNCiAgICAgICAgICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb24NCiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKTsNCiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgICAgIGFbMF0gPSAxOw0KICAgICAgICAgICAgYVsxXSA9IDA7DQogICAgICAgICAgICBhWzJdID0gMDsNCiAgICAgICAgICAgIGFbM10gPSAwOw0KICAgICAgICAgICAgYVs0XSA9IDA7DQogICAgICAgICAgICBhWzVdID0gYzsNCiAgICAgICAgICAgIGFbNl0gPSBzOw0KICAgICAgICAgICAgYVs3XSA9IDA7DQogICAgICAgICAgICBhWzhdID0gMDsNCiAgICAgICAgICAgIGFbOV0gPSAtczsNCiAgICAgICAgICAgIGFbMTBdID0gYzsNCiAgICAgICAgICAgIGFbMTFdID0gMDsNCiAgICAgICAgICAgIGFbMTJdID0gMDsNCiAgICAgICAgICAgIGFbMTNdID0gMDsNCiAgICAgICAgICAgIGFbMTRdID0gMDsNCiAgICAgICAgICAgIGFbMTVdID0gMTsNCiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICAgICAgcmV0dXJuIHRoaXM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMuDQogICAgICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOg0KICAgICAgICAgKg0KICAgICAgICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTsNCiAgICAgICAgICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpOw0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFlSb3RhdGlvbihyYWQpIHsNCiAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyYWQpOw0KICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKHJhZCk7DQogICAgICAgICAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uDQogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5hc0FycmF5KCk7DQogICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgICAgICAgICBhWzBdID0gYzsNCiAgICAgICAgICAgIGFbMV0gPSAwOw0KICAgICAgICAgICAgYVsyXSA9IC1zOw0KICAgICAgICAgICAgYVszXSA9IDA7DQogICAgICAgICAgICBhWzRdID0gMDsNCiAgICAgICAgICAgIGFbNV0gPSAxOw0KICAgICAgICAgICAgYVs2XSA9IDA7DQogICAgICAgICAgICBhWzddID0gMDsNCiAgICAgICAgICAgIGFbOF0gPSBzOw0KICAgICAgICAgICAgYVs5XSA9IDA7DQogICAgICAgICAgICBhWzEwXSA9IGM7DQogICAgICAgICAgICBhWzExXSA9IDA7DQogICAgICAgICAgICBhWzEyXSA9IDA7DQogICAgICAgICAgICBhWzEzXSA9IDA7DQogICAgICAgICAgICBhWzE0XSA9IDA7DQogICAgICAgICAgICBhWzE1XSA9IDE7DQogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzLg0KICAgICAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKToNCiAgICAgICAgICoNCiAgICAgICAgICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7DQogICAgICAgICAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTsNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRaUm90YXRpb24ocmFkKSB7DQogICAgICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTsNCiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyYWQpOw0KICAgICAgICAgICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvbg0KICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYXNBcnJheSgpOw0KICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICAgICAgYVswXSA9IGM7DQogICAgICAgICAgICBhWzFdID0gczsNCiAgICAgICAgICAgIGFbMl0gPSAwOw0KICAgICAgICAgICAgYVszXSA9IDA7DQogICAgICAgICAgICBhWzRdID0gLXM7DQogICAgICAgICAgICBhWzVdID0gYzsNCiAgICAgICAgICAgIGFbNl0gPSAwOw0KICAgICAgICAgICAgYVs3XSA9IDA7DQogICAgICAgICAgICBhWzhdID0gMDsNCiAgICAgICAgICAgIGFbOV0gPSAwOw0KICAgICAgICAgICAgYVsxMF0gPSAxOw0KICAgICAgICAgICAgYVsxMV0gPSAwOw0KICAgICAgICAgICAgYVsxMl0gPSAwOw0KICAgICAgICAgICAgYVsxM10gPSAwOw0KICAgICAgICAgICAgYVsxNF0gPSAwOw0KICAgICAgICAgICAgYVsxNV0gPSAxOw0KICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgVmVjNCB3aXRoIGEgTWF0NC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZlYyAtIFRoZSB2ZWMgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdHJhbnNmb3JtVmVjNCh2ZWMpIHsNCiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKTsNCiAgICAgICAgICAgIGNvbnN0IHggPSB2ZWMueDsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB2ZWMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB2ZWMuejsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB2ZWMudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNChhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXSAqIHcsIGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdICogdywgYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdICogdywgYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdICogdyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIFZlYzMgd2l0aCBhIE1hdDQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2ZWMgLSBUaGUgdmVjIHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIHRyYW5zZm9ybVZlYzModmVjKSB7DQogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5hc0FycmF5KCk7DQogICAgICAgICAgICBjb25zdCB4ID0gdmVjLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdmVjLnk7DQogICAgICAgICAgICBjb25zdCB6ID0gdmVjLno7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl0sIGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdLCBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF0pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSb3RhdGVzIGEgZ2l2ZW4gYFZlYzNgIGFuZCB0aGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGEgbmV3IGBWZWMzYCwgYXBwbHlpbmcgb25seSB0aGUgdG9wIGxlZnQgY29tcG9uZW50cyBvZiB0aGUgbWF0cml4LCBzbyBub3QgYXBwbHlpbmcgYW55IHRyYW5zbGF0aW9uLg0KICAgICAgICAgKiBAcGFyYW0gdmVjIC0gVGhlIHZlYyB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICByb3RhdGVWZWMzKHZlYykgew0KICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuYXNBcnJheSgpOw0KICAgICAgICAgICAgY29uc3QgeCA9IHZlYy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHZlYy55Ow0KICAgICAgICAgICAgY29uc3QgeiA9IHZlYy56Ow0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiwgYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6LCBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0IHRoZSBwZXJzcGVjdGl2ZSBmcm9tIGEgTWF0NC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGZvdlkgLSBUaGUgZm92WSB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGFzcGVjdCAtIFRoZSBhc3BlY3QgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIG5lYXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgZmFyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0UGVyc3BlY3RpdmVNYXRyaXgoZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHsNCiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLnRhbihNYXRoLlBJICogMC41IC0gMC41ICogZm92eSk7DQogICAgICAgICAgICBjb25zdCByYW5nZUludiA9IDEuMCAvIChuZWFyIC0gZmFyKTsNCiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgICAgIHRoaXMuc2V0KGYgLyBhc3BlY3QsIDAsIDAsIDAsIDAsIGYsIDAsIDAsIDAsIDAsIChuZWFyICsgZmFyKSAqIHJhbmdlSW52LCAtMSwgMCwgMCwgbmVhciAqIGZhciAqIHJhbmdlSW52ICogMiwgMCk7DQogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgb3J0aG9ncmFwaGljIG1hdHJpeCBhbmQgc2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3MNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGxlZnQgLSBUaGUgbGVmdCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHJpZ2h0IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIGJvdHRvbSB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHRvcCAtIFRoZSB0b3AgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIG5lYXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgZmFyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0T3J0aG9ncmFwaGljTWF0cml4KGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7DQogICAgICAgICAgICBjb25zdCBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTsNCiAgICAgICAgICAgIGNvbnN0IGJ0ID0gMSAvIChib3R0b20gLSB0b3ApOw0KICAgICAgICAgICAgY29uc3QgbmYgPSAxIC8gKG5lYXIgLSBmYXIpOw0KICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICAgICAgdGhpcy5zZXQoLTIgKiBsciwgMCwgMCwgMCwgMCwgLTIgKiBidCwgMCwgMCwgMCwgMCwgMiAqIG5mLCAwLCAobGVmdCArIHJpZ2h0KSAqIGxyLCAodG9wICsgYm90dG9tKSAqIGJ0LCAoZmFyICsgbmVhcikgKiBuZiwgMSk7DQogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0IHRoZSBNYXRyaXggdG8gYmUgYSBzY2FsZSBtYXRyaXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIHggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB5IC0gVGhlIHkgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB6IC0gVGhlIHogdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRTY2FsZSh4LCB5LCB6KSB7DQogICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFZlYzMpIHsNCiAgICAgICAgICAgICAgICB0aGlzLnNldCh4LngsIDAsIDAsIDAsIDAsIHgueSwgMCwgMCwgMCwgMCwgeC56LCAwLCAwLCAwLCAwLCAxKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRoaXMuc2V0KHgsIDAsIDAsIDAsIDAsIHksIDAsIDAsIDAsIDAsIHosIDAsIDAsIDAsIDAsIDEpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovDQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYW5zZm9ybXMgYSAzeDQgbWF0cml4IGludG8gYSA0eDQgbWF0cml4IGFuZCBzZXQgdGhlIHJlc3VsdCB0byB0aGUgTWF0aDQgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBtM3g0IC0gVGhlIG0zeDQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tTWF0M3g0QXJyYXkobTN4NCkgew0KICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICAgICAgdGhpcy5zZXQobTN4NFswXSwgbTN4NFsxXSwgbTN4NFsyXSwgMCwgbTN4NFszXSwgbTN4NFs0XSwgbTN4NFs1XSwgMCwgbTN4NFs2XSwgbTN4NFs3XSwgbTN4NFs4XSwgMCwgbTN4NFs5XSwgbTN4NFsxMF0sIG0zeDRbMTFdLCAxKTsNCiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDbG9uZXMgdGhpcyBNYXQ0IHJldHVybmluZyBhIG5ldyBpbnN0YW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQ0KHRoaXMubTAwLCB0aGlzLm0wMSwgdGhpcy5tMDIsIHRoaXMubTAzLCB0aGlzLm0xMCwgdGhpcy5tMTEsIHRoaXMubTEyLCB0aGlzLm0xMywgdGhpcy5tMjAsIHRoaXMubTIxLCB0aGlzLm0yMiwgdGhpcy5tMjMsIHRoaXMubTMwLCB0aGlzLm0zMSwgdGhpcy5tMzIsIHRoaXMubTMzKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNBcnJheSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oanNvbikgew0KICAgICAgICAgICAgdGhpcy5mcm9tQXJyYXkoanNvbik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICAgICAgICAgIHRoaXMuZnJvbUFycmF5KHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KDE2KSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY3VycmVudCBNYXRoIHR5cGUgZGF0YSBhcyBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBhc0FycmF5KCkgew0KICAgICAgICAgICAgcmV0dXJuIFsNCiAgICAgICAgICAgICAgICB0aGlzLm0wMCwNCiAgICAgICAgICAgICAgICB0aGlzLm0wMSwNCiAgICAgICAgICAgICAgICB0aGlzLm0wMiwNCiAgICAgICAgICAgICAgICB0aGlzLm0wMywNCiAgICAgICAgICAgICAgICB0aGlzLm0xMCwNCiAgICAgICAgICAgICAgICB0aGlzLm0xMSwNCiAgICAgICAgICAgICAgICB0aGlzLm0xMiwNCiAgICAgICAgICAgICAgICB0aGlzLm0xMywNCiAgICAgICAgICAgICAgICB0aGlzLm0yMCwNCiAgICAgICAgICAgICAgICB0aGlzLm0yMSwNCiAgICAgICAgICAgICAgICB0aGlzLm0yMiwNCiAgICAgICAgICAgICAgICB0aGlzLm0yMywNCiAgICAgICAgICAgICAgICB0aGlzLm0zMCwNCiAgICAgICAgICAgICAgICB0aGlzLm0zMSwNCiAgICAgICAgICAgICAgICB0aGlzLm0zMiwNCiAgICAgICAgICAgICAgICB0aGlzLm0zMywNCiAgICAgICAgICAgIF07DQogICAgICAgIH0NCiAgICAgICAgZnJvbUFycmF5KGFycmF5KSB7DQogICAgICAgICAgICB0aGlzLm0wMCA9IGFycmF5WzBdOw0KICAgICAgICAgICAgdGhpcy5tMDEgPSBhcnJheVsxXTsNCiAgICAgICAgICAgIHRoaXMubTAyID0gYXJyYXlbMl07DQogICAgICAgICAgICB0aGlzLm0wMyA9IGFycmF5WzNdOw0KICAgICAgICAgICAgdGhpcy5tMTAgPSBhcnJheVs0XTsNCiAgICAgICAgICAgIHRoaXMubTExID0gYXJyYXlbNV07DQogICAgICAgICAgICB0aGlzLm0xMiA9IGFycmF5WzZdOw0KICAgICAgICAgICAgdGhpcy5tMTMgPSBhcnJheVs3XTsNCiAgICAgICAgICAgIHRoaXMubTIwID0gYXJyYXlbOF07DQogICAgICAgICAgICB0aGlzLm0yMSA9IGFycmF5WzldOw0KICAgICAgICAgICAgdGhpcy5tMjIgPSBhcnJheVsxMF07DQogICAgICAgICAgICB0aGlzLm0yMyA9IGFycmF5WzExXTsNCiAgICAgICAgICAgIHRoaXMubTMwID0gYXJyYXlbMTJdOw0KICAgICAgICAgICAgdGhpcy5tMzEgPSBhcnJheVsxM107DQogICAgICAgICAgICB0aGlzLm0zMiA9IGFycmF5WzE0XTsNCiAgICAgICAgICAgIHRoaXMubTMzID0gYXJyYXlbMTVdOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovDQogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcXVhdGVybmlvbi4gUXVhdGVybmlvbnMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IDMgZGltZW5zaW9uYWwgcm90YXRpb25zLg0KICAgICAqDQogICAgICogV2hpbGUgUXVhdGVybmlvbnMgYXJlIGRpZmZpY3VsdCB0byB1bmRlcnN0YW5kIHRoZXkgaGF2ZSBpbXBvcnRhbnQgbWF0aGVtYXRpY2FsIHByb3BlcnRpZXMgdGhhdCBtYWtlIHRoZW0gdmVyeSB1c2VmdWwgaW4gM2QgZW5naW5lcy4NCiAgICAgKiBUaGV5IGNhbiBiZSBkaXJlY3RseSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGluIHRoZSBzYW1lIHdhcyBhcyBtYXRyaWNlcy4NCiAgICAgKiBUaGV5IGNhbiBiZSBpbnRlcnBvbGF0ZWQgZnJvbSBvbmUgdmFsdWUgdG8gYW5vdGhlciB3aGlsZSBtYWludGFpbmluZyBjb25zdGFudCBhbmd1bGFyIHZlbG9jaXR5Lg0KICAgICAqIFRoZXkgY2FuIGJlIGNvbnZlcnRlZCB0byBvdGhlciBtb3JlIGVhc2lseSB1bmRlcnN0b29kIHJlcHJlc2VudGF0aW9ucyBzdWNoIGFzIEV1bGVyQW5nbGVzIG9yIE1hdHJpY2VzLg0KICAgICAqDQoNCiAgICAgKi8NCiAgICBjbGFzcyBRdWF0IHsNCiAgICAgICAgeDsNCiAgICAgICAgeTsNCiAgICAgICAgejsNCiAgICAgICAgdzsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEpIHsNCiAgICAgICAgICAgIHRoaXMueCA9IHg7DQogICAgICAgICAgICB0aGlzLnkgPSB5Ow0KICAgICAgICAgICAgdGhpcy56ID0gejsNCiAgICAgICAgICAgIHRoaXMudyA9IHc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0geCAtIFRoZSB4IGF4aXMgcm90YXRpb24uDQogICAgICAgICAqIEBwYXJhbSB5ICAtIFRoZSB5IGF4aXMgcm90YXRpb24uDQogICAgICAgICAqIEBwYXJhbSB6ICAtIFRoZSB6IGF4aXMgcm90YXRpb24uDQogICAgICAgICAqIEBwYXJhbSB3ICAtIFRoZSB3IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0KHgsIHksIHosIHcpIHsNCiAgICAgICAgICAgIHRoaXMueCA9IHg7DQogICAgICAgICAgICB0aGlzLnkgPSB5Ow0KICAgICAgICAgICAgdGhpcy56ID0gejsNCiAgICAgICAgICAgIHRoaXMudyA9IHc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHRlciBmcm9tIGFub3RoZXIgdmVjdG9yLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgdmVjdG9yIHRvIHNldCBmcm9tLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU90aGVyKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggPSBvdGhlci54Ow0KICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTsNCiAgICAgICAgICAgIHRoaXMueiA9IG90aGVyLno7DQogICAgICAgICAgICB0aGlzLncgPSBvdGhlci53Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXQgdGhpcyBRdWF0IGZyb20gYSBldWxlciByb3RhdGlvbi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGV1bGVyQW5nbGVzIC0gVGhlIGV1bGVyIGFuZ2xlcyByb3RhdGlvbi4NCiAgICAgICAgICovDQogICAgICAgIHNldEZyb21FdWxlckFuZ2xlcyhldWxlckFuZ2xlcykgew0KICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG5ldyBWZWMzKCk7DQogICAgICAgICAgICBzd2l0Y2ggKGV1bGVyQW5nbGVzLm9yZGVyKSB7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5YWVo6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLngsIC1ldWxlckFuZ2xlcy55LCBldWxlckFuZ2xlcy56KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5ZWlg6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLnksIC1ldWxlckFuZ2xlcy56LCBldWxlckFuZ2xlcy54KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5aWFk6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLnosIC1ldWxlckFuZ2xlcy54LCBldWxlckFuZ2xlcy55KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5YWlk6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLngsIGV1bGVyQW5nbGVzLnosIGV1bGVyQW5nbGVzLnkpOw0KICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICBjYXNlIEV1bGVyQW5nbGVzQXhpc09yZGVyLlpZWDoNCiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5zZXQoZXVsZXJBbmdsZXMueiwgZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueCk7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgRXVsZXJBbmdsZXNBeGlzT3JkZXIuWVhaOg0KICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy55LCBldWxlckFuZ2xlcy54LCBldWxlckFuZ2xlcy56KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgZGVmYXVsdDoNCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEV1bGVyQW5nbGVzIG9yZGVyOiAke2V1bGVyQW5nbGVzLm9yZGVyfWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgdGkgPSBvcmRlcmVkLnggKiAwLjU7DQogICAgICAgICAgICBjb25zdCB0aiA9IG9yZGVyZWQueSAqIDAuNTsNCiAgICAgICAgICAgIGNvbnN0IHRrID0gb3JkZXJlZC56ICogMC41Ow0KICAgICAgICAgICAgY29uc3QgY2kgPSBNYXRoLmNvcyh0aSk7DQogICAgICAgICAgICBjb25zdCBjaiA9IE1hdGguY29zKHRqKTsNCiAgICAgICAgICAgIGNvbnN0IGNrID0gTWF0aC5jb3ModGspOw0KICAgICAgICAgICAgY29uc3Qgc2kgPSBNYXRoLnNpbih0aSk7DQogICAgICAgICAgICBjb25zdCBzaiA9IE1hdGguc2luKHRqKTsNCiAgICAgICAgICAgIGNvbnN0IHNrID0gTWF0aC5zaW4odGspOw0KICAgICAgICAgICAgY29uc3QgY2MgPSBjaSAqIGNrOw0KICAgICAgICAgICAgY29uc3QgY3MgPSBjaSAqIHNrOw0KICAgICAgICAgICAgY29uc3Qgc2MgPSBzaSAqIGNrOw0KICAgICAgICAgICAgY29uc3Qgc3MgPSBzaSAqIHNrOw0KICAgICAgICAgICAgY29uc3QgYWkgPSBjaiAqIHNjIC0gc2ogKiBjczsNCiAgICAgICAgICAgIGNvbnN0IGFqID0gY2ogKiBzcyArIHNqICogY2M7DQogICAgICAgICAgICBjb25zdCBhayA9IGNqICogY3MgLSBzaiAqIHNjOw0KICAgICAgICAgICAgdGhpcy53ID0gY2ogKiBjYyArIHNqICogc3M7DQogICAgICAgICAgICBzd2l0Y2ggKGV1bGVyQW5nbGVzLm9yZGVyKSB7DQogICAgICAgICAgICAgICAgY2FzZSAwOg0KICAgICAgICAgICAgICAgICAgICAvLyAnIFhZWicNCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IC1hajsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYWs7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgMToNCiAgICAgICAgICAgICAgICAgICAgLy8gJ1laWCcNCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWs7DQogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGFpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSAtYWo7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgMjoNCiAgICAgICAgICAgICAgICAgICAgLy8gJ1pYWScNCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gLWFqOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBhazsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYWk7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgMzoNCiAgICAgICAgICAgICAgICAgICAgLy8gJ1haWScNCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGFrOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSBhajsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSA0Og0KICAgICAgICAgICAgICAgICAgICAvLyAnWllYJw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBhazsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYWo7DQogICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGFpOw0KICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICBjYXNlIDU6DQogICAgICAgICAgICAgICAgICAgIC8vICdZWFonDQogICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IGFqOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBhaTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYWs7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGRlZmF1bHQ6DQogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFdWxlckFuZ2xlcyBvcmRlcjogJHtldWxlckFuZ2xlcy5vcmRlcn1gKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgUXVhdCB0byBhbiBFdWxlckFuZ2xlcw0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcm90YXRpb25PcmRlciAtIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvRXVsZXJBbmdsZXMocm90YXRpb25PcmRlcikgew0KICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG5ldyBWZWMzKCk7DQogICAgICAgICAgICBzd2l0Y2ggKHJvdGF0aW9uT3JkZXIpIHsNCiAgICAgICAgICAgICAgICBjYXNlIEV1bGVyQW5nbGVzQXhpc09yZGVyLlhZWjoNCiAgICAgICAgICAgICAgICBjYXNlICdYWVonOg0KICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldCh0aGlzLnosIHRoaXMueCwgdGhpcy55KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5ZWlg6DQogICAgICAgICAgICAgICAgY2FzZSAnWVpYJzoNCiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueik7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgRXVsZXJBbmdsZXNBeGlzT3JkZXIuWlhZOg0KICAgICAgICAgICAgICAgIGNhc2UgJ1pYWSc6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueSwgdGhpcy56LCB0aGlzLngpOw0KICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICBjYXNlIEV1bGVyQW5nbGVzQXhpc09yZGVyLlhaWToNCiAgICAgICAgICAgICAgICBjYXNlICdYWlknOg0KICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldCh0aGlzLnksIC10aGlzLngsIHRoaXMueik7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgRXVsZXJBbmdsZXNBeGlzT3JkZXIuWllYOg0KICAgICAgICAgICAgICAgIGNhc2UgJ1pZWCc6DQogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueCwgLXRoaXMueiwgdGhpcy55KTsNCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5ZWFo6DQogICAgICAgICAgICAgICAgY2FzZSAnWVhaJzoNCiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5zZXQodGhpcy56LCAtdGhpcy55LCB0aGlzLngpOw0KICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm90YXRpb24gb3JkZXI6JyArIHJvdGF0aW9uT3JkZXIpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgZXVsZXIgPSBuZXcgVmVjMygpOw0KICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9yZGVyZWQueCAqIG9yZGVyZWQueSArIG9yZGVyZWQueiAqIHRoaXMudzsNCiAgICAgICAgICAgIGlmICh0ZXN0ID4gMC40OTk5OSkgew0KICAgICAgICAgICAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IG5vcnRoIHBvbGUNCiAgICAgICAgICAgICAgICBldWxlci55ID0gMi4wICogTWF0aC5hdGFuMihvcmRlcmVkLngsIHRoaXMudyk7DQogICAgICAgICAgICAgICAgZXVsZXIueiA9IE1hdGguUEkgKiAwLjU7DQogICAgICAgICAgICAgICAgZXVsZXIueCA9IDAuMDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKHRlc3QgPCAtMC40OTk5OSkgew0KICAgICAgICAgICAgICAgIC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGUNCiAgICAgICAgICAgICAgICBldWxlci55ID0gLTIuMCAqIE1hdGguYXRhbjIob3JkZXJlZC54LCB0aGlzLncpOw0KICAgICAgICAgICAgICAgIGV1bGVyLnogPSBNYXRoLlBJICogLTAuNTsNCiAgICAgICAgICAgICAgICBldWxlci54ID0gMC4wOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgY29uc3Qgc3F4ID0gb3JkZXJlZC54ICogb3JkZXJlZC54Ow0KICAgICAgICAgICAgICAgIGNvbnN0IHNxeSA9IG9yZGVyZWQueSAqIG9yZGVyZWQueTsNCiAgICAgICAgICAgICAgICBjb25zdCBzcXogPSBvcmRlcmVkLnogKiBvcmRlcmVkLno7DQogICAgICAgICAgICAgICAgZXVsZXIueSA9IE1hdGguYXRhbjIoMi4wICogb3JkZXJlZC55ICogdGhpcy53IC0gMi4wICogb3JkZXJlZC54ICogb3JkZXJlZC56LCAxLjAgLSAyLjAgKiBzcXkgLSAyLjAgKiBzcXopOw0KICAgICAgICAgICAgICAgIGV1bGVyLnogPSBNYXRoLmFzaW4oMi4wICogdGVzdCk7DQogICAgICAgICAgICAgICAgZXVsZXIueCA9IE1hdGguYXRhbjIoMi4wICogb3JkZXJlZC54ICogdGhpcy53IC0gMi4wICogb3JkZXJlZC55ICogb3JkZXJlZC56LCAxLjAgLSAyLjAgKiBzcXggLSAyLjAgKiBzcXopOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3dpdGNoIChyb3RhdGlvbk9yZGVyKSB7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5YWVo6DQogICAgICAgICAgICAgICAgY2FzZSAnWFlaJzoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci55LCBldWxlci56LCBldWxlci54LCByb3RhdGlvbk9yZGVyKTsNCiAgICAgICAgICAgICAgICBjYXNlIEV1bGVyQW5nbGVzQXhpc09yZGVyLllaWDoNCiAgICAgICAgICAgICAgICBjYXNlICdZWlgnOg0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLngsIGV1bGVyLnksIGV1bGVyLnosIHJvdGF0aW9uT3JkZXIpOw0KICAgICAgICAgICAgICAgIGNhc2UgRXVsZXJBbmdsZXNBeGlzT3JkZXIuWlhZOg0KICAgICAgICAgICAgICAgIGNhc2UgJ1pYWSc6DQogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXVsZXJBbmdsZXMoZXVsZXIueiwgZXVsZXIueCwgZXVsZXIueSwgcm90YXRpb25PcmRlcik7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5YWlk6DQogICAgICAgICAgICAgICAgY2FzZSAnWFpZJzoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcygtZXVsZXIueSwgZXVsZXIueCwgZXVsZXIueiwgcm90YXRpb25PcmRlcik7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5aWVg6DQogICAgICAgICAgICAgICAgY2FzZSAnWllYJzoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci54LCBldWxlci56LCAtZXVsZXIueSwgcm90YXRpb25PcmRlcik7DQogICAgICAgICAgICAgICAgY2FzZSBFdWxlckFuZ2xlc0F4aXNPcmRlci5ZWFo6DQogICAgICAgICAgICAgICAgY2FzZSAnWVhaJzoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci56LCAtZXVsZXIueSwgZXVsZXIueCwgcm90YXRpb25PcmRlcik7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldCB0aGlzIFF1YXQgdG8gYSByb3RhdGlvbiBkZWZpbmVkIGJ5IGFuIGF4aXMgYW5kIGFuIGFuZ2xlIChpbiByYWRpYW5zKS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlLg0KICAgICAgICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgdG8gcm90YXRlDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tQXhpc0FuZEFuZ2xlKGF4aXMsIGFuZ2xlKSB7DQogICAgICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIuMDsNCiAgICAgICAgICAgIGNvbnN0IHZlYyA9IGF4aXMubm9ybWFsaXplKCkuc2NhbGUoTWF0aC5zaW4oaGFsZkFuZ2xlKSk7DQogICAgICAgICAgICB0aGlzLnNldCh2ZWMueCwgdmVjLnksIHZlYy56LCBNYXRoLmNvcyhoYWxmQW5nbGUpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIFF1YXQgdG8gbG9vayBpbiBhIHBhcnRpY3VsYXIgZGlyZWN0aW9uIGFsb25nIHRoZSB6IGF4aXMuDQogICAgICAgICAqID4gVGhlIGNhbWVyYSBsb29rcyBkb3duIHRoZSBuZWdhdGl2ZSB6IGF4aXMsIHNvIHRvIHNldCBhIHJvdGF0aW9uIHZhbHVlDQogICAgICAgICAqID4gZm9yIHRoZSBjYW1lcmEsIHJlbWVtYmVyIHRvIG5lZ2F0ZSB0aGUgZGlyZWN0aW9uIHZlY3Rvci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGRpciAtIFRoZSBkaXJlY3Rpb24gdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB1cCAtIFRoZSB1cCB2ZWN0b3IuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IoZGlyLCB1cCkgew0KICAgICAgICAgICAgY29uc3QgbWF0MyA9IG5ldyBNYXQzKCk7DQogICAgICAgICAgICBtYXQzLnNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3RvcihkaXIsIHVwKTsNCiAgICAgICAgICAgIHRoaXMuc2V0RnJvbU1hdDMobWF0Myk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgUXVhdGAgZnJvbSB0d28gYFZlYzNgLiBUaGUgcXVhdGVybmlvbiB3b3VsZCB0aGVuIHJlcHJlc2VudCB0aGUgcm90YXRpb24gZnJvbSB2MCB0byB2MSBpbiAzZCBzcGFjZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHYwIC0gVGhlIHYwIHVuaXQgdmVjdG9yLg0KICAgICAgICAgKiBAcGFyYW0gdjEgLSBUaGUgdjEgdW5pdCB2ZWN0b3IuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tMlZlY3RvcnModjAsIHYxKSB7DQogICAgICAgICAgICBjb25zdCBjID0gdjAuY3Jvc3ModjEpOw0KICAgICAgICAgICAgY29uc3QgZCA9IHYwLmRvdCh2MSk7DQogICAgICAgICAgICBjb25zdCBzID0gTWF0aC5zcXJ0KCgxICsgZCkgKiAyKTsNCiAgICAgICAgICAgIC8vIHRoaXMuc2V0KCBzLzIsIGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMgKTsNCiAgICAgICAgICAgIHRoaXMuc2V0KGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMsIHMgLyAyKTsNCiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplSW5QbGFjZSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXQgdGhlIFF1YXQgZnJvbSBhIE1hdDMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBtYXQzIC0gVGhlIG1hdDMgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tTWF0MyhtYXQzKSB7DQogICAgICAgICAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlcw0KICAgICAgICAgICAgLy8gYXJ0aWNsZSAiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb24iLg0KICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1hdDMuYXNBcnJheSgpOw0KICAgICAgICAgICAgY29uc3QgZlRyYWNlID0gZGF0YVswXSArIGRhdGFbNF0gKyBkYXRhWzhdOw0KICAgICAgICAgICAgbGV0IGZSb290Ow0KICAgICAgICAgICAgaWYgKGZUcmFjZSA+IDAuMCkgew0KICAgICAgICAgICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzINCiAgICAgICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxKTsgLy8gMncNCiAgICAgICAgICAgICAgICB0aGlzLncgPSAwLjUgKiBmUm9vdDsNCiAgICAgICAgICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dykNCiAgICAgICAgICAgICAgICB0aGlzLnggPSAoZGF0YVs1XSAtIGRhdGFbN10pICogZlJvb3Q7DQogICAgICAgICAgICAgICAgdGhpcy55ID0gKGRhdGFbNl0gLSBkYXRhWzJdKSAqIGZSb290Ow0KICAgICAgICAgICAgICAgIHRoaXMueiA9IChkYXRhWzFdIC0gZGF0YVszXSkgKiBmUm9vdDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIC8vIHx3fCA8PSAxLzINCiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7DQogICAgICAgICAgICAgICAgaWYgKGRhdGFbNF0gPiBkYXRhWzBdKQ0KICAgICAgICAgICAgICAgICAgICBpID0gMTsNCiAgICAgICAgICAgICAgICBpZiAoZGF0YVs4XSA+IGRhdGFbaSAqIDMgKyBpXSkNCiAgICAgICAgICAgICAgICAgICAgaSA9IDI7DQogICAgICAgICAgICAgICAgY29uc3QgaiA9IChpICsgMSkgJSAzOw0KICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAoaSArIDIpICUgMzsNCiAgICAgICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChkYXRhW2kgKiAzICsgaV0gLSBkYXRhW2ogKiAzICsgal0gLSBkYXRhW2sgKiAzICsga10gKyAxLjApOw0KICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gWzAsIDAsIDAsIDBdOw0KICAgICAgICAgICAgICAgIGFycmF5W2ldID0gMC41ICogZlJvb3Q7DQogICAgICAgICAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsNCiAgICAgICAgICAgICAgICBhcnJheVszXSA9IChkYXRhW2ogKiAzICsga10gLSBkYXRhW2sgKiAzICsgal0pICogZlJvb3Q7DQogICAgICAgICAgICAgICAgYXJyYXlbal0gPSAoZGF0YVtqICogMyArIGldICsgZGF0YVtpICogMyArIGpdKSAqIGZSb290Ow0KICAgICAgICAgICAgICAgIGFycmF5W2tdID0gKGRhdGFbayAqIDMgKyBpXSArIGRhdGFbaSAqIDMgKyBrXSkgKiBmUm9vdDsNCiAgICAgICAgICAgICAgICB0aGlzLmZyb21BcnJheShhcnJheSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0IHRoZSBRdWF0IGZyb20gYSBNYXQ0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU1hdDQobWF0NCkgew0KICAgICAgICAgICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXMNCiAgICAgICAgICAgIC8vIGFydGljbGUgIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uIi4NCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtYXQ0LmFzQXJyYXkoKTsNCiAgICAgICAgICAgIGNvbnN0IGZUcmFjZSA9IGRhdGFbMF0gKyBkYXRhWzVdICsgZGF0YVsxMF07DQogICAgICAgICAgICBsZXQgZlJvb3Q7DQogICAgICAgICAgICBpZiAoZlRyYWNlID4gMC4wKSB7DQogICAgICAgICAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMg0KICAgICAgICAgICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEpOyAvLyAydw0KICAgICAgICAgICAgICAgIHRoaXMudyA9IDAuNSAqIGZSb290Ow0KICAgICAgICAgICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7IC8vIDEvKDR3KQ0KICAgICAgICAgICAgICAgIHRoaXMueCA9IChkYXRhWzZdIC0gZGF0YVs5XSkgKiBmUm9vdDsNCiAgICAgICAgICAgICAgICB0aGlzLnkgPSAoZGF0YVs4XSAtIGRhdGFbMl0pICogZlJvb3Q7DQogICAgICAgICAgICAgICAgdGhpcy56ID0gKGRhdGFbMV0gLSBkYXRhWzRdKSAqIGZSb290Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgLy8gfHd8IDw9IDEvMg0KICAgICAgICAgICAgICAgIGxldCBpID0gMDsNCiAgICAgICAgICAgICAgICBpZiAoZGF0YVs1XSA+IGRhdGFbMF0pDQogICAgICAgICAgICAgICAgICAgIGkgPSAxOw0KICAgICAgICAgICAgICAgIGlmIChkYXRhWzEwXSA+IGRhdGFbaSAqIDQgKyBpXSkNCiAgICAgICAgICAgICAgICAgICAgaSA9IDI7DQogICAgICAgICAgICAgICAgY29uc3QgaiA9IChpICsgMSkgJSAzOw0KICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAoaSArIDIpICUgMzsNCiAgICAgICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChkYXRhW2kgKiA0ICsgaV0gLSBkYXRhW2ogKiA0ICsgal0gLSBkYXRhW2sgKiA0ICsga10gKyAxLjApOw0KICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gWzAsIDAsIDAsIDBdOw0KICAgICAgICAgICAgICAgIGFycmF5W2ldID0gMC41ICogZlJvb3Q7DQogICAgICAgICAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsNCiAgICAgICAgICAgICAgICBhcnJheVszXSA9IChkYXRhW2ogKiA0ICsga10gLSBkYXRhW2sgKiA0ICsgal0pICogZlJvb3Q7DQogICAgICAgICAgICAgICAgYXJyYXlbal0gPSAoZGF0YVtqICogNCArIGldICsgZGF0YVtpICogNCArIGpdKSAqIGZSb290Ow0KICAgICAgICAgICAgICAgIGFycmF5W2tdID0gKGRhdGFbayAqIDQgKyBpXSArIGRhdGFbaSAqIDQgKyBrXSkgKiBmUm9vdDsNCiAgICAgICAgICAgICAgICB0aGlzLmZyb21BcnJheShhcnJheSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBhbmdsZSBvZiB0aGUgUXVhdCBpcyBsZXNzIHRoYXQgYCBOdW1iZXIuRVBTSUxPTmANCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICAgICAgICovDQogICAgICAgIGlzSWRlbnRpdHkoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZSgpIDwgTnVtYmVyLkVQU0lMT047DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybiB0aGUgYW5nbGUgb2YgdGhlIFF1YXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0QW5nbGUoKSB7DQogICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKHRoaXMudykgKiAyLjA7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFF1YXQgY29udGFpbnMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvdGhlciBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjb21wYXJlIHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGB0cnVlYCBpZiBhcmUgdGhlIHNhbWUgVmVjdG9yLCBvdGhlcndpc2UsIGBmYWxzZWAuDQogICAgICAgICAqLw0KICAgICAgICBpc0VxdWFsKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnogJiYgdGhpcy53ID09IG90aGVyLnc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFF1YXQgaXMgTk9UIGV4YWN0bHkgdGhlIHNhbWUgb3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBvciBmYWxzZS4NCiAgICAgICAgICovDQogICAgICAgIG5vdEVxdWFscyhvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55ICYmIHRoaXMueiAhPSBvdGhlci56ICYmIHRoaXMudyAhPSBvdGhlci53Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBRdWF0IGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXINCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcGFyYW0gcHJlY2lzaW9uIC0gVGhlIHByZWNpc2lvbiB0byB3aGljaCB0aGUgdmFsdWVzIG11c3QgbWF0Y2guDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAgICAgICAqLw0KICAgICAgICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiYNCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvbiAmJg0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueiAtIG90aGVyLnopIDwgcHJlY2lzaW9uICYmDQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy53IC0gb3RoZXIudykgPCBwcmVjaXNpb24pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgUXVhdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gYWRkLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkKG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSwgdGhpcy56ICsgb3RoZXIueiwgdGhpcy53ICsgb3RoZXIudyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBhZGQuDQogICAgICAgICAqLw0KICAgICAgICBhZGRJblBsYWNlKG90aGVyKSB7DQogICAgICAgICAgICB0aGlzLnggKz0gb3RoZXIueDsNCiAgICAgICAgICAgIHRoaXMueSArPSBvdGhlci55Ow0KICAgICAgICAgICAgdGhpcy56ICs9IG90aGVyLno7DQogICAgICAgICAgICB0aGlzLncgKz0gb3RoZXIudzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBRdWF0IGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gc3VidHJhY3QuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAgICAgICAqLw0KICAgICAgICBzdWJ0cmFjdChvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCAtIG90aGVyLngsIHRoaXMueSAtIG90aGVyLnksIHRoaXMueiAtIG90aGVyLnosIHRoaXMudyAtIG90aGVyLncpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTY2FsZXMgdGhpcyBRdWF0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgc2NhbGUoc2NhbGFyKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIsIHRoaXMueiAqIHNjYWxhciwgdGhpcy53ICogc2NhbGFyKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2NhbGVzIHRoaXMgUXVhdCBieSBzY2FsYXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgew0KICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjsNCiAgICAgICAgICAgIHRoaXMueSAqPSBzY2FsYXI7DQogICAgICAgICAgICB0aGlzLnogKj0gc2NhbGFyOw0KICAgICAgICAgICAgdGhpcy53ICo9IHNjYWxhcjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgUXVhdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4NCiAgICAgICAgICovDQogICAgICAgIGxlbmd0aCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuejsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLnc7DQogICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbGVuZ3RoLg0KICAgICAgICAgKi8NCiAgICAgICAgbGVuZ3RoU3F1YXJlZCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuejsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLnc7DQogICAgICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlIFF1YXQgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgUXVhdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIFF1YXQgbm9ybWFsaXplZC4NCiAgICAgICAgICovDQogICAgICAgIG5vcm1hbGl6ZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuejsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLnc7DQogICAgICAgICAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7DQogICAgICAgICAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlPw0KICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHggKiBsZW4sIHkgKiBsZW4sIHogKiBsZW4sIHcgKiBsZW4pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0LCBtb2RpZnlpbmcgaXRzIHZhbHVlcyBpbiBwbGFjZS4NCiAgICAgICAgICovDQogICAgICAgIG5vcm1hbGl6ZUluUGxhY2UoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgICAgICAgICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3Ow0KICAgICAgICAgICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOw0KICAgICAgICAgICAgdGhpcy5zZXQoeCAqIGxlbiwgeSAqIGxlbiwgeiAqIGxlbiwgdyAqIGxlbik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgcXVhdCBhZ2FpbnN0IGFub3RoZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgZG90KG90aGVyKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnkgKyB0aGlzLnogKiBvdGhlci56ICsgdGhpcy53ICogb3RoZXIudzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gUXVhdHMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjYWxjdWxhdGUgd2l0aC4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3QgYXMgYSBuZXcgUXVhdC4NCiAgICAgICAgICovDQogICAgICAgIGNyb3NzKG90aGVyKSB7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdCA9IHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IGJ4ID0gb3RoZXIueDsNCiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsNCiAgICAgICAgICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsNCiAgICAgICAgICAgIGNvbnN0IGJ0ID0gb3RoZXIudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdChheSAqIGJ6IC0gYXogKiBieSwgYXogKiBidCAtIGF0ICogYnosIGF0ICogYnggLSBheCAqIGJ0LCBheCAqIGJ5IC0gYXkgKiBieCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHJvdGF0aW9uYWwgY29uanVnYXRlIG9mIHRoaXMgUXVhdC4NCiAgICAgICAgICogQ29uanVnYXRpb24gcmVwcmVzZW50cyB0aGUgc2FtZSByb3RhdGlvbiBvZiB0aGUgUXVhdCBidXQNCiAgICAgICAgICogaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBhcm91bmQgdGhlIHJvdGF0aW9uYWwgYXhpcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIHRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb25qdWdhdGUoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQoLXRoaXMueCwgLXRoaXMueSwgLXRoaXMueiwgdGhpcy53KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJuIHRoZSBpbnZlcnNlIG9mIHRoZSBgUXVhdGANCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICAgICAgICovDQogICAgICAgIGludmVyc2UoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5jb25qdWdhdGUoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWxpZ25zIHRoaXMgcXVhdGVybmlvbiB3aXRoIGFub3RoZXIgb25lIGVuc3VyaW5nIHRoYXQgdGhlIGRlbHRhIGJldHdlZW4NCiAgICAgICAgICogdGhlIFF1YXQgdmFsdWVzIGlzIHRoZSBzaG9ydGVzdCBwYXRoIG92ZXIgdGhlIGh5cGVyLXNwaGVyZS4NCiAgICAgICAgICoNCiAgICAgICAgICogIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGRpdmlkZSBieS4NCiAgICAgICAgICovDQogICAgICAgIGFsaWduV2l0aChvdGhlcikgew0KICAgICAgICAgICAgaWYgKHRoaXMuZG90KG90aGVyKSA8IDAuMCkgew0KICAgICAgICAgICAgICAgIHRoaXMuc2V0KC10aGlzLngsIC10aGlzLnksIC10aGlzLnosIC10aGlzLncpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byB0aGlzIHF1YXQgYnkgYW5vdGhlciByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBtdWx0aXBseS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICAgICAgICovDQogICAgICAgIG11bHRpcGx5KG90aGVyKSB7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdyA9IHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IGJ4ID0gb3RoZXIueDsNCiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsNCiAgICAgICAgICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsNCiAgICAgICAgICAgIGNvbnN0IGJ3ID0gb3RoZXIudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LCBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LCBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LCBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTXVsdGlwbGllcyB0aGlzIHF1YXQgYnkgYW5vdGhlciwgbW9kaWZ5aW5nIGl0cyB2YWx1ZXMgaW4gcGxhY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIG11bHRpcGx5Lg0KICAgICAgICAgKi8NCiAgICAgICAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdyA9IHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IGJ4ID0gb3RoZXIueDsNCiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsNCiAgICAgICAgICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsNCiAgICAgICAgICAgIGNvbnN0IGJ3ID0gb3RoZXIudzsNCiAgICAgICAgICAgIHRoaXMuc2V0KGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksIGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosIGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsIGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IHRoaXMgcXVhdGVybmlvbi4NCiAgICAgICAgICogRG9uJ3QgZm9yZ2V0IHRvIG5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB1bmxlc3MNCiAgICAgICAgICogeW91IHdhbnQgYXhpYWwgdHJhbnNsYXRpb24gYXMgd2VsbCBhcyByb3RhdGlvbi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIHJvdGF0ZVZlYzModmVjMykgew0KICAgICAgICAgICAgY29uc3QgdnEgPSBuZXcgUXVhdCh2ZWMzLngsIHZlYzMueSwgdmVjMy56LCAwLjApOw0KICAgICAgICAgICAgY29uc3QgcHEgPSB0aGlzLm11bHRpcGx5KHZxKS5tdWx0aXBseSh0aGlzLmNvbmp1Z2F0ZSgpKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyhwcS54LCBwcS55LCBwcS56KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYSByb3RhdGlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJhZCAtIEFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGUuDQogICAgICAgICAqLw0KICAgICAgICByb3RhdGVYKHJhZCkgew0KICAgICAgICAgICAgcmFkICo9IDAuNTsNCiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7DQogICAgICAgICAgICBjb25zdCBheiA9IHRoaXMuejsNCiAgICAgICAgICAgIGNvbnN0IGF3ID0gdGhpcy53Ow0KICAgICAgICAgICAgY29uc3QgYnggPSBNYXRoLnNpbihyYWQpOw0KICAgICAgICAgICAgY29uc3QgYncgPSBNYXRoLmNvcyhyYWQpOw0KICAgICAgICAgICAgdGhpcy54ID0gYXggKiBidyArIGF3ICogYng7DQogICAgICAgICAgICB0aGlzLnkgPSBheSAqIGJ3ICsgYXogKiBieDsNCiAgICAgICAgICAgIHRoaXMueiA9IGF6ICogYncgLSBheSAqIGJ4Ow0KICAgICAgICAgICAgdGhpcy53ID0gYXcgKiBidyAtIGF4ICogYng7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIHRvIGEgcm90YXRpb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByYWQgLSBBbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLg0KICAgICAgICAgKi8NCiAgICAgICAgcm90YXRlWShyYWQpIHsNCiAgICAgICAgICAgIHJhZCAqPSAwLjU7DQogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsNCiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCBhdyA9IHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IGJ5ID0gTWF0aC5zaW4ocmFkKTsNCiAgICAgICAgICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MocmFkKTsNCiAgICAgICAgICAgIHRoaXMueCA9IGF4ICogYncgLSBheiAqIGJ5Ow0KICAgICAgICAgICAgdGhpcy55ID0gYXkgKiBidyArIGF3ICogYnk7DQogICAgICAgICAgICB0aGlzLnogPSBheiAqIGJ3ICsgYXggKiBieTsNCiAgICAgICAgICAgIHRoaXMudyA9IGF3ICogYncgLSBheSAqIGJ5Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiB0byBhIHJvdGF0aW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmFkIC0gQW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZS4NCiAgICAgICAgICovDQogICAgICAgIHJvdGF0ZVoocmFkKSB7DQogICAgICAgICAgICByYWQgKj0gMC41Ow0KICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCBheSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IGF6ID0gdGhpcy56Ow0KICAgICAgICAgICAgY29uc3QgYXcgPSB0aGlzLnc7DQogICAgICAgICAgICBjb25zdCBieiA9IE1hdGguc2luKHJhZCk7DQogICAgICAgICAgICBjb25zdCBidyA9IE1hdGguY29zKHJhZCk7DQogICAgICAgICAgICB0aGlzLnggPSBheCAqIGJ3ICsgYXkgKiBiejsNCiAgICAgICAgICAgIHRoaXMueSA9IGF5ICogYncgLSBheCAqIGJ6Ow0KICAgICAgICAgICAgdGhpcy56ID0gYXogKiBidyArIGF3ICogYno7DQogICAgICAgICAgICB0aGlzLncgPSBhdyAqIGJ3IC0gYXogKiBiejsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdGhpcyBRdWF0IHRvIGEgTWF0MyAoYSAzeDMgbWF0cml4KS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRSZXR1cm5zIGEgbmV3IE1hdDMuDQogICAgICAgICAqLw0KICAgICAgICB0b01hdDMoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53Ow0KICAgICAgICAgICAgY29uc3QgeDIgPSB4ICsgeDsNCiAgICAgICAgICAgIGNvbnN0IHkyID0geSArIHk7DQogICAgICAgICAgICBjb25zdCB6MiA9IHogKyB6Ow0KICAgICAgICAgICAgY29uc3QgeHggPSB4ICogeDI7DQogICAgICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjsNCiAgICAgICAgICAgIGNvbnN0IHl5ID0geSAqIHkyOw0KICAgICAgICAgICAgY29uc3QgenggPSB6ICogeDI7DQogICAgICAgICAgICBjb25zdCB6eSA9IHogKiB5MjsNCiAgICAgICAgICAgIGNvbnN0IHp6ID0geiAqIHoyOw0KICAgICAgICAgICAgY29uc3Qgd3ggPSB3ICogeDI7DQogICAgICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjsNCiAgICAgICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyOw0KICAgICAgICAgICAgY29uc3QgbWF0MyA9IG5ldyBNYXQzKCk7DQogICAgICAgICAgICBtYXQzLm0wMCA9IDEgLSB5eSAtIHp6Ow0KICAgICAgICAgICAgbWF0My5tMTAgPSB5eCAtIHd6Ow0KICAgICAgICAgICAgbWF0My5tMjAgPSB6eCArIHd5Ow0KICAgICAgICAgICAgbWF0My5tMDEgPSB5eCArIHd6Ow0KICAgICAgICAgICAgbWF0My5tMTEgPSAxIC0geHggLSB6ejsNCiAgICAgICAgICAgIG1hdDMubTIxID0genkgLSB3eDsNCiAgICAgICAgICAgIG1hdDMubTAyID0genggLSB3eTsNCiAgICAgICAgICAgIG1hdDMubTEyID0genkgKyB3eDsNCiAgICAgICAgICAgIG1hdDMubTIyID0gMSAtIHh4IC0geXk7DQogICAgICAgICAgICByZXR1cm4gbWF0MzsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyBhIFZlYzMgdmFsdWUgYWxpZ25lZCB3aXRoIHRoZSBYIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJlc3VsdGluZyBWZWMzIHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBnZXRYYXhpcygpIHsNCiAgICAgICAgICAgIGNvbnN0IHh5ID0gdGhpcy54ICogdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeHogPSB0aGlzLnggKiB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB5eSA9IHRoaXMueSAqIHRoaXMueTsNCiAgICAgICAgICAgIGNvbnN0IHl3ID0gdGhpcy55ICogdGhpcy53Ow0KICAgICAgICAgICAgY29uc3QgenogPSB0aGlzLnogKiB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB6dyA9IHRoaXMueiAqIHRoaXMudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygxLjAgLSAyLjAgKiAoenogKyB5eSksIDIuMCAqICh4eSArIHp3KSwgMi4wICogKHh6IC0geXcpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyBhIFZlYzMgdmFsdWUgYWxpZ25lZCB3aXRoIHRoZSBZIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJlc3VsdGluZyBWZWMzIHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBnZXRZYXhpcygpIHsNCiAgICAgICAgICAgIGNvbnN0IHh4ID0gdGhpcy54ICogdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeHkgPSB0aGlzLnggKiB0aGlzLnk7DQogICAgICAgICAgICBjb25zdCB4dyA9IHRoaXMueCAqIHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IHl6ID0gdGhpcy55ICogdGhpcy56Ow0KICAgICAgICAgICAgY29uc3QgenogPSB0aGlzLnogKiB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB6dyA9IHRoaXMueiAqIHRoaXMudzsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygyLjAgKiAoeHkgLSB6dyksIDEuMCAtIDIuMCAqICh6eiArIHh4KSwgMi4wICogKHl6ICsgeHcpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyBhIFZlYzMgdmFsdWUgYWxpZ25lZCB3aXRoIHRoZSBaIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJlc3VsdGluZyBWZWMzIHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBnZXRaYXhpcygpIHsNCiAgICAgICAgICAgIGNvbnN0IHh4ID0gdGhpcy54ICogdGhpcy54Ow0KICAgICAgICAgICAgY29uc3QgeHogPSB0aGlzLnggKiB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB4dyA9IHRoaXMueCAqIHRoaXMudzsNCiAgICAgICAgICAgIGNvbnN0IHl5ID0gdGhpcy55ICogdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeXogPSB0aGlzLnkgKiB0aGlzLno7DQogICAgICAgICAgICBjb25zdCB5dyA9IHRoaXMueSAqIHRoaXMudzsNCiAgICAgICAgICAgIC8vIGNvbnN0IHRlbXAgPSBuZXcgVmVjMygpDQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoMi4wICogKHl3ICsgeHopLCAyLjAgKiAoeXogLSB4dyksIDEuMCAtIDIuMCAqICh5eSArIHh4KSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlZmxlY3RzIHRoaXMgcXVhdGVybmlvbiBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgcHJvdmlkZWQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBheGlzSW5kZXggLSBBbiBpbnRlZ2VyIHdpdGggdmFsdWUgb2YgMCBmb3IgdGhlIFggYXhpcywgMSBmb3IgdGhlIFkgYXhpcywgYW5kIDIgZm9yIHRoZSBaIGF4aXMuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAgICAgICAqLw0KICAgICAgICBtaXJyb3IoYXhpc0luZGV4KSB7DQogICAgICAgICAgICBzd2l0Y2ggKGF4aXNJbmRleCkgew0KICAgICAgICAgICAgICAgIGNhc2UgMDoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueiwgdGhpcy53LCB0aGlzLngsIHRoaXMueSk7DQogICAgICAgICAgICAgICAgY2FzZSAxOg0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQoLXRoaXMudywgdGhpcy56LCB0aGlzLnksIC10aGlzLngpOw0KICAgICAgICAgICAgICAgIGNhc2UgMjoNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCwgdGhpcy55LCB0aGlzLnosIC10aGlzLncpOw0KICAgICAgICAgICAgICAgIGNhc2UgMDoNCiAgICAgICAgICAgICAgICBkZWZhdWx0Og0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy56LCB0aGlzLncsIHRoaXMueCwgdGhpcy55KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgdGhpcyBRdWF0IHRvIGEgTWF0NCAoYSA0eDQgbWF0cml4KS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICAgICAgICovDQogICAgICAgIHRvTWF0NCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55Ow0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuejsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLnc7DQogICAgICAgICAgICBjb25zdCB4MiA9IHggKyB4Ow0KICAgICAgICAgICAgY29uc3QgeTIgPSB5ICsgeTsNCiAgICAgICAgICAgIGNvbnN0IHoyID0geiArIHo7DQogICAgICAgICAgICBjb25zdCB4eCA9IHggKiB4MjsNCiAgICAgICAgICAgIGNvbnN0IHl4ID0geSAqIHgyOw0KICAgICAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7DQogICAgICAgICAgICBjb25zdCB6eCA9IHogKiB4MjsNCiAgICAgICAgICAgIGNvbnN0IHp5ID0geiAqIHkyOw0KICAgICAgICAgICAgY29uc3QgenogPSB6ICogejI7DQogICAgICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjsNCiAgICAgICAgICAgIGNvbnN0IHd5ID0gdyAqIHkyOw0KICAgICAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7DQogICAgICAgICAgICAvLyBTZXQgdGhlIGNvbHVtbnMNCiAgICAgICAgICAgIGNvbnN0IG1hdDQgPSBuZXcgTWF0NCgpOw0KICAgICAgICAgICAgbWF0NC5tMDAgPSAxIC0geXkgLSB6ejsNCiAgICAgICAgICAgIG1hdDQubTEwID0geXggLSB3ejsNCiAgICAgICAgICAgIG1hdDQubTIwID0genggKyB3eTsNCiAgICAgICAgICAgIG1hdDQubTAxID0geXggKyB3ejsNCiAgICAgICAgICAgIG1hdDQubTExID0gMSAtIHh4IC0geno7DQogICAgICAgICAgICBtYXQ0Lm0yMSA9IHp5IC0gd3g7DQogICAgICAgICAgICBtYXQ0Lm0wMiA9IHp4IC0gd3k7DQogICAgICAgICAgICBtYXQ0Lm0xMiA9IHp5ICsgd3g7DQogICAgICAgICAgICBtYXQ0Lm0yMiA9IDEgLSB4eCAtIHl5Ow0KICAgICAgICAgICAgcmV0dXJuIG1hdDQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gb2YgdGhpcyBRdWF0IHRvd2FyZHMgYW5vdGhlciBRdWF0LCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgIC0gVGhlIG90aGVyIFF1YXQgdG8gaW50ZXJwb2xhdGUgdG93YXJkcy4NCiAgICAgICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIHJhdGlvLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKi8NCiAgICAgICAgbGVycChvdGhlciwgdCkgew0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFF1YXQodGhpcy54ICsgdCAqIChvdGhlci54IC0gdGhpcy54KSwgdGhpcy55ICsgdCAqIChvdGhlci55IC0gdGhpcy55KSwgdGhpcy56ICsgdCAqIChvdGhlci56IC0gdGhpcy56KSwgdGhpcy53ICsgdCAqIChvdGhlci53IC0gdGhpcy53KSk7DQogICAgICAgICAgICByZXN1bHQubm9ybWFsaXplSW5QbGFjZSgpOw0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gb2YgdGhpcyBRdWF0IHRvd2FyZHMgYW5vdGhlciBRdWF0LCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLg0KICAgICAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuDQogICAgICAgICAqLw0KICAgICAgICBzbGVycChvdGhlciwgbGFtYmRhKSB7DQogICAgICAgICAgICAvLy8gaHR0cHM6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vRmFzdEFuZEFjY3VyYXRlU2xlcnAucGRmDQogICAgICAgICAgICBjb25zdCBkb3RQcm9kdWN0ID0gdGhpcy5kb3Qob3RoZXIpOw0KICAgICAgICAgICAgaWYgKGRvdFByb2R1Y3QgPiAwLjk5OSkNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgICAgIC8vIGFsZ29yaXRobSBhZGFwdGVkIGZyb20gU2hvZW1ha2UncyBwYXBlcg0KICAgICAgICAgICAgLy8gbGFtYmRhIGlzIGluICgwLCDPgC8yXQ0KICAgICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLmFjb3MoZG90UHJvZHVjdCk7DQogICAgICAgICAgICBjb25zdCBzdCA9IE1hdGguc2luKHRoZXRhKTsNCiAgICAgICAgICAgIGNvbnN0IHN1dCA9IE1hdGguc2luKGxhbWJkYSAqIHRoZXRhKTsNCiAgICAgICAgICAgIGNvbnN0IHNvdXQgPSBNYXRoLnNpbigoMSAtIGxhbWJkYSkgKiB0aGV0YSk7DQogICAgICAgICAgICBjb25zdCBjb2VmZjEgPSBzb3V0IC8gc3Q7DQogICAgICAgICAgICBjb25zdCBjb2VmZjIgPSBzdXQgLyBzdDsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWF0KGNvZWZmMSAqIHRoaXMueCArIGNvZWZmMiAqIG90aGVyLngsIGNvZWZmMSAqIHRoaXMueSArIGNvZWZmMiAqIG90aGVyLnksIGNvZWZmMSAqIHRoaXMueiArIGNvZWZmMiAqIG90aGVyLnosIGNvZWZmMSAqIHRoaXMudyArIGNvZWZmMiAqIG90aGVyLncpOw0KICAgICAgICAgICAgcmVzdWx0Lm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENsb25lcyB0aGlzIFF1YXQgYW5kIHJldHVybnMgYSBuZXcgUXVhdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhcyBhbiBhcnJheS4NCiAgICAgICAgICovDQogICAgICAgIGFzQXJyYXkoKSB7DQogICAgICAgICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107DQogICAgICAgIH0NCiAgICAgICAgZnJvbUFycmF5KGFycmF5KSB7DQogICAgICAgICAgICB0aGlzLnggPSBhcnJheVswXTsNCiAgICAgICAgICAgIHRoaXMueSA9IGFycmF5WzFdOw0KICAgICAgICAgICAgdGhpcy56ID0gYXJyYXlbMl07DQogICAgICAgICAgICB0aGlzLncgPSBhcnJheVszXTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwDQogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKCkgew0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICB4OiB0aGlzLngsDQogICAgICAgICAgICAgICAgeTogdGhpcy55LA0KICAgICAgICAgICAgICAgIHo6IHRoaXMueiwNCiAgICAgICAgICAgICAgICB3OiB0aGlzLncsDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIHRoaXMueCA9IGoueDsNCiAgICAgICAgICAgIHRoaXMueSA9IGoueTsNCiAgICAgICAgICAgIHRoaXMueiA9IGouejsNCiAgICAgICAgICAgIHRoaXMudyA9IGoudzsNCiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplSW5QbGFjZSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyKSB7DQogICAgICAgICAgICB0aGlzLnggPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICB0aGlzLncgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqLw0KICAgIC8qKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBYZm8gdHJhbnNmb3JtLCB3aGljaCBpcyBhIHRyYW5zZm9ybWF0aW9uIGRlY29tcG9zZWQgaW50byAzIGNvbXBvbmVudCB2YWx1ZXMuIFRyYW5zbGF0aW9uLCBPcmllbnRhdGlvbiwgYW5kIFNjYWxpbmcuDQogICAgICovDQogICAgY2xhc3MgWGZvIHsNCiAgICAgICAgdHI7DQogICAgICAgIG9yaTsNCiAgICAgICAgc2M7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgWGZvIG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHRyIC0gVGhlIHRyYW5zbGF0aW9uIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gb3JpIC0gVGhlIG9yaWVudGF0aW9uIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gc2MgLSBUaGUgc2NhbGluZyB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHRyID0gbmV3IFZlYzMoKSwgb3JpID0gbmV3IFF1YXQoKSwgc2MgPSBuZXcgVmVjMygxLCAxLCAxKSkgew0KICAgICAgICAgICAgdGhpcy50ciA9IHRyOw0KICAgICAgICAgICAgdGhpcy5vcmkgPSBvcmk7DQogICAgICAgICAgICB0aGlzLnNjID0gc2M7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBYZm8gb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdHIgLSBUaGUgdHJhbnNsYXRpb24gdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBvcmkgLSBUaGUgb3JpZW50YXRpb24gdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBzYyAtIFRoZSBzY2FsaW5nIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0KHRyLCBvcmksIHNjKSB7DQogICAgICAgICAgICB0aGlzLnRyID0gdHI7DQogICAgICAgICAgICB0aGlzLm9yaSA9IG9yaTsNCiAgICAgICAgICAgIGlmIChzYyBpbnN0YW5jZW9mIFZlYzMpDQogICAgICAgICAgICAgICAgdGhpcy5zYyA9IHNjOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdCB1c2luZyBhbm90aGVyIFhmbyBvYmplY3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBYZm8gdG8gc2V0IGZyb20uDQogICAgICAgICAqLw0KICAgICAgICBzZXRGcm9tT3RoZXIob3RoZXIpIHsNCiAgICAgICAgICAgIHRoaXMudHIgPSBvdGhlci50cjsNCiAgICAgICAgICAgIHRoaXMub3JpID0gb3RoZXIub3JpOw0KICAgICAgICAgICAgdGhpcy5zYyA9IG90aGVyLnNjOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBYZm8gb2JqZWN0IGlzIGFuIGBpZGVudGl0eWAsIGNoZWNraW5nIHRoYXQgdGhlIHRyYW5zbGF0aW9uLCBvcmllbnRhdGlvbiBhbmQgc2NhbGluZyBhdHRyaWJ1dGVzIGFyZSBpbiB0aGVpciBpbml0aWFsIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzSWRlbnRpdHkoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy50ci5pc051bGwoKSAmJiB0aGlzLm9yaS5pc0lkZW50aXR5KCkgJiYgdGhpcy5zYy5pczExMSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDaGVja3MgaWYgdGhpcyBWZWMzIGNvbnRhaW5zIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgb3RoZXIgVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgYXJlIHRoZSBzYW1lIFZlY3Rvciwgb3RoZXJ3aXNlLCBgZmFsc2VgLg0KICAgICAgICAgKi8NCiAgICAgICAgaXNFcXVhbChvdGhlcikgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMudHIuaXNFcXVhbChvdGhlci50cikgJiYgdGhpcy5vcmkuaXNFcXVhbChvdGhlci5vcmkpICYmIHRoaXMuc2MuaXNFcXVhbChvdGhlci5zYyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFZlYzIgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gY29tcGFyZSB3aXRoLg0KICAgICAgICAgKiBAcGFyYW0gcHJlY2lzaW9uIC0gVGhlIHByZWNpc2lvbiB0byB3aGljaCB0aGUgdmFsdWVzIG11c3QgbWF0Y2guDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuDQogICAgICAgICAqLw0KICAgICAgICBhcHByb3hFcXVhbChvdGhlciwgcHJlY2lzaW9uID0gTnVtYmVyLkVQU0lMT04pIHsNCiAgICAgICAgICAgIHJldHVybiAoKG90aGVyLnRyID8gdGhpcy50ci5hcHByb3hFcXVhbChvdGhlci50ciwgcHJlY2lzaW9uKSA6IHRydWUpICYmDQogICAgICAgICAgICAgICAgKG90aGVyLm9yaSA/IHRoaXMub3JpLmFwcHJveEVxdWFsKG90aGVyLm9yaSwgcHJlY2lzaW9uKSA6IHRydWUpICYmDQogICAgICAgICAgICAgICAgKG90aGVyLnNjID8gdGhpcy5zYy5hcHByb3hFcXVhbChvdGhlci5zYywgcHJlY2lzaW9uKSA6IHRydWUpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldExvb2tBdCBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBwb3MgLSBUaGUgcG9zaXRpb24gdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdXAgLSBUaGUgdXAgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRMb29rQXQocG9zLCB0YXJnZXQsIHVwKSB7DQogICAgICAgICAgICAvLyBOb3RlOiBXZSBsb29rIGFsb25nIHRoZSAteiBheGlzLiBOZWdhdGUgdGhlIGRpcmVjdGlvbi4NCiAgICAgICAgICAgIGNvbnN0IGRpciA9IHBvcy5zdWJ0cmFjdCh0YXJnZXQpOw0KICAgICAgICAgICAgY29uc3QgZGlyTGVuID0gZGlyLmxlbmd0aCgpOw0KICAgICAgICAgICAgaWYgKGRpckxlbiA8IE51bWJlci5FUFNJTE9OKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpcicpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5vcmkuc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGRpciwgdXApOw0KICAgICAgICAgICAgdGhpcy50ciA9IHBvczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTXVsdGlwbGllcyB0d28gWGZvIHRyYW5zZm9ybXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB4Zm8gLSBUaGUgeGZvIHRvIG11bHRpcGx5IHdpdGguDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFuIFhmby4NCiAgICAgICAgICovDQogICAgICAgIG11bHRpcGx5KHhmbykgew0KICAgICAgICAgICAgbGV0IHRoaXNfc2MgPSB0aGlzLnNjOw0KICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vbi11bmlmb3JtIHNjYWxlLg0KICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc2MueSAtIHRoaXMuc2MueCkgPiAwLjAwMSB8fA0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuc2MueiAtIHRoaXMuc2MueCkgPiAwLjAwMSB8fA0KICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuc2MueiAtIHRoaXMuc2MueSkgPiAwLjAwMSkgew0KICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNfbWF0NCA9IHRoaXMudG9NYXQ0KCk7DQogICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJfbWF0NCA9IHhmby5vcmkudG9NYXQ0KCk7DQogICAgICAgICAgICAgICAgY29uc3QgcmVzTTQgPSB0aGlzX21hdDQubXVsdGlwbHkob3RoZXJfbWF0NCk7DQogICAgICAgICAgICAgICAgdGhpc19zYyA9IG5ldyBWZWMzKHJlc000LnhBeGlzLmxlbmd0aCgpLCByZXNNNC55QXhpcy5sZW5ndGgoKSwgcmVzTTQuekF4aXMubGVuZ3RoKCkpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFhmbyh0aGlzLnRyLmFkZCh0aGlzLm9yaS5yb3RhdGVWZWMzKHRoaXMuc2MubXVsdGlwbHkoeGZvLnRyKSkpLCB0aGlzLm9yaS5tdWx0aXBseSh4Zm8ub3JpKSwgdGhpc19zYy5tdWx0aXBseSh4Zm8uc2MpKTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIFhmbyBvYmplY3QsIGJ1dCByZXR1cm5zLiB0aGUgcmVzdWx0IGFzIGEgbmV3IFhmby4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgWGZvLg0KICAgICAgICAgKi8NCiAgICAgICAgaW52ZXJzZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBYZm8oKTsNCiAgICAgICAgICAgIHJlc3VsdC5vcmkgPSB0aGlzLm9yaS5pbnZlcnNlKCk7DQogICAgICAgICAgICAvLyBjaGVjayBmb3Igbm9uLXVuaWZvcm0gc2NhbGUuDQogICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zYy55IC0gdGhpcy5zYy54KSA+IDAuMDAxIHx8DQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5zYy56IC0gdGhpcy5zYy54KSA+IDAuMDAxIHx8DQogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5zYy56IC0gdGhpcy5zYy55KSA+IDAuMDAxKSB7DQogICAgICAgICAgICAgICAgY29uc3QgdGhpc19tYXQ0ID0gdGhpcy50b01hdDQoKS5pbnZlcnNlKCk7DQogICAgICAgICAgICAgICAgcmVzdWx0LnNjID0gbmV3IFZlYzModGhpc19tYXQ0LnhBeGlzLmxlbmd0aCgpLCB0aGlzX21hdDQueUF4aXMubGVuZ3RoKCksIHRoaXNfbWF0NC56QXhpcy5sZW5ndGgoKSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICByZXN1bHQuc2MgPSB0aGlzLnNjLmludmVyc2UoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJlc3VsdC50ciA9IHJlc3VsdC5vcmkucm90YXRlVmVjMyh0aGlzLnRyLm5lZ2F0ZSgpLm11bHRpcGx5KHJlc3VsdC5zYykpOw0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVHJhbnNmb3JtcyBYZm8gb2JqZWN0IHVzaW5nIGEgYFZlYzNgIG9iamVjdC4gRmlyc3Qgc2NhbGluZyBpdCwgdGhlbiByb3RhdGluZyBhbmQgZmluYWxseSBhZGRpbmcgdGhlIHJlc3VsdCB0byBjdXJyZW50IHRyYW5zbGF0aW9uIG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0cmFuc2Zvcm1WZWMzKHZlYzMpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyLmFkZCh0aGlzLm9yaS5yb3RhdGVWZWMzKHRoaXMuc2MubXVsdGlwbHkodmVjMykpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgWGZvIGFuZCBvdGhlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFhmbyB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLg0KICAgICAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gcmF0aW8uDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFhmby4NCiAgICAgICAgICovDQogICAgICAgIGxlcnAob3RoZXIsIHQpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgWGZvKHRoaXMudHIubGVycChvdGhlci50ciwgdCksIHRoaXMub3JpLnNsZXJwKG90aGVyLm9yaSwgdCksIHRoaXMuc2MubGVycChvdGhlci5zYywgdCkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFhmbyB0byBhIE1hdDQgKGEgNHg0IG1hdHJpeCkuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuDQogICAgICAgICAqLw0KICAgICAgICB0b01hdDQoKSB7DQogICAgICAgICAgICBjb25zdCBzY2wgPSBuZXcgTWF0NCh0aGlzLnNjLngsIDAsIDAsIDAsIDAsIHRoaXMuc2MueSwgMCwgMCwgMCwgMCwgdGhpcy5zYy56LCAwLCAwLCAwLCAwLCAxLjApOw0KICAgICAgICAgICAgY29uc3Qgcm90ID0gdGhpcy5vcmkudG9NYXQ0KCk7DQogICAgICAgICAgICBjb25zdCB0cm4gPSBuZXcgTWF0NCgpOw0KICAgICAgICAgICAgdHJuLnRyYW5zbGF0aW9uID0gdGhpcy50cjsNCiAgICAgICAgICAgIHJldHVybiB0cm4ubXVsdGlwbHkocm90KS5tdWx0aXBseShzY2wpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgWGZvIG9iamVjdCB1c2luZyBNYXQ0Lg0KICAgICAgICAgKiBAcGFyYW0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RnJvbU1hdDQobWF0NCkgew0KICAgICAgICAgICAgdGhpcy50ciA9IG1hdDQudHJhbnNsYXRpb247DQogICAgICAgICAgICB0aGlzLm9yaS5zZXRGcm9tTWF0NChtYXQ0KTsNCiAgICAgICAgICAgIHRoaXMuc2Muc2V0KG1hdDQueEF4aXMubGVuZ3RoKCksIG1hdDQueUF4aXMubGVuZ3RoKCksIG1hdDQuekF4aXMubGVuZ3RoKCkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDbG9uZXMgdGhpcyBYZm8gYW5kIHJldHVybnMgYSBuZXcgWGZvLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBYZm8uDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgWGZvKHRoaXMudHIuY2xvbmUoKSwgdGhpcy5vcmkuY2xvbmUoKSwgdGhpcy5zYy5jbG9uZSgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKCkgew0KICAgICAgICAgICAgY29uc3QgaiA9IHsNCiAgICAgICAgICAgICAgICB0cjogdGhpcy50ci50b0pTT04oKSwNCiAgICAgICAgICAgICAgICBvcmk6IHRoaXMub3JpLnRvSlNPTigpLA0KICAgICAgICAgICAgICAgIHNjOiB0aGlzLnNjLnRvSlNPTigpLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIHJldHVybiBqOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIHRoaXMudHIuZnJvbUpTT04oai50cik7DQogICAgICAgICAgICB0aGlzLm9yaS5mcm9tSlNPTihqLm9yaSk7DQogICAgICAgICAgICBpZiAoai5zYykgew0KICAgICAgICAgICAgICAgIHRoaXMuc2MuZnJvbUpTT04oai5zYyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsNCiAgICAgICAgICAgIHRoaXMudHIucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICAgICAgdGhpcy5vcmkucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICAgICAgdGhpcy5zYy5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9TdHJpbmcoKSB7DQogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBib3ggaW4gMkQgc3BhY2UuIE5lZWRpbmcgdHdvIFZlYzIgdmVjdG9ycyBkZXNjcmliaW5nIHRoZSBjb3JuZXJzDQogICAgICovDQogICAgY2xhc3MgQm94MiB7DQogICAgICAgIHAwOw0KICAgICAgICBwMTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSBCb3gyIG9iamVjdCB1c2luZyBWZWMycy4NCiAgICAgICAgICogSW4gY2FzZSB0aGUgcGFyYW1ldGVycyBhcmUgbm90IHBhc3NlZCBieSwgdGhlaXIgdmFsdWVzIGFyZSBwcmUtZGVmaW5lZDoNCiAgICAgICAgICoNCiAgICAgICAgICogcDAgaXMgYSBWZWMyIHdpdGgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9QT1NJVElWRV9JTkZJTklUWXxgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYH0NCiAgICAgICAgICoNCiAgICAgICAgICogcDEgaXMgYSBWZWMyIHdpdGgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9ORUdBVElWRV9JTkZJTklUWXxgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZYH0NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHAwIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAyRCBib3guDQogICAgICAgICAqIEBwYXJhbSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94Lg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IocDAsIHAxKSB7DQogICAgICAgICAgICBpZiAocDAgaW5zdGFuY2VvZiBWZWMyKSB7DQogICAgICAgICAgICAgICAgdGhpcy5wMCA9IHAwOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5wMCA9IG5ldyBWZWMyKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChwMSBpbnN0YW5jZW9mIFZlYzIpIHsNCiAgICAgICAgICAgICAgICB0aGlzLnAxID0gcDE7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aGlzLnAxID0gbmV3IFZlYzIoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIGJvdGggVmVjMiBwb2ludHMNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHAwIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAyRCBib3guDQogICAgICAgICAqIEBwYXJhbSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94Lg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0KHAwLCBwMSkgew0KICAgICAgICAgICAgdGhpcy5wMCA9IHAwOw0KICAgICAgICAgICAgdGhpcy5wMSA9IHAxOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXNldHMgdGhlIGJveDIgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvUE9TSVRJVkVfSU5GSU5JVFl8YE51bWJlci5QT1NJVElWRV9JTkZJTklUWWB9DQogICAgICAgICAqIGFuZCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL05FR0FUSVZFX0lORklOSVRZfGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgfQ0KICAgICAgICAgKi8NCiAgICAgICAgcmVzZXQoKSB7DQogICAgICAgICAgICB0aGlzLnAwLnggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAxLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAwLnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAxLnkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3ggaGFzIGJlZW4gZXhwYW5kZWQgdG8gY29udGFpbiBhIHBvaW50Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzVmFsaWQoKSB7DQogICAgICAgICAgICByZXR1cm4gKHRoaXMucDAueCAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgICAgICAgICAgICB0aGlzLnAxLnggIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZICYmDQogICAgICAgICAgICAgICAgdGhpcy5wMC55ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJg0KICAgICAgICAgICAgICAgIHRoaXMucDEueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHBhbmRzIHRoZSBCb3gyIHRvIGNvbnRhaW4gdGhlIG5ldyBwb2ludC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHBvaW50IC0gQSBwb2ludCByZXByZXNlbnRzIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94Lg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkUG9pbnQocG9pbnQpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLnAwLnggPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHBvaW50LnggPCB0aGlzLnAwLngpDQogICAgICAgICAgICAgICAgdGhpcy5wMC54ID0gcG9pbnQueDsNCiAgICAgICAgICAgIGlmICh0aGlzLnAwLnkgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHBvaW50LnkgPCB0aGlzLnAwLnkpDQogICAgICAgICAgICAgICAgdGhpcy5wMC55ID0gcG9pbnQueTsNCiAgICAgICAgICAgIGlmICh0aGlzLnAxLnkgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHBvaW50LnggPiB0aGlzLnAxLngpDQogICAgICAgICAgICAgICAgdGhpcy5wMS54ID0gcG9pbnQueDsNCiAgICAgICAgICAgIGlmICh0aGlzLnAxLnkgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIHx8IHBvaW50LnkgPiB0aGlzLnAxLnkpDQogICAgICAgICAgICAgICAgdGhpcy5wMS55ID0gcG9pbnQueTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBkaWFnb25hbCBvZiB0aGUgYm94Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlzdGFuY2UuDQogICAgICAgICAqLw0KICAgICAgICBzaXplKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucDEuZGlzdGFuY2VUbyh0aGlzLnAwKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiBhIEJveDIgLSB0aGUgc2FtZSBhcyBzaXplKCkuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGRpYWdvbmFsKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiBhIEJveDIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGNlbnRlcigpIHsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7DQogICAgICAgICAgICByZXN1bHQuc2NhbGVJblBsYWNlKDAuNSk7DQogICAgICAgICAgICByZXN1bHQuYWRkSW5QbGFjZSh0aGlzLnAwKTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENsb25lcyB0aGlzIFZlYzIgYW5kIHJldHVybnMgYSBuZXcgVmVjMi4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3gyKHRoaXMucDAuY2xvbmUoKSwgdGhpcy5wMS5jbG9uZSgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBFbmNvZGVzIGBCb3gyYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksDQogICAgICAgICAgICAgICAgcDE6IHRoaXMucDEudG9KU09OKCksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgcDAgYW5kIHAxIGF4ZXMgYXJlIG51bWVyaWMsIHNvIGluIGNhc2UgdGhleSBhcmUgbm90LCB3ZSByZXN0b3JlIHRoZW0gdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMuDQogICAgICAgICAgICAvLyBUaGlzLCBiZWNhdXNlICdJbmZpbml0eScgYW5kICctSW5maW5pdHknIGFyZSBzdHJpbmdpZmllZCBhcyAnbnVsbCcuDQogICAgICAgICAgICBjb25zdCBwMCA9IHsNCiAgICAgICAgICAgICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAwLngpID8gai5wMC54IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLA0KICAgICAgICAgICAgICAgIHk6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDAueSkgPyBqLnAwLnkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksDQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgY29uc3QgcDEgPSB7DQogICAgICAgICAgICAgICAgeDogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMS54KSA/IGoucDEueCA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwNCiAgICAgICAgICAgICAgICB5OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLnkpID8gai5wMS55IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIHRoaXMucDAuZnJvbUpTT04ocDApOw0KICAgICAgICAgICAgdGhpcy5wMS5mcm9tSlNPTihwMSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGxzIGB0b0pTT05gIG1ldGhvZCBhbmQgc3RyaW5naWZpZXMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9TdHJpbmcoKSB7DQogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcA0KICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8NCiAgICAvKioNCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtYXRoZW1hdGljYWwgc3BoZXJlLCBhcyBvcHBvc2VkIHRvIHRoZSBTcGhlcmUgY2xhc3MgZGVyaXZlZCBmcm9tIFByb2NlZHVyYWxNZXNoLg0KICAgICAqDQogICAgICovDQogICAgY2xhc3MgU3BoZXJlVHlwZSB7DQogICAgICAgIHBvczsNCiAgICAgICAgcmFkaXVzOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgc3BoZXJlLg0KICAgICAgICAgKiBAcGFyYW0gcG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzcGhlcmUuDQogICAgICAgICAqIEBwYXJhbSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3Rvcihwb3MgPSBuZXcgVmVjMygpLCByYWRpdXMgPSAwKSB7DQogICAgICAgICAgICBpZiAocG9zIGluc3RhbmNlb2YgVmVjMykgew0KICAgICAgICAgICAgICAgIHRoaXMucG9zID0gcG9zOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBuZXcgVmVjMygpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENsb25lcyB0aGlzIHNwaGVyZSBhbmQgcmV0dXJucyBhIG5ldyBzcGhlcmUuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IHNwaGVyZS4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmVUeXBlKHRoaXMucG9zLmNsb25lKCksIHRoaXMucmFkaXVzKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgc3BoZXJlIGludGVyc2VjdHMgYSBib3guDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBib3ggLSBUaGUgYm94IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGludGVyc2VjdHNCb3goYm94KSB7DQogICAgICAgICAgICByZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUodGhpcyk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgcG9zOiB0aGlzLnBvcy50b0pTT04oKSwNCiAgICAgICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsbHMgYHRvSlNPTmAgbWV0aG9kIGFuZCBzdHJpbmdpZmllcyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKioNCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBib3ggaW4gM0Qgc3BhY2UuDQogICAgICogUmVwcmVzZW50cyBhIGJveCBpbiAzRCBzcGFjZSBkZWZpbmVkIGJ5IHR3byBWZWMzIHZhbHVlcyB3aGljaCBkZWZpbmUgb3Bwb3NpbmcgY29ybmVycyBvZiB0aGUgYm94Lg0KICAgICAqLw0KICAgIGNsYXNzIEJveDMgew0KICAgICAgICBwMDsNCiAgICAgICAgcDE7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGEgQm94MyBvYmplY3QgdXNpbmcgVmVjM3MuDQogICAgICAgICAqIEluIGNhc2UgdGhlIHBhcmFtZXRlcnMgYXJlIG5vdCBwYXNzZWQgYnksIHRoZWlyIHZhbHVlcyBhcmUgcHJlLWRlZmluZWQ6DQogICAgICAgICAqDQogICAgICAgICAqIHAwIGlzIGEgVmVjMiB3aXRoIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvUE9TSVRJVkVfSU5GSU5JVFl8YE51bWJlci5QT1NJVElWRV9JTkZJTklUWWB9DQogICAgICAgICAqDQogICAgICAgICAqIHAxIGlzIGEgVmVjMiB3aXRoIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTkVHQVRJVkVfSU5GSU5JVFl8YE51bWJlci5ORUdBVElWRV9JTkZJTklUWWB9DQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94Lg0KICAgICAgICAgKiBAcGFyYW0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHAwID0gbmV3IFZlYzMoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSksIHAxID0gbmV3IFZlYzMoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkpIHsNCiAgICAgICAgICAgIHRoaXMucDAgPSBwMDsNCiAgICAgICAgICAgIHRoaXMucDEgPSBwMTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgbG93ZXIgKHgsIHksIHopIGJvdW5kYXJ5IG9mIHRoZSBib3guDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtaW5pbXVtIFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBnZXQgbWluKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucDA7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmb3IgdGhlIHVwcGVyICh4LCB5LCB6KSBib3VuZGFyeSBvZiB0aGUgYm94Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbWF4aW11bSBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IG1heCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnAxOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIGJvdGggVmVjMyBwb2ludHMNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHAwIC0gQSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guDQogICAgICAgICAqIEBwYXJhbSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94Lg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0KHAwLCBwMSkgew0KICAgICAgICAgICAgdGhpcy5wMCA9IHAwOw0KICAgICAgICAgICAgdGhpcy5wMSA9IHAxOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXNldHMgdGhlIGJveDMgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVzZXQoKSB7DQogICAgICAgICAgICB0aGlzLnAwLnggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAwLnkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAwLnogPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAxLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAxLnkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgICAgICAgICB0aGlzLnAxLnogPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3ggaGFzIGJlZW4gZXhwYW5kZWQgdG8gY29udGFpbiBhIHBvaW50Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzVmFsaWQoKSB7DQogICAgICAgICAgICByZXR1cm4gKHRoaXMucDAueCAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgICAgICAgICAgICB0aGlzLnAxLnggIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZICYmDQogICAgICAgICAgICAgICAgdGhpcy5wMC55ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJg0KICAgICAgICAgICAgICAgIHRoaXMucDEueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgJiYNCiAgICAgICAgICAgICAgICB0aGlzLnAwLnogIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmDQogICAgICAgICAgICAgICAgdGhpcy5wMS56ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEV4cGFuZHMgdGhlIEJveDMgdG8gY29udGFpbiB0aGUgbmV3IHBvaW50Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcG9pbnQgLSBBIHBvaW50IHJlcHJlc2VudHMgdGhlIGNvcm5lcnMgb2YgYSAzRCBib3guDQogICAgICAgICAqLw0KICAgICAgICBhZGRQb2ludChwb2ludCkgew0KICAgICAgICAgICAgaWYgKHBvaW50LnggIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIHBvaW50LnggIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7DQogICAgICAgICAgICAgICAgaWYgKHBvaW50LnggPCB0aGlzLnAwLngpDQogICAgICAgICAgICAgICAgICAgIHRoaXMucDAueCA9IHBvaW50Lng7DQogICAgICAgICAgICAgICAgaWYgKHBvaW50LnggPiB0aGlzLnAxLngpDQogICAgICAgICAgICAgICAgICAgIHRoaXMucDEueCA9IHBvaW50Lng7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAocG9pbnQueSAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYgcG9pbnQueSAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHsNCiAgICAgICAgICAgICAgICBpZiAocG9pbnQueSA8IHRoaXMucDAueSkNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMC55ID0gcG9pbnQueTsNCiAgICAgICAgICAgICAgICBpZiAocG9pbnQueSA+IHRoaXMucDEueSkNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMS55ID0gcG9pbnQueTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChwb2ludC56ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBwb2ludC56ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgew0KICAgICAgICAgICAgICAgIGlmIChwb2ludC56IDwgdGhpcy5wMC56KQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLnAwLnogPSBwb2ludC56Ow0KICAgICAgICAgICAgICAgIGlmIChwb2ludC56ID4gdGhpcy5wMS56KQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLnAxLnogPSBwb2ludC56Ow0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBZGRzIGBCb3gzYCB0byB0aGlzIGBCb3gzYCwgb2YgdGhlIFhmbyBpbnN0YW5jZSBpcyBwYXNzZWQgaW4gdGhlIHBhcmFtZXRlcnMNCiAgICAgICAgICogaXQgcHJvY2VlZHMgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSBmb3IgdGhlIFZlYzMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBib3gzIC0gQSAzRCBib3guDQogICAgICAgICAqIEBwYXJhbSB4Zm8gLSBBIDNEIHRyYW5zZm9ybS4NCiAgICAgICAgICovDQogICAgICAgIGFkZEJveDMoYm94MywgdHJhbnNmb3JtKSB7DQogICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7DQogICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGVhY2ggY29ybmVyIG9mIHRoZSBCb3gzIGludG8gdGhlIG5ldyBjb29yZGluYXRlIHN5c3RlbS4NCiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHRyYW5zZm9ybS50cmFuc2Zvcm1WZWMzKGJveDMucDApKTsNCiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHRyYW5zZm9ybS50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzKGJveDMucDAueCwgYm94My5wMC55LCBib3gzLnAxLnopKSk7DQogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAwLngsIGJveDMucDEueSwgYm94My5wMC56KSkpOw0KICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQodHJhbnNmb3JtLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMoYm94My5wMS54LCBib3gzLnAwLnksIGJveDMucDAueikpKTsNCiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHRyYW5zZm9ybS50cmFuc2Zvcm1WZWMzKG5ldyBWZWMzKGJveDMucDAueCwgYm94My5wMS55LCBib3gzLnAxLnopKSk7DQogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDAueSwgYm94My5wMS56KSkpOw0KICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQodHJhbnNmb3JtLnRyYW5zZm9ybVZlYzMobmV3IFZlYzMoYm94My5wMS54LCBib3gzLnAxLnksIGJveDMucDAueikpKTsNCiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KHRyYW5zZm9ybS50cmFuc2Zvcm1WZWMzKGJveDMucDEpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQoYm94My5wMCk7DQogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChib3gzLnAxKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBkaWFnb25hbCBvZiB0aGUgYm94Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlzdGFuY2UuDQogICAgICAgICAqLw0KICAgICAgICBzaXplKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucDEuZGlzdGFuY2VUbyh0aGlzLnAwKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgZGlhZ29uYWwgdmVjdG9yIG9mIHRoZSBCPWJveCBmcm9tIHAwIHRvIHAxLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIEJveDMuDQogICAgICAgICAqLw0KICAgICAgICBkaWFnb25hbCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgYSBCb3gzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzMuDQogICAgICAgICAqLw0KICAgICAgICBjZW50ZXIoKSB7DQogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApOw0KICAgICAgICAgICAgcmVzdWx0LnNjYWxlSW5QbGFjZSgwLjUpOw0KICAgICAgICAgICAgcmVzdWx0LmFkZEluUGxhY2UodGhpcy5wMCk7DQogICAgICAgICAgICByZXR1cm4gcmVzdWx0Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEJveDMgdG8gYSBNYXQ0IChhIDR4NCBtYXRyaXgpLiBUaGUgcmV0dXJuZWQgbWF0NCB3b3VsZCB0cmFuc2Zvcm0gYSB1bml0IGN1YmUgaW50byB0aGUgc2hhcGUgb2YgdGhlIEJvdW5kaW5nIGJveC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0NC4NCiAgICAgICAgICovDQogICAgICAgIHRvTWF0NCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHNjeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDsNCiAgICAgICAgICAgIGNvbnN0IHNjeSA9IHRoaXMucDEueSAtIHRoaXMucDAueTsNCiAgICAgICAgICAgIGNvbnN0IHNjeiA9IHRoaXMucDEueiAtIHRoaXMucDAuejsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0NChzY3gsIDAsIDAsIDAsIDAsIHNjeSwgMCwgMCwgMCwgMCwgc2N6LCAwLCB0aGlzLnAwLngsIHRoaXMucDAueSwgdGhpcy5wMC56LCAxLjApOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBib3VuZGluZyBTcGhlcmUgb2YgdGhlIEJveDMNCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRCb3VuZGluZ1NwaGVyZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgU3BoZXJlVHlwZSh0aGlzLmNlbnRlcigpLCB0aGlzLmRpYWdvbmFsKCkubGVuZ3RoKCkgKiAwLjUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgQm94MyBpbnRlcnNlY3RzIGEgZ2l2ZW4gYm94IHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gYm94IC0gVGhlIGJveCB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIGFnYWluc3QuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHNoYXBlcyBpbnRlcnNlY3QuDQogICAgICAgICAqLw0KICAgICAgICBpbnRlcnNlY3RzQm94KGJveCkgew0KICAgICAgICAgICAgLy8gVXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuDQogICAgICAgICAgICByZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fA0KICAgICAgICAgICAgICAgIGJveC5taW4ueCA+IHRoaXMubWF4LnggfHwNCiAgICAgICAgICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8DQogICAgICAgICAgICAgICAgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fA0KICAgICAgICAgICAgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwNCiAgICAgICAgICAgICAgICBib3gubWluLnogPiB0aGlzLm1heC56DQogICAgICAgICAgICAgICAgPyBmYWxzZQ0KICAgICAgICAgICAgICAgIDogdHJ1ZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEJveDMgaW50ZXJzZWN0cyBhIHNwaGVyZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzaGFwZXMgaW50ZXJzZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgaW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHsNCiAgICAgICAgICAgIGxldCBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjMygpOw0KICAgICAgICAgICAgLy8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci4NCiAgICAgICAgICAgIC8vIHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7DQogICAgICAgICAgICAvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC4NCiAgICAgICAgICAgIHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUbyhzcGhlcmUucG9zKSA8PSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1czsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEJveDMgaW50ZXJzZWN0cyBhIHBsYW5lLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcGxhbmUgLSBUaGUgcGxhbmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGludGVyc2VjdHNQbGFuZShwbGFuZSkgew0KICAgICAgICAgICAgLy8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlcw0KICAgICAgICAgICAgLy8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uDQogICAgICAgICAgICBsZXQgbWluOw0KICAgICAgICAgICAgbGV0IG1heDsNCiAgICAgICAgICAgIGlmIChwbGFuZS5ub3JtYWwueCA+IDApIHsNCiAgICAgICAgICAgICAgICBtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7DQogICAgICAgICAgICAgICAgbWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgbWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54Ow0KICAgICAgICAgICAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChwbGFuZS5ub3JtYWwueSA+IDApIHsNCiAgICAgICAgICAgICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55Ow0KICAgICAgICAgICAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55Ow0KICAgICAgICAgICAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAocGxhbmUubm9ybWFsLnogPiAwKSB7DQogICAgICAgICAgICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejsNCiAgICAgICAgICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejsNCiAgICAgICAgICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIG1pbiA8PSAtcGxhbmUudyAmJiBtYXggPj0gLXBsYW5lLnc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENsb25lcyB0aGlzIEJveDMgYW5kIHJldHVybnMgYSBuZXcgQm94My4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgQm94My4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3gzKHRoaXMucDAuY2xvbmUoKSwgdGhpcy5wMS5jbG9uZSgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBFbmNvZGVzIGBCb3gzYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTigpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksDQogICAgICAgICAgICAgICAgcDE6IHRoaXMucDEudG9KU09OKCksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgcDAgYW5kIHAxIGF4ZXMgYXJlIG51bWVyaWMsIHNvIGluIGNhc2UgdGhleSBhcmUgbm90LCB3ZSByZXN0b3JlIHRoZW0gdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMuDQogICAgICAgICAgICAvLyBUaGlzLCBiZWNhdXNlICdJbmZpbml0eScgYW5kICctSW5maW5pdHknIGFyZSBzdHJpbmdpZmllZCBhcyAnbnVsbCcuDQogICAgICAgICAgICBjb25zdCBwMCA9IHsNCiAgICAgICAgICAgICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAwLngpID8gai5wMC54IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLA0KICAgICAgICAgICAgICAgIHk6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDAueSkgPyBqLnAwLnkgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksDQogICAgICAgICAgICAgICAgejogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC56KSA/IGoucDAueiA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBjb25zdCBwMSA9IHsNCiAgICAgICAgICAgICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLngpID8gai5wMS54IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLA0KICAgICAgICAgICAgICAgIHk6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDEueSkgPyBqLnAxLnkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksDQogICAgICAgICAgICAgICAgejogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMS56KSA/IGoucDEueiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICB0aGlzLnAwLmZyb21KU09OKHAwKTsNCiAgICAgICAgICAgIHRoaXMucDEuZnJvbUpTT04ocDEpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvU3RyaW5nKCkgew0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXANCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICBsZXQgbnVtQmFzZUl0ZW1zID0gMDsNCiAgICAvKioNCiAgICAgKiBCYXNlIGNsYXNzIGZvciBJdGVtcyBpbiB0aGUgc2NlbmUuIEl0IGNhbiBiZSBwYXJhbWV0ZXJpemVkIGFuZCBjYW4gZW1pdCBldmVudHMuDQogICAgICoNCiAgICAgKiAqKkV2ZW50cyoqDQogICAgICogKiAqKm5hbWVDaGFuZ2VkOioqIEVtaXR0ZWQgZXZlcnkgdGltZSB0aGUgSXRlbSdzIG5hbWUgaXMgY2hhbmdlLiBtb3N0bHkgaW4gYHNldE5hbWVgIG1ldGhvZC4NCiAgICAgKiAqICoqc2VsZWN0ZWRDaGFuZ2VkOioqIEVtaXR0ZWQgYHNlbGVjdGVkYCBzdGF0dXMgY2hhbmdlcywgbW9zdGx5IGluIGBzZXRTZWxlY3RlZGAgbWV0aG9kLg0KICAgICAqDQogICAgICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn0NCiAgICAgKi8NCiAgICBjbGFzcyBCYXNlSXRlbSBleHRlbmRzIEV2ZW50RW1pdHRlciB7DQogICAgICAgIF9fbmFtZTsNCiAgICAgICAgX19vd25lckl0ZW0gPSB1bmRlZmluZWQ7DQogICAgICAgIF9fc2VsZWN0YWJsZSA9IHRydWU7DQogICAgICAgIF9fc2VsZWN0ZWQgPSBmYWxzZTsNCiAgICAgICAgX19tZXRhRGF0YSA9IHt9Ow0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgYmFzZSBpdGVtIGJ5IGRlZmluaW5nIGl0cyBuYW1lLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGl0ZW0uDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLl9fbmFtZSA9IG5hbWU7DQogICAgICAgICAgICBudW1CYXNlSXRlbXMrKzsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFN0YXRpYyBNZXRob2RzDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2V0TnVtQmFzZUl0ZW1zIG1ldGhvZCByZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgYmFzZSBpdGVtcyBjcmVhdGVkLg0KICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluIGRlYnVnZ2luZyBtZW1vcnkgY29uc3VtcHRpb24uDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgYmFzZSBpdGVtcyBjcmVhdGVkLg0KICAgICAgICAgKi8NCiAgICAgICAgc3RhdGljIGdldE51bUJhc2VJdGVtcygpIHsNCiAgICAgICAgICAgIHJldHVybiBudW1CYXNlSXRlbXM7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBOYW1lIGFuZCBQYXRoDQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBiYXNlIGl0ZW0uDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBiYXNlIGl0ZW0gbmFtZS4NCiAgICAgICAgICovDQogICAgICAgIGdldCBuYW1lKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBiYXNlIGl0ZW0oVXBkYXRlcyBwYXRoKS4NCiAgICAgICAgICoNCiAgICAgICAgICogQGVtaXRzIGBuYW1lQ2hhbmdlZGAgd2l0aCBgbmV3TmFtZWAgYW5kIGBvbGROYW1lYCBkYXRhLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBiYXNlIGl0ZW0gbmFtZS4NCiAgICAgICAgICovDQogICAgICAgIHNldCBuYW1lKHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldE5hbWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBhdGggb2YgdGhlIGl0ZW0gaW4gdGhlIHRyZWUgYXMgYW4gYXJyYXkgb2YgbmFtZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFuIGFycmF5Lg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IHBhdGgoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXRoKCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGJhc2UgaXRlbS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGJhc2UgaXRlbSBuYW1lLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TmFtZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbmFtZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgYmFzZSBpdGVtKFVwZGF0ZXMgcGF0aCkuDQogICAgICAgICAqDQogICAgICAgICAqIEBlbWl0cyBgbmFtZUNoYW5nZWRgIHdpdGggYG5ld05hbWVgIGFuZCBgb2xkTmFtZWAgZGF0YS4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgYmFzZSBpdGVtIG5hbWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXROYW1lKG5hbWUpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fbmFtZSAhPSBuYW1lKSB7DQogICAgICAgICAgICAgICAgY29uc3Qgb2xkTmFtZSA9IHRoaXMuX19uYW1lOw0KICAgICAgICAgICAgICAgIHRoaXMuX19uYW1lID0gbmFtZTsNCiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOYW1lQ2hhbmdlZEV2ZW50KG9sZE5hbWUsIG5hbWUpOw0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbmFtZUNoYW5nZWQnLCBldmVudCk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGF0aCBvZiB0aGUgaXRlbSBpbiB0aGUgdHJlZSBhcyBhbiBhcnJheSBvZiBuYW1lcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYW4gYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBnZXRQYXRoKCkgew0KICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0gPT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fX25hbWVdOw0KICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9fb3duZXJJdGVtLmdldFBhdGgoKSwgdGhpcy5fX25hbWVdOw0KICAgICAgICB9DQogICAgICAgIC8vIFBhdGggVHJhdmVyc2FsDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgcmVzb2x2ZVBhdGggbWV0aG9kIHRyYXZlcnNlcyB0aGUgc3VidHJlZSBmcm9tIHRoaXMgaXRlbSBkb3duDQogICAgICAgICAqIG1hdGNoaW5nIGVhY2ggbmFtZSBpbiB0aGUgcGF0aCB3aXRoIGEgY2hpbGQgdW50aWwgaXQgcmVhY2hlcyB0aGUNCiAgICAgICAgICogZW5kIG9mIHRoZSBwYXRoLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVzb2x2ZVBhdGgocGF0aCwgaW5kZXggPSAwKSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPT0gMCkgew0KICAgICAgICAgICAgICAgIGlmIChwYXRoWzBdID09ICcuJyB8fCBwYXRoWzBdID09IHRoaXMuX19uYW1lKQ0KICAgICAgICAgICAgICAgICAgICBpbmRleCsrOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKHBhdGhbaW5kZXhdID09ICcuLicpIHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX293bmVySXRlbSkgew0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX293bmVySXRlbS5yZXNvbHZlUGF0aChwYXRoLCBpbmRleCArIDEpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RoaXMuX19vd25lckl0ZW0gaXMgdW5kZWZpbmVkJyk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGluZGV4ID09IHBhdGgubGVuZ3RoKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBPd25lciBJdGVtDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2V0T3duZXIgbWV0aG9kIHJldHVybnMgdGhlIGN1cnJlbnQgb3duZXIgb2YgdGhlIGl0ZW0uDQogICAgICAgICAqIFRoZSBpdGVtIGlzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgb3duZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBjdXJyZW50IG93bmVyLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0T3duZXIoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX293bmVySXRlbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldE93bmVyIG1ldGhvZCBhc3NpZ25zIGEgbmV3IG93bmVyIHRvIHRoZSBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3duZXJJdGVtIC0gVGhlIG5ldyBvd25lciBpdGVtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0T3duZXIob3duZXJJdGVtKSB7DQogICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtID0gb3duZXJJdGVtOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gU2VsZWN0YWJpbGl0eSBhbmQgU2VsZWN0aW9uDQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgaXRlbSBpcyBzZWxlY3RhYmxlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaXRlbSBpcyBzZWxlY3RhYmxlLg0KICAgICAgICAgKi8NCiAgICAgICAgaXNTZWxlY3RhYmxlKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19zZWxlY3RhYmxlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNb2RpZmllcyB0aGUgc2VsZWN0YWJpbGl0eSBvZiB0aGlzIGl0ZW0uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2YWwgLSBBIGJvb2xlYW4gaW5kaWNhdGluZyB0aGUgc2VsZWN0YWJpbGl0eSBvZiB0aGUgaXRlbS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBjaGFuZ2VkLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U2VsZWN0YWJsZSh2YWwpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fc2VsZWN0YWJsZSAhPSB2YWwpIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fc2VsZWN0YWJsZSA9IHZhbDsNCiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgU2VsZWN0YWJpbGl0eUNoYW5nZWRFdmVudCh0aGlzLl9fc2VsZWN0YWJsZSk7DQogICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3RhYmlsaXR5Q2hhbmdlZCcsIGV2ZW50KTsNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGlzU2VsZWN0ZWQgbWV0aG9kLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzU2VsZWN0ZWQoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX3NlbGVjdGVkOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzZWxlY3Rpb24gb2YgdGhpcyBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAZW1pdHMgYHNlbGVjdGVkQ2hhbmdlZGAgd2l0aCBzZWxlY3RlZCBzdGF0ZQ0KICAgICAgICAgKiBAcGFyYW0gc2VsIC0gQm9vbGVhbiBpbmRpY2F0aW5nIHRoZSBuZXcgc2VsZWN0aW9uIHN0YXRlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U2VsZWN0ZWQoc2VsKSB7DQogICAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWQgPSBzZWw7DQogICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgU2VsZWN0ZWRFdmVudCh0aGlzLl9fc2VsZWN0ZWQpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3RlZENoYW5nZWQnLCBldmVudCk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBNZXRhZGF0YQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0cyBJdGVtJ3MgbWV0YS1kYXRhIHZhbHVlIGJ5IHBhc3NpbmcgdGhlIGBrZXlgIHN0cmluZy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUgdW5kZXIgd2hpY2ggdG8gY2hlY2sgZm9yIG1ldGFkYXRhLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuDQogICAgICAgICAqLw0KICAgICAgICBnZXRNZXRhZGF0YShrZXkpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGFba2V5XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGVyZSBpcyBtZXRhZGF0YSBmb3IgYSBnaXZlbiBrZXkuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHZhbHVlIHVuZGVyIHdoaWNoIHRvIGNoZWNrIGZvciBtZXRhZGF0YS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIG1ldGFkYXRhIGV4aXN0cyB1bmRlciB0aGUgZ2l2ZW4ga2V5LCBvdGhlcndpc2UgcmV0dXJucyBgZmFsc2VgLg0KICAgICAgICAgKi8NCiAgICAgICAgaGFzTWV0YWRhdGEoa2V5KSB7DQogICAgICAgICAgICByZXR1cm4ga2V5IGluIHRoaXMuX19tZXRhRGF0YTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQXNzaWducyBtZXRhZGF0YSB0byBhIGdpdmVuIGtleS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUgdW5kZXIgd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGlzIGdvaW5nIHRvIGJlIHNhdmVkLg0KICAgICAgICAgKiBAcGFyYW0gbWV0YURhdGEgLSBUaGUgbWV0YURhdGEgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRNZXRhZGF0YShrZXksIG1ldGFEYXRhKSB7DQogICAgICAgICAgICB0aGlzLl9fbWV0YURhdGFba2V5XSA9IG1ldGFEYXRhOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZW1vdmVzIG1ldGFkYXRhIGZvciBhIGdpdmVuIGtleS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBkZWxldGVNZXRhZGF0YShrZXkpIHsNCiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fbWV0YURhdGFba2V5XTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBFbmNvZGVzIHRoZSBjdXJyZW50IG9iamVjdCBhcyBhIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QganNvbiA9IHsNCiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLA0KICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX19uYW1lLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIHJldHVybiBqc29uOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGpzb24gLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oanNvbiwgY29udGV4dCkgew0KICAgICAgICAgICAgaWYgKGpzb24ubmFtZSkNCiAgICAgICAgICAgICAgICB0aGlzLl9fbmFtZSA9IGpzb24ubmFtZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IEl0ZW0oSW5jbHVkaW5nIHBhcmFtZXRlcnMpIHVzaW5nIGEgYmluYXJ5IHJlYWRlciBvYmplY3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIC8vIHJlYWQgdGhlIHR5cGUsIGJ1dCBkb24ndCB1c2UgaXQuIFRoaXMgbGluZSBtdXN0IG5vdCBiZSByZW1vdmVkLg0KICAgICAgICAgICAgLy8gYXMgdGhlIGJpbmFyeSBwb2ludGVyIGlzIGluY3JlbWVudGVkLg0KICAgICAgICAgICAgLypjb25zdCB0eXBlID0gKi8gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICAgICAgICAgIHRoaXMuc2V0TmFtZShyZWFkZXIubG9hZFN0cigpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29udmVydHMgb2JqZWN0J3MgSlNPTiB2YWx1ZSBhbmQgY29udmVydHMgaXQgdG8gYSBzdHJpbmcuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0DQogICAgICAgICAqIEByZXR1cm4gLSBTdHJpbmcgb2Ygb2JqZWN0J3MgcGFyYW1ldGVyIGxpc3Qgc3RhdGUuDQogICAgICAgICAqLw0KICAgICAgICB0b1N0cmluZyhjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgMik7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBDbG9uZSBhbmQgRGVzdHJveQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2xvbmVzIHRoaXMgYmFzZSBpdGVtIGFuZCByZXR1cm5zIGEgbmV3IGJhc2UgaXRlbS4NCiAgICAgICAgICoNCiAgICAgICAgICogKipOb3RlOioqIEVhY2ggY2xhc3Mgc2hvdWxkIGltcGxlbWVudCBjbG9uZSB0byBiZSBjbG9uYWJsZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnIGRvZXMgbm90IGltcGxlbWVudCBpdHMgY2xvbmUgbWV0aG9kJyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFdoZW4gYSBCYXNlSXRlbSBpcyBjbG9uZWQsIGluaXRpYWxseSB0aGUgY29uc3RydWN0b3IgaXMNCiAgICAgICAgICogY2FsbGVkIHRvIGdlbmVyYXRlIGEgbmV3IGluc3RhbmNlLiBUaGlzIGluc3RhbmNlIHRoZW4gY29waWVzDQogICAgICAgICAqIGl0cyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHVzaW5nIHRoaXMgbWV0aG9kLg0KICAgICAgICAgKiBUaGlzIG1ldGhvZCBjb3BpZXMgYW55IHJlbGV2YW50IGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdCB0bw0KICAgICAgICAgKiBlbnN1cmUgdGhhdCBpdCByZXByZXNlbnRzIGEgdmFsaWQgY2xvbmUuDQogICAgICAgICAqIERlcml2ZWQgY2xhc3NlcyBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjb3B5IGFueSByZWxldmFudA0KICAgICAgICAgKiBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzcmMgLSBUaGUgQmFzZUl0ZW0gdG8gY29weSBmcm9tLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBjb3B5RnJvbShzcmMsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuc2V0TmFtZShzcmMuZ2V0TmFtZSgpKTsNCiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0YWJsZShzcmMuaXNTZWxlY3RhYmxlKCkpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKg0KICAgICAqIENsYXNzIHRoYXQgYWxsb3dzIG90aGVyIGNsYXNzZXMgdG8gYmUgcGFyYW1ldGVyaXplZCBieSBgUGFyYW1ldGVyYCB0eXBlIG9mIG9iamVjdHMuDQogICAgICogTm90IG9ubHkgaG9zdGluZyBwYXJhbWV0ZXJzLCBidXQgdGhlaXIgZXZlbnRzLg0KICAgICAqDQogICAgICogQGV4dGVuZHMge0Jhc2VJdGVtfQ0KICAgICAqLw0KICAgIGNsYXNzIFBhcmFtZXRlck93bmVyIGV4dGVuZHMgQmFzZUl0ZW0gew0KICAgICAgICBwYXJhbUV2ZW50TGlzdGVuZXJJRHMgPSB7fTsNCiAgICAgICAgcGFyYW1NYXBwaW5nID0ge307DQogICAgICAgIHBhcmFtcyA9IFtdOw0KICAgICAgICBkZXByZWNhdGVkUGFyYW1NYXBwaW5nID0ge307DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBhcmFtZXRlck93bmVyIGJ5IGluaXRpYWxpemluZyBwYXJhbWV0ZXIgaG9zdGluZyBtYXBwaW5ncyBhbmQgZXZlbnRzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBFdmVyeSBPYmplY3QgaGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgd2hpY2ggaXMgYmFzZWQgb24gYSBjb3VudGVyIHRoYXQgaXMgaW5jcmVtZW50ZWQuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgY3VycmVudCBvYmplY3QgaGFzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TnVtUGFyYW1ldGVycygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5sZW5ndGg7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGN1cnJlbnQgb2JqZWN0IGhhcy4NCiAgICAgICAgICovDQogICAgICAgIGdldCBudW1QYXJhbWV0ZXJzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmxlbmd0aDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFBhcmFtZXRlciBMaXN0DQogICAgICAgICAqLw0KICAgICAgICBnZXRQYXJhbWV0ZXJzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIHBhcmFtZXRlciBpbiBwYXJhbWV0ZXIgbGlzdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHBhcmFtTmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICogQHJldHVybiAtIFBvc2l0aW9uIGluIHRoZSBhcnJheQ0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1OYW1lKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbU1hcHBpbmdbcGFyYW1OYW1lXTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBgUGFyYW1ldGVyYCBvYmplY3QgaW4gYSBnaXZlbiBpbmRleA0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBQb3NpdGlvbiBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBhcnJheQ0KICAgICAgICAgKiBAcmV0dXJuIC0gUGFyYW1ldGVyIG9iamVjdCB2YWx1ZQ0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0UGFyYW1ldGVyQnlJbmRleChpbmRleCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zW2luZGV4XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVmFsaWRhdGVzIGlmIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIGV4aXN0cyBpbiB0aGUgb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGhhc1BhcmFtZXRlcihwYXJhbU5hbWUpIHsNCiAgICAgICAgICAgIHJldHVybiBwYXJhbU5hbWUgaW4gdGhpcy5wYXJhbU1hcHBpbmc7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZCBhIG1hcHBpbmcgZnJvbSBvbmUgbmFtZSB0byBhIG5ldyBwYXJhbWV0ZXIuDQogICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBoYW5kbGUgbWlncmF0aW5nIHBhcmFtZXRlcnMgdG8gbmV3IG5hbWVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIHBhcmFtZXRlciBuYW1lLg0KICAgICAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGFkZFBhcmFtZXRlckRlcHJlY2F0aW9uTWFwcGluZyhrZXksIHBhcmFtTmFtZSkgew0KICAgICAgICAgICAgdGhpcy5kZXByZWNhdGVkUGFyYW1NYXBwaW5nW2tleV0gPSBwYXJhbU5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgYFBhcmFtZXRlcmAgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBuYW1lDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBwYXJhbU5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuDQogICAgICAgICAqIEByZXR1cm4gLSBQYXJhbWV0ZXIgb2JqZWN0IHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBnZXRQYXJhbWV0ZXIocGFyYW1OYW1lKSB7DQogICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmFtTWFwcGluZ1twYXJhbU5hbWVdOw0KICAgICAgICAgICAgaWYgKGluZGV4ID09IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtTmFtZSA9IHRoaXMuZGVwcmVjYXRlZFBhcmFtTWFwcGluZ1twYXJhbU5hbWVdOw0KICAgICAgICAgICAgICAgIGlmICghbmV3UGFyYW1OYW1lKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIG1ldGhvZCBub3QgcmV0dXJuIG51bGw/DQogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOw0KICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBFcnJvcihgTm8gUGFyYW1ldGVyIHdpdGggdGhhdCBuYW1lIGV4aXN0czogJHtwYXJhbU5hbWV9IGApDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFBhcmFtZXRlciBuYW1lICR7cGFyYW1OYW1lfSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAke25ld1BhcmFtTmFtZX0gaW5zdGVhZC5gKTsNCiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnBhcmFtTWFwcGluZ1tuZXdQYXJhbU5hbWVdOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtc1tpbmRleF07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3Nlcw0KICAgICAgICAgKiB0byBwZXJmb3JtIGdlbmVyYWwgdXBkYXRlcyAoc2VlIEdMUGFzcyBvciBCYXNlSXRlbSkuDQogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKi8NCiAgICAgICAgcGFyYW1ldGVyVmFsdWVDaGFuZ2VkKGV2ZW50KSB7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3BhcmFtZXRlclZhbHVlQ2hhbmdlZCcsIGV2ZW50KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBgUGFyYW1ldGVyYCBvYmplY3QgdG8gdGhlIG93bmVyJ3MgcGFyYW1ldGVyIGxpc3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBlbWl0cyBgcGFyYW1ldGVyQWRkZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIGFkZC4NCiAgICAgICAgICogQHJldHVybiAtIFdpdGggYG93bmVyYCBhbmQgYHZhbHVlQ2hhbmdlZGAgZXZlbnQgc2V0Lg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkUGFyYW1ldGVyKHBhcmFtKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRQYXJhbWV0ZXIocGFyYW0sIHRoaXMucGFyYW1zLmxlbmd0aCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgYFBhcmFtZXRlcmAgb2JqZWN0IHRvIHRoZSBvd25lcidzIHBhcmFtZXRlciBsaXN0IHVzaW5nIHRoZSBpbmRleC4NCiAgICAgICAgICogSXQgcmVwbGFjZXMgdGhlIGV2ZW50IGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqDQogICAgICAgICAqIEBlbWl0cyBgcGFyYW1ldGVyQWRkZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIGluc2VydC4NCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gV2l0aCBgb3duZXJgIGFuZCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuDQogICAgICAgICAqLw0KICAgICAgICBpbnNlcnRQYXJhbWV0ZXIocGFyYW0sIGluZGV4KSB7DQogICAgICAgICAgICBjb25zdCBuYW1lID0gcGFyYW0uZ2V0TmFtZSgpOw0KICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1NYXBwaW5nW25hbWVdICE9IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVwbGFjaW5nIFBhcmFtZXRlcjonICsgbmFtZSk7DQogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBwYXJhbS5zZXRPd25lcih0aGlzKTsNCiAgICAgICAgICAgIHRoaXMucGFyYW1FdmVudExpc3RlbmVySURzW25hbWVdID0gcGFyYW0ub24oJ3ZhbHVlQ2hhbmdlZCcsIChldmVudCkgPT4gew0KICAgICAgICAgICAgICAgIC8vIE5vdGU6IHNwcmVhZCBvcGVyYXRvcnMgY2F1c2UgZXJyb3JzIG9uIGlPUyAxMS4NCiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IHsgcGFyYW0gfTsNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudCkNCiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRba2V5XSA9IGV2ZW50W2tleV07DQogICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJWYWx1ZUNoYW5nZWQobmV3RXZlbnQpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB0aGlzLnBhcmFtcy5zcGxpY2UoaW5kZXgsIDAsIHBhcmFtKTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMucGFyYW1zLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5wYXJhbU1hcHBpbmdbdGhpcy5wYXJhbXNbaV0uZ2V0TmFtZSgpXSA9IGk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBQYXJhbWV0ZXJBZGRlZEV2ZW50KG5hbWUpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJBZGRlZCcsIGV2ZW50KTsNCiAgICAgICAgICAgIHJldHVybiBwYXJhbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmVtb3ZlcyBgUGFyYW1ldGVyYCBmcm9tIG93bmVyLCBieSB1c2luZyBwYXJhbWV0ZXIncyBuYW1lLg0KICAgICAgICAgKiBAZW1pdHMgYHBhcmFtZXRlclJlbW92ZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS4NCiAgICAgICAgICovDQogICAgICAgIHJlbW92ZVBhcmFtZXRlcihuYW1lKSB7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbU1hcHBpbmdbbmFtZV0gPT0gdW5kZWZpbmVkKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVtb3ZlIFBhcmFtZXRlcjonICsgbmFtZSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyYW1NYXBwaW5nW25hbWVdOw0KICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLnBhcmFtc1t0aGlzLnBhcmFtTWFwcGluZ1tuYW1lXV07DQogICAgICAgICAgICBwYXJhbS5vZmYoJ3ZhbHVlQ2hhbmdlZCcsIHRoaXMucGFyYW1FdmVudExpc3RlbmVySURzW25hbWVdKTsNCiAgICAgICAgICAgIHRoaXMucGFyYW1zLnNwbGljZShpbmRleCwgMSk7DQogICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJhbU1hcHBpbmdbbmFtZV07DQogICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHRoaXMucGFyYW1NYXBwaW5nW3RoaXMucGFyYW1zW2ldLmdldE5hbWUoKV0gPSBpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUGFyYW1ldGVyUmVtb3ZlZEV2ZW50KG5hbWUpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJSZW1vdmVkJywgZXZlbnQpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXBsYWNlcyBvbGQgYFBhcmFtZXRlcmAgYnkgcGFzc2luZyBhIG5ldyBvbmUgd2l0aCB0aGUgc2FtZSBuYW1lLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcGFyYW0gLSBUaGUgcGFyYW1ldGVyIHRvIHJlcGxhY2UuDQogICAgICAgICAqIEByZXR1cm4gLSBgUGFyYW1ldGVyYCB3aXRoIGB2YWx1ZUNoYW5nZWRgIGV2ZW50IHNldC4NCiAgICAgICAgICovDQogICAgICAgIHJlcGxhY2VQYXJhbWV0ZXIocGFyYW0pIHsNCiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbS5nZXROYW1lKCk7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbU1hcHBpbmdbbmFtZV0gPT0gdW5kZWZpbmVkKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVwbGFjZSBQYXJhbWV0ZXI6JyArIG5hbWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhcmFtTWFwcGluZ1tuYW1lXTsNCiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpOw0KICAgICAgICAgICAgdGhpcy5pbnNlcnRQYXJhbWV0ZXIocGFyYW0sIGluZGV4KTsNCiAgICAgICAgICAgIHJldHVybiBwYXJhbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlc29sdmVQYXRoIG1ldGhvZCB0cmF2ZXJzZXMgdGhlIHN1YnRyZWUgZnJvbSB0aGlzIGl0ZW0gZG93bg0KICAgICAgICAgKiBtYXRjaGluZyBlYWNoIG5hbWUgaW4gdGhlIHBhdGggd2l0aCBhIGNoaWxkIHVudGlsIGl0IHJlYWNoZXMgdGhlDQogICAgICAgICAqIGVuZCBvZiB0aGUgcGF0aC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlc29sdmVQYXRoKHBhdGgsIGluZGV4ID0gMCkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID09IDApIHsNCiAgICAgICAgICAgICAgICBpZiAocGF0aFswXSA9PSAnLicgfHwgcGF0aFswXSA9PSB0aGlzLl9fbmFtZSkNCiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChwYXRoW2luZGV4XSA9PSAnLi4nKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0pIHsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vd25lckl0ZW0ucmVzb2x2ZVBhdGgocGF0aCwgaW5kZXggKyAxKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0aGlzLl9fb3duZXJJdGVtIGlzIHVuZGVmaW5lZCcpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChpbmRleCA9PSBwYXRoLmxlbmd0aCkgew0KICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gTWF5YmUgdGhlIG5hbWUgaXMgYSBwYXJhbWV0ZXIgbmFtZS4NCiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIocGF0aFtpbmRleF0pOw0KICAgICAgICAgICAgaWYgKHBhcmFtKSB7DQogICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGF0aC5sZW5ndGgpIHsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnJlc29sdmVQYXRoKHBhdGgsIGluZGV4ICsgMSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgcGF0aCA6IFske3BhdGgudG9TdHJpbmcoKX1dIGFmdGVyOiAke3RoaXMuZ2V0TmFtZSgpfSBcbk5vIGNoaWxkIG9yIHBhcmFtZXRlciBjYWxsZWQgOiAiJHtwYXRoW2luZGV4XX0iYCk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKGNvbnRleHQpOw0KICAgICAgICAgICAgY29uc3QgcGFyYW1zSlNPTiA9IHt9Ow0KICAgICAgICAgICAgbGV0IHNhdmVkUGFyYW1zID0gMDsNCiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5wYXJhbXMpIHsNCiAgICAgICAgICAgICAgICBpZiAocGFyYW0uaXNEcml2ZW5CeU9wZXJhdG9yKCkpDQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtSlNPTiA9IHBhcmFtLnRvSlNPTihjb250ZXh0KTsNCiAgICAgICAgICAgICAgICBpZiAocGFyYW1KU09OKSB7DQogICAgICAgICAgICAgICAgICAgIHBhcmFtc0pTT05bcGFyYW0uZ2V0TmFtZSgpXSA9IHBhcmFtSlNPTjsNCiAgICAgICAgICAgICAgICAgICAgc2F2ZWRQYXJhbXMrKzsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoc2F2ZWRQYXJhbXMgPiAwKQ0KICAgICAgICAgICAgICAgIGpzb24ucGFyYW1zID0gcGFyYW1zSlNPTjsNCiAgICAgICAgICAgIHJldHVybiBqc29uOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ganNvbiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqc29uLCBjb250ZXh0KSB7DQogICAgICAgICAgICBzdXBlci5mcm9tSlNPTihqc29uLCBjb250ZXh0KTsNCiAgICAgICAgICAgIGlmIChqc29uLnBhcmFtcykgew0KICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGpzb24ucGFyYW1zKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHBqID0ganNvbi5wYXJhbXNba2V5XTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKHBqLnBhcmFtUGF0aCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dD8ucmVzb2x2ZVBhdGgocGoucGFyYW1QYXRoLCAocGFyYW0pID0+IHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VQYXJhbWV0ZXIocGFyYW0pOw0KICAgICAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4gew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHJlc29sdmUgc2hhcmVkIHBhcmFtZXRlcjonICsgcGoucGFyYW1QYXRoKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoa2V5KTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0gJiYgcGoudHlwZSAmJiBwai5uYW1lKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSBSZWdpc3RyeS5jb25zdHJ1Y3RDbGFzcyhwai50eXBlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBjb25zdHJ1Y3QgcHJvcDonICsgcGoubmFtZSArICcgb2YgdHlwZTonICsgcGoudHlwZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zZXROYW1lKHBqLm5hbWUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHBhcmFtKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5mcm9tSlNPTihwaiwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFVzZXMgcGFzc2VkIGluIEJpblJlYWRlciBvYmplY3QoY29udGFpbmluZyBhbiBJbnQzMiBhcnJheSB3aXRoIGFsbCB0aGUgcGFyYW1ldGVycykgdG8gcmVjb25zdHJ1Y3QgYWxsIHBhcmFtZXRlcnMgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEluIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBhcnJheSwgcHJvcFR5cGUgYW5kIHByb3BOYW1lIGFyZSBleHRyYWN0ZWQgYW5kDQogICAgICAgICAqIHVzZWQgdG8gYnVpbGQgdGhlIHJpZ2h0IGBQYXJhbWV0ZXJgIGNsYXNzLiBUaGVuIGFsbCBvZiB0aGVtIGFyZSBhZGRlZCB0byB0aGUgb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAZW1pdHMgYHBhcmFtZXRlckFkZGVkYCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJhbS4NCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgc3VwZXIucmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpOw0KICAgICAgICAgICAgdGhpcy5yZWFkQmluYXJ5UGFyYW1zKHJlYWRlciwgY29udGV4dCk7DQogICAgICAgIH0NCiAgICAgICAgcmVhZEJpbmFyeVBhcmFtcyhyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIGlmIChjb250ZXh0Py52ZXJzaW9uc1snemVhLWVuZ2luZSddLmNvbXBhcmUoWzAsIDAsIDNdKSA+PSAwKSB7DQogICAgICAgICAgICAgICAgY29uc3QgbnVtUHJvcHMgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJvcHM7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHJlYWRlci5sb2FkU3RyKCk7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIocHJvcE5hbWUpOw0KICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKHByb3BUeXBlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0pIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gY29uc3RydWN0IHByb3A6JyArIHByb3BOYW1lICsgJyBvZiB0eXBlOicgKyBwcm9wVHlwZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zZXROYW1lKHByb3BOYW1lKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHBhcmFtKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gQ2xvbmUgYW5kIERlc3Ryb3kNCiAgICAgICAgLyoqDQogICAgICAgICAqIENsb25lcyB0aGlzIGJhc2UgaXRlbSBhbmQgcmV0dXJucyBhIG5ldyBiYXNlIGl0ZW0uDQogICAgICAgICAqDQogICAgICAgICAqICoqTm90ZToqKiBFYWNoIGNsYXNzIHNob3VsZCBpbXBsZW1lbnQgY2xvbmUgdG8gYmUgY2xvbmFibGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZShjb250ZXh0KSB7DQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIGNsb25lIG1ldGhvZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb3BpZXMgUGFyYW1ldGVycyBmcm9tIGFub3RoZXIgYFBhcmFtZXRlck93bmVyYCB0byBjdXJyZW50IG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNyYyAtIFRoZSBQYXJhbWV0ZXJPd25lciBjb3B5IGZyb20uDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUNCiAgICAgICAgICovDQogICAgICAgIGNvcHlGcm9tKHNyYywgY29udGV4dCkgew0KICAgICAgICAgICAgc3VwZXIuY29weUZyb20oc3JjLCBjb250ZXh0KTsNCiAgICAgICAgICAgIC8vIE5vdGU6IExvb3Agb3ZlciB0aGUgcGFyYW1ldGVycyBpbiByZXZlcnNlIG9yZGVyLA0KICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIG9mdGVuLCBwYXJhbWV0ZXIgZGVwZW5kZW5jaWVzDQogICAgICAgICAgICAvLyBhcmUgYm90dG9tIHRvIHRvcCAoYm90dG9tIHBhcmFtcyBkZXBlbmRlbnQgb24gaGlnaGVyIHBhcmFtcykuDQogICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgYXMgYSBwYXJhbWV0ZXIgaXMgc2V0IHdpdGggYSBuZXcgdmFsdWUNCiAgICAgICAgICAgIC8vIGl0IHdpbGwgZGlydHkgdGhlIHBhcmFtcyBiZWxvdyBpdC4NCiAgICAgICAgICAgIGxldCBpID0gc3JjLmdldE51bVBhcmFtZXRlcnMoKTsNCiAgICAgICAgICAgIHdoaWxlIChpLS0pIHsNCiAgICAgICAgICAgICAgICBjb25zdCBzcmNQYXJhbSA9IHNyYy5nZXRQYXJhbWV0ZXJCeUluZGV4KGkpOw0KICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoc3JjUGFyYW0uZ2V0TmFtZSgpKTsNCiAgICAgICAgICAgICAgICBpZiAocGFyYW0pIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBjbG9uaW5nIHRoZSB2YWx1ZXMuDQogICAgICAgICAgICAgICAgICAgIHBhcmFtLmNvcHlGcm9tKHNyY1BhcmFtKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHNyY1BhcmFtLmNsb25lKCkpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgZnVuY3Rpb24gYXBwcm94RXF1YWwoYSwgYikgew0KICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgIGlmIChNYXRoLmFicyhiW2ldIC0gYVtpXSkgPiAwLjAwMSkNCiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgfQ0KICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgfQ0KICAgIGNvbnN0IHJlc2l6ZUFycmF5ID0gKGluQXJyYXksIG5ld1NpemUpID0+IHsNCiAgICAgICAgaWYgKGluQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7DQogICAgICAgICAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50OEFycmF5KG5ld1NpemUpOw0KICAgICAgICAgICAgbmV3QXJyYXkuc2V0KGluQXJyYXkpOw0KICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5Ow0KICAgICAgICB9DQogICAgICAgIGVsc2UgaWYgKGluQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIHsNCiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IEludDhBcnJheShuZXdTaXplKTsNCiAgICAgICAgICAgIG5ld0FycmF5LnNldChpbkFycmF5KTsNCiAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTsNCiAgICAgICAgfQ0KICAgICAgICBlbHNlIGlmIChpbkFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHsNCiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpOw0KICAgICAgICAgICAgbmV3QXJyYXkuc2V0KGluQXJyYXkpOw0KICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5Ow0KICAgICAgICB9DQogICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1NpemUpOw0KICAgICAgICAgICAgbmV3QXJyYXkuc2V0KGluQXJyYXkpOw0KICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5Ow0KICAgICAgICB9DQogICAgfTsNCiAgICBjbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBCYXNlQ2xhc3Mgew0KICAgICAgICBkYXRhVHlwZU5hbWU7DQogICAgICAgIHN0cmlkZTsNCiAgICAgICAgaW5pdFZhbHVlID0gTnVtYmVyLk5hTjsNCiAgICAgICAgbm9ybWFsaXplZDsNCiAgICAgICAgZGF0YTsNCiAgICAgICAgbWVzaDsNCiAgICAgICAgc3BsaXRWYWx1ZXMgPSBbXTsNCiAgICAgICAgc3BsaXRzID0ge307DQogICAgICAgIGNvbnN0cnVjdG9yKGRhdGFUeXBlTmFtZSwgc3RyaWRlLCBpbml0VmFsdWUgPSBOdW1iZXIuTmFOKSB7DQogICAgICAgICAgICBzdXBlcigpOw0KICAgICAgICAgICAgdGhpcy5kYXRhVHlwZU5hbWUgPSBkYXRhVHlwZU5hbWU7DQogICAgICAgICAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTsNCiAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlID0gaW5pdFZhbHVlOw0KICAgICAgICAgICAgdGhpcy5pbml0KCk7DQogICAgICAgIH0NCiAgICAgICAgaW5pdCgpIHsNCiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMCk7DQogICAgICAgICAgICB0aGlzLmluaXRSYW5nZSgwKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgTWVzaCByZWZlcmVuY2UgdG8gdGhlIFZlcnRleEF0dHJpYnV0ZS4gVGhpcyBpcyBuZWVkZWQgZm9yIGF0dHJpYnV0ZXMNCiAgICAgICAgICogYXNzaWduZWQgdG8gbWVzaGVzLCBhbmQgaXMgdXNlZCB0byBjYWxjdWxhdGUgZmFjZSB2ZXJ0ZXggaW5kaWNlcy4NCiAgICAgICAgICogPiBOb3RlOiB0aGUgbWVzaCBhdXRvbWF0aWNhbGx5IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gYSB2ZXJ0ZXggYXR0cmlidXRlIGlzIGFzc2lnbmVkLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbWVzaCAtIFRoZSBtZXNoIG9iamVjdA0KICAgICAgICAgKi8NCiAgICAgICAgc2V0TWVzaChtZXNoKSB7DQogICAgICAgICAgICB0aGlzLm1lc2ggPSBtZXNoOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBiYWNraW5nIGFycmF5IGZvciB0aGlzIGF0dHJpYnV0ZQ0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGFzQXJyYXkoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBtYXRoIHR5cGUgdGhpcyBhdHRyaWJ1dGUgc3RvcmVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldERhdGFUeXBlTmFtZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFUeXBlTmFtZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgY291bnQgb2YgYXR0cmlidXRlIHZhbHVlcyBpbiB0aGUgZGF0YS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRDb3VudCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGNvdW50IG9mIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gdGhlIGRhdGEuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IGNvdW50KCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgY291bnQgb2YgYXR0cmlidXRlIHZhbHVlcyBpbiB0aGUgZGF0YS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldENvdW50KGNvdW50KSB7DQogICAgICAgICAgICBjb25zdCBwcmV2TGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDsNCiAgICAgICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGNvdW50ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICBpZiAobmV3TGVuZ3RoID4gcHJldkxlbmd0aCkgew0KICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHJlc2l6ZUFycmF5KHRoaXMuZGF0YSwgbmV3TGVuZ3RoKTsNCiAgICAgICAgICAgICAgICB0aGlzLmluaXRSYW5nZShwcmV2TGVuZ3RoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKG5ld0xlbmd0aCA8IHByZXZMZW5ndGgpIHsNCiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoMCwgbmV3TGVuZ3RoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgOw0KICAgICAgICAgICAgdGhpcy5zcGxpdHMgPSB7fTsNCiAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMgPSBbXTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRmlsbHMgdXAgZGF0YSB2YWx1ZXMgd2l0aCBkZWZhdWx0IG9uZXMgc3RhcnRpbmcgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBpbml0UmFuZ2Uoc3RhcnQpIHsNCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlcyB0byBpbnZhbGlkIHZhbHVlcy4NCiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IHRoaXMuaW5pdFZhbHVlOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGlzSW5pdGlhbGl6ZWQoYSkgew0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgaWYgKGFbaV0gIT0gdGhpcy5pbml0VmFsdWUpDQogICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIGZhbHNlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc3RvcmVkIGluIGVhY2ggYFRgLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldCBudW1FbGVtZW50cygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmlkZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBkYXRhIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRGbG9hdDMyVmFsdWUoaW5kZXgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIGRhdGEgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRGbG9hdDMyVmFsdWUoaW5kZXgsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgZGF0YSB2YWx1ZXMgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlcyhpbmRleCkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSkNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIGRhdGEgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqLw0KICAgICAgICBzZXRWYWx1ZXMoaW5kZXgsIHZhbHVlcykgew0KICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSkNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHZhbHVlcywgb2Zmc2V0KTsNCiAgICAgICAgfQ0KICAgICAgICBtZXJnZShvdGhlciwgeGZvID0gbmV3IFhmbygpKSB7DQogICAgICAgICAgICBjb25zdCBwcmV2TnVtVmFsdWVzID0gdGhpcy5kYXRhLmxlbmd0aDsNCiAgICAgICAgICAgIGNvbnN0IGFkZGVkVmFsdWVzID0gb3RoZXIuZGF0YS5sZW5ndGg7DQogICAgICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBwcmV2TnVtVmFsdWVzICsgYWRkZWRWYWx1ZXM7DQogICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShuZXdMZW5ndGgpOw0KICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5kYXRhLCAwKTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkZWRWYWx1ZXM7IGkrKykgew0KICAgICAgICAgICAgICAgIGRhdGFbcHJldk51bVZhbHVlcyArIGldID0gb3RoZXIuZGF0YVtpXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7DQogICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzID0gWy4uLnRoaXMuc3BsaXRWYWx1ZXMsIC4uLm90aGVyLnNwbGl0VmFsdWVzXTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBGYWNlIFZlcnRleCBWYWx1ZXMNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRTcGxpdHMgbWV0aG9kLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldFNwbGl0cygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0czsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgpIHsNCiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHRoaXMubWVzaC5nZXRGYWNlVmVydGV4SW5kZXgoZmFjZSwgZmFjZVZlcnRleCk7DQogICAgICAgICAgICBpZiAodmVydGV4IGluIHRoaXMuc3BsaXRzICYmIGZhY2UgaW4gdGhpcy5zcGxpdHNbdmVydGV4XSkgew0KICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0VmFsdWVzW3RoaXMuc3BsaXRzW3ZlcnRleF1bZmFjZV1dOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJhcnJheSh2ZXJ0ZXggKiB0aGlzLnN0cmlkZSwgKHZlcnRleCArIDEpICogdGhpcy5zdHJpZGUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgsIHZhbHVlKSB7DQogICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLm1lc2guZ2V0RmFjZVZlcnRleEluZGV4KGZhY2UsIGZhY2VWZXJ0ZXgpOw0KICAgICAgICAgICAgdGhpcy5zZXRGYWNlVmVydGV4VmFsdWVfQnlWZXJ0ZXhJbmRleChmYWNlLCB2ZXJ0ZXgsIHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4IG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpIHsNCiAgICAgICAgICAgIGNvbnN0IGN1cnJWYWx1ZSA9IHRoaXMuZGF0YS5zdWJhcnJheSh2ZXJ0ZXggKiB0aGlzLnN0cmlkZSwgKHZlcnRleCArIDEpICogdGhpcy5zdHJpZGUpOw0KICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQoY3VyclZhbHVlKSkgew0KICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBpcyB1bmluaXRpYWxpemVkLiBJbml0aWFsaXplIGl0Lg0KICAgICAgICAgICAgICAgIGN1cnJWYWx1ZS5zZXQodmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSBpZiAoYXBwcm94RXF1YWwoY3VyclZhbHVlLCB2YWx1ZSkpIDsNCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHZhbHVlDQogICAgICAgICAgICAgICAgaWYgKHZlcnRleCBpbiB0aGlzLnNwbGl0cykgew0KICAgICAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGV4aXN0aW5nIHNwbGl0cyBmb3IgdGhpcyB2ZXJ0ZXggbWF0Y2ggdGhlIHZhbHVlIGJlaW5nIHNldC4NCiAgICAgICAgICAgICAgICAgICAgLy8gaS5lLiBmb3IgZmFjZXMgYXJvdW5kIGEgdmVydGV4LCB0aGVyZSB3aWxsIG9mdGVuIGJlIGEgc2VhbSBhbG9uZyAyIGVkZ2VzDQogICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRoZSB2YWx1ZXMgZGlmZmVyLiBPbiBlYWNoIHNpZGUgb2YgdGhlIHNlYW0sIGFsbCBmYWNlcyBjYW4gdXNlIHRoZSBzYW1lDQogICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlLiBXZSBzaG91bGQgc2VlIHRoZW4gb25seSBvbmUgc3BsaXQgdmFsdWUgZm9yIHRoZSB2ZXJ0ZXguDQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleFNwbGl0SWRzID0gdGhpcy5zcGxpdHNbdmVydGV4XTsNCiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWQgaW4gdmVydGV4U3BsaXRJZHMpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0SWQgPSB2ZXJ0ZXhTcGxpdElkc1tmaWRdOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveEVxdWFsKHRoaXMuc3BsaXRWYWx1ZXNbc3BsaXRJZF0sIHZhbHVlKSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLXVzZSB0aGlzIHNwbGl0IHZhbHVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4U3BsaXRJZHNbZmFjZV0gPSBzcGxpdElkOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHNwbGl0IGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGZhY2UsIHJlLXVzZSBpdC4NCiAgICAgICAgICAgICAgICAgICAgaWYgKGZhY2UgaW4gdGhpcy5zcGxpdHNbdmVydGV4XSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlc1t0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXSA9IHZhbHVlOw0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0c1t2ZXJ0ZXhdID0ge307DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRzW3ZlcnRleF1bZmFjZV0gPSB0aGlzLnNwbGl0VmFsdWVzLmxlbmd0aDsNCiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzLnB1c2godmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRTcGxpdFZlcnRleFZhbHVlX2FycmF5KHZlcnRleCwgZmFjZSwgdmFsdWUpIHsNCiAgICAgICAgICAgIGlmICghKHZlcnRleCBpbiB0aGlzLnNwbGl0cykpDQogICAgICAgICAgICAgICAgdGhpcy5zcGxpdHNbdmVydGV4XSA9IHt9Ow0KICAgICAgICAgICAgaWYgKGZhY2UgaW4gdGhpcy5zcGxpdHNbdmVydGV4XSkgew0KICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJWYWx1ZSA9IHRoaXMuc3BsaXRWYWx1ZXNbdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXV07DQogICAgICAgICAgICAgICAgaWYgKGFwcHJveEVxdWFsKGN1cnJWYWx1ZSwgdmFsdWUpKQ0KICAgICAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWNlIFZlcnRleCBBbHJlYWR5IFNwbGl0IHdpdGggZGlmZmVyZW50IHZhbHVlJyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdID0gdGhpcy5zcGxpdFZhbHVlcy5sZW5ndGg7DQogICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzLnB1c2godmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZXMgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gdmVydGV4IC0gVGhlIHZlcnRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2VHcm91cCAtIFRoZSBmYWNlR3JvdXAgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFNwbGl0VmVydGV4VmFsdWVzKHZlcnRleCwgZmFjZUdyb3VwLCB2YWx1ZXMpIHsNCiAgICAgICAgICAgIGlmICghKHZlcnRleCBpbiB0aGlzLnNwbGl0cykpDQogICAgICAgICAgICAgICAgdGhpcy5zcGxpdHNbdmVydGV4XSA9IHt9Ow0KICAgICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHRoaXMuc3BsaXRWYWx1ZXMubGVuZ3RoOw0KICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlcy5wdXNoKHZhbHVlcyk7DQogICAgICAgICAgICBmb3IgKGNvbnN0IGZhY2Ugb2YgZmFjZUdyb3VwKSB7DQogICAgICAgICAgICAgICAgLy8gaWYgKGZhY2UgaW4gdGhpcy5zcGxpdHNbdmVydGV4XSkgew0KICAgICAgICAgICAgICAgIC8vICAgICBsZXQgY3VyclZhbHVlID0gdGhpcy5zcGxpdFZhbHVlc1t0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXTsNCiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGN1cnJWYWx1ZS5hcHByb3hFcXVhbCh2YWx1ZSkpDQogICAgICAgICAgICAgICAgLy8gICAgICAgICByZXR1cm47DQogICAgICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUud2FybigiRmFjZSBWZXJ0ZXggQWxyZWFkeSBTcGxpdCB3aXRoIGRpZmZlcmVudCB2YWx1ZSIpOw0KICAgICAgICAgICAgICAgIC8vIH0NCiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdID0gc3BsaXRJbmRleDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdlbmVyYXRlU3BsaXRWYWx1ZXMgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gc3BsaXRJbmRpY2VzIC0gVGhlIHNwbGl0SW5kaWNlcyB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHNwbGl0Q291bnQgLSBUaGUgc3BsaXRDb3VudCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZW5lcmF0ZVNwbGl0VmFsdWVzKHNwbGl0SW5kaWNlcywgc3BsaXRDb3VudCkgew0KICAgICAgICAgICAgaWYgKHNwbGl0Q291bnQgPT0gMCkNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhOw0KICAgICAgICAgICAgY29uc3QgbnVtVW5TcGxpdFZhbHVlcyA9IHRoaXMuZ2V0Q291bnQoKTsNCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNpemVBcnJheSh0aGlzLmRhdGEsIChudW1VblNwbGl0VmFsdWVzICsgc3BsaXRDb3VudCkgKiB0aGlzLnN0cmlkZSk7DQogICAgICAgICAgICAvLyBOb3cgZHVwbGljYXRlIHRoZSBzcGxpdCB2YWx1ZXMgdG8gZ2VuZXJhdGUgYW4gYXR0cmlidXRlcyBhcnJheQ0KICAgICAgICAgICAgLy8gdXNpbmcgdGhlIHNoYXJlZCBzcGxpdHMgYWNyb3NzIGFsbCBhdHRyaWJ1dGVzLg0KICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbg0KICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzKSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmFjZXMgPSBzcGxpdEluZGljZXNbdmVydGV4XTsNCiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluDQogICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWNlIGluIGZhY2VzKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRndCA9IG51bVVuU3BsaXRWYWx1ZXMgKyBmYWNlc1tmYWNlXTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCBpbiB0aGlzLnNwbGl0cyAmJiBmYWNlIGluIHRoaXMuc3BsaXRzW3ZlcnRleF0pIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYXR0cmlidXRlIGhhcyBhIHNwbGl0IHZhbHVlIGluIGl0cyBhcnJheS4NCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG11c3QgdXNlIHRoYXQgdmFsdWUuLi4NCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuc3BsaXRzW3ZlcnRleF1bZmFjZV07DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmNBcnJheSA9IHRoaXMuc3BsaXRWYWx1ZXNbc3JjXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjQXJyYXkubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3RndCAqIHRoaXMuc3RyaWRlICsgaV0gPSBzcmNBcnJheVtpXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgZWFjaCBzY2FsYXIgdmFsdWUgdG8gdGhlIG5ldyBwbGFjZSBpbiB0aGUgYXJyYXkuDQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBwYXJzZUludCh2ZXJ0ZXgpOw0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLnN0cmlkZTsgZSsrKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVt0Z3QgKiB0aGlzLnN0cmlkZSArIGVdID0gdGhpcy5kYXRhW3NyYyAqIHRoaXMuc3RyaWRlICsgZV07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gZGF0YTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgZGF0YTogQXJyYXkuZnJvbSh0aGlzLmRhdGEpLA0KICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0aGlzLmRhdGFUeXBlTmFtZSwNCiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSwNCiAgICAgICAgICAgIH07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGopIHsNCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBqLmRhdGE7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgbG9hZFNwbGl0VmFsdWVzIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkU3BsaXRWYWx1ZXMocmVhZGVyKSB7DQogICAgICAgICAgICBjb25zdCBzcGxpdEluZGljZXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KCk7DQogICAgICAgICAgICBpZiAoc3BsaXRJbmRpY2VzLmxlbmd0aCA9PSAwKQ0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOw0KICAgICAgICAgICAgbGV0IG51bVNwbGl0VmFsdWVzID0gMDsNCiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7DQogICAgICAgICAgICAgICAgY29uc3QgdmVydGV4SWQgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdOw0KICAgICAgICAgICAgICAgIGNvbnN0IG51bVNwbGl0cyA9IHNwbGl0SW5kaWNlc1tvZmZzZXQrK107DQogICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRzID0ge307DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TcGxpdHM7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWNlSWQgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdOw0KICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdElkID0gc3BsaXRJbmRpY2VzW29mZnNldCsrXTsNCiAgICAgICAgICAgICAgICAgICAgc3BsaXRzW2ZhY2VJZF0gPSBzcGxpdElkOw0KICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRJZCA+PSBudW1TcGxpdFZhbHVlcykNCiAgICAgICAgICAgICAgICAgICAgICAgIG51bVNwbGl0VmFsdWVzID0gc3BsaXRJZCArIDE7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRzW3ZlcnRleElkXSA9IHNwbGl0czsNCiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID49IHNwbGl0SW5kaWNlcy5sZW5ndGgpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgZGltID0gdGhpcy5zdHJpZGU7DQogICAgICAgICAgICBjb25zdCBzcGxpdFZhbHVlcyA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KG51bVNwbGl0VmFsdWVzICogZGltKTsNCiAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMgPSBbXTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3BsaXRWYWx1ZXM7IGkrKykgew0KICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHNwbGl0VmFsdWVzLnNsaWNlKGkgKiBkaW0sIGkgKiBkaW0gKyBkaW0pOw0KICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMucHVzaCh2YWwpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCdzIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHRvU3RyaW5nKCkgew0KICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIDIpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gTWVtb3J5DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHZlcnRleCBhdHRyaWJ1dGVzIGJ1ZmZlcnMgYW5kIGl0cyBjb3VudC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZW5CdWZmZXIoKSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHZhbHVlczogdGhpcy5kYXRhLA0KICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLmdldENvdW50KCksDQogICAgICAgICAgICAgICAgZGltZW5zaW9uOiB0aGlzLnN0cmlkZSwNCiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5kYXRhVHlwZU5hbWUsDQogICAgICAgICAgICAgICAgbm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgIH0KCiAgICAvKioNCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gYXR0cmlidXRlLg0KICAgICAqLw0KICAgIGNsYXNzIFZlYzJBdHRyaWJ1dGUgZXh0ZW5kcyBBdHRyaWJ1dGUgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgVmVjMkF0dHJpYnV0ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKGRhdGFUeXBlTmFtZSA9ICdWZWMyJykgew0KICAgICAgICAgICAgc3VwZXIoZGF0YVR5cGVOYW1lLCAyKTsNCiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZCA9IGZhbHNlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBWZWMyIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzIgLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0VmFsdWUoaW5kZXgpIHsNCiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpDQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5kYXRhW29mZnNldF0sIHRoaXMuZGF0YVtvZmZzZXQgKyAxXSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgVmVjMiBhdCB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSkNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIDMpOw0KICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiB0aGlzLnN0cmlkZTsNCiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQodmFsdWUuYXNBcnJheSgpLCBvZmZzZXQpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLg0KICAgICAgICAgKiA+IE5vdGU6ICdSZWYnIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhIGluIHRoZSBhdHRyaWJ1dGUuDQogICAgICAgICAqID4gVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGNhdXNpbmcgdGhlIGF0dHJpYnV0ZXMgZGF0YSBpcyBjaGFuZ2VkLg0KICAgICAgICAgKiA+IE5vIG5lZWQgdG8gY2FsbCAnc2V0RmFjZVZlcnRleFZhbHVlJy4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RmFjZVZlcnRleFZhbHVlKGZhY2UsIGZhY2VWZXJ0ZXgpIHsNCiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gdGhpcy5nZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkoZmFjZSwgZmFjZVZlcnRleCk7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoYXJyYXlbMF0sIGFycmF5WzFdKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgdGhpcy5zZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkoZmFjZSwgZmFjZVZlcnRleCwgRmxvYXQzMkFycmF5LmZyb20odmFsdWUuYXNBcnJheSgpKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRTcGxpdFZlcnRleFZhbHVlIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFNwbGl0VmVydGV4VmFsdWUodmVydGV4LCBmYWNlLCB2YWx1ZSkgew0KICAgICAgICAgICAgdGhpcy5zZXRTcGxpdFZlcnRleFZhbHVlX2FycmF5KHZlcnRleCwgZmFjZSwgRmxvYXQzMkFycmF5LmZyb20odmFsdWUuYXNBcnJheSgpKSk7DQogICAgICAgIH0NCiAgICAgICAgbWVyZ2Uob3RoZXIsIHhmbyA9IG5ldyBYZm8oKSkgew0KICAgICAgICAgICAgY29uc3QgcHJldk51bVZhbHVlcyA9IHRoaXMuZ2V0Q291bnQoKTsNCiAgICAgICAgICAgIGNvbnN0IGFkZGVkVmFsdWVzID0gb3RoZXIuZ2V0Q291bnQoKTsNCiAgICAgICAgICAgIHRoaXMuc2V0Q291bnQocHJldk51bVZhbHVlcyArIGFkZGVkVmFsdWVzKTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkZWRWYWx1ZXM7IGkrKykgew0KICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUocHJldk51bVZhbHVlcyArIGksIG90aGVyLmdldFZhbHVlKGkpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMgPSBbLi4udGhpcy5zcGxpdFZhbHVlcywgLi4ub3RoZXIuc3BsaXRWYWx1ZXNdOw0KICAgICAgICB9DQogICAgfQ0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdWZWMyQXR0cmlidXRlJywgVmVjMkF0dHJpYnV0ZSk7CgogICAgY29uc3QgbWFwSW4kMiA9ICh2YWx1ZSkgPT4gew0KICAgICAgICByZXR1cm4gTWF0aEZ1bmN0aW9ucy5lbmNvZGUxNkJpdEZsb2F0KHZhbHVlKTsNCiAgICB9Ow0KICAgIGNvbnN0IG1hcE91dCQyID0gKHZhbHVlKSA9PiB7DQogICAgICAgIHJldHVybiBNYXRoRnVuY3Rpb25zLmRlY29kZTE2Qml0RmxvYXQodmFsdWUpOw0KICAgIH07DQogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGF0dHJpYnV0ZS4NCiAgICAgKi8NCiAgICBjbGFzcyBWZWMyZjE2QXR0cmlidXRlIGV4dGVuZHMgVmVjMkF0dHJpYnV0ZSB7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSBWZWMzZjhBdHRyaWJ1dGUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcigpIHsNCiAgICAgICAgICAgIHN1cGVyKCdWZWMyZjE2Jyk7DQogICAgICAgIH0NCiAgICAgICAgaW5pdCgpIHsNCiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MTZBcnJheSgwKTsNCiAgICAgICAgICAgIHRoaXMuaW5pdFJhbmdlKDApOw0KICAgICAgICB9DQogICAgICAgIGluaXRSYW5nZShzdGFydCkgew0KICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdmFsdWVzIHRvIGludmFsaWQgdmFsdWVzLg0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gbWFwSW4kMihOdW1iZXIuTmFOKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICBpc0luaXRpYWxpemVkKGEpIHsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobWFwT3V0JDIoYVtpXSkpKQ0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIFZlYzIgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzIgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKG1hcE91dCQyKHZhbHVlRGF0YVswXSksIG1hcE91dCQyKHZhbHVlRGF0YVsxXSkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIFZlYzIgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRWYWx1ZShpbmRleCwgdmFsdWUpIHsNCiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpDQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICBjb25zdCB2YWx1ZURhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLnN0cmlkZSk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMF0gPSBtYXBJbiQyKHZhbHVlLngpOw0KICAgICAgICAgICAgdmFsdWVEYXRhWzFdID0gbWFwSW4kMih2YWx1ZS55KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogPiBOb3RlOiAnUmVmJyBtZWFucyB0aGF0IHRoZSB2YWx1ZSBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBpbiB0aGUgYXR0cmlidXRlLg0KICAgICAgICAgKiA+IFRoZSBjb21wb25lbnRzIG9mIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBjYXVzaW5nIHRoZSBhdHRyaWJ1dGVzIGRhdGEgaXMgY2hhbmdlZC4NCiAgICAgICAgICogPiBObyBuZWVkIHRvIGNhbGwgJ3NldEZhY2VWZXJ0ZXhWYWx1ZScuDQogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguDQogICAgICAgICAqIEBwYXJhbSBmYWNlVmVydGV4IC0gVGhlIGluZGV4IG9mIHZlcnRleCB3aXRoaW4gdGhlIGZhY2UuIFswLi4uIG51bSBmYWNlIHZlcnRpY2VzXQ0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4KSB7DQogICAgICAgICAgICBjb25zdCBhcnJheSA9IHRoaXMuZ2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKG1hcE91dCQyKGFycmF5WzBdKSwgbWFwT3V0JDIoYXJyYXlbMV0pKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gbmV3IFVpbnQxNkFycmF5KDIpOw0KICAgICAgICAgICAgdmFsdWVEYXRhWzBdID0gbWFwSW4kMih2YWx1ZS54KTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVsxXSA9IG1hcEluJDIodmFsdWUueSk7DQogICAgICAgICAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZURhdGEpOw0KICAgICAgICB9DQogICAgfQoKICAgIGNsYXNzIFZlYzNSZWYgew0KICAgICAgICBkYXRhOw0KICAgICAgICBjb25zdHJ1Y3RvcihkYXRhKSB7DQogICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhOw0KICAgICAgICB9DQogICAgICAgIGdldCB4KCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTsNCiAgICAgICAgfQ0KICAgICAgICBzZXQgeCh2YWx1ZSkgew0KICAgICAgICAgICAgdGhpcy5kYXRhWzBdID0gdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgZ2V0IHkoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzFdOw0KICAgICAgICB9DQogICAgICAgIHNldCB5KHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSB2YWx1ZTsNCiAgICAgICAgfQ0KICAgICAgICBnZXQgeigpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07DQogICAgICAgIH0NCiAgICAgICAgc2V0IHoodmFsdWUpIHsNCiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9IHZhbHVlOw0KICAgICAgICB9DQogICAgICAgIHNldCh4LCB5LCB6KSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMF0gPSB4Ow0KICAgICAgICAgICAgdGhpcy5kYXRhWzFdID0geTsNCiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9IHo7DQogICAgICAgIH0NCiAgICB9DQogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGF0dHJpYnV0ZS4NCiAgICAgKi8NCiAgICBjbGFzcyBWZWMzQXR0cmlidXRlIGV4dGVuZHMgQXR0cmlidXRlIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIFZlYzNBdHRyaWJ1dGUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihkYXRhVHlwZU5hbWUgPSAnVmVjMycpIHsNCiAgICAgICAgICAgIHN1cGVyKGRhdGFUeXBlTmFtZSwgMyk7DQogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIFZlYzMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMuZGF0YVtvZmZzZXQgKyAwXSwgdGhpcy5kYXRhW29mZnNldCArIDFdLCB0aGlzLmRhdGFbb2Zmc2V0ICsgMl0pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgVmVjMyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgbWV0aG9kIHdpbGwgc29vbiBiZSByZW1vdmVkLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlUmVmKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzUmVmKHRoaXMuZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDMpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBWZWMzIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldFZhbHVlcyhpbmRleCwgdmFsdWUuYXNBcnJheSgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogPiBOb3RlOiAnUmVmJyBtZWFucyB0aGF0IHRoZSB2YWx1ZSBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBpbiB0aGUgYXR0cmlidXRlLg0KICAgICAgICAgKiA+IFRoZSBjb21wb25lbnRzIG9mIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBjYXVzaW5nIHRoZSBhdHRyaWJ1dGVzIGRhdGEgaXMgY2hhbmdlZC4NCiAgICAgICAgICogPiBObyBuZWVkIHRvIGNhbGwgJ3NldEZhY2VWZXJ0ZXhWYWx1ZScuDQogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguDQogICAgICAgICAqIEBwYXJhbSBmYWNlVmVydGV4IC0gVGhlIGluZGV4IG9mIHZlcnRleCB3aXRoaW4gdGhlIGZhY2UuIFswLi4uIG51bSBmYWNlIHZlcnRpY2VzXQ0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4KSB7DQogICAgICAgICAgICBjb25zdCBhcnJheSA9IHRoaXMuZ2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RmFjZVZlcnRleFZhbHVlKGZhY2UsIGZhY2VWZXJ0ZXgsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4LCBGbG9hdDMyQXJyYXkuZnJvbSh2YWx1ZS5hc0FycmF5KCkpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldFNwbGl0VmVydGV4VmFsdWUgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gdmVydGV4IC0gVGhlIHZlcnRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgsIGZhY2UsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodmVydGV4LCBmYWNlLCBGbG9hdDMyQXJyYXkuZnJvbSh2YWx1ZS5hc0FycmF5KCkpKTsNCiAgICAgICAgfQ0KICAgICAgICBtZXJnZShvdGhlciwgeGZvID0gbmV3IFhmbygpKSB7DQogICAgICAgICAgICBjb25zdCBwcmV2TnVtVmFsdWVzID0gdGhpcy5nZXRDb3VudCgpOw0KICAgICAgICAgICAgY29uc3QgYWRkZWRWYWx1ZXMgPSBvdGhlci5nZXRDb3VudCgpOw0KICAgICAgICAgICAgLy8gV2UgY2FjaGVkIHRoZXNlIHZhbHVlcyBiZWZvcmUgY2FsbGluZyAnc2V0Q291bnQnLg0KICAgICAgICAgICAgLy8gTWF5YmUgJ3NldENvdW50JyBzaG91bG5kJ3QgY2xlYXIgdGhlIHNwbGl0cy4gSXQgc2VlbXMgaGVhdnksIGJ1dCBJIGRvbid0IHdhbnQgdG8gY2hhbmdlIGFueXRoaW5nLg0KICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGp1c3QgcmUtd3JpdGUgdGhlIHN5c3RlbSB3aXRob3V0IHNwbGl0cyBhbnl3YXkuDQogICAgICAgICAgICAvLyBjb25zdCBzcGxpdFZhbHVlcyA9IFsuLi50aGlzLnNwbGl0VmFsdWVzLCAuLi5vdGhlci5zcGxpdFZhbHVlc10NCiAgICAgICAgICAgIC8vIGNvbnN0IHNwbGl0cyA9IFsuLi50aGlzLnNwbGl0cywgLi4ub3RoZXIuc3BsaXRzXQ0KICAgICAgICAgICAgdGhpcy5zZXRDb3VudChwcmV2TnVtVmFsdWVzICsgYWRkZWRWYWx1ZXMpOw0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRlZFZhbHVlczsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwcmV2TnVtVmFsdWVzICsgaSwgeGZvLnRyYW5zZm9ybVZlYzMob3RoZXIuZ2V0VmFsdWUoaSkpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIHRoaXMuc3BsaXRWYWx1ZXMgPSBbLi4udGhpcy5zcGxpdFZhbHVlcywgLi4ub3RoZXIuc3BsaXRWYWx1ZXNdDQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1ZlYzNBdHRyaWJ1dGUnLCBWZWMzQXR0cmlidXRlKTsKCiAgICBjbGFzcyBWZWMzZjhSZWYgew0KICAgICAgICBkYXRhOw0KICAgICAgICBjb25zdHJ1Y3RvcihkYXRhKSB7DQogICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhOw0KICAgICAgICB9DQogICAgICAgIGdldCB4KCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZGVjb2RlMTZCaXRGbG9hdCh0aGlzLmRhdGFbMF0pOw0KICAgICAgICB9DQogICAgICAgIHNldCB4KHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMF0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIGdldCB5KCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZGVjb2RlMTZCaXRGbG9hdCh0aGlzLmRhdGFbMV0pOw0KICAgICAgICB9DQogICAgICAgIHNldCB5KHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIGdldCB6KCkgew0KICAgICAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZGVjb2RlMTZCaXRGbG9hdCh0aGlzLmRhdGFbMl0pOw0KICAgICAgICB9DQogICAgICAgIHNldCB6KHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMl0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIHNldCh4LCB5LCB6KSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMF0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQoeCk7DQogICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQoeSk7DQogICAgICAgICAgICB0aGlzLmRhdGFbMl0gPSBNYXRoRnVuY3Rpb25zLmVuY29kZTE2Qml0RmxvYXQoeik7DQogICAgICAgIH0NCiAgICB9DQogICAgY29uc3QgbWFwSW4kMSA9ICh2YWx1ZSwgdmFsdWVSYW5nZSkgPT4gew0KICAgICAgICByZXR1cm4gTWF0aEZ1bmN0aW9ucy5yZW1hcCh2YWx1ZSwgdmFsdWVSYW5nZVswXSwgdmFsdWVSYW5nZVsxXSwgLTEyNywgMTI3KTsNCiAgICB9Ow0KICAgIGNvbnN0IG1hcE91dCQxID0gKHZhbHVlLCB2YWx1ZVJhbmdlKSA9PiB7DQogICAgICAgIHJldHVybiBNYXRoRnVuY3Rpb25zLnJlbWFwKHZhbHVlLCAtMTI3LCAxMjcsIHZhbHVlUmFuZ2VbMF0sIHZhbHVlUmFuZ2VbMV0pOw0KICAgIH07DQogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGF0dHJpYnV0ZS4NCiAgICAgKi8NCiAgICBjbGFzcyBWZWMzZjhBdHRyaWJ1dGUgZXh0ZW5kcyBWZWMzQXR0cmlidXRlIHsNCiAgICAgICAgdmFsdWVSYW5nZTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIFZlYzNmOEF0dHJpYnV0ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlUmFuZ2UgPSBbLTEsIDFdKSB7DQogICAgICAgICAgICBzdXBlcignVmVjM2Y4Jyk7DQogICAgICAgICAgICB0aGlzLnZhbHVlUmFuZ2UgPSB2YWx1ZVJhbmdlOw0KICAgICAgICB9DQogICAgICAgIGluaXQoKSB7DQogICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW50OEFycmF5KDApOw0KICAgICAgICAgICAgdGhpcy5pbml0UmFuZ2UoMCk7DQogICAgICAgIH0NCiAgICAgICAgaW5pdFJhbmdlKHN0YXJ0KSB7DQogICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB2YWx1ZXMgdG8gaW52YWxpZCB2YWx1ZXMuDQogICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBtYXBJbiQxKE51bWJlci5OYU4sIHRoaXMudmFsdWVSYW5nZSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgaXNJbml0aWFsaXplZChhKSB7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG1hcE91dCQxKGFbaV0sIHRoaXMudmFsdWVSYW5nZSkpKQ0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIFZlYzMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKG1hcE91dCQxKHZhbHVlRGF0YVswXSwgdGhpcy52YWx1ZVJhbmdlKSwgbWFwT3V0JDEodmFsdWVEYXRhWzFdLCB0aGlzLnZhbHVlUmFuZ2UpLCBtYXBPdXQkMSh2YWx1ZURhdGFbMl0sIHRoaXMudmFsdWVSYW5nZSkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgVmVjMyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgbWV0aG9kIHdpbGwgc29vbiBiZSByZW1vdmVkLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlUmVmKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzZjhSZWYodGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMykpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIFZlYzMgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRWYWx1ZShpbmRleCwgdmFsdWUpIHsNCiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpDQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogdGhpcy5zdHJpZGU7DQogICAgICAgICAgICBjb25zdCB2YWx1ZURhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLnN0cmlkZSk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMF0gPSBtYXBJbiQxKHZhbHVlLngsIHRoaXMudmFsdWVSYW5nZSk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMV0gPSBtYXBJbiQxKHZhbHVlLnksIHRoaXMudmFsdWVSYW5nZSk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMl0gPSBtYXBJbiQxKHZhbHVlLnosIHRoaXMudmFsdWVSYW5nZSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgY29ybmVyIHZlcnRleCBvZiBhIGZhY2UuDQogICAgICAgICAqID4gTm90ZTogJ1JlZicgbWVhbnMgdGhhdCB0aGUgdmFsdWUgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGRhdGEgaW4gdGhlIGF0dHJpYnV0ZS4NCiAgICAgICAgICogPiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgY2F1c2luZyB0aGUgYXR0cmlidXRlcyBkYXRhIGlzIGNoYW5nZWQuDQogICAgICAgICAqID4gTm8gbmVlZCB0byBjYWxsICdzZXRGYWNlVmVydGV4VmFsdWUnLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRGYWNlVmVydGV4VmFsdWUoZmFjZSwgZmFjZVZlcnRleCkgew0KICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0aGlzLmdldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4KTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyhtYXBPdXQkMShhcnJheVswXSwgdGhpcy52YWx1ZVJhbmdlKSwgbWFwT3V0JDEoYXJyYXlbMV0sIHRoaXMudmFsdWVSYW5nZSksIG1hcE91dCQxKGFycmF5WzJdLCB0aGlzLnZhbHVlUmFuZ2UpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gbmV3IEludDhBcnJheSgzKTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVswXSA9IG1hcEluJDEodmFsdWUueCwgdGhpcy52YWx1ZVJhbmdlKTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVsxXSA9IG1hcEluJDEodmFsdWUueSwgdGhpcy52YWx1ZVJhbmdlKTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVsyXSA9IG1hcEluJDEodmFsdWUueiwgdGhpcy52YWx1ZVJhbmdlKTsNCiAgICAgICAgICAgIHRoaXMuc2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgsIHZhbHVlRGF0YSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRTcGxpdFZlcnRleFZhbHVlcyBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZUdyb3VwIC0gVGhlIGZhY2VHcm91cCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZXModmVydGV4LCBmYWNlR3JvdXAsIHZhbHVlcykgew0KICAgICAgICAgICAgc3VwZXIuc2V0U3BsaXRWZXJ0ZXhWYWx1ZXModmVydGV4LCBmYWNlR3JvdXAsIHZhbHVlcy5tYXAoKHYpID0+IG1hcEluJDEodiwgdGhpcy52YWx1ZVJhbmdlKSwgdGhpcy52YWx1ZVJhbmdlKSk7DQogICAgICAgIH0NCiAgICB9CgogICAgY29uc3QgbWFwSW4gPSAodmFsdWUpID0+IHsNCiAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZW5jb2RlMTZCaXRGbG9hdCh2YWx1ZSk7DQogICAgfTsNCiAgICBjb25zdCBtYXBPdXQgPSAodmFsdWUpID0+IHsNCiAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZGVjb2RlMTZCaXRGbG9hdCh2YWx1ZSk7DQogICAgfTsNCiAgICBjbGFzcyBWZWMzZjE2UmVmIHsNCiAgICAgICAgZGF0YTsNCiAgICAgICAgY29uc3RydWN0b3IoZGF0YSkgew0KICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTsNCiAgICAgICAgfQ0KICAgICAgICBnZXQgeCgpIHsNCiAgICAgICAgICAgIHJldHVybiBtYXBPdXQodGhpcy5kYXRhWzBdKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXQgeCh2YWx1ZSkgew0KICAgICAgICAgICAgdGhpcy5kYXRhWzBdID0gbWFwSW4odmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIGdldCB5KCkgew0KICAgICAgICAgICAgcmV0dXJuIG1hcE91dCh0aGlzLmRhdGFbMV0pOw0KICAgICAgICB9DQogICAgICAgIHNldCB5KHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSBtYXBJbih2YWx1ZSk7DQogICAgICAgIH0NCiAgICAgICAgZ2V0IHooKSB7DQogICAgICAgICAgICByZXR1cm4gbWFwT3V0KHRoaXMuZGF0YVsyXSk7DQogICAgICAgIH0NCiAgICAgICAgc2V0IHoodmFsdWUpIHsNCiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9IG1hcEluKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXQoeCwgeSwgeikgew0KICAgICAgICAgICAgdGhpcy5kYXRhWzBdID0gbWFwSW4oeCk7DQogICAgICAgICAgICB0aGlzLmRhdGFbMV0gPSBtYXBJbih5KTsNCiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9IG1hcEluKHopOw0KICAgICAgICB9DQogICAgfQ0KICAgIC8qKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBhdHRyaWJ1dGUuDQogICAgICovDQogICAgY2xhc3MgVmVjM2YxNkF0dHJpYnV0ZSBleHRlbmRzIFZlYzNBdHRyaWJ1dGUgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgVmVjM2Y4QXR0cmlidXRlLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoKSB7DQogICAgICAgICAgICBzdXBlcignVmVjM2YxNicpOw0KICAgICAgICB9DQogICAgICAgIGluaXQoKSB7DQogICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoMCk7DQogICAgICAgICAgICB0aGlzLmluaXRSYW5nZSgwKTsNCiAgICAgICAgfQ0KICAgICAgICBpbml0UmFuZ2Uoc3RhcnQpIHsNCiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlcyB0byBpbnZhbGlkIHZhbHVlcy4NCiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IG1hcEluKE51bWJlci5OYU4pOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGlzSW5pdGlhbGl6ZWQoYSkgew0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShtYXBPdXQoYVtpXSkpKQ0KICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIFZlYzMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKG1hcE91dCh2YWx1ZURhdGFbMF0pLCBtYXBPdXQodmFsdWVEYXRhWzFdKSwgbWFwT3V0KHZhbHVlRGF0YVsyXSkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgVmVjMyB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgbWV0aG9kIHdpbGwgc29vbiBiZSByZW1vdmVkLg0KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlUmVmKGluZGV4KSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzZjE2UmVmKHRoaXMuZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDMpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBWZWMzIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJ0ZXggaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFZlcnRpY2VzOicgKyB0aGlzLmRhdGEubGVuZ3RoIC8gMyk7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOw0KICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOw0KICAgICAgICAgICAgdmFsdWVEYXRhWzBdID0gbWFwSW4odmFsdWUueCk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMV0gPSBtYXBJbih2YWx1ZS55KTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVsyXSA9IG1hcEluKHZhbHVlLnopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLg0KICAgICAgICAgKiA+IE5vdGU6ICdSZWYnIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhIGluIHRoZSBhdHRyaWJ1dGUuDQogICAgICAgICAqID4gVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGNhdXNpbmcgdGhlIGF0dHJpYnV0ZXMgZGF0YSBpcyBjaGFuZ2VkLg0KICAgICAgICAgKiA+IE5vIG5lZWQgdG8gY2FsbCAnc2V0RmFjZVZlcnRleFZhbHVlJy4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RmFjZVZlcnRleFZhbHVlKGZhY2UsIGZhY2VWZXJ0ZXgpIHsNCiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gdGhpcy5nZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkoZmFjZSwgZmFjZVZlcnRleCk7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobWFwT3V0KGFycmF5WzBdKSwgbWFwT3V0KGFycmF5WzFdKSwgbWFwT3V0KGFycmF5WzJdKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgY29ybmVyIHZlcnRleCBvZiBhIGZhY2UuDQogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguDQogICAgICAgICAqIEBwYXJhbSBmYWNlVmVydGV4IC0gVGhlIGluZGV4IG9mIHZlcnRleCB3aXRoaW4gdGhlIGZhY2UuIFswLi4uIG51bSBmYWNlIHZlcnRpY2VzXQ0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRGYWNlVmVydGV4VmFsdWUoZmFjZSwgZmFjZVZlcnRleCwgdmFsdWUpIHsNCiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YSA9IG5ldyBVaW50MTZBcnJheSgzKTsNCiAgICAgICAgICAgIHZhbHVlRGF0YVswXSA9IG1hcEluKHZhbHVlLngpOw0KICAgICAgICAgICAgdmFsdWVEYXRhWzFdID0gbWFwSW4odmFsdWUueSk7DQogICAgICAgICAgICB2YWx1ZURhdGFbMl0gPSBtYXBJbih2YWx1ZS56KTsNCiAgICAgICAgICAgIHRoaXMuc2V0RmFjZVZlcnRleFZhbHVlX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgsIHZhbHVlRGF0YSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRTcGxpdFZlcnRleFZhbHVlcyBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZUdyb3VwIC0gVGhlIGZhY2VHcm91cCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZXModmVydGV4LCBmYWNlR3JvdXAsIHZhbHVlcykgew0KICAgICAgICAgICAgc3VwZXIuc2V0U3BsaXRWZXJ0ZXhWYWx1ZXModmVydGV4LCBmYWNlR3JvdXAsIHZhbHVlcy5tYXAoKHYpID0+IG1hcEluKHYpKSk7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGF0dHJpYnV0ZS4NCiAgICAgKi8NCiAgICBjbGFzcyBDb2xvckF0dHJpYnV0ZSBleHRlbmRzIEF0dHJpYnV0ZSB7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSBDb2xvckF0dHJpYnV0ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgc3VwZXIoJ0NvbG9yJywgNCk7DQogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIENvbG9yIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiBDb2xvciAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRWYWx1ZShpbmRleCkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZSkNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIDMpOw0KICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiB0aGlzLnN0cmlkZTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5kYXRhW29mZnNldCArIDBdLCB0aGlzLmRhdGFbb2Zmc2V0ICsgMV0sIHRoaXMuZGF0YVtvZmZzZXQgKyAyXSwgdGhpcy5kYXRhW29mZnNldCArIDNdKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBDb2xvciBhdCB0aGUgc3BlY2lmaWVkIGluZGV4Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoaW5kZXgsIHZhbHVlLmFzQXJyYXkoKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgY29ybmVyIHZlcnRleCBvZiBhIGZhY2UuDQogICAgICAgICAqID4gTm90ZTogJ1JlZicgbWVhbnMgdGhhdCB0aGUgdmFsdWUgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGRhdGEgaW4gdGhlIGF0dHJpYnV0ZS4NCiAgICAgICAgICogPiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgY2F1c2luZyB0aGUgYXR0cmlidXRlcyBkYXRhIGlzIGNoYW5nZWQuDQogICAgICAgICAqID4gTm8gbmVlZCB0byBjYWxsICdzZXRGYWNlVmVydGV4VmFsdWUnLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRGYWNlVmVydGV4VmFsdWUoZmFjZSwgZmFjZVZlcnRleCkgew0KICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0aGlzLmdldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4KTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSwgYXJyYXlbM10pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4Lg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RmFjZVZlcnRleFZhbHVlKGZhY2UsIGZhY2VWZXJ0ZXgsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4LCBGbG9hdDMyQXJyYXkuZnJvbSh2YWx1ZS5hc0FycmF5KCkpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldFNwbGl0VmVydGV4VmFsdWUgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gdmVydGV4IC0gVGhlIHZlcnRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgsIGZhY2UsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLnNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodmVydGV4LCBmYWNlLCBGbG9hdDMyQXJyYXkuZnJvbSh2YWx1ZS5hc0FycmF5KCkpKTsNCiAgICAgICAgfQ0KICAgICAgICBtZXJnZShvdGhlciwgeGZvID0gbmV3IFhmbygpKSB7DQogICAgICAgICAgICBjb25zdCBwcmV2TnVtVmFsdWVzID0gdGhpcy5nZXRDb3VudCgpOw0KICAgICAgICAgICAgY29uc3QgYWRkZWRWYWx1ZXMgPSBvdGhlci5nZXRDb3VudCgpOw0KICAgICAgICAgICAgdGhpcy5zZXRDb3VudChwcmV2TnVtVmFsdWVzICsgYWRkZWRWYWx1ZXMpOw0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRlZFZhbHVlczsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShwcmV2TnVtVmFsdWVzICsgaSwgb3RoZXIuZ2V0VmFsdWUoaSkpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlcyA9IFsuLi50aGlzLnNwbGl0VmFsdWVzLCAuLi5vdGhlci5zcGxpdFZhbHVlc107DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0NvbG9yQXR0cmlidXRlJywgQ29sb3JBdHRyaWJ1dGUpOwoKICAgIHZhciBPcGVyYXRvck91dHB1dE1vZGU7DQogICAgKGZ1bmN0aW9uIChPcGVyYXRvck91dHB1dE1vZGUpIHsNCiAgICAgICAgT3BlcmF0b3JPdXRwdXRNb2RlW09wZXJhdG9yT3V0cHV0TW9kZVsiT1BfV1JJVEUiXSA9IDBdID0gIk9QX1dSSVRFIjsNCiAgICAgICAgT3BlcmF0b3JPdXRwdXRNb2RlW09wZXJhdG9yT3V0cHV0TW9kZVsiT1BfUkVBRF9XUklURSJdID0gMV0gPSAiT1BfUkVBRF9XUklURSI7DQogICAgfSkoT3BlcmF0b3JPdXRwdXRNb2RlIHx8IChPcGVyYXRvck91dHB1dE1vZGUgPSB7fSkpOwoKICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSByZWFjdGl2ZSB0eXBlIG9mIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSBvd25lZCBieSBhIGBQYXJhbWV0ZXJPd25lcmAgY2xhc3MuDQogICAgICoNCiAgICAgKiAqKkV2ZW50cyoqDQogICAgICogKiAqKm5hbWVDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgY2hhbmdlcy4NCiAgICAgKiAqICoqdmFsdWVDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGNoYW5nZXMuDQogICAgICovDQogICAgY2xhc3MgUGFyYW1ldGVyIGV4dGVuZHMgQmFzZUl0ZW0gew0KICAgICAgICBkaXJ0eSA9IGZhbHNlOw0KICAgICAgICBib3VuZElucHV0cyA9IFtdOw0KICAgICAgICBib3VuZE91dHB1dHMgPSBbXTsNCiAgICAgICAgY2xlYW5pbmcgPSBmYWxzZTsNCiAgICAgICAgZGlydHlPcEluZGV4ID0gMDsNCiAgICAgICAgZmlyc3RPUF9XUklURSA9IDA7DQogICAgICAgIF9fdmFsdWU7DQogICAgICAgIGRhdGFUeXBlOw0KICAgICAgICBvd25lckl0ZW07DQogICAgICAgIC8qKg0KICAgICAgICAgKiBXaGVuIGluaXRpYWxpemluZyBhIG5ldyBwYXJhbWV0ZXIsIHRoZSBwYXNzZWQgaW4gdmFsdWUgY291bGQgYmUgYW55dGhpbmcuDQogICAgICAgICAqIElmIGl0IGlzIGEgbmV3IHR5cGUgb2YgdmFsdWUsIGp1c3QgZW5zdXJlIHlvdSByZWdpc3RlciBpdCBpbiB0aGUgYFJlZ2lzdHJ5YC4NCiAgICAgICAgICoNCiAgICAgICAgICogSG93IHRvIHVzZSBpdDoNCiAgICAgICAgICoNCiAgICAgICAgICogYGBgamF2YXNjcmlwdA0KICAgICAgICAgKiAgLy8gQ3JlYXRpbmcgYSBwYXJhbWV0ZXIgb2JqZWN0DQogICAgICAgICAqICBjb25zdCBwYXJhbSA9IG5ldyBQYXJhbWV0ZXIoJ1RpdGxlJywgJ0F3ZXNvbWUgUGFyYW1ldGVyIFZhbHVlJywgJ1N0cmluZycpDQogICAgICAgICAqDQogICAgICAgICAqICAgLy8gQ2FwdHVyaW5nIGV2ZW50cw0KICAgICAgICAgKiAgcGFyYW0ub24oJ3ZhbHVlQ2hhbmdlZCcsICguLi5wYXJhbXMpID0+IGNvbnNvbGUubG9nKCdWYWx1ZSBjaGFuZ2VkIScpKQ0KICAgICAgICAgKg0KICAgICAgICAgKiAgLy8gQ2hhbmdpbmcgcGFyYW1ldGVyJ3MgdmFsdWUgd2lsbCBjYXVzZSBgdmFsdWVDaGFuZ2VkYCBldmVudCB0byB0cmlnZ2VyLg0KICAgICAgICAgKiAgcGFyYW0uc2V0VmFsdWUoJ0EgTmV3IEF3ZXNvbWUgUGFyYW1ldGVyIFZhbHVlJykNCiAgICAgICAgICogIC8vIEFzIHJlc3VsdCB0aGUgY29uc29sZSBsb2cgY29kZSB3aWxsIGV4ZWN1dGU6IFZhbHVlIENoYW5nZWQhDQogICAgICAgICAqIGBgYA0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gZGF0YVR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlLCBkYXRhVHlwZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSk7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZTsNCiAgICAgICAgICAgIHRoaXMuZGF0YVR5cGUgPSBkYXRhVHlwZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgb3duZXIgaXRlbSBvZiB0aGUgY3VycmVudCBwYXJhbWV0ZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0T3duZXIoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5vd25lckl0ZW07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIG93bmVyIGl0ZW0gb2YgdGhlIGN1cnJlbnQgcGFyYW1ldGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3duZXJJdGVtIC0gVGhlIG93bmVySXRlbSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldE93bmVyKG93bmVySXRlbSkgew0KICAgICAgICAgICAgdGhpcy5vd25lckl0ZW0gPSBvd25lckl0ZW07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgcGFyYW1ldGVyJ3MgZGF0YSB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldERhdGFUeXBlKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVR5cGU7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIE9wZXJhdG9yIGJpbmRpbmdzDQogICAgICAgIC8qKg0KICAgICAgICAgKiBXaGVuIGFuIE9wZXJhdG9yIGlzIHJlYWRpbmcgZnJvbSBhIHBhcmFtZXRlciwgaXQgbXVzdCBiZSBkaXJ0aWVkIHdoZW4gdGhlIHBhcmFtZXRlciB2YWx1ZQ0KICAgICAgICAgKiBjaGFuZ2VzLiBUaGUgUGFyYW1ldGVyIG1haW50YWlucyBhIGxpc3Qgb2YgYm91bmQgaW5wdXRzIGFuZCB3aWxsIHByb3BhZ2F0ZSBkaXJ0eSB0bw0KICAgICAgICAgKiB0aGVtIGV4cGxpY2l0bHkuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvcGVyYXRvcklucHV0IC0gVGhlIG91dHB1dCB0aGF0IHdlIGFyZSB1bmJpbmRpbmcgZnJvbSB0aGUgUGFyYW1ldGVyDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleChvcHRpb25hbCkgdGhhdCB0aGUgb3V0cHV0IGlzIGJlaW5nIGJvdW5kIGF0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBib3VuZCBvdXRwdXQuDQogICAgICAgICAqLw0KICAgICAgICBiaW5kT3BlcmF0b3JJbnB1dChvcGVyYXRvcklucHV0KSB7DQogICAgICAgICAgICB0aGlzLmJvdW5kSW5wdXRzLnB1c2gob3BlcmF0b3JJbnB1dCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFdoZW4gYW4gb3BlcmF0b3IgaXMgYmVpbmcgcmVtb3ZlZCBmcm9tIHJlYWRpbmcgZnJvbSBhIFBhcmFtZXRlciwgdGhlIElucHV0IGlzIHJlbW92ZWQNCiAgICAgICAgICogVGhpcyBtZWFucyB0aGUgb3BlcmF0b3Igd2lsbCBubyBsb25nZXIgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG9wZXJhdG9yIGNoYW5nZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBvcGVyYXRvcklucHV0IC0gVGhlIG91dHB1dCB0aGF0IHdlIGFyZSB1bmJpbmRpbmcgZnJvbSB0aGUgUGFyYW1ldGVyDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdW5iaW5kT3BlcmF0b3JJbnB1dChvcGVyYXRvcklucHV0KSB7DQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYm91bmRJbnB1dHMuaW5kZXhPZihvcGVyYXRvcklucHV0KTsNCiAgICAgICAgICAgIHRoaXMuYm91bmRJbnB1dHMuc3BsaWNlKGluZGV4LCAxKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogV2hlbiBhbiBPcGVyYXRvciB3cml0ZXMgdG8gYSBwYXJhbWV0ZXIsIGl0IGJpbmRzIGl0cyBvdXRwdXRzIHRvIHRoZSBwYXJhbWV0ZXIgYXQgYSBnaXZlbg0KICAgICAgICAgKiBpbmRleC4gVGhlbiB3aGVuIHRoZSBvcGVyYXRvciBpcyBkaXJ0aWVkIGJ5IG9uZSBvZiBpdHMgaW5wdXRzLCBpdCBleHBsaWNpdGx5IGRpcnRpZXMNCiAgICAgICAgICogdGhlIG91dHB1dCBwYXJhbWV0ZXJzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gb3BlcmF0b3JPdXRwdXQgLSBUaGUgb3V0cHV0IHRoYXQgd2UgYXJlIHVuYmluZGluZyBmcm9tIHRoZSBQYXJhbWV0ZXINCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4KG9wdGlvbmFsKSB0aGF0IHRoZSBvdXRwdXQgaXMgYmVpbmcgYm91bmQgYXQuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgaW5kZXggb2YgdGhlIGJvdW5kIG91dHB1dC4NCiAgICAgICAgICovDQogICAgICAgIGJpbmRPcGVyYXRvck91dHB1dChvcGVyYXRvck91dHB1dCwgaW5kZXggPSAtMSkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKQ0KICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoOw0KICAgICAgICAgICAgdGhpcy5ib3VuZE91dHB1dHMuc3BsaWNlKGluZGV4LCAwLCBvcGVyYXRvck91dHB1dCk7DQogICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBiaW5kaW5nIGluZGljZXMNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuYm91bmRPdXRwdXRzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5ib3VuZE91dHB1dHNbaV0uc2V0UGFyYW1CaW5kSW5kZXgoaSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlbid0IGFscmVhZHkgZGlydHksIG1ha2Ugc3VyZSB0byBlbWl0IGEgJ3ZhbHVlQ2hhbmdlZCcgYW55d2F5Lg0KICAgICAgICAgICAgdGhpcy5fX2ZpbmRGaXJzdE9QX1dSSVRFKCk7DQogICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgb3BlcmF0b3Igc3RhY2sgaXMgY29uc2lkZXJlZCAnY2xlYW4nDQogICAgICAgICAgICAvLyBhbmQgdGhlbiB3ZSBjYWxsIHNldCBkaXJ0eSB0byBmb3JjZSBpdCB0byBiZWNvbWUgZGlydHkgZnJvbSB0aGUgaW5zZXJ0aW9uIHBvaW50IGRvd24uDQogICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgbGluZSwgdGhlIG9wZXJhdG9yIGlzIGNvbnNpZGVyZWQgYWxyZWFkeSAnZGlydHknLCBhbmQgc28gd29uJ3QgcHJvcGFnYXRlLg0KICAgICAgICAgICAgdGhpcy5kaXJ0eU9wSW5kZXggPSB0aGlzLmJvdW5kT3V0cHV0cy5sZW5ndGg7DQogICAgICAgICAgICB0aGlzLnNldERpcnR5KGluZGV4KTsNCiAgICAgICAgICAgIHJldHVybiBpbmRleDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogV2hlbiBhbiBvcGVyYXRvciBpcyB1bmJpbmRpbmcgZnJvbSBhIHBhcmFtZXRlciwgaXQgcmVtb3ZlcyBpdHMgc2VsZiBmcm9tIHRoZSBsaXN0IG1haW50YWluZWQNCiAgICAgICAgICogYnkgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG9wZXJhdG9yT3V0cHV0IC0gVGhlIG91dHB1dCB0aGF0IHdlIGFyZSB1bmJpbmRpbmcgZnJvbSB0aGUgUGFyYW1ldGVyDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdW5iaW5kT3BlcmF0b3JPdXRwdXQob3BlcmF0b3JPdXRwdXQpIHsNCiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3BlcmF0b3JPdXRwdXQuZ2V0UGFyYW1CaW5kSW5kZXgoKTsNCiAgICAgICAgICAgIHRoaXMuYm91bmRPdXRwdXRzLnNwbGljZShpbmRleCwgMSk7DQogICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBiaW5kaW5nIGluZGljZXMNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuYm91bmRPdXRwdXRzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgdGhpcy5ib3VuZE91dHB1dHNbaV0uc2V0UGFyYW1CaW5kSW5kZXgoaSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLl9fZmluZEZpcnN0T1BfV1JJVEUoKTsNCiAgICAgICAgICAgIHRoaXMuZGlydHlPcEluZGV4ID0gdGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoOw0KICAgICAgICAgICAgdGhpcy5zZXREaXJ0eShNYXRoLm1heCgwLCBpbmRleCAtIDEpKTsNCiAgICAgICAgICAgIHJldHVybiBpbmRleDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRmluZCB0aGUgZmlyc3Qgb3BlcmF0b3IgaW4gb3VyIHN0YWNrIHdoaWNoIHdyaXRlcyB1c2luZyBhbiBPUF9XUklURSBjb25uZWN0aW9uLg0KICAgICAgICAgKiBBbGwgb3BlcmF0b3JzIGJlZm9yZSB0aGlzIG9wIGNhbiBiZSBpZ25vcmVkIGR1cmluZyBkaXJ0eSBwcm9wYWdhdGlvbi4NCiAgICAgICAgICogQHByaXZhdGUNCiAgICAgICAgICovDQogICAgICAgIF9fZmluZEZpcnN0T1BfV1JJVEUoKSB7DQogICAgICAgICAgICB0aGlzLmZpcnN0T1BfV1JJVEUgPSB0aGlzLmJvdW5kT3V0cHV0cy5sZW5ndGg7DQogICAgICAgICAgICBpZiAodGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoID4gMCkgew0KICAgICAgICAgICAgICAgIGZvciAodGhpcy5maXJzdE9QX1dSSVRFLS07IHRoaXMuZmlyc3RPUF9XUklURSA+IDA7IHRoaXMuZmlyc3RPUF9XUklURS0tKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IE9QX1dSSVRFIGJpbmRpbmcuIChOb3RlOiB3ZSBjb3VsZCBjYWNoZSB0aGlzKQ0KICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZE91dHB1dHNbdGhpcy5maXJzdE9QX1dSSVRFXS5nZXRNb2RlKCkgPT0gT3BlcmF0b3JPdXRwdXRNb2RlLk9QX1dSSVRFKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGlzRHJpdmVuQnlPcGVyYXRvcigpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0T1BfV1JJVEUgPT0gMCAmJiB0aGlzLmJvdW5kT3V0cHV0cy5sZW5ndGggPiAwOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBEaXJ0aWVzIHRoaXMgUGFyYW1ldGVyIHNvIHN1YnNlcXVlbnQgY2FsbHMgdG8gYGdldFZhbHVlYCB3aWxsIGNhdXNlIGFuIGV2YWx1YXRpb24gb2YgaXRzIGJvdW5kIG9wZXJhdG9ycy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gSW5kZXggb2YgdGhlIG9wZXJhdG9yDQogICAgICAgICAqIEByZXR1cm4gLSBgdHJ1ZWAgaWYgdGhlIFBhcmFtZXRlciB3YXMgbWFkZSBkaXJ0eSwgZWxzZSBgZmFsc2VgIGlmIGl0IHdhcyBhbHJlYWR5IGRpcnR5Lg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RGlydHkoaW5kZXgpIHsNCiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgZmlyc3Qgb3BlcmF0b3IgaW4gdGhlIHN0YWNrIHRoYXQgbXVzdCBldmFsdWF0ZSB0byBjbGVhbiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgICAgLy8gTm90ZTogaWYgYSBSRUFEX1dSSVRFIG9wIGlzIGJlY29taW5nIGRpcnR5LCB0aGVuIHdlIGRpcnR5IGJhY2sgdXAgdG8gdGhhdCBvcC4NCiAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGlydHlPcEluZGV4KSB7DQogICAgICAgICAgICAgICAgLy8gSWYgd2UgbXVzdCBkaXJ0eSBhbGwgb3BlcmF0b3JzIGluIHRoZSBzdGFjayBmcm9tIHRoZSBsYXN0IE9QX1dSSVRFIHRvIHRoZSBlbmQuDQogICAgICAgICAgICAgICAgLy8gTm90ZTogSWYgYSBzZXREaXJ0eSBjYWxsIGNvbWVzIGZyb20gYW4gb3AgdGhhdCBwcmVjZWRlcyBhbiBPUF9XUklURSBvcGVyYXRvciwgd2UNCiAgICAgICAgICAgICAgICAvLyBjYW4gc2FmZWx5IGRpc2NhcmQgaXQsIGFzIGl0cyBvdXRwdXQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgdmFsdWUgb2YgdGhpcyBwYXJhbWV0ZXIuDQogICAgICAgICAgICAgICAgbGV0IG5ld0RpcnR5SW5kZXggPSB0aGlzLmZpcnN0T1BfV1JJVEU7DQogICAgICAgICAgICAgICAgaWYgKG5ld0RpcnR5SW5kZXggPD0gaW5kZXgpIHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eU9wSW5kZXggPSBuZXdEaXJ0eUluZGV4Ow0KICAgICAgICAgICAgICAgICAgICBmb3IgKG5ld0RpcnR5SW5kZXgrKzsgbmV3RGlydHlJbmRleCA8IHRoaXMuYm91bmRPdXRwdXRzLmxlbmd0aDsgbmV3RGlydHlJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXJ0eSBhbGwgdGhlIG90aGVyIGJvdW5kIG9wcyBmcm9tIHRoZSBPUF9XUklURSB0byB0aGUgdG9wIG9mIHRoZSBzdGFjay4NCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdEaXJ0eUluZGV4ICE9IGluZGV4KSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdXNlIHRoZSBvdGhlciBvdXRwdXRzIG9mIHRoZSBvcGVyYXRvciB0byBiZWNvbWUgZGlydHkuDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZE91dHB1dHNbbmV3RGlydHlJbmRleF0uZ2V0T3BlcmF0b3IoKS5zZXREaXJ0eSgpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3VuZElucHV0cy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZElucHV0c1tpXS5zZXREaXJ0eSgpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcGFyYW1ldGVyIGlzIGN1cnJlbnRseSBkaXJ0eSBhbmQgd2lsbCBldmFsdWF0ZSBpdHMgYm91bmQNCiAgICAgICAgICogb3BlcmF0b3JzIGlmIGl0cyB2YWx1ZSBpcyByZXF1ZXN0ZWQgYnkgYSBjYWxsIHRvIGdldFZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIGJvb2xlYW4uDQogICAgICAgICAqLw0KICAgICAgICBpc0RpcnR5KCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlydHlPcEluZGV4IDwgdGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgJ2RpcnR5JyBiaW5kaW5nIGluIHRoZSBzdGFjay4gVGhpcyB3aWxsIGJlIHRoZSBpbmRleCBvZiB0aGUNCiAgICAgICAgICogZmlyc3Qgb3BlcmF0b3IgdGhhdCB3aWxsIGV2YWx1YXRlIHdoZW4gdGhlIHBhcmFtZXRlciBuZWVkcyB0byBiZSBjbGVhbmVkLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBkaXJ0eSBiaW5kaW5nIGluIHRoZSBiaW5kaW5nIHN0YWNrLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RGlydHlCaW5kaW5nSW5kZXgoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eU9wSW5kZXg7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRDbGVhbkZyb21PcCBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBjb21wdXRlZCB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gdGhlIFBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBib3VuZCBPcGVyYXRvck91dHB1dC4NCiAgICAgICAgICovDQogICAgICAgIHNldENsZWFuRnJvbU9wKHZhbHVlLCBpbmRleCkgew0KICAgICAgICAgICAgaWYgKGluZGV4ICE9IHRoaXMuZGlydHlPcEluZGV4KSB7DQogICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5kaXJ0eU9wSW5kZXgpIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYW4gb3BlcmF0b3IgaW4gdGhlIGZvbGxvd2luZyBjYXNlLg0KICAgICAgICAgICAgICAgICAgICAvLyBQYXJhbUEgW09wQywgT3BCLCBPcEFdDQogICAgICAgICAgICAgICAgICAgIC8vIFBhcmFtQiBbT3BDLCBPcEFdDQogICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gT3BCIGRpcnRpZXMgUGFyYW1BLCBhbmQgaXMgZXZhbHVhdGVkLCBQYXJhbUIgaXMgY29uc2lkZXJlZCBjbGVhbiBiZWNhdXNlIE9wQSB3YXMgbmV2ZXIgZGlydGllZA0KICAgICAgICAgICAgICAgICAgICAvLyBXZSBzZWUgdGhpcyBtZXNzYWdlIHdoZW4gcGFyYW1ldGVycyBhcmUgZXZhbHVhdGVkIGFzIHNvb24gYXMgYSBjaGFuZ2UgaXMgZGV0ZWN0ZWQgaW5zdGVhZCBvZg0KICAgICAgICAgICAgICAgICAgICAvLyBpbiBiYXRjaGVzLiBOb3cgdGhhdCBhbGwgcmVuZGVyaW5nIGNvZGUgaXMgcHVsbGluZyBkYXRhIG9ubHkgZHVyaW5nIHRoZSByZW5kZXIgY3ljbGUsIHdlIGFyYQ0KICAgICAgICAgICAgICAgICAgICAvLyBub3Qgc2VlaW5nIGl0IGFueW1vcmUuIEhvd2V2ZXIsIG1heWJlIHdpdGggYSBVSSBvcGVuLCBpdCB3aWxsIHN0YXJ0IGVtaXR0aW5nIHRoaXMgd2FybmluZy4NCiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyB3b3VsZCBiZSBjYXVzZWQsIGlmIGEgUGFyYW1ldGVyIGlzIGFscmVhZHkgY2xlYW5lZCBieSBhbiBPcGVyYXRvciwgYW5kIHlldCB0aGUgT3BlcmF0b3INCiAgICAgICAgICAgICAgICAgICAgLy8gaXMgcmUtZXZhbHVhdGluZy4gSSBhbSBub3Qgc3VyZSBob3cgdGhpcyBjYW4gb2NjdXIuDQogICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IG9wID0gb3BlcmF0b3JPdXRwdXQuZ2V0T3BlcmF0b3IoKQ0KICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygNCiAgICAgICAgICAgICAgICAgICAgLy8gICBgT3BlcmF0b3I6OiAkew0KICAgICAgICAgICAgICAgICAgICAvLyAgICAgb3AuY29uc3RydWN0b3IubmFtZQ0KICAgICAgICAgICAgICAgICAgICAvLyAgIH0gd2l0aCBuYW1lOiAke29wLmdldE5hbWUoKX0gaXMgYmVpbmcgY2xlYW5lZCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBsYXppbHkuYA0KICAgICAgICAgICAgICAgICAgICAvLyApDQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbWV0ZXIgaXMgY2xlYW5lZCB3aGVuIGl0IHdhcyBhbHJlYWR5IGNsZWFuIHRvIHRoYXQgcG9pbnQgaW4gdGhlIHN0YWNrOmAsIHRoaXMuZ2V0UGF0aCgpKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ib3VuZE91dHB1dHNbaW5kZXhdLmdldE1vZGUoKSAhPSBPcGVyYXRvck91dHB1dE1vZGUuT1BfV1JJVEUpIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gQSBwYXJhbWV0ZXIgY2FuIGJlY29tZSBkaXJ0eSAoc28gX19kaXJ0eU9wSW5kZXggPT0gMCksIGFuZCB0aGVuIGFub3RoZXIgb3BlcmF0b3IgYm91bmQgb24gdG9wLg0KICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbmV4dCBvcCBpcyBhIFdSSVRFIG9wLCB0aGVuIHdlIGNhbiBmYXN0IGZvcndhcmQgdGhlIGRpcnR5IGluZGV4Lg0KICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGlzQ2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUoKTsNCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3AgPSB0aGlzLmJvdW5kT3V0cHV0c1tpbmRleF0uZ2V0T3BlcmF0b3IoKTsNCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BDbGFzc05hbWUgPSBvcC5nZXRDbGFzc05hbWUoKTsNCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXI6ICR7dGhpc0NsYXNzTmFtZX0gd2l0aCBuYW1lOiAke3RoaXMuZ2V0TmFtZSgpfSBpcyBub3QgY2xlYW5pbmcgYWxsIG91dHB1dHMgZHVyaW5nIGV2YWx1YXRpb24gb2Ygb3A6ICR7b3BDbGFzc05hbWV9IHdpdGggbmFtZTogJHtvcC5nZXROYW1lKCl9YCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gdmFsdWU7DQogICAgICAgICAgICAvLyBBcyBlYWNoIG9wZXJhdG9yIHdyaXRlcyBpdHMgdmFsdWUsIHRoZSBkaXJ0eSB2YWx1ZSBpcyBpbmNyZW1lbnRlZA0KICAgICAgICAgICAgdGhpcy5kaXJ0eU9wSW5kZXggPSBpbmRleCArIDE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIER1cmluZyBvcGVyYXRvciBldmFsdWF0aW9uLCBvcGVyYXRvcnMgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgZXhpc3RpbmcNCiAgICAgICAgICogdmFsdWUgb2Ygb25lIG9mIHRoZWlyIG91dHB1dHMuDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgYm91bmQgT3BlcmF0b3JPdXRwdXQgdG8gZXZhbHVhdGUgdXAgdG8uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0VmFsdWVGcm9tT3AoaW5kZXgpIHsNCiAgICAgICAgICAgIC8vIE5vdGU6IGR1cmluZyBldmFsdWF0aW9uIG9mIGFuIE9wZXJhdG9yIHRoYXQgd3JpdGVzIHRvIG11bHRpcGxlIG91dHB1dHMsDQogICAgICAgICAgICAvLyBpdCBjYW4gd3JpdGUgdG8gYW4gb3V0cHV0IHdpdGggYW4gSU8gc2V0dGluZywgd2hpY2ggbWVhbnMgaXQgcmV0cmlldmVzDQogICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgd2hpbGUgY2FsY3VsYXRpbmcgdGhlIG5leHQuDQogICAgICAgICAgICBpZiAodGhpcy5kaXJ0eU9wSW5kZXggPCBpbmRleCkgew0KICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFuKGluZGV4KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENsZWFucyB0aGUgcGFyYW1ldGVyIHVwIHRwIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGluZGV4IG9mIHRoZSBib3VuZCBPcGVyYXRvck91dHB1dA0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGJvdW5kIE9wZXJhdG9yT3V0cHV0IHRvIGV2YWx1YXRlIHVwIHRvLg0KICAgICAgICAgKi8NCiAgICAgICAgX2NsZWFuKGluZGV4KSB7DQogICAgICAgICAgICBpZiAodGhpcy5jbGVhbmluZykgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3ljbGUgZGV0ZWN0ZWQgd2hlbiBjbGVhbmluZzogJHt0aGlzLmdldFBhdGgoKX0uIE9wZXJhdG9ycyBuZWVkIHRvIGJlIHJlYm91bmQgdG8gZml4IGVycm9yc2ApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5jbGVhbmluZyA9IHRydWU7DQogICAgICAgICAgICB3aGlsZSAodGhpcy5kaXJ0eU9wSW5kZXggPCBpbmRleCkgew0KICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuZGlydHlPcEluZGV4Ow0KICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yT3V0cHV0ID0gdGhpcy5ib3VuZE91dHB1dHNbdGhpcy5kaXJ0eU9wSW5kZXhdOw0KICAgICAgICAgICAgICAgIC8vIFRoZSBvcCBjYW4gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIGFuZCBtb2RpZnkgaXQgaW4gcGxhY2UNCiAgICAgICAgICAgICAgICAvLyBhbmQgc2V0IHRoZSBvdXRwdXQgdG8gY2xlYW4uDQogICAgICAgICAgICAgICAgb3BlcmF0b3JPdXRwdXQuZ2V0T3BlcmF0b3IoKS5ldmFsdWF0ZSgpOw0KICAgICAgICAgICAgICAgIGlmICh0bXAgPT0gdGhpcy5kaXJ0eU9wSW5kZXgpIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWwgY29uZmlndXJhdGlvbiBvZiBhbiBvcGVyYXRvciwgY2xlYW5pbmcgb3V0cHV0cyBtaWdodCBiZSBkaXNhYmxlZC4NCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3AgPSB0aGlzLmJvdW5kT3V0cHV0c1t0aGlzLmRpcnR5T3BJbmRleF0uZ2V0T3BlcmF0b3IoKTsNCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BDbGFzc05hbWUgPSBvcC5nZXRDbGFzc05hbWUoKTsNCiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBPcGVyYXRvcjogJHtvcENsYXNzTmFtZX0gd2l0aCBuYW1lOiAke29wLmdldE5hbWUoKX0gaXMgbm90IGNsZWFuaW5nIGl0cyBvdXRwdXRzIGR1cmluZyBldmFsdWF0aW9uYCk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHlPcEluZGV4Kys7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5jbGVhbmluZyA9IGZhbHNlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHBhcmFtZXRlcidzIHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldFZhbHVlKCkgew0KICAgICAgICAgICAgaWYgKHRoaXMuZGlydHlPcEluZGV4IDwgdGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoKSB7DQogICAgICAgICAgICAgICAgdGhpcy5fY2xlYW4odGhpcy5ib3VuZE91dHB1dHMubGVuZ3RoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0VmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbA0KICAgICAgICAgICAgICAgIHRocm93ICd1bmRlZmluZWQgd2FzIHBhc3NlZCBpbnRvIHRoZSBzZXQgdmFsdWUgZm9yIHBhcmFtOicgKyB0aGlzLmdldE5hbWUoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kT3V0cHV0cy5sZW5ndGggPiAwKSB7DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYm91bmRPdXRwdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yT3V0cHV0ID0gdGhpcy5ib3VuZE91dHB1dHNbaV07DQogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3BlcmF0b3JPdXRwdXQuYmFja1Byb3BhZ2F0ZVZhbHVlKHZhbHVlKTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yT3V0cHV0LmdldE1vZGUoKSA9PSAwIC8qIE9QX1dSSVRFICovKQ0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogZXF1YWxpdHkgdGVzdHMgb24gYW55dGhpbmcgYnV0IHNpbXBsZSB2YWx1ZXMgaXMgZ29pbmcgdG8gYmUgc3VwZXIgZXhwZW5zaXZlLg0KICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fdmFsdWUgPT0gdmFsdWUpDQogICAgICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IHZhbHVlOw0KICAgICAgICAgICAgLy8gTm90ZTogb25seSB1c2VycyBjYWxsICdzZXRWYWx1ZScuIE9wZXJhdG9ycyBjYWxsICdzZXRDbGVhbkZyb21PcCcNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3VuZElucHV0cy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHRoaXMuYm91bmRJbnB1dHNbaV0ucGFyYW1WYWx1ZUNoYW5nZWQoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgIH0NCiAgICAgICAgZ2V0IHZhbHVlKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXQgdmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBsb2FkVmFsdWUgaXMgdXNlZCB0byBjaGFuZ2UgdGhlIHZhbHVlIG9mIGEgcGFyYW1ldGVyLCB3aXRob3V0IHRyaWdnZXJpbmcgYQ0KICAgICAgICAgKiB2YWx1ZUNoYW5nZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZTsNCiAgICAgICAgfQ0KICAgICAgICBjb3B5RnJvbShzcmMsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMubG9hZFZhbHVlKHNyYy5fX3ZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlYWRCaW5hcnkgbWV0aG9kLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zb2xlLndhcm4oYFRPRE86IFBhcmFtZXRlcjogJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHdpdGggbmFtZTogJHt0aGlzLl9fbmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IHJlYWRCaW5hcnlgKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVyJ3MgcGF0aCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLg0KICAgICAgICAgKiBJbmNsdWRlcyBvd25lcidzIHBhdGggaW4gY2FzZSBpdCBpcyBvd25lZCBieSBhIGBQYXJhbWV0ZXJPd25lcmAuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0UGF0aCgpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLm93bmVySXRlbSBpbnN0YW5jZW9mIEJhc2VJdGVtKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLm93bmVySXRlbS5nZXRQYXRoKCksIHRoaXMuX19uYW1lXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fX25hbWVdOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIHJlc29sdmVQYXRoKHBhdGgsIGluZGV4ID0gMCkgew0KICAgICAgICAgICAgaWYgKGluZGV4ID09IDApIHsNCiAgICAgICAgICAgICAgICBpZiAocGF0aFswXSA9PSAnLicgfHwgcGF0aFswXSA9PSB0aGlzLl9fbmFtZSkNCiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChwYXRoW2luZGV4XSA9PSAnLi4nKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0pIHsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vd25lckl0ZW0ucmVzb2x2ZVBhdGgocGF0aCwgaW5kZXggKyAxKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0aGlzLl9fb3duZXJJdGVtIGlzIHVuZGVmaW5lZCcpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChpbmRleCA9PSBwYXRoLmxlbmd0aCkgew0KICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKHBhdGhbaW5kZXhdID09ICd2YWx1ZScpIHsNCiAgICAgICAgICAgICAgICAvLyBUaGUgcGF0aCB0byB0aGUgcGFyYW1ldGVyLCBhc3N1bWVzIHRoYXQgdGhlIG5leHQgaXRlbSB3aWxsIGJlIGEgc3ViLXBhcmFtDQogICAgICAgICAgICAgICAgLy8gb2YgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBCYXNlSXRlbSkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUucmVzb2x2ZVBhdGgocGF0aCwgaW5kZXggKyAxKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRoOicgKyBwYXRoICsgJ1snICsgaW5kZXggKyAnXS4gUGF0aCBkb2VzIG5vdCByZXNvbHZlIHRvIGEgQmFzZUl0ZW0nKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlYWRCaW5hcnkgbWV0aG9kLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGRlc3Ryb3koKSB7DQogICAgICAgICAgICBjb25zb2xlLndhcm4oJ25vdGhpbmcgZGVzdHJveWVkLiBUaGlzIG1ldGhvZCB3YXMgbm90IG92ZXJ3cml0dGVuIGluIHN1YmNsYXNzJyk7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IG9ubHkgc3RvcmVzIG51bWVyaWMgdmFsdWVzLg0KICAgICAqDQogICAgICogYGBgamF2YXNjcmlwdA0KICAgICAqIGNvbnN0IG51bWJlclBhcmFtID0gbmV3IE51bWJlclBhcmFtZXRlcignTXlOdW1iZXInLCAxNSkNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIobnVtYmVyUGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBOdW1iZXJQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICByYW5nZTsgLy8gVE9ETzogc2hvdWxkIGNyZWF0ZSB0eXBlIHdpdGggdHdvIGZpZWxkcyBmb3IgcmFuZ2UuIE11c3QgY2hhbmdlIGhvdyByYW5nZSBpcyB1c2VkLg0KICAgICAgICBzdGVwOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgbnVtYmVyIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbnVtYmVyIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSByYW5nZSAtIEFuIGFycmF5IHdpdGggdHdvIG51bWJlcnMuIElmIGRlZmluZWQsIHRoZSBwYXJhbWV0ZXIgdmFsdWUgd2lsbCBiZSBjbGFtcGVkLg0KICAgICAgICAgKiBAcGFyYW0gc3RlcCAtIFRoZSBzdGVwIHZhbHVlLiBJZiBkZWZpbmVkLCB0aGUgcGFyYW1ldGVyIHZhbHVlIHdpbGwgYmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSA9IDAsIHJhbmdlLCBzdGVwKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSwgJ051bWJlcicpOw0KICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlOw0KICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgcmFuZ2UgdG8gd2hpY2ggdGhlIHBhcmFtZXRlciBpcyByZXN0cmFpbmVkLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldFJhbmdlKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2U7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIHJhbmdlIHRvIHdoaWNoIHRoZSBwYXJhbWV0ZXIgaXMgcmVzdHJhaW5lZC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0UmFuZ2UocmFuZ2UpIHsNCiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgc3RlcCBudW1iZXIsIHdoaWNoIGlzIHRoZSBvbmUgdXNlZCBmb3Igcm91bmRpbmcuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0U3RlcCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXA7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgc3RlcCB2YWx1ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHN0ZXAgLSBUaGUgc3RlcCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFN0ZXAoc3RlcCkgew0KICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcDsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJykgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGEgbnVtYmVyLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksIG5hbWU6IHRoaXMubmFtZSwgdmFsdWU6IHRoaXMuX192YWx1ZSB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSBqLnZhbHVlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyBhIG51bWJlciB2YWx1ZSBmcm9tIGEgYnVmZmVyLCB1cGRhdGluZyBjdXJyZW50IHBhcmFtZXRlciBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBDbG9uZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IG51bWJlciBwYXJhbWV0ZXIsIGNvcGllcyBpdHMgdmFsdWVzDQogICAgICAgICAqIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IG51bWJlciBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyUGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5fX3ZhbHVlLCB0aGlzLnJhbmdlLCB0aGlzLnN0ZXApOw0KICAgICAgICB9DQogICAgfQ0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWpzZG9jDQogICAgY2xhc3MgRmxvYXQzMlBhcmFtZXRlciBleHRlbmRzIE51bWJlclBhcmFtZXRlciB7DQogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWpzZG9jDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1qc2RvYw0KICAgIGNsYXNzIFNJbnQzMlBhcmFtZXRlciBleHRlbmRzIE51bWJlclBhcmFtZXRlciB7DQogICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWpzZG9jDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSByZWFkZXIubG9hZFNJbnQzMigpOw0KICAgICAgICB9DQogICAgfQ0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWpzZG9jDQogICAgY2xhc3MgVUludDMyUGFyYW1ldGVyIGV4dGVuZHMgTnVtYmVyUGFyYW1ldGVyIHsNCiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtanNkb2MNCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IHJlYWRlci5sb2FkVUludDMyKCk7DQogICAgICAgIH0NCiAgICB9DQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtanNkb2MNCiAgICBjbGFzcyBBbmdsZVBhcmFtZXRlciBleHRlbmRzIEZsb2F0MzJQYXJhbWV0ZXIgew0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignTnVtYmVyUGFyYW1ldGVyJywgTnVtYmVyUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfU0ludDMyJywgU0ludDMyUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfVUludDMyJywgVUludDMyUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfRmxvYXQzMicsIEZsb2F0MzJQYXJhbWV0ZXIpOw0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdBbmdsZVBhcmFtZXRlcicsIEFuZ2xlUGFyYW1ldGVyKTsKCiAgICAvKioNCiAgICAgKiBSZXByZXNlbnRzIGEgc3BlY2lmaWMgdHlwZSBvZiBwYXJhbWV0ZXIsIHRoYXQgc3RvcmVzIG11bHRpcGxlIGNob2ljZShhcnJheSkgdmFsdWVzLg0KICAgICAqDQogICAgICogaS5lLjoNCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogY29uc3QgbXVsdGlDaG9pY2VQYXJhbWV0ZXIgPSAgbmV3IE11bHRpQ2hvaWNlUGFyYW1ldGVyKCdJbml0aWFsWGZvTW9kZScsIEdST1VQX0lOSVRJQUxfWEZPX01PREVTLmF2ZXJhZ2UsIFsNCiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFudWFsJywNCiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmlyc3QnLA0KICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhdmVyYWdlJywNCiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ2xvYmFsJywNCiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIobXVsdGlDaG9pY2VQYXJhbWV0ZXIpDQogICAgICogYGBgDQogICAgICogQGV4dGVuZHMgTnVtYmVyUGFyYW1ldGVyDQogICAgICovDQogICAgY2xhc3MgTXVsdGlDaG9pY2VQYXJhbWV0ZXIgZXh0ZW5kcyBOdW1iZXJQYXJhbWV0ZXIgew0KICAgICAgICBjaG9pY2VzOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgbXVsdGkgY2hvaWNlIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbXVsdGkgY2hvaWNlIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY2hvaWNlcyAtIFRoZSBjaG9pY2VzIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSwgaW5kZXgsIGNob2ljZXMgPSBbXSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgaW5kZXgsIFswLCBjaG9pY2VzLmxlbmd0aF0sIDEpOw0KICAgICAgICAgICAgdGhpcy5jaG9pY2VzID0gY2hvaWNlczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBjaG9pY2VzIGFycmF5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldENob2ljZXMoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5jaG9pY2VzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHBhcmFtZXRlciBpbmRleCB2YWx1ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0VmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7DQogICAgICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodGhpcy5jaG9pY2VzLmluZGV4T2YodmFsdWUpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlDaG9pY2VQYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLl9fdmFsdWUsIHRoaXMuY2hvaWNlcyk7DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ011bHRpQ2hvaWNlUGFyYW1ldGVyJywgTXVsdGlDaG9pY2VQYXJhbWV0ZXIpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBgYm9vbGVhbmAgdmFsdWVzLg0KICAgICAqDQogICAgICogaS5lLjoNCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogY29uc3QgYm9vbGVhblBhcmFtID0gbmV3IEJvb2xlYW5QYXJhbWV0ZXIoJ015Qm9vbGVhbicsIHRydWUpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKGJvb2xlYW5QYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBCb29sZWFuUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSBuZXcgcGFyYW1ldGVyIHdpdGggYEJvb2xlYW5gIGRhdGEgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYm9vbGVhbiBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgdmFsdWUgIT0gdW5kZWZpbmVkID8gdmFsdWUgOiBmYWxzZSwgJ0Jvb2xlYW4nKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnYm9vbGVhbicpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhIGJvb2xlYW4uIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIExvYWRzIHRoZSBib29sZWFuIHZhbHVlcyBmcm9tIHRoZSBiaW5hcnkgYnVmZmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJlYWRlci5sb2FkVUludDgoKSAhPSAwOw0KICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZSAhPSBuZXdWYWx1ZSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IG5ld1ZhbHVlOw0KICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBCb29sZWFuUGFyYW1ldGVyIGlzIHVzZWQgaW4gVmlzaWJsaXR5DQogICAgICAgICAgICAgICAgLy8gSWYgaXQgY2hhbmdlcywgd2UgbGlzdGVuIGFuZCB1cGRhdGUgdmlzaWlsaXR5IG9mIGVudGlyZSBhc3NlbWJsaWVzLg0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIHNlcmlhbGl6ZXMgdGhpcyBpbnN0YW5jZSBhcyBhIEpTT04uDQogICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciBwZXJzaXN0ZW5jZSwgZGF0YSB0cmFuc2ZlciwgZXRjLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogdGhpcy5nZXRDbGFzc05hbWUoKSwgbmFtZTogdGhpcy5uYW1lLCB2YWx1ZTogdGhpcy5fX3ZhbHVlIH07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgdGFrZXMgYSBKU09OIGFuZCBkZXNlcmlhbGl6ZXMgaW50byBhbiBpbnN0YW5jZSBvZiB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fdmFsdWUgIT0gai52YWx1ZSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IGoudmFsdWU7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIEJvb2xlYW5QYXJhbWV0ZXIgaXMgdXNlZCBpbiBWaXNpYmxpdHkNCiAgICAgICAgICAgICAgICAvLyBJZiBpdCBjaGFuZ2VzLCB3ZSBsaXN0ZW4gYW5kIHVwZGF0ZSB2aXNpaWxpdHkgb2YgZW50aXJlIGFzc2VtYmxpZXMuDQogICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd2YWx1ZUNoYW5nZWQnKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IHBhcmFtZXRlciwgY29waWVzIGl0cyB2YWx1ZXMNCiAgICAgICAgICogZnJvbSB0aGlzIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY2xvbmVkIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuUGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5fX3ZhbHVlKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignQm9vbGVhblBhcmFtZXRlcicsIEJvb2xlYW5QYXJhbWV0ZXIpOw0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdQcm9wZXJ0eV9Cb29sZWFuJywgQm9vbGVhblBhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBWZWMyKHR3by1kaW1lbnNpb25hbCBjb29yZGluYXRlKSB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCB2ZWMyUGFyYW0gPSBuZXcgVmVjMlBhcmFtZXRlcignTXlWZWMyJywgbmV3IFZlYzIoMS4yLCAzLjQpKQ0KICAgICAqIC8vJ215UGFyYW1ldGVyT3duZXJJdGVtJyBpcyBhbiBpbnN0YW5jZSBvZiBhICdQYXJhbWV0ZXJPd25lcicgY2xhc3MuDQogICAgICogLy8gUmVtZW1iZXIgdGhhdCBvbmx5ICdQYXJhbWV0ZXJPd25lcicgYW5kIGNsYXNzZXMgdGhhdCBleHRlbmQgZnJvbSBpdCBjYW4gaG9zdCAnUGFyYW1ldGVyJyBvYmplY3RzLg0KICAgICAqIG15UGFyYW1ldGVyT3duZXJJdGVtLmFkZFBhcmFtZXRlcih2ZWMyUGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiAqKkV2ZW50cyoqDQogICAgICogKiAqKnJhbmdlQ2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiByYWdlIGFycmF5IGNoYW5nZXMuDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBWZWMyUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgcmFuZ2U7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSBWZWMyIHBhcmFtZXRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgVmVjMiBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdmFsdWUgaXMgYW4gYXJyYXkgb2YgdHdvIGBWZWMyYCBvYmplY3RzLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSwgcmFuZ2UpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIHZhbHVlID8gdmFsdWUgOiBuZXcgVmVjMigpLCAnVmVjMicpOw0KICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSByYW5nZSBvZiB2YWx1ZXMgaW4gd2hpY2ggY3VycmVudCBwYXJhbWV0ZXIgY2FuIGJlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldFJhbmdlKCkgew0KICAgICAgICAgICAgLy8gUmFuZ2Ugc2hvdWxkIGJlIGFuIGFycmF5IG9mIDIgdmVjMnMuIFttaW4oeCx5KSwgbWF4KHgseSldDQogICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIF9fc2V0UmFuZ2UgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdmFsdWUuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBzZXRSYW5nZShyYW5nZSkgew0KICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGFuIGFycmF5IFswLCAyMF0NCiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgncmFuZ2VDaGFuZ2VkJywgeyByYW5nZSB9KTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBWZWMyKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgJ1ZlYzInIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYSBudW1iZXIgdmFsdWUgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZT8ucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICB9DQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9fdmFsdWU/LnRvSlNPTigpLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCB2ZWMyID0gbmV3IFZlYzIoKTsNCiAgICAgICAgICAgIHZlYzIuZnJvbUpTT04oai52YWx1ZSk7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2ZWMyOw0KICAgICAgICAgICAgaWYgKGoubmFtZSkNCiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBqLm5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBWZWMyIHBhcmFtZXRlciwgY29waWVzIGl0cyB2YWx1ZXMNCiAgICAgICAgICogZnJvbSB0aGlzIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMiBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IFZlYzJQYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLl9fdmFsdWU/LmNsb25lKCkpOw0KICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2UpDQogICAgICAgICAgICAgICAgY2xvbmVkUGFyYW0uc2V0UmFuZ2UodGhpcy5yYW5nZSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1ZlYzJQYXJhbWV0ZXInLCBWZWMyUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfVmVjMl8zMmYnLCBWZWMyUGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IG9ubHkgc3RvcmVzIFZlYzModGhyZWUtZGltZW5zaW9uYWwgY29vcmRpbmF0ZSkgdmFsdWVzLg0KICAgICAqDQogICAgICogaS5lLjoNCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogY29uc3QgdmVjM1BhcmFtID0gbmV3IFZlYzNQYXJhbWV0ZXIoJ015VmVjMycsIG5ldyBWZWMzKDEuMiwgMy40LCAxKSkNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIodmVjM1BhcmFtKQ0KICAgICAqIGBgYA0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIFZlYzNQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICByYW5nZTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIFZlYzMgcGFyYW1ldGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBWZWMzIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB2YWx1ZSBpcyBhbiBhcnJheSBvZiB0d28gYFZlYzNgIG9iamVjdHMuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlLCByYW5nZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgdmFsdWUgPyB2YWx1ZSA6IG5ldyBWZWMzKCksICdWZWMzJyk7DQogICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7DQogICAgICAgIH0NCiAgICAgICAgc2V0VmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVmVjMykpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBhICdWZWMyJyBjbGFzcy4gQ2hlY2sgdGhlIHNvdXJjZSBvZiB0aGlzIHZhbHVlYCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBzdXBlci5zZXRWYWx1ZSh2YWx1ZSk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYSBudW1iZXIgdmFsdWUgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZT8ucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICB9DQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9fdmFsdWU/LnRvSlNPTigpLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCB2ZWM0ID0gbmV3IFZlYzMoKTsNCiAgICAgICAgICAgIHZlYzQuZnJvbUpTT04oai52YWx1ZSk7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2ZWM0Ow0KICAgICAgICAgICAgaWYgKGoubmFtZSkNCiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBqLm5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBWZWMzIHBhcmFtZXRlciwgY29waWVzIGl0cyB2YWx1ZXMNCiAgICAgICAgICogZnJvbSB0aGlzIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMyBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IFZlYzNQYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLl9fdmFsdWU/LmNsb25lKCkpOw0KICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhcmFtOw0KICAgICAgICB9DQogICAgfQ0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdWZWMzUGFyYW1ldGVyJywgVmVjM1BhcmFtZXRlcik7DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1Byb3BlcnR5X1ZlYzNfMzJmJywgVmVjM1BhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBWZWM0KGZvdXItZGltZW5zaW9uYWwgY29vcmRpbmF0ZSkgdmFsdWVzLg0KICAgICAqDQogICAgICogaS5lLjoNCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogY29uc3QgdmVjNFBhcmFtID0gbmV3IFZlYzRQYXJhbWV0ZXIoJ015VmVjNCcsIG5ldyBWZWM0KDEuMiwgMy40LCAxLCA0LjIpKQ0KICAgICAqIC8vJ215UGFyYW1ldGVyT3duZXJJdGVtJyBpcyBhbiBpbnN0YW5jZSBvZiBhICdQYXJhbWV0ZXJPd25lcicgY2xhc3MuDQogICAgICogLy8gUmVtZW1iZXIgdGhhdCBvbmx5ICdQYXJhbWV0ZXJPd25lcicgYW5kIGNsYXNzZXMgdGhhdCBleHRlbmQgZnJvbSBpdCBjYW4gaG9zdCAnUGFyYW1ldGVyJyBvYmplY3RzLg0KICAgICAqIG15UGFyYW1ldGVyT3duZXJJdGVtLmFkZFBhcmFtZXRlcih2ZWM0UGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBWZWM0UGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIFZlYzQgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBWZWM0IHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSA/IHZhbHVlIDogbmV3IFZlYzQoKSwgJ1ZlYzQnKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBWZWM0KSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgJ1ZlYzQnIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyBhIG51bWJlciB2YWx1ZSBmcm9tIGEgYnVmZmVyLCB1cGRhdGluZyBjdXJyZW50IHBhcmFtZXRlciBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlPy5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgICAgIH0NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksIG5hbWU6IHRoaXMubmFtZSwgdmFsdWU6IHRoaXMuX192YWx1ZT8udG9KU09OKCkgfTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCB2ZWM0ID0gbmV3IFZlYzQoKTsNCiAgICAgICAgICAgIHZlYzQuZnJvbUpTT04oai52YWx1ZSk7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2ZWM0Ow0KICAgICAgICAgICAgaWYgKGoubmFtZSkNCiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBqLm5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBDbG9uZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IFZlYzQgcGFyYW1ldGVyLCBjb3BpZXMgaXRzIHZhbHVlcw0KICAgICAgICAgKiBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWM0IHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgVmVjNFBhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZT8uY2xvbmUoKSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1ZlYzRQYXJhbWV0ZXInLCBWZWM0UGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfVmVjNF8zMmYnLCBWZWM0UGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi8NCiAgICAvKioNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBCb3gyUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIEJveDIgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBCb3gyIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSA/IHZhbHVlIDogbmV3IEJveDIoKSwgJ0JveDInKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBCb3gyKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgJ0JveDInIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYSBudW1iZXIgdmFsdWUgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZS5wMC5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUucDEucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICB9DQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiB7DQogICAgICAgICAgICAgICAgICAgIHAwOiB0aGlzLl9fdmFsdWUucDAudG9KU09OKCksDQogICAgICAgICAgICAgICAgICAgIHAxOiB0aGlzLl9fdmFsdWUucDEudG9KU09OKCksDQogICAgICAgICAgICAgICAgfSwNCiAgICAgICAgICAgIH07DQogICAgICAgIH0NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlLnAwLmZyb21KU09OKGoucDApOw0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlLnAxLmZyb21KU09OKGoucDEpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgQm94MiBwYXJhbWV0ZXIsDQogICAgICAgICAqIGNvcGllcyBpdHMgdmFsdWVzIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNsb25lZCBCb3gyIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgQm94MlBhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZT8uY2xvbmUoKSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0JveDJQYXJhbWV0ZXInLCBCb3gyUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfQm94Ml8zMmYnLCBCb3gyUGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi8NCiAgICAvKioNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBCb3gzUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIEJveDMgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBCb3gzIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSA/IHZhbHVlIDogbmV3IEJveDMoKSwgJ0JveDMnKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBCb3gzKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgJ0JveDMnIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYSBudW1iZXIgdmFsdWUgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZS5wMC5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUucDEucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICB9DQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9fdmFsdWUudG9KU09OKCksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIGlmIChqLnZhbHVlKSB7DQogICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZQ0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZS5mcm9tSlNPTihqLnZhbHVlKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IEJveDMgcGFyYW1ldGVyLA0KICAgICAgICAgKiBjb3BpZXMgaXRzIHZhbHVlcyBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBjbG9uZWQgQm94MyBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IEJveDNQYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLl9fdmFsdWU/LmNsb25lKCkpOw0KICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhcmFtOw0KICAgICAgICB9DQogICAgfQ0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdCb3gzUGFyYW1ldGVyJywgQm94M1BhcmFtZXRlcik7DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1Byb3BlcnR5X0JveDNfMzJmJywgQm94M1BhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBgQ29sb3JgIHZhbHVlcy4NCiAgICAgKg0KICAgICAqIGkuZS46DQogICAgICogYGBgamF2YXNjcmlwdA0KICAgICAqIGNvbnN0IGNvbG9yUGFyYW0gPSBuZXcgQ29sb3JQYXJhbWV0ZXIoJ015Q29sb3InLCBuZXcgQ29sb3IoMCwgMjU0LCAyKSkNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIoY29sb3JQYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIENvbG9yUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIGNvbG9yIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29sb3IgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdmFsdWUpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIHZhbHVlID8gdmFsdWUgOiBuZXcgQ29sb3IoKSwgJ0NvbG9yJyk7DQogICAgICAgIH0NCiAgICAgICAgc2V0VmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQ29sb3IpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYSAnQ29sb3InIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYENvbG9yYCB2YWx1ZXMgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVhZGVyLmxvYWRSR0JBRmxvYXQzMkNvbG9yKCk7DQogICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgaW4gbGluZWFyIHNwYWNlLCB0aGVuIHdlIHNob3VsZCBjb252ZXJ0IGl0IHRvIGdhbW1hIHNwYWNlLg0KICAgICAgICAgICAgLy8gTm90ZTogISEgdGhpcyBzaG91bGQgYWx3YXlzIGJlIGRvbmUgaW4gcHJlcHJvY2Vzc2luZy4uLg0KICAgICAgICAgICAgdmFsdWUuYXBwbHlHYW1tYSgyLjIpOw0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRDbGFzc05hbWUoKSwNCiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsDQogICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX192YWx1ZT8udG9KU09OKCksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIC8vIGlmIChqLnZhbHVlLnR5cGUpIHRoaXMuX192YWx1ZSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKCdDb2xvcicpIGFzIENvbG9yIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgUmVnaXN0cnkuY29uc3RydWN0Q2xhc3MNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZT8uZnJvbUpTT04oai52YWx1ZSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBjb2xvciBwYXJhbWV0ZXIsDQogICAgICAgICAqIGNvcGllcyBpdHMgdmFsdWVzIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNsb25lZCBjb2xvciBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IENvbG9yUGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5fX3ZhbHVlPy5jbG9uZSgpKTsNCiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYXJhbTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignQ29sb3JQYXJhbWV0ZXInLCBDb2xvclBhcmFtZXRlcik7DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1Byb3BlcnR5X0NvbG9yXzMyZicsIENvbG9yUGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IG9ubHkgc3RvcmVzIFZlYzMoZm91ci1kaW1lbnNpb25hbCBjb29yZGluYXRlKSB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCBxdWF0UGFyYW0gPSBuZXcgUXVhdFBhcmFtZXRlcignTXlRdWF0JywgbmV3IFF1YXQoMS4yLCAzLjQsIDEsIDQuMikpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKHF1YXRQYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIFF1YXRQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgUXVhdCBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFF1YXQgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdmFsdWUpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIHZhbHVlID8gdmFsdWUgOiBuZXcgUXVhdCgpLCAnUXVhdCcpOw0KICAgICAgICB9DQogICAgICAgIHNldFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFF1YXQpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYSAnUXVhdCcgY2xhc3MuIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIEV4dHJhY3RzIGEgbnVtYmVyIHZhbHVlIGZyb20gYSBidWZmZXIsIHVwZGF0aW5nIGN1cnJlbnQgcGFyYW1ldGVyIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWU/LnJlYWRCaW5hcnkocmVhZGVyKTsNCiAgICAgICAgfQ0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLA0KICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSwNCiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fX3ZhbHVlPy50b0pTT04oKSwNCiAgICAgICAgICAgIH07DQogICAgICAgIH0NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgcXVhdCA9IG5ldyBRdWF0KCk7DQogICAgICAgICAgICBxdWF0LmZyb21KU09OKGoudmFsdWUpOw0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gcXVhdDsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIENsb25lDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgUXVhdCBwYXJhbWV0ZXIsIGNvcGllcyBpdHMgdmFsdWVzDQogICAgICAgICAqIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xvbmUoKSB7DQogICAgICAgICAgICBjb25zdCBjbG9uZWRQYXJhbSA9IG5ldyBRdWF0UGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5fX3ZhbHVlPy5jbG9uZSgpKTsNCiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYXJhbTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUXVhdFBhcmFtZXRlcicsIFF1YXRQYXJhbWV0ZXIpOw0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdQcm9wZXJ0eV9RdWF0XzMyZicsIFF1YXRQYXJhbWV0ZXIpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBNYXQzKDN4MyBtYXRyaXgpIHZhbHVlcy4NCiAgICAgKg0KICAgICAqIGkuZS46DQogICAgICogYGBgamF2YXNjcmlwdA0KICAgICAqIGNvbnN0IG1hdDNQYXJhbSA9IG5ldyBNYTNQYXJhbWV0ZXIoJ015TWF0MycsIG5ldyBNYXQzKC4uLmFyZ3MpKQ0KICAgICAqIC8vJ215UGFyYW1ldGVyT3duZXJJdGVtJyBpcyBhbiBpbnN0YW5jZSBvZiBhICdQYXJhbWV0ZXJPd25lcicgY2xhc3MuDQogICAgICogLy8gUmVtZW1iZXIgdGhhdCBvbmx5ICdQYXJhbWV0ZXJPd25lcicgYW5kIGNsYXNzZXMgdGhhdCBleHRlbmQgZnJvbSBpdCBjYW4gaG9zdCAnUGFyYW1ldGVyJyBvYmplY3RzLg0KICAgICAqIG15UGFyYW1ldGVyT3duZXJJdGVtLmFkZFBhcmFtZXRlcihtYXQzUGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBNYXQzUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIE1hdDMgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBNYXQzIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIHZhbHVlKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSA/IHZhbHVlIDogbmV3IE1hdDMoKSwgJ01hdDMnKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBNYXQzKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGluc3RhbmNlIG9mIGEgJ01hdDMnIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgYSBudW1iZXIgdmFsdWUgZnJvbSBhIGJ1ZmZlciwgdXBkYXRpbmcgY3VycmVudCBwYXJhbWV0ZXIgc3RhdGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZT8ucmVhZEJpbmFyeShyZWFkZXIpOw0KICAgICAgICB9DQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9fdmFsdWU/LnRvSlNPTigpLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBtYXQzID0gbmV3IE1hdDMoKTsNCiAgICAgICAgICAgIG1hdDMuZnJvbUpTT04oai52YWx1ZSk7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSBtYXQzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgTWF0MyBwYXJhbWV0ZXIsDQogICAgICAgICAqIGNvcGllcyBpdHMgdmFsdWVzIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNsb25lZCBNYXQzIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgTWF0M1BhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZT8uY2xvbmUoKSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ01hdDNQYXJhbWV0ZXInLCBNYXQzUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfTWF0M18zMmYnLCBNYXQzUGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovDQogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IG9ubHkgc3RvcmVzIE1hdDQoNHg0IG1hdHJpeCkgdmFsdWVzLg0KICAgICAqDQogICAgICogaS5lLjoNCiAgICAgKiBgYGBqYXZhc2NyaXB0DQogICAgICogY29uc3QgbWF0NFBhcmFtID0gbmV3IE1hM1BhcmFtZXRlcignTXlNYXQ0JywgbmV3IE1hdDQoLi4uYXJncykpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKG1hdDRQYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIE1hdDRQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgTWF0NCBwYXJhbWV0ZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIE1hdDQgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdmFsdWUpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIHZhbHVlID8gdmFsdWUgOiBuZXcgTWF0NCgpLCAnTWF0NCcpOw0KICAgICAgICB9DQogICAgICAgIHNldFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIE1hdDQpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYSAnTWF0NCcgY2xhc3MuIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyBhIG51bWJlciB2YWx1ZSBmcm9tIGEgYnVmZmVyLCB1cGRhdGluZyBjdXJyZW50IHBhcmFtZXRlciBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlPy5yZWFkQmluYXJ5KHJlYWRlcik7DQogICAgICAgIH0NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRDbGFzc05hbWUoKSwNCiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fX3ZhbHVlPy50b0pTT04oKSwNCiAgICAgICAgICAgIH07DQogICAgICAgIH0NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgbWF0NCA9IG5ldyBNYXQ0KCk7DQogICAgICAgICAgICBtYXQ0LmZyb21KU09OKGoudmFsdWUpOw0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gbWF0NDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IE1hdDQgcGFyYW1ldGVyLA0KICAgICAgICAgKiBjb3BpZXMgaXRzIHZhbHVlcyBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBjbG9uZWQgTWF0NCBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IE1hdDRQYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLl9fdmFsdWU/LmNsb25lKCkpOw0KICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhcmFtOw0KICAgICAgICB9DQogICAgfQ0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdNYXQ0UGFyYW1ldGVyJywgTWF0NFBhcmFtZXRlcik7DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1Byb3BlcnR5X01hdDRfMzJmJywgTWF0NFBhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBgWGZvYCB0cmFuc2Zvcm0gdmFsdWVzLg0KICAgICAqDQogICAgICogYGBgamF2YXNjcmlwdA0KICAgICAqIGNvbnN0IHhmb1BhcmFtID0gbmV3IFhmb1BhcmFtZXRlcignTXlYZm8nLCBuZXcgWGZvKG5ldyBWZWMzKDEuMiwgMy40LCAxKSkpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKHhmb1BhcmFtKQ0KICAgICAqIGBgYA0KICAgICAqDQogICAgICogQGV4dGVuZHMgUGFyYW1ldGVyDQogICAgICovDQogICAgY2xhc3MgWGZvUGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIFhmbyBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFhmbyBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgdmFsdWUgPyB2YWx1ZSA6IG5ldyBYZm8oKSwgJ1hmbycpOw0KICAgICAgICB9DQogICAgICAgIHNldFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFhmbykpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBhICdYZm8nIGNsYXNzLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyBhIG51bWJlciB2YWx1ZSBmcm9tIGEgYnVmZmVyLCB1cGRhdGluZyBjdXJyZW50IHBhcmFtZXRlciBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlLnJlYWRCaW5hcnkocmVhZGVyKTsNCiAgICAgICAgfQ0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogdGhpcy5nZXRDbGFzc05hbWUoKSwgbmFtZTogdGhpcy5uYW1lLCB2YWx1ZTogdGhpcy5fX3ZhbHVlLnRvSlNPTigpIH07DQogICAgICAgIH0NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgeGZvID0gbmV3IFhmbygpOw0KICAgICAgICAgICAgeGZvLmZyb21KU09OKGoudmFsdWUpOw0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0geGZvOw0KICAgICAgICAgICAgaWYgKGoubmFtZSkNCiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBqLm5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBDbG9uZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsb25lIG1ldGhvZCBjb25zdHJ1Y3RzIGEgbmV3IFhmbyBwYXJhbWV0ZXIsIGNvcGllcyBpdHMgdmFsdWVzDQogICAgICAgICAqIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFhmbyBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFBhcmFtID0gbmV3IFhmb1BhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZS5jbG9uZSgpKTsNCiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYXJhbTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignWGZvUGFyYW1ldGVyJywgWGZvUGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfWGZvXzMyZicsIFhmb1BhcmFtZXRlcik7CgogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIDJEIGltYWdlIGl0ZW0sIGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodC4NCiAgICAgKg0KICAgICAqICoqRXZlbnRzKioNCiAgICAgKiAqICoqdXBkYXRlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgb2YgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGxpc3RlZCBhYm92ZSBjaGFuZ2VzLg0KICAgICAqDQogICAgICogQGV4dGVuZHMgUGFyYW1ldGVyT3duZXINCiAgICAgKi8NCiAgICBjbGFzcyBCYXNlSW1hZ2UgZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7DQogICAgICAgIHdpZHRoID0gMDsNCiAgICAgICAgaGVpZ2h0ID0gMDsNCiAgICAgICAgZm9ybWF0ID0gJ1JHQic7DQogICAgICAgIHR5cGUgPSAnVU5TSUdORURfQllURSc7DQogICAgICAgIGxvYWRlZCA9IGZhbHNlOw0KICAgICAgICBtaXBNYXBwZWQgPSB0cnVlOw0KICAgICAgICB3cmFwUyA9ICdSRVBFQVQnOw0KICAgICAgICB3cmFwVCA9ICdSRVBFQVQnOw0KICAgICAgICBtaW5GaWx0ZXIgPSAnTElORUFSJzsNCiAgICAgICAgbWFnRmlsdGVyID0gJ0xJTkVBUic7DQogICAgICAgIGFscGhhRnJvbUx1bWluYW5jZSA9IGZhbHNlOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCYXNlSW1hZ2UuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiB0aGUgaXRlbQ0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICdJbWFnZScpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUpOw0KICAgICAgICAgICAgdGhpcy5vbigncGFyYW1ldGVyVmFsdWVDaGFuZ2VkJywgKCkgPT4gew0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBsb2FkZWQuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgYm9vbGVhbi4NCiAgICAgICAgICovDQogICAgICAgIGlzTG9hZGVkKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGFsbCBwYXJhbWV0ZXJzIGFuZCBjbGFzcyBzdGF0ZSB2YWx1ZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0UGFyYW1zKCkgew0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsDQogICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLmZvcm1hdCwNCiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCwNCiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LA0KICAgICAgICAgICAgICAgIHdyYXBTOiB0aGlzLndyYXBTLA0KICAgICAgICAgICAgICAgIHdyYXBUOiB0aGlzLndyYXBULA0KICAgICAgICAgICAgICAgIG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsDQogICAgICAgICAgICAgICAgbWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlciwNCiAgICAgICAgICAgICAgICBtaXBNYXBwZWQ6IHRoaXMubWlwTWFwcGVkLA0KICAgICAgICAgICAgICAgIGFscGhhRnJvbUx1bWluYW5jZTogdGhpcy5hbHBoYUZyb21MdW1pbmFuY2UsDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBgQmFzZUltYWdlYCB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiAvLyBTaW5jZSBgTGFiZWxgIGlzIGEgYEJhc2VJbWFnZWAgaW1wbGVtZW50YXRpb24sIGl0IGhlbHBzIHVzIHdpdGggdGhlIGV4YW1wbGUuDQogICAgICogY29uc3QgbGFiZWwgPSBuZXcgTGFiZWwoJ015IGF3ZXNvbWUgbGFiZWwnLCAnTGFiZWxQYWNrJykNCiAgICAgKiBjb25zdCBpbWFnZVBhcmFtID0gbmV3IEltYWdlUGFyYW1ldGVyKCdNeUltYWdlJywgbGFiZWwpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKGltYWdlUGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBJbWFnZVBhcmFtZXRlciBleHRlbmRzIFBhcmFtZXRlciB7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYW4gaW1hZ2UgcGFyYW1ldGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBpbWFnZSBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgdmFsdWUsICdCYXNlSW1hZ2UnKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBCYXNlSW1hZ2UpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJ0Jhc2VJbWFnZScgY2xhc3MuIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgaiA9IHsNCiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLA0KICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSwNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlKSB7DQogICAgICAgICAgICAgICAgai5pbWFnZVR5cGUgPSB0aGlzLl9fdmFsdWUuZ2V0Q2xhc3NOYW1lKCk7DQogICAgICAgICAgICAgICAgai52YWx1ZSA9IHRoaXMuX192YWx1ZS50b0pTT04oKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBqOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIGlmIChqLmltYWdlVHlwZSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKGouaW1hZ2VUeXBlKTsNCiAgICAgICAgICAgICAgICBpZiAoai52YWx1ZSkNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlPy5mcm9tSlNPTihqLnZhbHVlLCBjb250ZXh0KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIENsb25lDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgaW1hZ2UgcGFyYW1ldGVyLA0KICAgICAgICAgKiBjb3BpZXMgaXRzIHZhbHVlcyBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBjbG9uZWQgaW1hZ2UgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xvbmUoKSB7DQogICAgICAgICAgICBjb25zdCBjbG9uZWRQYXJhbSA9IG5ldyBJbWFnZVBhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0ltYWdlUGFyYW1ldGVyJywgSW1hZ2VQYXJhbWV0ZXIpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLw0KICAgIC8qKg0KICAgICAqIFJlcHJlc2VudHMgYSBzcGVjaWZpYyB0eXBlIG9mIHBhcmFtZXRlciwgdGhhdCBvbmx5IHN0b3JlcyBNYXQ0KDR4NCBtYXRyaXgpIHZhbHVlcy4NCiAgICAgKg0KICAgICAqIGkuZS46DQogICAgICogYGBgamF2YXNjcmlwdA0KICAgICAqIGNvbnN0IHN0cmluZ1BhcmFtID0gbmV3IFN0cmluZ1BhcmFtZXRlcignTXlTdHJpbmcnLCAnQSBTdHJpbmcgdmFsdWUgZ29lcyBoZXJlJykNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIoc3RyaW5nUGFyYW0pDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBTdHJpbmdQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICBtdWx0aUxpbmU7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSBzdHJpbmcgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtYXRlcmlhbCBjb2xvciBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCB2YWx1ZSA9ICcnKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB2YWx1ZSwgJ1N0cmluZycpOw0KICAgICAgICAgICAgdGhpcy5tdWx0aUxpbmUgPSBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgbmV3IGxpbmUgZmVlZHMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBtdWx0aUxpbmUgLSBUaGUgbXVsdGlMaW5lIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0TXVsdGlMaW5lKG11bHRpTGluZSkgew0KICAgICAgICAgICAgdGhpcy5tdWx0aUxpbmUgPSBtdWx0aUxpbmU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgbXVsdGktbGluZSBmbGFnIHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldE11bHRpTGluZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpTGluZTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGEgc3RyaW5nLiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogRXh0cmFjdHMgdGhlIHN0cmluZyB2YWx1ZSBmcm9tIGEgYnVmZmVyLCB1cGRhdGluZyBjdXJyZW50IHBhcmFtZXRlciBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2Qgc2VyaWFsaXplcyB0aGlzIGluc3RhbmNlIGFzIGEgSlNPTi4NCiAgICAgICAgICogSXQgY2FuIGJlIHVzZWQgZm9yIHBlcnNpc3RlbmNlLCBkYXRhIHRyYW5zZmVyLCBldGMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLCBuYW1lOiB0aGlzLm5hbWUsIHZhbHVlOiB0aGlzLl9fdmFsdWUgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCB0YWtlcyBhIEpTT04gYW5kIGRlc2VyaWFsaXplcyBpbnRvIGFuIGluc3RhbmNlIG9mIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBqLnZhbHVlID8/ICcnOw0KICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZSAhPSBuZXdWYWx1ZSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IG5ld1ZhbHVlOw0KICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBCb29sZWFuUGFyYW1ldGVyIGlzIHVzZWQgaW4gVmlzaWJsaXR5DQogICAgICAgICAgICAgICAgLy8gSWYgaXQgY2hhbmdlcywgd2UgbGlzdGVuIGFuZCB1cGRhdGUgdmlzaWlsaXR5IG9mIGVudGlyZSBhc3NlbWJsaWVzLg0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBzdHJpbmcgcGFyYW1ldGVyLCBjb3BpZXMgaXRzIHZhbHVlcw0KICAgICAgICAgKiBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBzdHJpbmcgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xvbmUoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1BhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZSk7DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1N0cmluZ1BhcmFtZXRlcicsIFN0cmluZ1BhcmFtZXRlcik7DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1Byb3BlcnR5X1N0cmluZycsIFN0cmluZ1BhcmFtZXRlcik7CgogICAgLyoqDQogICAgICogQSBwYXJhbWV0ZXIgZm9yIHN0b3JpbmcgYW4gYXJyYXkgb2Ygc3RyaW5nIHZhbHVlcy4NCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIFN0cmluZ0xpc3RQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgc3RyaW5nIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWF0ZXJpYWwgY29sb3IgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdmFsdWUgPSBbXSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSwgdmFsdWUsICdTdHJpbmdbXScpOw0KICAgICAgICB9DQogICAgICAgIHNldFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBwcm92aWRlZCBpcyBub3QgYW4gYXJyYXkuIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgc3VwZXIuc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyB0aGUgc3RyaW5nIHZhbHVlIGZyb20gYSBidWZmZXIsIHVwZGF0aW5nIGN1cnJlbnQgcGFyYW1ldGVyIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSByZWFkZXIubG9hZFN0ckFycmF5KCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIHNlcmlhbGl6ZXMgdGhpcyBpbnN0YW5jZSBhcyBhIEpTT04uDQogICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciBwZXJzaXN0ZW5jZSwgZGF0YSB0cmFuc2ZlciwgZXRjLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCB1bmRlZmluZWQ+fSAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksIG5hbWU6IHRoaXMubmFtZSwgdmFsdWU6IHRoaXMuX192YWx1ZSB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIHRha2VzIGEgSlNPTiBhbmQgZGVzZXJpYWxpemVzIGludG8gYW4gaW5zdGFuY2Ugb2YgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCB1bmRlZmluZWQ+fSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gai52YWx1ZTsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBzdHJpbmcgcGFyYW1ldGVyLCBjb3BpZXMgaXRzIHZhbHVlcw0KICAgICAgICAgKiBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmdMaXN0UGFyYW1ldGVyfSAtIFJldHVybnMgYSBuZXcgc3RyaW5nIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgU3RyaW5nTGlzdFBhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuX192YWx1ZSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1N0cmluZ0xpc3RQYXJhbWV0ZXInLCBTdHJpbmdMaXN0UGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfU3RyaW5nTGlzdCcsIFN0cmluZ0xpc3RQYXJhbWV0ZXIpOwoKICAgIC8qKg0KICAgICAqIEEgcGFyYW1ldGVyIGZvciBzdG9yaW5nIGFuIGFycmF5IG9mIHN0cmluZyB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyBQYXJhbWV0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBGbG9hdDMyQXJyYXlQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgc3RyaW5nIHBhcmFtZXRlci4NCiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWF0ZXJpYWwgY29sb3IgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KCkpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIHZhbHVlLCAnRmxvYXRbXScpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBFeHRyYWN0cyB0aGUgc3RyaW5nIHZhbHVlIGZyb20gYSBidWZmZXIsIHVwZGF0aW5nIGN1cnJlbnQgcGFyYW1ldGVyIHN0YXRlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSByZWFkZXIubG9hZEZsb2F0MzJBcnJheSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBzZXJpYWxpemVzIHRoaXMgaW5zdGFuY2UgYXMgYSBKU09OLg0KICAgICAgICAgKiBJdCBjYW4gYmUgdXNlZCBmb3IgcGVyc2lzdGVuY2UsIGRhdGEgdHJhbnNmZXIsIGV0Yy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgdW5kZWZpbmVkPn0gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLCBuYW1lOiB0aGlzLm5hbWUsIHZhbHVlOiB0aGlzLl9fdmFsdWUgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCB0YWtlcyBhIEpTT04gYW5kIGRlc2VyaWFsaXplcyBpbnRvIGFuIGluc3RhbmNlIG9mIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgdW5kZWZpbmVkPn0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IGoudmFsdWU7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgc3RyaW5nIHBhcmFtZXRlciwgY29waWVzIGl0cyB2YWx1ZXMNCiAgICAgICAgICogZnJvbSB0aGlzIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5UGFyYW1ldGVyfSAtIFJldHVybnMgYSBuZXcgc3RyaW5nIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgRmxvYXQzMkFycmF5UGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5fX3ZhbHVlKTsNCiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYXJhbTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignRmxvYXQzMkFycmF5UGFyYW1ldGVyJywgRmxvYXQzMkFycmF5UGFyYW1ldGVyKTsNCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUHJvcGVydHlfRmxvYXQzMkFycmF5JywgRmxvYXQzMkFycmF5UGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi8NCiAgICAvKioNCiAgICAgKiBBIFBhcmFtZXRlciBmb3Igc3RvcmluZyBsaXN0KGFycmF5KSB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCBsaXN0UGFyYW0gPSBuZXcgTGlzdFBhcmFtZXRlcignTXlMaXN0JywgR2VhclBhcmFtZXRlcikNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIobGlzdFBhcmFtKQ0KICAgICAqIGBgYA0KICAgICAqDQogICAgICogKipFdmVudHMqKg0KICAgICAqICogKip2YWx1ZUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gc2V0dGluZyBhIHZhbHVlIGNoYW5nZXMgaW4gdGhlIGFycmF5KGluc2VydCwgYWRkLCByZW1vdmUpLg0KICAgICAqICogKiplbGVtZW50QWRkZWQ6KiogVHJpZ2dlcmVkIHdoZW4gYW4gZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgYXJyYXkoYWRkLCBpbnNlcnQpLg0KICAgICAqICogKiplbGVtZW50UmVtb3ZlZDoqKiBUcmlnZ2VyZWQgd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkNCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIExpc3RQYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgbGlzdCBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGxpc3QgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gZGF0YVR5cGUgLSBUaGUgZGF0YVR5cGUgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIGRhdGFUeXBlKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCBbXSwgZGF0YVR5cGUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZmlsdGVyIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGl0ZW0gLSBUaGUgaXRlbSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBmaWx0ZXIoaXRlbSkgew0KICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGNvdW50IG9mIGl0ZW1zIGluIHRoZSBhcnJheS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRDb3VudCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmFsdWU/Lmxlbmd0aCB8fCAwOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHZhbHVlIGZyb20gdGhlIGFycmF5IGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRFbGVtZW50KGluZGV4KSB7DQogICAgICAgICAgICBpZiAoIXRoaXMuX192YWx1ZSkNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX3ZhbHVlW2luZGV4XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBhIHZhbHVlIGluIHRoZSBzcGVjaWZpZWQgYXJyYXkncyBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRFbGVtZW50KGluZGV4LCB2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUpDQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gW107DQogICAgICAgICAgICB0aGlzLl9fdmFsdWVbaW5kZXhdID0gdmFsdWU7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBZGRzIGEgbmV3IGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgcGlsZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGVsZW0gLSBUaGUgZWxlbSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBhZGRFbGVtZW50KGVsZW0pIHsNCiAgICAgICAgICAgIGlmICgoIWVsZW0gJiYgZWxlbSAhPSAwKSB8fCAhdGhpcy5maWx0ZXIoZWxlbSkpDQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUpDQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gW107DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUucHVzaChlbGVtKTsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgnZWxlbWVudEFkZGVkJywgeyBlbGVtLCBpbmRleDogdGhpcy5fX3ZhbHVlLmxlbmd0aCAtIDEgfSk7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICAgICAgcmV0dXJuIGVsZW07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlbW92ZXMgYW4gYXJyYXkgZWxlbWVudCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXgNCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlRWxlbWVudChpbmRleCkgew0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUpDQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gW107DQogICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5fX3ZhbHVlW2luZGV4XTsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZS5zcGxpY2UoaW5kZXgsIDEpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdlbGVtZW50UmVtb3ZlZCcsIHsgZWxlbSwgaW5kZXggfSk7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBJbnNlcnRzIGEgbmV3IGVsZW1lbnQgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gZWxlbSAtIFRoZSBlbGVtIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgaW5zZXJ0RWxlbWVudChpbmRleCwgZWxlbSkgew0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUgfHwgIXRoaXMuZmlsdGVyKGVsZW0pKQ0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZS5zcGxpY2UoaW5kZXgsIDAsIGVsZW0pOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdlbGVtZW50QWRkZWQnLCB7IGVsZW0sIGluZGV4IH0pOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCd2YWx1ZUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGFuIGFycmF5LiBDaGVjayB0aGUgc291cmNlIG9mIHRoaXMgdmFsdWVgKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHN1cGVyLnNldFZhbHVlKHZhbHVlKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gW107DQogICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlKSB7DQogICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuX192YWx1ZSkgew0KICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGF0YVR5cGUgPT09ICdzdHJpbmcnKQ0KICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChwKTsNCiAgICAgICAgICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChwLnRvSlNPTihjb250ZXh0KSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLA0KICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSwNCiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBpZiAoai5pdGVtcyA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgUGFyYW1ldGVyIEpTT04nKTsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSBbXTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgai5pdGVtcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIGxldCBlbGVtOw0KICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhVHlwZSA9PT0gJ3N0cmluZycpIHsNCiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGouaXRlbXNbaV07DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGF0YVR5cGUpDQogICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnTm8gRGF0YVR5cGUnOw0KICAgICAgICAgICAgICAgICAgICBlbGVtID0gUmVnaXN0cnkuY29uc3RydWN0Q2xhc3ModGhpcy5kYXRhVHlwZSk7DQogICAgICAgICAgICAgICAgICAgIGVsZW0uZnJvbUpTT04oai5pdGVtc1tpXSwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZS5wdXNoKGVsZW0pOw0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZWxlbWVudEFkZGVkJywgeyBlbGVtLCBpbmRleDogdGhpcy5fX3ZhbHVlLmxlbmd0aCAtIDEgfSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gQ2xvbmUgYW5kIERlc3Ryb3kNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyBsaXN0IHBhcmFtZXRlciwgY29waWVzIGl0cyB2YWx1ZXMNCiAgICAgICAgICogZnJvbSB0aGlzIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgbGlzdCBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjbG9uZSgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdGhpcy5fX3ZhbHVlID8gdGhpcy5fX3ZhbHVlLnNsaWNlKDApIDogW107DQogICAgICAgICAgICBpZiAoIXRoaXMuZGF0YVR5cGUpDQogICAgICAgICAgICAgICAgdGhyb3cgJ1RoaXMgcGFyYW1ldGVyIGRvZXMgbm90IGhhdmUgYSBEYXRhVHlwZSc7DQogICAgICAgICAgICBjb25zdCBjbG9uZWRQYXJhbSA9IG5ldyBMaXN0UGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy5kYXRhVHlwZSk7DQogICAgICAgICAgICBjbG9uZWRQYXJhbS5zZXRWYWx1ZShjbG9uZWRWYWx1ZSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBkZXN0cm95IGlzIGNhbGxlZCBieSB0aGUgc3lzdGVtIHRvIGNhdXNlIGV4cGxpY2l0IHJlc291cmNlcyBjbGVhbnVwLg0KICAgICAgICAgKiBVc2VycyBzaG91bGQgbmV2ZXIgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5Lg0KICAgICAgICAgKi8NCiAgICAgICAgZGVzdHJveSgpIHsNCiAgICAgICAgICAgIGlmICghdGhpcy5fX3ZhbHVlKQ0KICAgICAgICAgICAgICAgIHJldHVybjsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fX3ZhbHVlLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZVtpXSBpbnN0YW5jZW9mIFBhcmFtZXRlcikNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlW2ldLmRlc3Ryb3koKTsNCiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoaSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0xpc3RQYXJhbWV0ZXInLCBMaXN0UGFyYW1ldGVyKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzICovDQogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IHN0b3JlcyBtdWx0aXBsZSBwYXJhbWV0ZXJzIGluIG9iamVjdCBmb3JtYXQuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCBzdHJ1Y3RQYXJhbSA9IG5ldyBTdHJ1Y3RQYXJhbWV0ZXIoJ015U3RydWN0UGFyYW0nKQ0KICAgICAqIC8vJ215UGFyYW1ldGVyT3duZXJJdGVtJyBpcyBhbiBpbnN0YW5jZSBvZiBhICdQYXJhbWV0ZXJPd25lcicgY2xhc3MuDQogICAgICogLy8gUmVtZW1iZXIgdGhhdCBvbmx5ICdQYXJhbWV0ZXJPd25lcicgYW5kIGNsYXNzZXMgdGhhdCBleHRlbmQgZnJvbSBpdCBjYW4gaG9zdCAnUGFyYW1ldGVyJyBvYmplY3RzLg0KICAgICAqIG15UGFyYW1ldGVyT3duZXJJdGVtLmFkZFBhcmFtZXRlcihzdHJ1Y3RQYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqICoqRXZlbnRzKioNCiAgICAgKiAqICoqdmFsdWVDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuZXZlciBwYXJhbWV0ZXIncyB2YWx1ZSBjaGFuZ2VzLg0KICAgICAqDQogICAgICogQGV4dGVuZHMgUGFyYW1ldGVyDQogICAgICovDQogICAgY2xhc3MgU3RydWN0UGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgbWVtYmVyczsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIHN0cnVjdCBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cnVjdCBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCB7fSwgJ1N0cnVjdCcpOw0KICAgICAgICAgICAgdGhpcy5tZW1iZXJzID0gW107DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBfYWRkTWVtYmVyIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIHBhcmFtZXRlciAtIFRoZSBwYXJhbWV0ZXIgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKi8NCiAgICAgICAgYWRkTWVtYmVyKHBhcmFtZXRlcikgew0KICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZSkNCiAgICAgICAgICAgICAgICB0aGlzLl9fdmFsdWVbcGFyYW1ldGVyLmdldE5hbWUoKV0gPSBwYXJhbWV0ZXIudmFsdWU7DQogICAgICAgICAgICBwYXJhbWV0ZXIub24oJ3ZhbHVlQ2hhbmdlZCcsICgpID0+IHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlKQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdmFsdWVbcGFyYW1ldGVyLmdldE5hbWUoKV0gPSBwYXJhbWV0ZXIudmFsdWU7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIHRoaXMubWVtYmVycy5wdXNoKHBhcmFtZXRlcik7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldFBhcmFtZXRlciBtZXRob2QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldFBhcmFtZXRlcihuYW1lKSB7DQogICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5tZW1iZXJzKSB7DQogICAgICAgICAgICAgICAgaWYgKHAuZ2V0TmFtZSgpID09IG5hbWUpDQogICAgICAgICAgICAgICAgICAgIHJldHVybiBwOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTG9va3MgZm9yIGEgbWVtYmVyIHBhcmFtZXRlciB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TWVtYmVyKG5hbWUpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhcmFtZXRlcihuYW1lKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiBhbGwgcGFyYW1ldGVycyBpbiBTdHJ1Y3RQYXJhbWV0ZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TWVtYmVyTmFtZXMoKSB7DQogICAgICAgICAgICBjb25zdCBuYW1lcyA9IFtdOw0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLm1lbWJlcnNbaV07DQogICAgICAgICAgICAgICAgaWYgKG1lbWJlciAhPSBudWxsKQ0KICAgICAgICAgICAgICAgICAgICBuYW1lc1tpXSA9IG1lbWJlci5nZXROYW1lKCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gbmFtZXM7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBtZW1iZXJzID0gW107DQogICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5tZW1iZXJzKQ0KICAgICAgICAgICAgICAgIG1lbWJlcnMucHVzaChwLnRvSlNPTihjb250ZXh0KSk7DQogICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLCBuYW1lOiB0aGlzLm5hbWUsIG1lbWJlcnMgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgaWYgKGoubWVtYmVycyA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgUGFyYW1ldGVyIEpTT04nKTsNCiAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICB9DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGoubWVtYmVycy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIGlmIChqLm1lbWJlcnNbaV0pIHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldLmZyb21KU09OKGoubWVtYmVyc1tpXSwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5uYW1lID0gai5uYW1lOw0KICAgICAgICB9DQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgU3RydWN0UGFyYW1ldGVyKHRoaXMubmFtZSk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFyYW07DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBEZXN0cm95DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZGVzdHJveSBpcyBjYWxsZWQgYnkgdGhlIHN5c3RlbSB0byBjYXVzZSBleHBsaWNpdCByZXNvdXJjZXMgY2xlYW51cC4NCiAgICAgICAgICogVXNlcnMgc2hvdWxkIG5ldmVyIG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseS4NCiAgICAgICAgICovDQogICAgICAgIGRlc3Ryb3koKSB7DQogICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5tZW1iZXJzKSB7DQogICAgICAgICAgICAgICAgLy8gVE9ETzogbm90IHN1cmUgYWJvdXQgdGhpcy4gSSBhZGRlZCBhIGRvLW5vdGhpbmcgZGVzdHJveSBtZXRob2QgaW4gUGFyYW1ldGVyPFQ+IHRvIGJlIG92ZXJ3cml0dGVuDQogICAgICAgICAgICAgICAgLy8gc2luY2Ugb25seSBzb21lIHN1YmNsYXNzZXMgdXNlIGRlc3Ryb3kuDQogICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1N0cnVjdFBhcmFtZXRlcicsIFN0cnVjdFBhcmFtZXRlcik7CgogICAgLyoqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVyYXRvciBvdXRwdXQuDQogICAgICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyDQogICAgICovDQogICAgY2xhc3MgT3BlcmF0b3JPdXRwdXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgew0KICAgICAgICBfX25hbWU7DQogICAgICAgIF9tb2RlOw0KICAgICAgICBfb3AgPSBudWxsOw0KICAgICAgICBfcGFyYW07DQogICAgICAgIF9wYXJhbUJpbmRJbmRleDsNCiAgICAgICAgZGV0YWNoZWQ7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYW4gb3BlcmF0b3Igb3V0cHV0Lg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gb3BlcmF0b3JPdXRwdXRNb2RlIC0gVGhlIG1vZGUgd2hpY2ggdGhlIE9wZXJhdG9yT3V0cHV0IHVzZXMgdG8gYmluZCB0byBpdHMgdGFyZ2V0IHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wZXJhdG9yT3V0cHV0TW9kZSA9IE9wZXJhdG9yT3V0cHV0TW9kZS5PUF9XUklURSkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuX19uYW1lID0gbmFtZTsNCiAgICAgICAgICAgIHRoaXMuX21vZGUgPSBvcGVyYXRvck91dHB1dE1vZGU7DQogICAgICAgICAgICB0aGlzLl9wYXJhbSA9IHVuZGVmaW5lZDsNCiAgICAgICAgICAgIHRoaXMuX3BhcmFtQmluZEluZGV4ID0gLTE7DQogICAgICAgICAgICB0aGlzLmRldGFjaGVkID0gZmFsc2U7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgbmFtZSBvZiB0aGUgb3V0cHV0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIG5hbWUgc3RyaW5nLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TmFtZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbmFtZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBvcGVyYXRvciB0aGF0IG93bnMgdGhpcyBvdXRwdXQuIENhbGxlZCBieSB0aGUgb3BlcmF0b3Igd2hlbiBhZGRpbmcgb3V0cHV0cw0KICAgICAgICAgKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0b3Igb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0T3BlcmF0b3Iob3ApIHsNCiAgICAgICAgICAgIHRoaXMuX29wID0gb3A7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgb3BlcmF0b3IgdGhhdCBvd25zIHRoaXMgb3V0cHV0Lg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIG9wZXJhdG9yIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIGdldE9wZXJhdG9yKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIG1vZGUgdGhhdCB0aGUgb3V0cHV0IHdyaXRlcyB0byBiZSBwYXJhbWV0ZXIuIE11c3QgYmUgYSBudW1iZXIgZnJvbSBPcGVyYXRvck91dHB1dE1vZGUNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBtb2RlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TW9kZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBvdXRwdXQgaXMgY29ubmVjdGVkIHRvIGEgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzQ29ubmVjdGVkKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtICE9IHVuZGVmaW5lZDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldFBhcmFtIG1ldGhvZC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRQYXJhbSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgUGFyYW1ldGVyIGZvciB0aGlzIG91dHB1dCB0byB3cml0ZSB0by4NCiAgICAgICAgICogQHBhcmFtIHBhcmFtIC0gVGhlIHBhcmFtIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdG8gYmluZCBhdCBpbiB0aGUgUGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0UGFyYW0ocGFyYW0sIGluZGV4ID0gLTEpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJhbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtLnVuYmluZE9wZXJhdG9yT3V0cHV0KHRoaXMpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5fcGFyYW0gPSBwYXJhbTsNCiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJhbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtQmluZEluZGV4ID0gdGhpcy5fcGFyYW0uYmluZE9wZXJhdG9yT3V0cHV0KHRoaXMsIGluZGV4KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuZW1pdCgncGFyYW1TZXQnLCB7IHBhcmFtOiB0aGlzLl9wYXJhbSB9KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGJpbmRpbmcgb24gdGhlIHBhcmFtZXRlciBvZiB0aGlzIE9wZXJhdG9yT3V0cHV0DQogICAgICAgICAqIHVwIHRvIGRhdGUuDQogICAgICAgICAqIEByZXR1cm4gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGJpbmRpbmcgb24gdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGdldFBhcmFtQmluZEluZGV4KCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtQmluZEluZGV4Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBJZiBiaW5kaW5ncyBjaGFuZ2Ugb24gYSBQYXJhbWV0ZXIsIGl0IHdpbGwgY2FsbCB0aGlzIG1ldGhvZCB0byBlbnN1cmUgdGhlIG91dHB1dCBpbmRleCBpcw0KICAgICAgICAgKiB1cCB0byBkYXRlLg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGJpbmRpbmcgb24gdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIHNldFBhcmFtQmluZEluZGV4KGluZGV4KSB7DQogICAgICAgICAgICB0aGlzLl9wYXJhbUJpbmRJbmRleCA9IGluZGV4Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBQcm9wYWdhdGVzIGRpcnR5IHRvIHRoZSBjb25uZWN0ZWQgcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RGlydHkoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5fcGFyYW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbS5zZXREaXJ0eSh0aGlzLl9wYXJhbUJpbmRJbmRleCk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRWYWx1ZSBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0VmFsdWUoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5fcGFyYW0pIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW0uZ2V0VmFsdWVGcm9tT3AodGhpcy5fcGFyYW1CaW5kSW5kZXgpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0cy1taWdyYXRlKDI1NTQpIEZJWE1FOiBFeHBlY3RlZCAwLTEgYXJndW1lbnRzLCBidXQgZ290IDIuDQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBnZXRWYWx1ZSBvbiBPcGVyYXRvck91dHB1dCB0aGF0IGlzIG5vdCBjb25uZWN0ZWQ6JywgdGhpcy5fX25hbWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBXaGVuIHRoZSB2YWx1ZSBvbiBhIFBhcmFtZXRlciBpcyBtb2RpZmllZCBieSBhIHVzZXIgYnkgY2FsbGluZyAnc2V0VmFsdWUsDQogICAgICAgICAqIHRoZW4gaWYgYW55IG9wZXJhdG9ycyBhcmUgYm91bmQsIHRoZSB2YWx1ZSBvZiB0aGUgUGFyYW1ldGVyIGNhbm5vdCBiZSBtb2RpZmllZA0KICAgICAgICAgKiBkaXJlY3RseSBhcyBpdCBpcyB0aGUgcmVzdWx0IG9mIGEgY29tcHV0YXRpb24uIEluc3RlYWQsIHRoZSBQYXJhbWV0ZXIgY2FsbHMNCiAgICAgICAgICogJ2JhY2tQcm9wYWdhdGVWYWx1ZScgb24gdGhlIE9wZXJhdG9yIHRvIGNhdXNlIHRoZSBPcGVyYXRvciB0byBoYW5kbGUgcHJvcGFnYXRpbmcNCiAgICAgICAgICogdGhlIHZhbHVlIHRvIG9uZSBvciBtb3JlIG9mIGl0cyBpbnB1dHMuDQogICAgICAgICAqIHRvIGl0cyBpbnB1dHMuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBwYXJhbS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBtb2RpZmllZCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGJhY2tQcm9wYWdhdGVWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHRoaXMuX29wKSB7DQogICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9vcC5iYWNrUHJvcGFnYXRlVmFsdWUodmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHZhbHVlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgc2V0Q2xlYW4gbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRDbGVhbih2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmFtKSB7DQogICAgICAgICAgICAgICAgdGhpcy5fcGFyYW0uc2V0Q2xlYW5Gcm9tT3AodmFsdWUsIHRoaXMuX3BhcmFtQmluZEluZGV4KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IHBhcmFtUGF0aCA9IHRoaXMuX3BhcmFtID8gdGhpcy5fcGFyYW0uZ2V0UGF0aCgpIDogJyc7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX19uYW1lLA0KICAgICAgICAgICAgICAgIHBhcmFtUGF0aDogY29udGV4dCAmJiBjb250ZXh0Lm1ha2VSZWxhdGl2ZSA/IGNvbnRleHQubWFrZVJlbGF0aXZlKHBhcmFtUGF0aCkgOiBwYXJhbVBhdGgsDQogICAgICAgICAgICAgICAgcGFyYW1CaW5kSW5kZXg6IHRoaXMuX3BhcmFtQmluZEluZGV4LA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgaWYgKGoucGFyYW1QYXRoKSB7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIHRyZWUgc2hvdWxkIGhhdmUgZnVsbHkgbG9hZGVkIGJ5IHRoZSB0aW1lIHdlIGFyZSBsb2FkaW5nIG9wZXJhdG9ycw0KICAgICAgICAgICAgICAgIC8vIGV2ZW4gbmV3IGl0ZW1zIGFuZCBncm91cHMgc2hvdWxkIGhhdmUgYmVlbiBjcmVhdGVkLiBPcGVyYXRvcnMgYW5kIHN0YXRlIG1hY2hpbmVzDQogICAgICAgICAgICAgICAgLy8gYXJlIGxvYWRlZCBsYXN0Lg0KICAgICAgICAgICAgICAgIGNvbnRleHQ/LnJlc29sdmVQYXRoKGoucGFyYW1QYXRoLCAocGFyYW0pID0+IHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbShwYXJhbSwgai5wYXJhbUJpbmRJbmRleCk7DQogICAgICAgICAgICAgICAgfSwgKHJlYXNvbikgPT4gew0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIk9wZXJhdG9yT3V0cHV0OiAnIiArIHRoaXMuZ2V0TmFtZSgpICsgIicuIFVuYWJsZSB0byBjb25uZWN0IHRvOiIgKyBqLnBhcmFtUGF0aCk7DQogICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBkZXRhY2ggbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdG9yIGlzIGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUgdHJlZS4NCiAgICAgICAgICogSXQgcmVtb3ZlcyBhbGwgY29ubmVjdGlvbnMgdG8gcGFyYW1ldGVycyBpbiB0aGUgc2NlbmUuDQogICAgICAgICAqLw0KICAgICAgICBkZXRhY2goKSB7DQogICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHdlIHdhbnQgdG8gc3VzcGVuZCBhbiBvcGVyYXRvcg0KICAgICAgICAgICAgLy8gZnJvbSBmdW5jdGlvbmluZyBiZWNhdXNlIGl0IGlzIGRlbGV0ZWQgYW5kIG9uIHRoZSB1bmRvIHN0YWNrLg0KICAgICAgICAgICAgLy8gT25jZSBvcGVyYXRvcnMgaGF2ZSBwZXJzaXN0ZW50IGNvbm5lY3Rpb25zLA0KICAgICAgICAgICAgLy8gd2Ugd2lsbCBzaW1wbHkgdW5pbnN0YWxsIHRoZSBvdXRwdXQgZnJvbSB0aGUgcGFyYW1ldGVyLg0KICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IHRydWU7DQogICAgICAgICAgICB0aGlzLl9wYXJhbUJpbmRJbmRleCA9IHRoaXMuX3BhcmFtID8gdGhpcy5fcGFyYW0udW5iaW5kT3BlcmF0b3JPdXRwdXQodGhpcykgOiAtMTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlYXR0YWNoIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHdoZW4gcmUtaW5zdGF0aW5nIGFuIG9wZXJhdG9yIGluIHRoZSBzY2VuZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYXR0YWNoKCkgew0KICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlOw0KICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmFtKSB7DQogICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1CaW5kSW5kZXggPSB0aGlzLl9wYXJhbS5iaW5kT3BlcmF0b3JPdXRwdXQodGhpcywgdGhpcy5fcGFyYW1CaW5kSW5kZXgpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgcmViaW5kIHJlYmluZHMgdGhlIG91dHB1dHMgdG8gYmUgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgZm9yIGl0cyBwYXJhbWV0ZXIuDQogICAgICAgICAqLw0KICAgICAgICByZWJpbmQoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5fcGFyYW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbS51bmJpbmRPcGVyYXRvck91dHB1dCh0aGlzKTsNCiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbUJpbmRJbmRleCA9IHRoaXMuX3BhcmFtLmJpbmRPcGVyYXRvck91dHB1dCh0aGlzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgIH0NCiAgICBjbGFzcyBYZm9PcGVyYXRvck91dHB1dCBleHRlbmRzIE9wZXJhdG9yT3V0cHV0IHsNCiAgICB9CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIC8qKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVyYXRvci4NCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlck93bmVyDQogICAgICovDQogICAgY2xhc3MgT3BlcmF0b3IgZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7DQogICAgICAgIF9faW5wdXRzOw0KICAgICAgICBfX291dHB1dHM7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYW4gb3BlcmF0b3IuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycpIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUpOw0KICAgICAgICAgICAgdGhpcy5fX2lucHV0cyA9IG5ldyBNYXAoKTsNCiAgICAgICAgICAgIHRoaXMuX19vdXRwdXRzID0gbmV3IE1hcCgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgb3BlcmF0b3IgdG8gZGlydHkgd2hpY2ggcHJvcGFnYXRlcw0KICAgICAgICAgKiB0byB0aGUgb3V0cHV0cyBvZiB0aGlzIG9wZXJhdG9yLCBhbmQgd2hpY2ggbWF5IHRoZW4gcHJvcGFnYXRlIHRvIG90aGVyDQogICAgICAgICAqIG9wZXJhdG9ycy4gV2hlbiB0aGUgc2NlbmUgaXMgY2xlYW5lZCwgd2hpY2ggdXN1YWxseSBpcyBjYXVzZWQgYnkgcmVuZGVyaW5nDQogICAgICAgICAqIHRoZW4gdGhlIGNoYWluIG9mIG9wZXJhdG9ycyBhcmUgY2xlYW5lZCBieSB0cmlnZ2VyaW5nIGV2YWx1YXRpb24uDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBzZXREaXJ0eSgpIHsNCiAgICAgICAgICAgIHRoaXMuX19vdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4gb3V0cHV0LnNldERpcnR5KCkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBkZXJpdmVkIGNsYXNzZXMNCiAgICAgICAgICogdG8gcGVyZm9ybSBnZW5lcmFsIHVwZGF0ZXMgKHNlZSBHTFBhc3Mgb3IgQmFzZUl0ZW0pLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQNCiAgICAgICAgICogQHByaXZhdGUNCiAgICAgICAgICovDQogICAgICAgIHBhcmFtZXRlclZhbHVlQ2hhbmdlZChldmVudCkgew0KICAgICAgICAgICAgc3VwZXIucGFyYW1ldGVyVmFsdWVDaGFuZ2VkKGV2ZW50KTsNCiAgICAgICAgICAgIHRoaXMuc2V0RGlydHkoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGFkZElucHV0IG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGlucHV0IC0gVGhlIG5hbWUgb2YgdGhlIGlucHV0LCBvciB0aGUgaW5wdXQgb2JqZWN0DQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkSW5wdXQoaW5wdXQpIHsNCiAgICAgICAgICAgIGlucHV0LnNldE9wZXJhdG9yKHRoaXMpOw0KICAgICAgICAgICAgdGhpcy5fX2lucHV0cy5zZXQoaW5wdXQuZ2V0TmFtZSgpLCBpbnB1dCk7DQogICAgICAgICAgICB0aGlzLnNldERpcnR5KCk7DQogICAgICAgICAgICByZXR1cm4gaW5wdXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSByZW1vdmVJbnB1dCBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBpbnB1dCAtIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCwgb3IgdGhlIGlucHV0IG9iamVjdA0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlSW5wdXQoaW5wdXQpIHsNCiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZycpDQogICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmdldElucHV0KGlucHV0KTsNCiAgICAgICAgICAgIGlmIChpbnB1dC5nZXRQYXJhbSgpKQ0KICAgICAgICAgICAgICAgIGlucHV0LnNldFBhcmFtKHVuZGVmaW5lZCk7DQogICAgICAgICAgICB0aGlzLl9faW5wdXRzLmRlbGV0ZShpbnB1dC5nZXROYW1lKCkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBudW1iZXIgb2YgaW5wdXRzIGluIHRoaXMgb3BlcmF0b3IuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaW5wdXRzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TnVtSW5wdXRzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbnB1dHMuc2l6ZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldElucHV0QnlJbmRleCBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRJbnB1dEJ5SW5kZXgoaW5kZXgpIHsNCiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX19pbnB1dHMudmFsdWVzKCkpW2luZGV4XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldElucHV0IG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRJbnB1dChuYW1lKSB7DQogICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuX19pbnB1dHMuZ2V0KG5hbWUpOw0KICAgICAgICAgICAgaWYgKCFpbnB1dCkNCiAgICAgICAgICAgICAgICB0aHJvdyBgQ291bGRuJ3QgZmluZCBhbiBJbnB1dCB3aXRoIHRoZSBuYW1lIG9mICcke25hbWV9J2A7DQogICAgICAgICAgICByZXR1cm4gaW5wdXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBhZGRPdXRwdXQgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gb3V0cHV0IC0gVGhlIG5hbWUgb2YgdGhlIG91dHB1dCwgb3IgdGhlIG91dHB1dCBvYmplY3QNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBhZGRPdXRwdXQob3V0cHV0KSB7DQogICAgICAgICAgICBvdXRwdXQuc2V0T3BlcmF0b3IodGhpcyk7DQogICAgICAgICAgICAvLyBpZiAodGhpcy5nZXRPdXRwdXQob3V0cHV0LmdldE5hbWUoKSkpIHRocm93IG5ldyBFcnJvcihgT3BlcmF0b3Igb3V0cHV0IGFscmVhZHkgZXhpc3RzICR7b3V0cHV0LmdldE5hbWUoKX1gKQ0KICAgICAgICAgICAgdGhpcy5fX291dHB1dHMuc2V0KG91dHB1dC5nZXROYW1lKCksIG91dHB1dCk7DQogICAgICAgICAgICB0aGlzLnNldERpcnR5KCk7DQogICAgICAgICAgICByZXR1cm4gb3V0cHV0Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgcmVtb3ZlT3V0cHV0IG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIG91dHB1dCAtIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQsIG9yIHRoZSBvdXRwdXQgb2JqZWN0DQogICAgICAgICAqLw0KICAgICAgICByZW1vdmVPdXRwdXQob3V0cHV0KSB7DQogICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PSAnc3RyaW5nJykNCiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmdldE91dHB1dChvdXRwdXQpOw0KICAgICAgICAgICAgaWYgKCEob3V0cHV0IGluc3RhbmNlb2YgT3BlcmF0b3JPdXRwdXQpKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZW1vdmVPdXRwdXQgb25seSBhY2NlcHRzIHN0cmluZyBvciBPcGVyYXRvcklucHV0YCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAob3V0cHV0LmdldFBhcmFtKCkpDQogICAgICAgICAgICAgICAgb3V0cHV0LnNldFBhcmFtKCk7DQogICAgICAgICAgICB0aGlzLl9fb3V0cHV0cy5kZWxldGUob3V0cHV0LmdldE5hbWUoKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdldHRlciBmb3IgdGhlIG51bWJlciBvZiBvdXRwdXRzIGluIHRoaXMgb3BlcmF0b3IuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygb3V0cHV0cy4NCiAgICAgICAgICovDQogICAgICAgIGdldE51bU91dHB1dHMoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX291dHB1dHMuc2l6ZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldE91dHB1dEJ5SW5kZXggbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0T3V0cHV0QnlJbmRleChpbmRleCkgew0KICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fX291dHB1dHMudmFsdWVzKCkpW2luZGV4XTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldE91dHB1dCBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0T3V0cHV0KG5hbWUpIHsNCiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuX19vdXRwdXRzLmdldChuYW1lKTsNCiAgICAgICAgICAgIGlmICghb3V0cHV0KQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhbiBPdXRwdXQgd2l0aCB0aGUgbmFtZSBvZiAnJHtuYW1lfSdgKTsNCiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBldmFsdWF0ZSBtZXRob2QuDQogICAgICAgICAqIENvbXB1dGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBvZiB0aGUgb3V0cHV0cyBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIHRoZSBpbnB1dHMNCiAgICAgICAgICogYW5kIHRoZSB2YWx1ZXMgb2Ygb3V0cHV0cyB3aXRoIG1vZGUgT1BfUkVBRF9XUklURS4NCiAgICAgICAgICogVGhpcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhbGwgT3BlcmF0b3JzLg0KICAgICAgICAgKi8NCiAgICAgICAgZXZhbHVhdGUoKSB7DQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogV2hlbiB0aGUgdmFsdWUgb24gYSBQYXJhbWV0ZXIgaXMgbW9kaWZpZWQgYnkgYSB1c2VyIGJ5IGNhbGxpbmcgJ3NldFZhbHVlLA0KICAgICAgICAgKiB0aGVuIGlmIGFueSBvcGVyYXRvcnMgYXJlIGJvdW5kLCB0aGUgdmFsdWUgb2YgdGhlIFBhcmFtZXRlciBjYW5ub3QgYmUgbW9kaWZpZWQNCiAgICAgICAgICogZGlyZWN0bHkgYXMgaXQgaXMgdGhlIHJlc3VsdCBvZiBhIGNvbXB1dGF0aW9uLiBJbnN0ZWFkLCB0aGUgUGFyYW1ldGVyIGNhbGxzDQogICAgICAgICAqICdiYWNrUHJvcGFnYXRlVmFsdWUnIG9uIHRoZSBPcGVyYXRvciB0byBjYXVzZSB0aGUgT3BlcmF0b3IgdG8gaGFuZGxlIHByb3BhZ2F0aW5nDQogICAgICAgICAqIHRoZSB2YWx1ZSB0byBvbmUgb3IgbW9yZSBvZiBpdHMgaW5wdXRzLg0KICAgICAgICAgKiB0byBpdHMgaW5wdXRzLg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgbW9kaWZpZWQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBiYWNrUHJvcGFnYXRlVmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBtZSBmb3IgY3VzdG9tIG1hbmlwdWxhdGlvbnMuDQogICAgICAgICAgICByZXR1cm4gdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBqID0gc3VwZXIudG9KU09OKGNvbnRleHQpOw0KICAgICAgICAgICAgai50eXBlID0gdGhpcy5nZXRDbGFzc05hbWUoKTsNCiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtdOw0KICAgICAgICAgICAgdGhpcy5fX2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gew0KICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKGlucHV0LnRvSlNPTihjb250ZXh0KSk7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIGouaW5wdXRzID0gaW5wdXRzOw0KICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFtdOw0KICAgICAgICAgICAgdGhpcy5fX291dHB1dHMuZm9yRWFjaCgob3V0cHV0KSA9PiB7DQogICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dC50b0pTT04oY29udGV4dCkpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgICAgICBqLm91dHB1dHMgPSBvdXRwdXRzOw0KICAgICAgICAgICAgcmV0dXJuIGo7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHN1cGVyLmZyb21KU09OKGosIGNvbnRleHQpOw0KICAgICAgICAgICAgaWYgKGouaW5wdXRzKSB7DQogICAgICAgICAgICAgICAgai5pbnB1dHMuZm9yRWFjaCgoaW5wdXRKc29uLCBpbmRleCkgPT4gew0KICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXQ7DQogICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dEpzb24ubmFtZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmdldElucHV0KGlucHV0SnNvbi5uYW1lKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRoaXMuYWRkSW5wdXQoaW5wdXRKc29uLm5hbWUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmdldElucHV0QnlJbmRleChpbmRleCk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgaW5wdXQuZnJvbUpTT04oaW5wdXRKc29uLCBjb250ZXh0KTsNCiAgICAgICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGlmIChqLm91dHB1dHMpIHsNCiAgICAgICAgICAgICAgICBqLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0SnNvbiwgaW5kZXgpID0+IHsNCiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dDsNCiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dEpzb24ubmFtZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5nZXRPdXRwdXQob3V0cHV0SnNvbi5uYW1lKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3V0cHV0KSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5hZGRPdXRwdXQob3V0cHV0SnNvbi5uYW1lKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuZ2V0T3V0cHV0QnlJbmRleChpbmRleCk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmZyb21KU09OKG91dHB1dEpzb24sIGNvbnRleHQpOw0KICAgICAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZGV0YWNoIG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIGRldGFjaCgpIHsNCiAgICAgICAgICAgIHRoaXMuX19pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGlucHV0LmRldGFjaCgpKTsNCiAgICAgICAgICAgIHRoaXMuX19vdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4gb3V0cHV0LmRldGFjaCgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlYXR0YWNoIG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIHJlYXR0YWNoKCkgew0KICAgICAgICAgICAgdGhpcy5fX2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gaW5wdXQucmVhdHRhY2goKSk7DQogICAgICAgICAgICB0aGlzLl9fb3V0cHV0cy5mb3JFYWNoKChvdXRwdXQpID0+IG91dHB1dC5yZWF0dGFjaCgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHJlYmluZCBtZXRob2QuDQogICAgICAgICAqLw0KICAgICAgICByZWJpbmQoKSB7DQogICAgICAgICAgICB0aGlzLl9fb3V0cHV0cy5mb3JFYWNoKChvdXRwdXQpID0+IG91dHB1dC5yZWJpbmQoKSk7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVyYXRvciBpbnB1dC4NCiAgICAgKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXINCiAgICAgKi8NCiAgICBjbGFzcyBPcGVyYXRvcklucHV0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHsNCiAgICAgICAgbmFtZTsNCiAgICAgICAgX29wOw0KICAgICAgICBwYXJhbTsNCiAgICAgICAgZGV0YWNoZWQgPSBmYWxzZTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhbiBvcGVyYXRvciBpbnB1dC4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsNCiAgICAgICAgICAgIHN1cGVyKCk7DQogICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2V0TmFtZSBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TmFtZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgb3BlcmF0b3IgdGhhdCBvd25zIHRoaXMgaW5wdXQuIENhbGxlZCBieSB0aGUgb3BlcmF0b3Igd2hlbiBhZGRpbmcgaW5wdXRzDQogICAgICAgICAqIEBwYXJhbSBvcCAtIFRoZSBvcGVyYXRvciBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICBzZXRPcGVyYXRvcihvcCkgew0KICAgICAgICAgICAgdGhpcy5fb3AgPSBvcDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBvcGVyYXRvciB0aGF0IG93bnMgdGhpcyBpbnB1dC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBvcGVyYXRvciBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICBnZXRPcGVyYXRvcigpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaW5wdXQgaXMgY29ubmVjdGVkIHRvIGEgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzQ29ubmVjdGVkKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0gIT0gbnVsbDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldFBhcmFtIG1ldGhvZC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRQYXJhbSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBAcHJpdmF0ZQ0KICAgICAgICAgKiBUaGUgaGFuZGxlciBmdW5jdGlvbiBmb3Igd2hlbiB0aGUgaW5wdXQgcGFyYW10ZXIgY2hhbmdlcy4NCiAgICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHBhcmFtVmFsdWVDaGFuZ2VkKCkgew0KICAgICAgICAgICAgaWYgKHRoaXMuX29wKQ0KICAgICAgICAgICAgICAgIHRoaXMuX29wLnNldERpcnR5KCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFzc2lnbnMgdGhlIFBhcmFtdGVyIHRvIGJlIHVzZWQgdG8gcHJvdmlkZSB0aGUgaW5wdXQgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBwYXJhbSAtIFRoZSBwYXJhbSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldFBhcmFtKHBhcmFtKSB7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbSkgew0KICAgICAgICAgICAgICAgIHRoaXMucGFyYW0udW5iaW5kT3BlcmF0b3JJbnB1dCh0aGlzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTsNCiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtKSB7DQogICAgICAgICAgICAgICAgdGhpcy5wYXJhbS5iaW5kT3BlcmF0b3JJbnB1dCh0aGlzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIFdoZW4gYW4gaW5wdXQgcGFyYW0gaXMgYXNzaWduZWQsIHRoZSBvcCBzaG91bGQNCiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBkaXJ0eSB0byBpdHMgb3V0cHV0cy4NCiAgICAgICAgICAgIGlmICh0aGlzLl9vcCkNCiAgICAgICAgICAgICAgICB0aGlzLl9vcC5zZXREaXJ0eSgpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJhbVNldCcsIHsgcGFyYW06IHRoaXMucGFyYW0gfSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRWYWx1ZSBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0VmFsdWUoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbSkNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbS52YWx1ZTsNCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldFZhbHVlJyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRWYWx1ZSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIHNldFZhbHVlKHZhbHVlKSB7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbSkgew0KICAgICAgICAgICAgICAgIHRoaXMucGFyYW0uc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBQcm9wYWdhdGVzIGZyb20gdGhlIHVwc3RyZWFtIHBhcmFtZXRlciB0byB0aGUgY29ubmVjdGVkIG9wZXJhdG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RGlydHkoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5fb3ApIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9vcC5zZXREaXJ0eSgpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgYWJzUGF0aCA9IHRoaXMucGFyYW0gPyB0aGlzLnBhcmFtLmdldFBhdGgoKSA6IFtdOw0KICAgICAgICAgICAgY29uc3QgcGFyYW1QYXRoID0gKGNvbnRleHQgJiYgY29udGV4dC5tYWtlUmVsYXRpdmUgPyBjb250ZXh0Lm1ha2VSZWxhdGl2ZShhYnNQYXRoKSA6IGFic1BhdGgpOw0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsDQogICAgICAgICAgICAgICAgcGFyYW1QYXRoOiBwYXJhbVBhdGgsDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBpZiAoai5wYXJhbVBhdGgpIHsNCiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgdHJlZSBzaG91bGQgaGF2ZSBmdWxseSBsb2FkZWQgYnkgdGhlIHRpbWUgd2UgYXJlIGxvYWRpbmcgb3BlcmF0b3JzDQogICAgICAgICAgICAgICAgLy8gZXZlbiBuZXcgaXRlbXMgYW5kIGdyb3VwcyBzaG91bGQgaGF2ZSBiZWVuIGNyZWF0ZWQuIE9wZXJhdG9ycyBhbmQgc3RhdGUgbWFjaGluZXMNCiAgICAgICAgICAgICAgICAvLyBhcmUgbG9hZGVkIGxhc3QuDQogICAgICAgICAgICAgICAgY29udGV4dD8ucmVzb2x2ZVBhdGgoai5wYXJhbVBhdGgsIChwYXJhbSkgPT4gew0KICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBhcmFtKHBhcmFtKTsNCiAgICAgICAgICAgICAgICB9LCAoKSA9PiB7DQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigiT3BlcmF0b3JJbnB1dDogJyIgKyB0aGlzLmdldE5hbWUoKSArICInLiBVbmFibGUgdG8gY29ubmVjdCB0bzoiICsgai5wYXJhbVBhdGgpOw0KICAgICAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZGV0YWNoIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRvciBpcyBiZWluZyByZW1vdmVkIGZyb20gdGhlIHNjZW5lIHRyZWUuDQogICAgICAgICAqIEl0IHJlbW92ZXMgYWxsIGNvbm5lY3Rpb25zIHRvIHBhcmFtZXRlcnMgaW4gdGhlIHNjZW5lLg0KICAgICAgICAgKi8NCiAgICAgICAgZGV0YWNoKCkgew0KICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB3ZSB3YW50IHRvIHN1c3BlbmQgYW4gb3BlcmF0b3INCiAgICAgICAgICAgIC8vIGZyb20gZnVuY3Rpb25pbmcgYmVjYXVzZSBpdCBpcyBkZWxldGVkIGFuZCBvbiB0aGUgdW5kbyBzdGFjay4NCiAgICAgICAgICAgIC8vIE9uY2Ugb3BlcmF0b3JzIGhhdmUgcGVyc2lzdGVudCBjb25uZWN0aW9ucywNCiAgICAgICAgICAgIC8vIHdlIHdpbGwgc2ltcGx5IHVuaW5zdGFsbCB0aGUgb3V0cHV0IGZyb20gdGhlIHBhcmFtZXRlci4NCiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtKSB7DQogICAgICAgICAgICAgICAgdGhpcy5wYXJhbS51bmJpbmRPcGVyYXRvcklucHV0KHRoaXMpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgcmVhdHRhY2ggbWV0aG9kIGNhbiBiZSBjYWxsZWQgd2hlbiByZS1pbnN0YXRpbmcgYW4gb3BlcmF0b3IgaW4gdGhlIHNjZW5lLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhdHRhY2goKSB7DQogICAgICAgICAgICB0aGlzLmRldGFjaGVkID0gZmFsc2U7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJhbSkgew0KICAgICAgICAgICAgICAgIHRoaXMucGFyYW0uYmluZE9wZXJhdG9ySW5wdXQodGhpcyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgY2xhc3MgWGZvT3BlcmF0b3JJbnB1dCBleHRlbmRzIE9wZXJhdG9ySW5wdXQgew0KICAgIH0KCiAgICAvKiogVGhlIG9wZXJhdG9yIHRoZSBjYWxjdWxhdGVzIHRoZSBnbG9iYWwgWGZvIG9mIGEgVHJlZUl0ZW0gYmFzZWQgb24gaXRzIHBhcmVudHMgR2xvYmFsWGZvIGFuZCBpdHMgb3duIExvY2FsWGZvDQogICAgICogQGV4dGVuZHMgT3BlcmF0b3INCiAgICAgKiBAcHJpdmF0ZQ0KICAgICAqLw0KICAgIGNsYXNzIENhbGNHbG9iYWxYZm9PcGVyYXRvciBleHRlbmRzIE9wZXJhdG9yIHsNCiAgICAgICAgcGFyZW50R2xvYmFsID0gbmV3IFhmb09wZXJhdG9ySW5wdXQoJ1BhcmVudEdsb2JhbCcpOw0KICAgICAgICBsb2NhbFhmbyA9IG5ldyBYZm9PcGVyYXRvcklucHV0KCdMb2NhbFhmbycpOw0KICAgICAgICBnbG9iYWxYZm8gPSBuZXcgWGZvT3BlcmF0b3JPdXRwdXQoJ0dsb2JhbFhmbycpOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGEgQ2FsY0dsb2JhbFhmb09wZXJhdG9yIG9wZXJhdG9yLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZ3JvdXBHbG9iYWxYZm9QYXJhbSAtIFRoZSBHbG9iYWxYZm8gcGFyYW0gZm91bmQgb24gdGhlIEdyb3VwLg0KICAgICAgICAgKiBAcGFyYW0gY3V0dGluZ1BsYW5lUGFyYW0gLSBUaGUgcGFyYW1ldGVyIG9uIHRoZSBHcm91cCB3aGljaCBkZWZpbmVzIHRoZSBkaXNwbGFjZW1lbnQgdG8gYXBwbHkgdG8gdGhlIG1lbWJlcnMuDQogICAgICAgICAqLw0KICAgICAgICAvLyBUT0RPOiBhZGRpbmcgbmV3IFhmb1AuLi4gdG8gbWFrZSBpbmhlcml0ZW5jZSB3b3JrDQogICAgICAgIGNvbnN0cnVjdG9yKGdsb2JhbFhmb1BhcmFtLCBsb2NhbFhmb1BhcmFtKSB7DQogICAgICAgICAgICBzdXBlcignQ2FsY0dsb2JhbFhmb09wZXJhdG9yJyk7DQogICAgICAgICAgICB0aGlzLmxvY2FsWGZvLnNldFBhcmFtKGxvY2FsWGZvUGFyYW0pOw0KICAgICAgICAgICAgdGhpcy5nbG9iYWxYZm8uc2V0UGFyYW0oZ2xvYmFsWGZvUGFyYW0pOw0KICAgICAgICAgICAgdGhpcy5hZGRJbnB1dCh0aGlzLnBhcmVudEdsb2JhbCk7DQogICAgICAgICAgICB0aGlzLmFkZElucHV0KHRoaXMubG9jYWxYZm8pOw0KICAgICAgICAgICAgdGhpcy5hZGRPdXRwdXQodGhpcy5nbG9iYWxYZm8pOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgYmFja1Byb3BhZ2F0ZVZhbHVlIG1ldGhvZCBpbnZlcnRzIHRoZSBtYXRoZW1hdGljcyBvZiB0aGUgJ2V2YWx1YXRlJw0KICAgICAgICAgKiBtZXRob2Qgc28gaXQgY2FuIHByb3BhZ2F0ZSB0aGUgdmFsdWUgYmFja3dhcmRzIHRvIGl0cyBpbnB1dHMuDQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgYmVpbmcgc2V0IG9uIHRoZSBvdXRwdXQgR2xvYmFsWGZvDQogICAgICAgICAqLw0KICAgICAgICBiYWNrUHJvcGFnYXRlVmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudEdsb2JhbC5pc0Nvbm5lY3RlZCgpKSB7DQogICAgICAgICAgICAgICAgY29uc3QgcGFyZW50R2xvYmFsWGZvID0gdGhpcy5wYXJlbnRHbG9iYWwuZ2V0VmFsdWUoKTsNCiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsWGZvLnNldFZhbHVlKHBhcmVudEdsb2JhbFhmby5pbnZlcnNlKCkubXVsdGlwbHkodmFsdWUpKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRoaXMubG9jYWxYZm8uc2V0VmFsdWUodmFsdWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZXZhbHVhdGUgbWV0aG9kIGNhbGN1bGF0ZXMgYSBuZXcgZ2xvYmFsIFhmbyBiYXNlZCBvbiB0aGUgcGFyZW50cyBHbG9iYWwgWGZvLA0KICAgICAgICAgKiBhbmQgdGhlIGxvY2FsIFhmbyB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGV2YWx1YXRlKCkgew0KICAgICAgICAgICAgY29uc3QgbG9jYWxYZm8gPSB0aGlzLmxvY2FsWGZvLmdldFZhbHVlKCk7DQogICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRHbG9iYWwuaXNDb25uZWN0ZWQoKSkgew0KICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEdsb2JhbFhmbyA9IHRoaXMucGFyZW50R2xvYmFsLmdldFZhbHVlKCk7DQogICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxYZm8uc2V0Q2xlYW4ocGFyZW50R2xvYmFsWGZvLm11bHRpcGx5KGxvY2FsWGZvKSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbFhmby5zZXRDbGVhbihsb2NhbFhmbyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0NhbGNHbG9iYWxYZm9PcGVyYXRvcicsIENhbGNHbG9iYWxYZm9PcGVyYXRvcik7CgogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIHNwZWNpZmljIHR5cGUgb2YgcGFyYW1ldGVyLCB0aGF0IG9ubHkgc3RvcmVzIGBCb3gzYCB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveFBhcmFtZXRlcignTXlCQm94JywgbmV3IFRyZWVJdGVtKCkpDQogICAgICogLy8nbXlQYXJhbWV0ZXJPd25lckl0ZW0nIGlzIGFuIGluc3RhbmNlIG9mIGEgJ1BhcmFtZXRlck93bmVyJyBjbGFzcy4NCiAgICAgKiAvLyBSZW1lbWJlciB0aGF0IG9ubHkgJ1BhcmFtZXRlck93bmVyJyBhbmQgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIGl0IGNhbiBob3N0ICdQYXJhbWV0ZXInIG9iamVjdHMuDQogICAgICogbXlQYXJhbWV0ZXJPd25lckl0ZW0uYWRkUGFyYW1ldGVyKGJvdW5kaW5nQm94KQ0KICAgICAqIGBgYA0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlcg0KICAgICAqLw0KICAgIGNsYXNzIEJvdW5kaW5nQm94UGFyYW1ldGVyIGV4dGVuZHMgQm94M1BhcmFtZXRlciB7DQogICAgICAgIC8vIHByb3RlY3RlZCBkaXJ0eTogYm9vbGVhbiwgdmFsdWUsIG5hbWUNCiAgICAgICAgdHJlZUl0ZW07DQogICAgICAgIGRpcnR5ID0gdHJ1ZTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQm91bmRpbmdCb3hQYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyDQogICAgICAgICAqIEBwYXJhbSB0cmVlSXRlbSAtIGBUcmVlSXRlbWAgdGhhdCBjb250YWlucyBgQm94M2AgcmVwcmVzZW50aW5nIHRoZSBCb3VuZGluZyBCb3gNCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgdHJlZUl0ZW0pIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUpOw0KICAgICAgICAgICAgdGhpcy50cmVlSXRlbSA9IHRyZWVJdGVtOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBNYWtlcyBwYXJhbWV0ZXIgdmFsdWUgYmUgZGlydHksIHNvIHdoZW4gYGdldFZhbHVlYCBpcyBjYWxsZWQsDQogICAgICAgICAqIGFuIGV2YWx1YXRpb24gaXMgdGhlbiBleGVjdXRlZCB0byByZS1jYWxjdWxhdGUgdGhlIEJvdW5kaW5nQm94DQogICAgICAgICAqDQogICAgICAgICAqIEBtZW1iZXJvZiBCb3VuZGluZ0JveFBhcmFtZXRlcg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RGlydHkoaW5kZXgpIHsNCiAgICAgICAgICAgIGlmICghdGhpcy5kaXJ0eSkgew0KICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOw0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBib3VuZGluZyBib3ggdmFsdWUNCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRWYWx1ZSgpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KSB7DQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gdGhpcy50cmVlSXRlbS5fY2xlYW5Cb3VuZGluZ0JveCgpOw0KICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmFsdWU7DQogICAgICAgIH0NCiAgICAgICAgY2xvbmUoKSB7DQogICAgICAgICAgICBjb25zdCBiQm94M0Nsb25lID0gbmV3IEJvdW5kaW5nQm94UGFyYW1ldGVyKHRoaXMubmFtZSwgdGhpcy50cmVlSXRlbSk7DQogICAgICAgICAgICBiQm94M0Nsb25lLnZhbHVlID0gdGhpcy5fX3ZhbHVlPy5jbG9uZSgpOw0KICAgICAgICAgICAgcmV0dXJuIGJCb3gzQ2xvbmU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFdlIGRvIG5vdCB3YW50IHRoaXMgcGFyYW1ldGVyIHNlcmlhbGl6ZWQuDQogICAgICAgICAqLw0KICAgICAgICBpc0RyaXZlbkJ5T3BlcmF0b3IoKSB7DQogICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgbG9hZFZhbHVlIGlzIHVzZWQgdG8gY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2l0aG91dCB0cmlnZ2VyaW5nIGENCiAgICAgICAgICogdmFsdWVDaGFuZ2VzLCBvciBzZXR0aW5nIHRoZSBVU0VSX0VESVRFRCBzdGF0ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkVmFsdWUodmFsdWUpIHsNCiAgICAgICAgICAgIHRoaXMuX192YWx1ZSA9IHZhbHVlLmNsb25lKCk7DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0JvdW5kaW5nQm94UGFyYW1ldGVyJywgQm91bmRpbmdCb3hQYXJhbWV0ZXIpOwoKICAgIC8qKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBJdGVtIGluIHRoZSBzY2VuZSB0cmVlIHdpdGggaGllcmFyY2h5IGNhcGFiaWxpdGllcyAoaGFzIGNoaWxkcmVuKS4NCiAgICAgKiBJdCBoYXMgdGhlIGNhcGFiaWxpdHkgdG8gYWRkIGFuZCByZW1vdmUgY2hpbGRyZW4uDQogICAgICogKipQYXJhbWV0ZXJzKioNCiAgICAgKiAqICoqVmlzaWJsZShgQm9vbGVhblBhcmFtZXRlcmApOioqIFNob3dzL0hpZGVzIHRoZSBpdGVtLg0KICAgICAqICogKipMb2NhbFhmbyhgWGZvUGFyYW1ldGVyYCk6KiogU3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhpcyB0cmVlIGl0ZW0gZnJvbSBpdHMgcGFyZW50Lg0KICAgICAqICogKipHbG9iYWxYZm8oYFhmb1BhcmFtZXRlcmApOioqIFByb3ZpZGVzIHRoZSBjb21wdXRlZCB3b3JsZCBYZm8gb2YgdGhpcyB0cmVlIGl0ZW0uDQogICAgICogKiAqKkJvdW5kaW5nQm94KGBCb3VuZGluZ0JveGApOioqIFByb3ZpZGVzIHRoZSBib3VuZGluZyBib3ggZm9yIHRoZSB0cmVlIGl0ZW0gYW5kIGFsbCBvZiBpdHMgY2hpbGRyZW4gaW4gdGhlIDNkIHNjZW5lLg0KICAgICAqDQogICAgICogKipFdmVudHMqKg0KICAgICAqICogKipnbG9iYWxYZm9DaGFuZ2VkOioqIEVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgb2YgR2xvYmFsWGZvIHBhcmFtZXRlciBjaGFuZ2VzLg0KICAgICAqICogKip2aXNpYmlsaXR5Q2hhbmdlZDoqKiBFbWl0dGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgb24gdGhlIHRyZWUgaXRlbSBjaGFuZ2VzLg0KICAgICAqICogKipoaWdobGlnaHRDaGFuZ2VkOioqIEVtaXR0ZWQgd2hlbiB0aGUgaGlnaGxpZ2h0IG9uIHRoZSB0cmVlIGl0ZW0gY2hhbmdlcy4NCiAgICAgKiAqICoqY2hpbGRBZGRlZDoqKiBFbWl0dGVkIHdoZW4gYSBpdGVtIGlzIGFkZGVkIGFzIGEgY2hpbGQuDQogICAgICogKiAqKmNoaWxkUmVtb3ZlZDoqKiBFbWl0dGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIGNoaWxkIG5vZGVzLg0KICAgICAqICogKipwb2ludGVyRG93bjoqKiBFbWl0dGVkIHdoZW4gYSBwb2ludGVyRG93biBldmVudCBoYXBwZW5zIGluIGFuIGl0ZW0uDQogICAgICogKiAqKnBvaW50ZXJVcDoqKiBFbWl0dGVkIHdoZW4gYSBwb2ludGVyVXAgZXZlbnQgaGFwcGVucyBpbiBhbiBpdGVtLg0KICAgICAqICogKipwb2ludGVyTW92ZToqKiBFbWl0dGVkIHdoZW4gYSBwb2ludGVyTW92ZSBldmVudCBoYXBwZW5zIGluIGFuIGl0ZW0uDQogICAgICogKiAqKnBvaW50ZXJFbnRlcjoqKiBFbWl0dGVkIHdoZW4gYSBwb2ludGVyRW50ZXIgZXZlbnQgaGFwcGVucyBpbiBhbiBpdGVtLg0KICAgICAqICogKipwb2ludGVyQ2xpY2s6KiogRW1pdHRlZCB3aGVuIGEgcG9pbnRlciBpcyBjbGlja2VkIG9uIGFuIGl0ZW0uDQogICAgICogKiAqKnBvaW50ZXJEb3VibGVDbGljazoqKiBFbWl0dGVkIHdoZW4gYSBwb2ludGVyIGlzIGRvdWJsZS1jbGlja2VkIG9uIGFuIGl0ZW0uDQogICAgICogKiAqKnBvaW50ZXJMb25nUHJlc3M6KiogRW1pdHRlZCB3aGVuIGEgcG9pbnRlciBpcyBjbGlja2VkIGFuZCBoZWxkIG9uIGFuIGl0ZW0gZm9yIGEgbG9uZyB0aW1lLg0KICAgICAqDQogICAgICoNCiAgICAgKiBAZXh0ZW5kcyB7UGFyYW1ldGVyT3duZXJ9DQogICAgICovDQogICAgY2xhc3MgVHJlZUl0ZW0gZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7DQogICAgICAgIC8vIENvbnRyb2xzIGlmIHRoaXMgVHJlZUl0ZW0gb3IgaXRzIGNoaWxkcmVuIGNvbnRyaWJ1dGUgdG8gdGhlIGJvdW5kaW5nIGJveGVzDQogICAgICAgIC8vIGluIHRoZSBzY2VuZS4gSWYgc2V0IHRvIGZhbHNlLCBDYW1lcmEgZnJhbWluZyB3aWxsIGlnbm9yZSB0aGlzIGl0ZW0sDQogICAgICAgIGRpc2FibGVCb3VuZGluZ0JveCA9IGZhbHNlOw0KICAgICAgICBfX2NoaWxkSXRlbXMgPSBbXTsNCiAgICAgICAgX19jaGlsZEl0ZW1zRXZlbnRIYW5kbGVycyA9IFtdOw0KICAgICAgICBjaGlsZEl0ZW1zTWFwcGluZyA9IHt9Ow0KICAgICAgICBjaGlsZEl0ZW1zTWFwcGluZ0NvcnJ1cHQgPSBmYWxzZTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIEBtZW1iZXIgZ2xvYmFsWGZvUGFyYW0gLSBTdG9yZXMgdGhlIGdsb2JhbCBYZm8gZm9yIHRoaXMgdHJlZSBpdGVtLg0KICAgICAgICAgKiBnbG9iYWwgeGZvcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsb2NhbFhmbyBhbmQgcGFyZW50WGZvLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2xvYmFsWGZvUGFyYW0gPSBuZXcgWGZvUGFyYW1ldGVyKCdHbG9iYWxYZm8nLCBuZXcgWGZvKCkpOw0KICAgICAgICAvKioNCiAgICAgICAgICogQG1lbWJlciBsb2NhbFhmb1BhcmFtIC0gU3RvcmVzIHRoZSBsb2NhbCBYZm8gZm9yIHRoaXMgdHJlZSBpdGVtLg0KICAgICAgICAgKiBsb2NhbCBYZm9zIGFyZSB0aGUgb2Zmc2V0IGZyb20gdGhlIHBhcmVudCdzIGNvb3JkaW5hdGUgZnJhbWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2NhbFhmb1BhcmFtID0gbmV3IFhmb1BhcmFtZXRlcignTG9jYWxYZm8nLCBuZXcgWGZvKCkpOw0KICAgICAgICAvKioNCiAgICAgICAgICogQG1lbWJlciBib3VuZGluZ0JveFBhcmFtIC0gU3RvcmVzIHRoZSBib3VuZGluZyBib3ggZm9yIHRoaXMgdHJlZSBpdGVtDQogICAgICAgICAqLw0KICAgICAgICBib3VuZGluZ0JveFBhcmFtID0gbmV3IEJvdW5kaW5nQm94UGFyYW1ldGVyKCdCb3VuZGluZ0JveCcsIHRoaXMpOw0KICAgICAgICAvKioNCiAgICAgICAgICogQG1lbWJlciB2aXNpYmxlUGFyYW0gLSBXaGV0aGVyIHRoaXMgdHJlZSBpdGVtIGlzIHZpc2libGUgb3Igbm90Lg0KICAgICAgICAgKiBBbnkgZ2l2ZW4gdHJlZSBpdGVtIGlzIGFsc28gaXMgYWZmZWN0ZWQgYnkgcGFyZW50J3MgdmlzaWJpbGl0eS4NCiAgICAgICAgICovDQogICAgICAgIHZpc2libGVQYXJhbSA9IG5ldyBCb29sZWFuUGFyYW1ldGVyKCdWaXNpYmxlJywgdHJ1ZSk7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBAbWVtYmVyIG9wYWNpdHlQYXJhbSAtIENvbnRyb2xzLCBpbiBjb21iaW5hdGlvbiB3aXRoIE1hdGVyaWFsIHRyYW5zcGFyZW5jeSwNCiAgICAgICAgICogdGhlIG9wYWNpdHkgb2YgdGhpcyBpdGVtIGFuZCBpdHMgY2hpbGRyZW4uDQogICAgICAgICAqLw0KICAgICAgICBvcGFjaXR5UGFyYW0gPSBuZXcgTnVtYmVyUGFyYW1ldGVyKCdPcGFjaXR5JywgMSwgWzAsIDFdKTsNCiAgICAgICAgaGlnaGxpZ2h0TWFwcGluZyA9IHt9Ow0KICAgICAgICBoaWdobGlnaHRzID0gW107DQogICAgICAgIF9fdmlzaWJsZSA9IHRydWU7DQogICAgICAgIHZpc2libGVDb3VudGVyID0gMTsgLy8gVmlzaWJsZSBieSBEZWZhdWx0Lg0KICAgICAgICBvcGFjaXR5ID0gMTsgLy8gT3BhcXVlIGJ5IERlZmF1bHQuDQogICAgICAgIGluaGVyaXRlZE9wYWNpdHlWYWx1ZXMgPSBuZXcgTWFwKCk7DQogICAgICAgIGdsb2JhbFhmb09wOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhIHRyZWUgaXRlbSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdHJlZSBpdGVtLiBJdCdzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSB0cmVlIGl0ZW0uDQogICAgICAgICAqIEl0J3MgYW4gaWRlbnRpZmllciBpbnRlbmRlZCB0byBiZSBodW1hbiByZWFkYWJsZS4NCiAgICAgICAgICogSXQncyBpbmNsdWRlZCBpbiB0aGUgcGF0aCB0aGF0IHdlIHVzZSB0byBhY2Nlc3MgYSBwYXJ0aWN1bGFyIGl0ZW0uDQogICAgICAgICAqIEl0J3MgdXNlZCB0byBkaXNwbGF5IGl0IGluIHRoZSB0cmVlLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IobmFtZSkgew0KICAgICAgICAgICAgc3VwZXIobmFtZSk7DQogICAgICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAvLyBBZGQgcGFyYW1ldGVycy4NCiAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHRoaXMudmlzaWJsZVBhcmFtKTsNCiAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHRoaXMub3BhY2l0eVBhcmFtKTsNCiAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHRoaXMubG9jYWxYZm9QYXJhbSk7DQogICAgICAgICAgICB0aGlzLmFkZFBhcmFtZXRlcih0aGlzLmdsb2JhbFhmb1BhcmFtKTsNCiAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHRoaXMuYm91bmRpbmdCb3hQYXJhbSk7DQogICAgICAgICAgICB0aGlzLmdsb2JhbFhmb09wID0gbmV3IENhbGNHbG9iYWxYZm9PcGVyYXRvcih0aGlzLmdsb2JhbFhmb1BhcmFtLCB0aGlzLmxvY2FsWGZvUGFyYW0pOw0KICAgICAgICAgICAgdGhpcy5nbG9iYWxYZm9QYXJhbS5vbigndmFsdWVDaGFuZ2VkJywgKGV2ZW50KSA9PiB7DQogICAgICAgICAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogZGVwcmVjYXRlIHRoaXMgZXZlbnQuDQogICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdnbG9iYWxYZm9DaGFuZ2VkJywgZXZlbnQpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB0aGlzLnZpc2libGVQYXJhbS5vbigndmFsdWVDaGFuZ2VkJywgKCkgPT4gew0KICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvdW50ZXIgKz0gdGhpcy52aXNpYmxlUGFyYW0udmFsdWUgPyAxIDogLTE7DQogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIHRoaXMub3BhY2l0eVBhcmFtLm9uKCd2YWx1ZUNoYW5nZWQnLCAoKSA9PiB7DQogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPcGFjaXR5KCk7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgKGFub3RoZXIgVHJlZUl0ZW0pIG9mIHRoZSBjdXJyZW50IFRyZWVJdGVtLg0KICAgICAgICAgKiBAcGFyYW0gcGFyZW50SXRlbSAtIFRoZSBwYXJlbnQgaXRlbS4NCiAgICAgICAgICovDQogICAgICAgIHNldE93bmVyKHBhcmVudEl0ZW0pIHsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fb3duZXJJdGVtKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0IG9mIHRoZSBpbnZpc2libGUgb3duZXIgaXMgcmVtb3ZlZC4NCiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9fb3duZXJJdGVtLmlzVmlzaWJsZSgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlQ291bnRlcisrOw0KICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX19vd25lckl0ZW0uZ2V0Q2hpbGRJbmRleCh0aGlzKTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApDQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLnVuYmluZENoaWxkKGluZGV4LCB0aGlzKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBzdXBlci5zZXRPd25lcihwYXJlbnRJdGVtKTsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fb3duZXJJdGVtKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0IG9mIHRoZSBpbnZpc2libGUgb3duZXIgaXMgYWRkZWQuDQogICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fX293bmVySXRlbS5pc1Zpc2libGUoKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvdW50ZXItLTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxYZm9PcC5nZXRJbnB1dCgnUGFyZW50R2xvYmFsJykuc2V0UGFyYW0odGhpcy5fX293bmVySXRlbS5nbG9iYWxYZm9QYXJhbSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxYZm9PcC5nZXRJbnB1dCgnUGFyZW50R2xvYmFsJykuc2V0UGFyYW0odW5kZWZpbmVkKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgY3VycmVudCBUcmVlSXRlbS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHBhcmVudCBpdGVtLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0UGFyZW50SXRlbSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE93bmVyKCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIHBhcmVudCBvZiBjdXJyZW50IFRyZWVJdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcGFyZW50SXRlbSAtIFRoZSBwYXJlbnQgaXRlbS4NCiAgICAgICAgICovDQogICAgICAgIHNldFBhcmVudEl0ZW0ocGFyZW50SXRlbSkgew0KICAgICAgICAgICAgdGhpcy5zZXRPd25lcihwYXJlbnRJdGVtKTsNCiAgICAgICAgfQ0KICAgICAgICBnZXQgcGFyZW50KCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3duZXIoKTsNCiAgICAgICAgfQ0KICAgICAgICBzZXQgcGFyZW50KHRyZWVJdGVtKSB7DQogICAgICAgICAgICB0aGlzLnNldE93bmVyKHRyZWVJdGVtKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFZpc2liaWxpdHkNCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdmlzaWJsZSBwYXJhbWV0ZXIgdmFsdWUgZm9yIGN1cnJlbnQgVHJlZUl0ZW0uDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgdmlzaWJsZSBwYXJhbSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGlzVmlzaWJsZSgpIHsNCiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBiZSBtb3JlIHRoYW4gMSwgYnV0IGNhbiBiZSBsZXNzIHRoYW4gMC4NCiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb3VudGVyID4gMDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB2aXNpYmxlIHBhcmFtZXRlciB2YWx1ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRWaXNpYmxlKHZpc2libGUpIHsNCiAgICAgICAgICAgIHRoaXMudmlzaWJsZVBhcmFtLnZhbHVlID0gdmlzaWJsZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVXBkYXRlcyBjdXJyZW50IFRyZWVJdGVtIHZpc2libGUgc3RhdGUgYW5kIHByb3BhZ2F0ZXMgaXRzIHZhbHVlIHRvIGNoaWxkcmVuIGVsZW1lbnRzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4NCiAgICAgICAgICovDQogICAgICAgIHByb3BhZ2F0ZVZpc2liaWxpdHkodmFsKSB7DQogICAgICAgICAgICB0aGlzLnZpc2libGVDb3VudGVyICs9IHZhbDsNCiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdXBkYXRlVmlzaWJpbGl0eSBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgYm9vbGVhbi4NCiAgICAgICAgICovDQogICAgICAgIHVwZGF0ZVZpc2liaWxpdHkoKSB7DQogICAgICAgICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlQ291bnRlciA+IDA7DQogICAgICAgICAgICBpZiAodmlzaWJsZSAhPSB0aGlzLl9fdmlzaWJsZSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX192aXNpYmxlID0gdmlzaWJsZTsNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSXRlbSBvZiB0aGlzLl9fY2hpbGRJdGVtcykgew0KICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW0ucHJvcGFnYXRlVmlzaWJpbGl0eSh0aGlzLl9fdmlzaWJsZSA/IDEgOiAtMSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmlzaWJpbGl0eUNoYW5nZWQnLCBuZXcgVmlzaWJpbGl0eUNoYW5nZWRFdmVudCh2aXNpYmxlKSk7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogd2UgdXNlZCB0byBoYW5kbGUgdGhpcyBieSBsaXN0ZW5pbmcgdG8gYSAndmFsdWVDaGFuZ2VkJyBldmVudCBvbiB0aGUNCiAgICAgICAgICAgICAgICAvLyBwYXJhbWV0ZXIuDQogICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLnNldEJvdW5kaW5nQm94RGlydHkoKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBPcGFjaXR5DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgb3BhY2l0eSB2YWx1ZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3BhY2l0eSB2YWx1ZSBpcyBsZXNzIHRoYW4gMS4NCiAgICAgICAgICovDQogICAgICAgIGlzT3BhcXVlKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BhY2l0eSA+IDAuOTk5Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIG9wYWNpdHkgaW5oZXJpdGVkIGJ5IGEgZ2l2ZW4gdHJlZSBpdGVtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0SW5oZXJpdGVkT3BhY2l0eShwYXJlbnQsIHZhbHVlKSB7DQogICAgICAgICAgICB0aGlzLmluaGVyaXRlZE9wYWNpdHlWYWx1ZXMuc2V0KHBhcmVudCwgdmFsdWUpOw0KICAgICAgICAgICAgdGhpcy51cGRhdGVPcGFjaXR5KCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBvcGFjaXR5IHZhbHVlIGJhc2VkIG9uIHRoZSBvcGFjaXR5UGFyYW0gdmFsdWUNCiAgICAgICAgICogYW5kIHRoZSBsb3dlc3Qgb2YgdGhlIGluaGVyaXRlZCBvcGFjaXR5IHZhbHVlcy4NCiAgICAgICAgICovDQogICAgICAgIHVwZGF0ZU9wYWNpdHkoKSB7DQogICAgICAgICAgICBsZXQgaW5oZXJpdGVkT3BhY2l0eVZhbHVlID0gMTsNCiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGVkT3BhY2l0eVZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gew0KICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IGluaGVyaXRlZE9wYWNpdHlWYWx1ZSkNCiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkT3BhY2l0eVZhbHVlID0gdmFsdWU7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIGNvbnN0IHdhc09wYXF1ZSA9IHRoaXMub3BhY2l0eSA+IDAuOTk5Ow0KICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5UGFyYW0udmFsdWUgKiBpbmhlcml0ZWRPcGFjaXR5VmFsdWU7DQogICAgICAgICAgICAvLyBlbHNlIHRoaXMub3BhY2l0eSA9IHRoaXMub3BhY2l0eVBhcmFtLnZhbHVlDQogICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSXRlbSBvZiB0aGlzLl9fY2hpbGRJdGVtcykgew0KICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5zZXRJbmhlcml0ZWRPcGFjaXR5KHRoaXMsIHRoaXMub3BhY2l0eSk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBpc09wYXF1ZSA9IHRoaXMub3BhY2l0eSA+IDAuOTk5Ow0KICAgICAgICAgICAgdGhpcy5lbWl0KCdvcGFjaXR5Q2hhbmdlZCcsIG5ldyBPcGFjaXR5U3RhdGVDaGFuZ2VkRXZlbnQoaXNPcGFxdWUsIHdhc09wYXF1ZSAhPSBpc09wYXF1ZSkpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gSGlnaGxpZ2h0cw0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBhIGhpZ2hsaWdodCB0byB0aGUgdHJlZSBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0cmVlIGl0ZW0uDQogICAgICAgICAqIEBwYXJhbSBjb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgaGlnaGxpZ2h0Lg0KICAgICAgICAgKiBAcGFyYW0gcHJvcGFnYXRlVG9DaGlsZHJlbiAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcHJvcGFnYXRlIHRvIGNoaWxkcmVuLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkSGlnaGxpZ2h0KG5hbWUsIGNvbG9yLCBwcm9wYWdhdGVUb0NoaWxkcmVuID0gdHJ1ZSkgew0KICAgICAgICAgICAgLy8gSWYgdGhlIGhpZ2hsaWdodCB3YXMgYWxyZWFkeSBpbiB0aGUgbGlzdCwNCiAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBhbmQgcHV0IGl0IGF0IHRoZSB0b3AuDQogICAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmhpZ2hsaWdodE1hcHBpbmcpIHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRzW3RoaXMuaGlnaGxpZ2h0cy5sZW5ndGggLSAxXSAhPSBuYW1lKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIFRoZSBoaWdobGlnaHQgd2FzIGFscmVhZHkgaW4gdGhlIGxpc3QsIGJ1dCBub3QgYXQgdGhlIHRvcC4gTW92ZSBpdCB0byB0aGUgdG9wLg0KICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuaGlnaGxpZ2h0cy5pbmRleE9mKG5hbWUpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodHMuc3BsaWNlKGlkLCAxKTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRzLnB1c2gobmFtZSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGlnaGxpZ2h0Q2hhbmdlZCcsIHsgbmFtZSwgY29sb3IgfSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGl0ZW0gaXMgYWxyZWFkeSBoaWdobGlnaHRlZCB3aXRoIHRoaXMgaGlnaGxpZ2h0DQogICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oaWdobGlnaHRNYXBwaW5nW25hbWVdLmlzRXF1YWwoY29sb3IpKSB7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE1hcHBpbmdbbmFtZV0gPSBjb2xvcjsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGlnaGxpZ2h0Q2hhbmdlZCcsIHsgbmFtZSwgY29sb3IgfSk7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodHMucHVzaChuYW1lKTsNCiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE1hcHBpbmdbbmFtZV0gPSBjb2xvcjsNCiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2hpZ2hsaWdodENoYW5nZWQnLCB7IG5hbWUsIGNvbG9yIH0pOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKHByb3BhZ2F0ZVRvQ2hpbGRyZW4pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fY2hpbGRJdGVtcy5mb3JFYWNoKChjaGlsZEl0ZW0pID0+IHsNCiAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtLmFkZEhpZ2hsaWdodChuYW1lLCBjb2xvciwgcHJvcGFnYXRlVG9DaGlsZHJlbik7DQogICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlbW92ZXMgYSBoaWdobGlnaHQgdG8gdGhlIHRyZWUgaXRlbS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdHJlZSBpdGVtLg0KICAgICAgICAgKiBAcGFyYW0gcHJvcGFnYXRlVG9DaGlsZHJlbiAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcHJvcGFnYXRlIHRvIGNoaWxkcmVuLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlSGlnaGxpZ2h0KG5hbWUsIHByb3BhZ2F0ZVRvQ2hpbGRyZW4gPSB0cnVlKSB7DQogICAgICAgICAgICBpZiAobmFtZSBpbiB0aGlzLmhpZ2hsaWdodE1hcHBpbmcpIHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRzW3RoaXMuaGlnaGxpZ2h0cy5sZW5ndGggLSAxXSA9PSBuYW1lKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0cy5wb3AoKTsNCiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGlnaGxpZ2h0TWFwcGluZ1tuYW1lXTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0cy5sZW5ndGggPiAwKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TmFtZSA9IHRoaXMuaGlnaGxpZ2h0c1t0aGlzLmhpZ2hsaWdodHMubGVuZ3RoIC0gMV07DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29sb3IgPSB0aGlzLmhpZ2hsaWdodE1hcHBpbmdbbmV4dE5hbWVdOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdoaWdobGlnaHRDaGFuZ2VkJywgeyBuYW1lOiBuZXh0TmFtZSwgY29sb3I6IG5leHRDb2xvciB9KTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGhpZ2hsaWdodCB3YXMgcmVtb3ZlZCwgc28gZW1pdCBhbiBldmVudCBzYXlpbmcgd2UgYXJlIG5vIGxvbmdlciBoaWdobGlnaHRlZC4NCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGlnaGxpZ2h0Q2hhbmdlZCcpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlZCBoaWdobGlnaHQgd2FzIG5vdCB0aGUgY3VycmVudCBoaWdobGlnaHQsIHNvIG5vIGNoYW5nZSBuZWVkcyB0byBiZSBzaG93bi4NCiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmhpZ2hsaWdodHMuaW5kZXhPZihuYW1lKTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRzLnNwbGljZShpZCwgMSk7DQogICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhpZ2hsaWdodE1hcHBpbmdbbmFtZV07DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChwcm9wYWdhdGVUb0NoaWxkcmVuKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuX19jaGlsZEl0ZW1zLmZvckVhY2goKGNoaWxkSXRlbSkgPT4gew0KICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtLnJlbW92ZUhpZ2hsaWdodChuYW1lLCBwcm9wYWdhdGVUb0NoaWxkcmVuKTsNCiAgICAgICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb2xvciBvZiB0aGUgY3VycmVudCBoaWdobGlnaHQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgY29sb3IgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRIaWdobGlnaHQoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRzLmxlbmd0aCA9PSAwKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gdGhpcy5oaWdobGlnaHRNYXBwaW5nW3RoaXMuaGlnaGxpZ2h0c1t0aGlzLmhpZ2hsaWdodHMubGVuZ3RoIC0gMV1dOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGhpZ2hsaWdodC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBjb2xvciB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEhpZ2hsaWdodE5hbWUoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRzLmxlbmd0aCA9PSAwKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gdGhpcy5oaWdobGlnaHRzW3RoaXMuaGlnaGxpZ2h0cy5sZW5ndGggLSAxXTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBpdGVtcyBoYXMgYSBoaWdobGlnaHQgY29sb3IgYXNzaWduZWQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBgVHJ1ZWAgaWYgdGhpcyBpdGVtIGlzIGhpZ2hsaWdodGVkLg0KICAgICAgICAgKi8NCiAgICAgICAgaXNIaWdobGlnaHRlZCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodHMubGVuZ3RoID4gMDsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIEJvdW5kaW5nIEJveA0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIF9jbGVhbkJvdW5kaW5nQm94IG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGJib3ggLSBUaGUgYm91bmRpbmcgYm94IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICogQHByaXZhdGUNCiAgICAgICAgICovDQogICAgICAgIF9jbGVhbkJvdW5kaW5nQm94KCkgew0KICAgICAgICAgICAgY29uc3QgYmJveCA9IG5ldyBCb3gzKCk7DQogICAgICAgICAgICB0aGlzLl9fY2hpbGRJdGVtcy5mb3JFYWNoKChjaGlsZEl0ZW0pID0+IHsNCiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtLmlzVmlzaWJsZSgpICYmIGNoaWxkSXRlbS5pc1NlbGVjdGFibGUoKSkgew0KICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygiIC0gIiwgY2hpbGRJdGVtLmNvbnN0cnVjdG9yLm5hbWUsIGNoaWxkSXRlbS5nZXROYW1lKCksIGNoaWxkSXRlbS5nbG9iYWxYZm9QYXJhbS52YWx1ZS5zYy54LCBjaGlsZEl0ZW0uZ2V0Qm91bmRpbmdCb3goKS50b1N0cmluZygpKQ0KICAgICAgICAgICAgICAgICAgICBjb25zdCBib3gzID0gY2hpbGRJdGVtLmJvdW5kaW5nQm94UGFyYW0udmFsdWU7DQogICAgICAgICAgICAgICAgICAgIGlmIChib3gzKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5hZGRCb3gzKGJveDMpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nZXROYW1lKCksIGJib3gudG9TdHJpbmcoKSkNCiAgICAgICAgICAgIHJldHVybiBiYm94Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgc2V0Qm91bmRpbmdCb3hEaXJ0eSBtZXRob2QuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBzZXRCb3VuZGluZ0JveERpcnR5KCkgew0KICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRpbmdCb3hQYXJhbSkgew0KICAgICAgICAgICAgICAgIC8vIFdpbGwgY2F1c2UgYm91bmRpbmdDaGFuZ2VkIHRvIGVtaXQNCiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94UGFyYW0uc2V0RGlydHkoLTEpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gTm90ZTogd2UgdXNlZCB0byBoYW5kbGUgdGhpcyBieSBsaXN0ZW5pbmcgdG8gYSAndmFsdWVDaGFuZ2VkJyBldmVudCBvbiB0aGUNCiAgICAgICAgICAgIC8vIHBhcmFtZXRlci4NCiAgICAgICAgICAgIGlmICh0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLnNldEJvdW5kaW5nQm94RGlydHkoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIENoaWxkcmVuDQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGNoaWxkcmVuIGxpc3QsIGJ1dCBjaGlsZHJlbiBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgaGllcmFyY2h5IHN0cnVjdHVyZShgVHJlZUl0ZW1gKS4NCiAgICAgICAgICogTWVhbmluZyB0aGF0IGl0IGNvdWxkIGJlIGFub3RoZXIga2luZCBvZiBpdGVtIHRoYW4gYFRyZWVJdGVtYC4NCiAgICAgICAgICoNCiAgICAgICAgICogaS5lLiAqKkJhc2VJbWFnZSoqDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBMaXN0IG9mIGBUcmVlSXRlbWAgb3duZWQgYnkgY3VycmVudCBUcmVlSXRlbS4NCiAgICAgICAgICovDQogICAgICAgIGdldENoaWxkcmVuKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jaGlsZEl0ZW1zOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGQgdHJlZSBpdGVtcy4NCiAgICAgICAgICovDQogICAgICAgIGdldE51bUNoaWxkcmVuKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jaGlsZEl0ZW1zLmxlbmd0aDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIHRyZWUgaXRlbXMuDQogICAgICAgICAqLw0KICAgICAgICBnZXQgbnVtQ2hpbGRyZW4oKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NoaWxkSXRlbXMubGVuZ3RoOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBBcHBseSBhbiBpbmRleCB0byB0aGUgbmFtZSBpZiBuYW1lIGV4aXN0cyB3aXRoaW4gdGhpcyBpdGVtJ3MgY2hpbGRyZW4uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgdW5pcXVlIG5hbWUuDQogICAgICAgICAqLw0KICAgICAgICBnZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZSkgew0KICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpXSAhPSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFJlZ2V4cCA9IC8oXGQrKSQvaTsNCiAgICAgICAgICAgICAgICBjb25zdCBpbmRleE1hdGNoZXMgPSBuYW1lLm1hdGNoKGluZGV4UmVnZXhwKTsNCiAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXggPSAxOw0KICAgICAgICAgICAgICAgIGlmIChpbmRleE1hdGNoZXMpIHsNCiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBwYXJzZUludChpbmRleE1hdGNoZXNbMV0pICsgMTsNCiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShpbmRleFJlZ2V4cCwgJycpOyAvLyByZW1vdmUgb2xkIGluZGV4DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIG5hbWUgKz0gYCR7bmV3SW5kZXh9YC5wYWRTdGFydCgyLCAnMCcpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIG5hbWU7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUgdGhhdCBzcGVlZHMgdXAgbG9va2luZyB1cCBjaGlsZHJlbiBieSBuYW1lLg0KICAgICAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgdmFsdWUuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICB1cGRhdGVDaGlsZE5hbWVNYXBwaW5nKHN0YXJ0KSB7DQogICAgICAgICAgICAvLyBJZiBhIGNoaWxkIGhhcyBiZWVuIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUNCiAgICAgICAgICAgIC8vIHRyZWUgaXRlbSwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUuDQogICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCB0aGlzLl9fY2hpbGRJdGVtcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9fY2hpbGRJdGVtc1tpXS5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7DQogICAgICAgICAgICAgICAgdGhpcy5jaGlsZEl0ZW1zTWFwcGluZ1tuYW1lXSA9IGk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFdoZW4gYSBjaGlsZCdzIG5hbWUgY2hhbmdlZCwgd2UgdXBkYXRlIG91ciBhY2NlbGVyYXRpb24gc3RydWN0dXJlLg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgc3RhcnQgdmFsdWUuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICBjaGlsZE5hbWVDaGFuZ2VkKGV2ZW50KSB7DQogICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUuDQogICAgICAgICAgICBpZiAodGhpcy5jaGlsZEl0ZW1zTWFwcGluZ0NvcnJ1cHQpIHsNCiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkTmFtZU1hcHBpbmcoMCk7DQogICAgICAgICAgICAgICAgdGhpcy5jaGlsZEl0ZW1zTWFwcGluZ0NvcnJ1cHQgPSBmYWxzZTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIGNvbnN0IG9sZE5hbWUgPSBldmVudC5vbGROYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7DQogICAgICAgICAgICAgICAgY29uc3QgbmV3TmFtZSA9IGV2ZW50Lm5ld05hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTsNCiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbb2xkTmFtZV07DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbbmV3TmFtZV0gIT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkSXRlbXNNYXBwaW5nQ29ycnVwdCA9IHRydWU7DQogICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbb2xkTmFtZV07DQogICAgICAgICAgICAgICAgdGhpcy5jaGlsZEl0ZW1zTWFwcGluZ1tuZXdOYW1lXSA9IGluZGV4Ow0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBJbnNlcnRzIGEgY2hpbGQuIEl0IGFjY2VwdHMgYWxsIGtpbmQgb2YgYFRyZWVJdGVtYCwgbm90IG9ubHkgYFRyZWVJdGVtYC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNoaWxkSXRlbSAtIFRoZSBjaGlsZCBUcmVlSXRlbSB0byBpbnNlcnQuDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB0byBhZGQgdGhlIGNoaWxkIGl0ZW0uDQogICAgICAgICAqIEBwYXJhbSBtYWludGFpblhmbyAtIEJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSBYZm8gdmFsdWUgaXMgbWFpbnRhaW5lZC4NCiAgICAgICAgICogQHBhcmFtIGZpeENvbGxpc2lvbnMgLSBNb2RpZnkgdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gYXZvaWQgbmFtZSBjb2xsaXNpb25zLg0KICAgICAgICAgKiBJZiBmYWxzZSwgYW4gZXhjZXB0aW9uIHdsbCBiZSB0aHJvd24gaW5zdGVhZCBpZiBhIG5hbWUgY29sbGlzaW9uIG9jY3Vycy4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgaXRlbSBpbiB0aGlzIGl0ZW1zIGNoaWxkcmVuIGFycmF5Lg0KICAgICAgICAgKi8NCiAgICAgICAgaW5zZXJ0Q2hpbGQoY2hpbGRJdGVtLCBpbmRleCwgbWFpbnRhaW5YZm8gPSBmYWxzZSwgZml4Q29sbGlzaW9ucyA9IHRydWUpIHsNCiAgICAgICAgICAgIGxldCBuYW1lID0gY2hpbGRJdGVtLm5hbWU7DQogICAgICAgICAgICBsZXQgbmFtZUxjID0gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpOw0KICAgICAgICAgICAgaWYgKG5hbWVMYyBpbiB0aGlzLmNoaWxkSXRlbXNNYXBwaW5nKSB7DQogICAgICAgICAgICAgICAgaWYgKGZpeENvbGxpc2lvbnMpIHsNCiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2VuZXJhdGVVbmlxdWVOYW1lKG5hbWUpOw0KICAgICAgICAgICAgICAgICAgICBuYW1lTGMgPSBuYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7DQogICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5zZXROYW1lKG5hbWUpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJdGVtICciICsgbmFtZSArICInIGlzIGFscmVhZHkgYSBjaGlsZCBvZiA6IiArIHRoaXMuZ2V0UGF0aCgpKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoIShjaGlsZEl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBpcyBpcyBub3QgYSB0cmVlIGl0ZW0gOicgKyBjaGlsZEl0ZW0pOyAvLyBUT0RPOiBuZWVkIGJldHRlciBvdXRwdXQgaGVyZSsgY2hpbGRJdGVtLmNvbnN0cnVjdG9yLm5hbWUpDQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBsaXN0ZW5lcklEcyA9IHt9Ow0KICAgICAgICAgICAgbGlzdGVuZXJJRHNbJ25hbWVDaGFuZ2VkJ10gPSBjaGlsZEl0ZW0ub24oJ25hbWVDaGFuZ2VkJywgKGV2ZW50KSA9PiB7DQogICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5hbWVDaGFuZ2VkKGV2ZW50KTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgbGV0IHByZXZHbG9iYWw7DQogICAgICAgICAgICBpZiAobWFpbnRhaW5YZm8pIHsNCiAgICAgICAgICAgICAgICBwcmV2R2xvYmFsID0gY2hpbGRJdGVtLmdsb2JhbFhmb1BhcmFtLnZhbHVlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7DQogICAgICAgICAgICB0aGlzLmhpZ2hsaWdodHMuZm9yRWFjaCgobmFtZSkgPT4gew0KICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5hZGRIaWdobGlnaHQobmFtZSwgdGhpcy5oaWdobGlnaHRNYXBwaW5nW25hbWVdLCB0cnVlKTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgY2hpbGRJdGVtLnNldEluaGVyaXRlZE9wYWNpdHkodGhpcywgdGhpcy5vcGFjaXR5KTsNCiAgICAgICAgICAgIHRoaXMuX19jaGlsZEl0ZW1zLnNwbGljZShpbmRleCwgMCwgY2hpbGRJdGVtKTsNCiAgICAgICAgICAgIHRoaXMuX19jaGlsZEl0ZW1zRXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDAsIGxpc3RlbmVySURzKTsNCiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm9uLXVuaXF1ZSBuYW1lcywgd2UgbmVlZCB0byByZWdlbmVyYXRlIHRoaXMgbWFwcGluZy4NCiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkSXRlbXNNYXBwaW5nW25hbWVMY10pDQogICAgICAgICAgICAgICAgdGhpcy5jaGlsZEl0ZW1zTWFwcGluZ0NvcnJ1cHQgPSB0cnVlOw0KICAgICAgICAgICAgdGhpcy5jaGlsZEl0ZW1zTWFwcGluZ1tuYW1lTGNdID0gaW5kZXg7DQogICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkTmFtZU1hcHBpbmcoaW5kZXggKyAxKTsNCiAgICAgICAgICAgIGNoaWxkSXRlbS5zZXRPd25lcih0aGlzKTsNCiAgICAgICAgICAgIGlmIChtYWludGFpblhmbykgew0KICAgICAgICAgICAgICAgIC8vIE1haW5haW4gdGhlIHByZXZpb3VzIGdsb2JhbCBYZm8uDQogICAgICAgICAgICAgICAgY2hpbGRJdGVtLmdsb2JhbFhmb1BhcmFtLnZhbHVlID0gcHJldkdsb2JhbDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hpbGRBZGRlZCcsIG5ldyBDaGlsZEFkZGVkRXZlbnQoaW5kZXgsIGNoaWxkSXRlbSkpOw0KICAgICAgICAgICAgcmV0dXJuIGNoaWxkSXRlbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBhIGNoaWxkLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY2hpbGRJdGVtIC0gVGhlIGNoaWxkIFRyZWVJdGVtIHRvIGFkZC4NCiAgICAgICAgICogQHBhcmFtIG1haW50YWluWGZvIC0gQm9vbGVhbiB0aGF0IGRldGVybWluZXMgaWYNCiAgICAgICAgICogdGhlIEdsb2JhbCBYZm8gdmFsdWUgaXMgbWFpbnRhaW5lZC4gSWYgdHJ1ZSwgd2hlbiBtb3ZpbmcNCiAgICAgICAgICogaXRlbXMgaW4gdGhlIGhpZXJhcmNoeSBmcm9tIG9uZSBwYXJlbnQgdG8gYW5vdGhlciwgdGhlIGxvY2FsIFhmbw0KICAgICAgICAgKiBvZiB0aGUgaXRlbSB3aWxsIGJlIG1vZGlmaWVkIHRvIG1haW50YWluIGFuZCB0aGUgR2xvYmFsIFhmby4NCiAgICAgICAgICogTm90ZTogdGhpcyBvcHRpb24gZGVmYXVsdHMgdG8gZmFsc2UgYmVjYXVzZSB3ZSBleHBlY3QgdGhhdCBpcyB0aGUNCiAgICAgICAgICogYmVoYXZpb3IgdXNlcnMgd291bGQgZXhwZWN0IHdoZW4gbWFuaXB1bGF0aW5nIHRoZSB0cmVlIGluIGNvZGUuDQogICAgICAgICAqIFRvIGJlIHNhZmUgYW5kIHVuYW1iaWd1b3VzLCBhbHdheXMgdHJ5IHRvIHNwZWNpZnkgdGhpcyB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGZpeENvbGxpc2lvbnMgLSBNb2RpZnkgdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gYXZvaWQNCiAgICAgICAgICogbmFtZSBjb2xsaXNpb25zIHdpdGggb3RoZXIgY2hpbGRyZW4gb2YgdGhlIHNhbWUgcGFyZW50Lg0KICAgICAgICAgKiBJZiBmYWxzZSwgYW4gZXhjZXB0aW9uIHdsbCBiZSB0aHJvd24gaW5zdGVhZCBpZiBhIG5hbWUgY29sbGlzaW9uIG9jY3Vycy4NCiAgICAgICAgICogQHJldHVybiBjaGlsZEl0ZW0gLSBUaGUgY2hpbGQgVHJlZUl0ZW0gdGhhdCB3YXMgYWRkZWQuDQogICAgICAgICAqLw0KICAgICAgICBhZGRDaGlsZChjaGlsZEl0ZW0sIG1haW50YWluWGZvID0gdHJ1ZSwgZml4Q29sbGlzaW9ucyA9IHRydWUpIHsNCiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2NoaWxkSXRlbXMubGVuZ3RoOw0KICAgICAgICAgICAgdGhpcy5pbnNlcnRDaGlsZChjaGlsZEl0ZW0sIGluZGV4LCBtYWludGFpblhmbywgZml4Q29sbGlzaW9ucyk7DQogICAgICAgICAgICByZXR1cm4gY2hpbGRJdGVtOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGNoaWxkIGVsZW1lbnQgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHJlbW92ZSB0aGUgY2hpbGQgVHJlZUl0ZW0uDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gdGhlIGNoaWxkIFRyZWVJdGVtLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0Q2hpbGQoaW5kZXgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY2hpbGRJdGVtc1tpbmRleF07DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY2hpbGQgZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybiB0aGUgY2hpbGQgVHJlZUl0ZW0uDQogICAgICAgICAqLw0KICAgICAgICBnZXRDaGlsZEJ5TmFtZShuYW1lKSB7DQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpXTsNCiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2NoaWxkSXRlbXNbaW5kZXhdOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIG51bGw7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY2hpbGRyZW4gbmFtZXMgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIEFuIGFycmF5IG9mIG5hbWVzIGZvciBlYWNoIGNoaWxkLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0Q2hpbGROYW1lcygpIHsNCiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gW107DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX19jaGlsZEl0ZW1zLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgY29uc3QgY2hpbGRJdGVtID0gdGhpcy5fX2NoaWxkSXRlbXNbaV07DQogICAgICAgICAgICAgICAgaWYgKGNoaWxkSXRlbSAhPSBudWxsKQ0KICAgICAgICAgICAgICAgICAgICBuYW1lc1tpXSA9IGNoaWxkSXRlbS5nZXROYW1lKCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gbmFtZXM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFVuQmluZCBhbiBpdGVtIGZyb20gdGhlIGdyb3VwLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQNCiAgICAgICAgICogYXV0b21hdGljYWxseSB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBncm91cC4NCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY2hpbGRJdGVtIC0gaXRlbSB0byB1bmJpbmQuDQogICAgICAgICAqIEBwcml2YXRlDQogICAgICAgICAqLw0KICAgICAgICB1bmJpbmRDaGlsZChpbmRleCwgY2hpbGRJdGVtKSB7DQogICAgICAgICAgICBjb25zdCBsaXN0ZW5lcklEcyA9IHRoaXMuX19jaGlsZEl0ZW1zRXZlbnRIYW5kbGVyc1tpbmRleF07DQogICAgICAgICAgICBjaGlsZEl0ZW0ub2ZmKCduYW1lQ2hhbmdlZCcsIGxpc3RlbmVySURzWyduYW1lQ2hhbmdlZCddKTsNCiAgICAgICAgICAgIHRoaXMuX19jaGlsZEl0ZW1zLnNwbGljZShpbmRleCwgMSk7DQogICAgICAgICAgICB0aGlzLl9fY2hpbGRJdGVtc0V2ZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTsNCiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkSXRlbXNNYXBwaW5nW2NoaWxkSXRlbS5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCldOw0KICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZE5hbWVNYXBwaW5nKGluZGV4KTsNCiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCB7IGNoaWxkSXRlbSwgaW5kZXggfSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlbW92ZXMgYSBjaGlsZCBUcmVlSXRlbSBieSBzcGVjaWZ5aW5nIGl0cyBpbmRleC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlQ2hpbGQoaW5kZXgpIHsNCiAgICAgICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IHRoaXMuX19jaGlsZEl0ZW1zW2luZGV4XTsNCiAgICAgICAgICAgIGlmICghY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy51bmJpbmRDaGlsZChpbmRleCwgY2hpbGRJdGVtKTsNCiAgICAgICAgICAgIGNoaWxkSXRlbS5zZXRPd25lcih1bmRlZmluZWQpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZW1vdmVzIGEgY2hpbGQgVHJlZUl0ZW0gYnkgc3BlY2lmeWluZyBpdHMgbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBwYXJhbS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybiB0aGUgY2hpbGQgVHJlZUl0ZW0uDQogICAgICAgICAqLw0KICAgICAgICByZW1vdmVDaGlsZEJ5TmFtZShuYW1lKSB7DQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRJdGVtc01hcHBpbmdbbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpXTsNCiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZChpbmRleCk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGl0ZW0gZnJvbSB0aGlzIFRyZWVJdGVtIGlmIGl0IGlzIG9uZSBvZiBpdHMgY2hpbGRyZW4uDQogICAgICAgICAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGl0ZW0gaXMgbm90IGEgY2hpbGQgb2YgdGhpcyB0cmVlIGl0ZW0uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjaGlsZEl0ZW0gLSBUaGUgY2hpbGQgVHJlZUl0ZW0gdG8gcmVtb3ZlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVtb3ZlQ2hpbGRCeUhhbmRsZShjaGlsZEl0ZW0pIHsNCiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fX2NoaWxkSXRlbXMuaW5kZXhPZihjaGlsZEl0ZW0pOw0KICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKQ0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgaW4gcmVtb3ZlQ2hpbGRCeUhhbmRsZS4gQ2hpbGQgbm90IGZvdW5kOicgKyBjaGlsZEl0ZW0uZ2V0TmFtZSgpKTsNCiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoaW5kZXgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBJdGVtcy4NCiAgICAgICAgICovDQogICAgICAgIHJlbW92ZUFsbENoaWxkcmVuKCkgew0KICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fX2NoaWxkSXRlbXMubGVuZ3RoOw0KICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGluZGV4KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGluZGV4IHBvc2l0aW9uIG9mIHRoZSBzcGVjaWZpZWQgaXRlbS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNoaWxkSXRlbSAtIFRoZSBjaGlsZCBUcmVlSXRlbSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIENoaWxkIGluZGV4IGluIGNoaWxkcmVuIGFycmF5Lg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0Q2hpbGRJbmRleChjaGlsZEl0ZW0pIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY2hpbGRJdGVtcy5pbmRleE9mKGNoaWxkSXRlbSk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQYXRoIFRyYXZlcnNhbA0KICAgICAgICAvLyBOb3RlOiBQYXRoIHJlc29sdXRpb24gc3RhcnRzIGF0IHRoZSByb290IG9mIHRoZQ0KICAgICAgICAvLyB0cmVlIHRoZSBwYXRoIHdhcyBnZW5lcmF0ZWQgZnJvbSAoc28gaW5kZXg9MSwgYmVjYXVzZSB3ZSBkb24ndCByZXNvbHZlIHJvb3QpLg0KICAgICAgICAvLyBOb3RlOiBXaGVuIGEgcGF0aCBpcyBtYWRlIHJlbGF0aXZlIHRvIGFuIGl0ZW0gaW4gaXRzIHRyZWUsIHRoZSBwYXRoDQogICAgICAgIC8vIHN0YXJ0cyB3aXRoIHRoZSBjaGlsZCBlbGVtZW50cy4NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSByZXNvbHZlUGF0aCBtZXRob2QgdHJhdmVyc2VzIHRoZSBzdWJ0cmVlIGZyb20gdGhpcyBpdGVtIGRvd24NCiAgICAgICAgICogbWF0Y2hpbmcgZWFjaCBuYW1lIGluIHRoZSBwYXRoIHdpdGggYSBjaGlsZCB1bnRpbCBpdCByZWFjaGVzIHRoZQ0KICAgICAgICAgKiBlbmQgb2YgdGhlIHBhdGguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZXNvbHZlUGF0aChwYXRoLCBpbmRleCA9IDApIHsNCiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKSB7DQogICAgICAgICAgICAgICAgaWYgKHBhdGhbMF0gPT0gJy4nIHx8IHBhdGhbMF0gPT0gdGhpcy5fX25hbWUpDQogICAgICAgICAgICAgICAgICAgIGluZGV4Kys7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAocGF0aFtpbmRleF0gPT0gJy4uJykgew0KICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fb3duZXJJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fb3duZXJJdGVtLnJlc29sdmVQYXRoKHBhdGgsIGluZGV4ICsgMSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigndGhpcy5fX293bmVySXRlbSBpcyB1bmRlZmluZWQnKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoaW5kZXggPT0gcGF0aC5sZW5ndGgpIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IGNoaWxkTmFtZSA9IHBhdGhbaW5kZXhdOw0KICAgICAgICAgICAgY29uc3QgY2hpbGRJdGVtID0gdGhpcy5nZXRDaGlsZEJ5TmFtZShjaGlsZE5hbWUpOw0KICAgICAgICAgICAgaWYgKGNoaWxkSXRlbSkgew0KICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZEl0ZW0ucmVzb2x2ZVBhdGgocGF0aCwgaW5kZXggKyAxKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXNvbHZlUGF0aChwYXRoLCBpbmRleCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRyYXZlcnNlIHRoZSB0cmVlIHN0cnVjdHVyZSBmcm9tIHRoaXMgcG9pbnQgZG93bg0KICAgICAgICAgKiBhbmQgZmlyZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggdmlzaXRlZCBpdGVtLg0KICAgICAgICAgKiBOb3RlOiBEZXB0aCBvbmx5IHVzZWQgYnkgc2VsZWN0aW9uIHNldHMgZm9yIG5vdy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gaW5jbHVkZVRoaXMgLSBGaXJlIHRoZSBjYWxsYmFjayBmb3IgdGhpcyBpdGVtLg0KICAgICAgICAgKi8NCiAgICAgICAgdHJhdmVyc2UoY2FsbGJhY2ssIGluY2x1ZGVUaGlzID0gdHJ1ZSkgew0KICAgICAgICAgICAgY29uc3QgX19jID0gKHRyZWVJdGVtLCBkZXB0aCkgPT4gew0KICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZUl0ZW0uZ2V0Q2hpbGRyZW4oKTsNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSXRlbSBvZiBjaGlsZHJlbikgew0KICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKQ0KICAgICAgICAgICAgICAgICAgICAgICAgX190KGNoaWxkSXRlbSwgZGVwdGggKyAxKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgY29uc3QgX190ID0gKHRyZWVJdGVtLCBkZXB0aCkgPT4gew0KICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayh0cmVlSXRlbSwgZGVwdGgpID09IGZhbHNlKQ0KICAgICAgICAgICAgICAgICAgICByZXR1cm47DQogICAgICAgICAgICAgICAgX19jKHRyZWVJdGVtLCBkZXB0aCk7DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgaWYgKGluY2x1ZGVUaGlzKSB7DQogICAgICAgICAgICAgICAgX190KHRoaXMsIDEpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgX19jKHRoaXMsIDApOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIEV2ZW50cw0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBWaWV3cG9ydCB3aGVuIGV2ZW50cyBhcmUgcmVjZWl2ZWQgYnkgdGhlIGNhbnZhcyBlbGVtZW50Lg0KICAgICAgICAgKiBUaGUgZXZlbnQgaXMgcHJvcGFnYXRlZCB0byBhIFRyZWVJdGVtIGlmIGl0IGlzIHVuZGVyIHRoZSBwb2ludGVyIGF0IHRoZSB0aW1lLg0KICAgICAgICAgKiBUaGUgWmVhUG9pbnRlckV2ZW50IGFic3RyYWN0cyB0aGUgTW91c2UsIHRvdWNoIGFuZCBvdXIgY3VzdG9tIFhSIGV2ZW50cy4NCiAgICAgICAgICogVGhpcyBtZXRob2QgZW1pdHMgdGhlIFplYVBvaW50ZXJFdmVudCB3aXRoIHRoZSBrZXkgJ3BvaW50ZXJEb3duJywgYW5kDQogICAgICAgICAqIHByb3BhZ2F0ZXMgaXQgdXAgdG8gdGhlIFRyZWVJdGVtJ3Mgb3duZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB2YWx1ZQ0KICAgICAgICAgKi8NCiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkgew0KICAgICAgICAgICAgdGhpcy5lbWl0KCdwb2ludGVyRG93bicsIGV2ZW50KTsNCiAgICAgICAgICAgIGlmIChldmVudC5wcm9wYWdhdGluZyAmJiB0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLm9uUG9pbnRlckRvd24oZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gZXZlbnRzIGFyZSByZWNlaXZlZCBieSB0aGUgY2FudmFzIGVsZW1lbnQuDQogICAgICAgICAqIFRoZSBldmVudCBpcyBwcm9wYWdhdGVkIHRvIGEgVHJlZUl0ZW0gaWYgaXQgaXMgdW5kZXIgdGhlIHBvaW50ZXIgYXQgdGhlIHRpbWUuDQogICAgICAgICAqIFRoZSBaZWFQb2ludGVyRXZlbnQgYWJzdHJhY3RzIHRoZSBNb3VzZSwgdG91Y2ggYW5kIG91ciBjdXN0b20gWFIgZXZlbnRzLg0KICAgICAgICAgKiBUaGlzIG1ldGhvZCBlbWl0cyB0aGUgWmVhUG9pbnRlckV2ZW50IHdpdGggdGhlIGtleSAncG9pbnRlckRvd24nLCBhbmQNCiAgICAgICAgICogcHJvcGFnYXRlcyBpdCB1cCB0byB0aGUgVHJlZUl0ZW0ncyBvd25lci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHBvaW50ZXIgZXZlbnQgdGhhdCB3YXMgZ2VuZXJhdGVkIGZyb20gdGhlIHVzZXIgaW50ZXJhY3Rpb24NCiAgICAgICAgICovDQogICAgICAgIG9uUG9pbnRlclVwKGV2ZW50KSB7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3BvaW50ZXJVcCcsIGV2ZW50KTsNCiAgICAgICAgICAgIGlmIChldmVudC5wcm9wYWdhdGluZyAmJiB0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLm9uUG9pbnRlclVwKGV2ZW50KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBWaWV3cG9ydCB3aGVuIGV2ZW50cyBhcmUgcmVjZWl2ZWQgYnkgdGhlIGNhbnZhcyBlbGVtZW50Lg0KICAgICAgICAgKiBUaGUgZXZlbnQgaXMgcHJvcGFnYXRlZCB0byBhIFRyZWVJdGVtIGlmIGl0IGlzIHVuZGVyIHRoZSBwb2ludGVyIGF0IHRoZSB0aW1lLg0KICAgICAgICAgKiBUaGUgWmVhUG9pbnRlckV2ZW50IGFic3RyYWN0cyB0aGUgTW91c2UsIHRvdWNoIGFuZCBvdXIgY3VzdG9tIFhSIGV2ZW50cy4NCiAgICAgICAgICogVGhpcyBtZXRob2QgZW1pdHMgdGhlIFplYVBvaW50ZXJFdmVudCB3aXRoIHRoZSBrZXkgJ3BvaW50ZXJNb3ZlJywgYW5kDQogICAgICAgICAqIHByb3BhZ2F0ZXMgaXQgdXAgdG8gdGhlIFRyZWVJdGVtJ3Mgb3duZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBwb2ludGVyIGV2ZW50IHRoYXQgd2FzIGdlbmVyYXRlZCBmcm9tIHRoZSB1c2VyIGludGVyYWN0aW9uDQogICAgICAgICAqLw0KICAgICAgICBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3BvaW50ZXJNb3ZlJywgZXZlbnQpOw0KICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BhZ2F0aW5nICYmIHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX19vd25lckl0ZW0ub25Qb2ludGVyTW92ZShldmVudCk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENhbGxlZCBieSB0aGUgVmlld3BvcnQgd2hlbiB0aGUgbW91c2Ugb3Igb3RoZXIgcG9pbnRlciBlbnRlcnMgdGhlIGNhbnZhcyBlbGVtZW50Lg0KICAgICAgICAgKiBUaGUgZXZlbnQgaXMgcHJvcGFnYXRlZCB0byBhIFRyZWVJdGVtIGlmIGl0IGlzIHVuZGVyIHRoZSBwb2ludGVyIGF0IHRoZSB0aW1lLg0KICAgICAgICAgKiBUaGUgWmVhUG9pbnRlckV2ZW50IGFic3RyYWN0cyB0aGUgTW91c2UsIHRvdWNoIGFuZCBvdXIgY3VzdG9tIFhSIGV2ZW50cy4NCiAgICAgICAgICogVGhpcyBtZXRob2QgZW1pdHMgdGhlIFplYVBvaW50ZXJFdmVudCB3aXRoIHRoZSBrZXkgJ3BvaW50ZXJFbnRlcicsIGFuZA0KICAgICAgICAgKiBwcm9wYWdhdGVzIGl0IHVwIHRvIHRoZSBUcmVlSXRlbSdzIG93bmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcG9pbnRlciBldmVudCB0aGF0IHdhcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdXNlciBpbnRlcmFjdGlvbg0KICAgICAgICAgKi8NCiAgICAgICAgb25Qb2ludGVyRW50ZXIoZXZlbnQpIHsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9pbnRlckVudGVyJywgZXZlbnQpOw0KICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BhZ2F0aW5nICYmIHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX19vd25lckl0ZW0ub25Qb2ludGVyRW50ZXIoZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gdGhlIG1vdXNlIG9yIG90aGVyIHBvaW50ZXIgbGVhdmVzIHRoZSBjYW52YXMgZWxlbWVudC4NCiAgICAgICAgICogVGhlIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdG8gYSBUcmVlSXRlbSBpZiBpdCBpcyB1bmRlciB0aGUgcG9pbnRlciBhdCB0aGUgdGltZS4NCiAgICAgICAgICogVGhlIFplYVBvaW50ZXJFdmVudCBhYnN0cmFjdHMgdGhlIE1vdXNlLCB0b3VjaCBhbmQgb3VyIGN1c3RvbSBYUiBldmVudHMuDQogICAgICAgICAqIFRoaXMgbWV0aG9kIGVtaXRzIHRoZSBaZWFQb2ludGVyRXZlbnQgd2l0aCB0aGUga2V5ICdwb2ludGVyTGVhdmUnLCBhbmQNCiAgICAgICAgICogcHJvcGFnYXRlcyBpdCB1cCB0byB0aGUgVHJlZUl0ZW0ncyBvd25lci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHBvaW50ZXIgZXZlbnQgdGhhdCB3YXMgZ2VuZXJhdGVkIGZyb20gdGhlIHVzZXIgaW50ZXJhY3Rpb24NCiAgICAgICAgICovDQogICAgICAgIG9uUG9pbnRlckxlYXZlKGV2ZW50KSB7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3BvaW50ZXJMZWF2ZScsIGV2ZW50KTsNCiAgICAgICAgICAgIGlmIChldmVudC5wcm9wYWdhdGluZyAmJiB0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLm9uUG9pbnRlckxlYXZlKGV2ZW50KTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBWaWV3cG9ydCB3aGVuIHRoZSBtb3VzZSBvciBvdGhlciBwb2ludGVyIGlzIGNsaWNrZWQgb24gdGhpcyBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcG9pbnRlciBldmVudCB0aGF0IHdhcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdXNlciBpbnRlcmFjdGlvbg0KICAgICAgICAgKi8NCiAgICAgICAgb25Qb2ludGVyQ2xpY2soZXZlbnQpIHsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9pbnRlckNsaWNrJywgZXZlbnQpOw0KICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BhZ2F0aW5nICYmIHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX19vd25lckl0ZW0ub25Qb2ludGVyQ2xpY2soZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gdGhlIG1vdXNlIG9yIG90aGVyIHBvaW50ZXIgaXMgZG91YmxlLWNsaWNrZWQgb24gdGhpcyBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcG9pbnRlciBldmVudCB0aGF0IHdhcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdXNlciBpbnRlcmFjdGlvbg0KICAgICAgICAgKi8NCiAgICAgICAgb25Qb2ludGVyRG91YmxlQ2xpY2soZXZlbnQpIHsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgncG9pbnRlckRvdWJsZUNsaWNrJywgZXZlbnQpOw0KICAgICAgICAgICAgaWYgKGV2ZW50LnByb3BhZ2F0aW5nICYmIHRoaXMuX19vd25lckl0ZW0gaW5zdGFuY2VvZiBUcmVlSXRlbSkgew0KICAgICAgICAgICAgICAgIHRoaXMuX19vd25lckl0ZW0ub25Qb2ludGVyRG91YmxlQ2xpY2soZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gdGhlIG1vdXNlIG9yIG90aGVyIHBvaW50ZXIgaXMgZG91YmxlLWNsaWNrZWQgb24gdGhpcyBpdGVtLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgcG9pbnRlciBldmVudCB0aGF0IHdhcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdXNlciBpbnRlcmFjdGlvbg0KICAgICAgICAgKi8NCiAgICAgICAgb25Qb2ludGVyTG9uZ1ByZXNzKGV2ZW50KSB7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ3BvaW50ZXJMb25nUHJlc3MnLCBldmVudCk7DQogICAgICAgICAgICBpZiAoZXZlbnQucHJvcGFnYXRpbmcgJiYgdGhpcy5fX293bmVySXRlbSBpbnN0YW5jZW9mIFRyZWVJdGVtKSB7DQogICAgICAgICAgICAgICAgdGhpcy5fX293bmVySXRlbS5vblBvaW50ZXJMb25nUHJlc3MoZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gdGhlIG1vdXNlIHdoZWVsIGV2ZW50IGlzIHJlY2VpdmVkIGJ5IHRoZSBjYW52YXMgZWxlbWVudC4NCiAgICAgICAgICogRW1pdHMgdGhlIFplYVdoZWVsRXZlbnQgd2l0aCB0aGUga2V5ICdtb3VzZVdoZWVsJywgYW5kIFByb3BhZ2F0ZXMgaXMgdXAgdG8gdGhlIFRyZWVJdGVtJ3Mgb3duZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSB3aGVlbCBldmVudCB0aGF0IG9jY3Vycy4NCiAgICAgICAgICovDQogICAgICAgIG9uV2hlZWwoZXZlbnQpIHsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgnbW91c2VXaGVlbCcsIGV2ZW50KTsNCiAgICAgICAgICAgIGlmIChldmVudC5wcm9wYWdhdGluZyAmJiB0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLm9uV2hlZWwoZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIFZpZXdwb3J0IHdoZW4gdGhlIHRvdWNoIGNhbmNlbCBldmVudCBpcyByZWNlaXZlZCBieSB0aGUgY2FudmFzIGVsZW1lbnQuDQogICAgICAgICAqIEVtaXRzIHRoZSBaZWFUb3VjaEV2ZW50IHdpdGggdGhlIGtleSAndG91Y2hDYW5jZWwnLCBhbmQgUHJvcGFnYXRlcyBpcyB1cCB0byB0aGUgVHJlZUl0ZW0ncyBvd25lci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIHdoZWVsIGV2ZW50IHRoYXQgb2NjdXJzLg0KICAgICAgICAgKi8NCiAgICAgICAgb25Ub3VjaENhbmNlbChldmVudCkgew0KICAgICAgICAgICAgdGhpcy5lbWl0KCd0b3VjaENhbmNlbCcsIGV2ZW50KTsNCiAgICAgICAgICAgIGlmIChldmVudC5wcm9wYWdhdGluZyAmJiB0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgVHJlZUl0ZW0pIHsNCiAgICAgICAgICAgICAgICB0aGlzLl9fb3duZXJJdGVtLm9uVG91Y2hDYW5jZWwoZXZlbnQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIHNlcmlhbGl6ZXMgdGhpcyBpbnN0YW5jZSBhcyBhIEpTT04uDQogICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciBwZXJzaXN0ZW5jZSwgZGF0YSB0cmFuc2ZlciwgZXRjLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgbGV0IGogPSBzdXBlci50b0pTT04oY29udGV4dCk7DQogICAgICAgICAgICAvLyBTb21lIEl0ZW1zLCBzdWNoIGFzIHRoZSBTbGlkZXJTY2VuZVdpZGdldCBkbyBub3QgbmVlZCB0aGVpciBjaGlsZHJlbg0KICAgICAgICAgICAgLy8gdG8gYmUgc2F2ZWQuDQogICAgICAgICAgICBjb25zdCBjaGlsZEl0ZW1zSlNPTiA9IHt9Ow0KICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZEl0ZW0gb2YgdGhpcy5fX2NoaWxkSXRlbXMpIHsNCiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSlNPTiA9IGNoaWxkSXRlbS50b0pTT04oY29udGV4dCk7DQogICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEpTT04pDQogICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW1zSlNPTltjaGlsZEl0ZW0uZ2V0TmFtZSgpXSA9IGNoaWxkSlNPTjsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hpbGRJdGVtc0pTT04pLmxlbmd0aCA+IDApIHsNCiAgICAgICAgICAgICAgICBpZiAoaikgew0KICAgICAgICAgICAgICAgICAgICBqLmNoaWxkcmVuID0gY2hpbGRJdGVtc0pTT047DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICBqID0gew0KICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5fX25hbWUsDQogICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRJdGVtc0pTT04sDQogICAgICAgICAgICAgICAgICAgIH07DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIGo7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgdGFrZXMgYSBKU09OIGFuZCBkZXNlcmlhbGl6ZXMgaW50byBhbiBpbnN0YW5jZSBvZiB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQsIG9uRG9uZSkgew0KICAgICAgICAgICAgc3VwZXIuZnJvbUpTT04oaiwgY29udGV4dCk7DQogICAgICAgICAgICAvLyBpZiAoJ2Jib3gnIGluIGopew0KICAgICAgICAgICAgLy8gICAgIGxldCBib3ggPSBuZXcgQm94MygpOw0KICAgICAgICAgICAgLy8gICAgIGJveC5mcm9tSlNPTihqLmJib3gpOw0KICAgICAgICAgICAgLy8gICAgIHRoaXMuYm91bmRpbmdCb3hQYXJhbS52YWx1ZSA9IGJveCkNCiAgICAgICAgICAgIC8vIH0NCiAgICAgICAgICAgIGlmIChqLmNoaWxkcmVuICE9IG51bGwpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkpzb24gPSBqLmNoaWxkcmVuOw0KICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuSnNvbikpIHsNCiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZEpzb24gb2YgY2hpbGRyZW5Kc29uKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBEdXJpbmcgbG9hZGluZyBvZiBhc3NldCB0cmVlcywgd2UgaGF2ZSBhbg0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgdHJlZSBnZW5lcmF0ZWQgYnkgbG9hZGluZyBhIGJpbiBkYXRhIGZpbGUuDQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRJdGVtID0gdGhpcy5nZXRDaGlsZEJ5TmFtZShjaGlsZEpzb24ubmFtZSk7DQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtLmZyb21KU09OKGNoaWxkSnNvbiwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRKc29uLnR5cGUpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gUmVnaXN0cnkuY29uc3RydWN0Q2xhc3MoY2hpbGRKc29uLnR5cGUpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSBzaG91bGQgbG9hZCB0aGUganNvbiBmaXJzdCwgYXMgaXQNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBjb250YWluIHRoZSB1bmlxdWUgbmFtZSBvZiB0aGUgaXRlbS4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5mcm9tSlNPTihjaGlsZEpzb24sIGNvbnRleHQpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZEl0ZW0sIGZhbHNlLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4NCiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE5hbWUgaW4gY2hpbGRyZW5Kc29uKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEpzb24gPSBjaGlsZHJlbkpzb25bY2hpbGROYW1lXTsNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IER1cmluZyBsb2FkaW5nIG9mIGFzc2V0IHRyZWVzLCB3ZSBoYXZlIGFuDQogICAgICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyB0cmVlIGdlbmVyYXRlZCBieSBsb2FkaW5nIGEgYmluIGRhdGEgZmlsZS4NCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEl0ZW0gPSB0aGlzLmdldENoaWxkQnlOYW1lKGNoaWxkTmFtZSk7DQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtLmZyb21KU09OKGNoaWxkSnNvbiwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZEpzb24udHlwZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKGNoaWxkSnNvbi50eXBlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJdGVtKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGFkZCB0aGUgY2hpbGQgbm93IGJlZm9yZSBsb2FkaW5nLg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgY2VydGFpbiBpdGVtcy4gKGUuZy4gR3JvdXBzKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlaXIgZ2xvYmFsIFhmbywgYW5kIHVzZSBpdCB0byBtb2RpZnkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRyYW5zZm9ybSBvZiB0aGVpciBtZW1iZXJzLg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBHcm91cHMgYmluZCB0byBpdGVtcyBpbiB0aGUgc2NlbmUgd2hpY2ggYXJlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgYWRkZWQgYXMgY2hpbGRyZW4sIGFuZCBzbyBoYXZlIGdsb2JhbCBYZm9zLg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwcmVmZXIgdG8gYWRkIGEgY2hpbGQgYWZ0ZXIgaXRzIGxvYWRlZCwgYmVjYXVzZSBzb21ldGltZXMNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIHRyZWUgaXMgYXNzZXQgaXRlbXMsIHdobyB3aWxsIG9ubHkgdG9nZ2xlZCBhcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvYWRlZCBvbmNlIHRoZXkgYXJlIGxvYWRlZChlbHNlIHRoZXkgYXJlIGNvbnNpZGVyZWQgaW5saW5lIGFzc2V0cy4pDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5mcm9tSlNPTihjaGlsZEpzb24sIGNvbnRleHQpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkSXRlbSwgZmFsc2UsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIDsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIGlmIChqLmNvbXBvbmVudHMpIHsNCiAgICAgICAgICAgIC8vICAgZm9yIChjb25zdCBjaiBvZiBqLmNvbXBvbmVudHMpIHsNCiAgICAgICAgICAgIC8vICAgICBjb25zdCBjb21wb25lbnQgPSBSZWdpc3RyeS5jb25zdHJ1Y3RDbGFzcyhjai50eXBlID8gY2oudHlwZSA6IGNqLm5hbWUpDQogICAgICAgICAgICAvLyAgICAgaWYgKGNvbXBvbmVudCkgew0KICAgICAgICAgICAgLy8gICAgICAgY29tcG9uZW50LmZyb21KU09OKGNqLCBjb250ZXh0KQ0KICAgICAgICAgICAgLy8gICAgICAgdGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KQ0KICAgICAgICAgICAgLy8gICAgIH0NCiAgICAgICAgICAgIC8vICAgfQ0KICAgICAgICAgICAgLy8gfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIGN1cnJlbnQgSXRlbShJbmNsdWRpbmcgcGFyYW1ldGVycyAmIGNoaWxkcmVuKSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICBzdXBlci5yZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCk7DQogICAgICAgICAgICBjb25zdCBpdGVtRmxhZ3MgPSByZWFkZXIubG9hZFVJbnQ4KCk7DQogICAgICAgICAgICBjb25zdCB2aXNpYmlsaXR5RmxhZyA9IDEgPDwgMTsNCiAgICAgICAgICAgIC8vIE5vdGU6IFhSZWYgbG9hZHMgYSB2aXNpYmxpdHkgc2V0dGluZyBmb3IgaXRzZWxmIHdoZW4gbG9hZGluZyBpbiB0aGUgcGFyZW50IGFzc2VtYmx5IHRyZWUsDQogICAgICAgICAgICAvLyB0aGVuIGl0IGxvYWRzIHRoZSB6Y2FkIGZpbGUgd2hpY2ggY29udGFpbnMgYSB2aXNpYmlsaXR5IHNldHRpbmcgZm9yIHRoZSBDQURBc3NzZXQuIFRoaXMNCiAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgc2V0dGluZyB3b3VsZCBvdmVycmlkZSB0aGUgWFJlZi4gSWRlYWxseSB0aGUgemNhZCBmaWxlIHdvdWxkIG5vdCBzdG9yZSBhIHZpc2libGl0eQ0KICAgICAgICAgICAgLy8gc2V0dGluZyBmb3IgdGhlIENBREFzc2V0LCBhcyB0aGF0IHNob3VsZCBiZSBzZXQgYnkgdGhlIGxvYWRpbmcgY29udGV4dC4NCiAgICAgICAgICAgIC8vIFZpc2libGUgaXMgdHJ1ZSBieSBkZWZhdWx0LCBzbyBvbmx5IHNldCBpdCB0byBmYWxzZS4gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCB0aGUgYWJvdmUgY29uZmxpY3QuDQogICAgICAgICAgICBpZiAoKGl0ZW1GbGFncyAmIHZpc2liaWxpdHlGbGFnKSA9PSAwKQ0KICAgICAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7DQogICAgICAgICAgICAvLyBOb3RlOiB0byBzYXZlIHNwYWNlLCBzb21lIHZhbHVlcyBhcmUgc2tpcHBlZCBpZiB0aGV5IGFyZSBpZGVudGl0eSB2YWx1ZXMNCiAgICAgICAgICAgIGNvbnN0IGxvY2FsWGZvRmxhZyA9IDEgPDwgMjsNCiAgICAgICAgICAgIGNvbnN0IGxvY2FsWGZvSW5kZXBlbmRlbnRTY0ZsYWcgPSAxIDw8IDU7DQogICAgICAgICAgICBpZiAoaXRlbUZsYWdzICYgbG9jYWxYZm9GbGFnKSB7DQogICAgICAgICAgICAgICAgY29uc3QgeGZvID0gbmV3IFhmbygpOw0KICAgICAgICAgICAgICAgIHhmby50ciA9IHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKTsNCiAgICAgICAgICAgICAgICB4Zm8ub3JpID0gcmVhZGVyLmxvYWRGbG9hdDMyUXVhdCgpOw0KICAgICAgICAgICAgICAgIGlmIChpdGVtRmxhZ3MgJiBsb2NhbFhmb0luZGVwZW5kZW50U2NGbGFnKSB7DQogICAgICAgICAgICAgICAgICAgIHhmby5zYyA9IHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICAgICAgICAgIHhmby5zYy5zZXQoc2MsIHNjLCBzYyk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMubG9jYWxYZm9QYXJhbS52YWx1ZSA9IHhmbzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IGJib3hGbGFnID0gMSA8PCAzOw0KICAgICAgICAgICAgaWYgKGl0ZW1GbGFncyAmIGJib3hGbGFnKSB7DQogICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveFBhcmFtLmxvYWRWYWx1ZShuZXcgQm94MyhyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSkpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgbnVtQ2hpbGRyZW4gPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgaWYgKG51bUNoaWxkcmVuID4gMCkgew0KICAgICAgICAgICAgICAgIGNvbnN0IHRvYyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkobnVtQ2hpbGRyZW4pOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hpbGRyZW47IGkrKykgew0KICAgICAgICAgICAgICAgICAgICB0cnkgew0KICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNlZWsodG9jW2ldKTsgLy8gUmVzZXQgdGhlIHBvaW50ZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBpdGVtIGRhdGEuDQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRUeXBlID0gcmVhZGVyLmxvYWRTdHIoKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IFJlZ2lzdHJ5LmNvbnN0cnVjdENsYXNzKGNoaWxkVHlwZSk7DQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkSXRlbSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTmFtZSA9IHJlYWRlci5sb2FkU3RyKCk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29uc3RydWN0IGNoaWxkOicgKyBjaGlsZE5hbWUgKyAnIG9mIHR5cGU6JyArIGNoaWxkVHlwZSk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2Vlayh0b2NbaV0pOyAvLyBSZXNldCB0aGUgcG9pbnRlciB0byB0aGUgc3RhcnQgb2YgdGhlIGl0ZW0gZGF0YS4NCiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbS5yZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCk7DQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkSXRlbSwgZmFsc2UsIHRydWUpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvYWRpbmcgdHJlZSBpdGVtOiAnLCBlKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIENsb25lIGFuZCBEZXN0cm95DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgY2xvbmUgbWV0aG9kIGNvbnN0cnVjdHMgYSBuZXcgdHJlZSBpdGVtLCBjb3BpZXMgaXRzIHZhbHVlcw0KICAgICAgICAgKiBmcm9tIHRoaXMgaXRlbSBhbmQgcmV0dXJucyBpdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY2xvbmVkIHRyZWUgaXRlbS4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBUcmVlSXRlbSgnJyk7DQogICAgICAgICAgICBjbG9uZWQuY29weUZyb20odGhpcywgY29udGV4dCk7DQogICAgICAgICAgICByZXR1cm4gY2xvbmVkOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb3BpZXMgY3VycmVudCBUcmVlSXRlbSB3aXRoIGFsbCBpdHMgY2hpbGRyZW4uDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzcmMgLSBUaGUgdHJlZSBpdGVtIHRvIGNvcHkgZnJvbS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvcHlGcm9tKHNyYywgY29udGV4dCkgew0KICAgICAgICAgICAgc3VwZXIuY29weUZyb20oc3JjLCBjb250ZXh0KTsNCiAgICAgICAgICAgIC8vIE5vdGU6IGNvbmZpZ3VyZSB2aXNpYmxpdHkgYW5kIG9wYWNpdHkgYmVmb3JlIGFkZGluZyBjaGlsZHJlbi4gVGhleSB3aWxsDQogICAgICAgICAgICAvLyBpbmhlcml0IHRoZXNlIHNldHRpbmdzIGFzIHRoZXkgYXJlIGFkZGVkLg0KICAgICAgICAgICAgdGhpcy52aXNpYmxlQ291bnRlciA9IHRoaXMudmlzaWJsZVBhcmFtLnZhbHVlID8gMSA6IDA7DQogICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTsNCiAgICAgICAgICAgIHRoaXMudXBkYXRlT3BhY2l0eSgpOw0KICAgICAgICAgICAgLy8gTm90ZTogSWYgYSB0cmVlIGl0ZW0gYWxyZWFkeSBoYWQgY2hpbGRyZW4sIHdlIG11c3QgY2xlYXIgdGhlbSBiZWZvcmUgYWRkaW5nIGZyb20gdGhlIHNyYy4NCiAgICAgICAgICAgIC8vIEFuIFhSZWYgc3RvcmVkIGluIGFuIGFzc2VtYmx5IG1heSBjb250YWluIGEgY2FjaGUgb2YgaXRzIHN1YnRyZWUuDQogICAgICAgICAgICAvLyBJZiB0aGUgWFJlZiB1cmwgZG9lcyByZXNvbHZlIHRvIGEgZmlsZSwgd2UgbXVzdCBjbGVhciB0aGlzIGNhY2hlIGJlZm9yZSBsb2FkaW5nIHRoZSBhY3R1YWwgZGF0YS4NCiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsQ2hpbGRyZW4oKTsNCiAgICAgICAgICAgIHNyYy5nZXRDaGlsZHJlbigpLmZvckVhY2goKHNyY0NoaWxkSXRlbSkgPT4gew0KICAgICAgICAgICAgICAgIGlmIChzcmNDaGlsZEl0ZW0pDQogICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoc3JjQ2hpbGRJdGVtLmNsb25lKGNvbnRleHQpLCBmYWxzZSwgZmFsc2UpOw0KICAgICAgICAgICAgfSk7DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1RyZWVJdGVtJywgVHJlZUl0ZW0pOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi8NCiAgICAvKioNCiAgICAgKiBSZXByZXNlbnRzIGEgc3BlY2lmaWMgdHlwZSBvZiBwYXJhbWV0ZXIsIHRoYXQgb25seSBzdG9yZXMgYFRyZWVJdGVtYCB2YWx1ZXMuDQogICAgICoNCiAgICAgKiBpLmUuOg0KICAgICAqIGBgYGphdmFzY3JpcHQNCiAgICAgKiBjb25zdCB0cmVlSXRlbSA9IG5ldyBUcmVlSXRlbSgndHJlZTEnKQ0KICAgICAqIGNvbnN0IHRyZWVJdGVtUGFyYW0gPSBuZXcgVHJlZUl0ZW1QYXJhbWV0ZXIoJ015VHJlZUl0ZW0nLCB0cmVlSXRlbSkNCiAgICAgKiAvLydteVBhcmFtZXRlck93bmVySXRlbScgaXMgYW4gaW5zdGFuY2Ugb2YgYSAnUGFyYW1ldGVyT3duZXInIGNsYXNzLg0KICAgICAqIC8vIFJlbWVtYmVyIHRoYXQgb25seSAnUGFyYW1ldGVyT3duZXInIGFuZCBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gaXQgY2FuIGhvc3QgJ1BhcmFtZXRlcicgb2JqZWN0cy4NCiAgICAgKiBteVBhcmFtZXRlck93bmVySXRlbS5hZGRQYXJhbWV0ZXIodHJlZUl0ZW1QYXJhbSkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqICoqRXZlbnRzKioNCiAgICAgKiAqICoqdHJlZUl0ZW1HbG9iYWxYZm9DaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIGNvbXB1dGVkIHdvcmxkIFhmbyBvZiBwYXJhbWV0ZXIncyBgVHJlZUl0ZW1gIGNoYW5nZXMuDQogICAgICogKiAqKnZhbHVlQ2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiBwYXJhbWV0ZXIncyB2YWx1ZSBjaGFuZ2VzLg0KICAgICAqDQogICAgICogQGV4dGVuZHMgUGFyYW1ldGVyDQogICAgICovDQogICAgY2xhc3MgVHJlZUl0ZW1QYXJhbWV0ZXIgZXh0ZW5kcyBQYXJhbWV0ZXIgew0KICAgICAgICBmaWx0ZXJGbjsNCiAgICAgICAgb3duZXI7DQogICAgICAgIGxpc3RlbmVySURzID0ge307DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSB0cmVlIGl0ZW0gcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0cmVlIGl0ZW0gcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gZmlsdGVyRm4gLSBUaGUgZmlsdGVyRm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihuYW1lID0gJycsIGZpbHRlckZuKSB7DQogICAgICAgICAgICBzdXBlcihuYW1lLCBudWxsLCAnVHJlZUl0ZW0nKTsNCiAgICAgICAgICAgIHRoaXMub3duZXIgPSBuZXcgVHJlZUl0ZW0oJycpOyAvLyBUT0RPOihyZXZpZXcpIHNob3VsZCB0aGlzIGJlIGluaXRpYWxpemUgYnkgYXJndW1lbnRzIG9yIGlzIHRoaXMgb2s/DQogICAgICAgICAgICB0aGlzLmZpbHRlckZuID0gZmlsdGVyRm47DQogICAgICAgIH0NCiAgICAgICAgZW1pdFRyZWVJdGVtR2xvYmFsWGZvQ2hhbmdlZChldmVudCkgew0KICAgICAgICAgICAgdGhpcy5lbWl0KCd0cmVlSXRlbUdsb2JhbFhmb0NoYW5nZWQnLCBldmVudCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgcGFyYW1ldGVyIHZhbHVlJ3Mgb3duZXIgYFRyZWVJdGVtYC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG93bmVyIC0gVGhlIG93bmVyIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0T3duZXIob3duZXIpIHsNCiAgICAgICAgICAgIHRoaXMub3duZXIgPSBvd25lcjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBwYXJhbWV0ZXIgdmFsdWUncyBvd25lciBgVHJlZUl0ZW1gLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldE93bmVyKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMub3duZXI7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRGaWx0ZXJGbiBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBmaWx0ZXJGbiAtIFRoZSBmaWx0ZXJGbiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZpbHRlckZuKGZpbHRlckZuKSB7DQogICAgICAgICAgICB0aGlzLmZpbHRlckZuID0gZmlsdGVyRm47DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRGaWx0ZXJGbiBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RmlsdGVyRm4oKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJGbjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBwYXJhbWV0ZXIncyBgVHJlZUl0ZW1gIHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdHJlZUl0ZW0gdmFsdWUNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkgew0KICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBUcmVlSXRlbSkpIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBhICdUcmVlSXRlbScgY2xhc3MuIENoZWNrIHRoZSBzb3VyY2Ugb2YgdGhpcyB2YWx1ZWApOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gMCA9PSBub3JtYWwgc2V0LiAxID0gY2hhbmdlZCB2aWEgY2xlYW5lciBmbiwgMj1jaGFuZ2UgYnkgbG9hZGluZy9jbG9uaW5nIGNvZGUuDQogICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJGbiAmJiAhdGhpcy5maWx0ZXJGbih2YWx1ZSkpDQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgaWYgKHRoaXMuX192YWx1ZSAhPT0gdmFsdWUpIHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZS5vZmYoJ2dsb2JhbFhmb0NoYW5nZWQnLCB0aGlzLmxpc3RlbmVySURzWydnbG9iYWxYZm9DaGFuZ2VkJ10pOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZTsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3ZhbHVlKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJJRHNbJ2dsb2JhbFhmb0NoYW5nZWQnXSA9IHRoaXMuX192YWx1ZS5vbignZ2xvYmFsWGZvQ2hhbmdlZCcsIChldmVudCkgPT4gew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0VHJlZUl0ZW1HbG9iYWxYZm9DaGFuZ2VkKGV2ZW50KTsNCiAgICAgICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksDQogICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLA0KICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0Lm1ha2VSZWxhdGl2ZSh0aGlzLl9fdmFsdWU/LmdldFBhdGgoKSksDQogICAgICAgICAgICB9Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBpZiAoai52YWx1ZSA9PSBudWxsKSB7DQogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIFBhcmFtZXRlciBKU09OJyk7DQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29udGV4dC5yZXNvbHZlUGF0aChqLnZhbHVlLCAodHJlZUl0ZW0pID0+IHsNCiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRyZWVJdGVtKTsNCiAgICAgICAgICAgIH0sICgpID0+IHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byByZXNvbHZlIHRyZWUgaXRlbSBwYXJhbWV0ZXIgdmFsdWU6JyArIGoucGFyYW1QYXRoKTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gQ2xvbmUgYW5kIERlc3Ryb3kNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIG5ldyB0cmVlIGl0ZW0gcGFyYW1ldGVyLCBjb3BpZXMgaXRzIHZhbHVlcw0KICAgICAgICAgKiBmcm9tIHRoaXMgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyB0cmVlIGl0ZW0gcGFyYW1ldGVyLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xvbmUoY29udGV4dCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgVHJlZUl0ZW1QYXJhbWV0ZXIodGhpcy5uYW1lLCB0aGlzLmZpbHRlckZuKTsNCiAgICAgICAgICAgIGlmICh0aGlzLl9fdmFsdWUpDQogICAgICAgICAgICAgICAgY2xvbmVkUGFyYW0uc2V0VmFsdWUodGhpcy5fX3ZhbHVlLmNsb25lKGNvbnRleHQpKTsNCiAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYXJhbTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignVHJlZUl0ZW1QYXJhbWV0ZXInLCBUcmVlSXRlbVBhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIGNsYXNzIEl0ZW1FdmVudCBleHRlbmRzIEJhc2VFdmVudCB7DQogICAgICAgIGl0ZW07DQogICAgICAgIGluZGV4Ow0KICAgICAgICBjb25zdHJ1Y3RvcihpdGVtLCBpbmRleCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDsNCiAgICAgICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07DQogICAgICAgIH0NCiAgICB9DQogICAgLyoqIENsYXNzIHJlcHJlc2VudGluZyBhbiBpdGVtIHNldCBwYXJhbWV0ZXIuDQogICAgICogQGV4dGVuZHMgUGFyYW1ldGVyDQogICAgICogQHByaXZhdGUNCiAgICAgKi8NCiAgICBjbGFzcyBJdGVtU2V0UGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyIHsNCiAgICAgICAgZmlsdGVyRm47DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYW4gaXRlbSBzZXQgcGFyYW1ldGVyLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBpdGVtIHNldCBwYXJhbWV0ZXIuDQogICAgICAgICAqIEBwYXJhbSBmaWx0ZXJGbiAtIFRoZSBmaWx0ZXJGbiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUgPSAnJywgZmlsdGVyRm4pIHsNCiAgICAgICAgICAgIHN1cGVyKG5hbWUsIG5ldyBTZXQoKSwgJ1RyZWVJdGVtJyk7DQogICAgICAgICAgICB0aGlzLmZpbHRlckZuID0gZmlsdGVyRm47IC8vIE5vdGU6IHRoZSBmaWx0ZXIgRm4gaW5kaWNhdGVzIHRoYXQgdXNlcnMgd2lsbCBlZGl0IHRoZSBzZXQuDQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRGaWx0ZXJGbiBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBmaWx0ZXJGbiAtIFRoZSBmaWx0ZXJGbiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZpbHRlckZuKGZpbHRlckZuKSB7DQogICAgICAgICAgICB0aGlzLmZpbHRlckZuID0gZmlsdGVyRm47DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRGaWx0ZXJGbiBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RmlsdGVyRm4oKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJGbjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldEl0ZW0gbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggcGFyYW0uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0SXRlbShpbmRleCkgew0KICAgICAgICAgICAgLy8gaWYgKCF0aGlzLl9faXRlbXMpIHJldHVybiB1bmRlZmluZWQNCiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX192YWx1ZSlbaW5kZXhdOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgYWRkSXRlbSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBpdGVtIC0gVGhlIGl0ZW0gdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBlbWl0VmFsdWVDaGFuZ2VkIC0gVGhlIGVtaXQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgYWRkSXRlbShpdGVtLCBlbWl0VmFsdWVDaGFuZ2VkID0gdHJ1ZSkgew0KICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyRm4gJiYgIXRoaXMuZmlsdGVyRm4oaXRlbSkpIHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0ZW1TZXQgX19maWx0ZXJGbiByZWplY3RpbmcgaXRlbTonLCBpdGVtLmdldFBhdGgoKSk7DQogICAgICAgICAgICAgICAgcmV0dXJuOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUuaGFzKGl0ZW0pKSB7DQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlLmFkZChpdGVtKTsNCiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmZyb20odGhpcy5fX3ZhbHVlKS5pbmRleE9mKGl0ZW0pOw0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbUFkZGVkJywgbmV3IEl0ZW1FdmVudChpdGVtLCBpbmRleCkpOw0KICAgICAgICAgICAgICAgIGlmIChlbWl0VmFsdWVDaGFuZ2VkKQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHJldHVybiAtMTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBpdGVtcyB0byB0aGUgcGFyYW1ldGVyIHZhbHVlDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpdGVtcyAtIGxpc3Qgb2YgaXRlbXMgdG8gYWRkIHRvIHRoZSBwYXJhbWV0ZXINCiAgICAgICAgICogQHBhcmFtIGVtaXRWYWx1ZUNoYW5nZWQNCiAgICAgICAgICogQG1lbWJlcm9mIEl0ZW1TZXRQYXJhbWV0ZXINCiAgICAgICAgICovDQogICAgICAgIGFkZEl0ZW1zKGl0ZW1zLCBlbWl0VmFsdWVDaGFuZ2VkID0gdHJ1ZSkgew0KICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gdGhpcy5hZGRJdGVtKGl0ZW0sIGZhbHNlKSk7DQogICAgICAgICAgICBpZiAoZW1pdFZhbHVlQ2hhbmdlZCkNCiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgcmVtb3ZlSXRlbSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIGVtaXRWYWx1ZUNoYW5nZWQgLSBUaGUgZW1pdCBwYXJhbS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZW1vdmVJdGVtKGluZGV4LCBlbWl0VmFsdWVDaGFuZ2VkID0gdHJ1ZSkgew0KICAgICAgICAgICAgY29uc3QgaXRlbSA9IEFycmF5LmZyb20odGhpcy5fX3ZhbHVlKVtpbmRleF07DQogICAgICAgICAgICB0aGlzLl9fdmFsdWUuZGVsZXRlKGl0ZW0pOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdpdGVtUmVtb3ZlZCcsIG5ldyBJdGVtRXZlbnQoaXRlbSwgaW5kZXgpKTsNCiAgICAgICAgICAgIGlmIChlbWl0VmFsdWVDaGFuZ2VkKQ0KICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmFsdWVDaGFuZ2VkJyk7DQogICAgICAgICAgICByZXR1cm4gaXRlbTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHNldEl0ZW1zIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGl0ZW0gcGFyYW0uDQogICAgICAgICAqIEBwYXJhbSBlbWl0IC0gVGhlIGVtaXQgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICBzZXRJdGVtcyhpdGVtcywgZW1pdCA9IHRydWUpIHsNCiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5fX3ZhbHVlKTsNCiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsNCiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVzW2ldOw0KICAgICAgICAgICAgICAgIGlmICghaXRlbXMuaGFzKGl0ZW0pKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSXRlbShpLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7DQogICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUuaGFzKGl0ZW0pKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbShpdGVtLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgaWYgKGVtaXQpDQogICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd2YWx1ZUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsZWFySXRlbXMgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gZW1pdCAtIFRoZSBlbWl0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgY2xlYXJJdGVtcyhlbWl0VmFsdWVDaGFuZ2VkID0gdHJ1ZSkgew0KICAgICAgICAgICAgdGhpcy5fX3ZhbHVlLmNsZWFyKCk7DQogICAgICAgICAgICBpZiAoZW1pdFZhbHVlQ2hhbmdlZCkNCiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3ZhbHVlQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2V0TnVtSXRlbXMgbWV0aG9kLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldE51bUl0ZW1zKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX192YWx1ZS5zaXplOyAvLyBtaWdodCBiZSBmYXN0ZXINCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICB0b0pTT04oY29udGV4dCkgew0KICAgICAgICAgICAgaWYgKCF0aGlzLl9fdmFsdWUpDQogICAgICAgICAgICAgICAgdGhpcy5fX3ZhbHVlID0gbmV3IFNldCgpOw0KICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBbXTsNCiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9fdmFsdWUpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gaXRlbS5nZXRQYXRoKCk7DQogICAgICAgICAgICAgICAgcGF0aHMucHVzaChjb250ZXh0ICYmIGNvbnRleHQubWFrZVJlbGF0aXZlID8gY29udGV4dC5tYWtlUmVsYXRpdmUocGF0aCkgOiBwYXRoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRDbGFzc05hbWUoKSwNCiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsDQogICAgICAgICAgICAgICAgdmFsdWU6IHBhdGhzLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4NCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QgdGhpcyBpdGVtIG11c3QgZGVjb2RlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZnJvbUpTT04oaiwgY29udGV4dCkgew0KICAgICAgICAgICAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LnJlc29sdmVQYXRoKSB7DQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBKU09OIG9uIGEgSXRlbVNldFBhcmFtZXRlciB3aXRob3V0IGEgbG9hZCBjb250ZXh0Jyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBwYXRocyA9IGoudmFsdWU7DQogICAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7DQogICAgICAgICAgICAgICAgY29udGV4dC5yZXNvbHZlUGF0aChwYXRoLCAodHJlZUl0ZW0pID0+IHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtKHRyZWVJdGVtLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgfSwgKCkgPT4gew0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIkJhc2VHcm91cDogJyIgKyB0aGlzLmdldE5hbWUoKSArICInLiBVbmFibGUgdG8gbG9hZCBpdGVtOiIgKyBwYXRoKTsNCiAgICAgICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gQ2xvbmUNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbG9uZSBtZXRob2QgY29uc3RydWN0cyBhIGl0ZW0gc2V0IG5ldyBwYXJhbWV0ZXIsIGNvcGllcyBpdHMgdmFsdWVzDQogICAgICAgICAqIGZyb20gdGhpcyBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGl0ZW0gc2V0IHBhcmFtZXRlci4NCiAgICAgICAgICovDQogICAgICAgIGNsb25lKCkgew0KICAgICAgICAgICAgY29uc3QgY2xvbmVkUGFyYW0gPSBuZXcgSXRlbVNldFBhcmFtZXRlcih0aGlzLm5hbWUsIHRoaXMuZmlsdGVyRm4pOw0KICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhcmFtOw0KICAgICAgICB9DQogICAgfQ0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdJdGVtU2V0UGFyYW1ldGVyJywgSXRlbVNldFBhcmFtZXRlcik7CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLw0KICAgIGNvbnN0IHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgcG9zaXRpb25zX3F1YW50aXplZCwgcG9zaXRpb25zQXR0cikgPT4gew0KICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VbMF07IGkgPCByYW5nZVsxXTsgaSsrKSB7DQogICAgICAgICAgICBjb25zdCBwb3MgPSBuZXcgVmVjMyhwb3NpdGlvbnNfcXVhbnRpemVkW2kgKiAzICsgMF0gLyAyNTUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDFdIC8gMjU1LjAsIHBvc2l0aW9uc19xdWFudGl6ZWRbaSAqIDMgKyAyXSAvIDI1NS4wKTsNCiAgICAgICAgICAgIHBvcy5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKTsNCiAgICAgICAgICAgIHBvcy5hZGRJblBsYWNlKG9mZnNldCk7DQogICAgICAgICAgICBwb3NpdGlvbnNBdHRyLnNldFZhbHVlKGksIHBvcyk7DQogICAgICAgIH0NCiAgICB9Ow0KICAgIGNvbnN0IHBhcnNlMTZCaXRQb3NpdGlvbnNBcnJheSA9IChyYW5nZSwgb2Zmc2V0LCBzY2xWZWMsIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpID0+IHsNCiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlWzBdOyBpIDwgcmFuZ2VbMV07IGkrKykgew0KICAgICAgICAgICAgY29uc3QgcG9zID0gbmV3IFZlYzMocG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDBdIC8gNjU1MzUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDFdIC8gNjU1MzUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDJdIC8gNjU1MzUuMCk7DQogICAgICAgICAgICBwb3MubXVsdGlwbHlJblBsYWNlKHNjbFZlYyk7DQogICAgICAgICAgICBwb3MuYWRkSW5QbGFjZShvZmZzZXQpOw0KICAgICAgICAgICAgcG9zaXRpb25zQXR0ci5zZXRWYWx1ZShpLCBwb3MpOw0KICAgICAgICB9DQogICAgfTsNCiAgICBjb25zdCBwYXJzZThCaXROb3JtYWxzQXJyYXkgPSAocmFuZ2UsIG9mZnNldCwgc2NsVmVjLCBub3JtYWxzX3F1YW50aXplZCwgbm9ybWFsc0F0dHIpID0+IHsNCiAgICAgICAgaWYgKHNjbFZlYy5pc051bGwoKSkNCiAgICAgICAgICAgIHNjbFZlYy5zZXQoMSwgMSwgMSk7DQogICAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsNCiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWMzKG5vcm1hbHNfcXVhbnRpemVkW2kgKiAzICsgMF0gLyAyNTUuMCwgbm9ybWFsc19xdWFudGl6ZWRbaSAqIDMgKyAxXSAvIDI1NS4wLCBub3JtYWxzX3F1YW50aXplZFtpICogMyArIDJdIC8gMjU1LjApOw0KICAgICAgICAgICAgbm9ybWFsLm11bHRpcGx5SW5QbGFjZShzY2xWZWMpOw0KICAgICAgICAgICAgbm9ybWFsLmFkZEluUGxhY2Uob2Zmc2V0KTsNCiAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemVJblBsYWNlKCk7DQogICAgICAgICAgICBub3JtYWxzQXR0ci5zZXRWYWx1ZShpLCBub3JtYWwpOw0KICAgICAgICB9DQogICAgfTsNCiAgICBjb25zdCBwYXJzZThCaXRUZXh0dXJlQ29vcmRzQXJyYXkgPSAocmFuZ2UsIG9mZnNldCwgc2NsVmVjLCB0ZXhDb29yZHNfcXVhbnRpemVkLCB0ZXhDb29yZHNBdHRyKSA9PiB7DQogICAgICAgIC8vIGlmIChzY2xWZWMuaXNOdWxsKCkpDQogICAgICAgIC8vICAgICBzY2xWZWMuc2V0KDEsIDEsIDEpOw0KICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VbMF07IGkgPCByYW5nZVsxXTsgaSsrKSB7DQogICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmQgPSBuZXcgVmVjMih0ZXhDb29yZHNfcXVhbnRpemVkW2kgKiAyICsgMF0gLyAyNTUuMCwgdGV4Q29vcmRzX3F1YW50aXplZFtpICogMiArIDFdIC8gMjU1LjApOw0KICAgICAgICAgICAgdGV4dHVyZUNvb3JkLm11bHRpcGx5SW5QbGFjZShzY2xWZWMpOw0KICAgICAgICAgICAgdGV4dHVyZUNvb3JkLmFkZEluUGxhY2Uob2Zmc2V0KTsNCiAgICAgICAgICAgIHRleENvb3Jkc0F0dHIuc2V0VmFsdWUoaSwgdGV4dHVyZUNvb3JkKTsNCiAgICAgICAgfQ0KICAgIH07DQogICAgY29uc3QgcGFyc2UxNkJpdFRleHR1cmVDb29yZHNBcnJheSA9IChyYW5nZSwgb2Zmc2V0LCBzY2xWZWMsIHRleENvb3Jkc19xdWFudGl6ZWQsIHRleENvb3Jkc0F0dHIpID0+IHsNCiAgICAgICAgLy8gaWYgKHNjbFZlYy5pc051bGwoKSkNCiAgICAgICAgLy8gICAgIHNjbFZlYy5zZXQoMSwgMSwgMSk7DQogICAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsNCiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVDb29yZCA9IG5ldyBWZWMyKHRleENvb3Jkc19xdWFudGl6ZWRbaSAqIDIgKyAwXSAvIDY1NTM1LjAsIHRleENvb3Jkc19xdWFudGl6ZWRbaSAqIDIgKyAxXSAvIDY1NTM1LjApOw0KICAgICAgICAgICAgdGV4dHVyZUNvb3JkLm11bHRpcGx5SW5QbGFjZShzY2xWZWMpOw0KICAgICAgICAgICAgdGV4dHVyZUNvb3JkLmFkZEluUGxhY2Uob2Zmc2V0KTsNCiAgICAgICAgICAgIHRleENvb3Jkc0F0dHIuc2V0VmFsdWUoaSwgdGV4dHVyZUNvb3JkKTsNCiAgICAgICAgfQ0KICAgIH07DQogICAgLyoqDQogICAgICogUmVwcmVzZW50cyBhIGJhc2UgY2xhc3MgZm9yIDNEIGdlb21ldHJ5IGl0ZW1zLg0KICAgICAqDQogICAgICogKipFdmVudHMqKg0KICAgICAqICogKipib3VuZGluZ0JveENoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCBjaGFuZ2VzLg0KICAgICAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogRW1pdHRlZCB3aGVuIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZC4gVGhlIHRvcG9sb2d5IGRpZCBub3QgY2hhbmdlLiBUaGUgUmVuZGVyZXIgd2lsbCB1cGxvYWQgdGhlIG5ldyBhdHRyaWJ1dGVzIHRvIHRoZSBHUFUuDQogICAgICogKiAqKmdlb21EYXRhVG9wb2xvZ3lDaGFuZ2VkOioqIEVtaXR0ZWQgd2hlbiB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlcyBhbmQgdG9wb2xvZ3kgaGF2ZSBjaGFuZ2VkLiAgVGhlIFJlbmRlcmVyIHdpbGwgdXBsb2FkIHRoZSBuZXcgYXR0cmlidXRlcyBhbmQgdG9wb2xvZ3kgdG8gdGhlIEdQVS4NCiAgICAgKg0KICAgICAqIEBleHRlbmRzIFBhcmFtZXRlck93bmVyDQogICAgICovDQogICAgY2xhc3MgQmFzZUdlb20gZXh0ZW5kcyBQYXJhbWV0ZXJPd25lciB7DQogICAgICAgIGJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTsNCiAgICAgICAgYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7DQogICAgICAgIF9fbWV0YURhdGEgPSBuZXcgTWFwKCk7DQogICAgICAgICNudW1WZXJ0aWNlcyA9IDA7DQogICAgICAgIF9fdmVydGV4QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsNCiAgICAgICAgZGVidWdDb2xvciA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZSBhIGJhc2UgZ2VvbS4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnLCBuZXcgVmVjM2YxNkF0dHJpYnV0ZSgpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwYXRoIG9mIHRoZSBpdGVtIGluIHRoZSB0cmVlIGFzIGFuIGFycmF5IG9mIG5hbWVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhbiBhcnJheS4NCiAgICAgICAgICovDQogICAgICAgIGdldFBhdGgoKSB7DQogICAgICAgICAgICBpZiAodGhpcy5fX293bmVySXRlbSA9PSB1bmRlZmluZWQpDQogICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl9fbmFtZV07DQogICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fb3duZXJJdGVtIGluc3RhbmNlb2YgUGFyYW1ldGVyKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9fb3duZXJJdGVtLmdldFBhdGgoKSwgJ3ZhbHVlJ107DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuX19vd25lckl0ZW0uZ2V0UGF0aCgpLCB0aGlzLl9fbmFtZV07DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbGVhciBtZXRob2QuDQogICAgICAgICAqLw0KICAgICAgICBjbGVhcigpIHsNCiAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMoMCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgYSBuZXcgdmVydGV4IGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnkuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuDQogICAgICAgICAqIEBwYXJhbSBkYXRhVHlwZSAtIFRoZSBkYXRhVHlwZSB2YWx1ZS4gLy8gVE9ETzogaXMgYW55IG9rIHZzLiBBdHRyVmFsdWUgfCBudW1iZXIuIFVuc3VyZSBhYm91dCBob3cgZGF0YVR5cGUgaXMgdXNlZA0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhbiBhdHRyaWJ1dGUuDQogICAgICAgICAqLw0KICAgICAgICBhZGRWZXJ0ZXhBdHRyaWJ1dGUobmFtZSwgYXR0cikgew0KICAgICAgICAgICAgYXR0ci5zZXRDb3VudCh0aGlzLiNudW1WZXJ0aWNlcyk7DQogICAgICAgICAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENoZWNrcyBpZiB0aGUgdGhlIGdlb21ldHJ5IGhhcyBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgaGFzVmVydGV4QXR0cmlidXRlKG5hbWUpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5oYXMobmFtZSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdmVydGV4IGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRWZXJ0ZXhBdHRyaWJ1dGUobmFtZSkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldChuYW1lKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhbGwgdmVydGV4IGF0dHJpYnV0ZXMgaW4gYW4gb2JqZWN0IHdpdGggdGhlaXIgbmFtZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0VmVydGV4QXR0cmlidXRlcygpIHsNCiAgICAgICAgICAgIGNvbnN0IHZlcnRleEF0dHJpYnV0ZXMgPSB7fTsNCiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKQ0KICAgICAgICAgICAgICAgIHZlcnRleEF0dHJpYnV0ZXNba2V5XSA9IGF0dHI7DQogICAgICAgICAgICByZXR1cm4gdmVydGV4QXR0cmlidXRlczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyAncG9zaXRpb25zJyB2ZXJ0ZXggYXR0cmlidXRlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IHBvc2l0aW9ucygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5nZXQoJ3Bvc2l0aW9ucycpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGV4IGF0dHJpYnV0ZXMuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbnVtVmVydGljZXMoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy4jbnVtVmVydGljZXM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2ZXJ0ZXggYXR0cmlidXRlcy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXROdW1WZXJ0aWNlcygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLiNudW1WZXJ0aWNlczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoZSBnZW9tZXRyeSBoYXMuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBjb3VudCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldE51bVZlcnRpY2VzKGNvdW50KSB7DQogICAgICAgICAgICB0aGlzLiNudW1WZXJ0aWNlcyA9IGNvdW50Ow0KICAgICAgICAgICAgLy8gUmVzaXplcyBlYWNoIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlcyB0byBtYXRjaCB0aGUgbmV3IGNvdW50Lg0KICAgICAgICAgICAgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4gYXR0ci5zZXRDb3VudCh0aGlzLiNudW1WZXJ0aWNlcykpOw0KICAgICAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBCb3VuZGluZ0JveA0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBnZW9tZXRyeS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRCb3VuZGluZ0JveCgpIHsNCiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94RGlydHkpDQogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpOw0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRCb3VuZGluZ0JveERpcnR5IG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIHNldEJvdW5kaW5nQm94RGlydHkoKSB7DQogICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSB0cnVlOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdib3VuZGluZ0JveENoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHVwZGF0ZUJvdW5kaW5nQm94IG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KCkgew0KICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7DQogICAgICAgICAgICBjb25zdCBiYm94ID0gbmV3IEJveDMoKTsNCiAgICAgICAgICAgIGlmIChwb3NpdGlvbnMpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBudW1WZXJ0cyA9IHBvc2l0aW9ucy5nZXRDb3VudCgpOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykNCiAgICAgICAgICAgICAgICAgICAgYmJveC5hZGRQb2ludChwb3NpdGlvbnMuZ2V0VmFsdWUoaSkpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJib3g7DQogICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSBmYWxzZTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTWVyZ2VzIGEgc2VwYXJhdGUgZ2VvbWV0cnkgaW50byB0aGlzIG9uZS4gU2ltaWxhciB0byBhICd1bmlvbicgYm9vbGVhbiBvcGVyYXRpb24uDQogICAgICAgICAqIEBwYXJhbSBvdGhlciB0aGUgb3RoZXIgZ2VvbSB0aGF0IHdpbGwgYmUgbWVyZ2VkIGludG8gdGhpcyBvbmUNCiAgICAgICAgICogQHBhcmFtIHhmbyB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYmUgYXBwbGllZCB0byB0aGUgb3RoZXIgZ2VvbSBhcyBpdCBpcyBtZXJnZWQgaW4uDQogICAgICAgICAqLw0KICAgICAgICBtZXJnZShvdGhlciwgeGZvID0gbmV3IFhmbygpKSB7DQogICAgICAgICAgICBjb25zdCBwcmV2TnVtVmVydHMgPSB0aGlzLmdldE51bVZlcnRpY2VzKCk7DQogICAgICAgICAgICBjb25zdCBhZGRlZFZlcnRzID0gb3RoZXIuZ2V0TnVtVmVydGljZXMoKTsNCiAgICAgICAgICAgIGZvciAoY29uc3QgW2F0dHJOYW1lLCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykgew0KICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQXR0ciA9IG90aGVyLmdldFZlcnRleEF0dHJpYnV0ZShhdHRyTmFtZSk7DQogICAgICAgICAgICAgICAgaWYgKG90aGVyQXR0cikgew0KICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT0gJ3Bvc2l0aW9ucycpDQogICAgICAgICAgICAgICAgICAgICAgICBhdHRyLm1lcmdlKG90aGVyQXR0ciwgeGZvKTsNCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ck5hbWUgPT0gJ25vcm1hbHMnKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5tZXJnZShvdGhlckF0dHIsIG5ldyBYZm8obmV3IFZlYzMoKSwgeGZvLm9yaSkpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIE5vdGU6IGFsbCB0aGUgYXR0cmlidXRlcyBoYXZlIGFscmVhZHkgYmVlbiByZXNpemVkLCBzbw0KICAgICAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgZmluYWwgY2hlY2suDQogICAgICAgICAgICB0aGlzLnNldE51bVZlcnRpY2VzKHByZXZOdW1WZXJ0cyArIGFkZGVkVmVydHMpOw0KICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gTWV0YWRhdGENCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgbWV0YWRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBuYW1lLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRNZXRhZGF0YShrZXkpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGEuZ2V0KGtleSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFZlcmlmaWVzIGlmIGdlb21ldHJ5J3MgbWV0YWRhdGEgY29udGFpbnMgYSB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBoYXNNZXRhZGF0YShrZXkpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGEuaGFzKGtleSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgbWV0YWRhdGEgdmFsdWUgdG8gdGhlIGdlb21ldHJ5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIG1ldGFEYXRhIC0gVGhlIG1ldGFEYXRhIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0TWV0YWRhdGEoa2V5LCBtZXRhRGF0YSkgew0KICAgICAgICAgICAgdGhpcy5fX21ldGFEYXRhLnNldChrZXksIG1ldGFEYXRhKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmVtb3ZlcyBtZXRhZGF0YSB2YWx1ZSBmcm9tIHRoZSBnZW9tZXRyeSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGRlbGV0ZU1ldGFkYXRhKGtleSkgew0KICAgICAgICAgICAgdGhpcy5fX21ldGFEYXRhLmRlbGV0ZShrZXkpOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gTWVtb3J5DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHZlcnRleCBhdHRyaWJ1dGVzIGJ1ZmZlcnMgYW5kIGl0cyBjb3VudC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZW5CdWZmZXJzKG9wdHMpIHsNCiAgICAgICAgICAgIGNvbnN0IGF0dHJCdWZmZXJzID0ge307DQogICAgICAgICAgICBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgICAgICAgICAgICBhdHRyQnVmZmVyc1thdHRyTmFtZV0gPSBhdHRyLmdlbkJ1ZmZlcigpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICAgICBudW1WZXJ0aWNlczogdGhpcy5udW1WZXJ0aWNlcygpLA0KICAgICAgICAgICAgICAgIGF0dHJCdWZmZXJzLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogT25jZSB0aGUgYnVmZmVycyBoYXZlIGJlZW4gdXBsb2FkZWQgdG8gdGhlIEdQVSwgd2UgYXJlIGZyZWUgdG8gcmVsZWFzZSB0aGVtLg0KICAgICAgICAgKiBUaGUgR0xHZW9tTGlicmFyeSBtYXkgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGxldCB0aGUgZ2VvbWV0cnkga25vdyBpdCBjYW4gcmVsZWFzZSBhbnkgaGFuZGxlcy4NCiAgICAgICAgICovDQogICAgICAgIGZyZWVCdWZmZXJzKCkgeyB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBHZW9tZXRyeShJbmNsdWRpbmcgVmVydGljZXMgYW5kIEJvdW5kaW5nIEJveCkgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7DQogICAgICAgICAgICB0aGlzLm5hbWUgPSByZWFkZXIubG9hZFN0cigpOw0KICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSByZWFkZXIubG9hZFVJbnQ4KCk7DQogICAgICAgICAgICB0aGlzLmRlYnVnQ29sb3IgPSByZWFkZXIubG9hZFJHQkZsb2F0MzJDb2xvcigpOw0KICAgICAgICAgICAgY29uc3QgbnVtVmVydHMgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXQocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpOw0KICAgICAgICAgICAgbGV0IG5vcm1hbHNBdHRyOw0KICAgICAgICAgICAgbGV0IHRleENvb3Jkc0F0dHI7DQogICAgICAgICAgICBpZiAoZmxhZ3MgJiAoMSA8PCAxKSkgew0KICAgICAgICAgICAgICAgIG5vcm1hbHNBdHRyID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKTsNCiAgICAgICAgICAgICAgICBpZiAoIW5vcm1hbHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIG5vcm1hbHNBdHRyID0gbmV3IFZlYzNmOEF0dHJpYnV0ZSgpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgnbm9ybWFscycsIG5vcm1hbHNBdHRyKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoZmxhZ3MgJiAoMSA8PCAyKSkgew0KICAgICAgICAgICAgICAgIHRleENvb3Jkc0F0dHIgPSB0aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgndGV4Q29vcmRzJyk7DQogICAgICAgICAgICAgICAgaWYgKCF0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIHRleENvb3Jkc0F0dHIgPSBuZXcgVmVjMmYxNkF0dHJpYnV0ZSgpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgndGV4Q29vcmRzJywgdGV4Q29vcmRzQXR0cik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgbnVtQ2x1c3RlcnMgPSByZWFkZXIubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgaWYgKG51bUNsdXN0ZXJzID09IDApIHsNCiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbnNBdHRyID0gdGhpcy5wb3NpdGlvbnM7DQogICAgICAgICAgICAgICAgLy8gRnJvbSAzLjEyLjAsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uDQogICAgICAgICAgICAgICAgLy8gd2l0aG91dCBhbnkgay1tZWFucyBjbHVzdGVyaW5nLg0KICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUNCiAgICAgICAgICAgICAgICBwb3NpdGlvbnNBdHRyLmRhdGEgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KG51bVZlcnRzICogMyk7DQogICAgICAgICAgICAgICAgaWYgKG5vcm1hbHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUNCiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIuZGF0YSA9IHJlYWRlci5sb2FkSW50OEFycmF5KG51bVZlcnRzICogMyk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUNCiAgICAgICAgICAgICAgICAgICAgdGV4Q29vcmRzQXR0ci5kYXRhID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheShudW1WZXJ0cyAqIDIpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhIG5vLW9wIGluIGVhY2ggb2YgdGhlIGF0dHJpYnV0ZXMgYXMgdGhleSBhbHJlYWR5IGhhdmUNCiAgICAgICAgICAgICAgICAvLyBhcnJheXMgb2YgdGhlIGFwcHJvcHJpYXRlIHNpemUuLg0KICAgICAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMobnVtVmVydHMpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSBpZiAobnVtQ2x1c3RlcnMgPT0gMSkgew0KICAgICAgICAgICAgICAgIC8vIE9sZGVyIHpjYWQgZmlsZXMgc3RvcmUgMzIgYml0IGZsb2F0cy4gVGhlIHJlbmRlcmVyIG1heSBjb252ZXJ0IHRoZXNlIHRvIDE2Yml0Lg0KICAgICAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCdwb3NpdGlvbnMnLCBuZXcgVmVjM0F0dHJpYnV0ZSgpKTsNCiAgICAgICAgICAgICAgICB0aGlzLnNldE51bVZlcnRpY2VzKG51bVZlcnRzKTsNCiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbnNBdHRyID0gdGhpcy5wb3NpdGlvbnM7DQogICAgICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBib3gzID0gdGhpcy5ib3VuZGluZ0JveDsNCiAgICAgICAgICAgICAgICAgICAgLy8gRnJvbSAzLjkuMSwgdmVydGV4IGRhdGEgaXMgYSBtaXggb2YgMTZiaXQgYW5kIDggYml0IHF1YW5pdGl6YXRpb24NCiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudmVyc2lvbnNbJ3plYS1lbmdpbmUnXS5jb21wYXJlKFszLCA5LCAxXSkgPj0gMCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDE2QXJyYXkobnVtVmVydHMgKiAzLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTE2Qml0UG9zaXRpb25zQXJyYXkoWzAsIG51bVZlcnRzXSwgYm94My5wMCwgYm94My5kaWFnb25hbCgpLCBwb3NpdGlvbnNfcXVhbnRpemVkLCBwb3NpdGlvbnNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXRQb3NpdGlvbnNBcnJheShbMCwgbnVtVmVydHNdLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChub3JtYWxzQXR0cikgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBib3gzID0gbmV3IEJveDMocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpOw0KICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxzX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICAgICAgcGFyc2U4Qml0Tm9ybWFsc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc19xdWFudGl6ZWQsIG5vcm1hbHNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveDIgPSBuZXcgQm94MihyZWFkZXIubG9hZEZsb2F0MzJWZWMyKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzIoKSk7DQogICAgICAgICAgICAgICAgICAgIC8vIEZyb20gMy45LjEsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uDQogICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMywgOSwgMV0pID49IDApIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleENvb3Jkc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KG51bVZlcnRzICogMiwgZmFsc2UpOw0KICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UxNkJpdFRleHR1cmVDb29yZHNBcnJheShbMCwgbnVtVmVydHNdLCBib3gyLnAwLCBib3gyLmRpYWdvbmFsKCksIHRleENvb3Jkc19xdWFudGl6ZWQsIHRleENvb3Jkc0F0dHIpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4Q29vcmRzX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDIsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOEJpdFRleHR1cmVDb29yZHNBcnJheShbMCwgbnVtVmVydHNdLCBib3gyLnAwLCBib3gyLmRpYWdvbmFsKCksIHRleENvb3Jkc19xdWFudGl6ZWQsIHRleENvb3Jkc0F0dHIpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIHRleENvb3Jkc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgLy8gT2xkZXIgemNhZCBmaWxlcyBzdG9yZSAzMiBiaXQgZmxvYXRzLiBUaGUgcmVuZGVyZXIgbWF5IGNvbnZlcnQgdGhlc2UgdG8gMTZiaXQuDQogICAgICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoJ3Bvc2l0aW9ucycsIG5ldyBWZWMzQXR0cmlidXRlKCkpOw0KICAgICAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMobnVtVmVydHMpOw0KICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uc0F0dHIgPSB0aGlzLnBvc2l0aW9uczsNCiAgICAgICAgICAgICAgICBjb25zdCBjbHVzdGVycyA9IFtdOw0KICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2x1c3RlcnM7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHJlYWRlci5sb2FkVUludDMyKCk7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJEYXRhID0gew0KICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIG9mZnNldCArIGNvdW50XSwNCiAgICAgICAgICAgICAgICAgICAgICAgIGJib3g6IG5ldyBCb3gzKHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSwgcmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNSYW5nZTogbmV3IEJveDMoKSwNCiAgICAgICAgICAgICAgICAgICAgICAgIHRleENvb3Jkc1JhbmdlOiBuZXcgQm94MigpLA0KICAgICAgICAgICAgICAgICAgICB9Ow0KICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsc0F0dHIpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEYXRhLm5vcm1hbHNSYW5nZS5zZXQocmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMzKCkpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyRGF0YS50ZXhDb29yZHNSYW5nZS5zZXQocmVhZGVyLmxvYWRGbG9hdDMyVmVjMigpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMyKCkpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goY2x1c3RlckRhdGEpOw0KICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIC8vIEZyb20gMy45LjEsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uDQogICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uc19xdWFudGl6ZWQ7DQogICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudmVyc2lvbnNbJ3plYS1lbmdpbmUnXS5jb21wYXJlKFszLCA5LCAxXSkgPj0gMCkgew0KICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNfcXVhbnRpemVkID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheShudW1WZXJ0cyAqIDMsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzLCBmYWxzZSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGxldCBub3JtYWxzX3F1YW50aXplZCA9IG51bGw7DQogICAgICAgICAgICAgICAgbGV0IHRleENvb3Jkc19xdWFudGl6ZWQgPSBudWxsOw0KICAgICAgICAgICAgICAgIGlmIChub3JtYWxzQXR0cikgew0KICAgICAgICAgICAgICAgICAgICBub3JtYWxzX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYgKHRleENvb3Jkc0F0dHIpIHsNCiAgICAgICAgICAgICAgICAgICAgdGV4Q29vcmRzX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDIsIGZhbHNlKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbHVzdGVyczsgaSsrKSB7DQogICAgICAgICAgICAgICAgICAgIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveDMgPSBjbHVzdGVyc1tpXS5iYm94Ow0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnJvbSAzLjkuMSwgdmVydGV4IGRhdGEgaXMgYSBtaXggb2YgMTZiaXQgYW5kIDggYml0IHF1YW5pdGl6YXRpb24NCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMywgOSwgMV0pID49IDApIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTE2Qml0UG9zaXRpb25zQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgcG9zaXRpb25zX3F1YW50aXplZCwgcG9zaXRpb25zQXR0cik7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXRQb3NpdGlvbnNBcnJheShjbHVzdGVyc1tpXS5yYW5nZSwgYm94My5wMCwgYm94My5kaWFnb25hbCgpLCBwb3NpdGlvbnNfcXVhbnRpemVkLCBwb3NpdGlvbnNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsc19xdWFudGl6ZWQpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveDMgPSBjbHVzdGVyc1tpXS5ub3JtYWxzUmFuZ2U7DQogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXROb3JtYWxzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc19xdWFudGl6ZWQsIG5vcm1hbHNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBpZiAodGV4Q29vcmRzX3F1YW50aXplZCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94MiA9IGNsdXN0ZXJzW2ldLnRleENvb3Jkc1JhbmdlOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudmVyc2lvbnNbJ3plYS1lbmdpbmUnXS5jb21wYXJlKFszLCA5LCAxXSkgPj0gMCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlMTZCaXRUZXh0dXJlQ29vcmRzQXJyYXkoWzAsIG51bVZlcnRzXSwgYm94Mi5wMCwgYm94Mi5kaWFnb25hbCgpLCB0ZXhDb29yZHNfcXVhbnRpemVkLCB0ZXhDb29yZHNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOEJpdFRleHR1cmVDb29yZHNBcnJheShjbHVzdGVyc1tpXS5yYW5nZSwgYm94Mi5wMCwgYm94Mi5kaWFnb25hbCgpLCB0ZXhDb29yZHNfcXVhbnRpemVkLCB0ZXhDb29yZHNBdHRyKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAobm9ybWFsc0F0dHIpIHsNCiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7DQogICAgICAgICAgICAgICAgICAgIHRleENvb3Jkc0F0dHIubG9hZFNwbGl0VmFsdWVzKHJlYWRlcik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gTG9hZGluZyB0aGUgYXR0cmlidXRlcyBtYXkgaGF2ZSBkaXJ0aWVkIHRoZSBib3VuZGluZyBib3guDQogICAgICAgICAgICAvLyB3ZSBrb253IHdlIGFscmVhZHkgbG9hZGVkIHRoZSBiYm94LCBzbyBmb3JjZSBpdCB0byBiZSB2YWxpZC4NCiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IGZhbHNlOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oY29udGV4dCk7DQogICAgICAgICAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuc2tpcFRvcG9sb2d5KSB7DQogICAgICAgICAgICAgICAganNvbi5udW1WZXJ0aWNlcyA9IHRoaXMuI251bVZlcnRpY2VzIHx8IDA7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGVzID0ge307DQogICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGF0dHJdIG9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmVudHJpZXMoKSkgew0KICAgICAgICAgICAgICAgIGlmICghY29udGV4dCB8fCAhKCdza2lwQXR0cmlidXRlcycgaW4gY29udGV4dCkgfHwgIWNvbnRleHQuc2tpcEF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkNCiAgICAgICAgICAgICAgICAgICAgdmVydGV4QXR0cmlidXRlc1trZXldID0gYXR0ci50b0pTT04oY29udGV4dCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBqc29uLnZlcnRleEF0dHJpYnV0ZXMgPSB2ZXJ0ZXhBdHRyaWJ1dGVzOw0KICAgICAgICAgICAgcmV0dXJuIGpzb247DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqc29uIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGpzb24sIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTsNCiAgICAgICAgICAgIHN1cGVyLmZyb21KU09OKGpzb24sIGNvbnRleHQpOw0KICAgICAgICAgICAgdGhpcy5zZXROdW1WZXJ0aWNlcyhqc29uLm51bVZlcnRpY2VzKTsNCiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBqc29uLnZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgICAgICAgICAgICBsZXQgYXR0ciA9IHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldChuYW1lKTsNCiAgICAgICAgICAgICAgICBjb25zdCBhdHRySlNPTiA9IGpzb24udmVydGV4QXR0cmlidXRlc1tuYW1lXTsNCiAgICAgICAgICAgICAgICBpZiAoIWF0dHIgfHwgYXR0ci5kYXRhVHlwZU5hbWUgIT0gYXR0ckpTT04uZGF0YVR5cGUpIHsNCiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhdHRySlNPTi5kYXRhVHlwZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVmVjMic6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IG5ldyBWZWMyQXR0cmlidXRlKCk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdWZWMyZjE2JzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gbmV3IFZlYzJmMTZBdHRyaWJ1dGUoKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1ZlYzMnOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBuZXcgVmVjM0F0dHJpYnV0ZSgpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVmVjM2YxNic6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IG5ldyBWZWMzZjE2QXR0cmlidXRlKCk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdWZWMzZjgnOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBuZXcgVmVjM2Y4QXR0cmlidXRlKCk7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDb2xvcic6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IG5ldyBDb2xvckF0dHJpYnV0ZSgpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBWZWN0ZXggVHlwZTogJyArIGF0dHIuZGF0YVR5cGVOYW1lOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGF0dHIuc2V0Q291bnQodGhpcy4jbnVtVmVydGljZXMpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZShuYW1lLCBhdHRyKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgaWYgKGF0dHIpIHsNCiAgICAgICAgICAgICAgICAgICAgYXR0ci5mcm9tSlNPTihhdHRySlNPTik7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2F0dHIgdW5kZWZpbmVkLCBjYW5ub3QgZXhlY3V0ZSBmcm9tSlNPTigpJyk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YVRvcG9sb2d5Q2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIGdlb21ldHJ5IGRhdGEgdmFsdWUgaW4ganNvbiBmb3JtYXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgdG9TdHJpbmcoKSB7DQogICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgMik7DQogICAgICAgIH0NCiAgICB9CgogICAgLyoqDQogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcG9pbnQgcHJpbWl0aXZlIGRyYXdpbmcgdHlwZSwgZXZlcnkgdmVydGV4IHNwZWNpZmllZCBpcyBhIHBvaW50Lg0KICAgICAqDQogICAgICogYGBgDQogICAgICogY29uc3QgcG9pbnRzID0gbmV3IFBvaW50cygpDQogICAgICogYGBgDQogICAgICoNCiAgICAgKiAqICoqRXZlbnRzKioNCiAgICAgKiAqICoqYm91bmRpbmdCb3hDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIHRoZSBib3VuZGluZyBib3ggY2hhbmdlcy4NCiAgICAgKg0KICAgICAqIEBleHRlbmRzIEJhc2VHZW9tDQogICAgICovDQogICAgY2xhc3MgUG9pbnRzIGV4dGVuZHMgQmFzZUdlb20gew0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIHBvaW50cy4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsZWFyIG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIGNsZWFyKCkgew0KICAgICAgICAgICAgdGhpcy5zZXROdW1WZXJ0aWNlcygwKTsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIGN1cnJlbnQgZ2VvbWV0cnkoSW5jbHVkaW5nIGxpbmUgc2VnbWVudHMpIHVzaW5nIGEgYmluYXJ5IHJlYWRlciBvYmplY3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIsIGNvbnRleHQpOw0KICAgICAgICAgICAgLy8gdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignUG9pbnRzJywgUG9pbnRzKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi8NCiAgICAvKioNCiAgICAgKg0KICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBsaW5lcyBwcmltaXRpdmUgZHJhd2luZyB0eXBlLCBjb25uZWN0aW5nIHZlcnRpY2VzIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW5kaWNlcy4NCiAgICAgKiBpLmUuIFdlIGhhdmUgNCBwb2ludHModmVydGljZXMpIGJ1dCB3ZSBkb24ndCBrbm93IGhvdyB0aGV5IGNvbm5lY3QgdG8gZWFjaCBvdGhlciwNCiAgICAgKiBhbmQgdGhhdCdzIHdoeSB3ZSBuZWVkIGluZGljZXMoTnVtYmVycyBpbmRpY2F0aW5nIHdoaWNoIHZlcnRleCBjb25uZWN0cyB0byB3aGljaCkuDQogICAgICogSW4gdGhpcyBjYXNlIGlmIHdlIHNheSB0aGF0IGBpbmRpY2VzYCBpcyBgWzAsMSwyLDNdYCwgaXQgd291bGQgY29ubmVjdCB0aGUgZmlyc3QgdmVydGV4IHRvIHRoZSBzZWNvbmQsDQogICAgICogYW5kIHRoZSB0aGlyZCB0byB0aGUgZm91cnRoLg0KICAgICAqDQogICAgICogYGBgDQogICAgICogY29uc3QgbGluZXMgPSBuZXcgTGluZXMoKQ0KICAgICAqIGBgYA0KICAgICAqDQogICAgICogKipFdmVudHMqKg0KICAgICAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGdlb21ldHJ5IGlzIHNldChUaGlzIGluY2x1ZGVzIHJlYWRpbmcgYmluYXJ5KQ0KICAgICAqDQogICAgICogQGV4dGVuZHMgQmFzZUdlb20NCiAgICAgKi8NCiAgICBjbGFzcyBMaW5lcyBleHRlbmRzIEJhc2VHZW9tIHsNCiAgICAgICAgX19pbmRpY2VzOw0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlIGxpbmVzLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoKSB7DQogICAgICAgICAgICBzdXBlcigpOw0KICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNsZWFyIG1ldGhvZC4NCiAgICAgICAgICovDQogICAgICAgIGNsZWFyKCkgew0KICAgICAgICAgICAgdGhpcy5zZXROdW1TZWdtZW50cygwKTsNCiAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMoMCk7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ2dlb21EYXRhVG9wb2xvZ3lDaGFuZ2VkJyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBpbmRpY2VzKFZlcnRleCBjb25uZWN0b3JzKQ0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGljZXMgaW5kZXggYXJyYXkuDQogICAgICAgICAqLw0KICAgICAgICBnZXRJbmRpY2VzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbGluZSBzZWdtZW50cy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cy4NCiAgICAgICAgICovDQogICAgICAgIGdldE51bVNlZ21lbnRzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzLmxlbmd0aCAvIDI7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TnVtTGluZVNlZ21lbnRzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzLmxlbmd0aCAvIDI7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzIGluIHRoZSBsaW5lcyBnZW9tZXRyeS4NCiAgICAgICAgICogKipJbXBvcnRhbnQ6KiogSXQgcmVzZXRzIGluZGljZXMgdmFsdWVzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbnVtT2ZTZWdtZW50cyAtIFRoZSBjb3VudCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldE51bVNlZ21lbnRzKG51bU9mU2VnbWVudHMpIHsNCiAgICAgICAgICAgIGlmIChudW1PZlNlZ21lbnRzID4gdGhpcy5nZXROdW1TZWdtZW50cygpKSB7DQogICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShudW1PZlNlZ21lbnRzICogMik7DQogICAgICAgICAgICAgICAgaW5kaWNlcy5zZXQodGhpcy5fX2luZGljZXMpOw0KICAgICAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzID0gaW5kaWNlczsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzID0gdGhpcy5fX2luZGljZXMuc2xpY2UoMCwgbnVtT2ZTZWdtZW50cyAqIDIpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHNlZ21lbnQgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW5kZXguDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHAwIC0gVGhlIHAwIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gcDEgLSBUaGUgcDEgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBzZXRTZWdtZW50VmVydGV4SW5kaWNlcyhpbmRleCwgcDAsIHAxKSB7DQogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fX2luZGljZXMubGVuZ3RoIC8gMikNCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGluZSBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gU2VnbWVudHM6JyArIHRoaXMuX19pbmRpY2VzLmxlbmd0aCAvIDIpOw0KICAgICAgICAgICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMF0gPSBwMDsNCiAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzW2luZGV4ICogMiArIDFdID0gcDE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRTZWdtZW50VmVydGV4SW5kZXggbWV0aG9kLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbGluZSAtIFRoZSBsaW5lIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gbGluZVZlcnRleCAtIFRoZSBsaW5lVmVydGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICogQHByaXZhdGUNCiAgICAgICAgICovDQogICAgICAgIGdldFNlZ21lbnRWZXJ0ZXhJbmRleChsaW5lLCBsaW5lVmVydGV4KSB7DQogICAgICAgICAgICBjb25zdCBudW1TZWdtZW50cyA9IHRoaXMuZ2V0TnVtU2VnbWVudHMoKTsNCiAgICAgICAgICAgIGlmIChsaW5lIDwgbnVtU2VnbWVudHMpDQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzW2xpbmUgKiAyICsgbGluZVZlcnRleF07DQogICAgICAgICAgICByZXR1cm4gLTE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE1lcmdlcyBhIHNlcGFyYXRlIGdlb21ldHJ5IGludG8gdGhpcyBvbmUuIFNpbWlsYXIgdG8gYSAndW5pb24nIGJvb2xlYW4gb3BlcmF0aW9uLg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgdGhlIG90aGVyIGdlb20gdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoaXMgb25lDQogICAgICAgICAqIEBwYXJhbSB4Zm8gdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG90aGVyIGdlb20gYXMgaXQgaXMgbWVyZ2VkIGluLg0KICAgICAgICAgKi8NCiAgICAgICAgbWVyZ2Uob3RoZXIsIHhmbyA9IG5ldyBYZm8oKSkgew0KICAgICAgICAgICAgY29uc3QgcHJldk51bVZlcnRzID0gdGhpcy5nZXROdW1WZXJ0aWNlcygpOw0KICAgICAgICAgICAgc3VwZXIubWVyZ2Uob3RoZXIsIHhmbyk7DQogICAgICAgICAgICBjb25zdCBvdGhlSW5kaWNlcyA9IG90aGVyLl9faW5kaWNlczsNCiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX2luZGljZXMubGVuZ3RoICsgb3RoZUluZGljZXMubGVuZ3RoKTsNCiAgICAgICAgICAgIGluZGljZXMuc2V0KHRoaXMuX19pbmRpY2VzLCAwKTsNCiAgICAgICAgICAgIGluZGljZXMuc2V0KG90aGVJbmRpY2VzLm1hcCgoaW5kZXgpID0+IGluZGV4ICsgcHJldk51bVZlcnRzKSwgdGhpcy5fX2luZGljZXMubGVuZ3RoKTsNCiAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzID0gaW5kaWNlczsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIE1lbW9yeQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlcyBidWZmZXJzIGFuZCBpdHMgY291bnQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2VuQnVmZmVycyhvcHRzKSB7DQogICAgICAgICAgICBjb25zdCBidWZmZXJzID0gc3VwZXIuZ2VuQnVmZmVycygpOw0KICAgICAgICAgICAgbGV0IGluZGljZXM7DQogICAgICAgICAgICBpZiAoYnVmZmVycy5udW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDgpKSB7DQogICAgICAgICAgICAgICAgaW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19pbmRpY2VzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlcnMubnVtVmVydGljZXMgPCBNYXRoLnBvdygyLCAxNikpIHsNCiAgICAgICAgICAgICAgICBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19pbmRpY2VzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIGluZGljZXMgPSB0aGlzLl9faW5kaWNlczsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGJ1ZmZlcnMuaW5kaWNlcyA9IGluZGljZXM7DQogICAgICAgICAgICByZXR1cm4gYnVmZmVyczsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgIC8vIFBlcnNpc3RlbmNlDQogICAgICAgIC8qKg0KICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIGN1cnJlbnQgZ2VvbWV0cnkoSW5jbHVkaW5nIGxpbmUgc2VnbWVudHMpIHVzaW5nIGEgYmluYXJ5IHJlYWRlciBvYmplY3QuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIsIGNvbnRleHQpOw0KICAgICAgICAgICAgdGhpcy5zZXROdW1TZWdtZW50cyhyZWFkZXIubG9hZFVJbnQzMigpKTsNCiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVhZGVyLmxvYWRVSW50OCgpOw0KICAgICAgICAgICAgaWYgKGJ5dGVzID09IDEpDQogICAgICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKTsNCiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzID09IDIpDQogICAgICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KCk7DQogICAgICAgICAgICBlbHNlIGlmIChieXRlcyA9PSA0KQ0KICAgICAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MzJBcnJheSgpOw0KICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4NCiAgICAgICAgICovDQogICAgICAgIHRvSlNPTihjb250ZXh0KSB7DQogICAgICAgICAgICBjb25zdCBqID0gc3VwZXIudG9KU09OKGNvbnRleHQpOw0KICAgICAgICAgICAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LnNraXBUb3BvbG9neSkNCiAgICAgICAgICAgICAgICBqLmluZGljZXMgPSBBcnJheS5mcm9tKHRoaXMuX19pbmRpY2VzKTsNCiAgICAgICAgICAgIHJldHVybiBqOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBmcm9tSlNPTihqLCBjb250ZXh0KSB7DQogICAgICAgICAgICBzdXBlci5mcm9tSlNPTihqLCBjb250ZXh0KTsNCiAgICAgICAgICAgIGlmIChqLmluZGljZXMpDQogICAgICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSBVaW50MzJBcnJheS5mcm9tKGouaW5kaWNlcyk7DQogICAgICAgIH0NCiAgICB9DQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ0xpbmVzJywgTGluZXMpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqLw0KICAgIC8qKg0KICAgICAqIFRoZSBNZXNoIGNsYXNzIHByb3ZpZGVzIGEgZmxleGlibGUgYW5kIGZhc3QgcG9seWdvbiBtZXNoIHJlcHJlc2VudGF0aW9uLiBJdCBzdXBwb3J0cyBwb2x5Z29ucyBvZiBhcmJpdHJhcnkgY29tcGxleGl0eSwNCiAgICAgKiBmcm9tIGJhc2ljIHRyaWFuZ2xlcyBhbmQgcXVhZHMgdG8gcGVudGFnb25zIG1vcmUuDQogICAgICogSXQgc3VwcG9ydHMgc3RvcmluZyBwZXIgZmFjZSBhdHRyaWJ1dGVzLCBhbmQgcGVyIGVkZ2UgYXR0cmlidXRlcy4NCiAgICAgKiBUaGUgTWVzaCBjbGFzcyBoYW5kbGVzIGNvbnZlcnRpbmcgaXRzIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHBvbHlnb25zIGludG8gYSBzaW1wbGVyIHRyaWFuZ2xlcyByZXByZXNlbnRhdGlvbiBmb3IgcmVuZGVyaW5nLg0KICAgICAqDQogICAgICogYGBgDQogICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKCkNCiAgICAgKiBgYGANCiAgICAgKg0KICAgICAqICoqRXZlbnRzKioNCiAgICAgKiAqICoqZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIHRvcG9sb2d5IG9mIHRoZSBtZXNoIGhhcyBiZWVuIGNoYW5nZWQuDQogICAgICogKiAqKmdlb21EYXRhQ2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdmVydGljZXMgb2YgdGhlIG1lc2ggaGF2ZSBjaGFuZ2VkLCBidXQgbm90IG5lY2Vzc2FyaWx5IHRoZSB0b3BvbG9neS4NCiAgICAgKg0KICAgICAqIEBleHRlbmRzIEJhc2VHZW9tDQogICAgICovDQogICAgY2xhc3MgTWVzaCBleHRlbmRzIEJhc2VHZW9tIHsNCiAgICAgICAgZmFjZUNvdW50czsNCiAgICAgICAgZmFjZVZlcnRleEluZGljZXM7DQogICAgICAgIF9fbG9nVG9wb2xvZ3lXYXJuaW5nczsNCiAgICAgICAgX19lZGdlQXR0cmlidXRlczsNCiAgICAgICAgX19mYWNlQXR0cmlidXRlczsNCiAgICAgICAgbnVtRWRnZXM7DQogICAgICAgIGVkZ2VWZXJ0czsNCiAgICAgICAgZWRnZUFuZ2xlczsNCiAgICAgICAgZWRnZVZlY3M7DQogICAgICAgIGVkZ2VGYWNlczsNCiAgICAgICAgZmFjZUVkZ2VzOw0KICAgICAgICB2ZXJ0ZXhFZGdlczsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWVzaC4NCiAgICAgICAgICovDQogICAgICAgIGNvbnN0cnVjdG9yKCkgew0KICAgICAgICAgICAgc3VwZXIoKTsNCiAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzID0gW107DQogICAgICAgICAgICB0aGlzLmZhY2VFZGdlcyA9IFtbXV07DQogICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMgPSBbXTsNCiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKTsNCiAgICAgICAgICAgIHRoaXMuX19sb2dUb3BvbG9neVdhcm5pbmdzID0gZmFsc2U7DQogICAgICAgICAgICB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7DQogICAgICAgICAgICB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7DQogICAgICAgICAgICB0aGlzLm51bUVkZ2VzID0gMDsNCiAgICAgICAgICAgIHRoaXMuZWRnZVZlcnRzID0gW107DQogICAgICAgICAgICB0aGlzLnZlcnRleEVkZ2VzID0gW107DQogICAgICAgICAgICB0aGlzLmVkZ2VBbmdsZXMgPSBuZXcgRmxvYXQzMkFycmF5KCk7DQogICAgICAgICAgICB0aGlzLmVkZ2VWZWNzID0gW107DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBjbGVhciBtZXRob2QuDQogICAgICAgICAqLw0KICAgICAgICBjbGVhcigpIHsNCiAgICAgICAgICAgIHN1cGVyLmNsZWFyKCk7DQogICAgICAgICAgICAvL3RoaXMuaW5pdCgpDQogICAgICAgICAgICAvL3RoaXMuc2V0TnVtVmVydGljZXMoMCkNCiAgICAgICAgICAgIC8vIGNsZWFyIGVkZ2UgYW5kIGZhY2Ugbm9ybWFscy4NCiAgICAgICAgICAgIHRoaXMuZWRnZVZlcnRzID0gW107DQogICAgICAgICAgICB0aGlzLnZlcnRleEVkZ2VzID0gW107DQogICAgICAgICAgICB0aGlzLm51bUVkZ2VzID0gMDsNCiAgICAgICAgICAgIHRoaXMuZWRnZUFuZ2xlcyA9IG5ldyBGbG9hdDMyQXJyYXkoKTsNCiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQnKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQWRkcyBhIG5ldyB2ZXJ0ZXggYXR0cmlidXRlIHRvIHRoZSBnZW9tZXRyeS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS4NCiAgICAgICAgICogQHBhcmFtIGF0dHIgLSBUaGUgYXR0cmlidXRlIHRvIGFkZCB0byB0aGUgZ2VvbWV0cnkNCiAgICAgICAgICovDQogICAgICAgIGFkZFZlcnRleEF0dHJpYnV0ZShuYW1lLCBhdHRyKSB7DQogICAgICAgICAgICBzdXBlci5hZGRWZXJ0ZXhBdHRyaWJ1dGUobmFtZSwgYXR0cik7DQogICAgICAgICAgICBhdHRyLnNldE1lc2godGhpcyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRGYWNlQ291bnRzIG1ldGhvZC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXRGYWNlQ291bnRzKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZUNvdW50czsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldE51bUZhY2VzIG1ldGhvZC4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXROdW1GYWNlcygpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2VDb3VudHMubGVuZ3RoID09IDAgPyAwIDogdGhpcy5mYWNlQ291bnRzLnJlZHVjZSgobnVtRmFjZXMsIGZjKSA9PiAobnVtRmFjZXMgKz0gZmMpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGdldE51bVRyaWFuZ2xlcyBtZXRob2QuDQogICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0TnVtVHJpYW5nbGVzKCkgew0KICAgICAgICAgICAgbGV0IG51bVRyaWFuZ2xlcyA9IDA7DQogICAgICAgICAgICBsZXQgbnVtVHJpc1BlckZhY2UgPSAxOw0KICAgICAgICAgICAgZm9yIChjb25zdCBmYyBvZiB0aGlzLmZhY2VDb3VudHMpIHsNCiAgICAgICAgICAgICAgICBudW1UcmlhbmdsZXMgKz0gZmMgKiBudW1UcmlzUGVyRmFjZTsNCiAgICAgICAgICAgICAgICBudW1UcmlzUGVyRmFjZSsrOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIG51bVRyaWFuZ2xlczsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGZhY2VzIG9uIHRoZSBtZXNoIHVzaW5nIGFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGNvdW50cyBwZXIgcG9seWdvbiBzaXplLg0KICAgICAgICAgKiBUaGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLCB0aGUgc2Vjb25kLCB0aGUgbnVtYmVyIG9mIHF1YWRzLCB0aGUgM3JkLCB0aGUgbnVtYmVyIG9mIDUgc2lkZWQgcG9seWdvbnMgZXRjLi4NCiAgICAgICAgICogZS5nLiB0byBzcGVjaWZ5IDIgdHJpYW5nbGVzLCBhbmQgNyBxdWFkcywgd2Ugd291bGQgcGFzcyBbMiwgN10NCiAgICAgICAgICogQHBhcmFtIGZhY2VDb3VudHMgLSBUaGUgZmFjZUNvdW50cyB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIHNldEZhY2VDb3VudHMoZmFjZUNvdW50cykgew0KICAgICAgICAgICAgLy8gbGV0IG51bUZhY2VzID0gMA0KICAgICAgICAgICAgbGV0IG51bUZhY2VzVmVydGljZXMgPSAwOw0KICAgICAgICAgICAgbGV0IG51bVZlcnRzUGVyRmFjZSA9IDM7DQogICAgICAgICAgICBmb3IgKGNvbnN0IGZjIG9mIGZhY2VDb3VudHMpIHsNCiAgICAgICAgICAgICAgICAvLyBudW1GYWNlcyArPSBmYw0KICAgICAgICAgICAgICAgIG51bUZhY2VzVmVydGljZXMgKz0gZmMgKiBudW1WZXJ0c1BlckZhY2U7DQogICAgICAgICAgICAgICAgbnVtVmVydHNQZXJGYWNlKys7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBwcmV2TnVtRmFjZXMgPSB0aGlzLmdldE51bUZhY2VzKCk7DQogICAgICAgICAgICBpZiAocHJldk51bUZhY2VzID09IDApIHsNCiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG51bUZhY2VzVmVydGljZXMpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRleEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkobnVtRmFjZXNWZXJ0aWNlcyk7DQogICAgICAgICAgICAgICAgLy8gTm93IHdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBpbmRpY2VzIGlmIHRoZXkgZml0IHdpdGhpbiB0aGUgbmV3IGZhY2VWZXJ0ZXhJbmRpY2VzIGFycmF5Lg0KICAgICAgICAgICAgICAgIGxldCBzdGFydFNyYyA9IDA7DQogICAgICAgICAgICAgICAgbGV0IHN0YXJ0VGd0ID0gMDsNCiAgICAgICAgICAgICAgICBudW1GYWNlc1ZlcnRpY2VzID0gMDsNCiAgICAgICAgICAgICAgICBudW1WZXJ0c1BlckZhY2UgPSAzOw0KICAgICAgICAgICAgICAgIGZhY2VDb3VudHMuZm9yRWFjaCgoZmMsIGluZGV4KSA9PiB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFNyYyA9IHN0YXJ0U3JjICsgTWF0aC5taW4oZmMsIHRoaXMuZmFjZUNvdW50c1tpbmRleF0pICogbnVtVmVydHNQZXJGYWNlOw0KICAgICAgICAgICAgICAgICAgICBmYWNlVmVydGV4SW5kaWNlcy5zZXQodGhpcy5mYWNlVmVydGV4SW5kaWNlcy5zbGljZShzdGFydFNyYywgZW5kU3JjKSwgc3RhcnRUZ3QpOw0KICAgICAgICAgICAgICAgICAgICBzdGFydFNyYyArPSB0aGlzLmZhY2VDb3VudHNbaW5kZXhdICogbnVtVmVydHNQZXJGYWNlOw0KICAgICAgICAgICAgICAgICAgICBzdGFydFRndCArPSBmYyAqIG51bVZlcnRzUGVyRmFjZTsNCiAgICAgICAgICAgICAgICAgICAgbnVtVmVydHNQZXJGYWNlKys7DQogICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4SW5kaWNlcyA9IGZhY2VWZXJ0ZXhJbmRpY2VzOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5mYWNlQ291bnRzID0gZmFjZUNvdW50czsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGZhY2UgdmVydGljZXMNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBnZXROdW1GYWNlVmVydGljZXMoKSB7DQogICAgICAgICAgICBsZXQgbnVtRmFjZVZlcnRzID0gMDsNCiAgICAgICAgICAgIHRoaXMuZmFjZUNvdW50cy5mb3JFYWNoKChmYywgaW5kZXgpID0+IHsNCiAgICAgICAgICAgICAgICBudW1GYWNlVmVydHMgKz0gZmMgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgcmV0dXJuIG51bUZhY2VWZXJ0czsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluZGV4ZWQgYnkgdGhpcyBmYWNlDQogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpIHsNCiAgICAgICAgICAgIGxldCBpZHggPSAwOw0KICAgICAgICAgICAgbGV0IGNvdW50ID0gMDsNCiAgICAgICAgICAgIHRoaXMuZmFjZUNvdW50cy5zb21lKChmYywgaW5kZXgpID0+IHsNCiAgICAgICAgICAgICAgICBpZHggKz0gZmM7DQogICAgICAgICAgICAgICAgaWYgKGlkeCA+IGZhY2VJbmRleCkgew0KICAgICAgICAgICAgICAgICAgICBjb3VudCA9IGluZGV4ICsgMzsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsNCiAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgcmV0dXJuIGNvdW50Ow0KICAgICAgICB9DQogICAgICAgIGdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KSB7DQogICAgICAgICAgICBsZXQgaWR4ID0gMDsNCiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOw0KICAgICAgICAgICAgdGhpcy5mYWNlQ291bnRzLnNvbWUoKGZjLCBpbmRleCkgPT4gew0KICAgICAgICAgICAgICAgIGlmIChpZHggKyBmYyA+IGZhY2VJbmRleCkgew0KICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gKGZhY2VJbmRleCAtIGlkeCkgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlkeCArPSBmYzsNCiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmMgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBzZXRGYWNlVmVydGV4SW5kaWNlcyBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gdmVydGV4SW5kaWNlcyAtIFRoZSBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBmb3IgdGhpcyBmYWNlIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgc2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRpY2VzKSB7DQogICAgICAgICAgICBjb25zdCBmYWNlVmVydGV4Q291bnQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpOw0KICAgICAgICAgICAgaWYgKHZlcnRleEluZGljZXMubGVuZ3RoICE9IGZhY2VWZXJ0ZXhDb3VudCkgew0KICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbmRpY2VzIGZvciBmYWNlOiR7ZmFjZUluZGV4fSB2ZXJ0ZXhJbmRpY2VzOiR7dmVydGV4SW5kaWNlc30uIEV4cGVjdGVkICR7ZmFjZVZlcnRleENvdW50fSBpbmRpY2VzYCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsNCiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleEluZGljZXMuc2V0KHZlcnRleEluZGljZXMsIG9mZnNldCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgYSBuZXcgZmFjZSB0byB0aGUgbWVzaA0KICAgICAgICAgKiBAcGFyYW0gdmVydGV4SW5kaWNlcyAtIFRoZSB2ZXJ0ZXggaW5kaWNlcyBvZiB0aGUgZmFjZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgZmFjZSBpbiB0aGUgbWVzaC4NCiAgICAgICAgICovDQogICAgICAgIGFkZEZhY2UodmVydGV4SW5kaWNlcykgew0KICAgICAgICAgICAgY29uc3QgZmFjZUNvdW50cyA9IFsuLi50aGlzLmZhY2VDb3VudHNdOw0KICAgICAgICAgICAgaWYgKGZhY2VDb3VudHMubGVuZ3RoIDw9IHZlcnRleEluZGljZXMubGVuZ3RoIC0gMykgew0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmYWNlQ291bnRzLmxlbmd0aDsgaSA8IHZlcnRleEluZGljZXMubGVuZ3RoIC0gMzsgaSsrKQ0KICAgICAgICAgICAgICAgICAgICBmYWNlQ291bnRzW2ldID0gMDsNCiAgICAgICAgICAgICAgICBmYWNlQ291bnRzW3ZlcnRleEluZGljZXMubGVuZ3RoIC0gM10gPSAxOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgZmFjZUNvdW50c1t2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCAtIDNdKys7DQogICAgICAgICAgICB9DQogICAgICAgICAgICB0aGlzLnNldEZhY2VDb3VudHMoZmFjZUNvdW50cyk7DQogICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCBpbiB0aGUgZmFjZVZlcnRleEluZGljZXMgb2YgdGhpcyBuZXcgZmFjZS4NCiAgICAgICAgICAgIGxldCBmYWNlSW5kZXggPSAwOw0KICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMuc29tZSgoZmMsIGluZGV4KSA9PiB7DQogICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMyA9PSB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCkgew0KICAgICAgICAgICAgICAgICAgICBmYWNlSW5kZXggKz0gZmMgLSAxOw0KICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gKGZjIC0gMSkgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGZhY2VJbmRleCArPSBmYzsNCiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmMgKiAoaW5kZXggKyAzKTsNCiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleEluZGljZXMuc2V0KHZlcnRleEluZGljZXMsIG9mZnNldCk7DQogICAgICAgICAgICByZXR1cm4gZmFjZUluZGV4Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSB2ZXJ0ZXggaW5kaWNlcyBvZiB0aGUgc3BlY2lmaWVkIGZhY2UuDQogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBmYWNlDQogICAgICAgICAqIEByZXR1cm4gLSBBbiBhcnJheSBvZiBpbmRpY2VzIGludG8gdGhlIHZlcnRleCBhdHRyaWJ1dGVzDQogICAgICAgICAqLw0KICAgICAgICBnZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpIHsNCiAgICAgICAgICAgIGNvbnN0IHZlcnRleEluZGljZXMgPSBbXTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0RmFjZVZlcnRleE9mZnNldChmYWNlSW5kZXgpOw0KICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpOw0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7DQogICAgICAgICAgICAgICAgdmVydGV4SW5kaWNlcy5wdXNoKHRoaXMuZmFjZVZlcnRleEluZGljZXNbb2Zmc2V0ICsgaV0pOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHZlcnRleEluZGljZXM7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgYSBzaW5nbGUgdmVydGV4IGluZGV4IGZvciBhIGdpdmVuIGZhY2UgYW5kIGZhY2VWZXJ0ZXguDQogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBmYWNlIHZlcnRleCBpcyB0aGUgaW5kZXggd2l0aGluIHRoZSBmYWNlLiBTbyB0aGUgZmlyc3QgdmVydGV4IGluZGV4IGlzIDAuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgdmVydGV4IGluZGV4DQogICAgICAgICAqLw0KICAgICAgICBnZXRGYWNlVmVydGV4SW5kZXgoZmFjZUluZGV4LCBmYWNlVmVydGV4KSB7DQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2VWZXJ0ZXhJbmRpY2VzW29mZnNldCArIGZhY2VWZXJ0ZXhdOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBGYWNlIEF0dHJpYnV0ZXMNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBhZGRGYWNlQXR0cmlidXRlIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZSBhdHRyaWJ1dGUgdG8gYWRkLg0KICAgICAgICAgKiBAcGFyYW0gYXR0ciAtIFRoZSBhdHRyIHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBhZGRGYWNlQXR0cmlidXRlKG5hbWUsIGF0dHIpIHsNCiAgICAgICAgICAgIGF0dHIuc2V0Q291bnQodGhpcy5nZXROdW1GYWNlcygpKTsNCiAgICAgICAgICAgIHRoaXMuX19mYWNlQXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7DQogICAgICAgICAgICByZXR1cm4gYXR0cjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGhhc0ZhY2VBdHRyaWJ1dGUgbWV0aG9kLg0KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmYWNlIGF0dHJpYnV0ZS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBoYXNGYWNlQXR0cmlidXRlKG5hbWUpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuaGFzKG5hbWUpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2V0RmFjZUF0dHJpYnV0ZSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZhY2UgYXR0cmlidXRlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGdldEZhY2VBdHRyaWJ1dGUobmFtZSkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19mYWNlQXR0cmlidXRlcy5nZXQobmFtZSk7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBFZGdlIEF0dHJpYnV0ZXMNCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBhZGRFZGdlQXR0cmlidXRlIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGUgdG8gYWRkLg0KICAgICAgICAgKiBAcGFyYW0gYXR0ciAtIFRoZSBhdHRyIHZhbHVlDQogICAgICAgICAqLw0KICAgICAgICBhZGRFZGdlQXR0cmlidXRlKG5hbWUsIGF0dHIpIHsNCiAgICAgICAgICAgIGF0dHIuc2V0Q291bnQodGhpcy5udW1FZGdlcyk7DQogICAgICAgICAgICB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMuc2V0KG5hbWUsIGF0dHIpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgaGFzRWRnZUF0dHJpYnV0ZSBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVkZ2UgYXR0cmlidXRlLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGhhc0VkZ2VBdHRyaWJ1dGUobmFtZSkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5oYXMobmFtZSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZXRFZGdlQXR0cmlidXRlIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0RWRnZUF0dHJpYnV0ZShuYW1lKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLmdldChuYW1lKTsNCiAgICAgICAgfQ0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBnZW5Ub3BvbG9neUluZm8gbWV0aG9kLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2VuVG9wb2xvZ3lJbmZvKCkgew0KICAgICAgICAgICAgbGV0IGNvbm5lY3RlZFZlcnRpY2VzID0ge307IC8vIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUuDQogICAgICAgICAgICB0aGlzLnZlcnRleEVkZ2VzID0gW107IC8vIDJkIGFycmF5IG9mIHZlcnRleCB0byBlZGdlcy4NCiAgICAgICAgICAgIC8vIHRoaXMudmVydGV4RmFjZXMgPSBbXTsgLy8gMmQgYXJyYXkgb2YgdmVydGV4IHRvIGZhY2VzLg0KICAgICAgICAgICAgdGhpcy5lZGdlRmFjZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiAyIGZhY2UgaW5kaWNlcyBwZXIgZWRnZQ0KICAgICAgICAgICAgdGhpcy5lZGdlVmVydHMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiAyIHZlcnQgaW5kaWNlcyBwZXIgZWRnZQ0KICAgICAgICAgICAgdGhpcy5mYWNlRWRnZXMgPSBbXTsgLy8gdGhlIGVkZ2VzIGJvcmRlcmluZyBlYWNoIGZhY2UuDQogICAgICAgICAgICB0aGlzLm51bUVkZ2VzID0gMDsNCiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zOw0KICAgICAgICAgICAgY29uc3QgZ2V0RWRnZUluZGV4ID0gKHYwLCB2MSkgPT4gew0KICAgICAgICAgICAgICAgIGxldCB0bXAwID0gdjA7DQogICAgICAgICAgICAgICAgbGV0IHRtcDEgPSB2MTsNCiAgICAgICAgICAgICAgICBpZiAodG1wMSA8IHRtcDApIHsNCiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gdG1wMDsNCiAgICAgICAgICAgICAgICAgICAgdG1wMCA9IHRtcDE7DQogICAgICAgICAgICAgICAgICAgIHRtcDEgPSB0bXA7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRtcDAgKyAnPicgKyB0bXAxOw0KICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gY29ubmVjdGVkVmVydGljZXMpIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coa2V5ICsgJzonICsgY29ubmVjdGVkVmVydGljZXNba2V5XSArICIgZmFjZToiICsgKCB2MCA8IHYxID8gMCA6IDEpICk7DQogICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0ZWRWZXJ0aWNlc1trZXldOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBjb25zdCBwMCA9IHBvc2l0aW9ucy5nZXRWYWx1ZSh0bXAwKTsNCiAgICAgICAgICAgICAgICBjb25zdCBwMSA9IHBvc2l0aW9ucy5nZXRWYWx1ZSh0bXAxKTsNCiAgICAgICAgICAgICAgICBjb25zdCBlZGdlVmVjID0gcDEuc3VidHJhY3QocDApOw0KICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IHRoaXMuZWRnZUZhY2VzLmxlbmd0aCAvIDI7DQogICAgICAgICAgICAgICAgY29uc3QgZWRnZURhdGEgPSB7DQogICAgICAgICAgICAgICAgICAgIGVkZ2VJbmRleDogZWRnZUluZGV4LA0KICAgICAgICAgICAgICAgICAgICBlZGdlVmVjOiBlZGdlVmVjLA0KICAgICAgICAgICAgICAgIH07DQogICAgICAgICAgICAgICAgY29ubmVjdGVkVmVydGljZXNba2V5XSA9IGVkZ2VEYXRhOw0KICAgICAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpOw0KICAgICAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpOw0KICAgICAgICAgICAgICAgIHRoaXMuZWRnZVZlcnRzLnB1c2godG1wMCk7DQogICAgICAgICAgICAgICAgdGhpcy5lZGdlVmVydHMucHVzaCh0bXAxKTsNCiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhrZXkgKyAnOicgKyBjb25uZWN0ZWRWZXJ0aWNlc1trZXldICsgIiBmYWNlOiIgKyAoIHYwIDwgdjEgPyAwIDogMSkpOw0KICAgICAgICAgICAgICAgIHRoaXMubnVtRWRnZXMrKzsNCiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZURhdGE7DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgY29uc3QgYWRkRWRnZSA9ICh2MCwgdjEsIGZhY2VJbmRleCkgPT4gew0KICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZGRFZGdlOicgKyB2MCArICIgOiIgKyB2MSArICIgZmFjZUluZGV4OiIgKyBmYWNlSW5kZXggKTsNCiAgICAgICAgICAgICAgICBjb25zdCBlZGdlRGF0YSA9IGdldEVkZ2VJbmRleCh2MCwgdjEpOw0KICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IGVkZ2VEYXRhLmVkZ2VJbmRleDsNCiAgICAgICAgICAgICAgICBpZiAodjEgPCB2MCkgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGdlRmFjZUluZGV4ID0gZWRnZUluZGV4ICogMiArIDA7DQogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyAmJiB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSAhPSAtMSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRWRnZSBwb2x5IDAgYWxyZWFkeSBzZXQuIE1lc2ggaXMgbm9uLW1hbmlmb2xkLicpOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSA9IGZhY2VJbmRleDsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VGYWNlSW5kZXggPSBlZGdlSW5kZXggKiAyICsgMTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19sb2dUb3BvbG9neVdhcm5pbmdzICYmIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdICE9IC0xKQ0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFZGdlIHBvbHkgMSBhbHJlYWR5IHNldC4gTWVzaCBpcyBub24tbWFuaWZvbGQuJyk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdID0gZmFjZUluZGV4Ow0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAoIShmYWNlSW5kZXggaW4gdGhpcy5mYWNlRWRnZXMpKQ0KICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VFZGdlc1tmYWNlSW5kZXhdID0gW107DQogICAgICAgICAgICAgICAgdGhpcy5mYWNlRWRnZXNbZmFjZUluZGV4XS5wdXNoKGVkZ2VJbmRleCk7DQogICAgICAgICAgICAgICAgLy8gUHVzaCB0aGUgZWRnZSBpbmRleCBvbnRvIGJvdGggdmVydGV4IGVkZ2UgbGlzdHMuDQogICAgICAgICAgICAgICAgLy8gV2UgdXNlIFNldHMgdG8gYXZvaWQgYWRkaW5nIHRoZSBzYW1lIGVkZ2UgMnggdG8gdGhlIHNhbWUgdmVydGV4Lg0KICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW3YwXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MF0gPSBuZXcgU2V0KCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW3YxXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MV0gPSBuZXcgU2V0KCk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMudmVydGV4RWRnZXNbdjBdLmFkZChlZGdlSW5kZXgpOw0KICAgICAgICAgICAgICAgIHRoaXMudmVydGV4RWRnZXNbdjFdLmFkZChlZGdlSW5kZXgpOw0KICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnZlcnRleEZhY2VzW3YwXSA9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy52ZXJ0ZXhGYWNlc1t2MF0gPSBbXTsNCiAgICAgICAgICAgICAgICAvLyB9DQogICAgICAgICAgICAgICAgLy8gdGhpcy52ZXJ0ZXhGYWNlc1t2MF0ucHVzaChmYWNlSW5kZXgpOw0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOw0KICAgICAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gZmFjZVZlcnRzW2pdOw0KICAgICAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGZhY2VWZXJ0c1soaiArIDEpICUgZmFjZVZlcnRzLmxlbmd0aF07DQogICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UodjAsIHYxLCBmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29tcHV0ZXMgYSBub3JtYWwgdmFsdWUgcGVyIGZhY2UgYnkgYXZlcmFnaW5nIHRoZSB0cmlhbmdsZSBub3JtYWxzIG9mIHRoZSBmYWNlLg0KICAgICAgICAgKi8NCiAgICAgICAgY29tcHV0ZUZhY2VOb3JtYWxzKCkgew0KICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7DQogICAgICAgICAgICBjb25zdCBmYWNlTm9ybWFscyA9IG5ldyBWZWMzZjhBdHRyaWJ1dGUoKTsNCiAgICAgICAgICAgIHRoaXMuYWRkRmFjZUF0dHJpYnV0ZSgnbm9ybWFscycsIGZhY2VOb3JtYWxzKTsNCiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOw0KICAgICAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgIGNvbnN0IHAwID0gcG9zaXRpb25zLmdldFZhbHVlKGZhY2VWZXJ0c1swXSk7DQogICAgICAgICAgICAgICAgY29uc3QgcDEgPSBwb3NpdGlvbnMuZ2V0VmFsdWUoZmFjZVZlcnRzWzFdKTsNCiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHAxOw0KICAgICAgICAgICAgICAgIGNvbnN0IGZhY2VOb3JtYWwgPSBuZXcgVmVjMygpOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAyOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHBuID0gcG9zaXRpb25zLmdldFZhbHVlKGZhY2VWZXJ0c1tqXSk7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gcHJldi5zdWJ0cmFjdChwMCk7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gcG4uc3VidHJhY3QocDApOw0KICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFsLmFkZEluUGxhY2UodjAuY3Jvc3ModjEpLm5vcm1hbGl6ZSgpKTsNCiAgICAgICAgICAgICAgICAgICAgcHJldiA9IHBuOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBpZiAoZmFjZU5vcm1hbC5sZW5ndGhTcXVhcmVkKCkgPCBOdW1iZXIuRVBTSUxPTikgOw0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFscy5zZXRWYWx1ZShmYWNlSW5kZXgsIGZhY2VOb3JtYWwubm9ybWFsaXplKCkpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYW5nbGVzIGF0IGVhY2ggZWRnZSBiZXR3ZWVuIHRoZSBhZGpvaW5pbmcgZmFjZXMNCiAgICAgICAgICovDQogICAgICAgIGNhbGN1bGF0ZUVkZ2VBbmdsZXMoKSB7DQogICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGggPT0gMCkNCiAgICAgICAgICAgICAgICB0aGlzLmdlblRvcG9sb2d5SW5mbygpOw0KICAgICAgICAgICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTsNCiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zOw0KICAgICAgICAgICAgY29uc3QgZmFjZU5vcm1hbHMgPSB0aGlzLmdldEZhY2VBdHRyaWJ1dGUoJ25vcm1hbHMnKTsNCiAgICAgICAgICAgIHRoaXMuZWRnZVZlY3MgPSBbXTsNCiAgICAgICAgICAgIHRoaXMuZWRnZUFuZ2xlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1FZGdlcyk7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRnZUZhY2VzLmxlbmd0aDsgaSArPSAyKSB7DQogICAgICAgICAgICAgICAgY29uc3QgdjAgPSB0aGlzLmVkZ2VWZXJ0c1tpXTsNCiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IHRoaXMuZWRnZVZlcnRzW2kgKyAxXTsNCiAgICAgICAgICAgICAgICBjb25zdCBlZGdlVmVjID0gcG9zaXRpb25zLmdldFZhbHVlKHYxKS5zdWJ0cmFjdChwb3NpdGlvbnMuZ2V0VmFsdWUodjApKTsNCiAgICAgICAgICAgICAgICBlZGdlVmVjLm5vcm1hbGl6ZUluUGxhY2UoKTsNCiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VWZWNzLnB1c2goZWRnZVZlYyk7DQogICAgICAgICAgICAgICAgY29uc3QgcDAgPSB0aGlzLmVkZ2VGYWNlc1tpXTsNCiAgICAgICAgICAgICAgICBjb25zdCBwMSA9IHRoaXMuZWRnZUZhY2VzW2kgKyAxXTsNCiAgICAgICAgICAgICAgICBpZiAocDAgPT0gLTEgfHwgcDEgPT0gLTEpIHsNCiAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgZWRnZSBhcyBhIGJvcmRlciBlZGdlLi4uLg0KICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VBbmdsZXNbaSAvIDJdID0gTWF0aC5QSSAqIDIuMDsNCiAgICAgICAgICAgICAgICAgICAgY29udGludWU7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGNvbnN0IG4wID0gZmFjZU5vcm1hbHMuZ2V0VmFsdWUocDApOw0KICAgICAgICAgICAgICAgIGNvbnN0IG4xID0gZmFjZU5vcm1hbHMuZ2V0VmFsdWUocDEpOw0KICAgICAgICAgICAgICAgIHRoaXMuZWRnZUFuZ2xlc1tpIC8gMl0gPSBuMC5hbmdsZVRvKG4xKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ29tcHV0ZSB2ZXJ0ZXggbm9ybWFscy4NCiAgICAgICAgICogQHBhcmFtIGhhcmRBbmdsZSAtIFRoZSBoYXJkQW5nbGUgdmFsdWUgaW4gcmFkaWFucy4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb21wdXRlVmVydGV4Tm9ybWFscyhoYXJkQW5nbGUgPSAxLjAgLyogcmFkaWFucyAqLykgew0KICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVFZGdlQW5nbGVzKCk7DQogICAgICAgICAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpOw0KICAgICAgICAgICAgY29uc3Qgbm9ybWFsc0F0dHIgPSBuZXcgVmVjM2Y4QXR0cmlidXRlKCk7DQogICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgnbm9ybWFscycsIG5vcm1hbHNBdHRyKTsNCiAgICAgICAgICAgIC8vIHRoZXNlIG1ldGhvZHMgYXJlIGZhc3RlciB2ZXJzaW9ucyB0aGFuIHVzaW5nIHRoZSBtZXRob2RzDQogICAgICAgICAgICAvLyBwcm92aWRlZCBvbiB0aGUgYXR0cmlidXRlcy4gV2UgY2FjaGUgdmFsdWVzIGFuZCB1c2UgaGFyZCBjb2RlZCBjb25zdGFudHMuDQogICAgICAgICAgICAvLyBjb25zdCBmYWNlTm9ybWFsc0J1ZmZlciA9IGZhY2VOb3JtYWxzLmRhdGEuYnVmZmVyDQogICAgICAgICAgICBjb25zdCBnZXRGYWNlTm9ybWFsID0gKGluZGV4KSA9PiB7DQogICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VOb3JtYWxzLmdldFZhbHVlKGluZGV4KTsNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBjb25zdCBzZXRWZXJ0ZXhOb3JtYWwgPSAoaW5kZXgsIHZhbHVlKSA9PiB7DQogICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIuc2V0VmFsdWUoaW5kZXgsIHZhbHVlKTsNCiAgICAgICAgICAgIH07DQogICAgICAgICAgICBjb25zdCBnZXRDb25uZWN0ZWRFZGdlVmVjcyA9IChmYWNlSW5kZXgsIHZlcnRleEluZGV4KSA9PiB7DQogICAgICAgICAgICAgICAgbGV0IGUwOw0KICAgICAgICAgICAgICAgIGxldCBlMTsNCiAgICAgICAgICAgICAgICBjb25zdCBmYWNlRWRnZXMgPSB0aGlzLmZhY2VFZGdlc1tmYWNlSW5kZXhdOw0KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBmYWNlRWRnZXMpIHsNCiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRnZVZlcnRzW2UgKiAyXSA9PSB2ZXJ0ZXhJbmRleCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlMCkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMCA9IHRoaXMuZWRnZVZlY3NbZV07DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZTEgPSB0aGlzLmVkZ2VWZWNzW2VdOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZWRnZVZlcnRzW2UgKiAyICsgMV0gPT0gdmVydGV4SW5kZXgpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZTApDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZTAgPSB0aGlzLmVkZ2VWZWNzW2VdOw0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUxID0gdGhpcy5lZGdlVmVjc1tlXTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICByZXR1cm4gW2UwLCBlMV07DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWNlIGluZGV4aW5nIGRvZXNuJ3Qgc3RhcnQgYXQgMCwgdGhlbiB0aGUgdmVydGV4RWRnZXMgZG9uJ3QgZWl0aGVyLg0KICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW2ldID09IHVuZGVmaW5lZCkNCiAgICAgICAgICAgICAgICAgICAgY29udGludWU7DQogICAgICAgICAgICAgICAgY29uc3QgZWRnZXMgPSB0aGlzLnZlcnRleEVkZ2VzW2ldOw0KICAgICAgICAgICAgICAgIC8vIEdyb3VwcyBvZiBmYWNlcyBoYXZpbmcgYSBzbW9vdGggbm9ybWFsIGF0IHRoZSBjdXJyZW50IHZlcnRleC4NCiAgICAgICAgICAgICAgICBjb25zdCBmYWNlR3JvdXBzID0gW107DQogICAgICAgICAgICAgICAgY29uc3QgYWRkRmFjZVRvR3JvdXAgPSAoZmFjZSkgPT4gew0KICAgICAgICAgICAgICAgICAgICBsZXQgaW5Hcm91cCA9IGZhbHNlOw0KICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZhY2VHcm91cCBvZiBmYWNlR3JvdXBzKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBpbkdyb3VwID0gZmFjZUdyb3VwLmluY2x1ZGVzKGZhY2UpOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluR3JvdXApDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbkdyb3VwKQ0KICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwcy5wdXNoKFtmYWNlXSk7DQogICAgICAgICAgICAgICAgfTsNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZWRnZXMpIHsNCiAgICAgICAgICAgICAgICAgICAgY29uc3QgZjAgPSB0aGlzLmVkZ2VGYWNlc1tlICogMl07DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGYxID0gdGhpcy5lZGdlRmFjZXNbZSAqIDIgKyAxXTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKGYwICE9IC0xICYmIGYxICE9IC0xICYmIHRoaXMuZWRnZUFuZ2xlc1tlXSA8IGhhcmRBbmdsZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGYwICE9IC0xICYmIGYxID09IC0xICYmIHRoaXMuZWRnZUFuZ2xlc1tlXSA8IGhhcmRBbmdsZSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGYwZ3JvdXBJbmRleCA9IC0xOw0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGYxZ3JvdXBJbmRleCA9IC0xOw0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBJbmRleCA9IDA7IGdyb3VwSW5kZXggPCBmYWNlR3JvdXBzLmxlbmd0aDsgZ3JvdXBJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSAmJiBmYWNlR3JvdXBzW2dyb3VwSW5kZXhdLmluY2x1ZGVzKGYwKSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjBncm91cEluZGV4ID0gZ3JvdXBJbmRleDsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjFncm91cEluZGV4ID09IC0xICYmIGZhY2VHcm91cHNbZ3JvdXBJbmRleF0uaW5jbHVkZXMoZjEpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMWdyb3VwSW5kZXggPSBncm91cEluZGV4Ow0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYwZ3JvdXBJbmRleCA9PSAtMSAmJiBmMWdyb3VwSW5kZXggPT0gLTEpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlR3JvdXBzLnB1c2goW2YwLCBmMV0pOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZjBncm91cEluZGV4ICE9IC0xICYmIGYxZ3JvdXBJbmRleCAhPSAtMSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggIT0gZjFncm91cEluZGV4KSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIHRoZSAyIGdyb3VwcyB0aGF0IHRoZSBzbW9vdGggZWRnZSBqb2lucy4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdID0gZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdLmNvbmNhdChmYWNlR3JvdXBzW2YxZ3JvdXBJbmRleF0pOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlR3JvdXBzLnNwbGljZShmMWdyb3VwSW5kZXgsIDEpOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggPT0gLTEpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwc1tmMWdyb3VwSW5kZXhdLnB1c2goZjApOw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjFncm91cEluZGV4ID09IC0xKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VHcm91cHNbZjBncm91cEluZGV4XS5wdXNoKGYxKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgaGFyZCBlZGdlIG9yIGEgYm9yZGVyIGVkZ2UuLi4gQWRkIGZhY2VzIHNlcGFyYXRlbHkgZ3JvdXAuDQogICAgICAgICAgICAgICAgICAgIGlmIChmMCAhPSAtMSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZhY2VUb0dyb3VwKGYwKTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKGYxICE9IC0xKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmFjZVRvR3JvdXAoZjEpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAvLyBTb3J0IHRoZSBncm91cHMgdG8gaGF2ZSB0aGUgYmlnZ2VzdCBncm91cCBmaXJzdC4NCiAgICAgICAgICAgICAgICBmYWNlR3JvdXBzLnNvcnQoKGEsIGIpID0+IChhLmxlbmd0aCA8IGIubGVuZ3RoID8gMSA6IGEubGVuZ3RoID4gYi5sZW5ndGggPyAtMSA6IDApKTsNCiAgICAgICAgICAgICAgICBsZXQgZmlyc3RWZXJ0ZXggPSB0cnVlOw0KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmFjZUdyb3VwIG9mIGZhY2VHcm91cHMpIHsNCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlYzMoKTsNCiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWNlSW5kZXggb2YgZmFjZUdyb3VwKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWNlRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlVmVjcyhmYWNlSW5kZXgsIGkpOw0KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdlaWdodDsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWNlRWRnZXNbMF0gJiYgZmFjZUVkZ2VzWzFdKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gZmFjZUVkZ2VzWzBdLmFuZ2xlVG8oZmFjZUVkZ2VzWzFdKTsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuYWRkSW5QbGFjZShnZXRGYWNlTm9ybWFsKGZhY2VJbmRleCkuc2NhbGUod2VpZ2h0KSk7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3ZhcmlhYmxlIHdlaWdodCBpcyB1bmRlZmluZWQgYmVjYXVzZSBmYWNlRWRnZXNbMF0gb3IgZmFjZUVkZ2VzWzFdIGlzIHVuZGVmaW5lZCcpOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGkgPT0gMSkNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZygiRmFjZU5vcm1hbDoiICsgZmFjZUluZGV4ICsgIjoiICsgZ2V0RmFjZU5vcm1hbChmYWNlSW5kZXgpLnRvU3RyaW5nKCkpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemVJblBsYWNlKCk7DQogICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFZlcnRleCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVydGV4Tm9ybWFsKGksIG5vcm1hbCk7DQogICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRleCA9IGZhbHNlOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIuc2V0U3BsaXRWZXJ0ZXhWYWx1ZXMoaSwgZmFjZUdyb3VwLCBub3JtYWwuYXNBcnJheSgpKTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBub3JtYWxzQXR0cjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogVGhlIGNvbXB1dGVIYXJkRWRnZXNJbmRpY2VzIG1ldGhvZC4NCiAgICAgICAgICogQHBhcmFtIGhhcmRBbmdsZSAtIFRoZSBoYXJkQW5nbGUgdmFsdWUgaW4gcmFkaWFucy4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb21wdXRlSGFyZEVkZ2VzSW5kaWNlcyhoYXJkQW5nbGUgPSAxLjApIHsNCiAgICAgICAgICAgIGlmICh0aGlzLmVkZ2VWZXJ0cy5sZW5ndGggPT0gMCkNCiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUVkZ2VBbmdsZXMoKTsNCiAgICAgICAgICAgIGNvbnN0IGhhcmRFZGdlcyA9IFtdOw0KICAgICAgICAgICAgY29uc3QgYWRkRWRnZSA9IChpbmRleCkgPT4gew0KICAgICAgICAgICAgICAgIGhhcmRFZGdlcy5wdXNoKHRoaXMuZWRnZVZlcnRzW2luZGV4XSk7DQogICAgICAgICAgICAgICAgaGFyZEVkZ2VzLnB1c2godGhpcy5lZGdlVmVydHNbaW5kZXggKyAxXSk7DQogICAgICAgICAgICB9Ow0KICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkZ2VBbmdsZXMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGdlQW5nbGVzW2ldID4gaGFyZEFuZ2xlKSB7DQogICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UoaSAqIDIpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiBVaW50MzJBcnJheS5mcm9tKGhhcmRFZGdlcyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIE1lcmdlcyBhIHNlcGFyYXRlIGdlb21ldHJ5IGludG8gdGhpcyBvbmUuIFNpbWlsYXIgdG8gYSAndW5pb24nIGJvb2xlYW4gb3BlcmF0aW9uLg0KICAgICAgICAgKiBAcGFyYW0gb3RoZXIgdGhlIG90aGVyIGdlb20gdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoaXMgb25lDQogICAgICAgICAqIEBwYXJhbSB4Zm8gdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG90aGVyIGdlb20gYXMgaXQgaXMgbWVyZ2VkIGluLg0KICAgICAgICAgKi8NCiAgICAgICAgbWVyZ2Uob3RoZXIsIHhmbyA9IG5ldyBYZm8oKSkgew0KICAgICAgICAgICAgY29uc3QgcHJldk51bVZlcnRzID0gdGhpcy5nZXROdW1WZXJ0aWNlcygpOw0KICAgICAgICAgICAgc3VwZXIubWVyZ2Uob3RoZXIsIHhmbyk7DQogICAgICAgICAgICBjb25zdCBvdGhlckZhY2VWZXJ0ZXhJbmRpY2VzID0gb3RoZXIuZmFjZVZlcnRleEluZGljZXM7DQogICAgICAgICAgICBjb25zdCBmYWNlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmZhY2VWZXJ0ZXhJbmRpY2VzLmxlbmd0aCArIG90aGVyRmFjZVZlcnRleEluZGljZXMubGVuZ3RoKTsNCiAgICAgICAgICAgIGNvbnN0IG90aGVyRmFjZUNvdW50cyA9IG90aGVyLmdldEZhY2VDb3VudHMoKTsNCiAgICAgICAgICAgIGxldCBpbmRleE9mZnNldCA9IDA7DQogICAgICAgICAgICBsZXQgb3RoZXJJbmRleE9mZnNldCA9IDA7DQogICAgICAgICAgICBsZXQgbWVyZ2VkSW5kZXhPZmZzZXQgPSAwOw0KICAgICAgICAgICAgY29uc3QgbnVtQ291bnRzID0gTWF0aC5tYXgodGhpcy5mYWNlQ291bnRzLmxlbmd0aCwgb3RoZXJGYWNlQ291bnRzLmxlbmd0aCk7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50czsgaSsrKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFjZUNvdW50cy5sZW5ndGggPiBpKSB7DQogICAgICAgICAgICAgICAgICAgIC8vIEFkZCAndGhpcycgaW5kaWNlcw0KICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1JbmRpY2VzVGhpcyA9IHRoaXMuZmFjZUNvdW50c1tpXSAqIChpICsgMyk7DQogICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRpY2VzLnNldCh0aGlzLmZhY2VWZXJ0ZXhJbmRpY2VzLnNsaWNlKGluZGV4T2Zmc2V0LCBpbmRleE9mZnNldCArIG51bUluZGljZXNUaGlzKSwgbWVyZ2VkSW5kZXhPZmZzZXQpOw0KICAgICAgICAgICAgICAgICAgICBpbmRleE9mZnNldCArPSBudW1JbmRpY2VzVGhpczsNCiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW5kZXhPZmZzZXQgKz0gbnVtSW5kaWNlc1RoaXM7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGlmIChvdGhlckZhY2VDb3VudHMubGVuZ3RoID4gaSkgew0KICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlICdvdGhlcicgaW5kaWNlcw0KICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1JbmRpY2VzT3RoZXIgPSBvdGhlckZhY2VDb3VudHNbaV0gKiAoaSArIDMpOw0KICAgICAgICAgICAgICAgICAgICBmYWNlVmVydGV4SW5kaWNlcy5zZXQob3RoZXJGYWNlVmVydGV4SW5kaWNlcw0KICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKG90aGVySW5kZXhPZmZzZXQsIG90aGVySW5kZXhPZmZzZXQgKyBudW1JbmRpY2VzT3RoZXIpDQogICAgICAgICAgICAgICAgICAgICAgICAubWFwKChpbmRleCkgPT4gaW5kZXggKyBwcmV2TnVtVmVydHMpLCBtZXJnZWRJbmRleE9mZnNldCk7DQogICAgICAgICAgICAgICAgICAgIG90aGVySW5kZXhPZmZzZXQgKz0gbnVtSW5kaWNlc090aGVyOw0KICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbmRleE9mZnNldCArPSBudW1JbmRpY2VzT3RoZXI7DQogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZhY2VDb3VudHMubGVuZ3RoID09IGkpDQogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VDb3VudHNbaV0gPSAwOw0KICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VDb3VudHNbaV0gKz0gb3RoZXJGYWNlQ291bnRzW2ldOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuZmFjZVZlcnRleEluZGljZXMgPSBmYWNlVmVydGV4SW5kaWNlczsNCiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBtZXJnZSBkb2VzIG5vdCBjb3JyZWN0bHkgbWVyZ2Ugc3BsaXQgdmFsdWVzLCBhcyBpdCBpcyBxdWl0ZSBjb21wbGV4DQogICAgICAgICAgICAvLyBhbmQgd2UgZG9uJ3QgaGF2ZSB0aW1lIG5vdy4gV2UgY2FuIGNvbWUgYmFjayB0byB0aGlzLCBidXQgdGhlIHNwbGl0cyBzeXN0ZW0gaXMgb3Zlcmx5IGNvbXBsZXgNCiAgICAgICAgICAgIC8vIGFuZCB3ZSBjYW4gcHJvYmFibHkgcmUtd3JpdGUuDQogICAgICAgICAgICAvLyBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgICAgICAgIC8vICAgY29uc3Qgb3RoZXJBdHRyID0gb3RoZXIuZ2V0VmVydGV4QXR0cmlidXRlKGF0dHJOYW1lKQ0KICAgICAgICAgICAgLy8gICBpZiAob3RoZXJBdHRyKSB7DQogICAgICAgICAgICAvLyAgICAgY29uc3QgdGhpc1NwbGl0cyA9IGF0dHIuZ2V0U3BsaXRzKCkNCiAgICAgICAgICAgIC8vICAgICBjb25zdCBvdGhlclNwbGl0cyA9IG90aGVyQXR0ci5nZXRTcGxpdHMoKQ0KICAgICAgICAgICAgLy8gICAgIC8vIGZvciAobGV0IGtleSBpbiBvdGhlclNwbGl0cykgew0KICAgICAgICAgICAgLy8gICAgIC8vICAgdGhpc1NwbGl0c1trZXldID0gb3RoZXJTcGxpdHNba2V5XQ0KICAgICAgICAgICAgLy8gICAgIC8vIH0NCiAgICAgICAgICAgIC8vICAgfQ0KICAgICAgICAgICAgLy8gfQ0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUmVuZGVyaW5nDQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgZ2VuQnVmZmVycyBtZXRob2QuDQogICAgICAgICAqIEBwYXJhbSBvcHRzIC0gVGhlIG9wdHMgdmFsdWUuDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgZ2VuQnVmZmVycyhvcHRzKSB7DQogICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBub3JtYWxzIG9uIGRlbWFuZC4NCiAgICAgICAgICAgIC8vIGlmICghKCdub3JtYWxzJyBpbiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykpIHsNCiAgICAgICAgICAgIC8vICAgICAvLyB0aGlzLmdlb20uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsNCiAgICAgICAgICAgIC8vICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIsIFZlYzMsIDAuMCk7DQogICAgICAgICAgICAvLyB9DQogICAgICAgICAgICBjb25zdCBzcGxpdEluZGljZXMgPSB7fTsNCiAgICAgICAgICAgIGxldCBzcGxpdENvdW50ID0gMDsNCiAgICAgICAgICAgIGZvciAoY29uc3QgWywgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBhdHRyU3BsaXRzID0gYXR0ci5nZXRTcGxpdHMoKTsNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvbHlnb24gaW4gYXR0clNwbGl0cykgew0KICAgICAgICAgICAgICAgICAgICBpZiAoIShwb2x5Z29uIGluIHNwbGl0SW5kaWNlcykpDQogICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEluZGljZXNbcG9seWdvbl0gPSB7fTsNCiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBhdHRyU3BsaXRzW3BvbHlnb25dOw0KICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgaW4gdmVydGljZXMpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHBhcnNlSW50KHYpOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmVydGV4IGluIHNwbGl0SW5kaWNlc1twb2x5Z29uXSkpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEluZGljZXNbcG9seWdvbl1bdmVydGV4XSA9IHNwbGl0Q291bnQ7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRDb3VudCsrOw0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7DQogICAgICAgICAgICBjb25zdCBudW1VblNwbGl0VmVydGljZXMgPSBwb3NpdGlvbnMuZ2V0Q291bnQoKTsNCiAgICAgICAgICAgIGNvbnN0IHRvdGFsTnVtVmVydGljZXMgPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdENvdW50Ow0KICAgICAgICAgICAgbGV0IGluZGljZXM7DQogICAgICAgICAgICBpZiAoIW9wdHMgfHwgb3B0cy5pbmNsdWRlSW5kaWNlcyAhPSBmYWxzZSkgew0KICAgICAgICAgICAgICAgIGluZGljZXMgPSB0aGlzLmdlbmVyYXRlVHJpYW5ndWxhdGVkSW5kaWNlcyh0b3RhbE51bVZlcnRpY2VzLCBudW1VblNwbGl0VmVydGljZXMsIHNwbGl0SW5kaWNlcyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBsZXQgbWF4SW5kZXg7DQogICAgICAgICAgICAvLyBpZiAoZGVidWdBdHRyVmFsdWVzKQ0KICAgICAgICAgICAgLy8gICAgIG1heEluZGV4ID0gTWF0aC5tYXgoLi4uaW5kaWNlcyk7DQogICAgICAgICAgICBjb25zdCBhdHRyQnVmZmVycyA9IHt9Ow0KICAgICAgICAgICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIGF0dHJdIG9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSB7DQogICAgICAgICAgICAgICAgbGV0IHZhbHVlczsNCiAgICAgICAgICAgICAgICBpZiAoc3BsaXRDb3VudCA9PSAwKQ0KICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBhdHRyLmFzQXJyYXkoKTsNCiAgICAgICAgICAgICAgICBlbHNlDQogICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGF0dHIuZ2VuZXJhdGVTcGxpdFZhbHVlcyhzcGxpdEluZGljZXMsIHNwbGl0Q291bnQpOw0KICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGF0dHIuc3RyaWRlOw0KICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aCAvIGRpbWVuc2lvbjsNCiAgICAgICAgICAgICAgICAvLyBpZiAoZGVidWdBdHRyVmFsdWVzKSB7DQogICAgICAgICAgICAgICAgLy8gICAgIGlmIChjb3VudCA8PSBtYXhJbmRleCkNCiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUud2FybigiSW52YWxpZCBpbmRleGluZy4gQXR0ciB2YWx1ZSBpcyBpbnN1ZmZpY2llbnQgZm9yIGluZGV4aW5nOiIgKyBhdHRyTmFtZSArICIuIE1heCBJbmRleDoiICsgbWF4SW5kZXggKyAiIEF0dHIgU2l6ZToiICsgY291bnQpOw0KICAgICAgICAgICAgICAgIC8vIH0NCiAgICAgICAgICAgICAgICBhdHRyQnVmZmVyc1thdHRyTmFtZV0gPSB7DQogICAgICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLA0KICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQsDQogICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLA0KICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkOiBhdHRyTmFtZSA9PSAnbm9ybWFscycsDQogICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBhdHRyLmdldERhdGFUeXBlTmFtZSgpLA0KICAgICAgICAgICAgICAgIH07DQogICAgICAgICAgICB9DQogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7DQogICAgICAgICAgICAgICAgbnVtVmVydGljZXM6IHRoaXMubnVtVmVydGljZXMoKSwNCiAgICAgICAgICAgICAgICBudW1SZW5kZXJWZXJ0czogdG90YWxOdW1WZXJ0aWNlcywNCiAgICAgICAgICAgICAgICBpbmRpY2VzLA0KICAgICAgICAgICAgICAgIGF0dHJCdWZmZXJzLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIC8qIERpc2FibGVkIGR1cmluZyBUUyBtaWdyYXRpb24uDQogICAgICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmluY2x1ZGVWZXJ0ZXhOZWlnaGJvcnMpIHsNCiAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXMgPT0gdW5kZWZpbmVkKSB0aGlzLmdlblRvcG9sb2d5SW5mbygpDQogICAgICAgIA0KICAgICAgICAgICAgICBsZXQgY291bnQgPSAwDQogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFjZSBpbmRleGluZyBkb2Vzbid0IHN0YXJ0IGF0IDAsIHRoZW4gdGhlIHZlcnRleEVkZ2VzIGRvbid0IGVpdGhlci4NCiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1tpXSkgY291bnQgKz0gdGhpcy52ZXJ0ZXhFZGdlc1tpXS5zaXplDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgLy8gVGhlIGFycmF5IHdpbGwgYmUgc3RydWN0dXJlZCBhcyBhIHN0YXJ0K29mZnNldCBmb3IgZWFjaCB2ZXJ0ZXgsIGZvbGxvd2VkDQogICAgICAgICAgICAgIC8vIGJ5IGEgMmQgYXJyYXkgb2YgbmVpZ2hib3IgaW5kaWNlcy4NCiAgICAgICAgICAgICAgY29uc3QgdmVydGV4TmVpZ2hib3JzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmVydGV4RWRnZXMubGVuZ3RoICogMiArIGNvdW50KQ0KICAgICAgICAgICAgICBjb25zdCBzb3J0RmFuRWRnZXMgPSAoZmFuRWRnZXM6IGFueSkgPT4gew0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFuRWRnZXMubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgIGNvbnN0IGZlQSA9IGZhbkVkZ2VzW2ldDQogICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKykgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBmZUIgPSBmYW5FZGdlc1tqXQ0KICAgICAgICAgICAgICAgICAgICBpZiAoZmVBWzBdICE9IC0xICYmIGZlQVswXSA9PSBmZUJbMV0pIHsNCiAgICAgICAgICAgICAgICAgICAgICAvLyAgbW92ZSBmZUEgYWZ0ZXIgZmVCOw0KICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9IGogKyAxKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBmYW5FZGdlcy5zcGxpY2UoaSwgMSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqICsgMSwgMCwgZmVBKQ0KICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGlmIChmZUFbMV0gIT0gLTEgJiYgZmVBWzFdID09IGZlQlswXSkgew0KICAgICAgICAgICAgICAgICAgICAgIC8vICBtb3ZlIGZlQSBiZWZvcmUgZmVCOw0KICAgICAgICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShpLCAxKQ0KICAgICAgICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqLCAwLCBmZUEpDQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBjb25zdCBjaGVja0ZhbkVkZ2VzID0gKGZhbkVkZ2VzOiBhbnkpID0+IHsNCiAgICAgICAgICAgICAgICAvLyBub3cgY2hlY2sgdGhhdCB0aGUgZmFjZXMgYWxsIGJ1aWxkIGEgZmFuLiBNYXliZSBzdGFydGluZyBhbmQgZW5kaW5nIHdpdGggLTENCiAgICAgICAgICAgICAgICBpZiAoZmFuRWRnZXNbMF1bMF0gPT0gLTEgfHwgZmFuRWRnZXNbZmFuRWRnZXMubGVuZ3RoIC0gMV1bMV0gPT0gLTEpIHsNCiAgICAgICAgICAgICAgICAgIGlmIChmYW5FZGdlc1swXVswXSAhPSAtMSB8fCBmYW5FZGdlc1tmYW5FZGdlcy5sZW5ndGggLSAxXVsxXSAhPSAtMSkgew0KICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGZhbiBzdGFydHMgd2l0aCAtMSwgaXQgbXVzdCBhbHNvIGVuZCB3aXRoIC0xJykNCiAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYW5FZGdlcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgICAgY29uc3QgZmUgPSBmYW5FZGdlc1tpXQ0KICAgICAgICAgICAgICAgICAgaWYgKGZlWzBdID09IC0xIHx8IGZlWzFdID09IC0xKSB7DQogICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDAgJiYgaSAhPSBmYW5FZGdlcy5sZW5ndGggLSAxKSB7DQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCctMSBvbmx5IGFsbG93ZWQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgZmFuLicpDQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgIGlmIChmZVswXSAhPSAtMSkgew0KICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGkgLSAxDQogICAgICAgICAgICAgICAgICAgIGlmIChwcmV2IDwgMCkgcHJldiArPSBmYW5FZGdlcy5sZW5ndGgNCiAgICAgICAgICAgICAgICAgICAgaWYgKGZlWzBdICE9IGZhbkVkZ2VzW3ByZXZdWzFdKSB7DQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlcyBhcmUgbm90IHNlcXVlbnRpYWwnKQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICBpZiAoZmVbMV0gIT0gLTEpIHsNCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IChpICsgMSkgJSBmYW5FZGdlcy5sZW5ndGgNCiAgICAgICAgICAgICAgICAgICAgaWYgKGZlWzFdICE9IGZhbkVkZ2VzW25leHRdWzBdKSB7DQogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlcyBhcmUgbm90IHNlcXVlbnRpYWwnKQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICB9DQogICAgICAgIA0KICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgc3RhcnQgYW5kIG9mZnNldCB2YWx1ZXMuDQogICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aCAqIDINCiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbaV0gPT0gdW5kZWZpbmVkKSBjb250aW51ZQ0KICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy52ZXJ0ZXhFZGdlc1tpXQ0KICAgICAgICANCiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIHNvcnRlZCBsaXN0IG9mIGZhY2VzIGJhc2VkIG9uIGEgZmFuIGFyb3VuZA0KICAgICAgICAgICAgICAgIC8vIHRoZSB2ZXJ0ZXguDQogICAgICAgICAgICAgICAgY29uc3QgZmFuRWRnZXMgPSBbXQ0KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlZGdlcykgew0KICAgICAgICAgICAgICAgICAgY29uc3QgdjAgPSB0aGlzLmVkZ2VWZXJ0c1tlICogMl0NCiAgICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gdGhpcy5lZGdlVmVydHNbZSAqIDIgKyAxXQ0KICAgICAgICAgICAgICAgICAgbGV0IGYwID0gdGhpcy5lZGdlRmFjZXNbZSAqIDJdDQogICAgICAgICAgICAgICAgICBsZXQgZjEgPSB0aGlzLmVkZ2VGYWNlc1tlICogMiArIDFdDQogICAgICAgICAgICAgICAgICBsZXQgbmVpZ1ZlcnQNCiAgICAgICAgICAgICAgICAgIGlmICh2MCA9PSBpKSB7DQogICAgICAgICAgICAgICAgICAgIG5laWdWZXJ0ID0gdjENCiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodjEgPT0gaSkgew0KICAgICAgICAgICAgICAgICAgICBuZWlnVmVydCA9IHYwDQogICAgICAgICAgICAgICAgICAgIC8vIHN3YXAgdGhlIGZhY2VzDQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcCA9IGYwDQogICAgICAgICAgICAgICAgICAgIGYwID0gZjENCiAgICAgICAgICAgICAgICAgICAgZjEgPSB0bXANCiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3BvbG9neScpDQogICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICBmYW5FZGdlcy5wdXNoKFtmMCwgZjEsIG5laWdWZXJ0XSkNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgc29ydEZhbkVkZ2VzKGZhbkVkZ2VzKQ0KICAgICAgICAgICAgICAgIGNoZWNrRmFuRWRnZXMoZmFuRWRnZXMpDQogICAgICAgICAgICAgICAgY29uc3QgY2xvc2VkID0gZmFuRWRnZXNbMF1bMF0gIT0gLTEgfHwgZmFuRWRnZXNbZmFuRWRnZXMubGVuZ3RoIC0gMV1bMV0gIT0gLTENCiAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSAwDQogICAgICAgICAgICAgICAgaWYgKGNsb3NlZCkgZmxhZ3MgKz0gMQ0KICAgICAgICAgICAgICAgIHZlcnRleE5laWdoYm9yc1tpICogMl0gPSBvZmZzZXQNCiAgICAgICAgICAgICAgICB2ZXJ0ZXhOZWlnaGJvcnNbaSAqIDIgKyAxXSA9IGVkZ2VzLnNpemUgKyAoZmxhZ3MgPDwgOCkNCiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZlIG9mIGZhbkVkZ2VzKSB7DQogICAgICAgICAgICAgICAgICB2ZXJ0ZXhOZWlnaGJvcnNbb2Zmc2V0XSA9IGZlWzJdDQogICAgICAgICAgICAgICAgICBvZmZzZXQrKw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICA7KHJlc3VsdCBhcyBhbnkpLnZlcnRleE5laWdoYm9ycyA9IHZlcnRleE5laWdoYm9ycw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgKi8NCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbXB1dGUgdGhlIG51bWJlciBvZiB0cmlhbmdsZXMuIEZvciBoaWdoZXIgZGVncmVlIHBvbHlnb25zLCB0aGV5IGFyZSBkaXZpZGVkIGludG8gbXVsdGlwbGUgdHJpYW5nbGVzIGZvciByZW5kZXJpbmcuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLg0KICAgICAgICAgKi8NCiAgICAgICAgY29tcHV0ZU51bVRyaWFuZ2xlcygpIHsNCiAgICAgICAgICAgIGxldCBudW1WZXJ0c1BlckZhY2UgPSAzOw0KICAgICAgICAgICAgbGV0IHRyaXNDb3VudCA9IDA7DQogICAgICAgICAgICBmb3IgKGNvbnN0IGZjIG9mIHRoaXMuZmFjZUNvdW50cykgew0KICAgICAgICAgICAgICAgIHRyaXNDb3VudCArPSBmYyAqIChudW1WZXJ0c1BlckZhY2UgLSAyKTsNCiAgICAgICAgICAgICAgICBudW1WZXJ0c1BlckZhY2UrKzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0cmlzQ291bnQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRvIHByZXBhcmUgZGF0YSBmb3IgcmVuZGVyaW5nLCB0aGUgaW5kaWNlcyBmb3IgdGhlIHBvbHlnb25zIGlzIHVzZWQgdG8gY29tcHV0ZSBhIG5ldyBpbmRleCBidWZmZXIgYmFzZWQgb24NCiAgICAgICAgICogb25seSB0cmlhbmdsZXMuIFRoaXMgaXMgdXNlZCBkdXJpbmcgcmVuZGVyaW5nIGFuZCB0aGUgcmVzdWx0aW5nIGluZGljZXMgdXBsb2FkZWQgb3QgdGhlIEdQVSAgYnkgR0xNZXNoIGNsYXNzLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gdG90YWxOdW1WZXJ0aWNlcyAtIFRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMuDQogICAgICAgICAqIEBwYXJhbSBudW1VblNwbGl0VmVydGljZXMgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHVuLXNwbGl0IHZlcnRpY2VzLg0KICAgICAgICAgKiBAcGFyYW0gc3BsaXRJbmRpY2VzIC0gVGhlIHNwbGl0SW5kaWNlcyB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSB0eXBlZCBhcnJheSBjb250YWluaW5nIHRoZSB0cmlhbmd1bGF0ZWQgaW5kaWNlcy4NCiAgICAgICAgICovDQogICAgICAgIGdlbmVyYXRlVHJpYW5ndWxhdGVkSW5kaWNlcyh0b3RhbE51bVZlcnRpY2VzLCBudW1VblNwbGl0VmVydGljZXMsIHNwbGl0SW5kaWNlcykgew0KICAgICAgICAgICAgY29uc3QgdHJpc0NvdW50ID0gdGhpcy5jb21wdXRlTnVtVHJpYW5nbGVzKCk7DQogICAgICAgICAgICBsZXQgdHJpYW5ndWxhdGVkSW5kaWNlczsNCiAgICAgICAgICAgIGlmICh0b3RhbE51bVZlcnRpY2VzIDwgTWF0aC5wb3coMiwgOCkpDQogICAgICAgICAgICAgICAgdHJpYW5ndWxhdGVkSW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHRyaXNDb3VudCAqIDMpOw0KICAgICAgICAgICAgZWxzZSBpZiAodG90YWxOdW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkNCiAgICAgICAgICAgICAgICB0cmlhbmd1bGF0ZWRJbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRyaXNDb3VudCAqIDMpOw0KICAgICAgICAgICAgZWxzZQ0KICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkodHJpc0NvdW50ICogMyk7DQogICAgICAgICAgICBsZXQgdHJpYW5nbGVWZXJ0ZXggPSAwOw0KICAgICAgICAgICAgY29uc3QgYWRkVHJpYW5nbGVWZXJ0ZXhJbmRleCA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIGZhY2VJbmRleCkgew0KICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzICYmIGZhY2VJbmRleCBpbiBzcGxpdEluZGljZXNbdmVydGV4XSkNCiAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gbnVtVW5TcGxpdFZlcnRpY2VzICsgc3BsaXRJbmRpY2VzW3ZlcnRleF1bZmFjZUluZGV4XTsNCiAgICAgICAgICAgICAgICB0cmlhbmd1bGF0ZWRJbmRpY2VzW3RyaWFuZ2xlVmVydGV4XSA9IHZlcnRleDsNCiAgICAgICAgICAgICAgICB0cmlhbmdsZVZlcnRleCsrOw0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOw0KICAgICAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKSB7DQogICAgICAgICAgICAgICAgICAgIGlmIChqID49IDMpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGFkZGl0aW9uYWwgdHJpYW5nbGUsIHdlIGhhdmUgdG8gYWRkIDIgaW5kaWNlcy4NCiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRyaWFuZ2xlVmVydGV4SW5kZXgoZmFjZVZlcnRzWzBdLCBmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgICAgICAgICAgYWRkVHJpYW5nbGVWZXJ0ZXhJbmRleChmYWNlVmVydHNbaiAtIDFdLCBmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGFkZFRyaWFuZ2xlVmVydGV4SW5kZXgoZmFjZVZlcnRzW2pdLCBmYWNlSW5kZXgpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiB0cmlhbmd1bGF0ZWRJbmRpY2VzOw0KICAgICAgICB9DQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgLy8gUGVyc2lzdGVuY2UNCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlc3RvcmVzIG1lc2ggcHJvcGVydGllcyBmcm9tIGEgYmluYXJ5IHJlYWRlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuDQogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgew0KICAgICAgICAgICAgc3VwZXIubG9hZEJhc2VHZW9tQmluYXJ5KHJlYWRlciwgY29udGV4dCk7DQogICAgICAgICAgICB0aGlzLnNldEZhY2VDb3VudHMoQXJyYXkuZnJvbShyZWFkZXIubG9hZFVJbnQzMkFycmF5KCkpKTsNCiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOw0KICAgICAgICAgICAgLy8gTm90ZTogd2UgY2FuIHJlbW92ZSB0aGlzLiBXZSBjYW4gaW5mZXIgdGhpcyBmcm9tIHRoZSBhYm92ZSBmYWNlQ291bnRzIGFycmF5Lg0KICAgICAgICAgICAgLy8gRG8gbm90IGNsb25lIHRoZSBkYXRhLCBhcyBpdHMgJ3NjcmF0Y2ggbWVtb3J5JyBpbiBhbnkgY2FzZS4NCiAgICAgICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhIGxvdCBvZiB1bm5lY2Vzc2FyeSB0ZW1wb3JhcnkgYWxsb2NhaXRvbiBieSB1c2luZyBzaGFyZWQgYnVmZmVycy4NCiAgICAgICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXhDb3VudHMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtRmFjZXMsIGZhbHNlKTsNCiAgICAgICAgICAgIGNvbnN0IG9mZnNldFJhbmdlID0gcmVhZGVyLmxvYWRTSW50MzJWZWMyKCk7DQogICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlYWRlci5sb2FkVUludDgoKTsNCiAgICAgICAgICAgIGxldCBmYWNlVmVydGV4SW5kZXhEZWx0YXM7DQogICAgICAgICAgICBpZiAoYnl0ZXMgPT0gMSkNCiAgICAgICAgICAgICAgICBmYWNlVmVydGV4SW5kZXhEZWx0YXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkodW5kZWZpbmVkLCBmYWxzZSk7DQogICAgICAgICAgICBlbHNlIGlmIChieXRlcyA9PSAyKQ0KICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDE2QXJyYXkodW5kZWZpbmVkLCBmYWxzZSk7DQogICAgICAgICAgICBlbHNlIGlmIChieXRlcyA9PSA0KQ0KICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkodW5kZWZpbmVkLCBmYWxzZSk7DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignZmFjZVZlcnRleEluZGV4RGVsdGFzIHVuZGVmaW5lZCcpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAvLyBOb3RlOiBUaGUgTWVzaCBjb21wcmVzc2lvbiBzeXN0ZW0gbmVlZHMgYSB0aG9yb3VnaCByZXZpZXcuDQogICAgICAgICAgICAvLyBUaGUgQysrIGNsYXNzZXMgYXJlIG5vdCBzdG9yaW5nIGZhY2UgaW5kaWNlcyBpbiBhIHNvcnRlZCBtYW5uZXIuDQogICAgICAgICAgICAvLyBTbyBxdWFkcyBwcmVjZWRlIHRyaWFuZ2xlcyBpbiB0aGUgaW5kZXhpbmcsIHdoaWNoIGlzbid0IHN1cHBvc2VkIHRvIGhhcHBlbi4NCiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBmb3JjZSB0aGUgQysrIGNvZGUgdG8gc3RvcmUgcXVhZHMgYW5kIHRyaWFuZ2xlcyBpbiBvcmRlci4NCiAgICAgICAgICAgIC8vIGUuZy4gaW1wbGVtZW50IHRoZSAnYWRkRmFjZScgbWV0aG9kIGluIEMrKyBzbyBpdCBhdXRvbWF0aWNhbGx5IGRvZXMgdGhpcy4NCiAgICAgICAgICAgIGxldCBudW1GYWNlVmVydHMgPSAzOw0KICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICAgICAgICBjb25zdCBmYWNlT2Zmc2V0c0J5Q291bnQgPSB0aGlzLmZhY2VDb3VudHMubWFwKChmYywgaW5kZXgpID0+IHsNCiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvZmZzZXQ7DQogICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZjICogbnVtRmFjZVZlcnRzOw0KICAgICAgICAgICAgICAgIG51bUZhY2VWZXJ0cysrOw0KICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgICAgICB9KTsNCiAgICAgICAgICAgIGxldCBzcmNPZmZzZXQgPSAwOw0KICAgICAgICAgICAgbGV0IHByZXZDb3VudCA9IDA7DQogICAgICAgICAgICBjb25zdCBmYWNlT2Zmc2V0cyA9IFtdOw0KICAgICAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7DQogICAgICAgICAgICAgICAgY29uc3QgZmMgPSBmYWNlVmVydGV4Q291bnRzW2ZhY2VJbmRleF07DQogICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmFjZU9mZnNldHNCeUNvdW50W2ZjXTsNCiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGZjICsgMzsNCiAgICAgICAgICAgICAgICBmYWNlT2Zmc2V0c1tmYWNlSW5kZXhdID0gb2Zmc2V0Ow0KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykgew0KICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmNGYWNlVmVydGV4ID0gc3JjT2Zmc2V0ICsgajsNCiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRleCA9IG9mZnNldCArIGo7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZmFjZVZlcnRleEluZGV4RGVsdGFzW3NyY0ZhY2VWZXJ0ZXhdICsgb2Zmc2V0UmFuZ2UueDsNCiAgICAgICAgICAgICAgICAgICAgaWYgKGZhY2VJbmRleCA9PSAwKQ0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4SW5kaWNlc1tmYWNlVmVydGV4XSA9IGRlbHRhOw0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2RmFjZVZlcnRleCA9IGZhY2VPZmZzZXRzW2ZhY2VJbmRleCAtIDFdOw0KICAgICAgICAgICAgICAgICAgICAgICAgcHJldkZhY2VWZXJ0ZXggKz0gaiA8IHByZXZDb3VudCA/IGogOiBwcmV2Q291bnQgLSAxOw0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNlVmVydGV4SW5kaWNlc1tmYWNlVmVydGV4XSA9IHRoaXMuZmFjZVZlcnRleEluZGljZXNbcHJldkZhY2VWZXJ0ZXhdICsgZGVsdGE7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgc3JjT2Zmc2V0ICs9IGNvdW50Ow0KICAgICAgICAgICAgICAgIGZhY2VPZmZzZXRzQnlDb3VudFtmY10gKz0gY291bnQ7DQogICAgICAgICAgICAgICAgcHJldkNvdW50ID0gY291bnQ7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmVydGV4QXR0cmlidXRlKCdub3JtYWxzJykpIHsNCiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7DQogICAgICAgICAgICB0aGlzLmVtaXQoJ2dlb21EYXRhQ2hhbmdlZCcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0Lg0KICAgICAgICAgKi8NCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsNCiAgICAgICAgICAgIGNvbnN0IGogPSBzdXBlci50b0pTT04oY29udGV4dCk7DQogICAgICAgICAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuc2tpcFRvcG9sb2d5KSB7DQogICAgICAgICAgICAgICAgai5mYWNlQ291bnRzID0gQXJyYXkuZnJvbSh0aGlzLmZhY2VDb3VudHMpOw0KICAgICAgICAgICAgICAgIGouZmFjZVZlcnRleEluZGljZXMgPSBBcnJheS5mcm9tKHRoaXMuZmFjZVZlcnRleEluZGljZXMpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIGo7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuDQogICAgICAgICAqDQogICAgICAgICAqIGUuZy4gdG8gbG9hZCBkYXRhIGludG8gdGhlIG1lc2ggY2xhc3MsIHByb3ZpZGUgYSBqc29uIHN0cnVjdHVyZSBzaW1pbGFyIHRvIHRoZSBmb2xsb3dpbmcuDQogICAgICAgICAqIE5vdGU6IGZhY2VDb3VudHMgaXMgYW4gYXJyYXkgb2YgY291bnQgdmFsdWVzLCBzdGFydGluZyB3aXRoIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLCB0aGVuIHRoZSBudW1iZXIgb2YgcXVhZHMuIFNlZSAjc2V0RmFjZUNvdW50cw0KICAgICAgICAgKiBUaGUgZmFjZVZlcnRleEluZGljZXMgYXJyYXkgc2hvdWxkIGFsc28gYmUgc29ydGVkIHRvIGNvbnRhaW4gYWxsIHRoZSB0cmlhbmdsZXMgZmlyc3QsIGZvbGxvd2VkIGJ5IHRoZSBxdWFkcywgYW5kIHRoZW4gdGhlIHBlbnRhZ29ucyBldGMuLg0KICAgICAgICAgKiBgYGBqc29uDQogICAgICAgICAqIC8vIFRoaXMgY29kZSB3aWxsIGRlZmluZSBhIG1lc2ggbWFkZSB1cCBvZiAyIHRyaWFuZ2xlcyBhbmQgdGhlbiBhIHF1YWQuDQogICAgICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaCgpDQogICAgICAgICAqIG1lc2guZnJvbUpTT04oew0KICAgICAgICAgKiAgIGZhY2VDb3VudHM6WzIsIDFdLA0KICAgICAgICAgKiAgIGZhY2VWZXJ0ZXhJbmRpY2VzOiBbMCwgMSwgMiwgMCwgMiwgMywgMywgMiwgNCwgNV0sDQogICAgICAgICAqICAgbnVtVmVydGljZXM6IDYsDQogICAgICAgICAqICAgdmVydGV4QXR0cmlidXRlczogew0KICAgICAgICAgKiAgICAgcG9zaXRpb25zOiB7DQogICAgICAgICAqICAgICAgIGRhdGFUeXBlOiAnVmVjMycNCiAgICAgICAgICogICAgICAgZGVmYXVsdFNjYWxhclZhbHVlOiAwLjAsDQogICAgICAgICAqICAgICAgIGRhdGE6IFswLDAsMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMiwgMSwgMCwgMiwgMCwgMF0NCiAgICAgICAgICogICAgIH0NCiAgICAgICAgICogICB9DQogICAgICAgICAqIH0NCiAgICAgICAgICogYGBgDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4NCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHN1cGVyLmZyb21KU09OKGosIGNvbnRleHQpOw0KICAgICAgICAgICAgaWYgKGouZmFjZUNvdW50cykNCiAgICAgICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMgPSBqLmZhY2VDb3VudHM7DQogICAgICAgICAgICBpZiAoai5mYWNlVmVydGV4SW5kaWNlcykNCiAgICAgICAgICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhJbmRpY2VzID0gVWludDMyQXJyYXkuZnJvbShqLmZhY2VWZXJ0ZXhJbmRpY2VzKTsNCiAgICAgICAgfQ0KICAgIH0NCiAgICBSZWdpc3RyeS5yZWdpc3RlcignTWVzaCcsIE1lc2gpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovDQogICAgLyoqDQogICAgICogUmVhZHMgYmluYXJ5IGRhdGEgaW4gYSBzcGVjaWZpYyBlbmNvZGluZy4gVXNlZCBpbiBsb2FkaW5nIGJpbmFyeSBkYXRhIHN1Y2ggYXMgemNhZCBmaWxlcy4NCiAgICAgKi8NCiAgICBjbGFzcyBCaW5SZWFkZXIgew0KICAgICAgICBfX2RhdGE7DQogICAgICAgIF9fYnl0ZU9mZnNldDsNCiAgICAgICAgX19kYXRhVmlldzsNCiAgICAgICAgX19pc01vYmlsZURldmljZTsNCiAgICAgICAgdXRmOGRlY29kZXI7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgYSBiaW4gcmVhZGVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGJ1ZmZlci4NCiAgICAgICAgICogQHBhcmFtIGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZSBvZmZzZXQgdmFsdWUgdG8gc3RhcnQgcmVhZGluZyB0aGUgYnVmZmVyLg0KICAgICAgICAgKiBAcGFyYW0gaXNNb2JpbGVEZXZpY2UgLSBUaGUgaXNNb2JpbGVEZXZpY2UgdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBjb25zdHJ1Y3RvcihkYXRhLCBieXRlT2Zmc2V0ID0gMCwgaXNNb2JpbGVEZXZpY2UgPSB0cnVlKSB7DQogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IGRhdGE7DQogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7DQogICAgICAgICAgICB0aGlzLl9fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5fX2RhdGEpOw0KICAgICAgICAgICAgdGhpcy5fX2lzTW9iaWxlRGV2aWNlID0gaXNNb2JpbGVEZXZpY2U7DQogICAgICAgICAgICB0aGlzLnV0ZjhkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgc3RhdGUgb2Ygd2hldGhlciBvciBub3QgdGhlIGBCaW5SZWFkZXJgIG9iamVjdCB3YXMgaW5zdGFudGlhdGVkIGZyb20gYSBtb2JpbGUgZGV2aWNlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIGlzIGEgbW9iaWxlIGRldmljZSBpcyBkZXRlY3RlZC4NCiAgICAgICAgICovDQogICAgICAgIGdldCBpc01vYmlsZURldmljZSgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faXNNb2JpbGVEZXZpY2U7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGRhdGEgYnVmZmVyIHdlJ3JlIHJlYWRpbmcgZnJvbS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSBkYXRhIGJ1ZmZlciB3ZSBhcmUgcmVhZGluZyBmcm9tLA0KICAgICAgICAgKi8NCiAgICAgICAgZ2V0IGRhdGEoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGE7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgYnVmZmVyDQogICAgICAgICAqLw0KICAgICAgICBnZXQgYnl0ZUxlbmd0aCgpIHsNCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gcmVhZC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gcmVhZC4NCiAgICAgICAgICovDQogICAgICAgIGdldCByZW1haW5pbmdCeXRlTGVuZ3RoKCkgew0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhVmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5fX2J5dGVPZmZzZXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgY3VycmVudCBieXRlIG9mZnNldCBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBiaW5hcnkgYnVmZmVyDQogICAgICAgICAqLw0KICAgICAgICBwb3MoKSB7DQogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFNldHMgdGhlIGJ5dGUgb2Zmc2V0IHZhbHVlLg0KICAgICAgICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBieXRlT2Zmc2V0IHBhcmFtLg0KICAgICAgICAgKi8NCiAgICAgICAgc2VlayhieXRlT2Zmc2V0KSB7DQogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEFkZHMgb2Zmc2V0IGJ5dGVzIHRvIGN1cnJlbnQgb2Zmc2V0IHZhbHVlLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIE9mZnNldCBhbW91bnQuDQogICAgICAgICAqLw0KICAgICAgICBhZHZhbmNlKGJ5dGVPZmZzZXQpIHsNCiAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IGJ5dGVPZmZzZXQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHVuc2lnbmVkIFVpbnQ4IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sDQogICAgICAgICAqIGFuZCBhZGRzIG9uZSBieXRlIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFVJbnQ4KCkgew0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldFVpbnQ4KHRoaXMuX19ieXRlT2Zmc2V0KTsNCiAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDE7DQogICAgICAgICAgICByZXR1cm4gcmVzdWx0Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bnNpZ25lZCBVaW50MTYgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwNCiAgICAgICAgICogYW5kIGFkZHMgdHdvIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFVJbnQxNigpIHsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gMjsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHVuc2lnbmVkIFVpbnQzMiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLA0KICAgICAgICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFVJbnQzMigpIHsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNDsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIHNpZ25lZCBJbnQzMiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLA0KICAgICAgICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFNJbnQzMigpIHsNCiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRJbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0Ow0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLA0KICAgICAgICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEZsb2F0MTYoKSB7DQogICAgICAgICAgICBjb25zdCB1aW50MTYgPSB0aGlzLmxvYWRVSW50MTYoKTsNCiAgICAgICAgICAgIHJldHVybiBNYXRoRnVuY3Rpb25zLmRlY29kZTE2Qml0RmxvYXQodWludDE2KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyB0aGUgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLA0KICAgICAgICAgKiBhbmQgYWRkcyB0d28gYnl0ZXMgdG8gdGhlIG9mZnNldC4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkVUZsb2F0MTYoKSB7DQogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgICAgICAgICBpZiAocmVzdWx0IDwgMC4wKSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIDIwNDguMCAtIHJlc3VsdDsgLy8gTm90ZTogc3VidHJhY3QgYSBuZWdhdGl2ZSBudW1iZXIgdG8gYWRkIGl0Lg0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgICAgIH0NCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhIHNpbmdsZSBzaWduZWQgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uIGZyb20gMiB1bnNpZ25lZCBJbnQ4IHZhbHVlcywNCiAgICAgICAgICogYW5kIGFkZHMgdHdvIGJ5dGVzIHRvIHRoZSBvZmZzZXQuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEZsb2F0MTZGcm9tMnhVSW50OCgpIHsNCiAgICAgICAgICAgIHRocm93IEVycm9yKCdsb2FkRmxvYXQxNkZyb20yeFVJbnQ4IG5vdCBpbXBsZW1lbnRlZCEnKTsNCiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKQ0KICAgICAgICAgICAgLy8gY29uc3QgdWludDhzID0gdGhpcy5sb2FkVUludDhBcnJheSgyKTsNCiAgICAgICAgICAgIC8vIHJldHVybiBNYXRoLmRlY29kZTE2Qml0RmxvYXQodWludDhzKTsNCiAgICAgICAgICAgIC8vIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDINCiAgICAgICAgICAgIC8vIHJldHVybiByZXN1bHQNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIFVuc2lnbmVkIEZsb2F0MTYgdmFsdWVzLg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRVSW50MzJGcm9tMnhVRmxvYXQxNigpIHsNCiAgICAgICAgICAgIGNvbnN0IHBhcnRBID0gdGhpcy5sb2FkVUZsb2F0MTYoKTsNCiAgICAgICAgICAgIGNvbnN0IHBhcnRCID0gdGhpcy5sb2FkVUZsb2F0MTYoKTsNCiAgICAgICAgICAgIHJldHVybiBwYXJ0QSArIHBhcnRCICogNDA5NjsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIHNpZ25lZCBGbG9hdDE2IHZhbHVlcy4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpIHsNCiAgICAgICAgICAgIGNvbnN0IHBhcnRBID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgICAgICAgICAgY29uc3QgcGFydEIgPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgICAgICAgICByZXR1cm4gcGFydEEgKyBwYXJ0QiAqIDIwNDg7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJldHVybnMgdGhlIEZsb2F0MzIgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwNCiAgICAgICAgICogYW5kIGFkZHMgZm91ciBieXRlcyB0byB0aGUgb2Zmc2V0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRGbG9hdDMyKCkgew0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldEZsb2F0MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOw0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNDsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGEgc2lnbmVkIEludDggYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUsDQogICAgICAgICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC4NCiAgICAgICAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEludDhBcnJheShzaXplLCBjbG9uZSA9IHRydWUpIHsNCiAgICAgICAgICAgIGlmIChzaXplID09IHVuZGVmaW5lZCkNCiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7DQogICAgICAgICAgICBsZXQgcmVzdWx0Ow0KICAgICAgICAgICAgaWYgKGNsb25lKSB7DQogICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEludDhBcnJheSh0aGlzLl9fZGF0YS5zbGljZSh0aGlzLl9fYnl0ZU9mZnNldCwgdGhpcy5fX2J5dGVPZmZzZXQgKyBzaXplKSk7DQogICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT0gc2l6ZSkNCiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Jyb2tlbicpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEludDhBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIHNpemUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGFuIHVuc2lnbmVkIEludDggYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUsDQogICAgICAgICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC4NCiAgICAgICAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFVJbnQ4QXJyYXkoc2l6ZSwgY2xvbmUgPSB0cnVlKSB7DQogICAgICAgICAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpDQogICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgbGV0IHJlc3VsdDsNCiAgICAgICAgICAgIGlmIChjbG9uZSkgew0KICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19kYXRhLnNsaWNlKHRoaXMuX19ieXRlT2Zmc2V0LCB0aGlzLl9fYnl0ZU9mZnNldCArIHNpemUpKTsNCiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSBzaXplKQ0KICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYnJva2VuJyk7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIHNpemUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGFuIHVuc2lnbmVkIEludDE2IGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLA0KICAgICAgICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuDQogICAgICAgICAqIEJ5dGUgb2Zmc2V0IGlzIGluY3JlYXNlZCBieSB0aGUgc3BlY2lmaWVkIGJ5dGUgc2l6ZSB4IDIuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgcGFyYW0uDQogICAgICAgICAqIEBwYXJhbSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkVUludDE2QXJyYXkoc2l6ZSwgY2xvbmUgPSB0cnVlKSB7DQogICAgICAgICAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpDQogICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgaWYgKHNpemUgPT0gMCkNCiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KCk7DQogICAgICAgICAgICB0aGlzLnJlYWRQYWQoMik7DQogICAgICAgICAgICBsZXQgcmVzdWx0Ow0KICAgICAgICAgICAgaWYgKHRoaXMuX19pc01vYmlsZURldmljZSkgew0KICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50MTZBcnJheShzaXplKTsNCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsNCiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gMjsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICBpZiAoY2xvbmUpIHsNCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19kYXRhLnNsaWNlKHRoaXMuX19ieXRlT2Zmc2V0LCB0aGlzLl9fYnl0ZU9mZnNldCArIHNpemUgKiAyKSk7DQogICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9IHNpemUpDQogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYnJva2VuJyk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZSAqIDI7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gcmVzdWx0Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhbiB1bnNpZ25lZCBJbnQzMiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSwNCiAgICAgICAgICogc3RhcnRpbmcgZnJvbSBjdXJyZW50IGJ5dGUgb2Zmc2V0Lg0KICAgICAgICAgKiBCeXRlIG9mZnNldCBpcyBpbmNyZWFzZWQgYnkgdGhlIHNwZWNpZmllZCBieXRlIHNpemUgeCA0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLg0KICAgICAgICAgKiBAcGFyYW0gY2xvbmUgLSBUaGUgY2xvbmUgcGFyYW0uDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFVJbnQzMkFycmF5KHNpemUsIGNsb25lID0gdHJ1ZSkgew0KICAgICAgICAgICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsNCiAgICAgICAgICAgIGlmIChzaXplID09IDApDQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSgpOw0KICAgICAgICAgICAgdGhpcy5yZWFkUGFkKDQpOw0KICAgICAgICAgICAgbGV0IHJlc3VsdDsNCiAgICAgICAgICAgIGlmICh0aGlzLl9faXNNb2JpbGVEZXZpY2UpIHsNCiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSk7DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5fX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgaWYgKGNsb25lKSB7DQogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9fZGF0YS5zbGljZSh0aGlzLl9fYnl0ZU9mZnNldCwgdGhpcy5fX2J5dGVPZmZzZXQgKyBzaXplICogNCkpOw0KICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSBzaXplKQ0KICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Jyb2tlbicpOw0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX19kYXRhLCB0aGlzLl9fYnl0ZU9mZnNldCwgc2l6ZSk7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IHNpemUgKiA0Ow0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmVhZHMgYnVmZmVyIGFuZCByZXR1cm4gYSBGbG9hdDMyIGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLA0KICAgICAgICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuDQogICAgICAgICAqIEJ5dGUgb2Zmc2V0IGlzIGluY3JlYXNlZCBieSB0aGUgc3BlY2lmaWVkIGJ5dGUgc2l6ZSB4IDQuDQogICAgICAgICAqDQogICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgcGFyYW0uDQogICAgICAgICAqIEBwYXJhbSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS4NCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkRmxvYXQzMkFycmF5KHNpemUsIGNsb25lID0gdHJ1ZSkgew0KICAgICAgICAgICAgaWYgKHNpemUgPT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsNCiAgICAgICAgICAgIGlmIChzaXplID09IDApDQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoKTsNCiAgICAgICAgICAgIHRoaXMucmVhZFBhZCg0KTsNCiAgICAgICAgICAgIGxldCByZXN1bHQ7DQogICAgICAgICAgICBpZiAodGhpcy5fX2lzTW9iaWxlRGV2aWNlKSB7DQogICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTsNCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgew0KICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSk7DQogICAgICAgICAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgaWYgKGNsb25lKSB7DQogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuc2xpY2UodGhpcy5fX2J5dGVPZmZzZXQsIHRoaXMuX19ieXRlT2Zmc2V0ICsgc2l6ZSAqIDQpKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZSAqIDQ7DQogICAgICAgICAgICB9DQogICAgICAgICAgICByZXR1cm4gcmVzdWx0Ow0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBSZXR1cm5zIG5leHQgc3RyaW5nLg0KICAgICAgICAgKiBGaXJzdCBsb29rcyBmb3IgdGhlIHN0cmluZyBsZW5ndGggZGVzY3JpcHRpb24gaW4gdGhlIG5leHQgZm91ciBieXRlcyBpbiB0aGUgYnVmZmVyKFN0YXJ0aW5nIGZyb20gYnl0ZSBvZmZzZXQpLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRTdHIoKSB7DQogICAgICAgICAgICBjb25zdCBudW1DaGFycyA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgY29uc3QgY2hhcnMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIG51bUNoYXJzKTsNCiAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IG51bUNoYXJzOw0KICAgICAgICAgICAgcmV0dXJuIHRoaXMudXRmOGRlY29kZXIuZGVjb2RlKGNoYXJzKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzLg0KICAgICAgICAgKiBGaXJzdCByZWFkaW5nIHRoZSBzaXplIG9mIHRoZSBhcnJheSB0aGVuIHJlYWRpbmcgZWFjaCBzdHJpbmcuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFN0ckFycmF5KCkgew0KICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgew0KICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMubG9hZFN0cigpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gc2lnbmVkIEludDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzIuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkU0ludDMyVmVjMigpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRTSW50MzIoKTsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRTSW50MzIoKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gdW5zaWduZWQgSW50MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRVSW50MzJWZWMyKCkgew0KICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZFVJbnQzMigpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBGbG9hdDE2IHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzIuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkRmxvYXQxNlZlYzIoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBWZWMyLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEZsb2F0MzJWZWMyKCkgew0KICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjM2Agb2JqZWN0IHdpdGggdGhlIG5leHQgdGhyZWUgRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBWZWMzLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEZsb2F0MTZWZWMzKCkgew0KICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHgsIHksIHopOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzNgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHRocmVlIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMy4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRGbG9hdDMyVmVjMygpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBRdWF0YCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MTYgdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAgICAgICAqDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgUXVhdC4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRGbG9hdDE2UXVhdCgpIHsNCiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQxNigpOw0KICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MTYoKTsNCiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmxvYWRGbG9hdDE2KCk7DQogICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQoeCwgeSwgeiwgdyk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgUXVhdGAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFF1YXQuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkRmxvYXQzMlF1YXQoKSB7DQogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHgsIHksIHosIHcpOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0aHJlZSBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIENvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFJHQkZsb2F0MzJDb2xvcigpIHsNCiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICBjb25zdCBnID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYik7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBSR0JBIGBDb2xvcmAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIENvbG9yLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZFJHQkFGbG9hdDMyQ29sb3IoKSB7DQogICAgICAgICAgICBjb25zdCByID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMubG9hZEZsb2F0MzIoKTsNCiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRGbG9hdDMyKCk7DQogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5sb2FkRmxvYXQzMigpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBDb2xvcmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdGhyZWUgdW5zaWduZWQgSW50OCB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBDb2xvci4NCiAgICAgICAgICovDQogICAgICAgIGxvYWRSR0JVSW50OENvbG9yKCkgew0KICAgICAgICAgICAgY29uc3QgciA9IHRoaXMubG9hZFVJbnQ4KCk7DQogICAgICAgICAgICBjb25zdCBnID0gdGhpcy5sb2FkVUludDgoKTsNCiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1KTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIFJHQkEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIHVuc2lnbmVkIEludDggdmFsdWVzIGluIHRoZSBidWZmZXIuDQogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgQ29sb3IuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkUkdCQVVJbnQ4Q29sb3IoKSB7DQogICAgICAgICAgICBjb25zdCByID0gdGhpcy5sb2FkVUludDgoKTsNCiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRVSW50OCgpOw0KICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMubG9hZFVJbnQ4KCk7DQogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5sb2FkVUludDgoKTsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgQm94MmAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLg0KICAgICAgICAgKiBOZXh0IGZvdXIgYmVjYXVzZSBpdCBjcmVhdGVzIHR3byBWZWMyLg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIEJveDIuDQogICAgICAgICAqLw0KICAgICAgICBsb2FkQm94MigpIHsNCiAgICAgICAgICAgIHJldHVybiBuZXcgQm94Mih0aGlzLmxvYWRGbG9hdDMyVmVjMigpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMigpKTsNCiAgICAgICAgfQ0KICAgICAgICAvKioNCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBCb3gyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBzaXggRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4NCiAgICAgICAgICogTmV4dCBmb3VyIGJlY2F1c2UgaXQgY3JlYXRlcyB0d28gVmVjMy4NCiAgICAgICAgICoNCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBCb3gzLg0KICAgICAgICAgKi8NCiAgICAgICAgbG9hZEJveDMoKSB7DQogICAgICAgICAgICByZXR1cm4gbmV3IEJveDModGhpcy5sb2FkRmxvYXQzMlZlYzMoKSwgdGhpcy5sb2FkRmxvYXQzMlZlYzMoKSk7DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIEdpdmVuIGEgc3RyaWRlZSB2YWx1ZSwgYWR2YW5jZSB0aGUgcG9pbnRlciB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN0cmlkZS4NCiAgICAgICAgICogQHBhcmFtIHN0cmlkZSAtIFRoZSBzdHJpZGUgcGFyYW0uDQogICAgICAgICAqLw0KICAgICAgICByZWFkUGFkKHN0cmlkZSkgew0KICAgICAgICAgICAgY29uc3QgcGFkID0gdGhpcy5fX2J5dGVPZmZzZXQgJSBzdHJpZGU7DQogICAgICAgICAgICBpZiAocGFkICE9IDApDQogICAgICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc3RyaWRlIC0gcGFkOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKg0KICAgICAqIENsYXNzIGRlc2lnbmVkIHRvIHN0b3JlIHZlcnNpb24gZGF0YS4gV2lkZWx5IHVzZWQgaW4gdGhlIHplYSBlbmdpbmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5Lg0KICAgICAqLw0KICAgIGNsYXNzIFZlcnNpb24gew0KICAgICAgICBtYWpvciA9IDA7DQogICAgICAgIG1pbm9yID0gMDsNCiAgICAgICAgcGF0Y2ggPSAwOw0KICAgICAgICBicmFuY2ggPSAnJzsNCiAgICAgICAgLyoqDQogICAgICAgICAqIENyZWF0ZXMgYSB2ZXJzaW9uLg0KICAgICAgICAgKiBUaGUgdmVyc2lvbiBzdHJpbmcgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6DQogICAgICAgICAqIG1ham9yLCBtaW5vciBhbmQgcGF0Y2ggc2VwYXJhdGVkIGJ5IGEgZG90KGAuYCkgYW5kIHBhcnRzIHNlcGFyYXRlZCBieSBhIGRhc2goYC1gKS4NCiAgICAgICAgICoNCiAgICAgICAgICogQHBhcmFtIGFyZyAtIFRoZSB2ZXJzaW9uIHN0cmluZyB2YWx1ZSwgb3IgYW4gYXJyYXkgb2YgdmVyc2lvbiBudW1iZXJzLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoYXJnKSB7DQogICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PSAnc3RyaW5nJykgew0KICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXJnLnNwbGl0KCctJyk7DQogICAgICAgICAgICAgICAgY29uc3QgbnVtYmVycyA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7DQogICAgICAgICAgICAgICAgdGhpcy5tYWpvciA9IHBhcnNlSW50KG51bWJlcnNbMF0pOw0KICAgICAgICAgICAgICAgIHRoaXMubWlub3IgPSBudW1iZXJzLmxlbmd0aCA+IDEgPyBwYXJzZUludChudW1iZXJzWzFdKSA6IDA7DQogICAgICAgICAgICAgICAgdGhpcy5wYXRjaCA9IG51bWJlcnMubGVuZ3RoID4gMiA/IHBhcnNlSW50KG51bWJlcnNbMl0pIDogMDsNCiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDIpDQogICAgICAgICAgICAgICAgICAgIHRoaXMuYnJhbmNoID0gcGFydHNbMV07DQogICAgICAgICAgICB9DQogICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHsNCiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJzID0gYXJnOw0KICAgICAgICAgICAgICAgIHRoaXMubWFqb3IgPSBudW1iZXJzWzBdOw0KICAgICAgICAgICAgICAgIHRoaXMubWlub3IgPSBudW1iZXJzLmxlbmd0aCA+IDEgPyBudW1iZXJzWzFdIDogMDsNCiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoID0gbnVtYmVycy5sZW5ndGggPiAyID8gbnVtYmVyc1syXSA6IDA7DQogICAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgLyoqDQogICAgICAgICAqIENvbXBhcmUgYSB2ZXJzaW9uIG9iamVjdCBhZ2FpbnN0IGEgdmVyc2lvbiBudW1iZXJzIGFycmF5Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0gbnVtYmVycyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgMyB2ZXJzaW9uIG51bWJlcnMuIFtNYWpvciwgTWlub3IsIFBhdGNoXQ0KICAgICAgICAgKiBAcmV0dXJuIC0gcmV0dXJuIHBvc2l0aXZlOiB2MSA+IHYyLCB6ZXJvOnYxID09IHYyLCBuZWdhdGl2ZTogdjEgPCB2Mg0KICAgICAgICAgKi8NCiAgICAgICAgY29tcGFyZShudW1iZXJzKSB7DQogICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82ODMyNTk2L2hvdy10by1jb21wYXJlLXNvZnR3YXJlLXZlcnNpb24tbnVtYmVyLXVzaW5nLWpzLW9ubHktbnVtYmVyDQogICAgICAgICAgICAvLyAybmQgYW5zd2VyLg0KICAgICAgICAgICAgY29uc3QgdjEgPSBbdGhpcy5tYWpvciwgdGhpcy5taW5vciwgdGhpcy5wYXRjaF07DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykgew0KICAgICAgICAgICAgICAgIGlmICh2MVtpXSAhPT0gbnVtYmVyc1tpXSkNCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYxW2ldIC0gbnVtYmVyc1tpXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHJldHVybiAwOw0KICAgICAgICB9DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDb252ZXJ0cyB0aGUgVmVyc2lvbiBjbGFzcyBpbnN0YW5jZSBiYWNrIHRvIGFuIGFycmF5IGZvciBjb21wYXJpc29ucyB3aXRoIG90aGVyIHZlcnNpb24gY2xhc3MgaW5zdGFuY2VzLg0KICAgICAgICAgKiBlLmcuDQogICAgICAgICAqIGBgYA0KICAgICAgICAgKiAgIGNvbnN0IHZlcnNpb24xID0gbmV3IFZlcnNpb24oWzEsIDIsIDNdKQ0KICAgICAgICAgKiAgIGNvbnN0IHZlcnNpb24yID0gbmV3IFZlcnNpb24oWzEsIDIsIDRdKQ0KICAgICAgICAgKiAgIGNvbnN0IHJlcyA9IHZlcnNpb24xLmNvbXBhcmUodmVyc2lvbjIuYXNBcnJheSgpKQ0KICAgICAgICAgKiBgYGANCiAgICAgICAgICogQHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbWFqb3IsIG1pbm9yIGFuZCBwYXRjaCB2ZXJzaW9uIG51bWJlcnMuDQogICAgICAgICAqLw0KICAgICAgICBhc0FycmF5KCkgew0KICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm1ham9yLCB0aGlzLm1pbm9yLCB0aGlzLnBhdGNoXTsNCiAgICAgICAgfQ0KICAgICAgICB0b1N0cmluZygpIHsNCiAgICAgICAgICAgIHJldHVybiBgdiR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YCArICh0aGlzLmJyYW5jaCAhPSAnJyA/IGAtJHt0aGlzLmJyYW5jaH1gIDogJycpOw0KICAgICAgICB9DQogICAgfQoKICAgIC8qKg0KICAgICAqIEBwcml2YXRlDQogICAgICogQGV4dGVuZHMgQmFzZUdlb20NCiAgICAgKi8NCiAgICBjbGFzcyBDb21wb3VuZEdlb21Mb2FkZXIgZXh0ZW5kcyBCYXNlR2VvbSB7DQogICAgICAgIG51bVN1Ykdlb21zID0gMDsNCiAgICAgICAgaW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KDApOw0KICAgICAgICBvZmZzZXRzID0ge307DQogICAgICAgIGNvdW50cyA9IHt9Ow0KICAgICAgICAvLyBGb3IgZWFjaCB0eXBlIG9mIGdlb20gKFRSSUFOR0xFUywgTElORVMpDQogICAgICAgIC8vIEEgbWF0ZXJpYWwgaWQsIGFuZCBlYWNoIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGJsb2NrDQogICAgICAgIG1hdGVyaWFsU3ViR2VvbXMgPSB7fTsNCiAgICAgICAgc3ViR2VvbU9mZnNldHMgPSB7fTsNCiAgICAgICAgc3ViR2VvbUNvdW50cyA9IHt9Ow0KICAgICAgICBtYXRlcmlhbExpYnJhcnlJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KDApOw0KICAgICAgICBzdWJHZW9tTWF0ZXJpYWxJbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoMCk7DQogICAgICAgIC8qKg0KICAgICAgICAgKiBDcmVhdGUgcG9pbnRzLg0KICAgICAgICAgKi8NCiAgICAgICAgY29uc3RydWN0b3IoKSB7DQogICAgICAgICAgICBzdXBlcigpOw0KICAgICAgICB9DQogICAgICAgIGdlbkJ1ZmZlcnMoKSB7DQogICAgICAgICAgICBjb25zdCBhdHRyQnVmZmVycyA9IHt9Ow0KICAgICAgICAgICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIGF0dHJdIG9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSB7DQogICAgICAgICAgICAgICAgYXR0ckJ1ZmZlcnNbYXR0ck5hbWVdID0gYXR0ci5nZW5CdWZmZXIoKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IG51bVZlcnRpY2VzID0gdGhpcy5udW1WZXJ0aWNlcygpOw0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gew0KICAgICAgICAgICAgICAgIG51bVZlcnRpY2VzLA0KICAgICAgICAgICAgICAgIG51bVJlbmRlclZlcnRzOiBudW1WZXJ0aWNlcywNCiAgICAgICAgICAgICAgICBpbmRpY2VzOiB0aGlzLmluZGljZXMsDQogICAgICAgICAgICAgICAgYXR0ckJ1ZmZlcnMsDQogICAgICAgICAgICAgICAgb2Zmc2V0czogdGhpcy5vZmZzZXRzLA0KICAgICAgICAgICAgICAgIGNvdW50czogdGhpcy5jb3VudHMsDQogICAgICAgICAgICAgICAgbnVtU3ViR2VvbXM6IHRoaXMubnVtU3ViR2VvbXMsDQogICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldHM6IHRoaXMuc3ViR2VvbU9mZnNldHMsDQogICAgICAgICAgICAgICAgc3ViR2VvbUNvdW50czogdGhpcy5zdWJHZW9tQ291bnRzLA0KICAgICAgICAgICAgICAgIG1hdGVyaWFsTGlicmFyeUluZGljZXM6IHRoaXMubWF0ZXJpYWxMaWJyYXJ5SW5kaWNlcywNCiAgICAgICAgICAgICAgICBzdWJHZW9tTWF0ZXJpYWxJbmRpY2VzOiB0aGlzLnN1Ykdlb21NYXRlcmlhbEluZGljZXMsDQogICAgICAgICAgICAgICAgbWF0ZXJpYWxTdWJHZW9tczogdGhpcy5tYXRlcmlhbFN1Ykdlb21zLA0KICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7DQogICAgICAgIH0NCiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAvLyBQZXJzaXN0ZW5jZQ0KICAgICAgICAvKioNCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IGdlb21ldHJ5KEluY2x1ZGluZyBsaW5lIHNlZ21lbnRzKSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0Lg0KICAgICAgICAgKg0KICAgICAgICAgKiBAcGFyYW0ge0JpblJlYWRlcn0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4NCiAgICAgICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLg0KICAgICAgICAgKi8NCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIsIGNvbnRleHQpIHsNCiAgICAgICAgICAgIHN1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeShyZWFkZXIsIGNvbnRleHQpOw0KICAgICAgICAgICAgY29uc3QgZ2VvbUNvdW50c0J5VHlwZSA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoMyk7DQogICAgICAgICAgICB0aGlzLm9mZnNldHNbJ1RSSUFOR0xFUyddID0gMDsNCiAgICAgICAgICAgIHRoaXMuY291bnRzWydUUklBTkdMRVMnXSA9IGdlb21Db3VudHNCeVR5cGVbMF07DQogICAgICAgICAgICB0aGlzLm9mZnNldHNbJ0xJTkVTJ10gPSBnZW9tQ291bnRzQnlUeXBlWzBdOw0KICAgICAgICAgICAgdGhpcy5jb3VudHNbJ0xJTkVTJ10gPSBnZW9tQ291bnRzQnlUeXBlWzFdOw0KICAgICAgICAgICAgdGhpcy5vZmZzZXRzWydQT0lOVFMnXSA9IGdlb21Db3VudHNCeVR5cGVbMF0gKyBnZW9tQ291bnRzQnlUeXBlWzFdOw0KICAgICAgICAgICAgdGhpcy5jb3VudHNbJ1BPSU5UUyddID0gZ2VvbUNvdW50c0J5VHlwZVsyXTsNCiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVhZGVyLmxvYWRVSW50OCgpOw0KICAgICAgICAgICAgLy8gTm90ZTogZG8gbm90IGNsb25lIHRoZSBzb3VyY2UgYXJyYXlzIGFzIHdlIHdpbGwgdHJhbnNmZXIgdGhlDQogICAgICAgICAgICAvLyBlbnRpcmUgYnVmZmVyIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkIHdoZXJlIGl0IHdpbGwgYmUgZnJlZWQgb25jZQ0KICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgdXBsb2FkZWQgdG8gdGhlIEdQVS4NCiAgICAgICAgICAgIGlmIChieXRlcyA9PSAxKQ0KICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlcyA9IHJlYWRlci5sb2FkVUludDhBcnJheSgpOw0KICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMgPT0gMikNCiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXMgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KCk7DQogICAgICAgICAgICBlbHNlIGlmIChieXRlcyA9PSA0KQ0KICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsNCiAgICAgICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLw0KICAgICAgICAgICAgLy8gVFJJQU5HTEVTIHN1Ymdlb21zDQogICAgICAgICAgICBjb25zdCBieXRlc01lc2hTdWJHZW9tcyA9IHJlYWRlci5sb2FkVUludDgoKTsNCiAgICAgICAgICAgIGxldCBzdWJHZW9tQ291bnRzTWVzaDsNCiAgICAgICAgICAgIGlmIChieXRlc01lc2hTdWJHZW9tcyA9PSAxKQ0KICAgICAgICAgICAgICAgIHN1Ykdlb21Db3VudHNNZXNoID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KCk7DQogICAgICAgICAgICBlbHNlIGlmIChieXRlc01lc2hTdWJHZW9tcyA9PSAyKQ0KICAgICAgICAgICAgICAgIHN1Ykdlb21Db3VudHNNZXNoID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheSgpOw0KICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXNNZXNoU3ViR2VvbXMgPT0gNCkNCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzTWVzaCA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsNCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdzdWJHZW9tT2Zmc2V0cyB1bmRlZmluZWQnKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IHN1Ykdlb21PZmZzZXRzTWVzaCA9IG5ldyBVaW50MzJBcnJheShzdWJHZW9tQ291bnRzTWVzaC5sZW5ndGgpOw0KICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Ykdlb21Db3VudHNNZXNoLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldHNNZXNoW2ldID0gb2Zmc2V0Ow0KICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdWJHZW9tQ291bnRzTWVzaFtpXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU9mZnNldHNbJ1RSSUFOR0xFUyddID0gc3ViR2VvbU9mZnNldHNNZXNoOw0KICAgICAgICAgICAgdGhpcy5zdWJHZW9tQ291bnRzWydUUklBTkdMRVMnXSA9IHN1Ykdlb21Db3VudHNNZXNoOw0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAvLyBMSU5FUyBzdWJnZW9tcw0KICAgICAgICAgICAgY29uc3QgYnl0ZXNMaW5lc1N1Ykdlb21zID0gcmVhZGVyLmxvYWRVSW50OCgpOw0KICAgICAgICAgICAgbGV0IHN1Ykdlb21Db3VudHNMaW5lczsNCiAgICAgICAgICAgIGlmIChieXRlc0xpbmVzU3ViR2VvbXMgPT0gMSkNCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzTGluZXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKTsNCiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzTGluZXNTdWJHZW9tcyA9PSAyKQ0KICAgICAgICAgICAgICAgIHN1Ykdlb21Db3VudHNMaW5lcyA9IHJlYWRlci5sb2FkVUludDE2QXJyYXkoKTsNCiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzTGluZXNTdWJHZW9tcyA9PSA0KQ0KICAgICAgICAgICAgICAgIHN1Ykdlb21Db3VudHNMaW5lcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsNCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdzdWJHZW9tT2Zmc2V0cyB1bmRlZmluZWQnKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGNvbnN0IHN1Ykdlb21PZmZzZXRzTGluZXMgPSBuZXcgVWludDMyQXJyYXkoc3ViR2VvbUNvdW50c0xpbmVzLmxlbmd0aCk7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Ykdlb21Db3VudHNMaW5lcy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgICAgICAgIHN1Ykdlb21PZmZzZXRzTGluZXNbaV0gPSBvZmZzZXQ7DQogICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN1Ykdlb21Db3VudHNMaW5lc1tpXTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU9mZnNldHNbJ0xJTkVTJ10gPSBzdWJHZW9tT2Zmc2V0c0xpbmVzOw0KICAgICAgICAgICAgdGhpcy5zdWJHZW9tQ291bnRzWydMSU5FUyddID0gc3ViR2VvbUNvdW50c0xpbmVzOw0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAvLyBQT0lOVFMgc3ViZ2VvbXMNCiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50c1N1Ykdlb21zID0gcmVhZGVyLmxvYWRVSW50MzIoKTsNCiAgICAgICAgICAgIGNvbnN0IHN1Ykdlb21PZmZzZXRzUG9pbnRzID0gbmV3IFVpbnQzMkFycmF5KG51bVBvaW50c1N1Ykdlb21zKTsNCiAgICAgICAgICAgIGNvbnN0IHN1Ykdlb21Db3VudHNQb2ludHMgPSBuZXcgVWludDhBcnJheShudW1Qb2ludHNTdWJHZW9tcyk7DQogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50c1N1Ykdlb21zOyBpKyspIHsNCiAgICAgICAgICAgICAgICBzdWJHZW9tT2Zmc2V0c1BvaW50c1tpXSA9IG9mZnNldDsNCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzUG9pbnRzW2ldID0gMTsNCiAgICAgICAgICAgICAgICBvZmZzZXQrKzsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU9mZnNldHNbJ1BPSU5UUyddID0gc3ViR2VvbU9mZnNldHNQb2ludHM7DQogICAgICAgICAgICB0aGlzLnN1Ykdlb21Db3VudHNbJ1BPSU5UUyddID0gc3ViR2VvbUNvdW50c1BvaW50czsNCiAgICAgICAgICAgIGlmIChjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMywgMTEsIDBdKSA+IDApIHsNCiAgICAgICAgICAgICAgICAvLyBQb2ludHMgc3ViLWdlb21zIHdlcmUgbm90IGJlaW5nIGV4cG9ydGVkIGJlZm9yZSB0aGlzIHJlbGVhc2UuDQogICAgICAgICAgICAgICAgdGhpcy5udW1TdWJHZW9tcyA9IHN1Ykdlb21Db3VudHNNZXNoLmxlbmd0aCArIHN1Ykdlb21Db3VudHNMaW5lcy5sZW5ndGggKyBudW1Qb2ludHNTdWJHZW9tczsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgIHRoaXMubnVtU3ViR2VvbXMgPSBzdWJHZW9tQ291bnRzTWVzaC5sZW5ndGggKyBzdWJHZW9tQ291bnRzTGluZXMubGVuZ3RoOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAvLyBNYXRlcmlhbHMNCiAgICAgICAgICAgIGNvbnN0IG51bU1hdGVyaWFscyA9IHJlYWRlci5sb2FkVUludDMyKCk7DQogICAgICAgICAgICBpZiAobnVtTWF0ZXJpYWxzID4gMCkgew0KICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxMaWJyYXJ5SW5kaWNlcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkobnVtTWF0ZXJpYWxzKTsNCiAgICAgICAgICAgICAgICB0aGlzLnN1Ykdlb21NYXRlcmlhbEluZGljZXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkodGhpcy5udW1TdWJHZW9tcyk7DQogICAgICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICAgICAgLy8gTWF0ZXJpYWwgR3JvdXBzDQogICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICAgICAgICAgICAgbGV0IGN1cnJNYXRlcmlhbCA9IC05OTsNCiAgICAgICAgICAgICAgICBsZXQgY3Vyck1hdGVyaWFsU3ViR2VvbSA9IG51bGw7DQogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVN1Ykdlb21zOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgbGV0IGtleTsNCiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Ykdlb21PZmZzZXQgPSAwOw0KICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuc3ViR2VvbUNvdW50cy5UUklBTkdMRVMubGVuZ3RoKSB7DQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0ZXJpYWxTdWJHZW9tcy5UUklBTkdMRVMpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFN1Ykdlb21zLlRSSUFOR0xFUyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJ1RSSUFOR0xFUyc7DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IHRoaXMuc3ViR2VvbUNvdW50cy5UUklBTkdMRVMubGVuZ3RoICsgdGhpcy5zdWJHZW9tQ291bnRzLkxJTkVTLmxlbmd0aCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldCA9IHRoaXMuc3ViR2VvbUNvdW50cy5UUklBTkdMRVMubGVuZ3RoOw0KICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJ0xJTkVTJzsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRlcmlhbFN1Ykdlb21zLkxJTkVTKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxTdWJHZW9tcy5MSU5FUyA9IFtdOw0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldCA9IHRoaXMuc3ViR2VvbUNvdW50cy5UUklBTkdMRVMubGVuZ3RoICsgdGhpcy5zdWJHZW9tQ291bnRzLkxJTkVTLmxlbmd0aDsNCiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICdQT0lOVFMnOw0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGVyaWFsU3ViR2VvbXMuUE9JTlRTKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxTdWJHZW9tcy5QT0lOVFMgPSBbXTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRlcmlhbElkID0gdGhpcy5zdWJHZW9tTWF0ZXJpYWxJbmRpY2VzW2ldOw0KICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyck1hdGVyaWFsICE9IG1hdGVyaWFsSWQpIHsNCiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJNYXRlcmlhbCA9IG1hdGVyaWFsSWQ7DQogICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBzdWJHZW9tTWF0ZXJpYWxJbmRpY2VzIGlzIFVpbnQ4QXJyYXksIGFuZCAwIG1lYW5zIG5vIGN1c3RvbQ0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0ZXJpYWwgaXMgYXNzaWduZWQgdG8gdGhlIHN1Ykdlb20uDQogICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCAxIHRvIGdldCB0aGUgYWN0dWFsIG1hdGVyaWFsIGlkLg0KICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck1hdGVyaWFsU3ViR2VvbSA9IHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbElkOiBtYXRlcmlhbElkIC0gMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsDQogICAgICAgICAgICAgICAgICAgICAgICB9Ow0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLm51bVN1Ykdlb21zOyBpKyspIHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyck1hdGVyaWFsICE9IHRoaXMuc3ViR2VvbU1hdGVyaWFsSW5kaWNlc1tpXSkgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBnZXQgdG8gdGhlIGVuZCBvZyB0aGlzIGdlb20gdHlwZSAoZS5nIC5UUklBTkdMRVMpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgYSBuZXcgc3ViZ2VvbS4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAtIHN1Ykdlb21PZmZzZXQgPT0gdGhpcy5zdWJHZW9tQ291bnRzW2tleV0ubGVuZ3RoKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRoZSBtYXRlcmlhbCBpbmRleCB0byBiZSByZXNldCBvbiBsaW5lIDE2MiBhYm92ZS4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck1hdGVyaWFsID0gLTk5Ow0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyck1hdGVyaWFsU3ViR2VvbS5jb3VudCArPSB0aGlzLnN1Ykdlb21Db3VudHNba2V5XVtpIC0gc3ViR2VvbU9mZnNldF07DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY3Vyck1hdGVyaWFsU3ViR2VvbS5jb3VudDsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxTdWJHZW9tc1trZXldLnB1c2goY3Vyck1hdGVyaWFsU3ViR2VvbSk7DQogICAgICAgICAgICAgICAgICAgICAgICBpLS07DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgLy8gTm90ZTogb2xkZXIgdmVyc2lvbiBvZiB6Y2FkIGZpbGVzIHdvdWxkIGxpc3QgbWF0ZXJpYWxzIGZvciBUUklBTkdMRVMgYW5kIExJTkVTLA0KICAgICAgICAgICAgICAgIC8vIGJ1dCBub3QgcG9pbnRzLCBsZWF2aW5nIHRoZSBwb2ludHMgdW5yZW5kZXJlZC4NCiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJHZW9tQ291bnRzLlBPSU5UUy5sZW5ndGggPiAwICYmICF0aGlzLm1hdGVyaWFsU3ViR2VvbXMuUE9JTlRTKSB7DQogICAgICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxTdWJHZW9tcy5QT0lOVFMgPSBbDQogICAgICAgICAgICAgICAgICAgICAgICB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJZDogLTEsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLnN1Ykdlb21Db3VudHMuUE9JTlRTLmxlbmd0aCwNCiAgICAgICAgICAgICAgICAgICAgICAgIH0sDQogICAgICAgICAgICAgICAgICAgIF07DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFN1Ykdlb21zID0ge307DQogICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7DQogICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuY291bnRzKSB7DQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudHNba2V5XTsNCiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkgew0KICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFN1Ykdlb21zW2tleV0gPSBbDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbElkOiAtMSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LA0KICAgICAgICAgICAgICAgICAgICAgICAgXTsNCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnLCB7fSk7DQogICAgICAgIH0NCiAgICB9CgogICAgLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovDQogICAgLy8ga2V5LCB0b2MsIGdlb21JbmRleE9mZnNldCwgZ2VvbXNSYW5nZSwgaXNNb2JpbGVEZXZpY2UsIGJ1ZmZlclNsaWNlLCBnZW5CdWZmZXJzT3B0cywgY29udGV4dA0KICAgIGNvbnN0IHBhcnNlR2VvbXNCaW5hcnkgPSAoZGF0YSwgY2FsbGJhY2spID0+IHsNCiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbg0KICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhLmNvbnRleHQudmVyc2lvbnMpIHsNCiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLmNvbnRleHQudmVyc2lvbnNba2V5XTsNCiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBuZXcgVmVyc2lvbignJyk7DQogICAgICAgICAgICB2ZXJzaW9uLm1ham9yID0gdi5tYWpvcjsNCiAgICAgICAgICAgIHZlcnNpb24ubWlub3IgPSB2Lm1pbm9yOw0KICAgICAgICAgICAgdmVyc2lvbi5wYXRjaCA9IHYucGF0Y2g7DQogICAgICAgICAgICB2ZXJzaW9uLmJyYW5jaCA9IHYuYnJhbmNoOw0KICAgICAgICAgICAgZGF0YS5jb250ZXh0LnZlcnNpb25zW2tleV0gPSB2ZXJzaW9uOw0KICAgICAgICB9DQogICAgICAgIGNvbnN0IGdlb21EYXRhcyA9IFtdOw0KICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0Ow0KICAgICAgICAvLyBjb25zb2xlLmxvZygnYnl0ZU9mZnNldDonICsgYnl0ZU9mZnNldCwgJyBnZW9tc1JhbmdlOicsIGRhdGEuZ2VvbXNSYW5nZSkNCiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdOw0KICAgICAgICBmb3IgKGxldCBpID0gZGF0YS5nZW9tc1JhbmdlWzBdOyBpIDwgZGF0YS5nZW9tc1JhbmdlWzFdOyBpKyspIHsNCiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCaW5SZWFkZXIoZGF0YS5idWZmZXJTbGljZSwgZGF0YS50b2NbaV0gLSBieXRlT2Zmc2V0LCBkYXRhLmlzTW9iaWxlRGV2aWNlKTsNCiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHJlYWRlci5sb2FkU3RyKCk7DQogICAgICAgICAgICBjb25zdCBwb3MgPSByZWFkZXIucG9zKCk7DQogICAgICAgICAgICAvLyBjb25zdCBuYW1lID0gcmVhZGVyLmxvYWRTdHIoKQ0KICAgICAgICAgICAgLy8gY29uc29sZS5sb2coDQogICAgICAgICAgICAvLyAgIGkgKw0KICAgICAgICAgICAgLy8gICAgICc6JyArDQogICAgICAgICAgICAvLyAgICAgYnl0ZU9mZnNldCArDQogICAgICAgICAgICAvLyAgICAgJyBjbGFzc05hbWU6JyArDQogICAgICAgICAgICAvLyAgICAgY2xhc3NOYW1lICsNCiAgICAgICAgICAgIC8vICAgICAnIG5hbWU6JyArDQogICAgICAgICAgICAvLyAgICAgbmFtZSAvKiArICIgcG9zOiIgKyAoZGF0YS50b2NbaV0gLSBieXRlT2Zmc2V0KSArICIgYnVmZmVyU2xpY2UuYnl0ZUxlbmd0aDoiICsgIGJ1ZmZlclNsaWNlLmJ5dGVMZW5ndGgqLw0KICAgICAgICAgICAgLy8gKQ0KICAgICAgICAgICAgbGV0IGdlb207DQogICAgICAgICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkgew0KICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50cyc6DQogICAgICAgICAgICAgICAgICAgIGdlb20gPSBuZXcgUG9pbnRzKCk7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgJ0xpbmVzJzoNCiAgICAgICAgICAgICAgICAgICAgZ2VvbSA9IG5ldyBMaW5lcygpOw0KICAgICAgICAgICAgICAgICAgICBicmVhazsNCiAgICAgICAgICAgICAgICBjYXNlICdNZXNoJzoNCiAgICAgICAgICAgICAgICAgICAgZ2VvbSA9IG5ldyBNZXNoKCk7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGNhc2UgJ0NvbXBvdW5kR2VvbSc6DQogICAgICAgICAgICAgICAgICAgIGdlb20gPSBuZXcgQ29tcG91bmRHZW9tTG9hZGVyKCk7DQogICAgICAgICAgICAgICAgICAgIGJyZWFrOw0KICAgICAgICAgICAgICAgIGRlZmF1bHQ6DQogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgR2VvbSB0eXBlOicgKyBjbGFzc05hbWUpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgdHJ5IHsNCiAgICAgICAgICAgICAgICByZWFkZXIuc2Vlayhwb3MpOyAvLyBSZXNldCB0aGUgcG9pbnRlciB0byB0aGUgc3RhcnQgb2YgdGhlIGl0ZW0gZGF0YS4NCiAgICAgICAgICAgICAgICBnZW9tLnJlYWRCaW5hcnkocmVhZGVyLCBkYXRhLmNvbnRleHQpOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY2F0Y2ggKGUpIHsNCiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvYWRpbmc6JyArIGdlb20ubmFtZSArICdcbjonICsgZSk7DQogICAgICAgICAgICAgICAgZ2VvbURhdGFzLnB1c2goe30pOw0KICAgICAgICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgY29uc3QgZ2VvbUJ1ZmZlcnMgPSBnZW9tLmdlbkJ1ZmZlcnMoZGF0YS5nZW5CdWZmZXJzT3B0cyk7DQogICAgICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgICAgICAgICAgIC8vIFRyYW5zZmVyYWJsZXMNCiAgICAgICAgICAgIC8vIFRyYW5zZmVyIGFsbCB0aGUgYXR0cmlidXRlcyBhbmQgaW5kaWNlcyBiYWNrIHRvIHRoZSBtYWluIHRocmVhZC4NCiAgICAgICAgICAgIGlmIChnZW9tQnVmZmVycy5pbmRpY2VzKQ0KICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy5pbmRpY2VzLmJ1ZmZlcik7DQogICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGdlb21CdWZmZXJzLmF0dHJCdWZmZXJzKSB7DQogICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIHR5cGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIGF0dHJpYnV0ZSBjYW4NCiAgICAgICAgICAgICAgICAvLyBub3QgYmUgdHJhbnNmZXJyZWQgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQuIENvbnZlcnQgdG8NCiAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBuYW1lIGhlcmUgYW5kIHNlbmQgYmFjayBhcyBhIHN0cmluZy4NCiAgICAgICAgICAgICAgICBjb25zdCBhdHRyRGF0YSA9IGdlb21CdWZmZXJzLmF0dHJCdWZmZXJzW2F0dHJOYW1lXTsNCiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYXR0ckRhdGEudmFsdWVzLmJ1ZmZlcik7DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBDb21wb291bmQgR2VvbSBidWZmZXJzDQogICAgICAgICAgICBpZiAoZ2VvbUJ1ZmZlcnMubWF0ZXJpYWxMaWJyYXJ5SW5kaWNlcykgew0KICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy5tYXRlcmlhbExpYnJhcnlJbmRpY2VzLmJ1ZmZlcik7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoZ2VvbUJ1ZmZlcnMuc3ViR2VvbU1hdGVyaWFsSW5kaWNlcykgew0KICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy5zdWJHZW9tTWF0ZXJpYWxJbmRpY2VzLmJ1ZmZlcik7DQogICAgICAgICAgICB9DQogICAgICAgICAgICBpZiAoZ2VvbUJ1ZmZlcnMuc3ViR2VvbU9mZnNldHMpIHsNCiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZ2VvbUJ1ZmZlcnMuc3ViR2VvbU9mZnNldHMpIHsNCiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGdlb21CdWZmZXJzLnN1Ykdlb21PZmZzZXRzW2tleV0uYnVmZmVyKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgICAvLyBpZiAoZ2VvbUJ1ZmZlcnMudmVydGV4TmVpZ2hib3JzKSB7DQogICAgICAgICAgICAvLyAgIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy52ZXJ0ZXhOZWlnaGJvcnMuYnVmZmVyKQ0KICAgICAgICAgICAgLy8gfQ0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogICAgICAgICAgICBnZW9tRGF0YXMucHVzaCh7DQogICAgICAgICAgICAgICAgbmFtZTogZ2VvbS5uYW1lLA0KICAgICAgICAgICAgICAgIHR5cGU6IGNsYXNzTmFtZSwNCiAgICAgICAgICAgICAgICBnZW9tQnVmZmVycywNCiAgICAgICAgICAgICAgICBiYm94OiBnZW9tLmdldEJvdW5kaW5nQm94KCksDQogICAgICAgICAgICB9KTsNCiAgICAgICAgfQ0KICAgICAgICBjYWxsYmFjayh7DQogICAgICAgICAgICB0YXNrSWQ6IGRhdGEudGFza0lkLA0KICAgICAgICAgICAgZ2VvbUxpYnJhcnlJZDogZGF0YS5nZW9tTGlicmFyeUlkLA0KICAgICAgICAgICAgZ2VvbUZpbGVJRDogZGF0YS5nZW9tRmlsZUlELA0KICAgICAgICAgICAgZ2VvbUluZGV4T2Zmc2V0OiBkYXRhLmdlb21JbmRleE9mZnNldCwNCiAgICAgICAgICAgIGdlb21zUmFuZ2U6IGRhdGEuZ2VvbXNSYW5nZSwNCiAgICAgICAgICAgIGdlb21EYXRhcywNCiAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7DQogICAgfTsKCiAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKHNyY0RhdGEsIHBvc3RNZXNzYWdlKSB7CiAgICAgIHBhcnNlR2VvbXNCaW5hcnkoc3JjRGF0YSwgKHJlc3VsdERhdGEsIHRyYW5zZmVyYWJsZXMpID0+IHsKICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHREYXRhLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfSk7CiAgICB9OwoKICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcnVubmluZyBpbiB0aGUgV29ya2VyIGJlZm9yZSBhc3NpZ25pbmcgb25tZXNzYWdlCiAgICBpZiAoZ2xvYmFsVGhpcy5kb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIGdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7CiAgICAgICAgaWYgKCFldmVudC5kYXRhKSB7CiAgICAgICAgICAvLyBOb3RlOiB3ZSBzZWUgdGhpcyBvY2N1ciB3aGVuIGxvYWRpbmcgb25lIGxhcmdlIGFzc2V0IG1hbnkgdGltZXMuCiAgICAgICAgICAvLyBMaWtlIHdoZW4gbG9hZGluZyB0aGUgcG9ydGFmaWwuCiAgICAgICAgICAvLyBJdCBtYXkgYmUgZHVlIHRvIG1lbW9yeSBpc3N1ZXMsIGJ1dCBpdHMgbm90IGNsZWFyLgogICAgICAgICAgY29uc29sZS53YXJuKCdHZW9tTGlicmFyeSB3b3JrZXIucG9zdE1lc3NhZ2UgZmFpbGVkLiBkYXRhIHdhcyBsb3N0IG9uIHRoZSB3YXkgdG8gdGhlIHdlYiB3b3JrZXIuJyk7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgLy8gT3VyIHdvcmtlciBnZXRzIHRyaWdnZXJlZAogICAgICAgIGlmICghZXZlbnQuZGF0YS5jb250ZXh0KSB7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhLCBzZWxmLnBvc3RNZXNzYWdlKTsKICAgICAgfTsKICAgIH0KCiAgICBleHBvcnRzLmhhbmRsZU1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlOwoKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7CgogICAgcmV0dXJuIGV4cG9ydHM7Cgp9KSh7fSk7Cgo=', null, false);
  /* eslint-enable */

  /* eslint-disable require-jsdoc */
  class GeomParserMainThread extends EventEmitter {
      constructor() {
          super();
      }
      addTask(taskData, transferables) {
          return new Promise((resolve) => {
              // @ts-ignore
              handleMessage(taskData, (results) => {
                  if (results.eventName) {
                      this.emit(results.eventName, results);
                      return;
                  }
                  resolve(results);
              });
          });
      }
  }
  class GeomParserWorkerPool extends WorkerPool {
      constructor() {
          super(true);
      }
      constructWorker() {
          const worker = new WorkerFactory$1();
          return Promise.resolve(worker);
      }
  }
  let geomParserWorkerPool;
  // In NodeJS, we don't use the workers to parse data.
  if (!globalThis.navigator) {
      geomParserWorkerPool = new GeomParserMainThread();
  }
  else {
      geomParserWorkerPool = new GeomParserWorkerPool();
  }
  // /////////////////////////////////////////////
  // GeomLibrary
  let numGeomLibraries = 0;
  /** Class representing a geometry library.
   */
  class GeomLibrary extends EventEmitter {
      assetItem;
      listenerIDs = {};
      streamInfos = {};
      genBuffersOpts = {};
      loadContext;
      numGeoms = -1;
      numGeomFiles = 1;
      geoms = [];
      basePath = '';
      loadedCount = 0;
      /**
       * Create a geom library.
       */
      constructor(assetItem) {
          super();
          this.assetItem = assetItem;
          numGeomLibraries++;
      }
      /**
       * The returns true if all the geometries have been loaded and the loaded event has already been emitted.
       * @return - True if all geometries are already loaded, else false.
       */
      isLoaded() {
          return this.numGeoms == -1 || this.loadedCount == this.numGeoms;
      }
      /**
       * Loads a single geometry file for this GeomLibrary.
       *
       * @private
       *
       * @param geomFileID - The index of the file to load
       * @param incrementProgress - If true, the progress bar is incremented and decremented.
       * @return the promise resolves once the file is loaded, but not parsed.
       */
      loadGeomFile(geomFileID, incrementProgress = false) {
          if (incrementProgress)
              resourceLoader.incrementWorkload(1);
          return new Promise((resolve) => {
              const geomFileUrl = this.basePath + geomFileID + '.zgeoms';
              resourceLoader.loadFile('archive', geomFileUrl, false).then((entries) => {
                  const geomsData = entries[Object.keys(entries)[0]];
                  const streamFileParsedListenerID = this.on('streamFileParsed', (event) => {
                      if (event.geomFileID == geomFileID) {
                          if (incrementProgress)
                              resourceLoader.incrementWorkDone(1);
                          // console.log(`GeomFileLoaded :${geomFileID} > ${this.loadedGeomFiles}/${this.numGeomFiles}`)
                          this.off('streamFileParsed', streamFileParsedListenerID);
                          resolve();
                      }
                  });
                  this.readBinaryBuffer(geomFileID, geomsData.buffer, this.loadContext);
              });
          });
      }
      /**
       * Loads the geometry files for this GeomLibrary.
       * @param geomLibraryJSON - The json data describing the data needed to be loaded by the geom library
       * @param basePath - The base path of the file. (this is theURL of the zcad file without its extension.)
       * @param context - The value param.
       */
      loadGeomFilesStream(geomLibraryJSON, basePath, context) {
          this.numGeomFiles = geomLibraryJSON.numGeomFiles
              ? geomLibraryJSON.numGeomFiles
              : geomLibraryJSON.numGeomsPerFile.length;
          resourceLoader.incrementWorkload(this.numGeomFiles);
          this.numGeoms = geomLibraryJSON.numGeoms;
          this.basePath = basePath;
          this.loadContext = context;
          for (let geomFileID = 0; geomFileID < this.numGeomFiles; geomFileID++) {
              this.loadGeomFile(geomFileID, false).finally(() => resourceLoader.incrementWorkDone());
          }
      }
      /**
       * The setGenBufferOption method.
       * @param key - The key value.
       * @param value - The value param.
       */
      setGenBufferOption(key, value) {
          this.genBuffersOpts[key] = value;
      }
      /**
       * The setNumGeoms method.
       * @param expectedNumGeoms - The expectedNumGeoms value.
       */
      setNumGeoms(expectedNumGeoms) {
          this.numGeoms = expectedNumGeoms;
      }
      /**
       * Returns the number of geometries the GeomLibrary has, or will have at the end of loading.
       * @return - The number of geometries.
       */
      getNumGeoms() {
          return this.numGeoms;
      }
      /**
       * The getGeom method.
       * @param index - The index value.
       * @return - The stored geometry
       */
      getGeom(index) {
          if (index >= this.geoms.length) {
              // console.warn("Geom index invalid:" + index);
              return null;
          }
          return this.geoms[index];
      }
      /**
       * The getGeom method.
       * @param index - The index value.
       * @return - The stored geometry
       */
      setGeom(index, geom) {
          geom.libraryIndex = index;
          this.geoms[index] = geom;
      }
      /**
       * The readBinaryBuffer method.
       * @param geomFileID - The key value.
       * @param buffer - The buffer value.
       * @param context - The context value.
       */
      readBinaryBuffer(geomFileID, buffer, context) {
          const reader = new BinReader(buffer, 0, SystemDesc.isMobileDevice);
          const numGeoms = reader.loadUInt32();
          // Geoms within a given file are offset into the array of geometries of the library.
          // Note: One day, the geom library should already know all the offsets for each file before loading.
          const geomIndexOffset = reader.loadUInt32();
          this.streamInfos[geomFileID] = {
              total: numGeoms,
              done: 0,
          };
          if (numGeoms == 0) {
              const event = new StreamFileParsedEvent(geomFileID, 0);
              this.emit('streamFileParsed', event);
              return;
          }
          if (this.numGeoms == -1) {
              // Note: for loading geom streams, we need to know the total number
              // ahead of time to be able to generate accurate progress reports.
              this.numGeoms = numGeoms;
          }
          const toc = reader.loadUInt32Array(numGeoms);
          // TODO: Use SharedArrayBuffer once available.
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer
          if (numGeomLibraries > 1 || this.numGeomFiles > 1) {
              // In scenes loading many files, we just load each file on a different worker.
              // This has one big advantage that we don't clone the buffer using the 'slice' method
              // potentially reducing temporary memory consumption by a lot.
              const geomsRange = [0, numGeoms];
              const byteOffset = 0;
              geomParserWorkerPool
                  .addTask({
                  geomFileID,
                  toc,
                  byteOffset,
                  geomIndexOffset,
                  geomsRange,
                  isMobileDevice: reader.isMobileDevice,
                  bufferSlice: buffer,
                  genBuffersOpts: this.genBuffersOpts,
                  context: {
                      versions: context.versions,
                  },
              }, [buffer])
                  .then((results) => {
                  // @ts-ignore
                  this.receiveGeomDatas(results);
              });
          }
          else {
              // Often we are loading many small files, and we want as few workloads as possible.
              // e.g. one file per worker.
              // but sometimes we are loading one big file and we need to break the file into chunks
              // to get it processed on all available cores.
              const bytesPerWorkload = 2000000;
              let offset = 0;
              while (offset < numGeoms) {
                  const bufferSliceStart = toc[offset];
                  let byteCount = 0;
                  let offsetEnd = offset;
                  while (offsetEnd < numGeoms && byteCount < bytesPerWorkload) {
                      offsetEnd++;
                      byteCount = toc[offsetEnd] - bufferSliceStart;
                  }
                  let geomsRange;
                  let bufferSliceEnd;
                  if (offsetEnd >= numGeoms) {
                      geomsRange = [offset, numGeoms];
                      bufferSliceEnd = buffer.byteLength;
                  }
                  else {
                      geomsRange = [offset, offsetEnd];
                      bufferSliceEnd = toc[geomsRange[1]];
                  }
                  const passWholeBuffer = offset == 0 && offsetEnd == numGeoms;
                  const byteOffset = passWholeBuffer ? 0 : toc[geomsRange[0]];
                  const bufferSlice = passWholeBuffer ? buffer : buffer.slice(bufferSliceStart, bufferSliceEnd);
                  offset = offsetEnd;
                  // ////////////////////////////////////////////
                  // Multi Threaded Parsing
                  geomParserWorkerPool
                      .addTask({
                      geomFileID,
                      toc,
                      byteOffset,
                      geomIndexOffset,
                      geomsRange,
                      isMobileDevice: reader.isMobileDevice,
                      bufferSlice,
                      genBuffersOpts: this.genBuffersOpts,
                      context: {
                          versions: context.versions,
                      },
                  }, [bufferSlice])
                      .then((results) => {
                      // @ts-ignore
                      this.receiveGeomDatas(results);
                  });
              }
          }
      }
      /**
       * The receiveGeomDatas method.
       * @private
       * @param data - The data received back from the web worker
       * @return - returns true once all data for this geom library has been loaded.
       */
      receiveGeomDatas(results) {
          const { geomFileID, geomDatas, geomIndexOffset, geomsRange } = results;
          // We are storing a subset of the geoms from a binary file
          // which is a subset of the geoms in an asset.
          // geomIndexOffset: the offset of the file geoms in the asset.
          // geomsRange: the range of geoms in the bin file.
          const offset = geomIndexOffset + geomsRange[0];
          const storedRange = [offset, geomIndexOffset + geomsRange[1]];
          for (let i = 0; i < geomDatas.length; i++) {
              const geomData = geomDatas[i];
              if (!geomData.type)
                  continue;
              let proxy;
              switch (geomData.type) {
                  case 'Points':
                      proxy = new PointsProxy(geomData);
                      break;
                  case 'Lines':
                      proxy = new LinesProxy(geomData);
                      break;
                  case 'Mesh':
                  case 'Plane': // TODO: Support procedural shape params
                  case 'Sphere':
                  case 'Cone':
                      proxy = new MeshProxy(geomData);
                      break;
                  case 'CompoundGeom':
                      proxy = new CompoundGeom(geomData, this.assetItem.getMaterialLibrary());
                      break;
                  default:
                      throw new Error('Unsupported Geom type:');
              }
              this.setGeom(offset + i, proxy);
          }
          const event = new RangeLoadedEvent(storedRange);
          this.emit('rangeLoaded', event);
          const loaded = storedRange[1] - storedRange[0];
          // console.log("GeomLibrary Loaded:" + loaded);
          // Each file in the stream has its own counter for the number of
          // geoms, and once each stream file finishes parsing, we fire a signal.
          const streamInfo = this.streamInfos[geomFileID];
          streamInfo.done += loaded;
          // console.log('receiveGeomDatas:', geomFileID + ' Loaded:' + streamInfo.done + ' of :' + streamInfo.total)
          if (streamInfo.done == streamInfo.total) {
              const event = new StreamFileParsedEvent(geomFileID, streamInfo.done);
              this.emit('streamFileParsed', event);
              // Emit from the resource loader so anyone can listen.
              resourceLoader.emit('streamGeomsLoaded', event);
          }
          // Once all the geoms from all the files are loaded and parsed
          // fire the loaded signal.
          this.loadedCount += loaded;
          // console.log('this.loadedCount:', this.assetItem.path, this.loadedCount, ' this.numGeoms:', this.numGeoms)
          if (this.loadedCount == this.numGeoms) {
              // console.log('GeomLibrary Loaded:', this.assetItem.path, ' loaded:', this.loadedCount)
              this.emit('loaded');
          }
          // Return true if we are done loading geoms
          // This allows the worker to be shut down and free up memory.
          return this.loadedCount == this.numGeoms;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The toJSON method encodes this type as a json object for persistence.
       * @return - Returns the json object.
       */
      toJSON() {
          return {
              numGeoms: this.geoms.length,
          };
      }
      /**
       * The toString method.
       * @return - The return value.
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }
      /**
       *
       */
      loadMetadata(data, context) {
          const reader = new BinReader(data.buffer, 0, SystemDesc.isMobileDevice);
          const toc = reader.loadUInt32Array();
          for (let i = 0; i < toc.length; i++) {
              try {
                  const geom = this.geoms[i];
                  if (!geom) {
                      console.warn('Error loading metadata for geom that was not yet loaded: ', i);
                  }
                  if (geom instanceof CompoundGeom) {
                      reader.seek(toc[i]); // Reset the pointer to the start of the item data.
                      geom.loadMetadata(reader, context);
                  }
              }
              catch (e) {
                  console.warn('Error loading geom metadata: ', i);
              }
          }
      }
  }

  /** Class representing a material library in a scene tree.
   * @private
   */
  class MaterialLibrary extends BaseItem {
      assetItem;
      images = {};
      materials = [];
      __materialsMap = {};
      constructor(assetItem) {
          super();
          this.assetItem = assetItem;
      }
      /**
       * The clear method.
       */
      clear() {
          this.images = {};
          this.materials = [];
          this.__materialsMap = {};
      }
      /**
       * The getPath method.
       * @return - The return value.
       */
      getPath() {
          if (this.assetItem instanceof BaseItem) {
              return [...this.assetItem.getPath(), 'MaterialLibrary'];
          }
          else {
              return ['MaterialLibrary'];
          }
      }
      /**
       * The resolvePath method traverses the subtree from this item down
       * matching each name in the path with a child until it reaches the
       * end of the path.
       *
       * @param path - The path value.
       * @param index - The index value.
       * @return - The return value.
       */
      resolvePath(path, index = 0) {
          if (index == 0) {
              if (path[0] == '.' || path[0] == 'MaterialLibrary')
                  index++;
          }
          // Maybe the name is a parameter name.
          const material = this.getMaterial(path[index]);
          if (material) {
              if (index < path.length) {
                  return material.resolvePath(path, index + 1);
              }
              return material;
          }
          throw new Error(`Unable to resolve path : [${path.toString()}] after: 'MaterialLibrary' \nNo material called : "${path[index]}"`);
      }
      /**
       * The getNumMaterials method.
       * @return - The return value.
       */
      getNumMaterials() {
          return this.materials.length;
      }
      /**
       * The getMaterials method.
       * @return - The return value.
       */
      getMaterials() {
          return this.materials;
      }
      /**
       * The getMaterialNames method.
       * @return - The return value.
       */
      getMaterialNames() {
          const names = [];
          this.materials.forEach((material) => {
              names.push(material.getName());
          });
          return names;
      }
      /**
       * The hasMaterial method.
       * @param name - The name value.
       * @return - The return value.
       */
      hasMaterial(name) {
          return name in this.__materialsMap;
      }
      /**
       * Add a material.
       * @param material - The material value.
       */
      addMaterial(material) {
          material.setOwner(this);
          material.libraryIndex = this.materials.length;
          this.__materialsMap[material.getName()] = this.materials.length;
          this.materials.push(material);
      }
      /**
       * The getMaterial method.
       * @param nameOrIndex - The material name or its index.
       * @param assert - The assert value.
       * @return - The return value.
       */
      getMaterial(nameOrIndex) {
          if (typeof nameOrIndex == 'string') {
              const index = this.__materialsMap[nameOrIndex];
              if (index == undefined) {
                  return null;
              }
              return this.materials[index];
          }
          else if (Number.isFinite(nameOrIndex)) {
              return this.materials[nameOrIndex];
          }
      }
      /**
       * The hasImage method.
       * @param name - The material name.
       * @return - The return value.
       */
      hasImage(name) {
          return name in this.images;
      }
      /**
       * The addImage method.
       * @param image - The image value.
       */
      addImage(image) {
          image.setOwner(this);
          this.images[image.getName()] = image;
      }
      /**
       * The getImage method.
       * @param name - The material name.
       * @param assert - The assert value.
       * @return - The return value.
       */
      getImage(name, assert = true) {
          const res = this.images[name];
          if (!res && assert) {
              throw new Error('Image:' + name + ' not found in library:' + this.getImageNames());
          }
          return res;
      }
      /**
       * The getImageNames method.
       * @return - The return value.
       */
      getImageNames() {
          const names = [];
          // eslint-disable-next-line guard-for-in
          for (const name in this.images) {
              names.push(name);
          }
          return names;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The load method.
       * @param filePath - The file path.
       */
      load(filePath) {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', filePath, true);
          xhr.ontimeout = () => {
              throw new Error('The request for ' + filePath + ' timed out.');
          };
          xhr.onload = () => {
              if (xhr.readyState === 4) {
                  if (xhr.status === 200) {
                      this.fromJSON(JSON.parse(xhr.responseText));
                  }
                  else {
                      console.warn(xhr.statusText);
                  }
              }
          };
          xhr.send(null);
      }
      /**
       * The toJSON method encodes the current object as a json object.
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context = {}) {
          const j = {
              numMaterials: this.getNumMaterials(),
              images: {},
              materials: [],
          };
          for (const key in this.images) {
              j.images[key] = this.images[key].toJSON(context);
          }
          // eslint-disable-next-line guard-for-in
          for (const material of this.materials) {
              j.materials.push(material.toJSON(context));
          }
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context = {}) {
          // eslint-disable-next-line guard-for-in
          for (const name in j.textures) {
              const image = new FileImage(name);
              image.fromJSON(j.textures[name]);
              this.images[name] = image; // TODO: texture -> image
          }
          // eslint-disable-next-line guard-for-in
          for (const name in j.materials) {
              const material = new Material(name);
              material.fromJSON(j.materials[name]);
              this.addMaterial(material);
          }
      }
      /**
       * The readBinary method.
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          // if (context.version == undefined) context.version = 0
          /*const name = */ reader.loadStr();
          const numTextures = reader.loadUInt32();
          for (let i = 0; i < numTextures; i++) {
              const type = reader.loadStr();
              const texture = Registry.constructClass(type);
              texture.readBinary(reader, context);
              this.images[texture.getName()] = texture;
          }
          const numMaterials = reader.loadUInt32();
          if (numMaterials > 0) {
              const toc = reader.loadUInt32Array(numMaterials);
              for (let i = 0; i < numMaterials; i++) {
                  const shaderName = reader.loadStr();
                  let material;
                  switch (shaderName) {
                      case 'StandardMaterial':
                      case 'TransparentMaterial':
                      case 'StandardSurfaceShader':
                          material = Registry.constructClass('StandardSurfaceMaterial');
                          break;
                      case 'SimpleSurfaceShader':
                      case 'SimpleSurfaceMaterial':
                          material = Registry.constructClass('SimpleSurfaceMaterial');
                          break;
                      case 'PointsShader':
                      case 'PointsMaterial':
                          material = Registry.constructClass('PointsMaterial');
                          break;
                      case 'FatPointsShader':
                      case 'FatPointsMaterial':
                          material = Registry.constructClass('FatPointsMaterial');
                          break;
                      case 'LinesShader':
                      case 'LinesMaterial':
                          material = Registry.constructClass('LinesMaterial');
                          break;
                      default:
                          material = new Material('');
                          break;
                  }
                  reader.seek(toc[i]); // Reset the pointer to the start of the item data.
                  material.readBinary(reader, context); // (reader, context, this.images)
                  // Note: the compound geom now looks up materials by indexes
                  // and so the index of the material in the zcad file must mow match
                  // the index in the MaterialLibrary. (GeomItem looks up materials by name.)
                  this.materials[i] = material;
                  material.libraryIndex = i;
                  this.__materialsMap[material.getName()] = i;
              }
          }
          this.emit('loaded');
      }
      /**
       * The toString method.
       * @return - The return value.
       */
      toString() {
          return JSON.stringify(this.toJSON(), null, 2);
      }
  }

  /**
   * Provides a context for loading assets. This context can provide the units of the loading scene.
   * E.g. you can specify the scene units as 'millimeters' in the context object.
   * To load external references, you can also provide a dictionary that maps filenames to URLs that are used
   * to resolve the URL of an external reference that a given asset is expecting to find.
   */
  class AssetLoadContext extends EventEmitter {
      units = 'meters';
      versions = {};
      sdk = '';
      url = '';
      folder = '';
      camera = null;
      assetItem = null;
      resources = null; // a mapping of the key to asset urls.
      xrefs = {}; // a mapping of the xrefs that have been loaded to their paths.
      xrefLoadCallback = null; // When XRefs load, this callback can be used to supply the URL for the zcad file
      lazyLoading;
      postLoadCallbacks = [];
      promisses = [];
      urlStack = [];
      assetStack = [];
      addGeomToLayer;
      /**
       * Create a AssetLoadContext
       * @param context The source context to base this context on.
       */
      constructor(context) {
          super();
          if (context) {
              this.units = context.units;
              this.sdk = context.sdk;
              this.camera = context.camera;
              this.resources = context.resources;
              this.xrefs = context.xrefs;
              this.xrefLoadCallback = context.xrefLoadCallback;
              this.urlStack = [...context.urlStack];
              this.assetStack = [...context.assetStack];
          }
      }
      /**
       * During loading, asynchronous processes may be launched, and subsequently completed.
       * These method helps the Asset track how many asynchronous loading operations may be
       * occurring with the tree during load.
       * As each external reference starts to load, it adds a promise, letting the owning
       * Asset know to wait till the children promisses are resolved before emitting its own 'loaded' event.
       */
      addPromise(promise) {
          this.promisses.push(promise);
      }
      /**
       * Resolves a path within the loading asset. This is used to connect
       * items within the tree to other items. e.g. a Group can find its members.
       * or an instance can find its source tree.
       * @param path the path within the tree relative to the loading asset
       * @param onSucceed called with the successful result of the path resolution.
       * @param onFail called when the path resolution fails.
       */
      resolvePath(path, onSucceed, onFail) {
          // Note: Why not return a Promise here?
          // Promise evaluation is always async, so
          // all promises will be resolved after the current call stack
          // has terminated. In our case, we want all paths
          // to be resolved before the end of the function, which
          // we can handle easily with callback functions.
          try {
              const item = this.assetItem.resolvePath(path);
              onSucceed(item);
          }
          catch (e) {
              // Some paths resolve to items generated during load,
              // so push a callback to re-try after the load is complete.
              this.postLoadCallbacks.push(() => {
                  try {
                      const param = this.assetItem.resolvePath(path);
                      onSucceed(param);
                  }
                  catch (e) {
                      if (onFail) {
                          onFail(e);
                      }
                      else {
                          throw new Error(e.message);
                      }
                  }
              });
          }
      }
      /**
       * Adds a function to be called back once the main load call stack exists.
       * This is used to connect parts of the tree together after loading.
       * e.g. an instance will
       * @param postLoadCallback
       */
      addPLCB(postLoadCallback) {
          this.postLoadCallbacks.push(postLoadCallback);
      }
      /**
       * Triggers the resolution of any remaining callbacks.
       * During loading, InstanceItems, or Groups may try to resolve other
       * Items, but they might not be available yet, which causes a Post
       * Load Callback (PLCB) to be registered. The last step in loading
       * should be to resolve the PLCBs.
       */
      resolvePLCBs() {
          for (const cb of this.postLoadCallbacks)
              cb();
          this.postLoadCallbacks = [];
      }
      /**
       * The clone method constructs a new AssetLoadContext, copies its values
       * from this instance and returns it.
       */
      clone() {
          return new AssetLoadContext(this);
      }
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * BaseGroup are a special type of `TreeItem` that allows you to gather/classify/organize/modify
   * multiple items contained within the group. Items can be added to the group directly, or using
   * its path.
   * All parameters set to the group are also set to the children; in other words, it's a faster way
   * to apply common things to multiple items.
   *
   * **Parameters**
   * * **Items(`ItemSetParameter`):** _todo_
   *
   * @extends TreeItem
   */
  class BaseGroup extends TreeItem {
      /**
       * @member itemsParam - TODO
       */
      itemsParam = new ItemSetParameter('Items', (item) => item instanceof TreeItem);
      itemsEventHandlers = [];
      searchRoot;
      /**
       * Creates an instance of a group.
       *
       * @param name - The name of the group.
       */
      constructor(name) {
          super(name);
          this.addParameter(this.itemsParam);
          this.itemsParam.on('itemAdded', (event) => {
              this.bindItem(event.item, event.index);
              this.emit('itemAdded', event);
          });
          this.itemsParam.on('itemRemoved', (event) => {
              this.unbindItem(event.item, event.index);
              this.emit('itemRemoved', event);
          });
      }
      // ////////////////////////////////////////
      // Visibility
      /**
       * The updateVisibility method.
       * @return - The return value.
       * @private
       */
      updateVisibility() {
          if (super.updateVisibility()) {
              const value = this.isVisible();
              Array.from(this.itemsParam.value).forEach((item) => {
                  if (item instanceof TreeItem)
                      item.propagateVisibility(value ? 1 : -1);
              });
              return true;
          }
          return false;
      }
      /**
       * Calculates the new opacity value based on the opacityParam value
       * and the lowest of the inherited opacity values.
       */
      updateOpacity() {
          super.updateOpacity();
          Array.from(this.itemsParam.value).forEach((member) => {
              member.setInheritedOpacity(this, this.opacity);
          });
      }
      // ////////////////////////////////////////
      // Highlights
      /**
       * Adds a highlight to the tree item.
       *
       * @param name - The name of the tree item.
       * @param color - The color of the highlight.
       * @param propagateToChildren - A boolean indicating whether to propagate to children.
       */
      addHighlight(name, color, propagateToChildren = true) {
          super.addHighlight(name, color, propagateToChildren);
          if (propagateToChildren) {
              Array.from(this.itemsParam.value).forEach((item) => {
                  item.addHighlight(name, color, true);
              });
          }
      }
      /**
       * Removes a highlight to the tree item.
       *
       * @param name - The name of the tree item.
       * @param propagateToChildren - A boolean indicating whether to propagate to children.
       */
      removeHighlight(name, propagateToChildren = true) {
          super.removeHighlight(name, propagateToChildren);
          if (propagateToChildren) {
              Array.from(this.itemsParam.value).forEach((item) => {
                  item.removeHighlight(name, true);
              });
          }
      }
      // ////////////////////////////////////////
      // Items
      /**
       *  sets the root item to be used as the search root.
       * @param treeItem
       */
      setSearchRoot(treeItem) {
          this.searchRoot = treeItem;
      }
      /**
       * The setOwner method assigns a new owner to the item. The owner of a group becomes its search root unless another search root is already set.
       *
       * @param ownerItem - The new owner item.
       */
      setOwner(ownerItem) {
          if (!this.searchRoot || this.searchRoot == this.getOwner())
              this.searchRoot = ownerItem;
          super.setOwner(ownerItem);
      }
      /**
       * The __bindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      bindItem(item, index) {
          if (!(item instanceof TreeItem))
              return;
          const listenerIDs = {};
          listenerIDs['pointerDown'] = item.on('pointerDown', (event) => {
              this.onPointerDown(event);
          });
          listenerIDs['pointerUp'] = item.on('pointerUp', (event) => {
              this.onPointerUp(event);
          });
          listenerIDs['pointerMove'] = item.on('pointerMove', (event) => {
              this.onPointerMove(event);
          });
          listenerIDs['pointerEnter'] = item.on('pointerEnter', (event) => {
              this.onPointerEnter(event);
          });
          listenerIDs['pointerLeave'] = item.on('pointerLeave', (event) => {
              this.onPointerLeave(event);
          });
          listenerIDs['pointerClick'] = item.on('pointerClick', (event) => {
              this.onPointerClick(event);
          });
          listenerIDs['pointerDoubleClick'] = item.on('pointerDoubleClick', (event) => {
              this.onPointerDoubleClick(event);
          });
          listenerIDs['pointerLongPress'] = item.on('pointerLongPress', (event) => {
              this.onPointerLongPress(event);
          });
          listenerIDs['BoundingBox.valueChanged'] = item.boundingBoxParam.on('valueChanged', () => {
              this.setBoundingBoxDirty();
          });
          if (!this.isVisible()) {
              // Decrement the visibility counter which might cause
              // this item to become invisible. (or it might already be invisible.)
              item.propagateVisibility(-1);
          }
          // ///////////////////////////////
          // Update the highlight
          this.highlights.forEach((name) => {
              item.addHighlight(name, this.highlightMapping[name], true);
          });
          this.itemsEventHandlers.splice(index, 0, listenerIDs);
      }
      /**
       * The unbindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      unbindItem(item, index) {
          if (!(item instanceof TreeItem))
              return;
          const listenerIDs = this.itemsEventHandlers[index];
          // eslint-disable-next-line guard-for-in
          for (let key in listenerIDs) {
              const parts = key.split('.');
              if (parts.length > 1) {
                  const param = item.getParameter(parts[0]);
                  if (param)
                      param.off(parts[1], listenerIDs[key]);
              }
              else {
                  item.off(key, listenerIDs[key]);
              }
          }
          if (!this.isVisible()) {
              // Increment the Visibility counter which might cause
              // this item to become visible.
              // It will stay invisible if its parent is invisible, or if
              // multiple groups connect to it and say it is invisible.
              item.propagateVisibility(1);
          }
          // ///////////////////////////////
          // Update the highlight
          this.highlights.forEach((name) => {
              item.removeHighlight(name, true);
          });
          this.setBoundingBoxDirty();
          this.itemsEventHandlers.splice(index, 1);
      }
      /**
       * Adds an item to the group(See `Items` parameter).
       *
       * @param item - The item value.
       * @param emit - The emit value.
       */
      addItem(item, emit = true) {
          if (!item) {
              console.warn('Error adding item to group. Item is null');
              return;
          }
          this.itemsParam.addItem(item, emit);
      }
      /**
       * Removes an item from the group(See `Items` parameter).
       *
       * @param item - The item value.
       * @param emit - The emit value.
       */
      removeItem(item, emit = true) {
          const paramItems = this.itemsParam.value;
          if (!paramItems)
              return;
          const itemIndex = Array.from(paramItems).indexOf(item);
          if (itemIndex != -1)
              this.itemsParam.removeItem(itemIndex, emit);
      }
      /**
       * Removes all items from the group.
       *
       * @param emit - `true` triggers `valueChanged` event.
       */
      clearItems(emit = true) {
          // Note: Unbind reversed so that indices
          // do not get changed during the unbind.
          const paramItems = this.itemsParam.value;
          if (!paramItems)
              return;
          const items = Array.from(paramItems);
          for (let i = items.length - 1; i >= 0; i--) {
              this.unbindItem(items[i], i);
          }
          this.itemsParam.clearItems(emit);
      }
      /**
       * Returns the list of `TreeItem` objects owned by the group.
       *
       * @return - The return value.
       */
      getItems() {
          return this.itemsParam.value;
      }
      /**
       * Sets an entire new array of items to the BaseGroup replacing any previous items.
       *
       * @param items - List of `TreeItem` you want to add to the group
       */
      setItems(items) {
          this.clearItems(false);
          this.itemsParam.setItems(items);
      }
  }

  /* eslint-disable no-unused-vars */
  // TODO:  SelectionGroup in the zea-ux should extend this class.
  /**
   * @extends BaseGroup
   */
  class SelectionSet extends BaseGroup {
      #highlightUpdateRequested = false;
      /**
       * @member highlightedParam - Whether or not the TreeItem should be highlighted.
       */
      highlightedParam = new BooleanParameter('Highlighted', false);
      /**
       * @member highlightColorParam - The color of the highlight.
       */
      highlightColorParam = new ColorParameter('HighlightColor', new Color(0.5, 0.5, 1));
      /**
       * @member highlightFillParam - TODO
       */
      highlightFillParam = new NumberParameter('HighlightFill', 0.0, [0, 1]);
      /**
       * Creates an instance of a group.
       *
       * @param name - The name of the group.
       */
      constructor(name) {
          super(name);
          this.addParameter(this.highlightedParam);
          this.highlightedParam.on('valueChanged', () => {
              this.updateHighlight();
          });
          this.addParameter(this.highlightColorParam);
          this.highlightColorParam.on('valueChanged', () => {
              this.updateHighlight();
          });
          this.addParameter(this.highlightFillParam);
          this.highlightFillParam.on('valueChanged', () => {
              this.updateHighlight();
          });
      }
      // /////////////////////////////
      /**
       * The updateHighlight method.
       * @private
       */
      updateHighlight() {
          // Make this function async so that we don't pull on the
          // graph immediately when we receive a notification.
          // Note: propagating using an operator would be much better.
          if (!this.#highlightUpdateRequested) {
              this.#highlightUpdateRequested = true;
              setTimeout(() => {
                  this.#updateHighlightHelper();
                  this.#highlightUpdateRequested = false;
              }, 0);
          }
      }
      /**
       * The updateHighlight method.
       * @private
       */
      #updateHighlightHelper() {
          let highlighted = this.highlightedParam.value;
          let color;
          if (highlighted) {
              color = this.highlightColorParam.value.clone();
              color.a = this.highlightFillParam.value;
          }
          const key = 'groupItemHighlight' + this.getId();
          Array.from(this.itemsParam.value).forEach((item) => {
              if (item instanceof TreeItem) {
                  if (highlighted)
                      item.addHighlight(key, color, true);
                  else
                      item.removeHighlight(key, true);
              }
          });
      }
      /**
       * Changes selection's state of the group with all items it owns.
       *
       * @param sel - Boolean indicating the new selection state.
       */
      setSelected(sel) {
          super.setSelected(sel);
          this.updateHighlight();
      }
      // ////////////////////////////////////////
      // Items
      /**
       * The __bindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      bindItem(item, index) {
          super.bindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          // ///////////////////////////////
          // Update the highlight
          if (item instanceof TreeItem && this.highlightedParam.value) {
              const color = this.highlightColorParam.value;
              color.a = this.highlightFillParam.value;
              item.addHighlight('groupItemHighlight' + this.getId(), color, true);
          }
      }
      /**
       * The unbindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      unbindItem(item, index) {
          super.unbindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          if (this.highlightedParam.value) {
              item.removeHighlight('groupItemHighlight' + this.getId(), true);
          }
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new group,
       * copies its values and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned group.
       */
      clone(context) {
          const cloned = new SelectionSet(this.__name + ' clone');
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('SelectionSet', SelectionSet); // TODO

  class GroupGlobalXfoOperator extends CalcGlobalXfoOperator {
      offsetXfo = new Xfo();
      bindXfo = new Xfo();
      invBindXfo = new Xfo();
      #editingPivot = false;
      groupTransformXfo = new XfoOperatorOutput('GroupTransformXfo');
      constructor(globalXfoParam, localXfoParam, groupTransformXfoParam) {
          super(globalXfoParam, localXfoParam);
          this.groupTransformXfo.setParam(groupTransformXfoParam);
          this.addOutput(this.groupTransformXfo);
      }
      set editingPivot(value) {
          this.#editingPivot = value;
          // During pivot editing, the group global does not include the
          // Local Offset Xfo. So we need to make sure it is recalcuated when
          // changing modes.
          this.setDirty();
      }
      get editingPivot() {
          return this.#editingPivot;
      }
      /**
       * Create a GroupMemberXfoOperator operator.
       * @param bindXfo - The Bind Xfo calculated from the initial Transforms of the Group Members.
       */
      setBindXfo(bindXfo) {
          this.bindXfo = bindXfo;
          this.invBindXfo = bindXfo.inverse();
          this.setDirty();
      }
      /**
       * The backPropagateValue method inverts the mathematics of the 'evaluate'
       * method so it can propagate the value backwards to its inputs.
       * @param value - the new value being set on the output GlobalXfo
       */
      backPropagateValue(value) {
          let parentGlobalXfo;
          if (this.parentGlobal.isConnected()) {
              parentGlobalXfo = this.parentGlobal.getValue();
          }
          else {
              parentGlobalXfo = new Xfo();
          }
          if (this.editingPivot) {
              this.bindXfo = value;
              this.invBindXfo = this.bindXfo.inverse();
              this.offsetXfo = parentGlobalXfo.inverse().multiply(this.bindXfo);
              this.setDirty();
          }
          else {
              const parentGlobalWithOffsetXfo = parentGlobalXfo.multiply(this.offsetXfo);
              this.localXfo.setValue(parentGlobalWithOffsetXfo.inverse().multiply(value));
          }
      }
      /**
       * The evaluate method calculates a new global Xfo based on the parents Global Xfo,
       * and the local Xfo value.
       */
      evaluate() {
          let parentGlobalWithOffsetXfo;
          if (this.parentGlobal.isConnected()) {
              const parentGlobalXfo = this.parentGlobal.getValue();
              parentGlobalWithOffsetXfo = parentGlobalXfo.multiply(this.offsetXfo);
          }
          else {
              parentGlobalWithOffsetXfo = this.offsetXfo;
          }
          if (this.editingPivot) {
              let globalXfo = parentGlobalWithOffsetXfo;
              this.globalXfo.setClean(globalXfo);
              const groupTransformXfo = globalXfo.multiply(this.localXfo.getValue()).multiply(this.invBindXfo);
              this.groupTransformXfo.setClean(groupTransformXfo);
          }
          else {
              let globalXfo = parentGlobalWithOffsetXfo.multiply(this.localXfo.getValue());
              this.globalXfo.setClean(globalXfo);
              const groupTransformXfo = globalXfo.multiply(this.invBindXfo);
              this.groupTransformXfo.setClean(groupTransformXfo);
          }
      }
  }
  /** An operator for modifying group members by the groups Xfo
   * @private
   * @extends Operator
   *
   */
  class GroupMemberXfoOperator extends Operator {
      #enabled;
      groupTransformXfo = new XfoOperatorInput('GroupTransformXfo');
      memberGlobalXfo = new XfoOperatorOutput('MemberGlobalXfo', exports.OperatorOutputMode.OP_READ_WRITE);
      /**
       * Create a GroupMemberXfoOperator operator.
       * @param groupTransformXfoParam - The parameter on the Group which defines the displacement to apply to the members.
       * @param memberXfoGlobalParam - The GlobalXfo param found on the Member.
       */
      constructor(groupTransformXfoParam, memberXfoGlobalParam) {
          super();
          this.groupTransformXfo.setParam(groupTransformXfoParam);
          this.memberGlobalXfo.setParam(memberXfoGlobalParam);
          this.addInput(this.groupTransformXfo);
          this.addOutput(this.memberGlobalXfo);
          this.#enabled = true;
      }
      /**
       * used to temporarily disable/enable the operator when the Group bind Xfo is being calculated
       */
      disable() {
          this.#enabled = false;
          this.setDirty();
      }
      /**
       * used to temporarily disable/enable the operator when the Group bind Xfo is being calculated
       */
      enable() {
          this.#enabled = true;
          this.setDirty();
      }
      /**
       * The evaluate method.
       */
      evaluate() {
          const memberGlobalXfo = this.memberGlobalXfo.getValue();
          if (this.#enabled) {
              const groupTransformXfo = this.groupTransformXfo.getValue();
              this.memberGlobalXfo.setClean(groupTransformXfo.multiply(memberGlobalXfo));
          }
          else {
              this.memberGlobalXfo.setClean(memberGlobalXfo);
          }
      }
      /**
       * When the value on a Parameter is modified by a user by calling 'setValue,
       * then if any operators are bound, the value of the Parameter cannot be modified
       * directly as it is the result of a computation. Instead, the Parameter calls
       * 'backPropagateValue' on the Operator to cause the Operator to handle propagating
       * the value to one or more of its inputs.
       * to its inputs.
       * @param value - The value param.
       * @return - The modified value.
       */
      backPropagateValue(value) {
          if (this.#enabled) {
              const invGroupTransformXfo = this.groupTransformXfo.getValue().inverse();
              return invGroupTransformXfo.multiply(value);
          }
          return value;
      }
  }

  /* eslint-disable no-unused-vars */
  const GROUP_XFO_MODES = {
      disabled: 0,
      manual: 1,
      first: 2,
      average: 3,
      globalOri: 4,
  };
  /**
   * The KinematicGroup is used to control the transform of a collection of objects int eh scene.
   * Objects can be added to a kinematic group and then the group can be transformed, causing each
   * of the members to be transformed as one.
   *
   **Parameters**
   * **InitialXfoMode(`MultiChoiceParameter`):** _todo_
   * **GroupTransform(`XfoParameter`):** _todo_
   *
   * @extends BaseGroup
   */
  class KinematicGroup extends BaseGroup {
      calculatingGroupXfo;
      memberXfoOps;
      #highlightUpdateRequested = false;
      /**
       * @member initialXfoModeParam - TODO
       */
      initialXfoModeParam = new MultiChoiceParameter('InitialXfoMode', GROUP_XFO_MODES.average, [
          'manual',
          'first',
          'average',
          'global',
      ]);
      /**
       * @member groupTransformParam - Provides the transformation Xfo that is applied to each Group Member.
       */
      groupTransformParam = new XfoParameter('GroupTransform', new Xfo());
      /**
       * @member highlightedParam - Whether or not the TreeItem should be highlighted.
       */
      highlightedParam = new BooleanParameter('Highlighted', false);
      /**
       * @member highlightColorParam - The color of the highlight.
       */
      highlightColorParam = new ColorParameter('HighlightColor', new Color(1, 1, 0));
      /**
       * @member highlightFillParam - TODO
       */
      highlightFillParam = new NumberParameter('HighlightFill', 0.0, [0, 1]);
      /**
       * Creates an instance of a group.
       *
       * @param name - The name of the group.
       */
      constructor(name = '') {
          super(name);
          // Items which can be constructed by a user (not loaded in binary data.)
          this.calculatingGroupXfo = false;
          this.memberXfoOps = [];
          this.addParameter(this.initialXfoModeParam);
          this.initialXfoModeParam.on('valueChanged', () => {
              this.calcGroupXfo();
          });
          this.addParameter(this.groupTransformParam);
          this.addParameter(this.highlightedParam);
          this.highlightedParam.on('valueChanged', () => {
              this.#updateHighlight();
          });
          this.addParameter(this.highlightColorParam);
          this.highlightColorParam.on('valueChanged', () => {
              this.#updateHighlight();
          });
          this.addParameter(this.highlightFillParam);
          this.highlightFillParam.on('valueChanged', () => {
              this.#updateHighlight();
          });
          this.globalXfoOp = new GroupGlobalXfoOperator(this.globalXfoParam, this.localXfoParam, this.groupTransformParam);
      }
      /**
       * Returns enum of available xfo modes.
       *
       * | Name | Default |
       * | --- | --- |
       * | manual | <code>0</code> |
       * | first | <code>1</code> |
       * | average | <code>2</code> |
       * | globalOri | <code>3</code> |
       */
      static get INITIAL_XFO_MODES() {
          return GROUP_XFO_MODES;
      }
      /**
       * Returns bind Xfo that is used to compute the groupTransform
       * Note: The Bind Xfo is determined by the 'GROUP_XFO_MODES' value.
       */
      get bindXfo() {
          return this.globalXfoOp.bindXfo;
      }
      /**
       * The updateHighlight method.
       * @private
       */
      #updateHighlight() {
          // Make this function async so that we don't pull on the
          // graph immediately when we receive a notification.
          // Note: propagating using an operator would be much better.
          if (!this.#highlightUpdateRequested) {
              this.#highlightUpdateRequested = true;
              setTimeout(() => {
                  this.#updateHighlightHelper();
                  this.#highlightUpdateRequested = false;
              }, 0);
          }
      }
      #updateHighlightHelper() {
          let highlighted = this.highlightedParam.value;
          let color;
          if (highlighted) {
              color = this.highlightColorParam.value.clone();
              color.a = this.highlightFillParam.value;
          }
          const key = 'groupItemHighlight' + this.getId();
          Array.from(this.itemsParam.value).forEach((item) => {
              if (item instanceof TreeItem) {
                  if (highlighted)
                      item.addHighlight(key, color, true);
                  else
                      item.removeHighlight(key, true);
              }
          });
      }
      // ////////////////////////////////////////
      // Global Xfo
      /**
       * Calculate the group Xfo translate.
       * @private
       * @return - Returns a new Xfo.
       */
      calcGroupXfo() {
          const items = Array.from(this.itemsParam.value);
          if (items.length == 0)
              return;
          this.editingPivot = true;
          // TODO: Disable the group operator?
          const initialXfoMode = this.initialXfoModeParam.value;
          let xfo;
          if (initialXfoMode == GROUP_XFO_MODES.manual) {
              // The xfo is manually set by the current global xfo.
              xfo = this.globalXfoParam.value;
          }
          else if (initialXfoMode == GROUP_XFO_MODES.first && items[0] instanceof TreeItem) {
              xfo = items[0].globalXfoParam.value;
          }
          else if (initialXfoMode == GROUP_XFO_MODES.average) {
              xfo = new Xfo();
              xfo.ori.set(0, 0, 0, 0);
              let numTreeItems = 0;
              items.forEach((item, index) => {
                  if (item instanceof TreeItem) {
                      const itemXfo = item.globalXfoParam.value;
                      xfo.tr.addInPlace(itemXfo.tr);
                      // Note: Averaging rotations causes weird and confusing orientation.
                      // This also matches the behavior of the SelectionGroupXfoOperator in zea-ux.
                      if (index == 0)
                          xfo.ori = itemXfo.ori;
                      numTreeItems++;
                  }
              });
              xfo.tr.scaleInPlace(1 / numTreeItems);
              xfo.ori.normalizeInPlace();
              // xfo.sc.scaleInPlace(1/ numTreeItems);
          }
          else if (initialXfoMode == GROUP_XFO_MODES.globalOri) {
              xfo = new Xfo();
              let numTreeItems = 0;
              items.forEach((item, index) => {
                  if (item instanceof TreeItem) {
                      const itemXfo = item.globalXfoParam.value;
                      xfo.tr.addInPlace(itemXfo.tr);
                      numTreeItems++;
                  }
              });
              xfo.tr.scaleInPlace(1 / numTreeItems);
          }
          else {
              throw new Error('Invalid GROUP_XFO_MODES.');
          }
          this.globalXfoParam.value = xfo;
          this.editingPivot = false;
      }
      get editingPivot() {
          return this.globalXfoOp.editingPivot;
      }
      set editingPivot(value) {
          this.globalXfoOp.editingPivot = value;
      }
      // ////////////////////////////////////////
      // Items
      /**
       * The __bindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      bindItem(item, index) {
          super.bindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          const memberGlobalXfoParam = item.globalXfoParam;
          const memberXfoOp = new GroupMemberXfoOperator(this.groupTransformParam, memberGlobalXfoParam);
          this.memberXfoOps.splice(index, 0, memberXfoOp);
          if (this.highlightedParam.value) {
              const color = this.highlightColorParam.value;
              color.a = this.highlightFillParam.value;
              item.addHighlight('groupItemHighlight' + this.getId(), color, true);
          }
      }
      /**
       * The unbindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      unbindItem(item, index) {
          super.unbindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          this.memberXfoOps[index].detach();
          this.memberXfoOps.splice(index, 1);
          if (this.highlightedParam.value) {
              item.removeHighlight('groupItemHighlight' + this.getId(), true);
          }
      }
      /**
       * Adds an item to the group(See `Items` parameter).
       *
       * @param item - The item value.
       * @param emit - The emit value.
       */
      addItem(item, emit = true) {
          super.addItem(item, emit);
          if (emit) {
              this.calcGroupXfo();
          }
      }
      /**
       * Removes an item from the group(See `Items` parameter).
       *
       * @param item - The item value.
       * @param emit - The emit value.
       */
      removeItem(item, emit = true) {
          super.removeItem(item, emit);
          if (emit) {
              this.calcGroupXfo();
          }
      }
      /**
       * Sets an entire new array of items to the BaseGroup replacing any previous items.
       *
       * @param items - List of `TreeItem` you want to add to the group
       */
      setItems(items) {
          super.setItems(items); // TODO: originally: super.setItems(emit) -- should emit be done here?
          this.calcGroupXfo();
      }
      /**
       * Removes all items from the group.
       *
       * @param emit - `true` triggers `valueChanged` event.
       */
      clearItems(emit = true) {
          super.clearItems(emit);
          this.memberXfoOps = [];
          if (emit) {
              this.calcGroupXfo();
          }
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new group,
       * copies its values and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned group.
       */
      clone(context) {
          const cloned = new KinematicGroup();
          cloned.copyFrom(this, context);
          return cloned;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Encodes the current object as a json object.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context) {
          const json = super.toJSON(context);
          json.bindXfo = this.globalXfoOp.bindXfo.toJSON();
          const groupGlobalXfoOperator = this.globalXfoOp;
          json.offsetXfo = groupGlobalXfoOperator.offsetXfo.toJSON();
          return json;
      }
      /**
       * Decodes a json object for this type.
       *
       * @param json - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(json, context) {
          super.fromJSON(json, context);
          const xfo = new Xfo();
          xfo.fromJSON(json.bindXfo);
          const groupGlobalXfoOperator = this.globalXfoOp;
          groupGlobalXfoOperator.setBindXfo(xfo);
          if (json.offsetXfo) {
              groupGlobalXfoOperator.offsetXfo.fromJSON(json.offsetXfo);
          }
      }
  }
  Registry.register('KinematicGroup', KinematicGroup);

  /* eslint-disable no-unused-vars */
  /**
   *
   * **Parameters**
   * * **Material(`MaterialParameter`):** _todo_
   *
   * @extends BaseGroup
   */
  class MaterialGroup extends BaseGroup {
      // TODO: should BaseGroup have the materialParam?
      /**
       * @member materialParam - The Material to use when rendering this GeomItem
       */
      materialParam = new MaterialParameter('Material');
      __backupMaterials = {};
      /**
       * Creates an instance of a group.
       *
       * @param name - The name of the group.
       */
      constructor(name) {
          super(name);
          this.addParameter(this.materialParam);
          this.materialParam.on('valueChanged', () => {
              this.updateMaterial();
          });
      }
      // /////////////////////////////
      /**
       * The updateHighlight method.
       * @private
       */
      updateHighlight() {
          // Make this function async so that we don't pull on the
          // graph immediately when we receive a notification.
          // Note: propagating using an operator would be much better.
          // setTimeout(() => {}, 0)
          // TODO: make this async
          this.updateHighlightHelper();
      }
      /**
       * The updateHighlight method.
       * @private
       */
      updateHighlightHelper() {
          let highlighted = false;
          let color;
          if (this.isSelected()) {
              color = this.getHighlight();
              highlighted = true;
              color.a = 0.2;
          }
          const key = 'kinematicGroupItemHighlight' + this.getId();
          Array.from(this.itemsParam.value).forEach((item) => {
              if (item instanceof TreeItem) {
                  if (highlighted)
                      item.addHighlight(key, color, true);
                  else
                      item.removeHighlight(key, true);
              }
          });
      }
      /**
       * Changes selection's state of the group with all items it owns.
       *
       * @param sel - Boolean indicating the new selection state.
       */
      setSelected(sel) {
          super.setSelected(sel);
          this.updateHighlight();
      }
      // ////////////////////////////////////////
      // Materials
      /**
       * The updateOpacity method.
       */
      updateOpacity() {
          super.updateOpacity();
          Array.from(this.itemsParam.value).forEach((item) => {
              if (item instanceof TreeItem) {
                  item.opacityParam.value = this.opacity;
              }
          });
      }
      /**
       * The updateMaterial method.
       * @private
       */
      updateMaterial() {
          // Make this function async so that we don't pull on the
          // graph immediately when we receive a notification.
          // Note: propagating using an operator would be much better.
          // setTimeout(() => {}, 0)
          // TODO: make async
          this.updateMaterialHelper();
      }
      /**
       * The updateMaterial method.
       * @private
       */
      updateMaterialHelper() {
          const material = this.materialParam.value;
          // TODO: Bind an operator
          Array.from(this.itemsParam.value).forEach((item) => {
              item.traverse((treeItem) => {
                  if (treeItem instanceof BaseGeomItem) {
                      const baseGeomItem = treeItem;
                      const p = baseGeomItem.materialParam;
                      if (material) {
                          const m = p.value;
                          // TODO: How do we filter material assignments? this is a nasty hack.
                          // but else we end up assigning surface materials to our edges.
                          if (m != material && (!m || m.getShaderName() != 'LinesShader')) {
                              this.__backupMaterials[p.getId()] = m;
                              p.value = material;
                          }
                      }
                      else if (this.__backupMaterials[p.getId()]) {
                          p.value = this.__backupMaterials[p.getId()];
                      }
                  }
              });
          });
      }
      // ////////////////////////////////////////
      // Items
      /**
       * The __bindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      bindItem(item, index) {
          super.bindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          // ///////////////////////////////
          // Update the highlight
          if (this.isSelected()) {
              const color = this.getHighlight();
              color.a = 0.2;
              const key = 'materialGroupItemHighlight' + this.getId();
              item.addHighlight(key, color, true);
          }
          // ///////////////////////////////
          // Update the Material
          const material = this.materialParam.value;
          if (material) {
              // TODO: Bind an operator instead
              item.traverse((treeItem) => {
                  if (treeItem instanceof BaseGeomItem) {
                      const baseGeomItem = treeItem;
                      const p = baseGeomItem.materialParam;
                      if (material) {
                          const m = p.value;
                          // TODO: How do we filter material assignments? this is a nasty hack.
                          // but else we end up assigning surface materials to our edges.
                          if (m != material && (!m || m.getShaderName() != 'LinesShader')) {
                              this.__backupMaterials[p.getId()] = m;
                              p.value = material;
                          }
                      }
                  }
              }, true);
          }
          item.opacityParam.value = this.opacity;
      }
      /**
       * The unbindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      unbindItem(item, index) {
          super.unbindItem(item, index);
          if (!(item instanceof TreeItem))
              return;
          if (this.isSelected()) {
              const key = 'materialGroupItemHighlight' + this.getId();
              item.removeHighlight(key, true);
          }
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new group,
       * copies its values and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned group.
       */
      clone(context) {
          const cloned = new MaterialGroup(this.__name + 'clone');
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('MaterialGroup', MaterialGroup);

  /**
   * An operator that calculates the delta transform of the group since items were bound to it.
   * @extends Operator
   *
   */
  class CuttingPlaneOperator extends Operator {
      groupGlobalXfo = new XfoOperatorInput('GroupGlobalXfo');
      cuttingPlane = new Vec4OperatorOutput('CuttingPlane');
      /**
       * Create a GroupMemberXfoOperator operator.
       * @param groupGlobalXfoParam - The GlobalXfo param found on the Group.
       * @param cuttingPlaneParam - The parameter on the Group which defines the displacement to apply to the members.
       */
      constructor(groupGlobalXfoParam, cuttingPlaneParam) {
          super();
          this.groupGlobalXfo.setParam(groupGlobalXfoParam);
          this.cuttingPlane.setParam(cuttingPlaneParam);
          this.addInput(this.groupGlobalXfo);
          this.addOutput(this.cuttingPlane);
      }
      /**
       * The evaluate method.
       */
      evaluate() {
          const groupGlobalXfo = this.groupGlobalXfo.getValue();
          const vec = groupGlobalXfo.ori.getZaxis();
          const dist = groupGlobalXfo.tr.dot(vec);
          this.cuttingPlane.setClean(new Vec4(vec.x, vec.y, vec.z, -dist));
      }
  }

  /* eslint-disable no-unused-vars */
  /**
   * Groups are a special type of `BaseGroup` that allows you to gather/classify/organize/modify
   * multiple items contained within the group. Items can be added to the group directly, or using
   * its path.
   * All parameters set to the group are also set to the children; in other words, it's a faster way
   * to apply common things to multiple items.
   *
   * **Parameters**
   * * **CutAwayEnabled(`BooleanParameter`):** _todo_
   * * **CutPlaneNormal(`Vec3Parameter`):** _todo_
   * * **CutPlaneDist(`NumberParameter`):** _todo_
   *
   * @extends BaseGroup
   */
  class CuttingPlane extends BaseGroup {
      cutPlaneOp;
      cutAwayEnabledParam = new BooleanParameter('CutAwayEnabled', false);
      cutPlaneParam = new Vec4Parameter('CutPlane', new Vec4(1, 0, 0));
      /**
       * Creates an instance of a group.
       *
       * @param name - The name of the group.
       */
      constructor(name = '') {
          super(name);
          this.addParameter(this.cutAwayEnabledParam);
          this.addParameter(this.cutPlaneParam);
          this.cutPlaneOp = new CuttingPlaneOperator(this.globalXfoParam, this.cutPlaneParam);
          this.cutAwayEnabledParam.on('valueChanged', (event) => {
              this.updateCutaway(event);
          });
          this.cutPlaneParam.on('valueChanged', (event) => {
              this.updateCutaway(event);
          });
          // Create the geometry to display the plane.
          const material = new Material('plane', 'FlatSurfaceShader');
          material.getParameter('BaseColor').value = new Color(1, 1, 1, 0.2);
          const plane = new GeomItem(`PlaneGeom`, new Plane(1, 1), material);
          plane.setSelectable(false);
          this.addChild(plane);
          const borderMaterial = new Material('border', 'LinesShader');
          borderMaterial.getParameter('BaseColor').value = new Color(1, 0, 0, 1);
          const border = new GeomItem(`BorderGeom`, new Rect(1, 1), borderMaterial);
          border.setSelectable(false);
          this.addChild(border);
      }
      // ////////////////////////////////////////
      // Cutaways
      /**
       * The updateCutaway method.
       * @param item - The item in the group.
       * @private
       */
      updateCutaway(item) {
          // Make this function async so that we don't pull on the
          // graph immediately when we receive a notification.
          // Note: making this async broke the tests.
          // Note: propagating using an operator would be much better.
          // setTimeout(() => {
          const cutEnabled = this.cutAwayEnabledParam.value;
          const cutPlane = this.cutPlaneParam.value;
          const cutAwayVector = cutPlane.xyz;
          const cutAwayDist = cutPlane.w;
          if (item instanceof BaseGeomItem) {
              item.setCutawayEnabled(cutEnabled);
              item.setCutVector(cutAwayVector);
              item.setCutDist(cutAwayDist);
          }
          else {
              Array.from(this.itemsParam.value).forEach((item) => {
                  item.traverse((item) => {
                      if (item instanceof BaseGeomItem) {
                          item.setCutawayEnabled(cutEnabled);
                          item.setCutVector(cutAwayVector);
                          item.setCutDist(cutAwayDist);
                      }
                  }, true);
              });
          }
          // }, 0)
      }
      // ////////////////////////////////////////
      // Items
      /**
       * The __bindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      bindItem(item, index) {
          if (!(item instanceof TreeItem))
              return;
          // ///////////////////////////////
          // Update the item cutaway
          const cutEnabled = this.cutAwayEnabledParam.value;
          if (cutEnabled) {
              this.updateCutaway(item);
          }
          const bbox = new Box3();
          // const xfo = this.globalXfoParam.value
          // const invxfo = xfo.inverse()
          Array.from(this.itemsParam.value).forEach((item) => {
              if (item instanceof TreeItem) {
                  // const itemxfo = invxfo.multiply(item.globalXfoParam.value)
                  // bbox.addBox3(item.boundingBoxParam.value, itemxfo.toMat4())
                  bbox.addBox3(item.boundingBoxParam.value);
              }
          });
          {
              const sizex = bbox.p1.x - bbox.p0.x;
              const sizey = bbox.p1.y - bbox.p0.y;
              const xfo = new Xfo();
              xfo.sc.set(sizex, sizey, 1);
              this.getChild(0).localXfoParam.value = xfo;
              this.getChild(1).localXfoParam.value = xfo;
          }
      }
      /**
       * The unbindItem method.
       * @param item - The item value.
       * @param index - The index value.
       * @private
       */
      unbindItem(item, index) {
          if (!(item instanceof TreeItem))
              return;
          // ///////////////////////////////
          // Update the item cutaway
          item.traverse((treeItem) => {
              if (treeItem instanceof BaseGeomItem) {
                  treeItem.setCutawayEnabled(false);
              }
          }, true);
      }
      // ////////////////////////////////////////
      // Clone
      /**
       * The clone method constructs a new group,
       * copies its values and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned group.
       */
      clone(context) {
          const cloned = new CuttingPlane();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('CuttingPlane', CuttingPlane);

  /**
   * Given a units string, load returns a factor relative to meters
   * e.g. for Millimeters, returns 0.001, for Meters, returns 1.0
   * Given 2 different units, the factors are combined together to calculate the conversion between the 2 units.
   * @param units the name of the units value for the load context.
   * Supports: ['millimeters', 'centimeters', 'decimeters', 'meters', 'kilometers', 'inches', 'feet', 'miles']
   * @return Returns the factor relative to meters.
   */
  const getUnitsFactor = (units) => {
      switch (units.toLowerCase()) {
          case 'millimeters':
              return 0.001;
          case 'centimeters':
              return 0.01;
          case 'decimeters':
              return 0.1;
          case 'meters':
              return 1.0;
          case 'kilometers':
              return 1000.0;
          case 'inches':
              return 0.0254;
          case 'feet':
              return 0.3048;
          case 'miles':
              return 1609.34;
      }
      return 1.0;
  };

  /**
   * Represents a TreeItem with rendering and material capabilities.
   *
   * @extends TreeItem
   */
  class AssetItem extends TreeItem {
      geomLibrary = new GeomLibrary(this);
      materialLibrary = new MaterialLibrary(this);
      loaded = false;
      engineDataVersion;
      unitsScale = 1.0;
      units = 'meters';
      /**
       * Create an asset item.
       * @param name - The name of the asset item.
       */
      constructor(name = '') {
          super(name);
      }
      /**
       * Loads all the geometries and metadata from the asset file.
       * @param url - The URL of the asset to load
       * @return - Returns a promise that resolves once the initial load is complete
       */
      load(url) {
          return Promise.reject(`This method is not implemented for this Asset Item: ${url}`);
      }
      /**
       * Returns the loaded status of current item.
       *
       * @return - Returns true if the asset has already loaded its data.
       */
      isLoaded() {
          return this.loaded;
      }
      /**
       * Returns the zea engine version as an array with major, minor, patch order.
       *
       * @return - The return value.
       */
      getEngineDataVersion() {
          return this.engineDataVersion;
      }
      /**
       * Returns asset `GeomLibrary` that is in charge of rendering geometry data using workers.
       *
       * @return - The return value.
       */
      getGeometryLibrary() {
          return this.geomLibrary;
      }
      /**
       * Returns `MaterialLibrary` that is in charge of storing all materials of current Item.
       *
       * @return - The return value.
       */
      getMaterialLibrary() {
          return this.materialLibrary;
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * The readBinary method.
       * @param reader - The reader value.
       * @param context - The context value.
       */
      readBinary(reader, context) {
          context.assetItem = this;
          if (!context.units)
              context.units = 'meters';
          if (!context.versions['zea-engine']) {
              context.versions['zea-engine'] = new Version(reader.loadStr());
          }
          this.engineDataVersion = context.versions['zea-engine'];
          // console.log('Loading file version:', this.engineDataVersion.toString(), ' generated using :', context.sdk)
          const loadUnits = () => {
              this.units = reader.loadStr();
              // console.log('File units:', this.units)
              // Add this param so it is displayed in the CADViewer.
              this.addParameter(new StringParameter('FileUnits', this.units));
              // Calculate a scale factor to convert
              // the asset units to the units of the context we are loading in.
              if (this.units != context.units) {
                  const unitsFactor = getUnitsFactor(this.units);
                  const contextUnitsFactor = getUnitsFactor(context.units);
                  this.unitsScale = unitsFactor / contextUnitsFactor;
              }
              // The context propagates the new units to children assets.
              // This means that a child asset applies a unitsScale relative to this asset.
              context.units = this.units;
              // Apply units change to existing Xfo (avoid changing tr).
              const localXfoParam = this.localXfoParam;
              const xfo = localXfoParam.value;
              xfo.sc.scaleInPlace(this.unitsScale);
              localXfoParam.value = xfo;
          };
          if (context.versions['zea-engine'].compare([0, 0, 6]) > 0) {
              // Loading units modifies our Xfo, which then propagates up
              // the tree forcing a re-computation. Better just do it at
              // the start.
              loadUnits();
          }
          let layerRoot;
          const layers = {};
          context.addGeomToLayer = (geomItem, layer) => {
              if (!layers[layer]) {
                  if (!layerRoot) {
                      layerRoot = new TreeItem('Layers');
                      this.addChild(layerRoot, false);
                  }
                  const group = new BaseGroup(layer);
                  layerRoot.addChild(group, false);
                  layers[layer] = group;
              }
              layers[layer].addItem(geomItem);
          };
          this.materialLibrary.readBinary(reader, context);
          super.readBinary(reader, context);
          if (context.versions['zea-engine'].compare([0, 0, 5]) >= 0 &&
              context.versions['zea-engine'].compare([0, 0, 7]) < 0) {
              loadUnits();
          }
          // Invoke all the post-load callbacks to resolve any
          // remaining references.
          context.resolvePLCBs();
          this.loaded = true;
      }
      /** Checks if this item or its subtree have finished loading their geometries. */
      haveGeomsLoaded() {
          if (!this.geomLibrary.isLoaded())
              return false;
          let result = true;
          this.traverse((item) => {
              if (item instanceof AssetItem) {
                  if (!item.haveGeomsLoaded()) {
                      result = false;
                  }
                  // Stop the depth first traversal at each AsseItem, as the
                  // 'haveGeomsLoaded' call has already recursivly checked that subtree.
                  return false;
              }
              // As soon as we have one false value, we can stop traversal
              return result;
          }, false);
          return result;
      }
      /**
       * The toJSON method encodes this type as a json object for persistence.
       *
       * @param context - The context value.
       * @return - Returns the json object.
       */
      toJSON(context = {}) {
          context.makeRelative = (path) => {
              const assetPath = this.getPath();
              const start = path.slice(0, assetPath.length);
              for (let i = 0; i < start.length - 1; i++) {
                  if (start[i] != assetPath[i]) {
                      console.warn('Param Path is not relative to the asset. May not be able to be resolved at load time:' + path);
                      return path;
                  }
              }
              // Relative paths start with a symbol for the root element.
              const relativePath = path.slice(assetPath.length - 1);
              relativePath[0] = '.';
              return relativePath;
          };
          context.assetItem = this;
          const j = super.toJSON(context);
          j.materialLibrary = this.materialLibrary.toJSON();
          return j;
      }
      /**
       * The fromJSON method decodes a json object for this type.
       *
       * @param j - The json object this item must decode.
       * @param context - The context value.
       */
      fromJSON(j, context = new AssetLoadContext()) {
          context.assetItem = this;
          this.materialLibrary.fromJSON(j.materialLibrary, context);
          super.fromJSON(j, context);
          // Invoke all the post-load callbacks to resolve any
          // remaining references.
          context.resolvePLCBs();
      }
      // ////////////////////////////////////////
      // Clone and Destroy
      /**
       * The clone method constructs a new tree item, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned tree item.
       */
      clone(context) {
          const cloned = new AssetItem();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Copies current TreeItem with all its children.
       *
       * @param src - The tree item to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          this.geomLibrary = src.geomLibrary;
          this.materialLibrary = src.materialLibrary;
          this.units = src.units;
          super.copyFrom(src, context);
          this.loaded = src.loaded;
          if (!src.loaded) {
              src.once('loaded', () => {
                  this.units = src.units;
                  const srcLocalXfo = src.localXfoParam.value;
                  const localXfo = this.localXfoParam.value;
                  localXfo.sc = srcLocalXfo.sc.clone();
                  this.localXfoParam.value = localXfo;
                  // Note: An XRef stored in an assembly may contain a cache of its subtree.
                  // If the XRef url does resolve to a file, we must clear this cache before loading the actual data.
                  this.removeAllChildren();
                  src.getChildren().forEach((srcChildItem) => {
                      this.addChild(srcChildItem.clone(context), false, false);
                  });
                  this.loaded = true;
                  this.emit('loaded');
                  // We cn only determine if the geoms are loaded, after the initial tree is loaded.
                  // As we clone a subtree that may contain asset items. (happens when loading XRefs)
                  // The cloned tree needs to emit events when the source tree emits its events.
                  if (!src.haveGeomsLoaded()) {
                      src.once('geomsLoaded', () => this.emit('geomsLoaded'));
                  }
                  else {
                      this.emit('geomsLoaded');
                  }
              });
          }
          else {
              this.emit('loaded');
              if (!src.haveGeomsLoaded()) {
                  src.once('geomsLoaded', () => this.emit('geomsLoaded'));
              }
              else {
                  this.emit('geomsLoaded');
              }
          }
      }
  }
  Registry.register('AssetItem', AssetItem);

  /**
   * A special type of TreeItem(Item with hierarchical abilities) class that represents a banner in a 2D dimension.
   * Can own any type of `BaseImage`.
   * **Parameters**
   * * **Image(`ImageParameter`):** Is the BaseImage you want to display on the board.
   * * **PixelsPerMeter(`NumberParameter`):** Quality and Size of the board. The bigger the number, the smaller the board.
   * * **Alpha(`NumberParameter`):** Transparency of the board, from 0 to 1.
   * * **AlignedToCamera(`BooleanParameter`):** Faces or not the board to the camera at all time(Moves with camera movement).
   * * **DrawOnTop(`BooleanParameter`):** The billboards are rendered overlaid on the scene.
   * * **FixedSizeOnscreen(`BooleanParameter`):** The billboards are rendered at a fixed size on screen, regardless of the distance to the billboard.
   *
   * @extends TreeItem
   */
  class BillboardItem extends TreeItem {
      /**
       * Creates a billboard item.
       *
       * @param name - The name of the billboard item.
       * @param image - The image value.
       */
      /**
       * @member imageParam - Is the BaseImage you want to display on the board.
       */
      imageParam = new ImageParameter('Image');
      /**
       * @member pixelsPerMeterParam - Quality and Size of the board. The bigger the number, the smaller the board.
       */
      pixelsPerMeterParam = new NumberParameter('PixelsPerMeter', 1000.0);
      /**
       * @member alphaParam - Transparency of the board, from 0 to 1.
       */
      alphaParam = new NumberParameter('Alpha', 1.0);
      /**
       * @member colorParam - The color of the billboard
       */
      colorParam = new ColorParameter('Color', new Color(1.0, 1.0, 1.0));
      /**
       * @member alignedToCameraParam - Faces or not the board to the camera at all time(Moves with camera movement).
       */
      alignedToCameraParam = new BooleanParameter('AlignedToCamera', false);
      /**
       * @member drawOnTopParam - The billboards are rendered overlaid on the scene.
       */
      drawOnTopParam = new BooleanParameter('DrawOnTop', false);
      /**
       * @member fixedSizeOnscreenParam - The billboards are rendered at a fixed size on screen, regardless of the distance to the billboard.
       */
      fixedSizeOnscreenParam = new BooleanParameter('FixedSizeOnscreen', false);
      /**
       * @member pivotParam - Where the pivot of the billboard is.
       */
      pivotParam = new Vec2Parameter('Pivot', new Vec2(0.5, 0.0));
      constructor(name, image) {
          super(name);
          const imageParamResult = this.addParameter(this.imageParam);
          if (image)
              imageParamResult.value = image; // Note: this dirties the param and will ensure it is saved to JSON
          this.addParameter(this.pixelsPerMeterParam);
          this.addParameter(this.alphaParam);
          this.addParameter(this.colorParam);
          this.addParameter(this.alignedToCameraParam);
          this.addParameter(this.drawOnTopParam);
          this.addParameter(this.fixedSizeOnscreenParam);
          this.addParameter(this.pivotParam);
      }
  }
  Registry.register('BillboardItem', BillboardItem);

  /* eslint-disable no-unused-vars */
  /**
   * The Camera class is used to provide a point of view of the scene. The viewport is assigned
   * a camera, which is uses during drawing. The camera controls the view and projection used to
   * render the scene.
   *
   * Cameras can provide a perspective projection, or an orthographic projection, and anything in between.
   * To configure whether th projection provided by the camera is Orthographic or Perspective, set
   * the value of the 'isOrthographic' Parameter to a value between 0 and 1. 0.0 being fully perspective
   * and 1.0 being fully Orthographic.
   * Alternatively, you can call camera.setIsOrthographic and pass the value, and a time in milliseconds to
   * take to transition between the current value and your new value.
   * ```javascript
   *   camera.setIsOrthographic(1, 400);
   * ```
   *
   * By default, the Camera automatically adjusts the near and far planes as the focal distance is modified. This
   * behavior can be disabled, by setting the adjustNearAndFarPlanesToFocalDist property to false.
   * Alternatively, you can also adjust the factors that are used to modify the near and far plane based on the
   * focal distance.
   * ```javascript
   *   camera.adjustNearAndFarPlanesToFocalDist = true
   *   camera.nearDistFactor = 0.01
   *   camera.farDistFactor = 5
   * ```
   *
   * **Parameters**
   * * **isOrthographic(`NumberParameter`):** Controls the projection matrix generated by the camera. A value of 0.0, means a perspective projection, while 1 an orthographic projection. Any value in between generates a blended perspective -> orthographic projection.
   * * **fov(`NumberParameter`):** The vertical angle of the view frustum when generating a perspective projection. In orthographic mode, this value is used to calculate the size of the view at the target distance.
   * * **near(`NumberParameter`):** The near clipping distance of the camera.
   * * **far(`NumberParameter`):** The far clipping distance of the camera.
   * * **focalDistance(`NumberParameter`):** The distance at which the camera is focussed. Note: the CameraManipulator sets the focal distance when zooming in on a target.
   *
   * **Events**
   * * **projectionParamChanged:** When on of the parameters above change, the camera emits this event. Note: the Viewport listens to this event and triggers re-rendering.
   * * **movementFinished:** Triggered at the conclusion of some action. E.g. when a zoom action is finished, or when the mouse is released after an orbit action. The viewport listens to this event and triggers a re-rendering of the selection buffers.
   *
   * @extends TreeItem
   */
  class Camera extends TreeItem {
      isOrthographicParam = new NumberParameter('isOrthographic', 0.0);
      fovParam = new NumberParameter('fov', 1.0);
      nearParam = new NumberParameter('near', 0.1);
      farParam = new NumberParameter('far', 1000.0);
      focalDistanceParam = new NumberParameter('focalDistance', 5.0);
      // Controls whether the camera automatically adjusts the near and far planes
      // as the focal distance changes. Set to false to explicitly control the near
      // and far planes.
      adjustNearAndFarPlanesToFocalDist = true;
      // The factor by which the near plane is adjusted based on the focal distance.
      nearDistFactor = 0.01;
      // The factor by which the far plane is adjusted based on the focal distance.
      farDistFactor = 100;
      frameOnBoundingSphere = false;
      viewHeight = 0;
      intervalId = -1;
      /**
       * Instantiates a camera object, setting default configuration like zoom, target and positioning.
       *
       * @param name - The name of the camera.
       */
      constructor(name = 'Camera') {
          super(name);
          this.addParameter(this.isOrthographicParam);
          this.addParameter(this.fovParam);
          this.addParameter(this.nearParam);
          this.addParameter(this.farParam);
          this.addParameter(this.focalDistanceParam);
          const emitProjChanged = (event) => {
              this.emit('projectionParamChanged', event);
          };
          this.isOrthographicParam.on('valueChanged', emitProjChanged);
          this.fovParam.on('valueChanged', emitProjChanged);
          this.nearParam.on('valueChanged', emitProjChanged);
          this.farParam.on('valueChanged', emitProjChanged);
          // Initial viewing coords of a person standing 3 meters away from the
          // center of the stage looking at something 1 meter off the ground.
          this.setPositionAndTarget(new Vec3(3, 3, 1.75), new Vec3(0, 0, 1));
          this.setLensFocalLength('28mm');
      }
      // ////////////////////////////////////////////
      // Getters/setters.
      /**
       * Returns `near` parameter value.
       *
       * @return - Returns the near value.
       */
      getNear() {
          return this.nearParam.value;
      }
      /**
       * Sets `near` parameter value
       *
       * @param value - The near value.
       */
      setNear(value) {
          this.nearParam.value = value;
      }
      /**
       * Returns `far` parameter value.
       *
       * @return - Returns the far value.
       */
      getFar() {
          return this.farParam.value;
      }
      /**
       * Sets `far` parameter value
       *
       * @param value - The far value.
       */
      setFar(value) {
          this.farParam.value = value;
      }
      /**
       * Getter for the camera field of view (FOV).
       * The FOV defines the vertical angle of the view frustum
       * The horizontal angle is calculated from the FOV and the Viewport aspect ratio.
       *
       * @return - Returns the FOV value.
       */
      getFov() {
          return this.fovParam.value;
      }
      /**
       * Setter for the camera field of view (FOV).
       * The FOV defines the vertical angle of the view frustum
       * The horizontal angle is calculated from the FOV and the Viewport aspect ratio.
       * > Note: The Fov can also be set by calling #setLensFocalLength
       *
       * @param value - The new FOV value.
       */
      setFov(value) {
          this.fovParam.value = value;
      }
      /**
       * Getter for the camera frustum height value.
       * The frustum hight value is used to compute the orthographic projection of the scene.
       *
       * @return - Returns the Frustum Height value.
       */
      getFrustumHeight() {
          return this.viewHeight;
      }
      /**
       * Setter for the camera frustum height in orthographic mode.
       * > Note: in perspective mode, the frustum height is calculated based on the FOV value and focal distance.
       *
       * @param value - The new Frustum Height value.
       */
      setFrustumHeight(value) {
          this.viewHeight = value;
          this.emit('projectionParamChanged');
      }
      /**
       * Setter for the camera lens focal length. This method calculates a new vertical Field of View value
       * from the provided camera lense focal length.
       * > Note: conversion from Lense Focal length to Fov is based on the table found here: https://www.nikonians.org/reviews/fov-tables
       *
       * **Focal Length accepted values as string values:** 10mm, 11mm, 12mm, 14mm, 15mm, 17mm, 18mm,
       * 19mm, 20mm, 24mm, 28mm, 30mm, 35mm, 45mm, 50mm, 55mm, 60mm, 70mm, 75mm, 80mm,
       * 85mm, 90mm, 100mm, 105mm, 120mm, 125mm, 135mm, 150mm, 170mm, 180mm, 210mm, 300mm,
       * 400mm, 500mm, 600mm, 800mm
       *
       * @param value - The lens focal length value.
       */
      setLensFocalLength(value) {
          // https://www.nikonians.org/reviews/fov-tables
          const mapping = {
              '10mm': 100.4,
              '11mm': 95.0,
              '12mm': 90.0,
              '14mm': 81.2,
              '15mm': 77.3,
              '17mm': 70.4,
              '18mm': 67.4,
              '19mm': 64.6,
              '20mm': 61.9,
              '24mm': 53.1,
              '28mm': 46.4,
              '30mm': 43.6,
              '35mm': 37.8,
              '45mm': 29.9,
              '50mm': 27.0,
              '55mm': 24.6,
              '60mm': 22.6,
              '70mm': 19.5,
              '75mm': 18.2,
              '80mm': 17.1,
              '85mm': 16.1,
              '90mm': 15.2,
              '100mm': 13.7,
              '105mm': 13.0,
              '120mm': 11.4,
              '125mm': 11.0,
              '135mm': 10.2,
              '150mm': 9.1,
              '170mm': 8.1,
              '180mm': 7.6,
              '210mm': 6.5,
              '300mm': 4.6,
              '400mm': 3.4,
              '500mm': 2.7,
              '600mm': 2.3,
              '800mm': 1.7,
          };
          if (!(value in mapping)) {
              console.warn('Camera lense focal length not supported:' + value);
              return;
          }
          this.fovParam.value = MathFunctions.degToRad(mapping[value]);
      }
      /**
       * Returns `focalDistance` parameter value.
       *
       * @return - Returns the lens focal length value..
       */
      getFocalDistance() {
          return this.focalDistanceParam.value;
      }
      /**
       * Sets `focalDistance` parameter value.
       *
       * @errors on dist value lower or less than zero.
       * @param dist - The focal distance value.
       */
      setFocalDistance(dist) {
          if (dist < 0.0001)
              console.error('Never set focal distance to zero');
          this.focalDistanceParam.value = dist;
          if (this.adjustNearAndFarPlanesToFocalDist) {
              this.nearParam.value = dist * this.nearDistFactor;
              this.farParam.value = dist * this.farDistFactor;
          }
      }
      /**
       * Returns true if the camera is providing an orthographic projection.
       * @return - true if orthographic else false
       */
      isOrthographic() {
          return this.isOrthographicParam.value == 1.0;
      }
      /**
       * Sets the camera to be orthographic. The value can be between 0, and 1.
       * A value of 0 means fully perspective. A value of 1 means fully orthographic.
       * Any value in between produces a linear interpolation of perspective and orthographic.
       *
       * @param value - The value param.
       * @param duration - The duration in milliseconds to change the projection.
       */
      setIsOrthographic(value, duration = 0) {
          if (this.intervalId)
              clearInterval(this.intervalId);
          if (value > 0.5) {
              const fov = this.fovParam.value;
              const focalDistance = this.focalDistanceParam.value;
              this.viewHeight = Math.sin(fov * 0.5) * focalDistance * 2;
          }
          if (duration == 0) {
              this.isOrthographicParam.value = value;
          }
          else {
              const count = Math.round(duration / 20); // each step is 20ms
              let i = 0;
              const prevValue = this.isOrthographicParam.value;
              const applyMovement = () => {
                  i++;
                  const lerpValue = MathFunctions.lerp(prevValue, value, i / count);
                  this.isOrthographicParam.value = lerpValue;
                  if (i < count) {
                      this.intervalId = window.setTimeout(applyMovement, 20);
                  }
                  else {
                      this.intervalId = -1;
                      this.emit('movementFinished');
                  }
              };
              applyMovement();
          }
      }
      /**
       * Setter for the camera position and target.
       * As described at the start of the class, this is a `TreeItem`,
       * which means we can move it around using translation modifiers.
       * You can do it this way or using the changing `TreeItem` parameters,
       * although we recommend this one because it also changes focal distance.
       *
       * @param position - The position of the camera.
       * @param target - The target of the camera.
       */
      setPositionAndTarget(position, target) {
          this.setFocalDistance(position.distanceTo(target));
          const xfo = new Xfo();
          xfo.setLookAt(position, target, new Vec3(0.0, 0.0, 1.0));
          this.globalXfoParam.value = xfo;
          this.emit('movementFinished');
      }
      /**
       * Getter for the target position.
       * @return - Returns the target position.
       */
      getTargetPosition() {
          const focalDistance = this.focalDistanceParam.value;
          const xfo = this.globalXfoParam.value;
          const target = xfo.ori.getZaxis();
          target.scaleInPlace(-focalDistance);
          target.addInPlace(xfo.tr);
          return target;
      }
      // ///////////////////////////
      /**
       * Calculates a new camera position that frames all the items passed in `treeItems` array, moving
       * the camera to a point where we can see all of them.
       *
       * @param viewport - The viewport value.
       * @param treeItems - The treeItems value.
       * @param duration - The duration of time to apply the frame. A value of 0 specifies an instantaneous movement of the camera.
       * @param frameBorder - The variable to use to provide an empty space around the border for geometries.
       */
      frameView(viewport, treeItems, duration = 0, frameBorder = 0.1) {
          const focalDistance = this.focalDistanceParam.value;
          const fovY = this.fovParam.value;
          const newGlobalXfo = this.globalXfoParam.value.clone();
          const aspectRatio = viewport.getWidth() / viewport.getHeight();
          const fovX = Math.atan(Math.tan(fovY * 0.5) * aspectRatio) * 2.0;
          let newFocalDistance = focalDistance;
          if (this.frameOnBoundingSphere) {
              const box3 = new Box3();
              for (const treeItem of treeItems) {
                  box3.addBox3(treeItem.boundingBoxParam.value);
              }
              if (!box3.isValid()) {
                  console.warn('Bounding box not valid.');
                  return;
              }
              const cameraViewVec = newGlobalXfo.ori.getZaxis();
              const targetOffset = cameraViewVec.scale(-focalDistance);
              const currTarget = newGlobalXfo.tr.add(targetOffset);
              const newTarget = box3.center();
              const pan = newTarget.subtract(currTarget);
              newGlobalXfo.tr.addInPlace(pan);
              // Compute the distance the camera should be to fit the entire bounding sphere
              newFocalDistance = box3.size() / Math.tan(fovY);
              // const dollyDist = newFocalDistance - focalDistance
              // newGlobalXfo.tr.addInPlace(cameraViewVec.scale(dollyDist))
          }
          else {
              // Based on the solution described here:
              // https://stackoverflow.com/a/66113254/5546902
              const boundaryPoints = [];
              {
                  treeItems.forEach((treeItem) => {
                      treeItem.traverse((childItem) => {
                          // Stop traversal when we hig an item with a disabled bounding box
                          // or non-tree item.
                          if (!(childItem instanceof TreeItem))
                              return false;
                          if (childItem.disableBoundingBox)
                              return false;
                          if (!childItem.isVisible() || !childItem.isSelectable())
                              return false;
                          if (childItem instanceof GeomItem) {
                              const geom = childItem.geomParam.value;
                              if (geom) {
                                  const box3 = geom.getBoundingBox();
                                  if (box3.isValid()) {
                                      const mat4 = childItem.geomMatParam.value;
                                      boundaryPoints.push(mat4.transformVec3(box3.p0));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p0.x, box3.p0.y, box3.p1.z)));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p0.x, box3.p1.y, box3.p0.z)));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p1.x, box3.p0.y, box3.p0.z)));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p0.x, box3.p1.y, box3.p1.z)));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p1.x, box3.p0.y, box3.p1.z)));
                                      boundaryPoints.push(mat4.transformVec3(new Vec3(box3.p1.x, box3.p1.y, box3.p0.z)));
                                      boundaryPoints.push(mat4.transformVec3(box3.p1));
                                      return;
                                  }
                              }
                          }
                          if (childItem.getNumChildren() == 0) {
                              const box3 = childItem.boundingBoxParam.value;
                              if (box3.isValid()) {
                                  // Note: passing box3.p0 into boundaryPoints caused corruption later on.
                                  // I could not figure out how/why, but by constructing a new vector here,
                                  // we avoid the problem.
                                  boundaryPoints.push(new Vec3(box3.p0.x, box3.p0.y, box3.p0.z));
                                  boundaryPoints.push(new Vec3(box3.p0.x, box3.p0.y, box3.p1.z));
                                  boundaryPoints.push(new Vec3(box3.p0.x, box3.p1.y, box3.p0.z));
                                  boundaryPoints.push(new Vec3(box3.p1.x, box3.p0.y, box3.p0.z));
                                  boundaryPoints.push(new Vec3(box3.p0.x, box3.p1.y, box3.p1.z));
                                  boundaryPoints.push(new Vec3(box3.p1.x, box3.p0.y, box3.p1.z));
                                  boundaryPoints.push(new Vec3(box3.p1.x, box3.p1.y, box3.p0.z));
                                  boundaryPoints.push(new Vec3(box3.p1.x, box3.p1.y, box3.p1.z));
                                  return;
                              }
                          }
                      });
                  });
              }
              if (boundaryPoints.length == 0)
                  return;
              const angleX = this.isOrthographic() ? 0 : fovX / 2;
              const angleY = this.isOrthographic() ? 0 : fovY / 2;
              const frustumPlaneNormals = {};
              frustumPlaneNormals.XPos = new Vec3(Math.cos(angleX), 0, Math.sin(angleX));
              frustumPlaneNormals.XNeg = new Vec3(-Math.cos(angleX), 0, Math.sin(angleX));
              frustumPlaneNormals.YPos = new Vec3(0, Math.cos(angleY), Math.sin(angleY));
              frustumPlaneNormals.YNeg = new Vec3(0, -Math.cos(angleY), Math.sin(angleY));
              frustumPlaneNormals.ZPos = new Vec3(0, 0, 1);
              frustumPlaneNormals.ZNeg = new Vec3(0, 0, -1);
              const frustumPlaneNormalsWs = {};
              const frustumPlaneOffsets = {};
              // eslint-disable-next-line guard-for-in
              for (const key in frustumPlaneNormals) {
                  frustumPlaneNormalsWs[key] = newGlobalXfo.ori.rotateVec3(frustumPlaneNormals[key]);
                  frustumPlaneOffsets[key] = Number.NEGATIVE_INFINITY;
              }
              const centroid = new Vec3();
              boundaryPoints.forEach((point, index) => {
                  // Previously we had corrupt values coming through there. That is fixed,
                  // but just in case, we filter them out again here.
                  if (!Number.isFinite(point.x) || !Number.isFinite(point.y) || !Number.isFinite(point.z)) {
                      return;
                  }
                  const delta = point.subtract(newGlobalXfo.tr);
                  // eslint-disable-next-line guard-for-in
                  for (const key in frustumPlaneNormals) {
                      const planeOffset = delta.dot(frustumPlaneNormalsWs[key]);
                      if (planeOffset > frustumPlaneOffsets[key] && planeOffset != Number.POSITIVE_INFINITY) {
                          frustumPlaneOffsets[key] = planeOffset;
                      }
                  }
                  centroid.addInPlace(point);
              });
              // eslint-disable-next-line guard-for-in
              // Check for invalid planes.
              for (const key in frustumPlaneOffsets) {
                  if (frustumPlaneOffsets[key] == Number.POSITIVE_INFINITY)
                      return;
              }
              centroid.scaleInPlace(1 / boundaryPoints.length);
              let dolly = 0;
              if (this.isOrthographic()) {
                  const pan = new Vec3((-frustumPlaneOffsets.XNeg + frustumPlaneOffsets.XPos) * 0.5, (-frustumPlaneOffsets.YNeg + frustumPlaneOffsets.YPos) * 0.5, (-frustumPlaneOffsets.ZNeg + frustumPlaneOffsets.ZPos) * 0.5);
                  // Move the camera back by 2x the depth range of the scene.
                  const zrange = frustumPlaneOffsets.ZNeg + frustumPlaneOffsets.ZPos;
                  dolly = zrange * 2;
                  pan.z = -frustumPlaneOffsets.ZNeg + dolly;
                  newGlobalXfo.tr.addInPlace(newGlobalXfo.ori.rotateVec3(pan));
                  newFocalDistance = zrange * 2;
                  const viewWidth = frustumPlaneOffsets.XPos + frustumPlaneOffsets.XNeg;
                  const viewHeight = frustumPlaneOffsets.YPos + frustumPlaneOffsets.YNeg;
                  this.viewHeight = Math.max(viewHeight, viewWidth / aspectRatio);
                  this.viewHeight += this.viewHeight * frameBorder;
              }
              else {
                  const angleX = fovX / 2;
                  const angleY = fovY / 2;
                  // Now we solve the problem in 2D. For each camera plane (XZ and YZ), we calculate the lines in 2d that
                  // represent the frustum planes for the top and bottom, adjusted so they touch the boundary points. We
                  // then find the intersection of these 2 2d lines to calculate the adjustment in that axis for the camera.
                  // We need to dolly back to fix the plane which needs the most adjustment.
                  // Calculate a 2d point on the line for each plane, and a direction.
                  const xP0 = new Vec2(Math.cos(angleX) * frustumPlaneOffsets.XPos, Math.sin(angleX) * frustumPlaneOffsets.XPos);
                  const xP1 = xP0.add(new Vec2(Math.sin(angleX), -Math.cos(angleX)));
                  const xP2 = new Vec2(-Math.cos(angleX) * frustumPlaneOffsets.XNeg, Math.sin(angleX) * frustumPlaneOffsets.XNeg);
                  const xP3 = xP2.add(new Vec2(-Math.sin(angleX), -Math.cos(angleX)));
                  const xP = Vec2.intersectionOfLines(xP0, xP1, xP2, xP3);
                  const yP0 = new Vec2(Math.cos(angleY) * frustumPlaneOffsets.YPos, Math.sin(angleY) * frustumPlaneOffsets.YPos);
                  const yP1 = yP0.add(new Vec2(Math.sin(angleY), -Math.cos(angleY)));
                  const yP2 = new Vec2(-Math.cos(angleY) * frustumPlaneOffsets.YNeg, Math.sin(angleY) * frustumPlaneOffsets.YNeg);
                  const yP3 = yP2.add(new Vec2(-Math.sin(angleY), -Math.cos(angleY)));
                  const yP = Vec2.intersectionOfLines(yP0, yP1, yP2, yP3);
                  if (xP === null || yP === null) {
                      console.warn('xP or yP === null');
                      return;
                  }
                  dolly = Math.max(xP.y, yP.y);
                  const pan = new Vec3(xP.x, yP.x, dolly);
                  newGlobalXfo.tr.addInPlace(newGlobalXfo.ori.rotateVec3(pan));
                  newFocalDistance = centroid.distanceTo(newGlobalXfo.tr);
                  const frameBorderAdjustment = newFocalDistance * frameBorder;
                  newGlobalXfo.tr.addInPlace(newGlobalXfo.ori.rotateVec3(new Vec3(0, 0, frameBorderAdjustment)));
                  dolly += frameBorderAdjustment;
              }
              if (this.adjustNearAndFarPlanesToFocalDist) {
                  frustumPlaneOffsets.ZPos -= dolly;
                  frustumPlaneOffsets.ZNeg += dolly;
                  const near = frustumPlaneOffsets.ZNeg * this.nearDistFactor;
                  const far = -frustumPlaneOffsets.ZPos * this.farDistFactor;
                  this.nearParam.value = near;
                  this.farParam.value = far;
              }
          }
          if (duration == 0) {
              this.setFocalDistance(newFocalDistance);
              this.globalXfoParam.value = newGlobalXfo;
              this.emit('movementFinished');
          }
          else {
              if (this.intervalId > 0)
                  window.clearTimeout(this.intervalId);
              const count = Math.round(duration / 20); // each step is 20ms
              let i = 0;
              const prevFocalDistance = this.focalDistanceParam.value;
              const prevXfo = this.globalXfoParam.value;
              const applyMovement = () => {
                  i++;
                  const t = i / count;
                  const focalDistance = MathFunctions.lerp(prevFocalDistance, newFocalDistance, t);
                  const globalXfo = prevXfo.lerp(newGlobalXfo, t);
                  this.globalXfoParam.value = globalXfo;
                  this.setFocalDistance(focalDistance);
                  if (i < count) {
                      this.intervalId = window.setTimeout(applyMovement, 20);
                  }
                  else {
                      this.intervalId = -1;
                      this.emit('movementFinished');
                  }
              };
              applyMovement();
          }
      }
      /**
       * Sets camera perspective from a Mat4 object.
       *
       * @param mat - The mat value.
       * @param aspect - The aspect value.
       */
      updateProjectionMatrix(mat, aspect) {
          const isOrthographic = this.isOrthographicParam.value;
          const fov = this.fovParam.value;
          const near = this.nearParam.value;
          const far = this.farParam.value;
          const orthoMat = new Mat4();
          if (isOrthographic > 0.0) {
              const halfHeight = this.viewHeight * 0.5;
              const bottom = -halfHeight;
              const top = halfHeight;
              const left = halfHeight * -aspect;
              const right = halfHeight * aspect;
              orthoMat.setOrthographicMatrix(left, right, bottom, top, near, far);
          }
          if (isOrthographic < 1.0) {
              mat.setPerspectiveMatrix(fov, aspect, near, far);
          }
          if (isOrthographic == 1.0) {
              mat.setFromMat4(orthoMat);
          }
          else if (isOrthographic > 0.0) {
              mat.set(MathFunctions.lerp(mat.m00, orthoMat.m00, isOrthographic), MathFunctions.lerp(mat.m01, orthoMat.m01, isOrthographic), MathFunctions.lerp(mat.m02, orthoMat.m02, isOrthographic), MathFunctions.lerp(mat.m03, orthoMat.m03, isOrthographic), MathFunctions.lerp(mat.m10, orthoMat.m10, isOrthographic), MathFunctions.lerp(mat.m11, orthoMat.m11, isOrthographic), MathFunctions.lerp(mat.m12, orthoMat.m12, isOrthographic), MathFunctions.lerp(mat.m13, orthoMat.m13, isOrthographic), MathFunctions.lerp(mat.m20, orthoMat.m20, isOrthographic), MathFunctions.lerp(mat.m21, orthoMat.m21, isOrthographic), MathFunctions.lerp(mat.m22, orthoMat.m22, isOrthographic), MathFunctions.lerp(mat.m23, orthoMat.m23, isOrthographic), MathFunctions.lerp(mat.m30, orthoMat.m30, isOrthographic), MathFunctions.lerp(mat.m31, orthoMat.m31, isOrthographic), MathFunctions.lerp(mat.m32, orthoMat.m32, isOrthographic), MathFunctions.lerp(mat.m33, orthoMat.m33, isOrthographic));
          }
      }
  }
  Registry.register('Camera', Camera);

  /**
   * Class for loading zcad files.
   * The CADAsset is a TreeItem and can be added to the scene tree.
   *
   * **Events**
   * * **loaded:** Emitted when the  asset is loaded
   * @extends AssetItem
   */
  class CADAsset extends AssetItem {
      cadfileVersion = new Version('0,0,0');
      sdk;
      url;
      metadataLoadPromise;
      metadataLoaded = false;
      /**
       * Create a CAD asset.
       * @param {string} name - The name value.
       */
      constructor(name) {
          super(name);
      }
      /**
       * The clone method constructs a new CADAsset, copies its values
       * from this item and returns it.
       *
       * @param context - The CloneContext param.
       * @return - The cloned instance.
       */
      clone(context) {
          const cloned = new CADAsset();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Copies current TreeItem with all its children.
       *
       * @param src - The tree item to copy from.
       * @param context - The context value.
       */
      copyFrom(src, context) {
          super.copyFrom(src, context);
          this.url = src.url;
          if (!src.loaded) {
              src.once('geomsLoaded', (event) => {
                  this.emit('geomsLoaded', event);
              });
          }
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Returns the version of the data loaded by the CADAsset.
       *
       * @return - The version value.
       */
      getVersion() {
          return this.cadfileVersion;
      }
      /**
       * Initializes CADAsset's asset, material, version and layers; adding current `CADAsset` Geometry Item toall the layers in reader
       *
       * @param {BinReader} reader - The reader param.
       * @param {AssetLoadContext} context - The load context object that provides additional data such as the units of the scene we are loading into.
       */
      readRootLevelBinary(reader, context) {
          // Reset the versions dictionary. We don't want a shared context to provide from other asset loads.
          context.versions = {};
          context.versions['zea-cad'] = new Version(reader.loadStr());
          context.sdk = reader.loadStr();
          this.sdk = context.sdk;
          // console.log('Loading CAD File version:', this.cadfileVersion, ' exported using SDK:', context.cadSDK)
          super.readBinary(reader, context);
      }
      /**
       * Enables loading zcad data records.
       *
       * @param {Record<string, Uint8Array>} entries - The entries that were stored in the zcad file.
       * @param {AssetLoadContext} context - The load context object that provides additional data such as the units of the scene we are loading into.
       */
      async loadZCADEntries(entries, context) {
          const treeReader = new BinReader((entries.tree2 || entries.tree).buffer, 0, SystemDesc.isMobileDevice);
          // Note: An XRef stored in an assembly may contain a cache of its subtree.
          // If the XRef url does resolve to a file, we must clear this cache before loading the actual data.
          // keep the assembly level features and apply them after the load.
          this.removeAllChildren();
          const name = this.getName();
          this.readRootLevelBinary(treeReader, context);
          // Maintain the name provided by the user before loading.
          if (name != '')
              this.setName(name);
          context.versions['zea-cad'] = this.getVersion();
          context.versions['zea-engine'] = this.getEngineDataVersion();
          if (entries.geomsdata) {
              // If metadata is available, load it straight away.
              this.metadataLoadPromise = new Promise((resolve) => {
                  this.geomLibrary.once('loaded', () => {
                      this.geomLibrary.loadMetadata(entries.geomsdata, context);
                      this.metadataLoaded = true;
                      resolve();
                  });
              });
          }
          if (entries.geoms) {
              const geomFileID = -1;
              this.geomLibrary.readBinaryBuffer(geomFileID, entries.geoms.buffer, context);
          }
          else if (entries['geomLibrary.json']) {
              const geomLibraryJSON = JSON.parse(new TextDecoder('utf-8').decode(entries['geomLibrary.json']));
              const url = context.url;
              const filename = url.lastIndexOf('/') > -1 ? url.substring(url.lastIndexOf('/') + 1) : '';
              const stem = filename.substring(0, filename.lastIndexOf('.'));
              const basePath = context.folder + stem;
              if (geomLibraryJSON.numGeomFiles == 0) {
                  console.error("Corrupt zcad file. Missing 'geoms':", url);
              }
              else {
                  this.geomLibrary.loadGeomFilesStream(geomLibraryJSON, basePath, context);
              }
          }
          return new Promise((resolve, reject) => {
              Promise.allSettled(context.promisses)
                  .then(() => {
                  this.loaded = true;
                  this.emit('loaded');
                  resolve();
                  // Now check if we have GeomLibraries loading that we need to wait for.
                  // We want to emit an event when the entire sub-tree has loaded.
                  const geomPromises = [];
                  if (!this.geomLibrary.isLoaded()) {
                      geomPromises.push(new Promise((resolve) => this.geomLibrary.once('loaded', resolve)));
                  }
                  const includeThis = false;
                  this.traverse((item) => {
                      if (item instanceof CADAsset && !item.geomLibrary.isLoaded()) {
                          geomPromises.push(new Promise((resolve) => item.once('geomsLoaded', resolve)));
                      }
                  }, includeThis);
                  Promise.allSettled(geomPromises).then(() => this.emit('geomsLoaded'));
              })
                  .catch((reason) => {
                  reject(reason);
              });
          });
      }
      /**
       * Loads all the geometries and metadata from the asset file.
       * @param data - The URL of the asset to load, or the ArrayBuffer of the asset.
       * @param context - The load context object that provides additional data such as paths to external references.
       * @return - Returns a promise that resolves once the load of the tree is complete. Geometries, textures and other resources might still be loading.
       */
      async load(data, context = new AssetLoadContext()) {
          // Clone the context to avoid modifying the input context
          // which could be shared between assets and supplying desired units values.
          context = context.clone();
          // These values are used by XRef to generate URLS.
          context.assetItem = this;
          return new Promise((resolve, reject) => {
              // We add a 'workload' to the resource loader, to represent the
              // parsing of the loaded zcad file.
              // Note: this addresses an issue where the load count drops to 0 as soon
              // as loadFile('archive' resolves.
              resourceLoader.incrementWorkload(1);
              if (typeof data == 'string') {
                  const url = data;
                  const folder = url.lastIndexOf('/') > -1 ? url.substring(0, url.lastIndexOf('/')) + '/' : '';
                  this.url = url;
                  context.url = url;
                  context.folder = folder;
                  context.urlStack.push(url);
                  context.assetStack.push(this);
                  resourceLoader.loadFile('archive', url).then((entries) => {
                      if (!(entries.tree2 || entries.tree)) {
                          resourceLoader.incrementWorkDone(1);
                          const error = "Corrupt zcad file. Missing 'tree':" + url;
                          this.emit('error', error);
                          reject(error);
                          return;
                      }
                      this.loadZCADEntries(entries, context).then(() => {
                          resourceLoader.incrementWorkDone(1);
                          resolve();
                      });
                  }, (error) => {
                      resourceLoader.incrementWorkDone(1);
                      this.emit('error', error);
                      reject(error);
                  });
              }
              else if (data instanceof ArrayBuffer) {
                  // Note: Some clients have asked to be able to load zcad files
                  // directly from ArrayBuffers, potentially generated from Node.fs module.
                  const archiveUnpacker = resourceLoader.plugins['archive'];
                  archiveUnpacker.extractFile(data).then((entries) => {
                      this.loadZCADEntries(entries, context).then(() => {
                          resourceLoader.incrementWorkDone(1);
                          resolve();
                      });
                  }, (error) => {
                      resourceLoader.incrementWorkDone(1);
                      this.emit('error', error);
                      reject(error);
                  });
              }
          });
      }
      /**
       * Loads the metadata file for the previously loaded zcad file.
       * Note: in most cases, the CADAsset can generate the url for the metadata file.
       *
       * @param metaDataUrl - The URL of the metadata file to load.
       */
      loadMetadata(metaDataUrl = '') {
          if (this.metadataLoaded)
              return Promise.resolve();
          if (this.metadataLoadPromise)
              return this.metadataLoadPromise;
          this.metadataLoadPromise = new Promise((resolve, reject) => {
              if (this.metadataLoaded)
                  resolve();
              if (metaDataUrl == '') {
                  const url = this.url;
                  const base = url.substring(0, url.lastIndexOf('.'));
                  metaDataUrl = base + '.zmetadata';
              }
              resourceLoader.incrementWorkload();
              resourceLoader.loadFile('archive', metaDataUrl).then((entries) => {
                  const context = new AssetLoadContext();
                  context.versions['zea-engine'] = this.getEngineDataVersion();
                  this.geomLibrary.loadMetadata(entries.geomsdata, context);
                  resourceLoader.incrementWorkDone(1);
                  this.metadataLoaded = true;
                  resolve();
              }, (error) => {
                  resourceLoader.incrementWorkDone(1);
                  this.emit('error', error);
                  reject(error);
              });
          });
          return this.metadataLoadPromise;
      }
  }
  Registry.register('CADAsset', CADAsset);

  /**
   * Represents a Tree Item of an Assembly modeling. Brings together components to define a larger product.
   *
   * @extends TreeItem
   */
  class CADAssembly extends TreeItem {
      /**
       * Create a CAD assembly.
       *
       * @param name - The name of the tree item.
       */
      constructor(name) {
          super(name);
      }
      /**
       * The clone method constructs a new CADAssembly item, copies its values
       * from this item and returns it.
       *
       * @param context - The CloneContext param.
       * @return - The cloned instance.
       */
      clone(context) {
          const cloned = new CADAssembly();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('CADAssembly', CADAssembly);

  /**
   * Represents a Part within a CAD assembly.
   *
   * @extends TreeItem
   */
  class CADPart extends TreeItem {
      /**
       * Creates an instance of CADPart setting up the initial configuration for Material and Color parameters.
       *
       * @param name - The name value.
       */
      constructor(name) {
          super(name);
      }
      /**
       * The clone method constructs a new CADPart, copies its values
       * from this item and returns it.
       *
       * @param context - The CloneContext param.
       * @return - The cloned instance.
       */
      clone(context) {
          const cloned = new CADPart();
          cloned.copyFrom(this, context);
          return cloned;
      }
  }
  Registry.register('CADPart', CADPart);

  /**
   * Represents a Body within a CAD Part. A Body is made up of either a single mesh or a collection of meshes, one for each surface.
   * When a zcad file is produced, the tool can  optimize bodies to contain only one mesh to speed up loading of large models, and support bigger models being loaded.
   *
   * @extends GeomItem
   */
  class CADBody extends GeomItem {
      shattered = false;
      /**
       * Creates an instance of CADBody setting up the initial configuration for Material and Color parameters.
       *
       * @param {string} name - The name value.
       */
      constructor(name) {
          super(name);
      }
      /**
       * Sets the state of this CADBody whether the geometry isdisplayed as
       * 'shattered', meaning that each face, edge and vertex can be selected
       * individually.
       *
       * @param state - The state value.
       */
      setShatterState(state) {
          if (this.shattered != state) {
              this.shattered = state;
              this.emit('shatterStateChanged', new StateChangedEvent(state));
          }
      }
      /**
       * The clone method constructs a new CADBody, copies its values
       * from this item and returns it.
       *
       * @param context - The CloneContext param.
       * @return - The cloned instance.
       */
      clone(context) {
          const cloned = new CADBody();
          cloned.copyFrom(this, context);
          return cloned;
      }
      // ///////////////////////////
      // Persistence
      /**
       * Initializes CADBody's asset, material, version and layers; adding current `CADBody` Geometry Item toall the layers in reader
       *
       * @param reader - The reader param.
       * @param context - The context param.
       */
      readBinary(reader, context) {
          if (context.versions['zea-engine'].compare([3, 9, 0]) < 0) {
              BaseGeomItem.prototype.readBinary.call(this, reader, context);
              // Note: the bodyDescId is now deprecated as it is part of the parametric surface evaluation code.
              // The BinReader must read the value to continue loading others.
              /* const bodyDescId = */ reader.loadSInt32();
              if (context.versions['zea-cad'].compare([0, 0, 4]) < 0) {
                  const materialName = reader.loadStr();
                  const materialLibrary = context.assetItem.getMaterialLibrary();
                  let material = materialLibrary.getMaterial(materialName);
                  if (!material) {
                      material = new Material(materialName, 'SimpleSurfaceShader');
                      material.getParameter('BaseColor').setValue(Color.random(0.25));
                      context.assetItem.getMaterialLibrary().addMaterial(material);
                  }
                  this.materialParam.setValue(material);
              }
              if (context.versions['zea-cad'].compare([0, 0, 2]) >= 0 && context.versions['zea-cad'].compare([0, 0, 4]) < 0) {
                  this.layers = reader.loadStrArray();
                  // console.log("Layers:", this.layers)
                  // Note: addGeomToLayer should take a 'BaseGeomItem'
                  // @ts-ignore
                  for (const layer of this.layers)
                      context.addGeomToLayer(this, layer);
              }
          }
          else {
              super.readBinary(reader, context);
          }
      }
  }
  Registry.register('CADBody', CADBody);

  const plane = new Cuboid(1, 1, 1);
  let planeMaterial = null;
  // Disable all highlighting so it never shows on screen.
  class PMIPickingPlane extends GeomItem {
      addHighlight(name, color, propagateToChildren = true) { }
      removeHighlight(name, propagateToChildren = true) { }
  }
  /**
   * Represents a view of PMI data. within a CAD assembly.
   *
   * @extends TreeItem
   */
  class PMIItem extends TreeItem {
      materialMapping = {};
      /**
       * Creates an instance of PMIItem setting up the initial configuration for Material and Color parameters.
       *
       * @param {string} name - The name value.
       */
      constructor(name) {
          super(name);
      }
      /**
       * The clone method constructs a new PMIItem, copies its values
       * from this item and returns it.
       *
       * @param {number} flags - The flags param.
       * @return {PMIItem} - The return value.
       */
      clone(context) {
          const cloned = new PMIItem();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Changes the current state of the selection of this item.
       * Note: the PMIItem also activates the PMI linking when selected.
       *
       * @emits `selectedChanged` with selected state
       * @param sel - Boolean indicating the new selection state.
       */
      setSelected(sel) {
          super.setSelected(sel);
          if (sel)
              this.activate();
          else
              this.deactivate();
      }
      /**
       * Activates the PMIView, adjusting visibility of the PMI items and the camera Xfo
       */
      activate() { }
      /**
       * Deactivates the PMIItem
       */
      deactivate() { }
      /**
       * Adds a highlight to the tree item.
       *
       * @param {string} name - The name of the tree item.
       * @param {Color} color - The color of the highlight.
       * @param {boolean} propagateToChildren - A boolean indicating whether to propagate to children.
       */
      addHighlight(name, color, propagateToChildren = true) {
          super.addHighlight(name, color, false);
          // Instead of adding highlights around the PMI text, which makes it difficult to read
          // we clone the material and modify it so the text, symbols, and line colors
          // become the highlight color.
          if (propagateToChildren) {
              const baseColor = color.clone();
              baseColor.a = 1.0; // highlight colors often have zero alpha, as it controls the highlight fill.
              const materialCache = {};
              this.traverse((treeItem) => {
                  if (treeItem instanceof PMIPickingPlane)
                      return false;
                  if (treeItem instanceof GeomItem) {
                      const material = treeItem.materialParam.value;
                      this.materialMapping[treeItem.getId()] = material;
                      if (!(material.getId() in materialCache)) {
                          const highlightMaterial = material.clone();
                          if (highlightMaterial.hasParameter('BaseColor')) {
                              const param = highlightMaterial.getParameter('BaseColor');
                              if (param instanceof MaterialColorParam)
                                  param.colorSpace = exports.ColorSpace.Gamma;
                              param.setValue(baseColor);
                          }
                          if (highlightMaterial.hasParameter('EdgeColor')) {
                              const param = highlightMaterial.getParameter('EdgeColor');
                              if (param instanceof MaterialColorParam)
                                  param.colorSpace = exports.ColorSpace.Gamma;
                              param.setValue(baseColor);
                          }
                          if (highlightMaterial.hasParameter('Overlay')) {
                              highlightMaterial.getParameter('Overlay').setValue(0.85);
                          }
                          // This *hack* forces PMI text to be rendered to the transparent layer
                          // which means it will not have an outline drawn around it.
                          // Maybe we should add PMI to the 'OverLay' pass.
                          // This would assume that the overlay pass does not clear the depth buffer, which
                          // it does right now.
                          // @ts-ignore
                          highlightMaterial.__isOpaque = false;
                          treeItem.materialParam.value = highlightMaterial;
                          // We can reuse this material on other PMI items with the same
                          // original material
                          materialCache[material.getId()] = highlightMaterial;
                      }
                      treeItem.materialParam.value = materialCache[material.getId()];
                  }
              });
          }
          const pmiContainer = this.getOwner().getOwner(); // TODO: check
          const pmiOwner = pmiContainer.getOwner();
          if (pmiOwner) {
              const linkedBodies = {};
              const linkedBodyElements = {};
              const linkedEntitiesParam = this.getParameter('LinkedEntities');
              if (linkedEntitiesParam) {
                  const linkedEntityPaths = linkedEntitiesParam.getValue();
                  linkedEntityPaths.forEach((pathStr, index) => {
                      if (pathStr == '')
                          return;
                      const path = pathStr.split(', ');
                      const elemId = path.pop();
                      try {
                          const cadBody = pmiOwner.resolvePath(path);
                          if (cadBody && cadBody instanceof CADBody) {
                              if (cadBody.getNumChildren() == 0) {
                                  cadBody.setShatterState(true);
                                  if (!linkedBodies[cadBody.getId()]) {
                                      linkedBodies[cadBody.getId()] = cadBody;
                                      linkedBodyElements[cadBody.getId()] = [];
                                  }
                                  linkedBodyElements[cadBody.getId()].push(elemId);
                              }
                              else {
                                  const linkedEntity = cadBody.getChildByName(elemId);
                                  if (linkedEntity)
                                      linkedEntity.addHighlight(name, color, true);
                              }
                              // linkedEntity.addHighlight(name + ':' + elemId, color, true)
                          }
                          else {
                              console.log('linkedEntity.addHighlight(name, color, true):', path);
                          }
                      }
                      catch (e) {
                          console.log(index + ':' + e.message);
                      }
                  });
                  for (let key in linkedBodies) {
                      const cadBody = linkedBodies[key];
                      const elemIds = linkedBodyElements[key];
                      cadBody.addHighlight(name + ':' + elemIds.toString(), color, true);
                  }
              }
          }
      }
      /**
       * Removes a highlight to the tree item.
       *
       * @param {string} name - The name of the tree item.
       * @param {boolean} propagateToChildren - A boolean indicating whether to propagate to children.
       */
      removeHighlight(name, propagateToChildren = true) {
          // super.removeHighlight(name, propagateToChildren)
          super.removeHighlight(name, false);
          if (propagateToChildren) {
              this.traverse((treeItem) => {
                  if (treeItem instanceof GeomItem) {
                      if (treeItem.getId() in this.materialMapping) {
                          treeItem.materialParam.value = this.materialMapping[treeItem.getId()];
                          delete this.materialMapping[treeItem.getId()];
                      }
                  }
              });
          }
          const pmiContainer = this.getOwner().getOwner();
          const pmiOwner = pmiContainer.getOwner();
          if (pmiOwner) {
              const linkedBodies = {};
              const linkedBodyElements = {};
              const linkedEntitiesParam = this.getParameter('LinkedEntities');
              if (linkedEntitiesParam) {
                  const linkedEntityPaths = linkedEntitiesParam.getValue();
                  linkedEntityPaths.forEach((pathStr) => {
                      if (pathStr == '')
                          return;
                      const path = pathStr.split(', ');
                      const elemId = path.pop();
                      try {
                          const cadBody = pmiOwner.resolvePath(path);
                          if (cadBody && cadBody instanceof CADBody) {
                              if (cadBody.getNumChildren() == 0) {
                                  cadBody.setShatterState(false);
                                  if (!linkedBodies[cadBody.getId()]) {
                                      linkedBodies[cadBody.getId()] = cadBody;
                                      linkedBodyElements[cadBody.getId()] = [];
                                  }
                                  linkedBodyElements[cadBody.getId()].push(elemId);
                              }
                              else {
                                  const linkedEntity = cadBody.getChildByName(elemId);
                                  if (linkedEntity)
                                      linkedEntity.removeHighlight(name, true);
                              }
                              // linkedEntity.addHighlight(name + ':' + elemId, color, true)
                          }
                          else {
                              console.log('linkedEntity.addHighlight(name, color, true):failed');
                          }
                      }
                      catch (e) {
                          console.log(e.message);
                      }
                  });
                  for (let key in linkedBodies) {
                      const cadBody = linkedBodies[key];
                      const elemIds = linkedBodyElements[key];
                      cadBody.removeHighlight(name + ':' + elemIds.toString(), true);
                  }
              }
          }
      }
      // ///////////////////////////
      // Persistence
      /**
       * Load the binary data for this class
       * @param reader - The reader param.
       * @param context - The context param.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          this.traverse((item) => {
              if (item instanceof GeomItem) {
                  const material = item.materialParam.value;
                  if (material.getShaderName() == 'StandardSurfaceShader') {
                      material.setShaderName('FlatSurfaceShader');
                  }
                  // This *hack* forces PMI text to be rendered to the transparent layer
                  // which means it will not have an outline drawn around it.
                  // Maybe we should add PMI to the 'OverLay' pass.
                  // This would assume that the overlay pass does not clear the depth buffer, which
                  // it does right now.
                  // @ts-ignore
                  item.opacity = 0.99;
              }
          });
          // Here we place a transparent plane behind the PMI Text to enable
          // easier clicking on PMI items in the 3d Viewport.
          context.assetItem.getGeometryLibrary().once('loaded', () => {
              this.traverse((item) => {
                  // Note: We could implement a PMIText class that is generated in the bridge
                  // when processing PMI, so we don't need to do this hacky name check.
                  // Then the Text would be able to generate the plane during load.
                  if (item.getName().startsWith('Text')) {
                      const planeItems = [];
                      item.traverse((item) => {
                          if (item instanceof GeomItem) {
                              const geom = item.geomParam.value;
                              const bbox = geom.getBoundingBox();
                              if (!planeMaterial) {
                                  planeMaterial = new FlatSurfaceMaterial('plane');
                                  planeMaterial.baseColorParam.value = new Color(1, 1, 0, 0.001);
                                  planeMaterial.overlayParam.value = -0.001;
                              }
                              const planeGeomItem = new PMIPickingPlane('plane', plane, planeMaterial);
                              const xfo = item.localXfoParam.value.multiply(item.geomOffsetXfoParam.value);
                              xfo.tr.addInPlace(bbox.center());
                              xfo.sc.multiplyInPlace(bbox.diagonal());
                              planeGeomItem.localXfoParam.value = xfo;
                              planeItems.push(planeGeomItem);
                          }
                      }, false);
                      planeItems.forEach((planeItem) => item.addChild(planeItem, false));
                      return false;
                  }
              }, false);
          });
      }
  }
  Registry.register('PMIItem', PMIItem);

  /**
   * Represents a view of PMI data. within a CAD assembly.
   *
   * @extends PMIItem
   */
  class PMIView extends PMIItem {
      camera;
      /**
       * Creates an instance of PMIView setting up the initial configuration for Material and Color parameters.
       *
       * @param {string} name - The name value.
       */
      constructor(name) {
          super(name);
          this.camera = null;
      }
      /**
       * The clone method constructs a new PMIView, copies its values
       * from this item and returns it.
       *
       * @param context - The clone context.
       * @return - The return value.
       */
      clone(context) {
          const cloned = new PMIView();
          cloned.copyFrom(this, context);
          return cloned;
      }
      /**
       * Activates the PMIView, adjusting visibility of the PMI items and the camera Xfo
       */
      activate() {
          super.activate();
          let graphicalItems = [];
          if (this.hasParameter('GraphicalElements')) {
              graphicalItems = this.getParameter('GraphicalElements').getValue();
          }
          const findAssetItem = () => {
              let item = this;
              while (item && !(item instanceof CADAsset))
                  item = item.getParentItem();
              if (item instanceof CADAsset)
                  return item;
              return null;
          };
          const assetItem = findAssetItem();
          const pmiContainer = this.getParentItem().getParentItem();
          const pmiOwner = pmiContainer.getParentItem();
          if (pmiOwner) {
              const pmiItems = [];
              pmiContainer.traverse((item) => {
                  if (item instanceof PMIView)
                      return;
                  if (item instanceof PMIItem)
                      pmiItems.push(item);
              });
              pmiItems.forEach((pmiItem) => {
                  const visible = graphicalItems.includes(pmiItem.getName());
                  pmiItem.setVisible(visible);
              });
          }
          if (this.camera) {
              const cameraXfo = this.localXfoParam.value.clone();
              const TargetPoint = this.getParameter('TargetPoint').getValue().clone();
              const CameraType = this.getParameter('CameraType').getValue();
              cameraXfo.tr.scaleInPlace(assetItem.unitsScale);
              TargetPoint.scaleInPlace(assetItem.unitsScale);
              const dist = cameraXfo.tr.distanceTo(TargetPoint);
              cameraXfo.sc.set(1.0, 1.0, 1.0);
              this.camera.globalXfoParam.value = cameraXfo;
              this.camera.setFocalDistance(dist);
              if (CameraType == 'Camera_Orthographic') {
                  this.camera.setIsOrthographic(1, 0);
                  // When switching from perspective to ortho here is how the zoom is computed:
                  // _zoom = 1.f;
                  // float coef = _targetDistance * CATTan(CATDegreeToRadian * _viewAngle);
                  // if (coef > 0.f) _zoom = 1./ coef;
                  if (this.hasParameter('CameraZoom') && assetItem) {
                      const CameraZoom = this.getParameter('CameraZoom').getValue();
                      const FrustHeight = (1 / CameraZoom) * assetItem.unitsScale * 2;
                      this.camera.setFrustumHeight(FrustHeight);
                  }
              }
          }
          if (this.hasParameter('ClippingPlaneOrigin')) {
              const clippingPlaneOrigin = this.getParameter('ClippingPlaneOrigin').getValue();
              const clippingPlaneNormal = this.getParameter('ClippingPlaneNormal').getValue();
              const cutEnabled = true;
              const cutAwayDist = -clippingPlaneOrigin.dot(clippingPlaneNormal) * assetItem.unitsScale;
              pmiOwner.traverse((item) => {
                  if (item instanceof PMIItem)
                      return false;
                  if (item instanceof GeomItem) {
                      item.setCutawayEnabled(cutEnabled);
                      item.setCutVector(clippingPlaneNormal);
                      item.setCutDist(cutAwayDist);
                  }
              });
          }
          else {
              pmiOwner.traverse((item) => {
                  if (item instanceof PMIItem)
                      return false;
                  if (item instanceof GeomItem) {
                      item.setCutawayEnabled(false);
                  }
              });
          }
      }
      /**
       * Deactivates the PMIItem
       */
      deactivate() {
          super.deactivate();
          // if (this.hasParameter('GraphicalElements')) {
          //   const pmiContainer = (this.getOwner() as TreeItem).getOwner() as TreeItem
          //   const pmiOwner = pmiContainer.getOwner()
          //   if (pmiOwner) {
          //     const pmiItems: TreeItem[] = []
          //     pmiContainer.traverse((item: TreeItem) => {
          //       if (item instanceof PMIView) return
          //       if (item instanceof PMIItem) pmiItems.push(item)
          //     })
          //     pmiItems.forEach((pmiItem) => {
          //       pmiItem.setVisible(true)
          //     })
          //   }
          // }
          // // Note: leave the camera as is
          // if (this.camera) {
          //   this.camera.setIsOrthographic(0)
          // }
      }
      // ///////////////////////////
      // Persistence
      /**
       * Load the binary data for this class
       * @param reader - The reader param.
       * @param context - The context param.
       */
      readBinary(reader, context) {
          super.readBinary(reader, context);
          if (context.camera) {
              this.camera = context.camera;
          }
      }
  }
  Registry.register('PMIView', PMIView);

  /**
   * Represents a view of PMI data. within a CAD assembly.
   *
   * @extends TreeItem
   */
  class XRef extends CADAsset {
      /**
       * @member configurationParam - Stores the value of the configuration this XRef must attempt to load
       */
      configurationParam = new StringParameter('Configuration');
      /**
       * Creates an instance of XRef setting up the initial configuration for Material and Color parameters.
       *
       * @param {string} name - The name value.
       */
      constructor(name) {
          super(name);
          this.addParameter(this.configurationParam);
      }
      /**
       * The clone method constructs a new XRef, copies its values
       * from this item and returns it.
       *
       * @param context - The context value.
       * @return - Returns a new cloned xref.
       */
      clone(context) {
          const cloned = new XRef();
          cloned.copyFrom(this, context);
          return cloned;
      }
      // ///////////////////////////
      // Persistence
      /**
       * Initializes XRef's asset, material, version and layers; adding current `XRef` Geometry Item toall the layers in reader
       *
       * @paramreader - The reader param.
       * @param context - The load context param.
       */
      readBinary(reader, context) {
          let relativePath;
          if (context.versions['zea-engine'].compare([3, 13, 1]) >= 0) {
              TreeItem.prototype.readBinary.call(this, reader, context);
              relativePath = reader.loadStr();
          }
          else {
              reader.loadStr(); // read type
              const name = reader.loadStr(); // read name
              this.setName(name);
              relativePath = reader.loadStr();
              const xfo = new Xfo();
              if (context.versions['zea-cad'].compare([3, 6, 2]) > 0) {
                  xfo.tr = reader.loadFloat32Vec3();
                  xfo.ori = reader.loadFloat32Quat();
                  this.localXfoParam.value = xfo;
              }
              else {
                  // Note: the SpatialBridge now encodes the 'ReferenceName' into the
                  // XRef, while CADEx didn't provide one. Use the name if it is provided.
                  if (name == '')
                      this.setName(relativePath);
              }
              // XRefs can now contain custom props that may contain colors, or configurations.
              if (context.versions['zea-engine'].compare([3, 11, 1]) > 0) {
                  // Note: after the refactor of the Class hierarchy where
                  // we inverted the relationship between BaseItem and PArameterOWner
                  // we needed to fix this code path.
                  //@ts-ignore
                  this.readBinaryParams(reader, context);
              }
          }
          const assemblyFeatures = this.getChildByName('Assembly Features');
          if (assemblyFeatures) {
              this.removeChildByHandle(assemblyFeatures);
          }
          // /////////////////////////////////////
          // URL
          // If a resources dict has been provided, look it up, else
          // generate a url.
          let url = undefined;
          if (context.resources) {
              if (context.resources[relativePath]) {
                  url = context.resources[relativePath];
              }
              else {
                  // CAD systems seem to have flexible path resolution strategies that we dont yet support.
                  // e.g. looking in multiple folders for a file.
                  // The relative paths often break.
                  // If the user provides a mapping table, we will use it, else
                  // we assume files will all be in the same folder.
                  if (relativePath.includes('/')) {
                      relativePath = relativePath.slice(relativePath.lastIndexOf('/') + 1);
                  }
                  else if (relativePath.includes('\\')) {
                      relativePath = relativePath.slice(relativePath.lastIndexOf('\\') + 1);
                  }
                  if (context.resources[relativePath]) {
                      url = context.resources[relativePath];
                  }
                  else if (context.xrefLoadCallback) {
                      url = context.xrefLoadCallback.call(context, relativePath, this);
                  }
              }
          }
          else if (context.xrefLoadCallback) {
              url = context.xrefLoadCallback.call(context, relativePath, this);
          }
          else {
              if (relativePath.includes('/')) {
                  relativePath = relativePath.slice(relativePath.lastIndexOf('/') + 1);
              }
              else if (relativePath.includes('\\')) {
                  relativePath = relativePath.slice(relativePath.lastIndexOf('\\') + 1);
              }
              // Generate a url relative to the folder of the asset we are currently loading.
              url = context.folder + relativePath + '.zcad';
          }
          if (url) {
              // Note: this occurs in Vallee data: CELA00925.sldasm (imports its self.)
              if (context.urlStack.includes(url)) {
                  const index = context.urlStack.indexOf(url);
                  const asset = context.assetStack[index];
                  console.warn('Circular load occurring at:', asset.path);
                  return;
              }
              // If an XRef already exists to the same zcad file, we can just clone the existing XRef.
              // This means the geometry will only be loaded once, and it will become re-used
              // by the cloned XRefs.
              if (context.xrefs[url]) {
                  context.addPromise(new Promise((resolve, reject) => {
                      const xref = context.xrefs[url];
                      const copyFromXRef = () => {
                          const name = this.name;
                          const xfo = this.localXfoParam.value;
                          this.copyFrom(xref);
                          // Make sure we keep our name and Xfo.
                          this.setName(name);
                          if (this.units != context.units) {
                              // The scale factor we must apply is relative to our parent, which
                              // could have a different units to the scrc(cloned) XRef. We re-calculate
                              // units scale based on our parents unit.
                              const unitsFactor = getUnitsFactor(this.units);
                              const contextUnitsFactor = getUnitsFactor(context.units);
                              this.unitsScale = unitsFactor / contextUnitsFactor;
                              xfo.sc.scaleInPlace(this.unitsScale);
                              xfo.tr.scaleInPlace(this.unitsScale);
                          }
                          this.localXfoParam.value = xfo;
                          if (assemblyFeatures) {
                              this.applyAssemblyLevelFeatures(assemblyFeatures);
                          }
                          resolve();
                      };
                      const loadFailed = () => {
                          this.emit('error');
                          reject();
                      };
                      if (!xref.loaded) {
                          xref.once('xrefLoaded', copyFromXRef);
                          xref.once('error', loadFailed);
                      }
                      else {
                          copyFromXRef();
                      }
                  }));
              }
              else {
                  context.xrefs[url] = this;
                  context.addPromise(new Promise((resolve, reject) => {
                      this.load(url, new AssetLoadContext(context)).then(() => {
                          this.emit('xrefLoaded');
                          // CADAsset applies a units scale to the sc, but not the tr.
                          const xfo = this.localXfoParam.value;
                          xfo.tr.scaleInPlace(this.unitsScale);
                          this.localXfoParam.value = xfo;
                          if (assemblyFeatures) {
                              this.applyAssemblyLevelFeatures(assemblyFeatures);
                          }
                          resolve();
                      }, () => {
                          // console.warn(`While Loading ${this.getPath()} unable to load XRef: ${relativePath}`)
                          reject();
                      });
                  }));
              }
          }
          else {
              console.warn(`While Loading ${this.getPath()} unable to load XRef: ${relativePath}`);
              // If the XRef didn't resolve, we can keep the Assembly features,
              // which represent a cache of the data as it was last saved.
              if (assemblyFeatures) {
                  const children = assemblyFeatures.getChildren();
                  for (const subFeatureTreeItem of children) {
                      this.addChild(subFeatureTreeItem, false);
                  }
              }
          }
      }
      applyAssemblyLevelFeatures(assemblyFeatures) {
          // An Xef contains only one child. Either a part or an assembly.
          // this.applyFeatureToChildren(assemblyFeatures, this)
          const featureTreeChild = assemblyFeatures.getChild(0);
          const prototypeTreeItem = this.getChild(0);
          if (featureTreeChild && prototypeTreeItem)
              this.applyFeature(featureTreeChild, prototypeTreeItem);
          // this.addChild(assemblyFeatures)
      }
      applyFeatureToChildren(featureTreeItem, prototypeTreeItem) {
          const children = [...featureTreeItem.getChildren()];
          for (const subFeatureTreeItem of children) {
              const subAssemblyTreeItem = prototypeTreeItem.getChildByName(subFeatureTreeItem.name);
              if (subAssemblyTreeItem) {
                  this.applyFeature(subFeatureTreeItem, subAssemblyTreeItem);
              }
              else
                  console.log(`Feature node: ${subFeatureTreeItem.path} does not match a node in the assembly tree for the following XRef:`, this.name);
          }
      }
      applyFeature(featureTreeItem, prototypeTreeItem) {
          const xfo = featureTreeItem.localXfoParam.value;
          if (!xfo.isIdentity()) {
              prototypeTreeItem.localXfoParam.value = featureTreeItem.localXfoParam.value;
          }
          if (featureTreeItem instanceof GeomItem) {
              const material = featureTreeItem.materialParam.value;
              prototypeTreeItem.traverse((subTreeItem) => {
                  if (subTreeItem instanceof GeomItem) {
                      subTreeItem.materialParam.value = material;
                      // Remove any per-face materials that would override the assembly material
                      const geom = subTreeItem.geomParam.value;
                      if (geom instanceof CompoundGeom)
                          geom.clearMaterials();
                      else {
                          subTreeItem.geomParam.once('valueChanged', () => {
                              const geom = subTreeItem.geomParam.value;
                              if (geom instanceof CompoundGeom) {
                                  geom.clearMaterials();
                              }
                          });
                      }
                  }
              }, true);
              // Note: the GeomItem can contain children with other data to apply in the tree.
              // We allow the traversal to continue.
          }
          else if (featureTreeItem instanceof CADPart) {
              if (prototypeTreeItem instanceof CADPart) {
                  const xfo = prototypeTreeItem.localXfoParam.value;
                  const parentItem = prototypeTreeItem.parent;
                  parentItem.removeChildByHandle(prototypeTreeItem);
                  parentItem.addChild(featureTreeItem, false, false);
                  featureTreeItem.localXfoParam.value = xfo;
              }
              else if (prototypeTreeItem instanceof XRef || prototypeTreeItem instanceof InstanceItem) {
                  // Transfer the Xfo to the prototypeTreeItem.
                  // Note: the featureTreeItem contains a transfer that probabably matches
                  // that of the prototypeTreeItem. However, it may have changed, so we keep it.
                  prototypeTreeItem.localXfoParam.value = featureTreeItem.localXfoParam.value;
                  featureTreeItem.localXfoParam.value = new Xfo();
                  prototypeTreeItem.removeAllChildren();
                  prototypeTreeItem.addChild(featureTreeItem, false, false);
              }
              return;
          }
          if (prototypeTreeItem instanceof XRef && prototypeTreeItem.getNumChildren() == 1) {
              // Note: the Assembly Feature tree does not include nodes for Instance items.
              // and instead only has the prototype. We need to step down into the
              // prototype to access its children.
              prototypeTreeItem = prototypeTreeItem.getChild(0);
          }
          if (prototypeTreeItem) {
              this.applyFeatureToChildren(featureTreeItem, prototypeTreeItem);
          }
      }
  }
  Registry.register('XRef', XRef);

  const PassType = {
      PRE: 1,
      OPAQUE: 2,
      TRANSPARENT: 3,
      OVERLAY: 4,
  };
  /** This class abstracts the rendering of a collection of geometries to screen.
   * @extends ParameterOwner
   */
  class GLPass extends ParameterOwner {
      enabled = true;
      passIndex = -1;
      __gl = null;
      renderer = null;
      __renderer = null;
      enabledParam = new BooleanParameter('Enabled', true);
      /**
       * Create a GL pass.
       */
      constructor() {
          super();
          this.enabled = true;
          this.passIndex = 0;
          this.addParameter(this.enabledParam);
          this.enabledParam.on('valueChanged', () => (this.enabled = this.enabledParam.value));
      }
      /**
       * The __parameterValueChanged method.
       * @param event - The event object.
       * @private
       */
      parameterValueChanged(event) {
          super.parameterValueChanged(event);
          if (this.renderer)
              this.renderer.requestRedraw();
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLRenderer
       */
      init(renderer, passIndex) {
          if (passIndex == undefined)
              throw new Error('Missing constructor argument.'); // Type checking. Seomthing that TypeScript will do for us.
          this.__gl = renderer.gl;
          this.renderer = renderer;
          this.__renderer = renderer;
          this.passIndex = passIndex;
      }
      /**
       * The setPassIndex method.
       * @param passIndex - The index of the pass in the GLRenderer
       */
      setPassIndex(passIndex) {
          this.passIndex = passIndex;
      }
      /**
       * Returns the pass type. OPAQUE passes are always rendered first, followed by TRANSPARENT passes, and finally OVERLAY.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.OPAQUE;
      }
      /**
       * The itemAddedToScene method is called on each pass when a new item
       * is added to the scene, and the renderer must decide how to render it.
       * It allows Passes to select geometries to handle the drawing of.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * The object contains a parameter 'continueInSubTree', which can be set to false,
       * so the subtree of this node will not be traversed after this node is handled.
       * @return - The return value.
       */
      itemAddedToScene(treeItem, rargs) {
          throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`);
      }
      /**
       * The itemRemovedFromScene method is called on each pass when aa item
       * is removed to the scene, and the pass must handle cleaning up any resources.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * @return - The return value.
       */
      itemRemovedFromScene(treeItem, rargs) {
          throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`);
      }
      /**
       * The startPresenting method.
       */
      startPresenting() { }
      /**
       * The stopPresenting method.
       */
      stopPresenting() { }
      // ///////////////////////////////////
      // Rendering
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          throw Error('draw not implemented on GLPass');
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) { }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) { }
      /**
       * The getGeomItemAndDist method.
       * @param geomData - The geomData value.
       */
      getGeomItemAndDist(geomData) {
          throw Error('getGeomItemAndDist not implemented on GLPass');
      }
  }

  /**
   * Class representing a GL CAD pass.
   *
   * **Events**
   * * **updated**
   * @extends GLPass
   */
  class GLCADPass extends GLPass {
      /**
       * Create a GL CAD pass.
       * @param {boolean} debugMode - If true, then puts the GLCADPass rendering into debug mode.
       */
      constructor(debugMode = false) {
          super();
          console.warn('GLCADPass is deprecated. No need to install this pass in the renderer.');
      }
      /**
       * The itemAddedToScene method is called on each pass when a new item
       * is added to the scene, and the renderer must decide how to render it.
       * It allows Passes to select geometries to handle the drawing of.
       * @param {TreeItem} treeItem - The treeItem value.
       * @param {object} rargs - Extra return values are passed back in this object.
       * The object contains a parameter 'continueInSubTree', which can be set to false,
       * so the subtree of this node will not be traversed after this node is handled.
       * @return {Boolean} - The return value.
       */
      itemAddedToScene(treeItem, rargs) {
          return false;
      }
      /**
       * The itemRemovedFromScene method is called on each pass when aa item
       * is removed to the scene, and the pass must handle cleaning up any resources.
       * @param {TreeItem} treeItem - The treeItem value.
       * @param {object} rargs - Extra return values are passed back in this object.
       * @return {Boolean} - The return value.
       */
      itemRemovedFromScene(treeItem, rargs) {
          return false;
      }
  }

  /**
   * The GridTreeItem displays a grid of a given size and resolution. The Grid is oriented on the XY plane
   * and highlights the X and Y axes with Red and Green lines. Grids are useful in displaying scene scale and coordinate system.
   * The Grid geometry does not return a bounding box and so does not effect the bounding of the scene.
   *
   * @extends {TreeItem}
   */
  class GridTreeItem extends TreeItem {
      /**
       * Creates an instance of GridTree.
       *
       * @param gridSize
       * @param resolution
       * @param gridColor
       */
      constructor(gridSize = 5, resolution = 50, gridColor = new Color('#DCDCDC')) {
          super('GridTree');
          this.disableBoundingBox = true;
          this.setSelectable(false);
          const gridMaterial = new LinesMaterial('gridMaterial');
          gridMaterial.baseColorParam.value = gridColor;
          gridMaterial.overlayParam.value = 0.0;
          const grid = new Grid(gridSize, gridSize, resolution, resolution, true);
          const gridItem = new GeomItem('GridItem', grid, gridMaterial);
          gridItem.setSelectable(false);
          this.addChild(gridItem, false);
          const axisLine = new Lines();
          axisLine.setNumVertices(2);
          axisLine.setNumSegments(1);
          axisLine.setSegmentVertexIndices(0, 0, 1);
          const positions = axisLine.getVertexAttribute('positions');
          positions.setValue(0, new Vec3(gridSize * -0.5, 0.0, 0.0));
          positions.setValue(1, new Vec3(gridSize * 0.5, 0.0, 0.0));
          const gridXAxisMaterial = new LinesMaterial('gridXAxisMaterial');
          gridXAxisMaterial.baseColorParam.value = new Color(gridColor.luminance(), 0, 0);
          gridXAxisMaterial.overlayParam.value = 0.0;
          const gridXAxis = new GeomItem('xAxisLine', axisLine, gridXAxisMaterial);
          gridXAxis.setSelectable(false);
          this.addChild(gridXAxis, false);
          const gridYAxisMaterial = new LinesMaterial('gridYAxisMaterial');
          gridYAxisMaterial.baseColorParam.value = new Color(0, gridColor.luminance(), 0);
          gridYAxisMaterial.overlayParam.value = 0.0;
          const zAxisLineItem = new GeomItem('yAxisLine', axisLine, gridYAxisMaterial);
          zAxisLineItem.setSelectable(false);
          const geomOffset = new Xfo();
          geomOffset.ori.setFromAxisAndAngle(new Vec3(0, 0, 1), Math.PI * 0.5);
          zAxisLineItem.geomOffsetXfoParam.value = geomOffset;
          this.addChild(zAxisLineItem, false);
      }
      /**
       * @private
       * @return - Reset Bounding Box
       */
      _cleanBoundingBox() {
          return new Box3();
      }
  }
  Registry.register('GridTreeItem', GridTreeItem);

  const defaultGridColor = new Color('#DCDCDC');
  /**
   * Class representing the environment where all the displayed assets live.
   */
  class Scene {
      /**
       * @member envMapParam - The image displayed and used for the environment map.
       */
      envMapParam = new ImageParameter('EnvMap');
      /**
       * @member displayEnvMapParam - Boolean that determines whether or not the environment map should be displayed.
       */
      displayEnvMapParam = new BooleanParameter('Display EnvMap', false);
      /**
       * @member envMapLODParam - TODO
       */
      envMapLODParam = new NumberParameter('EnvMapLOD', 0);
      root = new TreeItem('root');
      /**
       * Create a scene.
       */
      constructor() { }
      /**
       * Returns the scene's root item(`TreeItem`) that owns every item in the scene.
       *
       * @return - The return value.
       */
      getRoot() {
          return this.root;
      }
      /**
       * Returns resourceLoader object set on class initialization.
       *
       * @return - The return value.
       */
      getResourceLoader() {
          return resourceLoader;
      }
      /**
       * Sets Environment Map with the BaseImage you'd like to display in your scene background.
       *
       * @param envMap - The envMap value.
       */
      setEnvMap(envMap) {
          this.envMapParam.value = envMap;
      }
      /**
       * Sets up and displays the scene grid of a given size and resolution. The Grid is oriented on the XY plane
       * and highlights the X and Y axes with Red and Green lines. Grids are useful in displaying scene scale and coordinate system.
       * The Grid geometry does not return a bounding box and so does not effect the bounding of the scene.
       * The GridTreeItem display a grid of a given size and resolution. The Grid is oriented on the XY plane
       * and highlights the X and Y axes with Red and Green lines.
       *
       * @param gridSize - The size of the grid.
       * @param resolution - The resolution of the grid.
       * @param gridColor - The color of the grid.
       * @return - The return value.
       */
      setupGrid(gridSize = 5, resolution = 50, gridColor = defaultGridColor) {
          const gridTreeItem = new GridTreeItem(gridSize, resolution, gridColor);
          this.root.addChild(gridTreeItem, false);
          return gridTreeItem;
      }
  }

  /**
   * Class designed to load and handle `.vla` files.
   *
   * **Events**
   * * **loaded:** Triggered once the tree is loaded. Note: the tree bounding box is valid once the tree is loaded.
   * * **geomsLoaded:** Triggered once all geometries are loaded.
   *
   * @extends AssetItem
   */
  class VLAAsset extends AssetItem {
      /**
       * Create a VLA asset.
       * @param name - The name value.
       */
      constructor(name) {
          super(name);
          // A signal that is emitted once all the geometries are loaded.
          // Often the state machine will activate the
          // first state when this signal emits.
          this.geomLibrary.on('loaded', () => {
              this.emit('geomsLoaded');
          });
      }
      // ////////////////////////////////////////
      // Persistence
      /**
       * Sets state of current asset using a binary reader object.
       *
       * @param reader - The reader value.
       * @param context - The context value.
       * @return - The return value.
       */
      readBinary(reader, context) {
          if (context.versions['zea-engine']) ;
          else {
              // Now we split the mesh out from the engine version.
              context.versions['zea-mesh'] = new Version(reader.loadStr());
          }
          // console.log('Loading Mesh File version:', context.versions['zea-mesh'])
          const numGeomsFiles = reader.loadUInt32();
          super.readBinary(reader, context);
          if (context.versions['zea-engine'].compare([2, 1, 0]) < 0) {
              // Some data is no longer being read at the end of the buffer
              // so we skip to the end here.
              // The data was the atlas size of the lightmap that we no longer support.
              reader.loadFloat32Vec2();
          }
          this.geomLibrary.setNumGeoms(reader.loadUInt32());
          return numGeomsFiles;
      }
      /**
       * Loads all the geometries and metadata from the asset file.
       * @param url - The URL of the asset to load
       * @param context - The load context object that provides additional data such as the units of the scene we are loading into.
       * @return - Returns a promise that resolves once the initial load is complete
       */
      load(url, context = new AssetLoadContext()) {
          return new Promise((resolve, reject) => {
              const folder = url.lastIndexOf('/') > -1 ? url.substring(0, url.lastIndexOf('/')) + '/' : '';
              const filename = url.lastIndexOf('/') > -1 ? url.substring(url.lastIndexOf('/') + 1) : '';
              const stem = filename.substring(0, filename.lastIndexOf('.'));
              let numGeomsFiles = 0;
              context.assetItem = this;
              context.url = url;
              context.folder = folder;
              // preload in case we don't have embedded geoms.
              // completed by geomLibrary.on('loaded' ..
              resourceLoader.incrementWorkload(1);
              // To ensure that the resource loader knows when
              // parsing is done, we listen to the GeomLibrary streamFileLoaded
              // signal. This is fired once the entire stream is parsed.
              this.geomLibrary.on('loaded', () => {
                  // A chunk of geoms are now parsed, so update the resource loader.
                  resourceLoader.incrementWorkDone(1);
              });
              resourceLoader.loadFile('archive', url).then((entries) => {
                  // Load the tree file. This file contains
                  // the scene tree of the asset, and also
                  // tells us how many geom files will need to be loaded.
                  let treeReader;
                  if (entries.tree2) {
                      treeReader = new BinReader(entries.tree2.buffer, 0, SystemDesc.isMobileDevice);
                  }
                  else {
                      const entry = entries.tree ? entries.tree : entries[Object.keys(entries)[0]];
                      treeReader = new BinReader(entry.buffer, 0, SystemDesc.isMobileDevice);
                      context.versions['zea-engine'] = new Version();
                  }
                  numGeomsFiles = this.readBinary(treeReader, context);
                  this.loaded = true;
                  this.emit('loaded');
                  if (numGeomsFiles == 0 && entries.geoms) {
                      this.geomLibrary.readBinaryBuffer(-1, entries.geoms.buffer, context);
                  }
                  else {
                      const basePath = folder + stem;
                      const geomLibraryJSON = {
                          numGeomsPerFile: numGeomsFiles,
                          numGeoms: this.geomLibrary.getNumGeoms(), // Note: was set during readBinary.Why do we need to provide this again?
                      };
                      this.geomLibrary.loadGeomFilesStream(geomLibraryJSON, basePath, context);
                  }
                  resolve();
              }, (error) => {
                  this.emit('error', error);
                  reject(error);
              });
          });
      }
  }
  Registry.register('VLAAsset', VLAAsset);

  /* eslint-disable guard-for-in */
  // AssetItem.registerDataLoader('.obj', ObjDataLoader);
  /**
   * Class designed to load and handle `.obj` files.
   * Which define the geometry and other properties for objects.
   *
   * **Parameters**
   * * **splitObjects(`BooleanParameter`):** _todo_
   * * **splitGroupsIntoObjects(`BooleanParameter`):** _todo_
   * * **loadMtlFile(`BooleanParameter`):** _todo_
   * * **unitsConversion(`NumberParameter`):** _todo_
   * * **defaultShader(`StringParameter`):** _todo_
   *
   * **Events**
   * * **loaded:** Triggered once everything is loaded.
   * * **geomsLoaded:** Triggered once all geometries are loaded.
   *
   * @extends AssetItem
   */
  class ObjAsset extends AssetItem {
      splitObjects = new BooleanParameter('splitObjects', false);
      splitGroupsIntoObjects = new BooleanParameter('splitGroupsIntoObjects', false);
      loadMtlFile = new BooleanParameter('loadMtlFile', true);
      unitsConversion = new NumberParameter('unitsConversion', 1.0);
      defaultShader = new StringParameter('defaultShader', '');
      /**
       * Create an obj asset.
       * @param name - The name of the object asset.
       */
      /**
       * @member splitObjectsParam - TODO
       */
      splitObjectsParam = new BooleanParameter('splitObjects', false);
      /**
       * @member splitGroupsIntoObjectsParam - TODO
       */
      splitGroupsIntoObjectsParam = new BooleanParameter('splitGroupsIntoObjects', false);
      /**
       * @member loadMtlFileParam - TODO
       */
      loadMtlFileParam = new BooleanParameter('loadMtlFile', true);
      /**
       * @member unitsConversionParam - TODO
       */
      unitsConversionParam = new NumberParameter('unitsConversion', 1.0);
      /**
       * @member defaultShaderParam - The default shader to use.
       */
      defaultShaderParam = new StringParameter('defaultShader', '');
      constructor(name) {
          super(name);
          this.addParameter(this.splitObjectsParam);
          this.addParameter(this.splitGroupsIntoObjectsParam);
          this.addParameter(this.loadMtlFileParam);
          this.addParameter(this.unitsConversionParam);
          this.addParameter(this.defaultShaderParam);
      }
      /**
       * Loads all the geometries and metadata from the Obj file.
       * @param url - The URL of the asset to load
       * @return - Returns a promise that resolves once the initial load is complete
       */
      load(url) {
          this.loaded = false;
          return new Promise((resolve, reject) => {
              const fileFolder = url.substring(0, url.lastIndexOf('/')) + '/';
              const parseMtlData = (mtlFileData) => {
                  const lines = mtlFileData.split('\n');
                  const WHITESPACE_RE = /\s+/;
                  let material;
                  const parseColor = function (elements) {
                      if (elements.length == 3)
                          return new Color(parseFloat(elements[0]), parseFloat(elements[1]), parseFloat(elements[2]));
                      else
                          throw new Error('Unable to parse a color from the following parts:' + elements.join('_'));
                  };
                  const parseMap = (name, filename) => {
                      const fileImage = new FileImage(name);
                      fileImage.load(fileFolder + filename);
                      return fileImage;
                  };
                  for (let i = 0; i < lines.length; i++) {
                      let line = lines[i].trim();
                      if (line.startsWith('#'))
                          continue;
                      if (line.includes('#'))
                          line = line.substring(0, line.indexOf('#')).trim();
                      const elements = line.split(WHITESPACE_RE);
                      const key = elements.shift();
                      const value = elements.join(' ');
                      switch (key) {
                          case 'newmtl':
                              material = new StandardSurfaceMaterial(value);
                              this.materialLibrary.addMaterial(material);
                              break;
                          case 'Kd': {
                              material.baseColorParam.value = parseColor(elements);
                              material.baseColorParam.colorSpace == exports.ColorSpace.Linear;
                              break;
                          }
                          case 'map_Kd': {
                              material.baseColorParam.setImage(parseMap('map_Kd', elements[0]));
                              break;
                          }
                          case 'Ks':
                              const specular = (parseFloat(elements[0]) + parseFloat(elements[1]) + parseFloat(elements[2])) / 3.0;
                              material.roughnessParam.value = 1.0 - specular;
                              material.reflectanceParam.value = specular;
                              break;
                          case 'map_Ks':
                              material.roughnessParam.setImage(parseMap('map_Ks', elements[0])); /* flags=TEXTURE_INVERT */
                              material.reflectanceParam.value = 0.2;
                              break;
                          case 'd':
                              material.opacityParam.value = parseFloat(value);
                              break;
                          case 'map_d':
                              material.opacityParam.setImage(parseMap('map_Kd', elements[0]));
                              break;
                          case 'map_bump':
                              material.normalParam.setImage(parseMap('normal', elements[0])); /* flags=BUMP_TO_NORMAL */
                              break;
                          // console.warn("Unhandled material parameter: '" + key +"' in:" + filePath);
                      }
                  }
              };
              const loadMtlFile = (mtlFile) => {
                  return new Promise((resolve) => {
                      loadTextfile(mtlFile, (fileData) => {
                          resourceLoader.incrementWorkDone(1);
                          parseMtlData(fileData);
                          resourceLoader.incrementWorkDone(1);
                          resolve();
                      });
                  });
              };
              const vertices = [];
              const normals = [];
              const texCoords = [];
              const geomDatas = {};
              const parseObjData = async (fileData) => {
                  // performance.mark("parseObjData");
                  // array of lines separated by the newline
                  const lines = fileData.split('\n');
                  const WHITESPACE_RE = /\s+/;
                  let currGeom = undefined;
                  let currMtl = undefined;
                  let numGeoms = 0;
                  const newGeom = (name) => {
                      if (name in geomDatas) {
                          let suffix = 1;
                          while (name + String(suffix) in geomDatas) {
                              suffix++;
                          }
                          name = name + String(suffix);
                      }
                      currGeom = {
                          verticesRemapping: {},
                          texCoordsRemapping: {},
                          normalsRemapping: {},
                          vertexIndices: [],
                          texCoordIndices: [],
                          normalIndices: [],
                          numVertices: 0,
                          numTexCoords: 0,
                          numNormals: 0,
                          faceCounts: [],
                          material: currMtl,
                      };
                      geomDatas[name] = currGeom;
                      numGeoms++;
                  };
                  newGeom('geom');
                  const splitGroupsIntoObjects = this.splitGroupsIntoObjectsParam.value;
                  const stop = false;
                  // let numPolys = 0;
                  for (let i = 0; i < lines.length && !stop; i++) {
                      let line = lines[i].trim();
                      if (line.startsWith('#'))
                          continue;
                      if (line.includes('#'))
                          line = line.substring(0, line.indexOf('#')).trim();
                      const elements = line.split(WHITESPACE_RE);
                      const key = elements.shift();
                      const value = elements.join(' ');
                      switch (key) {
                          case '':
                          case 's':
                              // ignore shading groups
                              continue;
                          case 'mtllib':
                              if (!this.loadMtlFileParam.value)
                                  continue;
                              // Load and parse the mat lib.
                              resourceLoader.incrementWorkload(2);
                              const mtlFile = fileFolder + value;
                              if (mtlFile) {
                                  await loadMtlFile(mtlFile);
                              }
                              break;
                          case 'o':
                              newGeom(value);
                              break;
                          case 'usemtl':
                              currMtl = value;
                              newGeom(value + Object.keys(geomDatas).length);
                              break;
                          case 'g':
                              if (splitGroupsIntoObjects) {
                                  newGeom(value ? elements.join('_') : 'Group' + numGeoms);
                              }
                              break;
                          case 'v':
                              vertices.push(elements.map((i) => parseFloat(i)));
                              break;
                          case 'vt':
                              texCoords.push(elements.map((i) => parseFloat(i)));
                              break;
                          case 'vn':
                              normals.push(elements.map((i) => parseFloat(i)));
                              break;
                          case 'f': {
                              const v_poly = [];
                              const vt_poly = [];
                              const vn_poly = [];
                              for (let j = 0, eleLen = elements.length; j < eleLen; j++) {
                                  // v/vt/vn
                                  const indices = elements[j].split('/').map((i) => parseInt(i) - 1);
                                  const v = indices[0];
                                  // v_poly.push(v);
                                  let v_index = currGeom.verticesRemapping[v];
                                  if (v_index == undefined) {
                                      v_index = currGeom.numVertices;
                                      currGeom.verticesRemapping[v] = v_index;
                                      currGeom.numVertices++;
                                  }
                                  v_poly.push(v_index);
                                  if (indices.length > 1 && !isNaN(indices[1])) {
                                      const vt = indices[1];
                                      vt_poly.push(vt);
                                  }
                                  if (indices.length > 2 && !isNaN(indices[2])) {
                                      const vn = indices[2];
                                      vn_poly.push(vn);
                                  }
                              }
                              currGeom.vertexIndices.push(v_poly);
                              if (vn_poly.length > 0)
                                  currGeom.normalIndices.push(vn_poly);
                              if (vt_poly.length > 0)
                                  currGeom.texCoordIndices.push(vt_poly);
                              if (currGeom.faceCounts[v_poly.length - 3] == undefined) {
                                  currGeom.faceCounts[v_poly.length - 3] = [];
                              }
                              currGeom.faceCounts[v_poly.length - 3]++;
                              // numPolys++;
                              // if(numPolys == 16000)
                              //     stop = true;
                              break;
                          }
                          default: {
                              console.warn('Unhandled line:' + line);
                          }
                      }
                  }
              };
              const buildChildItems = () => {
                  // performance.mark("parseObjDataDone");
                  // performance.mark("buildObjTree");
                  for (const geomName in geomDatas) {
                      if (geomDatas[geomName].numVertices == 0)
                          continue;
                      buildChildItem(geomName, geomDatas[geomName]);
                  }
                  // Done.
                  this.emit('loaded');
                  this.getGeometryLibrary().emit('loaded');
                  this.emit('geomsLoaded');
                  resolve();
              };
              const buildChildItem = (geomName, geomData) => {
                  for (let i = 0; i < geomData.faceCounts.length; i++) {
                      if (geomData.faceCounts[i] == undefined) {
                          geomData.faceCounts[i] = 0;
                      }
                  }
                  const numVertices = geomData.numVertices;
                  const mesh = new Mesh();
                  mesh.name = geomName;
                  mesh.setFaceCounts(geomData.faceCounts);
                  mesh.setNumVertices(numVertices);
                  const positionsAttr = mesh.getVertexAttribute('positions');
                  const unitsConversion = this.unitsConversionParam.value;
                  for (const vsrcKey in geomData.verticesRemapping) {
                      const vsrc = Number.parseInt(vsrcKey);
                      const vtgt = geomData.verticesRemapping[vsrc];
                      positionsAttr.setValue(vtgt, new Vec3(vertices[vsrc][0] * unitsConversion, vertices[vsrc][1] * unitsConversion, vertices[vsrc][2] * unitsConversion));
                  }
                  let normalsAttr;
                  let texCoordsAttr;
                  if (geomData.normalIndices.length > 0) {
                      normalsAttr = new Vec3Attribute();
                      mesh.addVertexAttribute('normals', normalsAttr); // TODO: this method returns void
                  }
                  if (geomData.texCoordIndices.length > 0) {
                      texCoordsAttr = new Vec2Attribute();
                      mesh.addVertexAttribute('texCoords', texCoordsAttr);
                  }
                  const loadedFaces = Array(geomData.faceCounts.length).fill(0);
                  for (let i = 0; i < geomData.vertexIndices.length; i++) {
                      const v_poly = geomData.vertexIndices[i];
                      let faceId = 0;
                      for (let j = 0; j < v_poly.length - 3; ++j) {
                          if (geomData.faceCounts[j])
                              faceId += geomData.faceCounts[j];
                      }
                      faceId += loadedFaces[v_poly.length - 3];
                      loadedFaces[v_poly.length - 3]++;
                      mesh.setFaceVertexIndices(faceId, v_poly);
                      // Set the texCoords and normals...
                      if (normalsAttr) {
                          const vn_poly = geomData.normalIndices[i];
                          for (let j = 0; j < vn_poly.length; j++) {
                              const value = new Vec3(normals[vn_poly[j]][0], normals[vn_poly[j]][1], normals[vn_poly[j]][2]);
                              normalsAttr.setFaceVertexValue(faceId, j, value);
                          }
                      }
                      if (texCoordsAttr && geomData.texCoordIndices.length == geomData.vertexIndices.length) {
                          const vt_poly = geomData.texCoordIndices[i];
                          for (let j = 0; j < vt_poly.length; j++) {
                              const value = new Vec2(texCoords[vt_poly[j]][0], texCoords[vt_poly[j]][1]);
                              texCoordsAttr.setFaceVertexValue(faceId, j, value);
                          }
                      }
                  }
                  const geomItem = new GeomItem(geomName, mesh);
                  // Move the transform of the geom item to the center of the geom.
                  // This is so that transparent objects can render correctly, and the
                  // transform gizmo becomes centered on each geom(for testing)
                  const delta = mesh.getBoundingBox().center();
                  {
                      const offset = delta.negate();
                      const positions = mesh.getVertexAttribute('positions');
                      for (let i = 0; i < positions.getCount(); i++) {
                          positions.setValue(i, positions.getValue(i).add(offset));
                      }
                      mesh.setBoundingBoxDirty();
                  }
                  geomItem.localXfoParam.value = new Xfo(delta);
                  if (geomData.material != undefined && this.materialLibrary.hasMaterial(geomData.material)) {
                      geomItem.materialParam.value = this.materialLibrary.getMaterial(geomData.material);
                  }
                  else {
                      const defaultShader = this.defaultShaderParam.value;
                      const material = new Material(geomName + ' mat');
                      material.setShaderName(defaultShader != '' ? defaultShader : 'StandardSurfaceShader');
                      this.materialLibrary.addMaterial(material);
                      geomItem.materialParam.value = material;
                  }
                  this.addChild(geomItem, false);
              };
              const loadObjData = () => {
                  resourceLoader.incrementWorkload(2);
                  loadTextfile(url, (fileData) => {
                      resourceLoader.incrementWorkDone(1);
                      parseObjData(fileData).then(() => {
                          buildChildItems();
                          resourceLoader.incrementWorkDone(1);
                      });
                  }, (error) => {
                      this.emit('error', error);
                      reject(error);
                  });
              };
              loadObjData();
          });
      }
  }

  /**
   * The BaseTool provides an interface you can implement to define your own mouse, keyboard, and touch event handlers.
   *
   * A tool is a class that is delegated the handling of all user interaction events. The built-in {CameraManipulator}
   * class provides a default tool for moving the viewport camera.
   *
   * You can define your own custom tool, and replace the default CameraManipulator like so.
   * ```javascript
   *   const customManipulator = new MyCustomCameraManipulator()
   *   renderer.getViewport().setManipulator(customManipulator)
   * ```
   *
   * Each tool should provide handlers for the main types of events it will be responsible for handling.
   * These include mouse, keyboard, touch and VR events. Once a tool is installed on the viewport, the viewport
   * will start invoking the handler methods defined in the interface.
   * If the Tool handles an event, it should call stopPropagation on the event so the engine knows to stop the
   * propagation of the event to other classes.
   *
   * > Note: VR Events are ann emulation of mouse events, generated by the engine, allowing custom tools to be used to provide various VR interactions.
   *
   * **Events**
   * * **installChanged:** Triggered when the tool is installed or uninstalled.
   * * **activatedChanged:** Triggered when a tool is activated or deactivated.
   *
   * @extends ParameterOwner
   */
  class BaseTool extends ParameterOwner {
      __activated = false;
      /**
       * Creates an instance of BaseTool.
       */
      constructor() {
          super();
      }
      /**
       * Enables tools usage. This method is called by either the Viewport when a tool is removed, or the ToolManage if it is installed.
       */
      activateTool() {
          if (this.__activated)
              throw new Error('Tool already activate');
          this.__activated = true;
          this.emit('activatedChanged', { activated: this.__activated });
      }
      /**
       * Disables tool usage. This method is called by either the Viewport when a tool is removed, or the ToolManage if it is installed.
       */
      deactivateTool() {
          this.__activated = false;
          this.emit('activatedChanged', { activated: this.__activated });
      }
      // ///////////////////////////////////
      // Pointer events
      /**
       * Event fired when either the mouse button is pressed, or a touch start event occurs.
       *
       * @param event - The event param.
       */
      onPointerDown(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when either the mouse cursor is moved, or a touch point moves.
       *
       * @param event - The event param.
       */
      onPointerMove(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when either the mouse button is released, or a touch end event occurs.
       *
       * @param event - The event param.
       */
      onPointerUp(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when a pointing device button is clicked.
       *
       * @param event - The event param.
       */
      onPointerClick(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when a pointing device button is double clicked.
       *
       * @param event - The event param.
       */
      onPointerDoubleClick(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when a pointing device button is held for a long time..
       *
       * @param event - The event param.
       */
      onPointerLongPress(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when a mouse pointer enters the viewport
       *
       * @param event - The event param.
       */
      onPointerEnter(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when a mouse pointer leaves the viewport
       *
       * @param event - The event param.
       */
      onPointerLeave(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when the user rotates the pointing device wheel.
       *
       * @param event - The event param.
       */
      onWheel(event) {
          // console.warn('Implement me')
      }
      // ///////////////////////////////////
      // Keyboard events
      /**
       * Event fired when the user presses down a key on the keyboard.
       *
       * @param event - The event param.
       */
      onKeyDown(event) {
          // console.warn('Implement me')
      }
      /**
       * Event fired when the user releases a key on the keyboard.
       *
       * @param event - The event param.
       */
      onKeyUp(event) {
          // console.warn('Implement me')
      }
      // ///////////////////////////////////
      // Touch events
      /**
       * Event fired when one or more touch points have been disrupted in an implementation-specific manner.
       *
       * @param event - The event param.
       */
      onTouchCancel(event) {
          // console.warn('Implement me')
      }
  }

  /* eslint-disable require-jsdoc */
  const MANIPULATION_MODES = {
      pan: 0,
      dolly: 1,
      zoom: 2,
      look: 3,
      turntable: 4,
      tumbler: 5,
      trackball: 6,
  };
  /**
   * Class for defining and interaction model of the camera.
   *
   * The CameraManipulator supports a variety of manipulation modes, and hotkeys/modifier keys
   * that allow the user to rapidly switch between modes, such as 'turntable' and 'pan'.
   * A detailed explanation of various camera manipulation modes can be found
   * here: https://www.mattkeeter.com/projects/rotation/
   *
   * **MANIPULATION_MODES**
   * * **pan:** Translates the camera sideways according the the camera's current orientation. Activated by the right mouse button, or two fingered touches on mobile.
   * * **dolly:** Translates the camera forwards and backwards according the the camera's current orientation. Activated by holding the ctrl and alt keys while using the left mouse button, or the mouse wheel, or two fingered touches on mobile.
   * * **focussing:** Focusses the camera on a specific 3d point in the scene. Activated by double clicking, or double tapping on a geometry in the 3d view.
   * * **look:** Rotates the camera around its own position. Useful for simulating looking by turning ones head inside a scene. Activated by holding the ctrl key and right mouse button.
   * * **turntable:** Rotates the camera around the current camera target, using the turntable style manipulation described above. Activated by the left mouse button.
   * * **tumbler:** Rotates the camera around the current camera target, using the tumbler style manipulation described above. Activated by the left mouse button.
   * * **trackball:** Rotates the camera around the current camera target, using the trackball style manipulation described above. Activated by the left mouse button.
   *
   * The default manipulation mode, is the mode that is active with only the left mouse button. The default manipulation mode is currently 'turntable'.
   *
   * To Assign a different default manipulation mode, retrieve the manipulator from the viewport
   * and set the default mode.
   * ```
   * const cameraManipulator = renderer.getViewport().getManipulator()
   * cameraManipulator.setDefaultManipulationMode(CameraManipulator.MANIPULATION_MODES.trackball);
   * ```
   *
   * This class is the default manipulator, and can be replaced with custom manipulators.
   *
   * ```
   * const customManipulator = new CustomCameraManipulator()
   * renderer.getViewport().setManipulator(customManipulator);
   * ```
   *
   * The Camera manipulator can focus the view on a point in the view by various gestures.
   * A single click or touch tap can cause the view to be focussed or a double click or tap.
   * This behavior can be configured using the 2 values.
   * e.g. to disable all focus gestures, set both values to zero.
   * ```
   * // Make the aim focus occur after a single touch or click.
   * const cameraManipulator = renderer.getViewport().getManipulator()
   * cameraManipulator.aimFocusOnTouchTap = 1
   * cameraManipulator.aimFocusOnMouseClick = 1
   * ```
   *
   * **Parameters**
   * * **OrbitRate(`NumberParameter`):** The rate at which mouse or touch interactions are translated camera orientation changes.
   * * **DollySpeed(`NumberParameter`):** The rate at which the mouse button or touch interactions are translated camera dolly movement.
   * * **mouseWheelDollySpeed(`NumberParameter`):** The rate at which the mouse wheel interactions are translated camera dolly movement.
   *
   *   Note: this value defaults to different values for touch based interfaces to mouse based input.
   *   For mobile devices, the orbit rate defaults to 0.5, and for mouse based interaction, the value defaults to 1.
   *   A value of 1 means that the camera will rotate 180 degrees for a mouse interaction that spans from the left border of the viewport to the right border.
   *   Some applications might require lower, or higher default values
   *
   * To set different default values for mobile or desktop set a different value based on the SystemDesc.isMobileDevice flag.
   * ```
   * const cameraManipulator = renderer.getViewport().getManipulator()
   * cameraManipulator.getParameter('OrbitRate').setValue(SystemDesc.isMobileDevice ? 0.1 : 0.4)
   * ```
   *
   * **Events**
   * * **movementFinished:** Emitted when a camera movement is finished. E.g. when the user releases the mouse after a dolly, or after the focussing action has completed.
   * * **aimingFocus:** Emitted when a camera is being focussed on a target. E.g. when the user double clicks the mouse on a geometry in the view.
   *
   * @extends BaseTool
   */
  class CameraManipulator extends BaseTool {
      appData;
      orbitAroundCursor = false;
      zoomTowardGeomUnderCursor = false;
      aimFocusOnTouchTap = 2;
      aimFocusOnMouseClick = 2;
      enabledWASDWalkMode = false;
      defaultManipulationState = MANIPULATION_MODES.turntable;
      prevCursor;
      manipulationState;
      pointerDown = false;
      dragging = 0;
      keyboardMovement = false;
      keysPressed = [];
      velocity = new Vec3();
      prevVelocityIntegrationTime = -1;
      ongoingTouches = {};
      orbitTarget;
      prevMousePos;
      focusIntervalId;
      mouseWheelMovementDist = 0;
      mouseWheelZoomCount = 0;
      mouseWheelZoomId = -1;
      /**
       * @member orbitRateParam - The rate at which mouse or touch interactions are translated camera orientation changes.
       */
      orbitRateParam = new NumberParameter('OrbitRate', SystemDesc.isMobileDevice ? 0.5 : 1);
      /**
       * @member dollySpeedParam - The rate at which the mouse button or touch interactions are translated camera dolly movement.
       */
      dollySpeedParam = new NumberParameter('DollySpeed', 0.001);
      /**
       * @member mouseWheelDollySpeedParam - The rate at which the mouse wheel interactions are translated camera dolly movement.
       */
      mouseWheelDollySpeedParam = new NumberParameter('MouseWheelDollySpeed', 0.1);
      /**
       * @member walkSpeedParam - TODO
       */
      walkSpeedParam = new NumberParameter('WalkSpeed', 5); // Value is in meters/second
      /**
       * @member walkModeCollisionDetection - TODO
       */
      walkModeCollisionDetection = new BooleanParameter('WalkModeCollisionDetection', false);
      /**
       * Create a camera, mouse and keyboard
       * @param appData - The object containing the scene and the renderer.
       */
      constructor(appData) {
          super();
          this.appData = appData;
          this.defaultManipulationState = MANIPULATION_MODES.turntable;
          this.manipulationState = this.defaultManipulationState;
          this.addParameter(this.orbitRateParam);
          this.addParameter(this.dollySpeedParam);
          this.addParameter(this.mouseWheelDollySpeedParam);
          this.addParameter(this.walkSpeedParam);
          this.addParameter(this.walkModeCollisionDetection);
      }
      /**
       * Enables tools usage.
       */
      activateTool() {
          super.activateTool();
          if (this.appData && this.appData.renderer) {
              this.prevCursor = this.appData.renderer.getGLCanvas().style.cursor;
              this.appData.renderer.getGLCanvas().style.cursor = 'cursor';
          }
      }
      /**
       * Disables tool usage.
       */
      deactivateTool() {
          super.deactivateTool();
          if (this.appData && this.appData.renderer) {
              this.appData.renderer.getGLCanvas().style.cursor = this.prevCursor;
          }
      }
      /**
       * Sets default manipulation mode.
       * The value can be on of the keys in #CameraManipulator.MANIPULATION_MODES
       *
       * @param manipulationMode - The manipulation mode value.
       */
      setDefaultManipulationMode(manipulationMode) {
          if (typeof manipulationMode == 'string') {
              this.defaultManipulationState = MANIPULATION_MODES[manipulationMode];
          }
          else
              this.defaultManipulationState = manipulationMode;
          if (!Object.values(MANIPULATION_MODES).includes(this.defaultManipulationState)) {
              throw new Error('Invalid Camera Manipulation Mode. Must be one of ' + Object.keys(MANIPULATION_MODES));
          }
      }
      /**
       * The look method.
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      look(event, dragVec) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const orbitRate = this.orbitRateParam.value;
          const globalXfo = camera.globalXfoParam.value;
          // Orbit
          const orbit = new Quat();
          orbit.rotateZ((dragVec.x / viewport.getWidth()) * Math.PI * orbitRate);
          globalXfo.ori = orbit.multiply(globalXfo.ori);
          // Pitch
          const pitch = new Quat();
          pitch.rotateX((dragVec.y / viewport.getHeight()) * Math.PI * orbitRate);
          globalXfo.ori.multiplyInPlace(pitch);
          camera.globalXfoParam.value = globalXfo;
      }
      /**
       * Rotates viewport camera about the target.
       *
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      turntable(event, dragVec) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const orbitRate = this.orbitRateParam.value;
          const globalXfo = camera.globalXfoParam.value;
          const cameraTargetOffset = globalXfo.ori.inverse().rotateVec3(globalXfo.tr.subtract(this.orbitTarget));
          // Orbit
          const orbit = new Quat();
          orbit.rotateZ((dragVec.x / viewport.getWidth()) * 2 * Math.PI * -orbitRate);
          globalXfo.ori = orbit.multiply(globalXfo.ori);
          // Pitch
          const pitch = new Quat();
          pitch.rotateX((dragVec.y / viewport.getHeight()) * Math.PI * -orbitRate);
          globalXfo.ori.multiplyInPlace(pitch);
          globalXfo.tr = this.orbitTarget.add(globalXfo.ori.rotateVec3(cameraTargetOffset));
          camera.globalXfoParam.value = globalXfo;
      }
      /**
       * Rotates viewport camera about the target.
       *
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      tumbler(event, dragVec) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const orbitRate = this.orbitRateParam.value;
          const globalXfo = camera.globalXfoParam.value;
          const xVec = globalXfo.ori.getXaxis();
          const yVec = globalXfo.ori.getYaxis();
          const zVec = globalXfo.ori.getZaxis();
          const vec = xVec.scale(-dragVec.x).add(yVec.scale(dragVec.y));
          const rotateAxis = vec.cross(zVec);
          rotateAxis.normalizeInPlace();
          const dragVecLength = dragVec.length();
          const cameraTargetOffset = globalXfo.ori.inverse().rotateVec3(globalXfo.tr.subtract(this.orbitTarget));
          // Orbit
          const orbit = new Quat();
          orbit.setFromAxisAndAngle(rotateAxis, (dragVecLength / viewport.getWidth()) * Math.PI * -orbitRate);
          globalXfo.ori = orbit.multiply(globalXfo.ori);
          globalXfo.tr = this.orbitTarget.add(globalXfo.ori.rotateVec3(cameraTargetOffset));
          camera.globalXfoParam.value = globalXfo;
      }
      /**
       * Rotates viewport camera about the target.
       *
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      trackball(event, dragVec) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const orbitRate = this.orbitRateParam.value;
          const globalXfo = camera.globalXfoParam.value;
          const xVec = globalXfo.ori.getXaxis();
          const yVec = globalXfo.ori.getYaxis();
          const zVec = globalXfo.ori.getZaxis();
          const vec = xVec.scale(-dragVec.x).add(yVec.scale(dragVec.y));
          const rotateAxis = vec.cross(zVec);
          rotateAxis.normalizeInPlace();
          const dragVecLength = dragVec.length();
          const cameraTargetOffset = globalXfo.ori.inverse().rotateVec3(globalXfo.tr.subtract(this.orbitTarget));
          // Orbit
          const orbit = new Quat();
          orbit.setFromAxisAndAngle(rotateAxis, (dragVecLength / viewport.getWidth()) * Math.PI * -orbitRate);
          globalXfo.ori = orbit.multiply(globalXfo.ori);
          globalXfo.tr = this.orbitTarget.add(globalXfo.ori.rotateVec3(cameraTargetOffset));
          camera.globalXfoParam.value = globalXfo;
      }
      /**
       * Rotates the camera around its own `X`,`Y` axes.
       *
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      pan(event, dragVec) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const delta = new Xfo();
          const xAxis = new Vec3(1, 0, 0);
          const yAxis = new Vec3(0, 1, 0);
          if (camera.isOrthographic()) {
              const frustumHeight = camera.getFrustumHeight();
              const frustumWidth = frustumHeight * (viewport.getWidth() / viewport.getHeight());
              delta.tr = xAxis.scale(-(dragVec.x / viewport.getWidth()) * frustumWidth);
              delta.tr.addInPlace(yAxis.scale((dragVec.y / viewport.getHeight()) * frustumHeight));
          }
          else {
              const focalDistance = camera.getFocalDistance();
              const fovY = camera.getFov();
              const cameraPlaneHeight = 2.0 * focalDistance * Math.tan(0.5 * fovY);
              const cameraPlaneWidth = cameraPlaneHeight * (viewport.getWidth() / viewport.getHeight());
              delta.tr = xAxis.scale(-(dragVec.x / viewport.getWidth()) * cameraPlaneWidth);
              delta.tr.addInPlace(yAxis.scale((dragVec.y / viewport.getHeight()) * cameraPlaneHeight));
          }
          const cameraXfo = camera.globalXfoParam.value;
          camera.globalXfoParam.value = cameraXfo.multiply(delta);
      }
      /**
       * Dollying moves the camera forward at a constant speed, not changing the focal distance.
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      dolly(event, pointerPos, dragVec) {
          const viewport = event.viewport;
          const camera = viewport.getCamera();
          const focalDistance = camera.getFocalDistance();
          // As we click and drag away from the center of the screen, we move forward.
          // Like pullingoutelves into the screen farther.
          const screenCenter = new Vec2(viewport.getWidth() * 0.5, viewport.getHeight() * 0.5);
          const vecFromCenter = pointerPos.subtract(screenCenter).normalize();
          const dragDist = dragVec.dot(vecFromCenter);
          const applyMovement = () => {
              const dollyDist = dragDist * this.dollySpeedParam.value * focalDistance;
              const delta = new Xfo();
              delta.tr.set(0, 0, dollyDist);
              const globalXfo = camera.globalXfoParam.value;
              camera.globalXfoParam.value = globalXfo.multiply(delta);
          };
          const applyViewScale = () => {
              const dollyDist = dragDist * this.dollySpeedParam.value;
              const viewHeight = camera.getFrustumHeight();
              const zoomDist = viewHeight * dollyDist;
              camera.setFrustumHeight(viewHeight + zoomDist);
          };
          if (camera.isOrthographic()) {
              applyViewScale();
          }
          else {
              applyMovement();
          }
      }
      /**
       * Zooms the camera towards the target.
       * @param event - The event value.
       * @param dragVec - The drag vector value.
       */
      zoom(event, dragStartPos, dragVec) {
          const viewport = event.viewport;
          const camera = viewport.getCamera();
          const focalDistance = camera.getFocalDistance();
          // As we click and drag away from the center of the screen, we move forward.
          // Like pullingoutelves into the screen farther.
          const screenCenter = new Vec2((viewport.getWidth() * 0.5) / window.devicePixelRatio, (viewport.getHeight() * 0.5) / window.devicePixelRatio);
          const vecFromCenter = dragStartPos.subtract(screenCenter).normalize();
          const dragDist = dragVec.dot(vecFromCenter);
          const applyMovement = () => {
              const zoomDist = -dragDist * this.dollySpeedParam.value * focalDistance;
              const delta = new Xfo();
              delta.tr.set(0, 0, zoomDist);
              const globalXfo = camera.globalXfoParam.value;
              camera.setFocalDistance(focalDistance + zoomDist);
              camera.globalXfoParam.value = globalXfo.multiply(delta);
          };
          const applyViewScale = () => {
              const dollyDist = -dragDist * this.dollySpeedParam.value;
              const viewHeight = camera.getFrustumHeight();
              const zoomDist = viewHeight * dollyDist;
              camera.setFrustumHeight(viewHeight + zoomDist);
          };
          if (camera.isOrthographic()) {
              applyViewScale();
          }
          else {
              applyMovement();
          }
      }
      /**
       * The initDrag method.
       *
       * @private
       * @param event - The event value.
       */
      initDrag(event) {
          this.pointerDown = true;
          const viewport = event.viewport;
          const camera = viewport.getCamera();
          const xfo = camera.globalXfoParam.value;
          if (this.orbitAroundCursor) {
              if (event.intersectionData != undefined && this.orbitAroundCursor) {
                  this.orbitTarget = event.intersectionData.intersectionPos;
                  const vec = xfo.inverse().transformVec3(event.intersectionData.intersectionPos);
                  camera.setFocalDistance(-vec.z);
              }
              else {
                  if (event.pointerRay) {
                      this.orbitTarget = event.pointerRay.pointAtDist(camera.getFocalDistance());
                  }
                  else {
                      this.orbitTarget = xfo.tr.add(xfo.ori.getZaxis().scale(-camera.getFocalDistance()));
                  }
              }
          }
          else {
              this.orbitTarget = xfo.tr.add(xfo.ori.getZaxis().scale(-camera.getFocalDistance()));
          }
          this.dragging = 1;
      }
      /**
       * The initDrag method.
       *
       * @private
       * @param event - The event value.
       */
      endDrag(event) {
          if (event.getCapture() == this)
              event.releaseCapture();
          this.dragging = 0;
          this.pointerDown = false;
      }
      /**
       * The aimFocus method.
       *
       * @private
       * @param camera - The camera that we are aiming
       * @param target - The target to focus on.
       * @param distance - The distance from the target to get to.
       * @param duration - The duration in milliseconds to aim the focus.
       */
      aimFocus(camera, target, distance = -1, duration = 400) {
          if (this.focusIntervalId)
              clearInterval(this.focusIntervalId);
          const count = Math.round(duration / 20); // each step is 20ms
          const initalMode = this.defaultManipulationState;
          let i = 0;
          const applyMovement = () => {
              const prevGlobalXfo = camera.globalXfoParam.value;
              const initialDist = camera.getFocalDistance();
              const dir = target.subtract(prevGlobalXfo.tr);
              const currDist = dir.normalizeInPlace();
              const targetGlobalXfo = prevGlobalXfo.clone();
              if (initalMode == MANIPULATION_MODES.turntable || initalMode == MANIPULATION_MODES.look) {
                  // Orbit
                  {
                      const currDir = prevGlobalXfo.ori.getZaxis().clone();
                      currDir.z = 0;
                      const newDir = dir.negate();
                      newDir.z = 0;
                      const orbit = new Quat();
                      orbit.setFrom2Vectors(currDir, newDir);
                      targetGlobalXfo.ori = orbit.multiply(targetGlobalXfo.ori);
                  }
                  // Pitch
                  {
                      const xAxis = prevGlobalXfo.ori.getXaxis().clone();
                      const currDir = prevGlobalXfo.ori.getZaxis().clone();
                      const newDir = dir.negate();
                      newDir.subtractInPlace(xAxis.scale(newDir.dot(xAxis)));
                      newDir.normalizeInPlace();
                      const pitch = new Quat();
                      if (currDir.cross(newDir).dot(xAxis) > 0.0)
                          pitch.rotateX(currDir.angleTo(newDir));
                      else
                          pitch.rotateX(-currDir.angleTo(newDir));
                      targetGlobalXfo.ori = targetGlobalXfo.ori.multiply(pitch);
                  }
                  // Fix Roll
                  {
                      const currDir = targetGlobalXfo.ori.getXaxis().clone();
                      const newDir = currDir.clone();
                      newDir.z = 0;
                      newDir.normalizeInPlace();
                      const roll = new Quat();
                      roll.setFrom2Vectors(currDir, newDir);
                      targetGlobalXfo.ori = roll.multiply(targetGlobalXfo.ori);
                  }
              }
              else {
                  const currDir = prevGlobalXfo.ori.getZaxis().clone();
                  const newDir = dir.negate();
                  const orbit = new Quat();
                  orbit.setFrom2Vectors(currDir, newDir);
                  targetGlobalXfo.ori = orbit.multiply(targetGlobalXfo.ori);
              }
              // With each iteration we get closer to our goal
              // and on the final iteration we should aim perfectly at
              // the target.
              const t = Math.pow(i / count, 2);
              const globalXfo = prevGlobalXfo.clone();
              globalXfo.ori = prevGlobalXfo.ori.lerp(targetGlobalXfo.ori, t);
              if (distance > 0) {
                  const displacement = dir.scale(currDist - distance);
                  globalXfo.tr.addInPlace(displacement.scale(t));
              }
              camera.setFocalDistance(initialDist + (currDist - initialDist) * t);
              camera.globalXfoParam.value = globalXfo;
              i++;
              if (i <= count) {
                  // @ts-ignore
                  this.focusIntervalId = setTimeout(applyMovement, 20);
              }
              else {
                  this.focusIntervalId = undefined;
                  this.emit('movementFinished');
                  camera.emit('movementFinished');
              }
          };
          applyMovement();
      }
      /**
       * The orientPointOfView method.
       *
       * @private
       * @param camera - The camera that we are orienting
       * @param position - The target to focus on.
       * @param target - The target to focus on.
       * @param distance - The distance to the specified we want the user to be moved to
       * @param duration - The duration in milliseconds to aim the focus.
       */
      orientPointOfView(camera, position, target, distance = 0, duration = 400) {
          if (this.focusIntervalId)
              clearInterval(this.focusIntervalId);
          const count = Math.round(duration / 20); // each step is 20ms
          let i = 0;
          const applyMovement = () => {
              const initialGlobalXfo = camera.globalXfoParam.value;
              const initialTarget = camera.getTargetPosition();
              // With each iteration we get closer to our goal
              // and on the final iteration we should aim perfectly at
              // the target.
              const t = Math.pow(i / count, 2);
              // Sometimes we want to pull users to within some threshold of the specified position.
              const dirToPosition = position.subtract(initialGlobalXfo.tr);
              const currDistToPosition = dirToPosition.normalizeInPlace();
              const displacement = dirToPosition.scale(currDistToPosition - distance);
              const pos = initialGlobalXfo.tr.add(displacement.scale(t));
              const targetPos = initialTarget.lerp(target, t);
              camera.setPositionAndTarget(pos, targetPos);
              i++;
              if (i <= count) {
                  // @ts-ignore
                  this.focusIntervalId = setTimeout(applyMovement, 20);
              }
              else {
                  this.focusIntervalId = undefined;
                  this.emit('movementFinished');
                  camera.emit('movementFinished');
              }
          };
          applyMovement();
      }
      /**
       * Invoked when a user double presses a pointer over an element.
       *
       * @param event - The pointer event that occurs
       * @memberof CameraManipulator
       */
      onPointerDoubleClick(event) {
          const aimFocus = (pointerRay) => {
              const viewport = event.viewport;
              const camera = viewport.getCamera();
              const cameraGlobalXfo = camera.globalXfoParam.value;
              const aimTarget = cameraGlobalXfo.tr.add(pointerRay.dir.scale(event.intersectionData.dist));
              this.aimFocus(camera, aimTarget);
              // Note: Collab can use these mouseEvents to guide users attention.
              // @ts-ignore
              event.aimTarget = aimTarget;
              // @ts-ignore
              event.aimDistance = event.intersectionData.dist;
              this.emit('aimingFocus', event);
              camera.emit('aimingFocus', event);
              event.stopPropagation();
          };
          if (event.intersectionData && this.aimFocusOnMouseClick) {
              if (event.pointerType === POINTER_TYPES.mouse && this.aimFocusOnMouseClick == 2) {
                  const mouseEvent = event;
                  aimFocus(mouseEvent.pointerRay);
                  mouseEvent.preventDefault();
              }
              if (event.pointerType === POINTER_TYPES.touch && this.aimFocusOnTouchTap == 2) {
                  const pointerEvent = event;
                  aimFocus(pointerEvent.pointerRay);
              }
          }
      }
      /**
       * Event fired when either the mouse button is pressed, or a touch start event occurs.
       *
       * @param event - The mouse event that occurs.
       */
      onPointerDown(event) {
          if (event instanceof ZeaMouseEvent) {
              if (this.dragging == 1) {
                  this.endDrag(event);
              }
              this.initDrag(event);
              const mouseEvent = event;
              this.prevMousePos = mouseEvent.pointerPos;
              if (mouseEvent.button == 2) {
                  this.manipulationState = MANIPULATION_MODES.pan;
              }
              else if (mouseEvent.ctrlKey && mouseEvent.altKey) {
                  this.manipulationState = MANIPULATION_MODES.dolly;
              }
              else if (mouseEvent.ctrlKey || mouseEvent.button == 2) {
                  this.manipulationState = MANIPULATION_MODES.look;
              }
              else {
                  this.manipulationState = this.defaultManipulationState;
              }
              mouseEvent.preventDefault();
          }
          else if (event.pointerType === POINTER_TYPES.touch) {
              this._onTouchStart(event);
          }
      }
      /**
       * Event fired when either the mouse cursor is moved, or a touch point moves.
       *
       * @param event - The mouse event that occurs.
       */
      onPointerMove(event) {
          if (this.dragging != 0) {
              if (event instanceof ZeaMouseEvent) {
                  this._onMouseMove(event);
                  event.preventDefault();
              }
              if (event instanceof ZeaTouchEvent) {
                  this._onTouchMove(event);
              }
              this.dragging = 2;
              event.stopPropagation();
          }
      }
      /**
       * The event that occurs when the user moves the pointer across a screen.
       *
       * @param event -The event value
       */
      _onMouseMove(event) {
          if (!this.pointerDown)
              return;
          const pointerPos = event.pointerPos;
          const dragVec = pointerPos.subtract(this.prevMousePos);
          // Note: at mouse down, we selected the manipulation
          // mode to use for this interaction.
          switch (this.manipulationState) {
              case MANIPULATION_MODES.turntable:
                  this.turntable(event, dragVec);
                  break;
              case MANIPULATION_MODES.tumbler:
                  this.tumbler(event, dragVec);
                  break;
              case MANIPULATION_MODES.trackball:
                  this.trackball(event, dragVec);
                  break;
              case MANIPULATION_MODES.look:
                  this.look(event, dragVec);
                  break;
              case MANIPULATION_MODES.pan:
                  this.pan(event, pointerPos.subtract(this.prevMousePos));
                  break;
              case MANIPULATION_MODES.dolly:
                  this.dolly(event, pointerPos, dragVec);
                  break;
              case MANIPULATION_MODES.zoom:
                  this.zoom(event, pointerPos, dragVec);
                  break;
          }
          this.prevMousePos = pointerPos;
      }
      /**
       * The event that occurs when the user moves pointer across a touch screen.
       *
       * @param event - The touch event that occurs.
       * @private
       */
      _onTouchMove(event) {
          const touches = event.touches;
          if (touches.length == 1) {
              const touch = touches[0];
              const touchPos = touch.touchPos;
              const touchData = this.ongoingTouches[touch.identifier];
              if (!touchData)
                  return;
              const dragVec = touchPos.subtract(touchData.pos);
              switch (this.defaultManipulationState) {
                  case MANIPULATION_MODES.look:
                      // TODO: scale panning here.
                      dragVec.scaleInPlace(6.0);
                      this.look(event, dragVec);
                      break;
                  case MANIPULATION_MODES.turntable:
                      this.turntable(event, dragVec);
                      break;
                  case MANIPULATION_MODES.tumbler:
                      this.tumbler(event, dragVec);
                      break;
                  case MANIPULATION_MODES.trackball:
                      this.trackball(event, dragVec);
                      break;
                  case MANIPULATION_MODES.pan:
                      this.pan(event, dragVec);
                      break;
                  case MANIPULATION_MODES.dolly:
                      this.dolly(event, touchPos, dragVec);
                      break;
                  case MANIPULATION_MODES.zoom:
                      this.zoom(event, touchData.pos, dragVec);
                      break;
              }
              touchData.pos = touchPos;
          }
          else if (touches.length == 2) {
              const touch0 = touches[0];
              const touchData0 = this.ongoingTouches[touch0.identifier];
              const touch1 = touches[1];
              const touchData1 = this.ongoingTouches[touch1.identifier];
              if (!touchData0 || !touchData1)
                  return;
              const touch0Pos = touch0.touchPos;
              const touch1Pos = touch1.touchPos;
              const startSeparation = touchData1.pos.subtract(touchData0.pos).length();
              const dragSeparation = touch1Pos.subtract(touch0Pos).length();
              const separationDist = startSeparation - dragSeparation;
              const touch0Drag = touch0Pos.subtract(touchData0.pos);
              const touch1Drag = touch1Pos.subtract(touchData1.pos);
              const dragVec = touch0Drag.add(touch1Drag);
              // TODO: scale panning here.
              dragVec.scaleInPlace(0.5);
              // apply the vectors to calculate a pan and zoom
              const dragDist = separationDist * 0.002;
              const { viewport } = event;
              const camera = viewport.getCamera();
              const focalDistance = camera.getFocalDistance();
              const fovY = camera.getFov();
              const xAxis = new Vec3(1, 0, 0);
              const yAxis = new Vec3(0, 1, 0);
              const cameraPlaneHeight = 2.0 * focalDistance * Math.tan(0.5 * fovY);
              const cameraPlaneWidth = cameraPlaneHeight * (viewport.getWidth() / viewport.getHeight());
              const delta = new Xfo();
              delta.tr = xAxis.scale(-(dragVec.x / viewport.getWidth()) * cameraPlaneWidth);
              delta.tr.addInPlace(yAxis.scale((dragVec.y / viewport.getHeight()) * cameraPlaneHeight));
              const zoomDist = dragDist * focalDistance;
              camera.setFocalDistance(focalDistance + zoomDist);
              delta.tr.z += zoomDist;
              // Apply the roll
              switch (this.defaultManipulationState) {
                  case MANIPULATION_MODES.tumbler:
                  case MANIPULATION_MODES.trackball:
                      const vecPrev = touchData1.pos.subtract(touchData0.pos);
                      const vecNow = touch1Pos.subtract(touch0Pos);
                      let deltaAngle = vecPrev.normalize().angleTo(vecNow.normalize());
                      if (vecPrev.cross(vecNow) < 0.0) {
                          deltaAngle = -deltaAngle;
                      }
                      const roll = new Quat();
                      roll.rotateZ(deltaAngle);
                      delta.ori.multiplyInPlace(roll);
                      break;
              }
              const globalXfo = camera.globalXfoParam.value;
              camera.globalXfoParam.value = globalXfo.multiply(delta);
              touchData0.pos = touch0Pos;
              touchData1.pos = touch1Pos;
          }
      }
      /**
       * Event fired when either the mouse button is released, or a touch end event occurs.
       *
       * @param event - The mouse event that occurs.
       */
      onPointerUp(event) {
          if (this.dragging == 1) {
              // No dragging ocurred. Release the capture and let the event propagate like normal.
              this.endDrag(event);
              if (event.intersectionData) {
                  if ((event.pointerType === POINTER_TYPES.mouse && this.aimFocusOnMouseClick == 1) ||
                      (event.pointerType === POINTER_TYPES.touch && this.aimFocusOnTouchTap == 1)) {
                      const viewport = event.viewport;
                      const camera = viewport.getCamera();
                      const cameraGlobalXfo = camera.globalXfoParam.value;
                      const pointerRay = event.pointerType === POINTER_TYPES.mouse
                          ? event.pointerRay
                          : event.pointerRay;
                      const aimTarget = cameraGlobalXfo.tr.add(pointerRay.dir.scale(event.intersectionData.dist));
                      this.aimFocus(camera, aimTarget);
                      // Note: Collab can use these events to guide users attention.
                      // @ts-ignore
                      event.aimTarget = aimTarget;
                      // @ts-ignore
                      event.aimDistance = event.intersectionData.dist;
                      this.emit('aimingFocus', event);
                      camera.emit('aimingFocus', event);
                      // Note: for a single click (no-drag) we don't want to stop the propagation of the event.
                      event.stopPropagation();
                      if (event.pointerType === POINTER_TYPES.mouse)
                          event.preventDefault();
                  }
              }
          }
          else if (this.dragging == 2) {
              if (event.pointerType === POINTER_TYPES.mouse) {
                  this.endDrag(event);
                  this.emit('movementFinished');
                  const viewport = event.viewport;
                  viewport.getCamera().emit('movementFinished');
              }
              else if (event.pointerType === POINTER_TYPES.touch) {
                  const touchEvent = event;
                  const { changedTouches, touches } = touchEvent;
                  for (let i = 0; i < changedTouches.length; i++) {
                      this.__endTouch(changedTouches[i]);
                  }
                  if (Object.keys(this.ongoingTouches).length == 0) {
                      this.endDrag(event);
                  }
                  else if (!touches.length) {
                      this.endDrag(event);
                      this.ongoingTouches = {};
                  }
                  touchEvent.preventDefault();
              }
              event.stopPropagation();
          }
      }
      /**
       * Causes an event to occur when the mouse pointer is moved out of this viewport
       * @param event - The event that occurs.
       */
      onPointerLeave(event) {
          // If the pointer leaves the viewport, then we will no longer receive key up events,
          // so we must immediately disable movement here.
          if (this.keysPressed.length > 0) {
              this.keysPressed = [];
              this.velocity.set(0, 0, 0);
              this.keyboardMovement = false;
          }
      }
      /**
       * Invoked when the mouse wheel is rolled up or down over an element.
       *
       * @param event - The wheel event that occurs.
       */
      onWheel(event) {
          const viewport = event.viewport;
          const camera = viewport.getCamera();
          const mouseWheelDollySpeed = this.mouseWheelDollySpeedParam.value;
          const modulator = event.shiftKey ? 0.1 : 0.5;
          const xfo = camera.globalXfoParam.value;
          let dir;
          if (!camera.isOrthographic()) {
              if (this.zoomTowardGeomUnderCursor) {
                  if (event.intersectionData != undefined) {
                      dir = xfo.tr.subtract(event.intersectionData.intersectionPos);
                      dir.normalizeInPlace();
                      const viewVec = xfo.inverse().transformVec3(event.intersectionData.intersectionPos);
                      camera.setFocalDistance(-viewVec.z);
                  }
                  else {
                      const point = event.pointerRay.pointAtDist(camera.getFocalDistance());
                      dir = xfo.tr.subtract(point);
                      dir.normalizeInPlace();
                  }
              }
              else {
                  dir = camera.globalXfoParam.value.ori.getZaxis();
              }
          }
          // To normalize mouse wheel speed across vendors and OSs, it is recommended to simply convert scroll value to -1 or 1
          // See here: https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
          const steps = 6;
          const direction = event.deltaY < 0 ? -1 : 1;
          const applyMovement = () => {
              const focalDistance = camera.getFocalDistance();
              const zoomDist = focalDistance * this.mouseWheelMovementDist;
              xfo.tr.addInPlace(dir.scale(zoomDist));
              camera.setFocalDistance(focalDistance + zoomDist);
              camera.globalXfoParam.value = xfo;
              this.mouseWheelZoomCount++;
              if (this.mouseWheelZoomCount < steps) {
                  this.mouseWheelZoomId = window.setTimeout(applyMovement, 10);
              }
              else {
                  this.mouseWheelZoomId = -1;
                  this.emit('movementFinished');
                  camera.emit('movementFinished');
              }
          };
          const applyDolly = () => {
              const dollyDist = 50.0 * this.mouseWheelMovementDist;
              const delta = new Xfo();
              delta.tr.set(0, 0, dollyDist);
              xfo.tr.addInPlace(dir.scale(dollyDist));
              camera.globalXfoParam.value = xfo;
          };
          const applyViewScale = () => {
              const frustumHeight = camera.getFrustumHeight();
              const zoomDist = frustumHeight * this.mouseWheelMovementDist;
              camera.setFrustumHeight(frustumHeight + zoomDist);
              if (event.intersectionData && this.zoomTowardGeomUnderCursor) {
                  const dir = xfo.tr.subtract(event.intersectionData.intersectionPos);
                  const zAxis = xfo.ori.getZaxis();
                  dir.subtractInPlace(zAxis.scale(dir.dot(zAxis)));
                  xfo.tr.addInPlace(dir.scale(zoomDist / (frustumHeight + zoomDist)));
                  camera.globalXfoParam.value = xfo;
              }
              this.mouseWheelZoomCount++;
              if (this.mouseWheelZoomCount < steps) {
                  this.mouseWheelZoomId = window.setTimeout(applyViewScale, 10);
              }
              else {
                  this.mouseWheelZoomId = -1;
                  this.emit('movementFinished');
                  camera.emit('movementFinished');
              }
          };
          if (this.mouseWheelZoomId > 0) {
              // If a new wheel event arrives while the previous is still running, modify the distance
              // and reset.
              this.mouseWheelMovementDist += (direction * mouseWheelDollySpeed * modulator * 0.5) / steps;
              this.mouseWheelZoomCount = 0;
          }
          else {
              this.mouseWheelMovementDist = (direction * mouseWheelDollySpeed * modulator) / steps;
              this.mouseWheelZoomCount = 0;
              if (camera.isOrthographic()) {
                  applyViewScale();
              }
              else {
                  if (event.ctrlKey)
                      applyDolly();
                  else
                      applyMovement();
              }
          }
          event.preventDefault();
          event.stopPropagation();
      }
      /**
       * The integrateVelocityChange method.
       * @param event - The event value.
       * @private
       */
      integrateVelocityChange(event) {
          const { viewport } = event;
          const camera = viewport.getCamera();
          const time = performance.now();
          if (this.prevVelocityIntegrationTime > 0) {
              const timeDelta = (time - this.prevVelocityIntegrationTime) / 1000;
              const speed = this.walkSpeedParam.value;
              // movement.tr = this.velocity.normalize().scale(speed * timeDelta)
              if (speed > 0.0) {
                  // As we move over a terrain, it can be helpful to allow users to walk
                  // over surfaces without falling through them. This allows users to look
                  // down while walking forwards for example.
                  // Calculate where we might be soon
                  const movement = new Xfo();
                  movement.tr = this.velocity.normalize().scale(speed * timeDelta);
                  const cameraXfo = camera.globalXfoParam.value;
                  const newXfo = cameraXfo.multiply(movement);
                  const collisionDetection = this.walkModeCollisionDetection.value;
                  if (collisionDetection) {
                      // Raycast from 1.5 meter up
                      const headHeight = 1.5;
                      const dist = 1.5;
                      const area = 0.5;
                      const raycastXfo = new Xfo(newXfo.tr);
                      const ray = new Ray(newXfo.tr, new Vec3(0, 0, -1));
                      const results = viewport.getRenderer().raycastCluster(raycastXfo, ray, dist, area, PassType.OPAQUE);
                      if (results.length > 0) {
                          let avgDist = 0;
                          // eslint-disable-next-line guard-for-in
                          results.forEach((result) => {
                              avgDist += result.dist;
                          });
                          avgDist /= results.length;
                          // Snap the movement vector to make the user rest on the ground.
                          newXfo.tr = ray.start.add(ray.dir.scale(avgDist - headHeight));
                      }
                  }
                  camera.globalXfoParam.value = newXfo;
              }
          }
          this.prevVelocityIntegrationTime = time;
      }
      /**
       * Invoked when the user is pressing a key on the keyboard.
       *
       * @param event - The keyboard event that occurs.
       */
      onKeyDown(event) {
          if (!this.enabledWASDWalkMode)
              return;
          const key = event.key.toLowerCase();
          // Note: onKeyPressed is called initially only once, and then we
          // get a series of calls. Here we ignore subsequent events.
          if (this.keysPressed.includes(key))
              return;
          switch (key) {
              case 'w':
                  this.velocity.z -= 1.0;
                  break;
              case 's':
                  this.velocity.z += 1.0;
                  break;
              case 'a':
                  this.velocity.x -= 1.0;
                  break;
              case 'd':
                  this.velocity.x += 1.0;
                  break;
              default:
                  return;
          }
          event.stopPropagation();
          this.keysPressed.push(key);
          if (!this.keyboardMovement) {
              this.keyboardMovement = true;
              this.prevVelocityIntegrationTime = performance.now();
              const animationFrame = () => {
                  this.integrateVelocityChange(event);
                  if (this.keyboardMovement) {
                      window.requestAnimationFrame(animationFrame);
                  }
              };
              window.requestAnimationFrame(animationFrame);
          }
      }
      /**
       * Invoked when the user releases a key on the keyboard.
       *
       * @param event - The event that occurs.
       */
      onKeyUp(event) {
          const key = event.key.toLowerCase();
          if (!this.keysPressed.includes(key))
              return;
          switch (key) {
              case 'w':
                  this.velocity.z += 1.0;
                  break;
              case 's':
                  this.velocity.z -= 1.0;
                  break;
              case 'a':
                  this.velocity.x += 1.0;
                  break;
              case 'd':
                  this.velocity.x -= 1.0;
                  break;
              default:
                  return;
          }
          event.stopPropagation();
          const keyIndex = this.keysPressed.indexOf(key);
          this.keysPressed.splice(keyIndex, 1);
          if (this.keysPressed.length == 0)
              this.keyboardMovement = false;
      }
      // ///////////////////////////////////
      // Touch controls
      /**
       * The __startTouch method.
       * @param touch - The touch value.
       * @private
       */
      __startTouch(touch) {
          this.ongoingTouches[touch.identifier] = {
              identifier: touch.identifier,
              pos: touch.touchPos,
          };
      }
      /**
       * The __endTouch method.
       * @param touch - The touch value.
       * @private
       */
      __endTouch(touch) {
          delete this.ongoingTouches[touch.identifier];
      }
      // Touch events
      /**
       * Invoked when the user touches an element on a touch screen.
       * @private
       * @param event - The touch event that occurs.
       */
      _onTouchStart(event) {
          const touches = event.changedTouches;
          for (let i = 0; i < touches.length; i++) {
              this.__startTouch(touches[i]);
          }
          this.initDrag(event);
      }
      /**
       * Invoked when the user removes his/her finger from the touch pad.
       *
       * @param event - The touch event that occurs.
       */
      onTouchEnd(event) {
          event.preventDefault();
          event.stopPropagation();
          const touches = event.changedTouches;
          for (let i = 0; i < touches.length; i++) {
              this.__endTouch(touches[i]);
          }
          if (Object.keys(this.ongoingTouches).length == 0)
              this.endDrag(event);
      }
      /**
       * Invoked when the touch event gets interrupted.
       *
       * @param event - The touch event that occurs.
       */
      onTouchCancel(event) {
          event.preventDefault();
          const touches = event.touches;
          for (let i = 0; i < touches.length; i++) {
              this.__endTouch(touches[i]);
          }
          if (Object.keys(this.ongoingTouches).length == 0)
              this.endDrag(event);
      }
      /**
       * Returns a dictionary of support manipulation modes.
       *
       * @param event - The touch event that occurs.
       */
      static get MANIPULATION_MODES() {
          return MANIPULATION_MODES;
      }
  }

  exports.GeomType = void 0;
  (function (GeomType) {
      GeomType[GeomType["TRIANGLES"] = 0] = "TRIANGLES";
      GeomType[GeomType["LINES"] = 1] = "LINES";
      GeomType[GeomType["POINTS"] = 2] = "POINTS";
  })(exports.GeomType || (exports.GeomType = {}));

  const create3DContext = function (canvas, opt_attribs) {
      let context = null;
      if (opt_attribs.webglContextType != undefined) {
          try {
              context = canvas.getContext(opt_attribs.webglContextType, opt_attribs);
              context.name = opt_attribs.webglContextType;
          }
          catch (e) { }
      }
      else {
          const names = ['webgl2', 'webgl'];
          for (let i = 0; i < names.length; i++) {
              const name = names[i];
              try {
                  context = canvas.getContext(name, opt_attribs);
                  context.name = name;
              }
              catch (e) { }
              if (context) {
                  break;
              }
          }
      }
      if (!context) {
          throw new Error('WebGL not supported on your system');
      }
      // context.setupInstancedQuad = setupInstancedQuad;
      // context.bindInstancedQuad = bindInstancedQuad;
      context.sizeInBytes = function (type) {
          switch (type) {
              case this.BYTE:
              case this.UNSIGNED_BYTE:
                  return 1;
              case this.SHORT:
              case this.UNSIGNED_SHORT:
                  return 2;
              case this.INT:
              case this.UNSIGNED_INT:
              case this.FLOAT:
                  return 4;
              default:
                  throw new Error('unknown type');
          }
      };
      if (context.name == 'webgl2') {
          context.floatTexturesSupported = true;
          context.__ext_float_linear = context.getExtension('OES_texture_float_linear');
          context.__ext_texture_half_float_linear = context.getExtension('OES_texture_half_float_linear');
          // Needed for rendering to float textures in an Fbo
          context.__ext_color_buffer_float = context.getExtension('EXT_color_buffer_float');
          // Safari does not support uploading HALF_FLOAT data into the GPU.
      }
      else {
          context.__ext_float = context.getExtension('OES_texture_float');
          if (context.__ext_float) {
              context.floatTexturesSupported = true;
              context.__ext_float_linear = context.getExtension('OES_texture_float_linear');
          }
          else {
              console.warn('OES_texture_float is not available');
          }
          context.__ext_half_float = context.getExtension('OES_texture_half_float');
          if (context.__ext_half_float) {
              context.HALF_FLOAT = context.__ext_half_float.HALF_FLOAT_OES;
              context.floatTexturesSupported = true;
              context.__ext_texture_half_float_linear = context.getExtension('OES_texture_half_float_linear');
          }
          // Needed for rendering to flat textures in an Fbo
          context.__ext_color_buffer_float = context.getExtension('EXT_color_buffer_float');
          context.__ext_std_derivatives = context.getExtension('OES_standard_derivatives');
          // context.__ext_sRGB = context.getExtension("EXT_sRGB");
          // context.__ext_draw_buffers = context.getExtension("WEBGL_draw_buffers");
          context.__ext_Inst = context.getExtension('ANGLE_instanced_arrays');
          if (context.__ext_Inst) {
              context.vertexAttribDivisor = context.__ext_Inst.vertexAttribDivisorANGLE.bind(context.__ext_Inst);
              context.drawArraysInstanced = context.__ext_Inst.drawArraysInstancedANGLE.bind(context.__ext_Inst);
              context.drawElementsInstanced = context.__ext_Inst.drawElementsInstancedANGLE.bind(context.__ext_Inst);
          }
          {
              // Note: OES_vertex_array_object is now supported on Safari.
              context.__ext_VAO = context.getExtension('OES_vertex_array_object');
              if (context.__ext_VAO) {
                  context.createVertexArray = context.__ext_VAO.createVertexArrayOES.bind(context.__ext_VAO);
                  context.deleteVertexArray = context.__ext_VAO.deleteVertexArrayOES.bind(context.__ext_VAO);
                  context.bindVertexArray = context.__ext_VAO.bindVertexArrayOES.bind(context.__ext_VAO);
              }
          }
          context.__ext_element_index_uint = context.getExtension('OES_element_index_uint');
          context.__ext_WEBGL_depth_texture = context.getExtension('WEBGL_depth_texture'); // Or browser-appropriate prefix
          if (context.__ext_WEBGL_depth_texture) {
              context.UNSIGNED_INT_24_8 = context.__ext_WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL;
          }
          context.DRAW_FRAMEBUFFER = context.FRAMEBUFFER;
      }
      context.__ext_frag_depth = context.getExtension('EXT_frag_depth');
      context.setupInstancedQuad = function () {
          // ////////////////////////////
          // Generate a buffer for drawing a full screen quad.
          const vertexIDs = new Float32Array([0.0, 1.0, 2.0, 3.0]);
          const indices = new Uint8Array([0, 1, 2, 2, 1, 3]);
          this.__quadVertexIdsBuffer = this.createBuffer();
          this.bindBuffer(this.ARRAY_BUFFER, this.__quadVertexIdsBuffer);
          this.bufferData(this.ARRAY_BUFFER, vertexIDs, this.STATIC_DRAW);
          this.__quadIndexBuffer = this.createBuffer();
          this.bindBuffer(this.ELEMENT_ARRAY_BUFFER, this.__quadIndexBuffer);
          this.bufferData(this.ELEMENT_ARRAY_BUFFER, indices, this.STATIC_DRAW);
          this.__quadattrbuffers = {
              vertexIDs: {
                  buffer: this.__quadVertexIdsBuffer,
                  dataType: context.FLOAT,
                  dimension: 1,
                  elementSize: 4,
                  count: vertexIDs.length,
                  shared: true /*This buffer is shared between geoms. do not destroy */,
              },
          };
      };
      context.drawQuad = function () {
          this.drawElements(this.TRIANGLES, 6, this.UNSIGNED_BYTE, 0);
      };
      return context;
  };

  const processTextureParams = function (gl, params) {
      if (!params.width || !params.height) {
          if (!params.width)
              throw new Error(`Invalid texture params. 'width' not provided`);
          if (!params.height)
              throw new Error(`Invalid texture params. 'height' not provided`);
      }
      const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      if (params.width <= 0 ||
          params.width > maxSize ||
          params.height <= 0 ||
          params.height > maxSize) {
          throw new Error('GLTextureParams: Invalid texture size. width:' +
              params.width +
              ' height:' +
              params.height +
              ' maxSize:' +
              maxSize);
      }
      const result = {
          width: params.width,
          height: params.height,
      };
      const getGLConst = (nameOrValue) => {
          return isNaN(nameOrValue) ? gl[nameOrValue] : nameOrValue;
      };
      const processParam = (name, defaultValue) => {
          if (name in params)
              result[name] = getGLConst(params[name]);
          else if (defaultValue)
              result[name] = getGLConst(defaultValue);
      };
      processParam('format');
      processParam('internalFormat', result.format);
      processParam('type', gl.UNSIGNED_BYTE);
      processParam('minFilter', params.filter ? params.filter : gl.LINEAR);
      processParam('magFilter', params.filter ? params.filter : gl.LINEAR);
      processParam('wrapS', params.wrapS ? params.wrapS : gl.CLAMP_TO_EDGE);
      processParam('wrapT', params.wrapT ? params.wrapT : gl.CLAMP_TO_EDGE);
      processParam('flipY', false);
      processParam('mipMapped', false);
      processParam('depthInternalFormat');
      processParam('depthFormat');
      processParam('depthType');
      if (params.createDepthTexture) {
          if (gl.name != 'webgl2' && !gl.__ext_WEBGL_depth_texture) {
              result['depthType'] = gl.UNSIGNED_SHORT;
          }
          else {
              if (gl.name == 'webgl2') {
                  // the proper texture format combination can be found here
                  // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
                  // https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/fbo_rtt_depth_texture.html
                  // gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT16, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
                  result['depthFormat'] = gl.DEPTH_COMPONENT;
                  result['depthType'] = gl.UNSIGNED_INT;
              }
              else {
                  result['depthFormat'] = gl.DEPTH_COMPONENT;
                  result['depthType'] = gl.UNSIGNED_INT;
              }
          }
      }
      // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
      if (result.format == gl.FLOAT) {
          if (gl.name == 'webgl2') {
              if (result.filter == gl.LINEAR && !gl.__ext_float_linear) {
                  console.warn('Floating point texture filtering not supported on result device');
                  result.filter = gl.NEAREST;
              }
          }
          else {
              if (gl.__ext_float) {
                  if (result.filter == gl.LINEAR && !gl.__ext_float_linear) {
                      console.warn('Floating point texture filtering not supported on result device');
                      result.filter = gl.NEAREST;
                  }
              }
              else {
                  if (gl.__ext_half_float) {
                      result.format = gl.HALF_FLOAT;
                      if (result.filter == gl.LINEAR && !gl.__ext_texture_half_float_linear) {
                          console.warn('Half Float texture filtering not supported on result device');
                          result.filter = gl.NEAREST;
                      }
                  }
                  else {
                      throw new Error('OES_texture_half_float is not available');
                  }
              }
          }
      }
      else if (result.format == gl.HALF_FLOAT) {
          if (gl.name == 'webgl2') ;
          else {
              if (gl.__ext_half_float) {
                  if (result.filter == gl.LINEAR && !gl.__ext_texture_half_float_linear) {
                      console.warn('Half Float texture filtering not supported on result device');
                      result.filter = gl.NEAREST;
                  }
              }
              else
                  throw new Error('OES_texture_half_float is not available');
              if (result.channels == gl.RGB) {
                  throw new Error('OES_texture_half_float onlysupports RGBA textures');
              }
          }
      }
      else if (result.format == 'sRGB') {
          if (!gl.__ext_sRGB)
              throw new Error('EXT_sRGB is not available');
      }
      // ////////////////////////////////////////////////////
      // Format ... InternalFormat combos.
      // Setup the correct combos.
      // the proper texture format combination can be found here
      // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
      // Determine the internal format from mthe format and type.
      if (result.format != undefined && gl.name == 'webgl2' && result.internalFormat == result.format) {
          if (result.type == gl.FLOAT) {
              if (result.format == gl.RED) {
                  result.internalFormat = gl.R32F;
              }
              else if (result.format == gl.RG) {
                  result.internalFormat = gl.RG32F;
              }
              else if (result.format == gl.RGB) {
                  result.internalFormat = gl.RGB32F;
              }
              else if (result.format == gl.RGBA) {
                  result.internalFormat = gl.RGBA32F;
              }
          }
          else if (result.type == gl.HALF_FLOAT) {
              if (result.format == gl.RED) {
                  result.internalFormat = gl.R16F;
              }
              else if (result.format == gl.RGB) {
                  result.internalFormat = gl.RGB16F;
              }
              else if (result.format == gl.RGBA) {
                  result.internalFormat = gl.RGBA16F;
              }
          }
          else if (result.type == gl.UNSIGNED_BYTE) {
              if (result.format == gl.RED) {
                  result.internalFormat = gl.R8;
              }
              if (result.format == gl.RGB) {
                  result.internalFormat = gl.RGB8;
              }
              else if (result.format == gl.RGBA) {
                  result.internalFormat = gl.RGBA8;
              }
          }
      }
      if (result.depthFormat != undefined) {
          if (gl.name == 'webgl2') {
              if (result.depthType == gl.UNSIGNED_SHORT) {
                  result.depthInternalFormat = gl.DEPTH_COMPONENT16;
              }
              else if (result.depthType == gl.UNSIGNED_INT) {
                  result.depthInternalFormat = gl.DEPTH_COMPONENT24;
              }
          }
          else {
              result.depthInternalFormat = result.depthFormat;
          }
      }
      return result;
  };

  /**
   * Represents a texture that contains 2-dimensional images.
   * Images have width and height, but no depth.
   *
   * @extends RefCounted
   */
  class GLTexture2D extends RefCounted {
      __gl;
      ready;
      width;
      height;
      textureType;
      textureDesc;
      __loaded;
      __bound;
      __image = null;
      __internalFormat = 0;
      __type = 0;
      __format = 0;
      __wrapParam = 0;
      params = {};
      __minFilter = 0;
      __magFilter = 0;
      __wrapS = 0;
      __wrapT = 0;
      __flipY = false;
      __mipMapped = false;
      invert = false;
      alphaFromLuminance = false;
      gltex = null;
      __typeParam = '';
      __formatParam = '';
      /**
       * Create a GL texture 2D.
       *
       * @param gl - The gl value.
       * @param params - The params value.
       */
      constructor(gl, params) {
          super();
          this.__gl = gl;
          this.ready = false;
          this.width = 0;
          this.height = 0;
          this.textureType = 1; // Default 2d 24bit texture image texture. No alpha.
          this.textureDesc = [0, 0, 0, 0]; // To be populated by derived classes.
          this.__loaded = false;
          this.__bound = false;
          if (params != undefined) {
              if (params instanceof BaseImage) {
                  this.__image = params;
                  const imageUpdated = () => {
                      // this.bufferData(data);
                      const params = this.__image.getParams();
                      const width = params.width;
                      const height = params.height;
                      const data = params.data;
                      this.bufferData(data, width, height);
                  };
                  this.__image.on('updated', imageUpdated);
                  if (this.__image.isLoaded()) {
                      this.configure(this.__image.getParams());
                  }
                  else {
                      this.__image.on('loaded', () => {
                          this.configure(this.__image.getParams());
                      });
                  }
              }
              else {
                  this.configure(params);
              }
          }
      }
      /**
       * Returns the loaded status of the 2D Texture
       *
       * @return - The return value.
       */
      isLoaded() {
          return this.__loaded;
      }
      /**
       * Returns the `BaseImage` of the GL Texture
       *
       * @return - The return value.
       */
      getImage() {
          return this.__image;
      }
      /**
       * Returns the specified value of the color components in the texture.
       *
       * @return - The return value.
       */
      getInternalFormat() {
          return this.__internalFormat;
      }
      /**
       * Returns the value of the specified data type of the texel data.
       *
       * @return - The return value.
       */
      getType() {
          return this.__type;
      }
      /**
       * Returns the value of the specified texel data. It must be the same as the `internalFormat`
       *
       * @return - The return value.
       */
      getFormat() {
          return this.__format;
      }
      /**
       * Returns the value of the specified wrapping function for texture coordinate
       *
       * @return - The return value.
       */
      getWrap() {
          return this.__wrapParam;
      }
      /**
       * Returns the value of the specified binding point.
       *
       * @return - The return value.
       */
      getMipMapped() {
          return this.__mipMapped;
      }
      /**
       * Builds the GLTexture2D using the specified parameters object.
       * Parameters must have the `BaseImage` properties structure.
       *
       * @param params - The params value.
       *
       * @param emit - The emit value.
       */
      configure(params) {
          const gl = this.__gl;
          const p = processTextureParams(gl, params); // TODO: check method
          this.params = p;
          this.__format = p.format;
          this.__internalFormat = p.internalFormat;
          this.__type = p.type;
          this.__minFilter = p.minFilter;
          this.__magFilter = p.magFilter;
          this.__wrapS = p.wrapS;
          this.__wrapT = p.wrapT;
          this.__flipY = 'flipY' in params ? params.flipY : false;
          this.__mipMapped = 'mipMapped' in params ? params.mipMapped : false;
          this.invert = 'invert' in params ? params.invert : false;
          this.alphaFromLuminance = 'alphaFromLuminance' in params ? params.alphaFromLuminance : false;
          this.textureType = 1; // Default 2d 8 bit texture image texture.
          this.textureDesc[0] = this.width;
          this.textureDesc[1] = this.height;
          // Detect an 8 bit image with an alpha channel.
          if (this.textureType == 1 && this.__format == gl.RGBA) {
              this.textureType = 2; // 32bit BPP image.
          }
          if (this.gltex) {
              gl.deleteTexture(this.gltex);
          }
          this.gltex = gl.createTexture();
          this.updateGLTexParams();
          const width = p.width;
          const height = p.height;
          const data = params.data;
          if (data) {
              this.bufferData(data, width, height, false, false);
          }
          else {
              this.resize(width, height, false, false);
          }
          if (!this.__loaded) {
              this.emit('ready');
              this.__loaded = true;
          }
      }
      activateLastTextureUnit() {
          // Load the image into the GPU for rendering.
          // We often need to populate textures during rendering.
          // e.g. when lazily updating a texture containing geometry
          // buffers (FatPoints)
          // We don't want to bind over an existing texture, so we use the
          // last texture unit. (we bind starting from 0, and go up)
          const gl = this.__gl;
          const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          gl.activeTexture(gl.TEXTURE0 + maxTextures - 1);
      }
      /**
       * The updateGLTexParams method.
       * @private
       */
      updateGLTexParams() {
          const gl = this.__gl;
          this.activateLastTextureUnit();
          gl.bindTexture(gl.TEXTURE_2D, this.gltex);
          // This parameter caused all images to be blank. Flipping in the pixel shader instead(by default)
          // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.__minFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.__magFilter);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.__wrapS);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.__wrapT);
      }
      /**
       * Initializes and creates the buffer of the object's data store.
       *
       * @param data - The data value.
       * @param width - The width value.
       * @param height - The height value.
       * @param bind - The bind value.
       * @param emit - The emit value.
       */
      // TODO: type Image doesn't exist.
      bufferData(data, width = -1, height = -1, bind = true, emit = true) {
          const gl = this.__gl;
          if (data != undefined) {
              if (data instanceof WebGLTexture) {
                  this.gltex = data;
              }
              else if (data instanceof HTMLImageElement ||
                  data instanceof ImageData ||
                  data instanceof HTMLCanvasElement ||
                  data instanceof HTMLImageElement ||
                  data instanceof HTMLVideoElement) {
                  if (bind) {
                      this.activateLastTextureUnit();
                      gl.bindTexture(gl.TEXTURE_2D, this.gltex);
                  }
                  gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, this.__format, this.__type, data);
                  this.width = data.width;
                  this.height = data.height;
              }
              else {
                  // if wieght and height not specified, assume they stay the same.
                  if (width == -1) {
                      width = this.width;
                  }
                  if (height == -1) {
                      height = this.height;
                  }
                  // Note: data images must have an even size width/height to load correctly.
                  // this doesn't mean they must be pot textures...
                  const numPixels = width * height;
                  let numChannels;
                  switch (this.__format) {
                      case gl.RED:
                      case gl.RED_INTEGER:
                      case gl.ALPHA:
                      case gl.LUMINANCE:
                      case gl.LUMINANCE_ALPHA:
                          numChannels = 1;
                          break;
                      case gl.RG:
                          numChannels = 2;
                          // Note: when uploading UNSIGNED_BYTE  RG textures, I received the following error: ArrayBuffer not big enough for request
                          // This answer on stack overflow lead me to this fix.
                          // https://stackoverflow.com/questions/42789896/webgl-error-arraybuffer-not-big-enough-for-request-in-case-of-gl-luminance
                          // The same fix maybe need to be applied to single channel textures above, although I have not seen the error.
                          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 2);
                          break;
                      case gl.RGB:
                          numChannels = 3;
                          break;
                      case gl.RGBA:
                          numChannels = 4;
                          break;
                      default:
                          console.warn('Reaching default case: numChannels:=1');
                          numChannels = 1;
                          break;
                  }
                  if (data.length != numPixels * numChannels) {
                      console.warn('Invalid data for Image width:' +
                          width +
                          ' height:' +
                          height +
                          ' format:' +
                          this.__formatParam +
                          ' type:' +
                          this.__typeParam +
                          ' Data Length:' +
                          data.length +
                          ' Expected:' +
                          numPixels * numChannels);
                  }
                  let uploadData = data;
                  if (this.__type == gl.HALF_FLOAT && data instanceof Float32Array) {
                      uploadData = MathFunctions.convertFloat32ArrayToUInt16Array(data);
                  }
                  if (bind) {
                      this.activateLastTextureUnit();
                      gl.bindTexture(gl.TEXTURE_2D, this.gltex);
                  }
                  if (gl.name == 'webgl2') {
                      gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, uploadData, 0);
                  }
                  else {
                      gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, uploadData);
                  }
                  // These values may not have changed....
                  this.width = width;
                  this.height = height;
              }
              if (this.__mipMapped) {
                  gl.generateMipmap(gl.TEXTURE_2D);
              }
          }
          else {
              if (bind) {
                  this.activateLastTextureUnit();
                  gl.bindTexture(gl.TEXTURE_2D, this.gltex);
              }
              gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, null);
              // simply resize the buffer.
              this.width = width;
              this.height = height;
          }
          if (emit) {
              this.emit('updated');
          }
      }
      /**
       * Clears the buffers to preset values
       */
      clear() {
          const gl = this.__gl;
          const numPixels = this.width * this.height;
          let numChannels;
          switch (this.__format) {
              case gl.RED:
              case gl.RED_INTEGER:
              case gl.ALPHA:
              case gl.LUMINANCE:
              case gl.LUMINANCE_ALPHA:
                  numChannels = 1;
                  break;
              case gl.RG:
                  numChannels = 2;
                  break;
              case gl.RGB:
                  numChannels = 3;
                  break;
              case gl.RGBA:
                  numChannels = 4;
                  break;
              default:
                  throw new Error('Invalid Format');
          }
          let data;
          switch (this.__type) {
              case gl.UNSIGNED_BYTE:
                  data = new Uint8Array(numPixels * numChannels);
                  break;
              case gl.HALF_FLOAT:
                  data = new Uint16Array(numPixels * numChannels);
                  break;
              case gl.FLOAT:
                  data = new Float32Array(numPixels * numChannels);
                  break;
              default:
                  throw new Error('Invalid Type');
          }
          if (gl.name == 'webgl2') {
              gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, data, 0);
          }
          else {
              gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, data);
          }
      }
      /**
       * The resize method.
       * @param width - The width value.
       * @param height - The height value.
       * @param preserveData - The preserveData value.
       * @param emit - The emit value.
       */
      resize(width, height, preserveData = false, emit = true) {
          const gl = this.__gl;
          const sizeChanged = this.width != width || this.height != height;
          if (sizeChanged) {
              const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
              if (width < 0 || width > maxSize || height < 0 || height > maxSize) {
                  throw new Error('gl-texture2d: Invalid texture size. width:' + width + ' height:' + height + ' maxSize:' + maxSize);
              }
              if (preserveData) {
                  const gltex = gl.createTexture();
                  this.activateLastTextureUnit();
                  gl.bindTexture(gl.TEXTURE_2D, gltex);
                  gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, null);
                  const fbo = gl.createFramebuffer();
                  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.gltex, 0);
                  gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, 0, 0, this.width, this.height, 0);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                  gl.deleteFramebuffer(fbo);
                  this.__gl.deleteTexture(this.gltex);
                  this.gltex = gltex;
                  this.updateGLTexParams();
              }
              else {
                  if (this.width > 0 && this.height > 0) {
                      this.__gl.deleteTexture(this.gltex);
                      this.gltex = gl.createTexture();
                      this.updateGLTexParams();
                  }
                  gl.bindTexture(gl.TEXTURE_2D, this.gltex);
                  gl.texImage2D(gl.TEXTURE_2D, 0, this.__internalFormat, width, height, 0, this.__format, this.__type, null);
              }
              this.width = width;
              this.height = height;
              if (emit) {
                  const event = new ResizedEvent(width, height);
                  this.emit('resized', event);
              }
          }
      }
      /**
       * Upload data for the image to the GPU.
       *
       * @param dataArray - The dataArray value.
       * @param width - The width value
       * @param height - The height value
       * @param offsetX - The offsetX value
       * @param offsetY - The offsetY value
       * @param bind - The bind value
       */
      populate(dataArray, width, height, offsetX = 0, offsetY = 0, bind = true) {
          const gl = this.__gl;
          if (bind) {
              this.activateLastTextureUnit();
              gl.bindTexture(gl.TEXTURE_2D, this.gltex);
          }
          gl.texSubImage2D(gl.TEXTURE_2D, 0, offsetX, offsetY, width, height, this.__format, this.__type, dataArray);
          if (bind)
              gl.bindTexture(gl.TEXTURE_2D, null);
      }
      /**
       * Returns the `width`(Index 0) and the `height`(Index 1) of the GL Texture.
       *
       * @return - The return value.
       */
      getSize() {
          return [this.width, this.height];
      }
      /**
       * Returns the value of the WebGLTexture value
       *
       * @return - The return value.
       */
      get glTex() {
          return this.gltex;
      }
      /**
       * Returns the value of the WebGLTexture value
       *
       * @return - The return value.
       */
      getTexHdl() {
          return this.gltex;
      }
      /**
       * The preBind method.
       * @param unif - The unif value.
       * @param unifs - The unifs value.
       * @return - The return value.
       */
      preBind(unif, unifs) {
          return {
              textureTypeUnif: unifs[unif.name + 'Type'],
              textureDescUnif: unifs[unif.name + 'Desc'],
          };
      }
      /**
       * Binds Texture to the ShaderUniform attribute.
       *
       * @param renderstate - The renderstate value.
       * @param unif - The unif value.
       * @param bindings - The bindings value.
       * @return - The return value.
       */
      bindToUniform(renderstate, unif, bindings) {
          if (!this.__loaded) {
              return false;
          }
          if (!this.gltex) {
              throw new Error('Unable to bind non-initialized or deleted texture.');
          }
          renderstate.bindTexture(unif, this.gltex);
          if (bindings) {
              const gl = this.__gl;
              if (bindings.textureTypeUnif) {
                  gl.uniform1i(bindings.textureTypeUnif.location, this.textureType);
              }
              if (bindings.textureDescUnif) {
                  gl.uniform4fv(bindings.textureDescUnif.location, this.textureDesc);
              }
          }
          return true;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          super.destroy();
          this.__gl.deleteTexture(this.gltex);
          this.gltex = null;
      }
      /**
       * @private
       */
      static getCachedGLTexture2D(image) {
          return gltextureCache.get(image);
      }
      /**
       * @private
       */
      static setCachedGLTexture2D(image, gltexture) {
          gltextureCache.set(image, gltexture);
      }
  }
  const gltextureCache = new Map();

  /*
    regex variables
  */
  const WHITESPACE_RE = /\s+/;
  /** Class representing a shader library.
   * @private
   */
  class ShaderLibrary {
      __shaderModules;
      materialTemplates;
      /**
       * Create a shader library.
       */
      constructor() {
          this.__shaderModules = {};
          this.materialTemplates = {};
      }
      /**
       * The setShaderModule method. Shader must be set before parsing.
       * @param shaderName - The shader name.
       * @param shader - The unparsed shader GLSL.
       */
      setShaderModule(shaderName, shader) {
          if (!(shaderName in this.__shaderModules)) {
              this.__shaderModules[shaderName] = shader;
              return;
          }
          // note: this code does not update shader snippets, whatever is first, stays.
          // important for creating tests, since shaderLibrary is global.
      }
      /**
       * The getShaderModule method. Access specific uniforms, attributes of a particular module.
       * @param shaderName - The shader name.
       * @return - The return value.
       */
      getShaderModule(shaderName) {
          return this.__shaderModules[shaderName];
      }
      /**
       * The getShaderModuleNames method.
       * @return - The return value.
       */
      getShaderModuleNames() {
          const shaderNames = [];
          // eslint-disable-next-line guard-for-in
          for (const shaderName in this.__shaderModules)
              shaderNames.push(shaderName);
          return shaderNames;
      }
      /**
       * The parseAttr
       * @param parts - parts
       * @param instanced - instanced
       * @param result - result object to store parsed data
       */
      parseAttr(parts, instanced, result, line) {
          const name = parts[2].slice(0, parts[2].length - 1);
          const type = parts[1];
          const isInteger = type == 'int' || type == 'uint' || type == 'ivec2' || type == 'ivec3' || type == 'ivec4';
          result.attributes[name] = {
              glslType: type,
              instanced: instanced,
              integer: isInteger,
          };
          // console.log('attributes:' + name + ":" + parts[1]);
          if (parts[1] == 'color') {
              parts[1] = 'vec4';
              parts.join(' ');
          }
      }
      /**
       * The handleImport method -- takes the includeFile and if it exists, adds the parsed glsl, uniforms, and attributes to the result, recursively.
       * @param result - result object that stores the glsl, attribute, uniform
       * @param shaderName - shaderName
       * @param includeFile - file name of the shader snippet/module
       * @param includes - keep track of what was included
       * @param lineNumber - keep track of what line we're on
       */
      handleImport(result, shaderName, includeFile, includes, lineNumber) {
          if (includeFile in this.__shaderModules) {
              const includedGLSL = this.__shaderModules[includeFile]; // get glsl snippet code to add
              if (!includedGLSL)
                  throw Error('snippet not loaded or does not exists!');
              // recursively includes glsl snippets
              const reursiveResult = this.parseShaderHelper(shaderName, includedGLSL, includes, lineNumber);
              // adding code + snippet glsl, if not already added.
              includes.push(includeFile); // keep track of imports
              result.glsl = result.glsl + reursiveResult.glsl;
              result.numLines += reursiveResult.numLines;
              result.uniforms = {
                  ...result.uniforms,
                  ...reursiveResult.uniforms,
              };
              result.attributes = {
                  ...result.attributes,
                  ...reursiveResult.attributes,
              };
              // console.log('\n glsl snippet: ' + reursiveResult.glsl) // print out snippets
          }
          else {
              // throw new Error(shaderName + ': SNIPPET NOT FOUND: ' + includeFile)
              console.log('shaderName: ' + shaderName);
              console.log('SNIPPET NOT FOUND: ' + includeFile);
          }
      }
      /**
       * The parseShader method.
       * @param shaderName - The shader name.
       * @param glsl - The glsl param.
       * @return - returns the 'result' object
       */
      parseShader(shaderName, glsl) {
          return this.parseShaderHelper(shaderName, glsl, [], 0);
      }
      /**
       * The parseShader recursive helper method
       * @param shaderName - The shader name.
       * @param glsl - The glsl param.
       * @param includes - keep track of what was included
       * @param lineNumber - keep track of what line we're on
       * @return - The return value.
       */
      parseShaderHelper(shaderName, glsl, includes, lineNumber) {
          // console.log('parseShader:' + shaderName)
          const addLine = (result, line) => {
              result.glsl = result.glsl + line + '\n';
              result.numLines++;
          };
          includes.push(shaderName);
          // result that is returned
          const result = {
              glsl: '',
              numLines: 0,
              uniforms: {},
              attributes: {},
          };
          // go through each line of a GLSL file
          glsl = glsl.toString(); // TODO: remove ideally, this cast is here just to make jest pass
          const lines = glsl.split('\n'); // break up code by newlines
          for (let i = 0; i < lines.length; i++) {
              let line = lines[i];
              const trimmedLine = line.trim();
              // Get first token of a statement and switch
              const parts = trimmedLine.split(WHITESPACE_RE);
              const firstToken = parts[0];
              switch (firstToken) {
                  // TODO: deprecated - remove eventually
                  case '<%include':
                  case 'import': {
                      // get the contents between quotes and then if there are '/' get the filename
                      const includeFile = trimmedLine.split(/'|"|`/)[1].split('/').pop(); // can be undefined
                      if (!includes.includes(includeFile)) {
                          this.handleImport(result, shaderName, includeFile, includes, lineNumber);
                      }
                      break;
                  }
                  case 'attribute': {
                      this.parseAttr(parts, false, result, line);
                      addLine(result, line);
                      break;
                  }
                  case 'instancedattribute': {
                      this.parseAttr(parts, true, result, line);
                      parts[0] = 'attribute';
                      line = parts.join(' ');
                      addLine(result, line);
                      break;
                  }
                  case 'uniform': {
                      // When a precision qualifier exists in the uniform definition.
                      // e.g. uniform highp int instancesTextureSize;
                      let typeIndex = 1;
                      if (parts.length == 4)
                          typeIndex = 2;
                      const typeName = parts[typeIndex];
                      const name = parts[typeIndex + 1].slice(0, parts[typeIndex + 1].length - 1);
                      if (name.includes('[')) {
                          // Strip off the square brackets.
                          result.uniforms[name.substring(0, name.indexOf('['))] = {
                              glslType: typeName,
                          };
                      }
                      else {
                          result.uniforms[name] = {
                              glslType: typeName,
                          };
                      }
                      if (typeName == 'struct') {
                          console.log(parts);
                      }
                      if (parts[1] == 'color') {
                          parts[1] = 'vec4';
                          line = parts.join(' ');
                      }
                      addLine(result, line);
                      break;
                  }
                  // TODO: structs disabled in ts-migration
                  // case 'struct': {
                  //   let membersStr = ''
                  //   if (trimmedLine.includes('}')) {
                  //     membersStr = trimmedLine.substring(trimmedLine.indexOf('{') + 1, trimmedLine.indexOf('}') - 1)
                  //   } else {
                  //     i++
                  //     while (true) {
                  //       line += lines[i] + '\n'
                  //       membersStr += line.trim()
                  //       i++
                  //       if (membersStr.includes('}')) break
                  //     }
                  //   }
                  //   const structMembers = membersStr.substring(membersStr.indexOf('{') + 1, membersStr.indexOf('}') - 1)
                  //   const members = structMembers.split(';')
                  //   const structDesc = []
                  //   for (const member of members) {
                  //     if (member.length == 0) continue
                  //     const memberparts = member.trim().split(WHITESPACE_RE)
                  //     structDesc.push({
                  //       name: memberparts[1],
                  //       type: GlslTypes[memberparts[0]],
                  //     })
                  //   }
                  //   GlslTypes[parts[1]] = structDesc
                  //   addLine(result, line)
                  //   break
                  // }
                  default: {
                      // all other statements
                      addLine(result, line);
                      break;
                  }
              } // end of switch
          } // end of forloop
          // console.log('length of shader: ' + result.numLines)
          // console.log(result.glsl)
          return result;
      }
  }
  const shaderLibrary = new ShaderLibrary();

  class RenderState {
      gl;
      renderer;
      stack = [];
      top;
      glShader;
      shaderkey;
      directives = [];
      directivesHash;
      attrs;
      unifs;
      drawItemsTexture;
      shaderInstancedGeom;
      glGeom;
      boundVao;
      xrviewport;
      passIndex;
      pass;
      vrPresenting;
      supportsInstancing;
      viewport; // Viewport
      viewports;
      bindViewports;
      bindRendererUnifs;
      boundTextures;
      boundRendertarget;
      geometryMaskTextures;
      viewXfo;
      viewScale;
      region;
      depthRange;
      cameraMatrix;
      constructor(gl) {
          this.gl = gl;
      }
      pushGLStack(name) {
          this.top;
          this.top = { name, enabled: new Set(), disabled: new Set(), functions: {} };
          // Enable me to debug the rendering stack.
          // console.log('pushGLStack:', prevTop ? prevTop.name : '', ' > ', this.top.name)
          this.stack.push(this.top);
      }
      popGLStack() {
          const prevTop = this.stack.pop();
          this.top = this.stack[this.stack.length - 1];
          // Enable me to debug the rendering stack.
          // console.log('popGLStack:', prevTop.name, ' > ', this.top ? this.top.name : '')
          // As we pop the stack we must restore the GL state to what it was.
          if (this.stack.length > 0) {
              prevTop.enabled.forEach((prop) => {
                  let i;
                  for (i = this.stack.length - 1; i >= 0; i--) {
                      const stackItem = this.stack[i];
                      if (stackItem.enabled.has(prop)) {
                          break;
                      }
                      else if (stackItem.disabled.has(prop)) {
                          this.gl.disable(prop);
                          break;
                      }
                  }
                  if (i < 0) {
                      this.gl.disable(prop);
                  }
              });
              prevTop.disabled.forEach((prop) => {
                  let i;
                  for (i = this.stack.length - 1; i >= 0; i--) {
                      const stackItem = this.stack[i];
                      if (stackItem.disabled.has(prop)) {
                          break;
                      }
                      else if (stackItem.enabled.has(prop)) {
                          this.gl.enable(prop);
                          break;
                      }
                  }
                  if (i < 0) {
                      this.gl.enable(prop);
                  }
              });
          }
          //   for (let key in prevTop.enabled) {
          //   }
          //   for (let key in prevTop.disabled) {
          //     const prop = prevTop.enabled[key]
          //     if (stackItem.enabled[key] == prop) {
          //       break
          //     } else if (stackItem.disabled[key] == prop) {
          //       this.gl.enable(prop)
          //       break
          //     }
          //   }
          // }
          /*
            for (let key in prevTop.functions) {
              const args = prevTop[key]
              for (let i = this.stack.length - 1; i >= 0; i--) {
                const stackItem = this.stack[i]
                const prevArgs = stackItem.functions[key]
                if (prevArgs) {
                  if (prevArgs != args) {
                    if (Array.isArray(prevArgs)) {
                      this.gl[key](...prevArgs)
                    } else {
                      this.gl[key](prevArgs)
                    }
                  }
                  break
                }
              }
            }*/
          // }
      }
      glEnable(prop) {
          this.gl.enable(prop);
          this.top.enabled.add(prop);
      }
      glDisable(prop) {
          this.gl.disable(prop);
          this.top.disabled.add(prop);
      }
      bindTexture(unif, gltex) {
          const unit = this.boundTextures++;
          const gl = this.gl;
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, gltex);
          gl.uniform1i(unif.location, unit);
      }
  }

  class HighlightRenderState extends RenderState {
  }

  class ColorRenderState extends RenderState {
      envMap;
      renderMode;
      outlineMethod;
      outlineThickness;
      outlineColor;
      hiddenLineColor;
      screenQuad;
      exposure; // must initialize these
      gamma;
      toHighlightRenderState() {
          const highlightRenderState = new HighlightRenderState(this.gl);
          highlightRenderState.boundRendertarget = this.boundRendertarget;
          highlightRenderState.viewXfo = this.viewXfo;
          highlightRenderState.viewScale = this.viewScale;
          highlightRenderState.region = this.region;
          highlightRenderState.cameraMatrix = this.cameraMatrix;
          highlightRenderState.viewport = this.viewport;
          highlightRenderState.vrPresenting = this.vrPresenting;
          highlightRenderState.bindViewports = this.bindViewports;
          highlightRenderState.bindRendererUnifs = this.bindRendererUnifs;
          return highlightRenderState;
      }
  }

  class GeomDataRenderState extends RenderState {
      geomDataFbo; // only used in geomdata buffer rendering
      floatGeomBuffer;
      occlusionCulling;
  }

  /* eslint-disable valid-jsdoc */
  // Every instance of every shader should have a unique id.
  // This is so that we can uniquely identify the bound shader during
  // rendering. Materials and geometries cache bindings to shaders.
  // And need the id to be unique. (Note: we used to use the constructor.name
  // which was only unique if the same shader was constructed once, and
  // never unique in release mode after the port to Rollup)
  let shaderInstanceId = 0;
  /** Class representing a GL shader.
   * @extends BaseItem
   * @private
   */
  class GLShader extends BaseItem {
      __gl;
      shaderStagesGLSL = {};
      shaderStages = {};
      shaderProgramHdls = {};
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl, name) {
          super(name);
          if (gl)
              this.__gl = gl;
          this.__id = shaderInstanceId++;
          // hack to enable Zea-UX to work untill its upgraded.
          //@ts-ignore
          this.__shaderStages = this.shaderStages;
      }
      /**
       * Sets the GL context to the shader.
       * > Note: normally the context should be passed to the constructor. This method us used when using the Registry to construct shaders.
       * @param gl - The webgl rendering context.
       */
      setGLContext(gl) {
          this.__gl = gl;
      }
      /**
       * Sets the GLSL code for a given shader stage.
       * @param stageName - The name of the stage. currently only 'VERTEX_SHADER' or 'FRAGMENT_SHADER' are supported.
       * @param glsl - The GLSL code for the shader stage.
       */
      setShaderStage(stageName, glsl) {
          this.shaderStagesGLSL[stageName] = glsl;
          this.clearProgramsCache();
      }
      /**
       * Gets the GLSL code for a given shader stage.
       * @param stageName - The name of the stage. currently only 'VERTEX_SHADER' or 'FRAGMENT_SHADER' are supported.
       * @return - The GLSL code for the shader stage.
       */
      getShaderStage(stageName) {
          return this.shaderStagesGLSL[stageName];
      }
      /**
       * Clears all cached shader compilations for this shader.
       */
      clearProgramsCache() {
          const gl = this.__gl;
          for (const shaderProgramkey in this.shaderProgramHdls) {
              const shaderCompilationResult = this.shaderProgramHdls[shaderProgramkey];
              for (const shaderKey in shaderCompilationResult.shaderHdls) {
                  gl.deleteShader(shaderCompilationResult.shaderHdls[shaderKey]);
              }
              gl.deleteProgram(shaderCompilationResult.shaderProgramHdl);
          }
      }
      /**
       * The isOpaque method.
       * @return - The return value.
       */
      static isOpaque() {
          return true;
      }
      /**
       * The isOverlay method.
       * @return - The return value.
       */
      static isOverlay() {
          return false;
      }
      // /////////////////////////////////
      // Compilation
      generateNumberedLines(lines, startOffset, endOffset, errorLines) {
          const numberedLinesWithErrors = [];
          for (const key in errorLines) {
              const lineNumber = Number.parseInt(key) - 1;
              for (let i = Math.max(0, lineNumber - startOffset); i < lineNumber; i++)
                  numberedLinesWithErrors.push((i + 1 + ' ').padStart(3) + '\x1B[34;107;2m' + lines[i] + '\x1B[m');
              numberedLinesWithErrors.push((lineNumber + 1 + '>').padStart(3) + '\x1B[41;93;4m' + lines[lineNumber] + '\x1B[m');
              for (let i = lineNumber + 1; i < Math.min(lines.length - 1, lineNumber + endOffset); i++)
                  numberedLinesWithErrors.push((i + 1 + ' ').padStart(3) + '\x1B[34;107;2m' + lines[i] + '\x1B[m');
              const errors = errorLines[key];
              for (const error of errors) {
                  numberedLinesWithErrors.push(error);
              }
          }
          return numberedLinesWithErrors;
      }
      /**
       * The compileShaderStage method.
       * @param glsl - The glsl value.
       * @param stageID - The stageID value.
       * @param name - The name value.
       * @param directives - The directives value.
       * @return - The return value.
       * @private
       */
      compileShaderStage(glsl, stageID, name, directives) {
          const gl = this.__gl;
          // console.log("compileShaderStage:" + this.name+"."+name + " glsl:\n" + glsl);
          if (directives) {
              const defines = directives.join('\n') + '\n';
              glsl = defines + glsl;
          }
          if (gl.name == 'webgl2') {
              glsl = StringFunctions.replaceAll(glsl, 'attribute', 'in');
              if (name == 'vertexShader')
                  glsl = StringFunctions.replaceAll(glsl, 'varying', 'out');
              else
                  glsl = StringFunctions.replaceAll(glsl, 'varying', 'in');
              glsl = StringFunctions.replaceAll(glsl, 'texture2D', 'texture');
              const prefix = '#version 300 es\n';
              glsl = prefix + glsl;
          }
          const shaderHdl = gl.createShader(stageID);
          if (!shaderHdl)
              throw Error('shaderHdl not defined');
          gl.shaderSource(shaderHdl, glsl);
          // Compile the shader program.
          gl.compileShader(shaderHdl);
          // See if it compiled successfully
          if (!gl.getShaderParameter(shaderHdl, gl.COMPILE_STATUS)) {
              console.log('Errors in :' + this.constructor.name + '.' + name);
              const errors = gl.getShaderInfoLog(shaderHdl).split('\n');
              const errorLines = {};
              for (let i = 0; i < errors.length; i++) {
                  const parts = errors[i].split(':');
                  if (parts.length >= 2) {
                      const lineNum = parseInt(parts[2]); // TODO check against ATI and intel cards
                      if (!isNaN(lineNum)) {
                          if (errorLines[lineNum])
                              errorLines[lineNum].push(errors[i]);
                          else
                              errorLines[lineNum] = [errors[i]];
                      }
                  }
              }
              const lines = glsl.split('\n');
              console.groupCollapsed('ShaderError-All');
              const allErrorLines = this.generateNumberedLines(lines, lines.length, lines.length, errorLines);
              allErrorLines.forEach((line) => console.info(line));
              console.groupEnd();
              console.group('ShaderError-Summary');
              const sumaryLinesWithErrors = this.generateNumberedLines(lines, 4, 5, errorLines);
              sumaryLinesWithErrors.forEach((line) => console.info(line));
              console.groupEnd();
              throw new Error('An error occurred compiling the shader \n=================\n' + this.constructor.name + '.' + name);
          }
          return shaderHdl;
      }
      /**
       * The createProgram method.
       * @param directives - The directives value.
       * @return - The program value.
       * @private
       */
      createProgram(directives) {
          const gl = this.__gl;
          const shaderProgramHdl = gl.createProgram();
          if (!shaderProgramHdl)
              throw Error('shaderProgramHdl not defined');
          const shaderHdls = {};
          {
              if (!this.shaderStages['VERTEX_SHADER']) {
                  // preprocess the GLSL, including all shader snippets
                  this.shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader('VERTEX_SHADER', this.shaderStagesGLSL['VERTEX_SHADER']);
              }
              const glsl = this.shaderStages['VERTEX_SHADER'].glsl;
              if (glsl != undefined) {
                  const vertexShader = this.compileShaderStage(glsl, gl.VERTEX_SHADER, 'vertexShader', directives);
                  if (!vertexShader) {
                      return;
                  }
                  gl.attachShader(shaderProgramHdl, vertexShader);
                  shaderHdls[gl.VERTEX_SHADER] = vertexShader;
              }
          }
          {
              if (!this.shaderStages['FRAGMENT_SHADER']) {
                  // preprocess the GLSL, including all shader snippets
                  this.shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader('FRAGMENT_SHADER', this.shaderStagesGLSL['FRAGMENT_SHADER']);
              }
              const glsl = this.shaderStages['FRAGMENT_SHADER'].glsl;
              if (glsl != undefined) {
                  const fragmentShader = this.compileShaderStage(glsl, gl.FRAGMENT_SHADER, 'fragmentShader', directives);
                  if (!fragmentShader) {
                      return;
                  }
                  gl.attachShader(shaderProgramHdl, fragmentShader);
                  shaderHdls[gl.FRAGMENT_SHADER] = fragmentShader;
              }
          }
          gl.linkProgram(shaderProgramHdl);
          if (!gl.getProgramParameter(shaderProgramHdl, gl.LINK_STATUS)) {
              const info = gl.getProgramInfoLog(shaderProgramHdl);
              if (!info)
                  throw Error('info not defined');
              if (info.includes('D3D shader compilation failed')) {
                  // Usefull for debugging very nasty compiler errors generated only in the ANGL layer.
                  const debugExt = gl.getExtension('WEBGL_debug_shaders');
                  if (debugExt) {
                      const hlsl = debugExt.getTranslatedShaderSource(shaderHdls[gl.VERTEX_SHADER]);
                      console.log(hlsl);
                  }
              }
              console.groupCollapsed('vertexShaderGLSL');
              console.log(this.shaderStages['VERTEX_SHADER'].glsl);
              console.groupEnd();
              console.groupCollapsed('fragmentShaderGLSL');
              console.log(this.shaderStages['FRAGMENT_SHADER'].glsl);
              console.groupEnd();
              throw new Error('Unable to link the shader program:' + this.constructor.name + '\n==================\n' + info);
          }
          const attributeAndUniformLocation = this.extractAttributeAndUniformLocations(shaderProgramHdl);
          return {
              shaderHdls,
              shaderProgramHdl,
              unifs: attributeAndUniformLocation.unifs,
              attrs: attributeAndUniformLocation.attrs,
          };
      }
      /**
       * The extractAttributeAndUniformLocations method.
       * @param shaderProgramHdl - The shaderProgramHdl value.
       * @param directives - GLSL shader directives
       * @return - The dictionary of attributes and uniform values
       * @private
       */
      extractAttributeAndUniformLocations(shaderProgramHdl) {
          const gl = this.__gl;
          const attrs = this.getAttributes();
          const result = {
              attrs: {},
              unifs: {},
          };
          for (const attrName in attrs) {
              const location = gl.getAttribLocation(shaderProgramHdl, attrName);
              if (location == undefined) {
                  console.warn('Shader attribute not found:' + attrName);
                  continue;
              }
              const attrDesc = attrs[attrName];
              result.attrs[attrName] = {
                  name: attrName,
                  location: location,
                  glslType: attrDesc.glslType,
                  instanced: attrDesc.instanced,
                  integer: attrDesc.integer,
              };
          }
          const unifs = this.getUniforms(); // TODO: refactor type in fn()
          for (let uniformName in unifs) {
              const unifParseResult = unifs[uniformName];
              // TODO: array uniform disabled during ts-migration
              // if (unifType instanceof Array) {
              //   for (const member of unifType) {
              //     const structMemberName = uniformName + '.' + member.name
              //     const location = gl.getUniformLocation(shaderProgramHdl, structMemberName)
              //     if (location == undefined) {
              //       // console.warn(this.constructor.name + " uniform found in shader code but not in compiled program:" + uniformName);
              //       continue
              //     }
              //     result.unifs[structMemberName] = {
              //       name: structMemberName,
              //       location: location,
              //       type: member.type,
              //     }
              //   }
              // }
              const location = gl.getUniformLocation(shaderProgramHdl, uniformName);
              if (location == undefined) {
                  // console.warn(this.constructor.name + " uniform found in shader code but not in compiled program:" + uniformName);
                  continue;
              }
              result.unifs[uniformName] = {
                  name: uniformName,
                  location: location,
                  glslType: unifParseResult.glslType,
              };
          }
          return result;
      }
      /**
       * The getAttributes method.
       * @return - The dictionary of attributes that this shader expects to be bound.
       */
      getAttributes() {
          const attributes = {};
          for (const stageName in this.shaderStages) {
              const shaderStageBlock = this.shaderStages[stageName];
              for (const attrName in shaderStageBlock['attributes'])
                  attributes[attrName] = shaderStageBlock['attributes'][attrName];
          }
          return attributes;
      }
      /**
       * The getUniforms method.
       * @return - The dictionary of uniforms that this shader expects to be bound.
       */
      getUniforms() {
          const uniforms = {};
          for (const stageName in this.shaderStages) {
              const shaderStageBlock = this.shaderStages[stageName];
              for (const unifName in shaderStageBlock['uniforms'])
                  uniforms[unifName] = shaderStageBlock['uniforms'][unifName];
          }
          return uniforms;
      }
      /**
       * Checks to see if the engine is compiled for the target specified by the key
       * @param key - The key value.
       * @return - The return value.
       */
      isCompiledForTarget(key) {
          // The provided key only needs to be unique within each shaders cachel
          const shaderkey = key + this.getId() + '';
          return this.shaderProgramHdls[shaderkey] != undefined;
      }
      /**
       * The compileForTarget method.
       * @param key - The key value.
       * @param directives - The directives value.
       * @return - The result of the shader compilation.
       */
      compileForTarget(key, directives) {
          // Each time a shader is compiled, we cache the result.
          // A drived shader should not share cache value with its base class,
          // so we add the id to the cache key.
          const shaderkey = key + this.getId() + '';
          let shaderCompilationResult = this.shaderProgramHdls[shaderkey];
          if (!shaderCompilationResult) {
              shaderCompilationResult = this.createProgram(directives || []);
              // Note: the id is always added to the key, so cache the key without the id
              // so if we check the key again, the id is simply re-added.
              // see: GLGeomItemSetMultiDrawCompoundGeom.drawGeomData
              // When the geomDataShader is re-bound, it uses a cached key.
              // > geomDataShader.bind(renderstate, geomDataShaderKey)
              if (shaderCompilationResult)
                  shaderCompilationResult.shaderkey = key;
              this.shaderProgramHdls[shaderkey] = shaderCompilationResult;
              return shaderCompilationResult;
          }
          return shaderCompilationResult;
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key value.
       * @return - The return value.
       */
      bind(renderstate, key) {
          const gl = this.__gl;
          if (renderstate.glShader != this) {
              const shaderCompilationResult = this.compileForTarget(key, renderstate.directives);
              if (!shaderCompilationResult) {
                  // TODO: compileForTarget should return null or empty
                  console.warn(this.constructor.name + ' is not compiled for ' + key);
                  return false;
              }
              const shaderProgramHdl = shaderCompilationResult.shaderProgramHdl;
              gl.useProgram(shaderProgramHdl);
              renderstate.glShader = this;
              renderstate.shaderkey = shaderCompilationResult.shaderkey;
              renderstate.unifs = shaderCompilationResult.unifs;
              renderstate.attrs = shaderCompilationResult.attrs;
              renderstate.boundTextures = 0;
              // Make sure we clear the binding cached.
              renderstate.glGeom = undefined;
              // Once the shader has been bound, we allow the renderer to bind any
              // of its global uniform values. (e.g. env map values etc...)
              if (renderstate.bindRendererUnifs)
                  renderstate.bindRendererUnifs(shaderCompilationResult.unifs);
              if (renderstate.geometryMaskTextures && renderstate.unifs.frontDepthTexture) {
                  const { frontDepthTexture, backDepthTexture, viewportSize } = renderstate.unifs;
                  renderstate.bindTexture(frontDepthTexture, renderstate.geometryMaskTextures[0]);
                  renderstate.bindTexture(backDepthTexture, renderstate.geometryMaskTextures[1]);
                  gl.uniform2f(viewportSize.location, renderstate.region[2] - renderstate.region[0], renderstate.region[3] - renderstate.region[1]);
              }
              if (renderstate instanceof GeomDataRenderState) {
                  const { floatGeomBuffer, occlusionCulling } = renderstate.unifs;
                  if (floatGeomBuffer) {
                      gl.uniform1i(floatGeomBuffer.location, renderstate.floatGeomBuffer ? 1 : 0);
                  }
                  if (occlusionCulling) {
                      gl.uniform1i(occlusionCulling.location, renderstate.occlusionCulling);
                  }
              }
          }
          // By default shaders support instancing.
          // Derived Shaders may set this to false.
          renderstate.supportsInstancing = true;
          return true;
      }
      /**
       * The unbind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      unbind(renderstate) {
          renderstate.glShader = null;
          renderstate.shaderkey = '';
          renderstate.unifs = {};
          renderstate.attrs = {};
          return true;
      }
      // /////////////////////////////
      // Parameters
      /**
       * The getGeomDataShaderName method.
       * @return - an array of param declarations that the shader expects the material tp provide.
       */
      getGeomDataShaderName() {
          return '';
      }
      /**
       * The getSelectedShaderName method.
       */
      getSelectedShaderName() {
          return '';
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return true;
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(4);
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          throw new Error('Shader does not provide a material template.');
      }
      // /////////////////////////////////
      // Destroy
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          const gl = this.__gl;
          // eslint-disable-next-line guard-for-in
          for (const key in this.shaderProgramHdls) {
              const shaderCompilationResult = this.shaderProgramHdls[key];
              gl.deleteProgram(shaderCompilationResult.shaderProgramHdl);
          }
          this.shaderProgramHdls = {};
      }
  }

  /**
   * This class abstracts the rendering of a collection of geometries to screen.
   */
  class GLFbo {
      colorTextureResizeEventId = -1;
      __gl;
      __colorTexture;
      __createDepthTexture;
      __clearColor;
      __depthTexture = null;
      __fbo = null;
      __prevBoundFbo = null;
      /**
       * Creates a GL Framebuffer Object
       *
       * @param gl - The Canvas 3D Context.
       * @param colorTexture - Represents 2D Texture in GL.
       * @param createDepthTexture - The createDepthTexture value.
       */
      constructor(gl, colorTexture, createDepthTexture = false) {
          if (SystemDesc.isIOSDevice &&
              gl.name == 'webgl' &&
              (colorTexture.getType() == gl.FLOAT || colorTexture.getType() == gl.HALF_FLOAT)) {
              // So iOS simply refuses to bind anything to a render target except a UNSIGNED_BYTE texture.
              // See the subtle error message here: "floating-point render targets not supported -- this is legal"
              // https://www.khronos.org/registry/webgl/conformance-suites/1.0.2/conformance/extensions/oes-texture-float.html
              console.error('IOS devices are unable to render to float textures.');
          }
          this.__gl = gl;
          this.__colorTexture = colorTexture;
          this.__createDepthTexture = createDepthTexture;
          this.__clearColor = new Color(0, 0, 0, 0);
          if (this.__colorTexture) {
              this.colorTextureResizeEventId = this.__colorTexture.on('resized', () => {
                  console.warn('This code path will be deprecated. Instead, resize the GLFbo and it will resize the texture.');
                  this.resize(this.__colorTexture.width, this.__colorTexture.height, false);
              });
          }
          this.setup();
      }
      /**
       * Sets FBO clear color using RGBA array structure.
       *
       * @param clearColor - The clearColor value.
       */
      setClearColor(clearColor) {
          this.__clearColor = clearColor;
      }
      /**
       * Returns the `width` of the GL Texture
       *
       * @return - The return value.
       */
      getWidth() {
          return this.__colorTexture.width;
      }
      /**
       * Returns the `height` of the GL Texture
       *
       * @return - The return value.
       */
      getHeight() {
          return this.__colorTexture.height;
      }
      /**
       * Returns the `width`(Index 0) and the `height`(Index 1) of the GL Texture.
       *
       * @return - The return value.
       */
      getSize() {
          return [this.__colorTexture.width, this.__colorTexture.height];
      }
      /**
       * Returns the ColorTexture of the Fbo
       *
       * @return - The return value.
       */
      getColorTexture() {
          return this.__colorTexture;
      }
      /**
       * Returns the value of the deptTexture property.
       *
       * @return - The return value.
       */
      getDepthTextureGL() {
          return this.__depthTexture;
      }
      /**
       * Returns the `width` of the GL Texture
       *
       * @return - width of GLTexture
       */
      get width() {
          return this.__colorTexture.width;
      }
      /**
       * Returns the `height` of the GL Texture
       *
       * @return - height of GLTexture
       */
      get height() {
          return this.__colorTexture.height;
      }
      /**
       * Returns the [width, height] of the GL Texture.
       *
       * @return - returns [width, height] of the __colorTexture
       */
      get size() {
          return [this.__colorTexture.width, this.__colorTexture.height];
      }
      /**
       * Returns the ColorTexture of the Fbo
       *
       * @returns {GLTexture2D} - returns this.__colorTexture
       */
      get colorTexture() {
          return this.__colorTexture;
      }
      /**
       * Sets ColorTexture of the Fbo.
       *
       * @param colorTexture - The colorTexture value.
       */
      setColorTexture(colorTexture) {
          const gl = this.__gl;
          this.__colorTexture = colorTexture;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
      }
      /**
       * Returns the value of the depthTexture property.
       *
       * @return
       */
      get depthTextureGL() {
          return this.__depthTexture;
      }
      /**
       * The setup method.
       */
      setup() {
          const gl = this.__gl;
          this.__fbo = gl.createFramebuffer();
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
          if (this.__colorTexture) {
              if (gl.name == 'webgl2')
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
              else
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
          }
          // Create the depth texture
          if (this.__createDepthTexture) {
              this.createDepthTexture();
          }
          checkFramebuffer(gl, this.width, this.height);
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      createDepthTexture() {
          const gl = this.__gl;
          if (gl.name != 'webgl2' && !gl.__ext_WEBGL_depth_texture) {
              // Create the depth buffer
              const depthBuffer = gl.createRenderbuffer();
              gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
              gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
          }
          else {
              gl.activeTexture(gl.TEXTURE0);
              this.__depthTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, this.__depthTexture);
              // TODO: Copy params from the color image.
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              if (gl.name == 'webgl2') {
                  // the proper texture format combination can be found here
                  // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
                  // https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/fbo_rtt_depth_texture.html
                  // gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT16, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.__depthTexture, 0);
              }
              else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.__depthTexture, 0);
              }
          }
      }
      /**
       * Triggered Automatically when the texture resizes.
       *
       * @todo: Fbos should manage the textures assigned to them.
       * E.g. resizing and preserving data.
       */
      resize(width, height, resizeTexture = true) {
          const gl = this.__gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteFramebuffer(this.__fbo);
          if (resizeTexture) {
              this.__colorTexture.resize(width, height, false, false);
          }
          this.__fbo = gl.createFramebuffer();
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
          // The color texture is destoryed and re-created when it is resized,
          // so we must re-bind it here.
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.__colorTexture.glTex, 0);
          if (this.__depthTexture) {
              gl.deleteTexture(this.__depthTexture);
              this.createDepthTexture();
          }
          checkFramebuffer(gl, this.width, this.height);
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
       * Binds the Fbo to the canvas context, meaning that all WRITE operations will affect the current Fbo.
       *
       * @param renderstate - The renderstate value.
       */
      bindForWriting(renderstate) {
          if (renderstate) {
              this.__prevBoundFbo = renderstate.boundRendertarget;
              renderstate.boundRendertarget = this.__fbo;
          }
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__fbo);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
          gl.viewport(0, 0, this.width, this.height); // Match the viewport to the texture size
      }
      /**
       * Unbinds the Fbo to the canvas context for WRITE operations.
       *
       * @param renderstate - The renderstate value.
       */
      unbindForWriting(renderstate) {
          if (renderstate)
              renderstate.boundRendertarget = this.__prevBoundFbo;
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.__prevBoundFbo);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.__prevBoundFbo);
      }
      /**
       * Binds the Fbo to the canvas context, meaning that all WRITE operations will affect the current Fbo.
       *
       * @param renderstate - The renderstate value.
       */
      bind(renderstate) {
          this.bindForWriting(renderstate);
      }
      /**
       * Unbinds the Fbo to the canvas context for WRITE operations.
       *
       * @param renderstate - The renderstate value.
       */
      unbind(renderstate) {
          if (renderstate) {
              // For write operations
              this.unbindForWriting(renderstate);
          }
          else {
              const gl = this.__gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
      }
      /**
       * Binds the Fbo to the canvas context, meaning that all READ operations will affect the current Fbo.
       *
       * @param renderstate - The renderstate value.
       */
      bindForReading(renderstate) {
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.__fbo);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.__fbo);
      }
      /**
       * Unbinds the Fbo to the canvas context for READ operations.
       *
       * @param renderstate - The renderstate value.
       */
      unbindForReading() {
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
       * Enables all color components of the rendering context of the Fbo,
       * specifying the default color values when clearing color buffers and clears the buffers to preset values.
       */
      clear() {
          const gl = this.__gl;
          gl.colorMask(true, true, true, true);
          const col = this.__clearColor.asArray();
          gl.clearColor(col[0], col[1], col[2], col[3]);
          if (this.__createDepthTexture) {
              gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          }
          else {
              gl.clear(gl.COLOR_BUFFER_BIT);
          }
      }
      /**
       * Runs [`bind`](#bind) then [`clear`](#clear) methods.
       * @param renderstate - The renderstate value.
       */
      bindAndClear(renderstate) {
          this.bind(renderstate);
          this.clear();
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          const gl = this.__gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.deleteFramebuffer(this.__fbo);
          this.__fbo = null;
          this.__colorTexture.off('resized', this.colorTextureResizeEventId);
      }
  }
  function checkFramebuffer(gl, width, height) {
      let check;
      if (gl.name == 'webgl2')
          check = gl.checkFramebufferStatus(gl.DRAW_FRAMEBUFFER);
      else
          check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (check !== gl.FRAMEBUFFER_COMPLETE) {
          gl.bindTexture(gl.TEXTURE_2D, null);
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          console.warn('Error creating Fbo width:', width, ', height:', height);
          switch (check) {
              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                  throw new Error('The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.');
              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                  throw new Error('There is no attachment.');
              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                  throw new Error('Height and width of the attachment are not the same.');
              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                  throw new Error('The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.');
              case 36061: // gl.GL_FRAMEBUFFER_UNSUPPORTED:
                  throw new Error('The framebuffer is unsupported');
              default:
                  throw new Error('Incomplete Frambuffer');
          }
      }
  }

  /** The GLRenderTarget is used to generate a WebGL Framebuffer and its associated textures.
   * It can be used to create a FrameBuffer, several color textures and an optional depth texture, all bound to the Framebuffer.
   *
   *
   * ```javascript
   *  const renderTarget = new GLRenderTarget(gl, {
   *    type: gl.FLOAT,
   *    format: gl.RGBA,
   *    minFilter: gl.NEAREST,
   *    magFilter: gl.NEAREST,
   *    width: 128,
   *    height: 64,
   *    depthType: gl.FLOAT,
   *    depthFormat: gl.DEPTH_COMPONENT,
   *    depthInternalFormat: gl.DEPTH_COMPONENT32F,
   *  })
   * ```
   */
  class GLRenderTarget extends EventEmitter {
      __gl;
      textureTargets;
      depthTexture;
      frameBuffer;
      textureDesc;
      params = {};
      type;
      format;
      internalFormat;
      minFilter;
      maxFilter;
      wrap;
      flipY = false;
      width = 0;
      height = 0;
      clearColor;
      colorMask;
      textureType;
      prevBoundFbo;
      /**
       * Create a GL render target.
       * @param gl - The webgl rendering context.
       * @param params - The params value.
       */
      constructor(gl, params) {
          super();
          this.__gl = gl;
          this.textureTargets = [];
          this.depthTexture = null;
          this.textureDesc = [0, 0, 0, 0];
          this.clearColor = new Color(0, 0, 0, 0);
          this.colorMask = [true, true, true, true];
          if (params) {
              this.configure(params);
          }
      }
      /**
       * The configure method.
       * @param params - The params param.
       */
      configure(params) {
          const gl = this.__gl;
          const p = processTextureParams(gl, params); // TODO: review
          this.textureTargets.forEach((colorTexture) => {
              gl.deleteTexture(colorTexture);
          });
          this.textureTargets = [];
          if (this.depthTexture) {
              gl.deleteTexture(this.depthTexture);
              this.depthTexture = null;
          }
          if (this.frameBuffer) {
              gl.deleteFramebuffer(this.frameBuffer);
          }
          this.params = p;
          this.type = p.type;
          this.format = p.format;
          this.internalFormat = p.internalFormat;
          this.minFilter = p.minFilter ? p.minFilter : p.filter;
          this.minFilter = p.magFilter ? p.magFilter : p.filter;
          this.wrap = p.wrap;
          this.flipY = p.flipY;
          this.width = p.width;
          this.height = p.height;
          this.textureType = 1; // Default 2d 8 bit texture image texture.
          this.textureDesc[0] = this.width;
          this.textureDesc[1] = this.height;
          // -- Initialize texture targets
          const numColorChannels = params.numColorChannels != undefined ? params.numColorChannels : p.format != undefined ? 1 : 0;
          for (let i = 0; i < numColorChannels; i++) {
              gl.activeTexture(gl.TEXTURE0 + 1);
              const colorTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, colorTexture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);
              gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, p.width, p.height, 0, this.format, this.type, null);
              this.textureTargets.push(colorTexture);
          }
          if (p.depthFormat) {
              if (gl.name == 'webgl' && !gl.__ext_WEBGL_depth_texture)
                  throw new Error('Depth textures not support on this device');
              // -- Initialize depth texture
              gl.activeTexture(gl.TEXTURE0);
              this.depthTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);
              // the proper texture format combination can be found here
              // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
              gl.texImage2D(gl.TEXTURE_2D, 0, p.depthInternalFormat, p.width, p.height, 0, p.depthFormat, p.depthType, null);
          }
          // -- Initialize frame buffer
          this.frameBuffer = gl.createFramebuffer();
          this.bindForWriting();
          if (this.textureTargets.length > 0) {
              if (this.textureTargets.length > 1) {
                  if (gl.name == 'webgl' && !gl.drawBuffers) ;
              }
              const bufferIds = [];
              for (let i = 0; i < this.textureTargets.length; i++) {
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this.textureTargets[i], 0);
                  bufferIds.push(gl.COLOR_ATTACHMENT0 + i);
              }
              if (this.textureTargets.length > 1) {
                  gl.drawBuffers(bufferIds);
              }
          }
          if (this.depthTexture) {
              gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture, 0);
          }
          this.checkFramebuffer();
      }
      /**
       * The checkFramebuffer method.
       */
      checkFramebuffer() {
          this.bindForWriting(); // TODO
          const gl = this.__gl;
          const status = gl.checkFramebufferStatus(gl.DRAW_FRAMEBUFFER);
          if (status != gl.FRAMEBUFFER_COMPLETE) {
              switch (status) {
                  case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      throw new Error('The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.');
                  case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      throw new Error('There is no attachment.');
                  case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      throw new Error('Height and width of the attachment are not the same.');
                  case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      throw new Error('The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.');
                  case 36061: // gl.GL_FRAMEBUFFER_UNSUPPORTED:
                      throw new Error('The framebuffer is unsupported');
                  default:
                      throw new Error('Incomplete Frambuffer');
              }
          }
          this.unbindForWriting();
      }
      /**
       * The bindForWriting method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param clear - The clear value.
       */
      bindForWriting(renderstate, clear = false) {
          if (renderstate) {
              this.prevBoundFbo = renderstate.boundRendertarget;
              renderstate.boundRendertarget = this.frameBuffer;
          }
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBuffer);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
          gl.viewport(0, 0, this.width, this.height); // Match the viewport to the texture size
          if (clear)
              this.clear();
      }
      /**
       * The unbindForWriting method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      unbindForWriting(renderstate) {
          if (renderstate)
              renderstate.boundRendertarget = this.prevBoundFbo;
          const gl = this.__gl;
          gl.bindFramebuffer(gl.name == 'webgl2' ? gl.DRAW_FRAMEBUFFER : gl.FRAMEBUFFER, this.prevBoundFbo);
          this.prevBoundFbo = null;
      }
      /**
       * The clear method.
       * @param clearDepth - The clearDepth value.
       */
      clear(clearDepth = true) {
          const gl = this.__gl;
          const colMask = this.colorMask;
          gl.colorMask(colMask[0], colMask[1], colMask[2], colMask[3]);
          const clearCol = this.clearColor.asArray();
          gl.clearColor(clearCol[0], clearCol[1], clearCol[2], clearCol[3]);
          let flags = 0;
          if (this.textureTargets.length > 0)
              flags |= gl.COLOR_BUFFER_BIT;
          if (this.depthTexture)
              flags |= gl.DEPTH_BUFFER_BIT;
          gl.clear(flags);
      }
      /**
       * Binds the render target in preparation for 'readPixels' calls to pull data back to main memory.
       */
      bindForReading() {
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
      }
      /**
       * The unbindForReading method.
       */
      unbindForReading() {
          const gl = this.__gl;
          if (gl.name == 'webgl2')
              gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          else
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      /**
       * The bindColorTexture method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param channelId - The channelId value.
       * @return - The return value.
       */
      bindColorTexture(renderstate, unif, channelId = 0) {
          const gl = this.__gl;
          const unit = renderstate.boundTextures++;
          gl.uniform1i(unif.location, unit);
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, this.textureTargets[channelId]);
          return true;
      }
      /**
       * The bindDepthTexture method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param unif - The WebGL uniform
       * @return - The return value.
       */
      bindDepthTexture(renderstate, unif) {
          const gl = this.__gl;
          const unit = renderstate.boundTextures++;
          gl.uniform1i(unif.location, unit);
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
          return true;
      }
      /**
       * The unbind method.
       */
      unbind(renderstate) {
          this.unbindForWriting(renderstate);
      }
      /**
       * The resize method.
       * @param width - The width value.
       * @param height - The height value.
       * @param preserveData - The preserveData value.
       */
      resize(width, height, preserveData = false) {
          const gl = this.__gl;
          const sizeChanged = this.width != width || this.height != height;
          if (sizeChanged) {
              const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
              if (width < 0 || width > maxSize || height < 0 || height > maxSize) {
                  throw new Error(`GLRenderTarget: Invalid texture size. width: ${width} height: ${height} maxSize: ${maxSize}`);
              }
              if (preserveData) {
                  this.bindForReading();
              }
              const p = this.params;
              for (let i = 0; i < this.textureTargets.length; i++) {
                  const colorTexture = gl.createTexture();
                  gl.bindTexture(gl.TEXTURE_2D, colorTexture);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);
                  gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, width, height, 0, this.format, this.type, null);
                  if (preserveData) {
                      // see: http://jsfiddle.net/greggman/rs21sr46
                      gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.internalFormat, 0, 0, Math.min(width, this.width), Math.min(height, this.height), 0);
                  }
                  gl.deleteTexture(this.textureTargets[i]);
                  this.textureTargets[i] = colorTexture;
              }
              if (p.depthFormat) {
                  if (gl.name == 'webgl' && !gl.__ext_WEBGL_depth_texture)
                      throw new Error('Depth textures not support on this device');
                  // -- Initialize depth texture
                  gl.activeTexture(gl.TEXTURE0);
                  const depthTexture = gl.createTexture();
                  gl.bindTexture(gl.TEXTURE_2D, depthTexture);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, p.wrapS);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, p.wrapT);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, p.minFilter);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, p.magFilter);
                  // the proper texture format combination can be found here
                  // https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
                  gl.texImage2D(gl.TEXTURE_2D, 0, p.depthInternalFormat, width, height, 0, p.depthFormat, p.depthType, null);
                  if (preserveData) {
                      // see: http://jsfiddle.net/greggman/rs21sr46
                      gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.internalFormat, 0, 0, Math.min(width, this.width), Math.min(height, this.height), 0);
                  }
                  gl.deleteTexture(this.depthTexture);
                  this.depthTexture = depthTexture;
              }
              if (preserveData) {
                  this.unbindForReading();
              }
              this.width = width;
              this.height = height;
              // -- Initialize frame buffer
              if (this.frameBuffer) {
                  // Note: avoid re-using the framebuffer.
                  // see here: https://gamedev.stackexchange.com/questions/91991/resizing-a-framebuffer-object-ie-its-attachments-on-screen-resize
                  gl.deleteFramebuffer(this.frameBuffer);
              }
              this.frameBuffer = gl.createFramebuffer();
              this.bindForWriting();
              if (this.textureTargets.length > 0) {
                  if (this.textureTargets.length > 1) {
                      if (gl.name == 'webgl' && !gl.drawBuffers) ;
                  }
                  const bufferIds = [];
                  for (let i = 0; i < this.textureTargets.length; i++) {
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this.textureTargets[i], 0);
                      bufferIds.push(gl.COLOR_ATTACHMENT0 + i);
                  }
                  if (this.textureTargets.length > 1) {
                      gl.drawBuffers(bufferIds);
                  }
              }
              if (this.depthTexture) {
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture, 0);
              }
              this.checkFramebuffer();
          }
      }
      /**
       * The bindToUniform method.
       * @param renderstate - The renderstate param.
       * @param unif - The WebGL uniform
       * @param bindings - The bindings param.
       * @return - The return value.
       */
      bindToUniform(renderstate, unif, bindings) {
          // if (!this.__loaded) {
          //   return false
          // }
          // if (!this.gltex) {
          //   throw new Error('Unable to bind non-initialized or deleted texture.')
          // }
          const unit = renderstate.boundTextures++;
          const texId = this.__gl.TEXTURE0 + unit;
          const gl = this.__gl;
          gl.activeTexture(texId);
          gl.bindTexture(gl.TEXTURE_2D, this.textureTargets[0]);
          gl.uniform1i(unif.location, unit);
          if (bindings) {
              if (bindings.textureTypeUnif) {
                  gl.uniform1i(bindings.textureTypeUnif.location, this.textureType);
              }
              if (bindings.textureDescUnif) {
                  this.__gl.uniform4fv(bindings.textureDescUnif.location, this.textureDesc);
              }
          }
          return true;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          const gl = this.__gl;
          this.textureTargets.forEach((colorTexture) => {
              gl.deleteTexture(colorTexture);
          });
          this.textureTargets = [];
          if (this.depthTexture) {
              gl.deleteTexture(this.depthTexture);
              this.depthTexture = null;
          }
          if (this.frameBuffer) {
              gl.deleteFramebuffer(this.frameBuffer);
          }
      }
  }

  var computeViewNormal = "#define GLSLIFY 1\n  \n#ifdef ENABLE_ES3\nvec3 computeViewNormal(vec3 viewPos) {\n  vec3 fdx = dFdx(viewPos);\n  vec3 fdy = dFdy(viewPos);\n  return normalize(cross(fdx, fdy));\n}\n#else \nvec3 computeViewNormal(vec3 viewPos) {\n  return vec3(0.0, 0.0, 0.0);\n}\n#endif\n"; // eslint-disable-line

  var calcFatLinesViewPos = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nvec3 calcFatLinesViewPos(int vertexID, mat4 modelViewMatrix, inout vec3 viewNormal, inout vec2 texCoord, inout vec3 pos) {\n\n  int seqentialIndex_0 = int(mod(segmentIndices.x, 2.));\n  int seqentialIndex_1 = int(mod(segmentIndices.y, 2.));\n  int index_0 = int(segmentIndices.x) / 2;\n  int index_1 = int(segmentIndices.y) / 2;\n\n  vec3 viewPos;\n  vec4 data_0 = fetchTexel(positionsTexture, positionsTextureSize, index_0);\n  vec4 data_1 = fetchTexel(positionsTexture, positionsTextureSize, index_1);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatPointsShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n\n  vec4 pos_0 = modelViewMatrix * vec4(data_0.xyz, 1.0);\n  vec4 pos_1 = modelViewMatrix * vec4(data_1.xyz, 1.0);\n  // Note: multiply the per-vertex line thickness with the line thickness uniform value;\n  float lineThickness_0 = LineThickness * data_0.w * viewScale;\n  float lineThickness_1 = LineThickness * data_1.w * viewScale;\n\n  if (vertexID < 2) {\n    pos = data_0.xyz;\n    viewPos = pos_0.xyz;\n  }\n  else {\n    pos = data_1.xyz;\n    viewPos = pos_1.xyz;\n  }\n  if (pos_1 != pos_0) {\n    vec3 segmentDir = normalize(pos_1.xyz - pos_0.xyz);\n    vec3 viewVector = normalize(viewPos);\n\n    if (vertexID < 2) {\n      vec3 segmentStartDir = segmentDir;\n      if (seqentialIndex_0 != 0) {\n        //if index_0 == 0, get the last index in the line as previous\n        int index_prev = (index_0 > 0) ? (index_0-1) : (positionsTextureSize-1);\n        vec4 data_prev = fetchTexel(positionsTexture, positionsTextureSize, index_prev);\n        vec4 pos_prev = modelViewMatrix * vec4(data_prev.xyz, 1.0);\n        segmentStartDir = normalize(segmentDir + normalize(pos_0.xyz - pos_prev.xyz));\n        // segmentStartDir = segmentDir;\n      }\n      // vec3 startBiTangent = normalize(cross(segmentStartDir, viewVector));\n      // viewNormal = normalize(cross(segmentStartDir, startBiTangent));\n      vec3 startBiTangent = normalize(vec3(-segmentStartDir.y, segmentStartDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos -= vec3(segmentStartDir * lineThickness_0 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 0.0;\n    }\n    else {\n      vec3 segmentEndDir = segmentDir;\n      if (seqentialIndex_1 != 0) {\n        //if index_1 == numPoints-1, get the first index in the line as next\n        int index_next = (index_1 < (positionsTextureSize-1)) ? (index_1+1) : 0;\n        vec4 data_next = fetchTexel(positionsTexture, positionsTextureSize, index_next);\n        vec4 pos_next = modelViewMatrix * vec4(data_next.xyz, 1.0);\n        segmentEndDir = normalize(segmentDir + normalize(pos_next.xyz - pos_1.xyz));\n        // segmentEndDir = segmentDir;\n      }\n      // vec3 endBiTangent = normalize(cross(segmentEndDir, viewVector));\n      // viewNormal = normalize(cross(segmentEndDir, endBiTangent));\n      vec3 endBiTangent = normalize(vec3(-segmentEndDir.y, segmentEndDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos += vec3(segmentEndDir * lineThickness_1 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 1.0;\n    }\n\n    // Move the line towards the viewer by the line thickness.\n    // this is to avoid depth issues when lines are rendered over meshes. \n    viewPos.z += (lineThickness_0 + lineThickness_1) * 0.5;\n  }\n\n  return viewPos;\n}\n\n"; // eslint-disable-line

  var constants = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define TwoPI (2.0 * PI)\n#define HalfPI (0.5 * PI)\n\n"; // eslint-disable-line

  var convolveHelpers = "#define GLSLIFY 1\n\n#ifdef ENVMAP_CUBE\n\nuniform samplerCube envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(envMap, dir);\n}\n\n#else \n\nuniform sampler2D   envMap;\n\nimport 'envmap-octahedral.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(dir);\n  vec4 texel = texture2D(envMap, vec2(uv.x, 1.0 - uv.y));\n  return vec4(texel.rgb/texel.a, 1.0); // TODO: Check this line. Do we need it?\n}\n\n#endif \n\nvec3 cubeFaceUvToDir(float u, float v, int faceId) {\n\n  // normalize into [-1, 1] range\n  float n_u = 2.0 * u - 1.0;\n  float n_v = 2.0 * v - 1.0;\n\n  vec3 dir;\n  switch (faceId)\n  {\n  case 0: //TEXTURE_CUBE_MAP_POSITIVE_X:\n    dir.x = 1.0f;\n    dir.y = n_v;\n    dir.z = -n_u;\n    break;\n  case 1: //TEXTURE_CUBE_MAP_NEGATIVE_X:\n    dir.x = -1.0f;\n    dir.y = n_v;\n    dir.z = n_u;\n    break;\n  case 3: //TEXTURE_CUBE_MAP_POSITIVE_Y:\n    dir.x = n_u;\n    dir.y = 1.0f;\n    dir.z = -n_v;\n    break;\n  case 2: //TEXTURE_CUBE_MAP_NEGATIVE_Y:\n    dir.x = n_u;\n    dir.y = -1.0f;\n    dir.z = n_v;\n    break;\n  case 4: //TEXTURE_CUBE_MAP_POSITIVE_Z:\n    dir.x = n_u;\n    dir.y = n_v;\n    dir.z = 1.0f;\n    break;\n  case 5: //TEXTURE_CUBE_MAP_NEGATIVE_Z:\n    dir.x = -n_u;\n    dir.y = n_v;\n    dir.z = -1.0f;\n    break;\n  }\n  return normalize(dir);\n}\n\n"; // eslint-disable-line

  var cutaways = "#define GLSLIFY 1\nuniform color cutColor;\n\n#ifdef ENABLE_FLOAT_TEXTURES\n  vec4 getCutaway(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n  }\n\n#else\n\n  uniform vec4 cutawayData;\n\n  vec4 getCutaway(int id) {\n    return cutawayData;\n  }\n\n#endif\n\n#define RAY_EPS 0.0000001\nstruct Ray {\n  vec3 start;\n  vec3 dir;\n};\n\nfloat intersectRayPlane(Ray ray, Ray plane) {\n  vec3 w = ray.start - plane.start;\n  float D = dot(plane.dir, ray.dir);\n  float N = dot(-plane.dir, w);\n\n  if (abs(D) < RAY_EPS) {\n    // segment is parallel to plane\n    if (N == 0.0)\n      return -1.0; // segment lies in plane\n    else\n      return -1.0; // no intersection\n  }\n  // they are not parallel\n  // compute intersect param\n  float sI = N / D;\n  if (sI < -RAY_EPS) {\n    return -1.0; // no intersection\n  }\n  return sI;\n}\n\nbool cutaway(vec3 worldPos, vec3 planeNormal, float planeDist) {\n\n  vec3 planePos = planeNormal * planeDist;\n  vec3 planeDir = worldPos + planePos;\n  float planeOffset = dot(planeDir, planeNormal);\n  if (planeOffset > 0.0) {\n    return true;\n  }\n  return false;\n}\n"; // eslint-disable-line

  var debugColors = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\nvec3 getDebugColor(float id) {\n  int sel = int(round(mod(round(id), 16.0)));\n  \n  if (sel==0)\n    return vec3(0.0, 1.0, 1.0);\n  else if (sel==1)\n    return vec3(0.0, 1.0, 0.0);\n  else if (sel==2)\n    return vec3(1.0, 0.0, 1.0);\n  else if (sel==3)\n    return vec3(0.75, 0.75, 0.0);\n  else if (sel==4)\n    return vec3(0.0, 0.75, 0.75);\n  else if (sel==5)\n    return vec3(0.75, 0.0, 0.75);\n  else if (sel==6)\n    return vec3(0.45, 0.95, 0.0);\n  else if (sel==7)\n    return vec3(0.0, 0.45, 0.95);\n  else if (sel==8)\n    return vec3(0.95, 0.0, 0.45);\n  else if (sel==9)\n    return vec3(0.95, 0.45, 0.0);\n  else if (sel==10)\n    return vec3(0.0, 0.95, 0.45);\n  else if (sel==11)\n    return vec3(0.45, 0.0, 0.95);\n  else if (sel==12)\n    return vec3(0.45, 0.45, 0.95);\n  else if (sel==13)\n    return vec3(0.0, 0.0, 0.45);\n  else if (sel==14)\n    return vec3(0.0, 0.45, 0.45);\n  else if (sel==15)\n    return vec3(0.45, 0.0, 0.45);\n  else return vec3(0.2, 0.2, 0.2);\n}\n\n"; // eslint-disable-line

  var geomItemId = "#define GLSLIFY 1\n\n#ifdef ENABLE_MULTI_DRAW\n\n// On some mobile GPUs the sampler2D defaults to lowp, which implies a maximum\n// resolution of 255. This caused rendering artifacts on larger scenes on mobile\n// devices.\nuniform highp sampler2D drawIdsTexture;\n\n#ifdef EMULATE_MULTI_DRAW\nuniform int drawId;\n#endif // EMULATE_MULTI_DRAW\n\nint getGeomItemId() {\n#ifndef EMULATE_MULTI_DRAW\n  int drawId = gl_DrawID;\n#endif // EMULATE_MULTI_DRAW\n\n  ivec2 texSize = textureSize(drawIdsTexture, 0);\n  ivec2 texelCoords = ivec2(drawId % texSize.x, drawId / texSize.x);\n  return int(texelFetch(drawIdsTexture, texelCoords, 0).r + 0.5);\n}\n\nvec4 getDrawItemIds() {\n#ifndef EMULATE_MULTI_DRAW\n  int drawId = gl_DrawID;\n#endif // EMULATE_MULTI_DRAW\n\n  ivec2 texSize = textureSize(drawIdsTexture, 0);\n  ivec2 texelCoords = ivec2(drawId % texSize.x, drawId / texSize.x);\n  vec4 color = texelFetch(drawIdsTexture, texelCoords, 0);\n  // Note: A 0 value in the texture means no sub-geom index is being rendered.\n  // subtract off 1 to get the true sub-geom index.\n  return vec4(color.r, color.g - 1.0, color.b, color.a);\n}\n\n#else // ENABLE_MULTI_DRAW\n\nuniform int geomItemId;\n\nattribute float instancedIds;    // instanced attribute..\nuniform int instancedDraw;\n\nint getGeomItemId() {\n  if (instancedDraw == 0) {\n    return geomItemId;\n  }\n  else {\n    return int(instancedIds);\n  }\n}\n\nvec4 getDrawItemIds() {\n  if (instancedDraw == 0) {\n    return vec4(float(geomItemId), 0.0, -1.0, -1.0);\n  }\n  else {\n    return vec4(float(instancedIds), 0.0, -1.0, -1.0);\n  }\n}\n\n#endif // ENABLE_MULTI_DRAW\n\n// For backwards compatibility with older plugins (UX.HandleShader)\nint getDrawItemId() {\n  return getGeomItemId();\n}\n"; // eslint-disable-line

  var geomItemFlags = "#define GLSLIFY 1\nconst int GEOMITEM_FLAG_CUTAWAY = 2; // 1<<1;\nconst int GEOMITEM_INVISIBLE_IN_GEOMDATA = 4; // 1<<2;\nconst int GEOMITEM_TRANSPARENT = 8; // 1<<3;\nconst int GEOMITEM_PLACEHOLDER = 16; // 1<<4;\nconst int GEOMITEM_MASK = 32; // 1<<5;\n"; // eslint-disable-line

  var geomType = "#define GLSLIFY 1\n\nconst int TRIANGLES = 0;\nconst int LINES = 1;\nconst int POINTS = 2;"; // eslint-disable-line

  var geometryMask = "#define GLSLIFY 1\nuniform sampler2D frontDepthTexture;\nuniform sampler2D backDepthTexture;\n\nuniform vec2 depthRange;\nuniform vec2 viewportSize;\n\nbool testGeometryMask(vec3 viewPos) {\n  float depth = gl_FragCoord.z;\n  vec2 texCoord = gl_FragCoord.xy / viewportSize;\n  float front = texture2D(frontDepthTexture, texCoord).r;\n  float back = texture2D(backDepthTexture, texCoord).r;\n\n  return depth < front || depth > back;\n}\n"; // eslint-disable-line

  var drawItemTexture = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\n// The texture populated by the GLGeomItemLibrary\nuniform sampler2D instancesTexture;\nuniform highp int instancesTextureSize;\n\n// See also: src\\Renderer\\GLSLConstants.js\nconst int pixelsPerItem = 8;\n\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 0);\n}\n\n"; // eslint-disable-line

  var envmapDualfisheye = "#define GLSLIFY 1\n\nvec2 dualfisheyeUVsFromDir(vec3 dir) {\n  vec2 result;\n  float angle = 0.465;\n  if (dir.x < 0.0) {\n    result = vec2(((dir.z * -angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  else {\n    result = vec2( 0.5 + ((dir.z * angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  return result;\n}\n\n"; // eslint-disable-line

  var envmapEquirect = "#define GLSLIFY 1 \nimport 'constants.glsl'\n\nvec2 latLongUVsFromDir(vec3 dir) {\n  // Math function taken from...\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]\n  float phi = acos(dir.z);\n  float theta = atan(dir.x, dir.y);\n  return vec2((1.0 + theta / PI) / 2.0, phi / PI);\n}\n\n// Note: when u == 0.5 z = 1.0\nvec3 dirFromLatLongUVs(float u, float v) {\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  float theta = PI*((u * 2.0) - 1.0);\n  float phi = PI*v;\n  return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec3 dirFromPolar(vec2 polar) {\n  float u = polar.x / (PI * 2.0);\n  float v = polar.y / PI;\n  return dirFromLatLongUVs(u, v);\n}\n\n"; // eslint-disable-line

  var envmapOctahedral = "#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'GLSLUtils.glsl'\n#define sectorize(value) step(0.0, (value))*2.0-1.0\n#define sum(value) dot(clamp((value), 1.0, 1.0), (value))\n\nvec2 dirToSphOctUv(vec3 normal) {\n  normal = normalize(normal);\n  vec3 aNorm = abs(normal);\n  vec3 sNorm = sectorize(normal);\n  \n  vec2 dir = aNorm.xy;\n  float orient = atan(dir.x, max(dir.y,0.0000000000000001))/HalfPI;\n\n  dir = vec2(aNorm.z, length(aNorm.xy));\n  float pitch = atan(dir.y, dir.x)/HalfPI;\n\n  vec2 uv = vec2(sNorm.x*orient, sNorm.y*(1.0-orient))*pitch;\n\n  if (normal.z < 0.0) {\n    uv = sNorm.xy - abs(uv.ts)*sNorm.xy;\n  }\n  vec2 res = uv*0.5+0.5;\n  // Flip-v\n  // return res;\n  return vec2(res.x, 1.0 - res.y);\n}\n\nvec3 sphOctUvToDir(vec2 uv) {\n  uv = uv*2.0-1.0;\n  // Flip-v\n  uv.y = -uv.y;\n  vec2 suv = sectorize(uv);\n  float sabsuv = sum(abs(uv));\n  float pitch = sabsuv*HalfPI;\n\n  if (pitch <= 0.0) {\n    return vec3(0.0, 0.0, 1.0);\n  }\n  if (abs(pitch - PI) < 0.000001) {\n    return vec3(0.0, 0.0, -1.0);\n  }\n  if (sabsuv > 1.0) {\n    uv = (1.0-abs(uv.ts))*suv;\n  }\n\n  float orient = (abs(uv.s)/sabsuv)*HalfPI;\n  float sOrient = sin(orient);\n  float cOrient = cos(orient);\n  float sPitch = sin(pitch);\n  float cPitch = cos(pitch);\n\n  return vec3(\n    sOrient*suv.s*sPitch,\n    cOrient*suv.t*sPitch,\n    cPitch\n  );\n}\n\n"; // eslint-disable-line

  var GLSLBits = "#define GLSLIFY 1\n    \n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n  vec4 enc = bitEnc * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n  return enc;\n}\nfloat DecodeFloatRGBA (vec4 v) {\n  return dot(v, bitDec);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://gist.github.com/Flexi23/1713774\n// \nvec2 encode16BitFloatInto2xUInt8(float v) {\n  vec2 c = vec2(0.);\n\n  int signum = (v >= 0.) ? 128 : 0;\n  v = abs(v);\n  int exponent = 15;\n  float limit = 1024.; // considering the bias from 2^-5 to 2^10 (==1024)\n  for(int exp = 15; exp > 0; exp--) {\n    if ( v < limit) {\n      limit /= 2.;\n      exponent--;\n    }\n  }\n\n  float rest;\n  if (exponent == 0) {\n    rest = v / limit / 2.;      // \"subnormalize\" implicite preceding 0. \n  } \n  else {\n    rest = (v - limit)/limit;   // normalize accordingly to implicite preceding 1.\n  }\n\n  int mantissa = int(rest * 2048.);   // 2048 = 2^11 for the (split) 11 bit mantissa\n  int msb = mantissa / 256;           // the most significant 3 bits go into the lower part of the first byte\n  int lsb = mantissa - msb * 256;     // there go the other 8 bit of the lower significance\n\n  c.x = float(signum + exponent * 8 + msb) / 255.;    // color normalization for texture2D\n  c.y = float(lsb) / 255.;\n\n  if (v >= 2048.) {\n    c.y = 1.;\n  }\n\n  return c;\n}\n\nfloat decode16BitFloatFrom2xUInt8(vec2 c) {\n  float v = 0.;\n\n  int ix = int(c.x*255.); // 1st byte: 1 bit signum, 4 bits exponent, 3 bits mantissa (MSB)\n  int iy = int(c.y*255.); // 2nd byte: 8 bit mantissa (LSB)\n\n  int s = (c.x >= 0.5) ? 1 : -1;\n  ix = (s > 0) ? ix - 128 : ix;   // remove the signum bit from exponent\n  int iexp = ix / 8;              // cut off the last 3 bits of the mantissa to select the 4 exponent bits\n  int msb = ix - iexp * 8;        // subtract the exponent bits to select the 3 most significant bits of the mantissa\n\n  int norm = (iexp == 0) ? 0 : 2048;          // distinguish between normalized and subnormalized numbers\n  int mantissa = norm + msb * 256 + iy;       // implicite preceding 1 or 0 added here\n  norm = (iexp == 0) ? 1 : 0;                 // normalization toggle\n  float exponent = pow( 2., float(iexp + norm) - 16.); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa \n  v = float( s * mantissa ) * exponent;\n\n  return v;\n}\n\n// TODO : Encoding Float32 to 4x UInt8\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// http://ultraist.hatenablog.com/entry/20110608/1307539319\n\n"; // eslint-disable-line

  var GLSLUtils = "#define GLSLIFY 1\n\nint ftoi(float val) {\n  return int(floor(val + 0.5));\n}\nivec2 ftoi(vec2 v2) {\n  return ivec2(ftoi(v2.x), ftoi(v2.y));\n}\nivec3 ftoi(vec3 v4) {\n  return ivec3(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z));\n}\nivec4 ftoi(vec4 v4) {\n  return ivec4(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z), ftoi(v4.w));\n}\n\n#ifdef ENABLE_ES3\n\nint imod(int x, int y) {\n  return x % y;\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags |= flag;\n}\n\nvoid clearFlag(inout int flags, int flag) {\n  flags &= ~flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return (flags & flag) != 0;\n}\n\n// private function: Mangle me...\nivec2 _pixelIndexToUV(int index, int textureWidth) {\n  return ivec2(index % textureWidth, index / textureWidth);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureWidth, int index) {\n  return texelFetch(texture, _pixelIndexToUV(index, textureWidth), 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  return texelFetch(texture, texCoord, 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, int index) {\n    return texelFetch(texture, _pixelIndexToUV(index, textureSize.x), 0);\n}\n\n#else\n\n// TODO: integrate: https://gist.github.com/mattatz/70b96f8c57d4ba1ad2cd\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nfloat round(float val) {\n  return floor(val + 0.4);\n}\n\nint imod(int x, int y) {\n  return x-y*(x/y);\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags += flag;\n}\nvoid clearFlag(inout int flags, int flag) {\n  flags -= flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return imod(flags / flag, 2) != 0;\n}\n\n// private function: Mangle me...\nvec2 _pixelIndexToUV(int index, int textureSize) {\n  float flTexSize = float(textureSize);\n  float x = (float(imod(index, textureSize))+0.5)/flTexSize;\n  float y = (floor(float(index / textureSize))+0.5)/flTexSize;\n  return vec2(x, y);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureSize, int index) {\n  vec2 texCoord = _pixelIndexToUV(index, textureSize);\n  return texture2D(texture, texCoord);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  vec2 ftextureSize = vec2(textureSize);\n  return texture2D(texture, (vec2(texCoord) + 0.5) / ftextureSize);\n}\n\n#endif // ENABLE_ES3\n\nint uvToPixelIndex(vec2 uv, int textureSize) {\n  return int(uv.x * float(textureSize)) + (int(floor(uv.y * float(textureSize))) * textureSize);\n}\n\n"; // eslint-disable-line

  var Hammersley = "#define GLSLIFY 1\nfloat RadicalInverse_VdC(uint bits) \n{\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n  return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n} \n"; // eslint-disable-line

  var ImportanceSampleGGX = "#define GLSLIFY 1\nimport 'constants.glsl'\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n  // from spherical coordinates to cartesian coordinates\n  vec3 H = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n  // from tangent-space vector to world-space sample vector\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n} \n"; // eslint-disable-line

  var materialparams = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\n\n \nuniform sampler2D materialsTexture;\nuniform highp ivec2 materialsTextureSize;\n\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\n  int index = ftoi(materialCoords.x) + valueIndex;\n  ivec2 texelCoords = ivec2(imod(index, materialsTextureSize.x), index / materialsTextureSize.x);\n  \n  return fetchTexel(materialsTexture, materialsTextureSize, texelCoords);\n}\n\n////////////////////////\n// Material Param Helpers.\n\nvoid getTextureColorValue(inout vec4 value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType == 1 || texType == 2) {\n    // Note: we assume textures are always in gamma space, and must be converted\n    // to linear. I cann't find evidence that 8-bit textures can be in linear space.\n    // TODO: Use SRGB textures.\n    value = toLinear(texture2D(tex, texCoord));\n  }\n  else if (texType == 3) {\n    // Float HDR Texture. We assume these textures are in linear space.\n    value = texture2D(tex, texCoord);\n  }\n}\n\nvec4 getColorParamValue(in vec4 value, sampler2D tex, int texType, vec2 texCoord) {\n  // for backwards compatiblity with zea-ux shader\n  vec4 tmp = value;\n  getTextureColorValue(tmp, tex, texType, texCoord);\n  return tmp;\n}\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nvoid getTextureLuminanceValue(inout float value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType != 0)\n    value = luminanceFromRGB(texture2D(tex, texCoord).rgb);\n}\n\nfloat getLuminanceParamValue(in float value, sampler2D tex, int texType, vec2 texCoord) {\n  // for backwards compatiblity with zea-ux shader\n  float tmp = value;\n  getTextureLuminanceValue(tmp, tex, texType, texCoord);\n  // for backwards compatiblity with zea-ux shader\n  return tmp;\n}\n\n"; // eslint-disable-line

  var modelMatrix = "#define GLSLIFY 1\n#ifdef ENABLE_FLOAT_TEXTURES\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matrix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 1);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 2);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 3);\n  mat4 result = transpose(mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0)));\n  return result;\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\n\n#else\n\nuniform mat4 modelMatrix;\n\nmat4 getModelMatrix(int id) {\n  return modelMatrix;\n}\n\n#endif\n\n"; // eslint-disable-line

  var PBRSurfaceRadiance = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nconst int ENVMAP_FLAG_HEADLIGHT =  1; // 1<<0;\n\nstruct MaterialParams {\n  vec3 baseColor;\n  float ambientOcclusion;\n  float metallic;\n  float roughness;\n  float reflectance;\n  float opacity;\n  float emission;\n};\n\n#ifndef ENABLE_PBR\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  vec3 irradiance = vec3(dot(normal, viewVector));\n  float ao = material.ambientOcclusion; \n  return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n\n  // return vec4(material.baseColor * ao * irradiance , material.opacity);\n}\n\n#else\n\nuniform int envMapFlags;\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D brdfLUT;\n\nvec3 sampleIrradiance(vec3 dir) {\n  return texture(irradianceMap, dir).rgb;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat luminance(vec3 color) {\n  return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  if (envMapFlags == -1) {\n    vec3 irradiance = vec3(dot(normal, viewVector));\n    float ao = material.ambientOcclusion; \n    return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n  }\n\n  vec3 N = normal;\n  vec3 V = viewVector;\n  vec3 R = reflect(-V, N);\n  float roughness = material.roughness * material.roughness;\n  vec3 diffuseColor = (1.0 - material.metallic) * material.baseColor;\n\n  // Note: The specular reflectance of metallic surfaces is chromatic\n  // https://google.github.io/filament/Filament.html#listing_fnormal\n  vec3 F0 = 0.16 * material.reflectance * material.reflectance * (1.0 - material.metallic) + material.baseColor * material.metallic;\n\n  float NdotV = dot(N, V);\n\n  vec3 F = fresnelSchlickRoughness(max(NdotV, 0.0), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - material.metallic;\n  float ao = material.ambientOcclusion; \n  \n  vec3 irradiance;\n  vec3 irradianceSampleDir = normal;\n  \n  bool headLightMode = testFlag(envMapFlags, ENVMAP_FLAG_HEADLIGHT);\n  if (headLightMode) {\n    irradianceSampleDir = viewVector;\n  }\n  irradiance = sampleIrradiance(irradianceSampleDir);\n  // vec3 irradiance = shGetIrradianceAt(shCoefficients, N);\n  vec3 diffuse    = irradiance * diffuseColor;\n  \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   \n  vec2 envBRDF  = texture(brdfLUT, vec2(max(NdotV, 0.0), roughness)).rg;\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  \n  vec3 radiance = (kD * diffuse + specular) * ao;\n  \n  // Now handle semi-transparent objects. We need to be able to linearly interpolate\n  // opacity to make objects disappear, so we need a continuous change.\n  float opacity = material.opacity;\n  vec4 transparent = vec4((radiance * opacity) + specular, opacity + luminance(specular) + luminance(F));\n  vec4 result = mix(transparent, vec4(radiance, 1.0), opacity);\n\n  // Add emission on as the final component.\n  // Note: emission allows a material to blend off its specular component, \n  // which can also be used to make an object completely disappear if also transparent.\n  return mix(result, vec4(material.baseColor, opacity), material.emission);\n}\n\n#endif // ENABLE_PBR\n"; // eslint-disable-line

  var SHCoeffs = "#define GLSLIFY 1\nuniform vec3 shCoeffs[9];\n\nvec3 sampleSHCoeffs(vec3 dir) {\n  // dir is assumed to have unit length\n  float x = dir.x, y = dir.y, z = dir.z;\n  // band 0\n  vec3 result = shCoeffs[ 0 ] * 0.886227;\n  // band 1\n  result += shCoeffs[ 1 ] * 2.0 * 0.511664 * y;\n  result += shCoeffs[ 2 ] * 2.0 * 0.511664 * z;\n  result += shCoeffs[ 3 ] * 2.0 * 0.511664 * x;\n  // band 2\n  result += shCoeffs[ 4 ] * 2.0 * 0.429043 * x * y;\n  result += shCoeffs[ 5 ] * 2.0 * 0.429043 * y * z;\n  result += shCoeffs[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n  result += shCoeffs[ 7 ] * 2.0 * 0.429043 * x * z;\n  result += shCoeffs[ 8 ] * 0.429043 * ( x * x - y * y );\n  return result;\n}\n"; // eslint-disable-line

  var gamma = "#define GLSLIFY 1\nconst float gamma_const = 2.2;\n\nfloat toLinear(float v) {\n  return pow(v, gamma_const);\n}\n\nvec2 toLinear(vec2 v) {\n  return pow(v, vec2(gamma_const));\n}\n\nvec3 toLinear(vec3 v) {\n  return pow(v, vec3(gamma_const));\n}\n\nvec4 toLinear(vec4 v) {\n  return vec4(toLinear(v.rgb), v.a);\n}\n\nfloat toGamma(float v) {\n  return pow(v, 1.0 / gamma_const);\n}\n\nvec2 toGamma(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_const));\n}\n\nvec3 toGamma(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_const));\n}\n\nvec4 toGamma(vec4 v) {\n  return vec4(toGamma(v.rgb), v.a);\n}\n\nfloat toGamma(float v, float gamma) {\n  return pow(v, 1.0 / gamma);\n}\n\nvec2 toGamma(vec2 v, float gamma) {\n  return pow(v, vec2(1.0 / gamma));\n}\n\nvec3 toGamma(vec3 v, float gamma) {\n  return pow(v, vec3(1.0 / gamma));\n}\n\nvec4 toGamma(vec4 v, float gamma) {\n  return vec4(toGamma(v.rgb, gamma), v.a);\n}\n\n"; // eslint-disable-line

  var inverse = "#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n#endif\n\n"; // eslint-disable-line

  var transpose = "#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n#endif\n\n"; // eslint-disable-line

  var quadVertexFromID = "#define GLSLIFY 1\nattribute float vertexIDs;\n\nvec2 getQuadVertexPositionFromID() {\n  int vertexID = int(vertexIDs);\n  if (vertexID == 0)\n    return vec2(-0.5, -0.5);\n  else if (vertexID == 1)\n    return vec2(0.5, -0.5);\n  else if (vertexID == 2)\n    return vec2(-0.5, 0.5);\n  else if (vertexID == 3)\n    return vec2(0.5, 0.5);\n  return vec2(0,0);\n}\n"; // eslint-disable-line

  var unpackHDR = "#define GLSLIFY 1\n\nvec3 decodeHDR(const in vec3 ldrPixel, const in float cdmAlpha) {\n  float avg = (cdmAlpha * 16.0 - 8.0);\n  float scl = 1.0;\n  vec3 color;\n  color.x = (tan((ldrPixel.x-0.5)*1.5)/scl)+avg;\n  color.y = (tan((ldrPixel.y-0.5)*1.5)/scl)+avg;\n  color.z = (tan((ldrPixel.z-0.5)*1.5)/scl)+avg;\n\n  // convert from logarithmic curve to linear curve.\n  // subtract the epsilon that was added during encoding.\n  const float eps = 0.001;\n  color.x = pow(10.0, color.x) - eps;\n  color.y = pow(10.0, color.y) - eps;\n  color.z = pow(10.0, color.z) - eps;\n  return color;\n}\n\nvec3 decodeHDR(sampler2D ldrSampler, sampler2D cdmSampler, vec2 texCoord) {\n#ifdef ENABLE_ES3\n  float cdm = texture2D(cdmSampler, texCoord).r;\n#else\n  float cdm = texture2D(cdmSampler, texCoord).a;\n#endif\n  return decodeHDR(texture2D(ldrSampler, texCoord).rgb, cdm);\n}\n\n"; // eslint-disable-line

  var surfaceGeomData = "#define GLSLIFY 1\n\n  uniform int floatGeomBuffer; // Remove once we update UX. \n  uniform int passId;\n  uniform int occlusionCulling;\n\n  import 'geomItemFlags.glsl'\n  import 'GLSLBits.glsl'\n  \n  vec4 setFragColor_geomData(vec3 v_viewPos, float geomItemId, float elemItemId, int isOrthographic, int flags){\n    vec4 fragColor;\n\n    float viewDist;\n    if (isOrthographic > 0) {\n      viewDist = abs(v_viewPos.z);\n    } else {\n      viewDist = length(v_viewPos);\n    }\n    \n    fragColor.r = float(passId); \n    fragColor.g = float(geomItemId);\n    fragColor.b = elemItemId;\n    fragColor.a = viewDist;\n  \n\n#ifdef ENABLE_ES3\n    if (occlusionCulling != 0) {\n      // Calculate a simple stochastic transparency to reduce the cost of the reduction shader.\n      // We only need one pixel to be visible to consider the geometry visible, so here we \n      // keep only one in 7x7 (49) pixels. This signficatly reduces the cost of reducing the scene\n      // to the reduction data buffer.\n      // Note: this is not a stochastic transparency, as we are simply setting black pixels to \n      // reduce the number of reduction points for this geometry. The black pixels (not discarded)\n      // still occlude other geometries, but during reduction count to nothing.\n      int x = int(gl_FragCoord.x * 1000.0);\n      int y = int(gl_FragCoord.y * 1000.0);\n      if (x % 7 != 0 || y % 7 != 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      };\n    }\n#endif // ENABLE_ES3\n\n    return fragColor;\n  }\n\n  vec4 setFragColor_geomData(vec3 v_viewPos, int floatGeomBuffer, int passId, float geomItemId, int isOrthographic){\n    return setFragColor_geomData(v_viewPos, geomItemId, 0.0, isOrthographic, 0);\n  }\n  vec4 setFragColor_geomData(vec3 v_viewPos, int floatGeomBuffer, int passId, float geomItemId, float elemItemId, int isOrthographic){\n    return setFragColor_geomData(v_viewPos, geomItemId, elemItemId, isOrthographic, 0);\n  }"; // eslint-disable-line

  var surfaceHighlight = "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\n\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n\nvec4 setFragColor_highlight(float v_geomItemId){\n  vec4 fragColor; \n  int geomItemId = int(v_geomItemId + 0.5);\n  fragColor = getHighlightColor(geomItemId);\n  return fragColor;\n}\n"; // eslint-disable-line

  var imageAtlas = "#define GLSLIFY 1\n// Note: On mobile, I can't seem to pass around a stuct containing sampler2D.\n// I have to unpack the struct and pass its members. :(\n// struct ImageAtlas {\n//     sampler2D layout;\n//     sampler2D image;\n//     vec4 desc;\n// };\n\nimport 'GLSLUtils.glsl'\n\nvec4 getSubImageLayout(int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    return fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n}\nvec2 calcSubImageTexCoords(vec2 texCoord, int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    // The following line is a hack to fix artifacts in our PBR lighting\n    // We were seeing loads of lighting garbage on some sufaces that were orthogonal\n    // to the world. The UV coordinates would have been landing right on the edges\n    // of our subimages and were often sampling outside the image. This couuld\n    // have been because of filtering, or an error in the uv coords. \n    texCoord = clamp(texCoord, vec2(0.01, 0.01), vec2(0.99, 0.99));\n    vec2 subimageTexel = texCoord * layoutData.zw;\n    // subimageTexel = clamp(subimageTexel, vec2(0.0, 0.0), vec2(1.0, 1.0));\n    return subimageTexel + layoutData.xy;\n}\nvec4 sampleSubImage(vec2 texCoord, int index, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    vec2 atlasCoords = calcSubImageTexCoords(texCoord, index, atlasLayout, atlasDesc);\n    return texture2D(atlasImage, atlasCoords);\n}"; // eslint-disable-line

  // @ts-nocheck
  shaderLibrary.setShaderModule('imageAtlas.glsl', imageAtlas);
  shaderLibrary.setShaderModule('surfaceGeomData.glsl', surfaceGeomData);
  shaderLibrary.setShaderModule('surfaceHighlight.glsl', surfaceHighlight);
  shaderLibrary.setShaderModule('computeViewNormal.glsl', computeViewNormal);
  shaderLibrary.setShaderModule('calcFatLinesViewPos.glsl', calcFatLinesViewPos);
  shaderLibrary.setShaderModule('constants.glsl', constants);
  shaderLibrary.setShaderModule('convolve-helpers.glsl', convolveHelpers);
  shaderLibrary.setShaderModule('cutaways.glsl', cutaways);
  shaderLibrary.setShaderModule('debugColors.glsl', debugColors);
  shaderLibrary.setShaderModule('drawItemId.glsl', geomItemId); // Needed for backwards compatiblity with older versions of ux.
  shaderLibrary.setShaderModule('geomItemId.glsl', geomItemId);
  shaderLibrary.setShaderModule('geomItemFlags.glsl', geomItemFlags);
  shaderLibrary.setShaderModule('geomType.glsl', geomType);
  shaderLibrary.setShaderModule('geometryMask.glsl', geometryMask);
  shaderLibrary.setShaderModule('drawItemTexture.glsl', drawItemTexture);
  shaderLibrary.setShaderModule('envmap-dualfisheye.glsl', envmapDualfisheye);
  shaderLibrary.setShaderModule('envmap-equirect.glsl', envmapEquirect);
  shaderLibrary.setShaderModule('envmap-octahedral.glsl', envmapOctahedral);
  shaderLibrary.setShaderModule('GLSLBits.glsl', GLSLBits);
  shaderLibrary.setShaderModule('GLSLUtils.glsl', GLSLUtils);
  shaderLibrary.setShaderModule('Hammersley.glsl', Hammersley);
  shaderLibrary.setShaderModule('ImportanceSampleGGX.glsl', ImportanceSampleGGX);
  shaderLibrary.setShaderModule('materialparams.glsl', materialparams);
  shaderLibrary.setShaderModule('modelMatrix.glsl', modelMatrix);
  shaderLibrary.setShaderModule('PBRSurfaceRadiance.glsl', PBRSurfaceRadiance);
  shaderLibrary.setShaderModule('SHCoeffs.glsl', SHCoeffs);
  shaderLibrary.setShaderModule('gamma.glsl', gamma);
  shaderLibrary.setShaderModule('inverse.glsl', inverse);
  shaderLibrary.setShaderModule('transpose.glsl', transpose);
  shaderLibrary.setShaderModule('quadVertexFromID.glsl', quadVertexFromID);
  shaderLibrary.setShaderModule('unpackHDR.glsl', unpackHDR);

  var frag$j = " \nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\nuniform sampler2D ldrSampler;\nuniform sampler2D cdmSampler;\nuniform vec4 srcRegion; // pos, and size of the source region\n\nimport 'unpackHDR.glsl'\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 srcUv = srcRegion.xy + (v_texCoord * srcRegion.zw);\n\n  fragColor = vec4(decodeHDR(ldrSampler, cdmSampler, srcUv), 1.0);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n"; // eslint-disable-line

  var vert$k = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** Shader for unpacking HDR images using Boost HDR algorithm.
   * @extends GLShader
   * @private
   */
  class UnpackHDRShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'UnpackHDRShader');
          this.setShaderStage('VERTEX_SHADER', vert$k);
          this.setShaderStage('FRAGMENT_SHADER', frag$j);
      }
  }

  /* eslint-disable guard-for-in */
  /**
   * Returns a descriptor for the provided geom attribute.
   * Used to generate WebGLBuffers from the data provided by the geometry.
   * @private
   * @param gl - The webgl context
   * @param attrDataType - The geometry attribute value.
   *
   * @return
   */
  const genDataTypeDesc = (gl, name) => {
      let dimension;
      let elementSize;
      let dataType;
      switch (name) {
          case 'UInt8':
              dimension = 1;
              elementSize = 4;
              dataType = gl.UNSIGNED_BYTE;
              break;
          case 'SInt8':
              dimension = 1;
              elementSize = 1;
              dataType = gl.BYTE;
              break;
          case 'UInt16':
              dimension = 1;
              elementSize = 2;
              dataType = gl.UNSIGNED_SHORT;
              break;
          case 'SInt16':
              dimension = 1;
              elementSize = 2;
              dataType = gl.SHORT;
              break;
          case 'UInt32':
              dimension = 1;
              elementSize = 4;
              dataType = gl.UNSIGNED_INT;
              break;
          case 'SInt32':
              dimension = 1;
              elementSize = 4;
              dataType = gl.INT;
              break;
          case 'Float32':
              dimension = 1;
              elementSize = 4;
              dataType = gl.FLOAT;
              break;
          case 'Vec2f8':
              dimension = 2;
              elementSize = 1;
              dataType = gl.BYTE;
              break;
          case 'Vec2f16':
              dimension = 2;
              elementSize = 2;
              dataType = gl.HALF_FLOAT;
              break;
          case 'Vec2':
              dimension = 2;
              elementSize = 4;
              dataType = gl.FLOAT;
              break;
          case 'Vec3f8':
              dimension = 3;
              elementSize = 1;
              dataType = gl.BYTE;
              break;
          case 'Vec3f16':
              dimension = 3;
              elementSize = 2;
              dataType = gl.HALF_FLOAT;
              break;
          case 'Vec3':
              dimension = 3;
              elementSize = 4;
              dataType = gl.FLOAT;
              break;
          case 'Vec4':
          case 'Color':
              dimension = 4;
              elementSize = 4;
              dataType = gl.FLOAT;
              break;
          case 'Vec4f8':
              dimension = 4;
              elementSize = 1;
              dataType = gl.BYTE;
              break;
          case 'Vec4f16':
              dimension = 4;
              elementSize = 2;
              dataType = gl.HALF_FLOAT;
              break;
          case 'RGBA':
              dimension = 4;
              elementSize = 1;
              dataType = gl.UNSIGNED_BYTE;
              break;
          default:
              throw 'Unhandled Type:' + name;
      }
      return {
          name,
          dimension,
          elementSize,
          dataType,
      };
  };
  class IGeomShaderBinding {
  }
  /** Class representing a geom shader binding.
   * @private
   */
  class GeomShaderBinding extends IGeomShaderBinding {
      gl;
      shaderAttrs;
      glattrbuffers;
      indexBuffer;
      /**
       * Create a geom shader binding.
       * @param gl - The webgl rendering context.
       * @param shaderAttrs - The shader attributes.
       * @param geomAttrBuffers - The geomAttrBuffers value.
       * @param indexBuffer - The index buffer.
       */
      constructor(gl, shaderAttrs, geomAttrBuffers, indexBuffer) {
          super();
          this.gl = gl;
          this.shaderAttrs = shaderAttrs;
          this.glattrbuffers = geomAttrBuffers;
          this.indexBuffer = indexBuffer;
      }
      /**
       * The bind method.
       * @param renderstate - The render state.
       * @return - The return value.
       */
      bind(renderstate) {
          const gl = this.gl;
          for (const attrName in this.shaderAttrs) {
              if (attrName == 'instancedIds')
                  continue;
              const shaderAttrDesc = this.shaderAttrs[attrName];
              const location = shaderAttrDesc.location;
              if (location == -1)
                  continue;
              const geomAttrBuffer = this.glattrbuffers[attrName];
              if (!geomAttrBuffer) {
                  gl.disableVertexAttribArray(location);
                  continue;
              }
              const dimension = geomAttrBuffer.dimension;
              const dataType = geomAttrBuffer.dataType;
              const normalized = geomAttrBuffer.normalized;
              const isInteger = shaderAttrDesc.integer;
              const stride = dimension * geomAttrBuffer.elementSize;
              const offset = geomAttrBuffer.offset != undefined ? geomAttrBuffer.offset * dimension * geomAttrBuffer.elementSize : 0;
              const instanced = shaderAttrDesc.instanced;
              gl.enableVertexAttribArray(location);
              gl.bindBuffer(gl.ARRAY_BUFFER, geomAttrBuffer.buffer);
              if (isInteger) {
                  gl.vertexAttribIPointer(location, dimension, dataType, stride, offset);
              }
              else {
                  gl.vertexAttribPointer(location, dimension, dataType, normalized, stride, offset);
              }
              if (instanced == true) {
                  gl.vertexAttribDivisor(location, 1); // This makes it instanced
              }
              else {
                  gl.vertexAttribDivisor(location, 0); // This makes it not-instanced
              }
              // console.log("Binding :" + attrName + " to attr:" + location + " count:" + geomAttrBuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
          }
          if (this.indexBuffer)
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          return true;
      }
      /**
       * The unbind method.
       */
      unbind(renderstate) {
          const gl = this.gl;
          for (const attrName in this.shaderAttrs) {
              const shaderAttrDesc = this.shaderAttrs[attrName];
              const location = shaderAttrDesc.location;
              if (location == -1) {
                  gl.enableVertexAttribArray(location);
              }
              if (shaderAttrDesc.instanced) {
                  gl.vertexAttribDivisor(location, 0); // This makes it not-instanced
              }
              // console.log("Binding :" + attrName + " to attr:" + location + " count:" + geomAttrBuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() { }
  }
  /** Class representing vertex array objects (VAO) geom shader binding.
   * @private
   */
  class VAOGeomShaderBinding extends IGeomShaderBinding {
      vao;
      gl;
      indexBuffer;
      /**
       * Create VAO geom shader binding.
       * @param gl - The webgl rendering context.
       * @param shaderAttrs - The shaderAttrs value.
       * @param geomAttrBuffers - The geomAttrBuffers value.
       * @param indexBuffer - The indexBuffer value.
       */
      constructor(gl, shaderAttrs, geomAttrBuffers, indexBuffer) {
          super();
          this.gl = gl;
          this.vao = gl.createVertexArray();
          gl.bindVertexArray(this.vao);
          for (const attrName in shaderAttrs) {
              if (attrName == 'instancedIds')
                  continue;
              const shaderAttrDesc = shaderAttrs[attrName];
              const location = shaderAttrDesc.location;
              if (location == -1)
                  continue;
              let geomAttrBuffer = geomAttrBuffers[attrName];
              let offset = 0;
              if (!geomAttrBuffer) {
                  if (attrName.endsWith('Next')) {
                      geomAttrBuffer = geomAttrBuffers[attrName.substring(0, attrName.length - 4)];
                      offset = 1 * geomAttrBuffer.dimension * geomAttrBuffer.elementSize;
                  }
                  if (!geomAttrBuffer) {
                      // console.warn("geomAttrBuffer missing:" + attrName + " location:" + location);
                      gl.disableVertexAttribArray(location);
                      continue;
                  }
              }
              const dimension = geomAttrBuffer.dimension;
              const dataType = geomAttrBuffer.dataType;
              const stride = geomAttrBuffer.dimension * geomAttrBuffer.elementSize;
              const isInteger = shaderAttrDesc.integer;
              const instanced = shaderAttrDesc.instanced;
              gl.enableVertexAttribArray(location);
              gl.bindBuffer(gl.ARRAY_BUFFER, geomAttrBuffer.buffer);
              if (isInteger) {
                  gl.vertexAttribIPointer(location, dimension, dataType, stride, offset);
              }
              else {
                  const normalized = geomAttrBuffer.normalized == true;
                  gl.vertexAttribPointer(location, dimension, dataType, normalized, stride, offset);
              }
              if (gl.vertexAttribDivisor) {
                  if (instanced == true) {
                      gl.vertexAttribDivisor(location, 1); // This makes it instanced
                  }
                  else {
                      gl.vertexAttribDivisor(location, 0); // This makes it not-instanced
                  }
              }
              // console.log("Binding :" + attrName + " to attr:" + location + " count:" + geomAttrBuffer.count + " dimension:" + dimension  + " stride:" + stride  + " offset:" + offset + " normalized:" + normalized + " instanced:" + instanced);
          }
          this.indexBuffer = indexBuffer;
          if (this.indexBuffer)
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      }
      /**
       * The bind method.
       * @param renderstate - The render state.
       * @return - The return value.
       */
      bind(renderstate) {
          const gl = this.gl;
          gl.bindVertexArray(this.vao);
          if (this.indexBuffer)
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          return true;
      }
      /**
       * The unbind method.
       */
      unbind(renderstate) {
          const gl = this.gl;
          gl.bindVertexArray(null);
          if (this.indexBuffer)
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          const gl = this.gl;
          // Ensure we detach the index buffer before deleting the VAO.
          if (this.indexBuffer) {
              gl.bindVertexArray(this.vao);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
          gl.deleteVertexArray(this.vao);
      }
  }
  function generateShaderGeomBinding(gl, shaderAttrs, geomAttrBuffers, indexBuffer) {
      if (gl.createVertexArray == null) {
          return new GeomShaderBinding(gl, shaderAttrs, geomAttrBuffers, indexBuffer);
      }
      else {
          return new VAOGeomShaderBinding(gl, shaderAttrs, geomAttrBuffers, indexBuffer);
      }
  }

  /** Class representing a GL high dynamic range (HDR) image.
   * @extends GLTexture2D
   * @private
   */
  class GLHDRImage extends GLTexture2D {
      //  protected __gl: WebGL12RenderingContext
      listenerIDs = {};
      hdrImage;
      fbo = null;
      srcLDRTex = null;
      srcCDMTex = null;
      unpackHDRShader = null;
      shaderBinding = null;
      /**
       * Create a GL HDR image.
       * @param gl - The webgl rendering context.
       * @param hdrImage - The HDR image.
       */
      constructor(gl, hdrImage) {
          super(gl);
          this.hdrImage = hdrImage;
          const loadImage = () => {
              this.__unpackHDRImage(this.hdrImage.getParams());
          };
          this.listenerIDs['updated'] = this.hdrImage.on('updated', loadImage);
          if (this.hdrImage.isLoaded()) {
              loadImage();
          }
          else {
              this.listenerIDs['loaded'] = this.hdrImage.on('loaded', loadImage);
          }
      }
      /**
       * Returns the `BaseImage` of the GL Texture
       *
       * @return - The return value.
       */
      getImage() {
          return this.hdrImage;
      }
      /**
       * The __unpackHDRImage method.
       * @param hdrImageParams - The HDR image parameters.
       * @private
       */
      __unpackHDRImage(hdrImageParams) {
          const gl = this.__gl;
          const ldr = hdrImageParams.data.ldr;
          const cdm = hdrImageParams.data.cdm;
          if (!this.fbo) {
              // Note: iOS devices create FLOAT Fbox.
              // If we want better quality, we could unpack the texture in JavaScript.
              this.configure({
                  format: 'RGBA',
                  type: 'FLOAT',
                  width: ldr.width,
                  height: ldr.height,
                  filter: 'LINEAR',
                  wrap: 'CLAMP_TO_EDGE',
              });
              this.fbo = new GLFbo(this.__gl, this);
              this.fbo.setClearColor(new Color(0, 0, 0, 0));
              this.srcLDRTex = new GLTexture2D(this.__gl, {
                  format: 'RGB',
                  type: 'UNSIGNED_BYTE',
                  width: ldr.width,
                  height: ldr.height,
                  filter: 'NEAREST',
                  mipMapped: false,
                  wrap: 'CLAMP_TO_EDGE',
                  data: ldr,
              });
              this.srcCDMTex = new GLTexture2D(this.__gl, {
                  format: gl.name == 'webgl2' ? 'RED' : 'ALPHA',
                  type: 'UNSIGNED_BYTE',
                  width: ldr.width /* 8*/,
                  height: ldr.height /* 8*/,
                  filter: 'NEAREST',
                  mipMapped: false,
                  wrap: 'CLAMP_TO_EDGE',
                  data: cdm,
              });
              this.unpackHDRShader = new UnpackHDRShader(this.__gl);
              const shaderComp = this.unpackHDRShader.compileForTarget('GLHDRImage', ['#define ENABLE_ES3']);
              this.shaderBinding = generateShaderGeomBinding(this.__gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
          }
          else {
              this.srcLDRTex.bufferData(ldr);
              this.srcCDMTex.bufferData(cdm);
          }
          this.fbo.bindAndClear();
          const renderstate = new RenderState(gl);
          this.unpackHDRShader.bind(renderstate, 'GLHDRImage');
          this.shaderBinding.bind(renderstate);
          const unifs = renderstate.unifs;
          this.srcLDRTex.bindToUniform(renderstate, unifs.ldrSampler);
          this.srcCDMTex.bindToUniform(renderstate, unifs.cdmSampler);
          gl.uniform4fv(unifs.srcRegion.location, [0, 0, 1, 1]);
          gl.drawQuad();
          // // Debug a block of pixels.
          // console.log(this.hdrImage.getName());
          // gl.finish();
          // let numPixels = 4;
          // let pixels = new Float32Array(4 * numPixels);
          // gl.readPixels(ldr.width / 4, ldr.height/4, numPixels, 1, gl.RGBA, gl.FLOAT, pixels);
          // console.log(pixels);
          // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          this.fbo.unbind();
          // if (!this.hdrImage.isStream()) {
          //     this.fbo.destroy();
          //     this.srcLDRTex.destroy();
          //     this.srcCDMTex.destroy();
          //     this.fbo = null;
          //     this.srcLDRTex = null;
          //     this.srcCDMTex = null;
          // }
          this.emit('updated');
      }
      /**
       * The bindToUniform method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param unif - The WebGL uniform
       * @param bindings - The bindings value.
       * @return - The return value.
       */
      bindToUniform(renderstate, unif, bindings) {
          return super.bindToUniform(renderstate, unif, bindings);
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          super.destroy();
          if (this.fbo) {
              this.fbo.destroy();
              this.srcLDRTex.destroy();
              this.srcCDMTex.destroy();
          }
          if (this.unpackHDRShader)
              this.unpackHDRShader.destroy();
          if (this.shaderBinding)
              this.shaderBinding.destroy();
          if ('loaded' in this.listenerIDs)
              this.hdrImage.off('loaded', this.listenerIDs['loaded']);
          this.hdrImage.off('updated', this.listenerIDs['updated']);
      }
  }

  /** Class representing a GL geom.
   * @private
   */
  class GLGeom extends RefCounted {
      __gl;
      geom;
      numVertices = -1;
      glattrbuffers = {};
      shaderBindings = {};
      buffersDirty = true;
      genBufferOpts = {};
      indexBuffer = null;
      /**
       * Create a GL geom.
       * @param gl - The webgl rendering context.
       * @param geom - A geometry object
       */
      constructor(gl, geom) {
          super();
          this.__gl = gl;
          this.geom = geom;
          const geomDataChanged = (opts) => {
              this.dirtyBuffers(opts);
          };
          this.geom.on('geomDataChanged', geomDataChanged);
          const geomDataTopologyChanged = (opts) => {
              this.clearBuffers();
              this.dirtyBuffers(opts);
          };
          this.geom.on('geomDataTopologyChanged', geomDataTopologyChanged);
      }
      /**
       * Returns the owned Geometry object
       * @return - The geometry object.
       */
      getGeom() {
          return this.geom;
      }
      // /////////////////////////////////////
      // Buffers
      /**
       * The dirtyBuffers method.
       * @param opts - options passed when geomDataChanged is emitted. (Currently ony used by the FreehandLines tool)
       */
      dirtyBuffers(opts) {
          this.genBufferOpts = opts;
          this.buffersDirty = true;
          this.emit('updated');
      }
      /**
       * The genBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      genBuffers(renderstate) {
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers();
          // eslint-disable-next-line guard-for-in
          for (const attrName in geomBuffers.attrBuffers) {
              if (!renderstate.attrs[attrName])
                  continue;
              if (this.glattrbuffers[attrName] && this.glattrbuffers[attrName].buffer) {
                  gl.deleteBuffer(this.glattrbuffers[attrName].buffer);
              }
              const attrData = geomBuffers.attrBuffers[attrName];
              const attrDesc = genDataTypeDesc(gl, attrData.dataType);
              const attrBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, attrBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);
              this.glattrbuffers[attrName] = {
                  dataType: attrDesc.dataType,
                  name: attrName,
                  dimension: attrData.dimension,
                  elementSize: attrDesc.elementSize,
                  normalized: false,
                  shared: false,
                  numValues: attrData.count,
                  buffer: attrBuffer,
              };
          }
          this.numVertices = this.geom.getNumVertices();
          this.buffersDirty = false;
      }
      /**
       * The updateBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      updateBuffers(renderstate) {
          if (this.numVertices != this.geom.getNumVertices()) {
              this.genBuffers(renderstate);
              return;
          }
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers({ includeIndices: false });
          // eslint-disable-next-line guard-for-in
          for (const attrName in geomBuffers.attrBuffers) {
              const attrData = geomBuffers.attrBuffers[attrName];
              const glattr = this.glattrbuffers[attrName];
              gl.bindBuffer(gl.ARRAY_BUFFER, glattr.buffer);
              gl.bufferData(gl.ARRAY_BUFFER, attrData.values, gl.STATIC_DRAW);
          }
          this.buffersDirty = false;
      }
      // /////////////////////////////////////
      // Binding
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - returns false if the binding failed.
       */
      bind(renderstate) {
          if (this.__destroyed)
              throw new Error('Error binding a destroyed geom');
          if (this.buffersDirty)
              this.updateBuffers(renderstate);
          let shaderBinding = this.shaderBindings[renderstate.shaderkey];
          if (!shaderBinding) {
              const gl = this.__gl;
              shaderBinding = generateShaderGeomBinding(gl, renderstate.attrs, this.glattrbuffers, this.indexBuffer);
              this.shaderBindings[renderstate.shaderkey] = shaderBinding;
          }
          shaderBinding.bind(renderstate);
      }
      /**
       * The unbind method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      unbind(renderstate) {
          // Unbinding a geom is important as it puts back some important
          // GL state. (vertexAttribDivisor)
          const shaderBinding = this.shaderBindings[renderstate.shaderkey];
          if (shaderBinding) {
              shaderBinding.unbind(renderstate);
          }
      }
      // /////////////////////////////////////
      // Drawing
      // Draw an item to screen.
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          throw new Error('Not implemented. Implement this method in a derived class.');
      }
      /**
       * The drawInstanced method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param instanceCount - The instanceCount param.
       */
      drawInstanced(renderstate, instanceCount) {
          throw new Error('Not implemented. Implement this method in a derived class.');
      }
      /**
       * The bindAndDraw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindAndDraw(renderstate) {
          this.bind(renderstate);
          this.draw(renderstate);
      }
      /**
       * The clearBuffers method.
       */
      clearBuffers() {
          const gl = this.__gl;
          // eslint-disable-next-line guard-for-in
          for (const attrName in this.glattrbuffers) {
              const glbuffer = this.glattrbuffers[attrName];
              if (glbuffer.shared)
                  continue; /* This buffer is shared between geoms. do not destroy */
              gl.deleteBuffer(glbuffer.buffer);
          }
          this.glattrbuffers = {};
          // eslint-disable-next-line guard-for-in
          for (const shaderkey in this.shaderBindings) {
              const shaderBinding = this.shaderBindings[shaderkey];
              shaderBinding.destroy();
          }
          this.shaderBindings = {};
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          this.clearBuffers();
          super.destroy();
      }
  }

  /** Class representing a GL mesh.
   * @extends GLGeom
   * @private
   */
  class GLMesh extends GLGeom {
      numTriIndices = 0;
      indexDataType = 0;
      numTriangles = 0;
      /**
       * Create a GL mesh.
       * @param gl - The webgl rendering context.
       * @param mesh - The mesh value.
       */
      constructor(gl, mesh) {
          super(gl, mesh);
      }
      // /////////////////////////////////////
      // Buffers
      /**
       * The genBuffers method.
       */
      genBuffers(renderstate) {
          super.genBuffers(renderstate);
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers();
          const indices = geomBuffers.indices;
          if (indices instanceof Uint8Array)
              this.indexDataType = this.__gl.UNSIGNED_BYTE;
          if (indices instanceof Uint16Array)
              this.indexDataType = this.__gl.UNSIGNED_SHORT;
          if (indices instanceof Uint32Array)
              this.indexDataType = this.__gl.UNSIGNED_INT;
          if (this.indexBuffer) {
              gl.deleteBuffer(this.indexBuffer);
          }
          this.indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geomBuffers.indices, gl.STATIC_DRAW);
          this.numTriIndices = geomBuffers.indices.length;
          this.numTriangles = indices.length / 3;
          if (this.glattrbuffers.textureCoords) {
              this.glattrbuffers.texCoords = this.glattrbuffers.textureCoords;
              delete this.glattrbuffers.textureCoords;
          }
      }
      /**
       * The clearBuffers method.
       */
      clearBuffers() {
          const gl = this.__gl;
          gl.deleteBuffer(this.indexBuffer);
          this.indexBuffer = null;
          super.clearBuffers();
      }
      // /////////////////////////////////////
      // Binding
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - returns false if the binding failed.
       */
      bind(renderstate) {
          super.bind(renderstate);
          const { geomType } = renderstate.unifs;
          if (geomType)
              this.__gl.uniform1i(geomType.location, 0 /*GeomType.TRIANGLES*/);
      }
      // ////////////////////////////////
      // Regular Drawing.
      /**
       * Draw an item to screen.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          this.__gl.drawElements(this.__gl.TRIANGLES, this.numTriIndices, this.indexDataType, 0);
      }
      /**
       * The drawInstanced method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param instanceCount - The instanceCount value.
       */
      drawInstanced(renderstate, instanceCount) {
          const gl = this.__gl;
          gl.drawElementsInstanced(this.__gl.TRIANGLES, this.numTriIndices, this.indexDataType, 0, instanceCount);
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          super.destroy();
          const gl = this.__gl;
          gl.deleteBuffer(this.indexBuffer);
          this.indexBuffer = null;
      }
  }

  const FRAMEBUFFER = {
      MSAA_RENDERBUFFER: 0,
      COLORBUFFER: 1,
      DEPTHBUFFER: 2,
  };
  /**
   * Class representing a GL base viewport.
   * @extends ParameterOwner
   * @private
   */
  class GLBaseViewport extends ParameterOwner {
      __gl;
      renderer;
      __renderer;
      __fbo = null;
      quad;
      offscreenBuffer = null;
      depthTexture = null;
      highlightedGeomsBufferFbo;
      __backgroundTexture = null;
      __backgroundGLTexture = null;
      offscreenBufferFbo = null;
      width = 0;
      height = 0;
      __canvasWidth = 0;
      __canvasHeight = 0;
      fb = null;
      colorRenderbuffer;
      depthBuffer = null;
      EXT_frag_depth = null;
      manipulator;
      depthRange = [0, 0];
      region = [0, 0, 0, 0];
      /**
       * @member backgroundColorParam - Changes background color of the scene
       */
      backgroundColorParam = new ColorParameter('BackgroundColor', new Color('#eeeeee')); // owned by viewport
      // The time between clicks for a double click to be registered.
      clickTime = 200;
      doubleClickTime = 200;
      // The duration for the pointer to be held to emit a long press event.
      longPressTime = 1000;
      // The maximum movingment of the pointer to still be considered a 'click'
      pointerClickTolerance = 5;
      longPressId;
      /**
       * Create a GL base viewport.
       * @param renderer - The renderer value.
       */
      constructor(renderer) {
          super();
          this.renderer = renderer;
          this.__renderer = renderer;
          const gl = this.__renderer.gl;
          this.__gl = gl;
          this.quad = new GLMesh(gl, new Plane(1, 1));
          // //////////////////////////////////
          // Setup Offscreen Render Targets
          // Note: On low end devices, such as Oculus, blitting the multi-sampled depth buffer is throwing errors,
          // and so we are simply disabling silhouettes on all low end devices now.
          this.highlightedGeomsBufferFbo = new GLRenderTarget(gl, {
              type: gl.UNSIGNED_BYTE,
              format: gl.RGBA,
              filter: gl.NEAREST,
              width: 4,
              height: 4,
              createDepthTexture: true,
          });
          this.highlightedGeomsBufferFbo.clearColor = new Color(0, 0, 0, 0);
          // //////////////////////////////////
          // Setup Camera Manipulator
          const processBGValue = () => {
              const value = this.backgroundColorParam.value;
              if (value instanceof BaseImage) {
                  if (value instanceof HDRImage) {
                      this.__backgroundTexture = value;
                      this.__backgroundGLTexture = new GLHDRImage(gl, value);
                  }
                  else {
                      this.__backgroundTexture = value;
                      this.__backgroundGLTexture = new GLTexture2D(gl, value);
                  }
              }
              else if (value instanceof Color) {
                  if (this.__backgroundGLTexture) {
                      this.__backgroundGLTexture.destroy();
                      this.__backgroundGLTexture = null;
                      this.__backgroundTexture = null;
                  }
                  if (this.offscreenBufferFbo) {
                      this.offscreenBufferFbo.clearColor = value;
                  }
              }
              else {
                  console.warn('Invalid background:' + value);
              }
              this.emit('updated');
          };
          processBGValue();
          this.backgroundColorParam.on('valueChanged', processBGValue);
      }
      /**
       * Returns the renderer this viewport is bound to.
       */
      getRenderer() {
          return this.renderer;
      }
      /**
       * The getWidth method.
       * @return - The return value.
       */
      getWidth() {
          return this.width;
      }
      /**
       * The getHeight method.
       * @return - The return value.
       */
      getHeight() {
          return this.height;
      }
      /**
       * The resize method.
       * @param canvasWidth - The canvasWidth value.
       * @param canvasHeight - The canvasHeight value.
       */
      resize(canvasWidth, canvasHeight) {
          if (this.__canvasWidth == canvasWidth && this.__canvasHeight == canvasHeight)
              return;
          this.__canvasWidth = canvasWidth;
          this.__canvasHeight = canvasHeight;
          this.width = canvasWidth;
          this.height = canvasHeight;
          this.region = [0, 0, this.width, this.height];
          this.resizeRenderTargets(canvasWidth, canvasHeight);
          const event = new ResizedEvent(this.width, this.height);
          this.emit('resized', event);
      }
      /**
       * Resize any offscreen render targets.
       * > Note: Values ,ay not be the entire canvas with if multiple viewports exists.
       * @param width - The width used by this viewport.
       * @param height - The height  used by this viewport.
       */
      resizeRenderTargets(width, height) {
          if (this.highlightedGeomsBufferFbo) {
              this.highlightedGeomsBufferFbo.resize(width, height);
          }
          const gl = this.__renderer.gl;
          if (this.renderer.outlineThickness > 0 && this.renderer.outlineMethod == 'image') {
              const disableOnSafari = SystemDesc.browserName == 'Safari';
              // Note: On low end devices, such as Oculus, blitting the multi-sampled depth buffer is throwing errors,
              // and so we are simply disabling silhouettes on all low end devices now.
              if (disableOnSafari || gl.name == 'webgl') {
                  console.warn('Disabling outlines on Safari due to a regression in WebKit', SystemDesc);
                  return;
              }
              if (this.fb) {
                  gl.deleteFramebuffer(this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER]);
                  gl.deleteFramebuffer(this.fb[FRAMEBUFFER.COLORBUFFER]);
                  gl.deleteFramebuffer(this.fb[FRAMEBUFFER.DEPTHBUFFER]);
                  if (this.colorRenderbuffer)
                      gl.deleteRenderbuffer(this.colorRenderbuffer);
                  if (this.depthBuffer)
                      gl.deleteRenderbuffer(this.depthBuffer);
              }
              // //////////////////////////////////
              // Setup Offscreen Render Targets
              // Note: On low end devices, such as Oculus, blitting the multi-sampled depth buffer is throwing errors,
              // and so we are simply disabling silhouettes on all low end devices now.
              if (!this.offscreenBuffer || !this.depthTexture) {
                  this.offscreenBuffer = new GLTexture2D(gl, {
                      type: 'UNSIGNED_BYTE',
                      format: 'RGBA',
                      filter: 'LINEAR',
                      width: 4,
                      height: 4,
                  });
                  this.depthTexture = new GLTexture2D(gl, {
                      type: gl.UNSIGNED_INT_24_8,
                      format: gl.DEPTH_STENCIL,
                      internalFormat: gl.name == 'webgl' ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT,
                      filter: gl.NEAREST,
                      wrap: gl.CLAMP_TO_EDGE,
                      width: 4,
                      height: 4,
                  });
              }
              else {
                  this.offscreenBuffer.resize(width, height);
                  this.depthTexture.resize(width, height);
              }
              // Create and bind the framebuffer
              this.fb = [];
              this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER] = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER]);
              this.colorRenderbuffer = gl.createRenderbuffer();
              // Create the color buffer
              gl.bindRenderbuffer(gl.RENDERBUFFER, this.colorRenderbuffer);
              // iOS devices have trouble with Multisample render buffers
              if (this.renderer.multiSampledScreenBuffer)
                  gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA8, width, height);
              else
                  gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.RGBA8, width, height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.colorRenderbuffer);
              this.depthBuffer = gl.createRenderbuffer();
              gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
              if (this.renderer.multiSampledScreenBuffer)
                  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, width, height);
              else
                  gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, width, height);
              gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
              // //////////////////////////////////
              // COLORBUFFER
              this.fb[FRAMEBUFFER.COLORBUFFER] = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb[FRAMEBUFFER.COLORBUFFER]);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.offscreenBuffer.glTex, 0);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              // //////////////////////////////////
              // DEPTHBUFFER
              // Create the depth texture that will be bitted to.
              this.fb[FRAMEBUFFER.DEPTHBUFFER] = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.fb[FRAMEBUFFER.DEPTHBUFFER]);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture.glTex, 0);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              const check = gl.checkFramebufferStatus(gl.name == 'webgl' ? gl.DRAW_FRAMEBUFFER : gl.FRAMEBUFFER);
              if (check !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (check) {
                      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                          throw new Error('The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.');
                      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                          throw new Error('There is no attachment.');
                      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                          throw new Error('Height and width of the attachment are not the same.');
                      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                          throw new Error('The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.');
                      case 36061: // gl.GL_FRAMEBUFFER_UNSUPPORTED:
                          throw new Error('The framebuffer is unsupported');
                      default:
                          throw new Error('Incomplete Frambuffer');
                  }
              }
          }
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__renderer.gl;
          renderstate.pushGLStack('GLBaseViewport.draw');
          const prevRendertarget = renderstate.boundRendertarget;
          if (this.renderer.outlineThickness > 0 && this.renderer.outlineMethod == 'image') {
              const disableOnSafari = SystemDesc.browserName == 'Safari';
              if (disableOnSafari || gl.name == 'webgl') {
                  console.warn('Disabling outlines on Safari due to a regression in WebKit', SystemDesc);
              }
              else {
                  if (!this.fb)
                      this.resizeRenderTargets(this.width, this.height);
                  const frameBuffer = this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER];
                  gl.bindFramebuffer(gl.name == 'webgl' ? gl.DRAW_FRAMEBUFFER : gl.FRAMEBUFFER, frameBuffer);
                  renderstate.boundRendertarget = frameBuffer;
              }
          }
          else {
              // Make sure the default fbo is bound
              // Note: boundRendertarget will be set during a WebXR session
              // Note: Sometimes an Fbo is left bound
              // from another op(like resizing, populating etc..)
              // We need to unbind here to ensure rendering is to the
              // right target.
              if (!renderstate.boundRendertarget)
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          renderstate.glEnable(gl.DEPTH_TEST);
          this.__renderer.drawScene(renderstate);
          const highlightRenderState = renderstate.toHighlightRenderState();
          this.drawHighlights(highlightRenderState);
          if (highlightRenderState.stack.length != 0) {
              console.warn(' corrupt highlightRenderState.stack.length:', highlightRenderState.stack.length);
          }
          // //////////////////////////////////
          // Post processing.
          if (this.fb) {
              // "blit" the scene into the color buffer
              gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER]);
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fb[FRAMEBUFFER.COLORBUFFER]);
              gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
              gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, prevRendertarget);
              renderstate.boundRendertarget = prevRendertarget;
              gl.viewport(this.region[0], this.region[1], this.region[2], this.region[3]);
              gl.disable(gl.DEPTH_TEST);
              const screenQuad = this.__renderer.screenQuad;
              screenQuad.bindShader(renderstate);
              screenQuad.draw(renderstate, this.offscreenBuffer);
              gl.enable(gl.DEPTH_TEST);
          }
          renderstate.popGLStack();
          this.renderer.emit('redrawOccurred');
      }
      /**
       * Draws the Silhouettes around geometries.
       * @param renderstate - The object tracking the current state of the renderer
       * @private
       */
      drawSilhouettes(renderstate) {
          renderstate.pushGLStack('GLBaseViewport.drawSilhouettes');
          // We cannot render silhouettes in iOS because EXT_frag_depth is not supported
          // and without it, we cannot draw lines over the top of geometries.
          // Note: On low end devices, such as Oculus, blitting the multi-sampled depth buffer is throwing errors,
          // and so we are simply disabling silhouettes on all low end devices now.
          const gl = this.__renderer.gl;
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER]);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fb[FRAMEBUFFER.DEPTHBUFFER]);
          gl.clearBufferfv(gl.COLOR, 0, [1, 1, 1, 1]);
          gl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
          // Rebind the MSAA RenderBuffer.
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER]);
          renderstate.boundRendertarget = this.fb[FRAMEBUFFER.MSAA_RENDERBUFFER];
          gl.viewport(this.region[0], this.region[1], this.region[2], this.region[3]);
          // ////////////////////////////////////
          //
          renderstate.glEnable(gl.BLEND);
          renderstate.glDisable(gl.DEPTH_TEST);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
          gl.depthMask(false);
          this.renderer.silhouetteShader.bind(renderstate);
          const unifs = renderstate.unifs;
          this.depthTexture.bindToUniform(renderstate, unifs.depthTexture);
          gl.uniform2f(unifs.screenSize.location, this.width, this.height);
          gl.uniform1f(unifs.outlineThickness.location, this.renderer.outlineThickness * window.devicePixelRatio);
          const oc = this.renderer.outlineColor.asArray();
          gl.uniform4f(unifs.outlineColor.location, oc[0], oc[1], oc[2], oc[3]);
          gl.uniform1f(unifs.outlineSensitivity.location, this.renderer.outlineSensitivity);
          gl.uniform1f(unifs.outlineDepthBias.location, this.renderer.outlineDepthBias);
          gl.uniform2f(unifs.depthRange.location, this.depthRange[0], this.depthRange[1]);
          this.quad.bindAndDraw(renderstate);
          gl.depthMask(true);
          renderstate.popGLStack();
      }
      /**
       * Draws the highlights around geometries.
       * @param renderstate - The object tracking the current state of the renderer
       * @private
       */
      drawHighlights(renderstate) {
          if (this.highlightedGeomsBufferFbo) {
              const gl = this.__renderer.gl;
              renderstate.pushGLStack('GLBaseViewport.drawHighlights');
              this.highlightedGeomsBufferFbo.bindForWriting(renderstate, true);
              // Highlighted geoms should always be rendered 2-sided
              renderstate.glEnable(gl.CULL_FACE);
              renderstate.glEnable(gl.DEPTH_TEST);
              renderstate.glDisable(gl.BLEND);
              gl.depthFunc(gl.LESS);
              gl.depthMask(true);
              renderstate.glShader = null; // clear any bound shaders.
              this.__renderer.drawHighlightedGeoms(renderstate);
              // Unbind and restore the bound fbo
              this.highlightedGeomsBufferFbo.unbindForWriting(renderstate);
              // Now render the outlines to the entire screen.
              gl.viewport(this.region[0], this.region[1], this.region[2], this.region[3]);
              {
                  renderstate.pushGLStack('GLBaseViewport.drawHighlights.highlightsShader');
                  this.renderer.highlightsShader.bind(renderstate);
                  renderstate.glEnable(gl.BLEND);
                  gl.blendEquation(gl.FUNC_ADD);
                  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                  const unifs = renderstate.unifs;
                  gl.uniform1f(unifs.outlineThickness.location, this.renderer.highlightOutlineThickness);
                  this.highlightedGeomsBufferFbo.bindColorTexture(renderstate, unifs.highlightDataTexture);
                  this.quad.bindAndDraw(renderstate);
                  renderstate.popGLStack();
              }
              renderstate.popGLStack();
          }
      }
      // ///////////////////////////
      // Events
      /**
       * The getManipulator method.
       * @return - The return value.
       */
      getManipulator() {
          return this.manipulator;
      }
      /**
       * Sets the tool that will receive mouse, touch and keyboard events from the viewport.
       * @param tool - The manipulator value.
       */
      setManipulator(tool) {
          if (this.manipulator != tool) {
              if (this.manipulator && this.manipulator.deactivateTool) {
                  this.manipulator.deactivateTool();
              }
              this.manipulator = tool;
              if (this.manipulator.activateTool) {
                  this.manipulator.activateTool();
              }
          }
      }
      /**
       * Handler of the `pointerdown` event fired when the pointer device is initially pressed.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerDown(event) {
          console.warn('@GLBaseViewport#onPointerDown - Implement me!');
      }
      /**
       * Handler of the `pointerup` event fired when the pointer device is finally released.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerUp(event) {
          console.warn('@GLBaseViewport#onPointerUp - Implement me!');
      }
      /**
       * Handler of the `pointermove` event fired when the pointer device changes coordinates, and the pointer has not been cancelled
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerMove(event) {
          console.warn('@GLBaseViewport#onPointerMove - Implement me!');
      }
      /**
       * Invoked when the mouse pointer is moved into this viewport.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerEnter(event) {
          console.warn('@GLBaseViewport#onPointerEnter - Implement me!');
      }
      /**
       * Invoked when the mouse pointer is moved out of this viewport.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerLeave(event) {
          console.warn('@GLBaseViewport#onPointerLeave - Implement me!');
      }
      /**
       * Invoked when the mouse pointer is moved out of an element.
       * @param event - The event that occurs.
       */
      onMouseLeave(event) { }
      /**
       * Invoked when the user is pressing a key on the keyboard.
       * @param event - The event that occurs.
       */
      onKeyDown(event) { }
      /**
       * Causes an event to occur  when the user releases a key on the keyboard.
       * @param event - The event that occurs.
       */
      onKeyUp(event) { }
  }

  /* eslint-disable guard-for-in */
  /**
   * Class representing a GL viewport.
   *
   * **Events**
   * * **resized:** Emitted when the GLViewport resizes
   * * **updated:** Emitted when the GLViewport needs updating. The Renderer will trigger a redraw when this occurs.
   * * **viewChanged:** Emitted when the view changes. Usually caused by the camera moving.
   * * **pointerDoubleClick:** Emitted when the user double clicks with the mouse, or double taps in the viewport.
   * * **pointerDown:** Emitted when the user presses a pointer
   * * **pointerUp:** Emitted when the user releases a pointer
   * * **pointerOverGeom:** Emitted when the pointer is moved over a geometry
   * * **pointerLeaveGeom:** Emitted when the pointer is moved off a geometry
   * * **pointerMove:** Emitted when the pointer is moved
   * * **pointerEnter:** Emitted when the pointer is moved into thg viewport
   * * **pointerLeave:** Emitted when the mouse leaves the viewport.
   * * **pointerClick:** Emitted when a pointer is clicked on an item.
   * * **pointerLongPress:** Emitted when a pointer is clicked and held on an item for a long time.
   * * **keyDown:** Emitted when the user presses a key on the keyboard
   * * **keyUp:** Emitted when the user releases a key on the keyboard
   * * **touchCancel:** Emitted when the user cancels a touch interaction
   *
   * @extends GLBaseViewport
   */
  class GLViewport extends GLBaseViewport {
      debugGeomDataBuffer = false;
      debugOcclusionBuffer = false;
      debugReductionBuffer = false;
      debugHighlightedGeomsBuffer = false;
      // To enable picking small items, we enable searching an area around the click point
      // for the closest item. Reduce the size of this value if
      mousePointerSearchArea = 5;
      // To enable picking small items, we enable searching an area around the touch point
      // for the closest item. This value approximates the size of the touch area.
      // The picking system will return the closest item to the camera within this search area.
      // To enable precise surface placement, this value should be reduced to a value such as 1.
      touchPointerSearchArea = 45;
      projectionMatrix;
      viewportFrustum;
      camera;
      bottomLeftCoords = new Vec2(0, 0);
      topRightCoords = new Vec2(1, 1);
      posX = 0;
      posY = 0;
      pointerDownTime = [];
      pointerDownButton = -1;
      pointerDownPos = new Vec2(-1, -1);
      prevClickTime;
      prevClickPos = new Vec2(-1, -1);
      prevClickButton = -1;
      geomDataBufferSizeFactor = window.devicePixelRatio;
      geomDataRenderTarget;
      geomDataBufferRendered = false;
      geomDataBufferInvalid = true;
      cameraXfo = new Xfo();
      cameraMat = new Mat4();
      viewMatrix = new Mat4();
      screenPos = null;
      intersectionData;
      pointerOverItem;
      /**
       * Create a GL viewport.
       * @param renderer - The renderer value.
       * @param name - The name value.
       * @param width - The width of the viewport
       * @param height - The height of the viewport
       */
      constructor(renderer, name, width, height) {
          super(renderer);
          this.name = name;
          this.projectionMatrix = new Mat4();
          this.viewportFrustum = new Vec4();
          // Layout coords, x:[0..1], y:[0..1]
          this.bottomLeftCoords = new Vec2(0, 0);
          this.topRightCoords = new Vec2(1, 1);
          this.prevClickTime = 0;
          // //////////////////////////////////
          // Setup GeomData Fbo
          if (SystemDesc.isMobileDevice) {
              this.geomDataBufferSizeFactor = 8;
          }
          const gl = this.__renderer.gl;
          this.geomDataRenderTarget = new GLRenderTarget(gl, {
              type: renderer.floatGeomBuffer ? gl.FLOAT : gl.UNSIGNED_BYTE,
              format: gl.RGBA,
              filter: gl.NEAREST,
              width: width <= 1 ? 1 : Math.floor(width / this.geomDataBufferSizeFactor),
              height: height <= 1 ? 1 : Math.floor(height / this.geomDataBufferSizeFactor),
              createDepthTexture: true,
          });
          this.geomDataRenderTarget.clearColor = new Color(0, 0, 0, 0);
          // //////////////////////////////////
          // Setup Camera Manipulator
          // Each user has a separate camera, and so the default
          //  camera cannot be part of the scene.
          this.camera = new Camera('DefaultCamera');
          this.setCamera(this.camera);
          this.setManipulator(new CameraManipulator({ renderer }));
          this.resize(width, height);
      }
      /**
       * The getBl method.
       * @return - The return value.
       */
      getBl() {
          return this.bottomLeftCoords;
      }
      /**
       * The setBl method.
       * @param bl - The bl value.
       */
      setBl(bl) {
          this.bottomLeftCoords = bl;
          this.#updateLayout();
      }
      /**
       * The getTr method.
       * @return - The return value.
       */
      getTr() {
          return this.topRightCoords;
      }
      /**
       * The setTr method.
       * @param tr - The tr value.
       */
      setTr(tr) {
          this.topRightCoords = tr;
          this.#updateLayout();
      }
      /**
       * The getPosX method.
       * @return - The return value.
       */
      getPosX() {
          return this.posX;
      }
      /**
       * The getPosY method.
       * @return - The return value.
       */
      getPosY() {
          return this.posY;
      }
      /**
       * Dynamically resizes viewport.
       *
       * @param canvasWidth - The canvasWidth value.
       * @param canvasHeight - The canvasHeight value.
       */
      resize(canvasWidth, canvasHeight) {
          this.__canvasWidth = canvasWidth;
          this.__canvasHeight = canvasHeight;
          this.#updateLayout();
      }
      #updateLayout() {
          this.posX = Math.round(this.__canvasWidth * this.bottomLeftCoords.x);
          this.posY = Math.round(this.__canvasWidth * this.bottomLeftCoords.y);
          this.width = Math.round(this.__canvasWidth * this.topRightCoords.x - this.__canvasWidth * this.bottomLeftCoords.x);
          this.height = Math.round(this.__canvasHeight * this.topRightCoords.y - this.__canvasHeight * this.bottomLeftCoords.y);
          this.region = [this.posX, this.posY, this.width, this.height];
          if (this.camera)
              this.updateProjectionMatrix();
          this.resizeRenderTargets(this.width, this.height);
          const event = new ResizedEvent(this.width, this.height);
          this.emit('resized', event);
      }
      /**
       * Resize any offscreen render targets.
       * > Note: Values ,ay not be the entire canvas with if multiple viewports exists.
       * @param width - The width used by this viewport.
       * @param height - The height  used by this viewport.
       */
      resizeRenderTargets(width, height) {
          super.resizeRenderTargets(width, height);
          if (this.geomDataRenderTarget) {
              this.geomDataRenderTarget.resize(Math.floor(this.width / this.geomDataBufferSizeFactor), Math.floor(this.height / this.geomDataBufferSizeFactor));
              this.invalidateGeomDataBuffer();
          }
      }
      /**
       * Returns current camera object
       *
       * @return - The return value.
       */
      getCamera() {
          return this.camera;
      }
      /**
       * Sets current camera object
       *
       * @param camera - The camera value.
       */
      setCamera(camera) {
          this.camera = camera;
          this.depthRange = [this.camera.getNear(), this.camera.getFar()];
          const globalXfoParam = camera.globalXfoParam;
          const getCameraParams = () => {
              this.cameraXfo = globalXfoParam.value;
              this.cameraMat = this.cameraXfo.toMat4();
              this.viewMatrix = this.cameraMat.inverse();
          };
          getCameraParams();
          globalXfoParam.on('valueChanged', () => {
              getCameraParams();
              this.emit('updated');
              this.invalidateGeomDataBuffer();
              const event = new ViewChangedEvent('CameraAndPointer', this.cameraXfo);
              this.emit('viewChanged', event);
          });
          this.camera.on('projectionParamChanged', () => {
              this.updateProjectionMatrix();
              this.depthRange = [this.camera.getNear(), this.camera.getFar()];
              this.emit('updated');
          });
          this.updateProjectionMatrix();
      }
      // eslint-disable-next-line require-jsdoc
      updateProjectionMatrix() {
          const aspect = this.width / this.height;
          this.camera.updateProjectionMatrix(this.projectionMatrix, aspect);
          const flocalDist = this.camera.getFocalDistance();
          const fovY = this.camera.getFov();
          const isOrthographic = this.camera.isOrthographicParam.value;
          const frustumHPersp = Math.tan(fovY / 2.0) * flocalDist * 2.0;
          const frustumWPersp = frustumHPersp * aspect;
          const frustumHOrtho = this.camera.getFrustumHeight();
          const frustumWOrtho = frustumHPersp * aspect;
          this.viewportFrustum.set(MathFunctions.lerp(frustumWPersp, frustumWOrtho, isOrthographic), MathFunctions.lerp(frustumHPersp, frustumHOrtho, isOrthographic), flocalDist, fovY);
      }
      /**
       * The getProjectionMatrix method.
       * @return - The return projection matrix for the viewport.
       */
      getProjectionMatrix() {
          return this.projectionMatrix;
      }
      /**
       * The getProjectionMatrix method.
       * @return - The return projection matrix for the viewport.
       */
      getViewMatrix() {
          return this.viewMatrix;
      }
      /**
       * Calculates a new camera position that frames all the items passed in `treeItems` array, moving
       * the camera to a point where we can see all of them.
       * > See Camera.frameView
       * @param treeItems - The array of TreeItem.
       * @param duration - The duration of time to apply the frame. A value of 0 specifies an instantaneous movement of the camera.
       * @param frameBorder - The variable to use to provide an empty space around the border for geometries.
       */
      frameView(treeItems, duration = 0, frameBorder = 0.1) {
          if (this.width > 0 && this.height > 0) {
              this.camera.frameView(this, treeItems, duration, frameBorder);
          }
          else {
              // Sometimes thew renderer is not yet setup, so here we
              // wait till the window is resized and try again.
              this.once('resized', () => this.frameView(treeItems, duration, frameBorder));
          }
      }
      /**
       * Compute the screen space position of an item from a world space coordinate.
       * @param screenPos - The screen position.
       * @return - The return value.
       */
      calcScreenPosFromWorldPos(worldPos) {
          const viewProjMatrix = this.projectionMatrix.multiply(this.viewMatrix);
          const projSpacePos = viewProjMatrix.transformVec4(new Vec4(worldPos.x, worldPos.y, worldPos.z, 1));
          // perspective divide
          projSpacePos.x /= projSpacePos.w;
          projSpacePos.y /= projSpacePos.w;
          return new Vec2((projSpacePos.x * 0.5 + 0.5) * this.width, (projSpacePos.y * -0.5 + 0.5) * this.height);
      }
      /**
       * Compute a ray into the scene based on a mouse coordinate.
       * @param screenPos - The screen position.
       * @return - The return value.
       */
      calcRayFromScreenPos(screenPos) {
          // Convert the raster coordinates to screen space ([0,{w|h}] -> [-1,1]
          // - Note: The raster vertical is inverted wrt OGL screenspace Y
          const x_pixelPos = screenPos.x * window.devicePixelRatio;
          const y_pixelPos = screenPos.y * window.devicePixelRatio;
          const top_y = this.__canvasHeight * (1.0 - this.topRightCoords.y);
          // sx /sy range from -1 ... +1
          const sx = ((x_pixelPos - this.posX) / this.width) * 2.0 - 1.0;
          const sy = ((y_pixelPos - top_y) / this.height) * 2.0 - 1.0;
          // Transform the origin from camera local to world space
          const cameraMat = this.cameraMat;
          const projInv = this.projectionMatrix.inverse();
          if (projInv == null) {
              // Sometimes this happens, not sure why...
              console.warn(`Unable to generate Ray from screen pos:${screenPos.toString()} in region ${this.region}`);
              return new Ray();
          }
          let rayStart;
          let rayDirection;
          if (this.camera.isOrthographic()) {
              // Orthographic projections.
              const cameraSpaceOffset = projInv.transformVec3(new Vec3(sx, -sy, -1.0));
              cameraSpaceOffset.z = 0;
              rayStart = cameraMat.transformVec3(cameraSpaceOffset);
              rayDirection = new Vec3(0.0, 0.0, -1.0);
          }
          else {
              rayStart = cameraMat.translation;
              // Get the projected window coordinate on the near plane
              // See http://www.songho.ca/opengl/gl_projectionmatrix.html
              // for details.
              rayDirection = projInv.transformVec3(new Vec3(sx, -sy, -1.0));
          }
          // And from projection space to camera local.
          // - We nuke the translation part since we're transforming a vector.
          rayDirection = cameraMat.rotateVec3(rayDirection).normalize();
          return new Ray(rayStart, rayDirection);
      }
      // //////////////////////////
      // GeomData
      /**
       * Renders the scene geometry to the viewport's geom data buffer
       * in preparation for mouse picking.
       */
      renderGeomDataFbo() {
          if (this.geomDataRenderTarget) {
              const geomDataRenderstate = new GeomDataRenderState(this.renderer.__gl);
              geomDataRenderstate.pushGLStack('GLViewport.renderGeomDataFbo');
              this.bindGLViewport(geomDataRenderstate);
              // Note: GLLinesPass binds a new Fbo, but shares this ones depth buffer.
              geomDataRenderstate.geomDataFbo = this.geomDataRenderTarget;
              this.geomDataRenderTarget.bindForWriting(geomDataRenderstate, true);
              this.__renderer.drawSceneGeomData(geomDataRenderstate);
              this.geomDataRenderTarget.unbindForWriting();
              geomDataRenderstate.popGLStack();
              this.geomDataBufferInvalid = false;
          }
      }
      /**
       * The invalidateGeomDataBuffer method.
       */
      invalidateGeomDataBuffer() {
          this.geomDataBufferInvalid = true;
      }
      /**
       * The getGeomDataAtPos method.
       * @param screenPos - The screen position.
       * @param pointerRay - The pointerRay value.
       * @return - The return value.
       */
      getGeomDataAtPos(screenPos, pointerRay, searchArea = 5) {
          if (this.geomDataRenderTarget) {
              if (this.geomDataBufferInvalid) {
                  this.renderGeomDataFbo();
                  this.screenPos = null;
              }
              // Cache the intersection tests result so subsequent queries will return the same value.
              // Note: every new mouse event will generate a new pointerPos value, so the cache
              // is only valid for a given event propagation, and for that exact pointerPos value.
              if (screenPos === this.screenPos) {
                  return this.intersectionData;
              }
              this.screenPos = screenPos;
              this.intersectionData = null;
              const gl = this.__renderer.gl;
              gl.finish();
              this.geomDataRenderTarget.bindForReading();
              // const logGeomData = ()=>{
              //     console.log("logGeomData :[" + this.geomDataRenderTarget.width +","+ this.geomDataRenderTarget.height + "]")
              //     const pixels = new Float32Array(this.geomDataRenderTarget.width * 4);
              //     for(let i=0; i<this.geomDataRenderTarget.height; i++){
              //       gl.readPixels(0, i, this.geomDataRenderTarget.width, 1, gl.RGBA, gl.FLOAT, pixels);
              //         for(let j=0; j<this.geomDataRenderTarget.width; j++){
              //             const geomData = pixels.subarray(j*4, (j+1)*4);
              //             if (geomData[0] != 0 || geomData[1] != 0){
              //                 console.log(j, i)
              //                 break; // Only log the left border pixels.
              //             }
              //         }
              //       // console.log(pixels);
              //     }
              // }
              // logGeomData();
              // console.log("getGeomDataAtPos:", screenPos.toString(), screenPos.x,this.width)
              const x_pixelPos = screenPos.x * window.devicePixelRatio;
              const y_pixelPos = screenPos.y * window.devicePixelRatio;
              const numPixels = searchArea * searchArea;
              const bufferWidth = this.geomDataRenderTarget.width;
              const bufferHeight = this.geomDataRenderTarget.height;
              const x = Math.floor(x_pixelPos * (bufferWidth / this.width)) - searchArea * 0.5;
              const y = Math.floor(bufferHeight - y_pixelPos * (bufferHeight / this.height) - 1) - searchArea * 0.5;
              const overlayPassClass = Registry.getClassDefinition('GLOverlayPass');
              const overlayPassIndex = this.__renderer.findPassIndex(overlayPassClass);
              let passId;
              let geomData;
              if (this.__renderer.floatGeomBuffer) {
                  // Allocate a 5x5 pixel block and read from the GeomData buffer.
                  const geomDatas = new Float32Array(4 * numPixels);
                  gl.readPixels(x, y, searchArea, searchArea, gl.RGBA, gl.FLOAT, geomDatas);
                  // ////////////////////////////////////
                  // scan to find the closest geom
                  let closest = Number.MAX_VALUE;
                  let closestId = -1;
                  const checkPixel = (id) => {
                      // We look for pixels rendered from the overlay pass, as that contains
                      // handles and other UI elements the user need to be able to click on.
                      // Mask the pass id to be only the first 6 bits of the integer.
                      const passId = Math.round(geomDatas[id * 4 + 0]) & (64 - 1);
                      if (passId == overlayPassIndex) {
                          closest = 0;
                          closestId = id;
                          return true;
                      }
                      // find the closest pixel in the block to the user.
                      const dist = geomDatas[id * 4 + 3];
                      if (dist > 0 && dist < closest) {
                          closest = dist;
                          closestId = id;
                      }
                      return false;
                  };
                  for (let i = 0; i < numPixels; i++) {
                      if (checkPixel(i))
                          break;
                  }
                  if (closestId == -1)
                      return;
                  geomData = geomDatas.slice(closestId * 4, (closestId + 1) * 4);
                  // Mask the pass id to be only the first 6 bits of the integer.
                  passId = Math.round(geomData[0]) & (64 - 1);
              }
              else {
                  const geomDatas = new Uint8Array(4 * numPixels);
                  gl.readPixels(x, bufferHeight - y - 1, searchArea, searchArea, gl.RGBA, gl.UNSIGNED_BYTE, geomDatas);
                  // ////////////////////////////////////
                  // scan to find the closest geom
                  let closest = Number.MAX_VALUE;
                  let closestId = -1;
                  const checkPixel = (id) => {
                      if (geomDatas[id * 4] == 0 && geomDatas[id * 4 + 1] == 0)
                          return;
                      const distVals = geomDatas.slice(closestId * 4 + 2, closestId * 4 + 3);
                      const dist = MathFunctions.decode16BitFloatFrom2xUInt8(distVals);
                      if (dist > 0 && dist < closest) {
                          closest = dist;
                          closestId = id;
                      }
                  };
                  for (let i = 0; i < numPixels; i++) {
                      checkPixel(i);
                  }
                  if (closestId == -1)
                      return;
                  geomData = new Uint8Array(4);
                  passId = Math.floor(geomData[1] / 32);
              }
              this.geomDataRenderTarget.unbindForReading();
              const pass = this.__renderer.getPass(passId);
              if (!pass) {
                  console.warn('Geom data buffer returns invalid pass id:', passId);
                  return null;
              }
              const geomItemAndDist = pass.getGeomItemAndDist(geomData);
              if (geomItemAndDist) {
                  if (!geomItemAndDist.geomItem.isSelectable())
                      return null;
                  if (!pointerRay)
                      pointerRay = this.calcRayFromScreenPos(screenPos);
                  const intersectionPos = pointerRay.start.add(pointerRay.dir.scale(geomItemAndDist.dist));
                  this.intersectionData = new IntersectionData(screenPos, pointerRay, intersectionPos, geomData, geomItemAndDist);
              }
              return this.intersectionData;
          }
          return null;
      }
      /**
       * this method returns an object containing an array of geomitems, and an array of count values in
       * the form of a histogram. The results are sorted by count, so the first items are the most visible,
       * down to the least visible.
       * @param tl - The top left value of the rectangle.
       * @param br - The bottom right corner of the rectangle.
       * @return - The return value.
       */
      getGeomVisiblity(tl, br) {
          if (this.geomDataRenderTarget) {
              if (this.geomDataBufferInvalid) {
                  this.renderGeomDataFbo();
                  this.screenPos = null;
              }
              const gl = this.__renderer.gl;
              gl.finish();
              // Allocate a pixel block.
              const bufferWidth = this.geomDataRenderTarget.width;
              const bufferHeight = this.geomDataRenderTarget.height;
              const widthFactor = bufferWidth / this.width;
              const heightFactor = bufferHeight / this.height;
              const tlX = Math.round(tl.x * widthFactor);
              const tlY = Math.round(tl.y * heightFactor);
              const brX = Math.round(br.x * widthFactor);
              const brY = Math.round(br.y * heightFactor);
              const rectBottom = Math.round(bufferHeight - brY);
              const rectLeft = Math.round(tlX);
              const rectWidth = Math.round(brX - tlX);
              const rectHeight = Math.round(brY - tlY);
              const numPixels = rectWidth * rectHeight;
              this.geomDataRenderTarget.bindForReading();
              let geomDatas;
              if (this.__renderer.floatGeomBuffer) {
                  geomDatas = new Float32Array(4 * numPixels);
                  gl.readPixels(rectLeft, rectBottom, rectWidth, rectHeight, gl.RGBA, gl.FLOAT, geomDatas);
              }
              else {
                  geomDatas = new Uint8Array(4 * numPixels);
                  gl.readPixels(rectLeft, rectBottom, rectWidth, rectHeight, gl.RGBA, gl.UNSIGNED_BYTE, geomDatas);
              }
              this.geomDataRenderTarget.unbindForReading();
              const geomItems = [];
              const histogram = [];
              const keys = new Map();
              for (let i = 0; i < numPixels; i++) {
                  let passId;
                  const geomData = geomDatas.subarray(i * 4, (i + 1) * 4);
                  if (this.__renderer.floatGeomBuffer) {
                      if (geomData[3] == 0)
                          continue;
                      passId = Math.round(geomData[0]);
                  }
                  else {
                      if (geomData[0] == 0 && geomData[1] == 0)
                          continue;
                      passId = Math.floor(geomData[1] / 64);
                  }
                  const key = geomData[0] + '-' + geomData[1];
                  const index = keys.get(key);
                  if (index != undefined) {
                      histogram[index]++;
                      continue;
                  }
                  const geomItemAndDist = this.__renderer.getPass(passId)?.getGeomItemAndDist(geomData);
                  if (geomItemAndDist) {
                      keys.set(key, histogram.length);
                      histogram.push(1);
                      geomItems.push(geomItemAndDist.geomItem);
                  }
              }
              const indexArray = [];
              for (let i = 0; i < histogram.length; i++) {
                  indexArray[i] = i;
              }
              indexArray.sort((a, b) => {
                  return histogram[a] > histogram[b] ? -1 : 1;
              });
              return {
                  geomItems: indexArray.map((index) => geomItems[index]),
                  histogram: indexArray.map((index) => histogram[index]),
              };
          }
          return null;
      }
      /**
       * getGeomItemsInRect
       * Gathers all the geoms renders in a given rectangle of the viewport.
       * @param tl - The top left value of the rectangle.
       * @param br - The bottom right corner of the rectangle.
       * @return - The return value.
       */
      getGeomItemsInRect(tl, br) {
          const geomsInView = this.getGeomVisiblity(tl, br);
          const set = new Set();
          geomsInView.geomItems.forEach((geomItem) => {
              set.add(geomItem);
          });
          return set;
      }
      // ///////////////////////////
      // Events
      /**
       * Calculates the event coordinates relative to the viewport.
       * There could be multiple viewports connected to the current renderer.
       *
       * @param rendererX - The rendererX value
       * @param rendererY - The rendererY value
       * @return - Returns a new Vec2.
       * @private
       */
      __getPointerPos(rendererX, rendererY) {
          return new Vec2(rendererX - this.getPosX(), rendererY - this.getPosY());
      }
      /**
       * Prepares pointer event by adding properties of the engine to it.
       *
       * @param event - The event that occurs in the canvas
       * @private
       */
      prepareUIEvent(event) {
          event.viewport = this;
      }
      /**
       * Handler of the `pointerdown` event fired when the pointer device is initially pressed.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerDown(event) {
          this.prepareUIEvent(event);
          if (event instanceof ZeaMouseEvent) {
              event.pointerPos = this.__getPointerPos(event.rendererX, event.rendererY);
              event.pointerRay = this.calcRayFromScreenPos(event.pointerPos);
              event.intersectionData = this.getGeomDataAtPos(event.pointerPos, event.pointerRay, this.mousePointerSearchArea);
              // Cache Pointer Down for PointerClick
              this.pointerDownButton = event.button;
              this.pointerDownPos = event.pointerPos;
              this.pointerDownTime[event.button] = Date.now();
          }
          else if (event instanceof ZeaTouchEvent) {
              if (event.touches.length == 1) {
                  const touch = event.touches[0];
                  event.pointerPos = this.__getPointerPos(touch.rendererX, touch.rendererY);
                  event.pointerRay = this.calcRayFromScreenPos(event.pointerPos);
                  event.intersectionData = this.getGeomDataAtPos(event.pointerPos, event.pointerRay, this.touchPointerSearchArea);
                  // Cache Pointer Down for PointerClick
                  this.pointerDownButton = 0;
                  this.pointerDownPos = event.pointerPos;
                  this.pointerDownTime[0] = Date.now();
              }
          }
          if (event.propagating && event.getCapture()) {
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
              event.getCapture().onPointerDown(event);
          }
          if (event.propagating && event.intersectionData != undefined) {
              event.intersectionData.geomItem.onPointerDown(event);
          }
          if (event.propagating) {
              this.emit('pointerDown', event);
          }
          if (event.propagating && this.manipulator) {
              this.manipulator.onPointerDown(event);
          }
          // //////////////////////////////////
          // Start the long press timer
          if (this.longPressId != undefined)
              clearTimeout(this.longPressId);
          if (event instanceof ZeaMouseEvent || (event instanceof ZeaTouchEvent && event.changedTouches.length == 1)) {
              this.longPressId = setTimeout(() => {
                  this.longPressId = undefined;
                  event.propagating = true;
                  if (event.intersectionData && event.intersectionData.geomItem) {
                      event.intersectionData.geomItem.onPointerLongPress(event);
                  }
                  this.emit('pointerLongPress', event);
                  if (event.propagating && this.manipulator) {
                      this.manipulator.onPointerLongPress(event);
                  }
              }, this.longPressTime);
          }
      }
      /**
       * Causes an event to occur when a user releases a mouse button over a element.
       *
       * @param event - The event that occurs.
       */
      onPointerUp(event) {
          this.prepareUIEvent(event);
          if (event.pointerType === POINTER_TYPES.mouse) {
              const mouseEvent = event;
              mouseEvent.pointerPos = this.__getPointerPos(mouseEvent.rendererX, mouseEvent.rendererY);
              mouseEvent.pointerRay = this.calcRayFromScreenPos(mouseEvent.pointerPos);
              mouseEvent.intersectionData = this.getGeomDataAtPos(mouseEvent.pointerPos, mouseEvent.pointerRay, this.mousePointerSearchArea);
          }
          else if (event.pointerType === POINTER_TYPES.touch) {
              const touchEvent = event;
              if (touchEvent.changedTouches.length == 1) {
                  const touch = touchEvent.changedTouches[0];
                  touchEvent.pointerPos = this.__getPointerPos(touch.rendererX, touch.rendererY);
                  touchEvent.pointerRay = this.calcRayFromScreenPos(touchEvent.pointerPos);
                  touchEvent.intersectionData = this.getGeomDataAtPos(touchEvent.pointerPos, touchEvent.pointerRay, this.touchPointerSearchArea);
              }
          }
          // ///////////////////////////////////////
          // Clear Long Press
          if (this.longPressId != undefined)
              clearTimeout(this.longPressId);
          if (event.getCapture()) {
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
              event.getCapture().onPointerUp(event);
          }
          if (event.propagating && event.intersectionData != undefined) {
              event.intersectionData.geomItem.onPointerUp(event);
          }
          if (event.propagating) {
              this.emit('pointerUp', event);
          }
          if (event.propagating && this.manipulator) {
              this.manipulator.onPointerUp(event);
          }
          // //////////////////////////////////////
          // Detect a Pointer Click
          // Generate a pointer click if we detect a pointerDown and a pointerUp in the
          // same location.
          const button = event instanceof ZeaMouseEvent ? event.button : 0;
          const pointerUpTime = Date.now();
          if ((event instanceof ZeaMouseEvent || (event instanceof ZeaTouchEvent && event.changedTouches.length == 1)) &&
              pointerUpTime - this.pointerDownTime[button] < this.clickTime &&
              event.pointerPos.distanceTo(this.pointerDownPos) < this.pointerClickTolerance &&
              this.pointerDownButton == button) {
              const clickTime = pointerUpTime;
              event.propagating = true;
              // Emit a double click if this is a second click.
              if (button == this.prevClickButton && clickTime - this.prevClickTime < this.doubleClickTime) {
                  if (event.intersectionData && event.intersectionData.geomItem) {
                      event.intersectionData.geomItem.onPointerDoubleClick(event);
                  }
                  if (event.propagating && event.propagating) {
                      this.emit('pointerDoubleClick', event);
                  }
                  if (event.propagating && this.manipulator) {
                      this.manipulator.onPointerDoubleClick(event);
                  }
              }
              else {
                  this.prevClickButton = button;
                  this.prevClickPos = event.pointerPos;
                  this.prevClickTime = clickTime;
                  if (event.intersectionData && event.intersectionData.geomItem) {
                      event.intersectionData.geomItem.onPointerClick(event);
                  }
                  if (event.propagating) {
                      this.emit('pointerClick', event);
                  }
                  if (event.propagating && this.manipulator) {
                      this.manipulator.onPointerClick(event);
                  }
              }
          }
          // //////////////////////////////////////
      }
      /**
       * Causes an event to occur when the pointer device is moving.
       *
       * @param event - The event that occurs.
       */
      onPointerMove(event) {
          this.prepareUIEvent(event);
          if (event.pointerType === POINTER_TYPES.mouse) {
              const mouseEvent = event;
              const pointerPos = this.__getPointerPos(mouseEvent.rendererX, mouseEvent.rendererY);
              mouseEvent.pointerPos = pointerPos;
              mouseEvent.pointerRay = this.calcRayFromScreenPos(pointerPos);
          }
          else if (event.pointerType === POINTER_TYPES.touch) {
              const touchEvent = event;
              for (let index = 0; index < touchEvent.touches.length; index++) {
                  const touch = touchEvent.touches[index];
                  touch.touchPos = this.__getPointerPos(touch.rendererX, touch.rendererY);
                  touch.touchRay = this.calcRayFromScreenPos(touch.touchPos);
              }
              touchEvent.pointerPos = touchEvent.touches[0].touchPos;
              touchEvent.pointerRay = touchEvent.touches[0].touchRay;
          }
          // Clear the long press timer if the pointer moves too far.
          if (this.longPressId != undefined &&
              event.pointerPos.distanceTo(this.pointerDownPos) > this.pointerClickTolerance) {
              clearTimeout(this.longPressId);
              this.longPressId = undefined;
          }
          // Note: the Captured item might be a tool, which might not need to have
          // the geom under the pointer. e.g. the CameraManipulator during a drag.
          if (event.getCapture()) {
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
              event.getCapture().onPointerMove(event);
          }
          event.intersectionData = this.getGeomDataAtPos(event.pointerPos, event.pointerRay, this.mousePointerSearchArea);
          if (event.propagating && event.intersectionData) {
              if (event.intersectionData.geomItem != this.pointerOverItem) {
                  if (this.pointerOverItem) {
                      event.leftGeometry = this.pointerOverItem;
                      this.pointerOverItem.onPointerLeave(event);
                      if (event.propagating) {
                          this.emit('pointerLeaveGeom', event);
                      }
                  }
                  event.propagating = true;
                  this.pointerOverItem = event.intersectionData.geomItem;
                  this.pointerOverItem.onPointerEnter(event);
                  if (event.propagating) {
                      this.emit('pointerOverGeom', event);
                  }
              }
              event.propagating = true;
              event.intersectionData.geomItem.onPointerMove(event);
          }
          else if (event.propagating && this.pointerOverItem) {
              event.leftGeometry = this.pointerOverItem;
              this.pointerOverItem.onPointerLeave(event);
              this.pointerOverItem = null;
              this.emit('pointerLeaveGeom', event);
          }
          if (event.propagating) {
              this.emit('pointerMove', event);
          }
          if (event.propagating && this.manipulator) {
              this.manipulator.onPointerMove(event);
          }
      }
      /**
       * Causes an event to occur when the mouse pointer is moved into this viewport
       * @param event - The event that occurs.
       */
      onPointerEnter(event) {
          this.prepareUIEvent(event);
          this.emit('pointerEnter', event);
          if (event.propagating && this.manipulator && this.manipulator.onPointerEnter) {
              this.manipulator.onPointerEnter(event);
          }
      }
      /**
       * Causes an event to occur when the mouse pointer is moved out of this viewport
       * @param event - The event that occurs.
       */
      onPointerLeave(event) {
          this.prepareUIEvent(event);
          this.emit('pointerLeave', event);
          if (!event.propagating)
              return;
          if (this.manipulator && this.manipulator.onPointerLeave) {
              this.manipulator.onPointerLeave(event);
              if (!event.propagating)
                  return;
          }
      }
      /**
       * Causes an event to occur when the user is pressing a key on the keyboard.
       * @param event - The event that occurs.
       */
      onKeyDown(event) {
          this.prepareUIEvent(event);
          if (this.manipulator) {
              this.manipulator.onKeyDown(event);
              if (!event.propagating)
                  return;
          }
          this.emit('keyDown', event);
      }
      /**
       * Causes an event to occur  when the user releases a key on the keyboard.
       * @param event - The event that occurs.
       */
      onKeyUp(event) {
          this.prepareUIEvent(event);
          if (this.manipulator) {
              this.manipulator.onKeyUp(event);
              if (!event.propagating)
                  return;
          }
          this.emit('keyUp', event);
      }
      /**
       * Causes an event to occur when the mouse wheel is rolled up or down over an element.
       * @param event - The event that occurs.
       */
      onWheel(event) {
          this.prepareUIEvent(event);
          event.pointerPos = this.__getPointerPos(event.rendererX, event.rendererY);
          event.pointerRay = this.calcRayFromScreenPos(event.pointerPos);
          event.intersectionData = this.getGeomDataAtPos(event.pointerPos, event.pointerRay, this.mousePointerSearchArea);
          if (event.intersectionData != undefined) {
              event.intersectionData.geomItem.onWheel(event);
              if (!event.propagating)
                  return;
          }
          if (this.manipulator) {
              this.manipulator.onWheel(event);
              return;
          }
          this.emit('mouseWheel', event);
      }
      // Touch events
      /**
       * Causes an event to occur when the touch event gets interrupted.
       * @param event - The event that occurs.
       */
      onTouchCancel(event) {
          this.prepareUIEvent(event);
          if (event.getCapture()) {
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
              event.getCapture().onTouchCancel(event);
              if (!event.propagating)
                  return;
          }
          if (this.manipulator) {
              this.manipulator.onTouchCancel(event);
              if (!event.propagating)
                  return;
          }
          this.emit('touchCancel', event);
      }
      // //////////////////////////
      // Rendering
      /**
       * The bindGLViewport method.
       * @param renderstate - The object tracking the current state of the renderer
       * @private
       */
      bindGLViewport(renderstate) {
          // console.log(this.viewMatrix.toString())
          renderstate.viewXfo = this.cameraXfo;
          renderstate.viewScale = 1.0;
          renderstate.region = this.region;
          renderstate.depthRange = this.depthRange;
          renderstate.cameraMatrix = this.cameraMat;
          renderstate.viewport = this;
          const gl = this.__renderer.gl;
          renderstate.bindRendererUnifs = (unifs) => {
              const { cameraMatrix, viewMatrix, projectionMatrix, eye, isOrthographic, viewportFrustum } = unifs;
              if (cameraMatrix) {
                  gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
              }
              if (viewMatrix) {
                  gl.uniformMatrix4fv(viewMatrix.location, false, this.viewMatrix.asArray());
              }
              if (projectionMatrix) {
                  gl.uniformMatrix4fv(projectionMatrix.location, false, this.projectionMatrix.asArray());
              }
              if (eye) {
                  // for monocular rendering, we just render viewport 0
                  gl.uniform1i(eye.location, 0);
              }
              if (isOrthographic) {
                  // Left or right eye, when rendering stereo VR.
                  gl.uniform1i(isOrthographic.location, this.camera.isOrthographic() ? 1 : 0);
              }
              if (viewportFrustum && this.viewportFrustum) {
                  // Left or right eye, when rendering stereo VR.
                  gl.uniform4f(viewportFrustum.location, this.viewportFrustum.x, this.viewportFrustum.y, this.viewportFrustum.z, this.viewportFrustum.w);
              }
          };
          renderstate.bindViewports = (unifs, draw) => draw();
      }
      /**
       * The draw method.
       */
      draw(renderstate) {
          // Turn this on to debug the geom data buffer.
          if (this.debugGeomDataBuffer) {
              this.renderGeomDataFbo();
              const gl = this.__renderer.gl;
              gl.viewport(this.region[0], this.region[1], this.region[2], this.region[3]);
              const bg = this.backgroundColorParam.value.asArray();
              gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
              // Note: renderGeomDataFbo would have bound other shaders.
              // and the renderstate used above is no longer valid. Reset.
              const renderstate = new ColorRenderState(this.__renderer.gl);
              const screenQuad = this.__renderer.screenQuad;
              screenQuad.bindShader(renderstate);
              screenQuad.draw(renderstate, this.geomDataRenderTarget.textureTargets[0]);
              return;
          }
          const gl = this.__renderer.gl;
          this.bindGLViewport(renderstate);
          renderstate.pushGLStack('GLViewport.draw');
          renderstate.glDisable(gl.BLEND);
          renderstate.glEnable(gl.DEPTH_TEST);
          renderstate.glEnable(gl.CULL_FACE);
          gl.viewport(this.region[0], this.region[1], this.region[2], this.region[3]);
          const bg = this.backgroundColorParam.value.asArray();
          gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
          gl.colorMask(true, true, true, true);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          super.draw(renderstate);
          renderstate.popGLStack();
          // Rendering of the GeomData buffer should always occur after a regular draw,
          // as Shaders, Materials and Geometries should be bound first duriing
          // a regular draw.
          if (this.geomDataBufferInvalid && !this.geomDataBufferRendered) {
              // Initialize the GeomData buffer by renderring it once.
              this.renderGeomDataFbo();
              this.geomDataBufferRendered = true;
          }
          if (this.debugHighlightedGeomsBuffer) {
              // Note: renderGeomDataFbo would have bound other shaders.
              // and the renderstate used above is no blonger valid. Reset.
              const renderstate = new ColorRenderState(this.__renderer.gl);
              const screenQuad = this.__renderer.screenQuad;
              screenQuad.bindShader(renderstate);
              screenQuad.draw(renderstate, this.highlightedGeomsBufferFbo.textureTargets[0]);
          }
          if (this.debugOcclusionBuffer) {
              renderstate.pushGLStack('debugOcclusionBuffer');
              // @ts-ignore
              const occlusionDataBuffer = this.__renderer.glGeomItemLibrary.occlusionDataBuffer;
              const gl = this.__renderer.gl;
              renderstate.glEnable(gl.BLEND);
              renderstate.glDisable(gl.DEPTH_TEST);
              gl.blendEquation(gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
              const screenQuad = this.__renderer.screenQuad;
              screenQuad.bindShader(renderstate);
              screenQuad.draw(renderstate, occlusionDataBuffer.textureTargets[0]);
              renderstate.popGLStack();
          }
          if (this.debugReductionBuffer) {
              // @ts-ignore
              const reductionDataBuffer = this.__renderer.glGeomItemLibrary.reductionDataBuffer;
              const screenQuad = this.__renderer.screenQuad;
              screenQuad.bindShader(renderstate);
              const imageInif = renderstate.unifs.image;
              reductionDataBuffer.bindColorTexture(renderstate, imageInif);
              const gl = this.__renderer.gl;
              gl.uniform1i(renderstate.unifs.isTextured.location, 1);
              gl.enable(gl.BLEND);
              gl.blendEquation(gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
              screenQuad.draw(renderstate, null);
              gl.disable(gl.BLEND);
          }
      }
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto$1.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  var frag$i = "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D image;\nuniform vec4 color;\nuniform int isTextured;\n\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  if (isTextured != 0)\n    fragColor = texture2D(image, v_texCoord);\n  else \n    fragColor = color;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$j = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * abs(size) * 2.0), 0.0, 1.0);\n  if (size.x < 0.0)\n    v_texCoord.x = 1.0 - v_texCoord.x;\n  if (size.y < 0.0)\n    v_texCoord.y = 1.0 - v_texCoord.y;\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class ScreenQuadShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'ScreenQuadShader');
          this.setShaderStage('VERTEX_SHADER', vert$j);
          this.setShaderStage('FRAGMENT_SHADER', frag$i);
      }
  }

  /** Class representing a GL screen quad.
   * @private
   */
  class GLScreenQuad {
      __gl;
      __pos;
      __size;
      flipY;
      __glshader;
      __quadBinding; // GeomShaderBinding | VAOGeomShaderBinding
      ready;
      /**
       * Create a GL screen quad.
       * @param gl - The webgl rendering context.
       * @param directives - GLSL shader directives
       */
      constructor(gl, directives) {
          this.__gl = gl;
          this.__pos = [0.0, 0.0];
          this.__size = [1.0, 1.0];
          this.flipY = true;
          this.__glshader = new ScreenQuadShader(gl);
          if (!gl.__quadVertexIdsBuffer)
              gl.setupInstancedQuad();
          const shaderComp = this.__glshader.compileForTarget('GLScreenQuad', directives);
          this.__quadBinding = generateShaderGeomBinding(this.__gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
          this.ready = true;
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param textureOrColor - The texture or color value.
       * @param pos - The pos value.
       * @param size - The size value.
       */
      bind(renderstate, textureOrColor, pos, size) {
          const unifs = renderstate.unifs;
          const gl = this.__gl;
          if (textureOrColor instanceof GLTexture2D) {
              gl.uniform1i(unifs.isTextured.location, 1);
              textureOrColor.bindToUniform(renderstate, renderstate.unifs.image);
          }
          else if (textureOrColor instanceof WebGLTexture) {
              gl.uniform1i(unifs.isTextured.location, 1);
              const unit = renderstate.boundTextures++;
              gl.activeTexture(gl.TEXTURE0 + unit);
              gl.bindTexture(gl.TEXTURE_2D, textureOrColor);
              gl.uniform1i(unifs.image.location, unit);
          }
          else if (textureOrColor && textureOrColor instanceof Color) {
              gl.uniform1i(unifs.isTextured.location, 0);
              gl.uniform4fv(unifs.color.location, textureOrColor.asArray());
          }
          {
              const unif = unifs.pos;
              if (unif) {
                  let list = pos ? (pos instanceof Vec2 ? pos.asArray() : pos) : this.__pos;
                  gl.uniform2fv(unif.location, list);
              }
          }
          {
              const unif = unifs.size;
              if (unif) {
                  let list = size ? (size instanceof Vec2 ? size.asArray() : size) : this.__size;
                  gl.uniform2fv(unif.location, list);
              }
          }
          this.__quadBinding.bind(renderstate);
      }
      /**
       * The bindShader method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      bindShader(renderstate) {
          return this.__glshader.bind(renderstate, 'GLScreenQuad');
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param textureOrColor - The texture or color value.
       * @param pos - The pos value.
       * @param size - The size value.
       */
      draw(renderstate, textureOrColor, pos, size) {
          this.bind(renderstate, textureOrColor, pos, size);
          const gl = this.__gl;
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
      }
  }

  class ParamUniformBinding extends BaseClass {
      unif;
      dirty = false;
      constructor(unif) {
          super();
          this.unif = unif;
      }
      /**
       * The unbind method.
       */
      bind(renderstate) { }
      /**
       * The unbind method.
       */
      unbind(renderstate) { }
      /**
       * The destroy method.
       */
      destroy() { }
  }
  class Sampler2DBinding extends ParamUniformBinding {
      boundImage;
      textureType;
      textureTypeUnif;
      dirty = false;
      param;
      texBinding;
      gltexture = null;
      constructor(gl, glMaterial, param, textureUnif, unifs) {
          super(textureUnif);
          const name = param.getName();
          this.param = param;
          // this.textureUnif = textureUnif
          this.textureTypeUnif = unifs[name + 'Type'];
          const genGLTex = (image) => {
              let gltexture = GLTexture2D.getCachedGLTexture2D(image);
              const textureType = 1;
              if (!gltexture) {
                  if (image.type === 'HDR') {
                      gltexture = new GLHDRImage(gl, image);
                  }
                  else {
                      gltexture = new GLTexture2D(gl, image);
                  }
                  GLTexture2D.setCachedGLTexture2D(image, gltexture);
              }
              this.texBinding = gltexture.preBind(this.unif, unifs);
              gltexture.on('updated', () => {
                  glMaterial.emit('updated');
              });
              this.gltexture = gltexture;
              this.gltexture.addRef(this);
              this.textureType = textureType;
              glMaterial.emit('updated');
          };
          let imageLoadedId;
          const connectImage = (image) => {
              if (!image.isLoaded()) {
                  imageLoadedId = image.on('loaded', () => {
                      genGLTex(this.boundImage);
                  });
              }
              else {
                  genGLTex(image);
              }
              this.boundImage = image;
          };
          const disconnectImage = () => {
              const gltexture = GLTexture2D.getCachedGLTexture2D(this.boundImage);
              gltexture.removeRef(this);
              this.texBinding = null;
              this.gltexture = null;
              this.textureType = -1;
              if (imageLoadedId) {
                  this.boundImage.off('loaded', imageLoadedId);
              }
              this.boundImage = null;
              imageLoadedId = null;
              glMaterial.emit('updated');
          };
          if (param.getImage())
              connectImage(param.getImage());
          param.on('textureConnected', () => {
              connectImage(param.getImage());
          });
          param.on('textureDisconnected', () => {
              disconnectImage();
          });
          this.dirty = true;
          param.on('valueChanged', () => {
              this.dirty = true;
              glMaterial.emit('updated');
          });
      }
      /**
       * The unbind method.
       */
      bind(renderstate) {
          if (this.gltexture)
              this.gltexture.bindToUniform(renderstate, this.unif, this.texBinding);
      }
  }
  /** Class representing simple uniform binding.
   * @private
   */
  class SimpleUniformBinding extends ParamUniformBinding {
      param;
      textureUnif;
      textureTypeUnif;
      texBinding;
      gltexture = null;
      textureType = -1;
      val;
      uniform1i;
      uniformXX;
      update;
      /**
       * Create simple uniform binding.
       * @param gl - The webgl rendering context.
       * @param glMaterial - The glMaterial value.
       * @param param - The param value.
       * @param unif - The WebGL uniform
       * @param unifs - The dictionary of WebGL uniforms.
       */
      constructor(gl, glMaterial, param, unif, unifs) {
          super(unif);
          const name = param.getName();
          this.param = param;
          this.unif = unif;
          this.textureUnif = unifs[name + 'Tex'];
          this.textureTypeUnif = unifs[name + 'TexType'];
          this.uniform1i = gl.uniform1i.bind(gl);
          switch (this.unif.glslType) {
              case 'bool':
                  // gl.uniform1ui(unif.location, value);// WebGL 2
                  this.uniformXX = gl.uniform1i.bind(gl);
                  break;
              case 'uint':
                  if (gl.name == 'webgl2')
                      this.uniformXX = gl.uniform1ui.bind(gl);
                  else
                      this.uniformXX = gl.uniform1i.bind(gl);
                  break;
              case 'int':
                  this.uniformXX = gl.uniform1i.bind(gl);
                  break;
              case 'float':
                  this.uniformXX = gl.uniform1f.bind(gl);
                  break;
          }
          this.bind = this.bindValue;
          const genGLTex = (image) => {
              let gltexture = GLTexture2D.getCachedGLTexture2D(image);
              const textureType = 1;
              if (!gltexture) {
                  if (image.type === 'HDR') {
                      gltexture = new GLHDRImage(gl, image);
                  }
                  else {
                      gltexture = new GLTexture2D(gl, image);
                  }
                  GLTexture2D.setCachedGLTexture2D(image, gltexture);
              }
              this.texBinding = gltexture.preBind(this.textureUnif, unifs);
              gltexture.on('updated', () => {
                  glMaterial.emit('updated');
              });
              this.gltexture = gltexture;
              this.gltexture.addRef(this);
              this.textureType = textureType;
              this.bind = this.bindTexture;
              glMaterial.emit('updated');
          };
          let boundImage;
          let imageLoadedId;
          this.update = () => {
              try {
                  // Sometimes the value of a color param is an image.
                  if (boundImage) {
                  }
                  else {
                      if (typeof param.value == 'boolean') {
                          this.val = param.value ? 1 : 0;
                      }
                      else
                          this.val = param.value;
                  }
              }
              catch (e) { }
              glMaterial.emit('updated');
          };
          /**
           * The update method.
           */
          if (this.textureUnif && param instanceof MaterialFloatParam) {
              const connectImage = (image) => {
                  if (!image.isLoaded()) {
                      imageLoadedId = image.on('loaded', () => {
                          genGLTex(boundImage);
                      });
                  }
                  else {
                      genGLTex(image);
                  }
                  boundImage = image;
              };
              const disconnectImage = () => {
                  const gltexture = GLTexture2D.getCachedGLTexture2D(boundImage);
                  gltexture.removeRef(this);
                  this.texBinding = null;
                  this.gltexture = null;
                  this.textureType = -1;
                  this.bind = this.bindValue;
                  if (imageLoadedId) {
                      boundImage.off('loaded', imageLoadedId);
                  }
                  boundImage = null;
                  imageLoadedId = null;
                  glMaterial.emit('updated');
              };
              if (param.getImage())
                  connectImage(param.getImage());
              param.on('textureConnected', () => {
                  connectImage(param.getImage());
              });
              param.on('textureDisconnected', () => {
                  disconnectImage();
              });
          }
          this.dirty = true;
          param.on('valueChanged', () => {
              this.dirty = true;
              glMaterial.emit('updated');
          });
      }
      /**
       * The bindValue method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindValue(renderstate) {
          if (this.dirty) {
              this.update();
              this.dirty = false;
          }
          if (this.unif)
              this.uniformXX(this.unif.location, this.val);
          if (this.textureTypeUnif)
              this.uniform1i(this.textureTypeUnif.location, 0);
      }
      /**
       * The bindTexture method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindTexture(renderstate) {
          if (this.dirty) {
              this.update();
              this.dirty = false;
          }
          this.gltexture.bindToUniform(renderstate, this.textureUnif, this.texBinding);
      }
  }
  /** Class representing complex uniform binding.
   * @private
   */
  class ComplexUniformBinding extends ParamUniformBinding {
      param;
      values;
      uniformXX;
      /**
       * Create complex uniform binding.
       * @param gl - The webgl rendering context.
       * @param glMaterial - The glMaterial value.
       * @param param - The param value.
       * @param unif - The WebGL uniform
       */
      constructor(gl, glMaterial, param, unif) {
          super(unif);
          this.param = param;
          switch (this.unif.glslType) {
              case 'vec2':
                  this.uniformXX = gl.uniform2fv.bind(gl);
                  break;
              case 'vec3':
                  this.uniformXX = gl.uniform3fv.bind(gl);
                  break;
              case 'vec4':
                  this.uniformXX = gl.uniform4fv.bind(gl);
                  break;
          }
          this.dirty = true;
          param.on('valueChanged', () => {
              this.dirty = true;
              glMaterial.emit('updated');
          });
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bind(renderstate) {
          if (this.dirty) {
              this.values = this.param.value.asArray();
              this.dirty = false;
          }
          this.uniformXX(this.unif.location, this.values);
      }
      /**
       * The unbind method.
       */
      unbind() { }
      /**
       * The destroy method.
       */
      destroy() { }
  }
  /** Class representing material uniform binding.
   * @private
   */
  class MatrixUniformBinding extends ParamUniformBinding {
      param;
      uniformMatrixXXX;
      values = [];
      /**
       * Create material uniform binding.
       * @param gl - The webgl rendering context.
       * @param glMaterial - The glMaterial value.
       * @param param - The param value.
       * @param unif - The WebGL uniform
       */
      constructor(gl, glMaterial, param, unif) {
          super(unif);
          this.param = param;
          switch (this.unif.glslType) {
              case 'mat3':
                  this.uniformMatrixXXX = gl.uniformMatrix3fv.bind(gl);
                  break;
              case 'mat4':
                  this.uniformMatrixXXX = gl.uniformMatrix4fv.bind(gl);
                  break;
          }
          this.dirty = true;
          param.on('valueChanged', () => {
              this.dirty = true;
              glMaterial.emit('updated');
          });
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bind(renderstate) {
          if (this.dirty) {
              this.values = this.param.value.asArray();
              this.dirty = false;
          }
          this.uniformMatrixXXX(this.unif.location, false, this.values);
      }
      /**
       * The unbind method.
       */
      unbind() { }
      /**
       * The destroy method.
       */
      destroy() { }
  }
  /** Class representing color uniform binding.
   * @private
   */
  class ColorUniformBinding extends ParamUniformBinding {
      param;
      textureUnif;
      textureTypeUnif;
      values = [];
      gltexture;
      textureType;
      texBinding;
      uniform1i;
      uniform4fv;
      update;
      /**
       * Create color uniform binding.
       * @param gl - The webgl rendering context.
       * @param glMaterial - The glMaterial value.
       * @param param - The param value.
       * @param unif - The WebGL uniform
       * @param unifs - The dictionary of WebGL uniforms.
       */
      constructor(gl, glMaterial, param, unif, unifs) {
          super(unif);
          const name = param.getName();
          this.param = param;
          this.textureUnif = unifs[name + 'Tex'];
          this.textureTypeUnif = unifs[name + 'TexType'];
          this.values = [0, 0, 0, 0];
          this.bind = this.bindValue;
          let boundImage;
          let imageLoadedId;
          this.update = () => {
              try {
                  // Sometimes the value of a color param is an image.
                  if (boundImage) {
                  }
                  else if (this.unif) {
                      if (param instanceof MaterialColorParam && param.colorSpace == exports.ColorSpace.Gamma) {
                          this.values = param.value.toLinear().asArray();
                      }
                      else {
                          this.values = param.value.asArray();
                      }
                  }
              }
              catch (e) { }
              glMaterial.emit('updated');
          };
          /**
           * The update method.
           */
          if (this.textureUnif && param instanceof MaterialColorParam) {
              const genGLTex = (image) => {
                  boundImage = image;
                  let gltexture = GLTexture2D.getCachedGLTexture2D(image);
                  const textureType = 1;
                  if (!gltexture) {
                      if (image.type === 'FLOAT') {
                          gltexture = new GLHDRImage(gl, image);
                      }
                      else {
                          gltexture = new GLTexture2D(gl, image);
                      }
                      GLTexture2D.setCachedGLTexture2D(image, gltexture);
                  }
                  this.texBinding = gltexture.preBind(this.textureUnif, unifs);
                  gltexture.on('updated', () => {
                      glMaterial.emit('updated');
                  });
                  this.gltexture = gltexture;
                  this.gltexture.addRef(this);
                  this.textureType = textureType;
                  this.bind = this.bindTexture;
                  glMaterial.emit('updated');
              };
              const connectImage = (image) => {
                  if (!image.isLoaded()) {
                      imageLoadedId = image.once('loaded', () => {
                          genGLTex(image);
                      });
                  }
                  else {
                      genGLTex(image);
                  }
              };
              const disconnectImage = () => {
                  this.gltexture.removeRef(this);
                  this.gltexture = null;
                  this.texBinding = null;
                  this.textureType = null;
                  if (imageLoadedId) {
                      boundImage.off('loaded', imageLoadedId);
                  }
                  this.bind = this.bindValue;
                  boundImage = null;
                  imageLoadedId = null;
                  glMaterial.emit('updated');
              };
              if (param.getImage())
                  connectImage(param.getImage());
              param.on('textureConnected', () => {
                  connectImage(param.getImage());
              });
              param.on('textureDisconnected', () => {
                  disconnectImage();
              });
          }
          this.dirty = true;
          param.on('valueChanged', () => {
              this.dirty = true;
          });
          this.uniform1i = gl.uniform1i.bind(gl);
          this.uniform4fv = gl.uniform4fv.bind(gl);
      }
      /**
       * The bindValue method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindValue(renderstate) {
          if (!this.unif)
              return; // Note: Normals parms have no unif and can only be bound to a texture.
          if (this.dirty) {
              this.update();
              this.dirty = false;
          }
          if (this.unif)
              this.uniform4fv(this.unif.location, this.values);
          if (this.textureTypeUnif)
              this.uniform1i(this.textureTypeUnif.location, 0);
      }
      /**
       * The bindTexture method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindTexture(renderstate) {
          if (this.dirty) {
              this.update();
              this.dirty = false;
          }
          this.gltexture.bindToUniform(renderstate, this.textureUnif, this.texBinding);
      }
  }
  /** Class representing material shader binding.
   * @private
   */
  class MaterialShaderBinding {
      uniformBindings = [];
      /**
       * Create material shader binding.
       * @param gl - The webgl rendering context.
       * @param glMaterial - The glMaterial value.
       * @param unifs - The dictionary of WebGL uniforms.
       * @param warnMissingUnifs - The warnMissingUnifs value.
       */
      constructor(gl, glMaterial, unifs, warnMissingUnifs) {
          const bindParam = (param) => {
              const name = param.getName();
              const unif = unifs[name];
              if (unif) {
                  // Note:
                  switch (unif.glslType) {
                      case 'bool':
                      case 'uint':
                      case 'int':
                      case 'float':
                          this.uniformBindings.push(new SimpleUniformBinding(gl, glMaterial, param, unif, unifs));
                          break;
                      case 'vec2':
                      case 'vec3':
                      case 'vec4':
                          this.uniformBindings.push(new ComplexUniformBinding(gl, glMaterial, param, unif));
                          break;
                      case 'color':
                          this.uniformBindings.push(new ColorUniformBinding(gl, glMaterial, param, unif, unifs));
                          break;
                      case 'mat4':
                          this.uniformBindings.push(new MatrixUniformBinding(gl, glMaterial, param, unif));
                          break;
                      default:
                          console.warn('Param :' + name + ' has unhandled data type:' + unif.glslType);
                          return;
                  }
              }
              else {
                  const textureUnif = unifs[name + 'Tex'];
                  if (textureUnif &&
                      textureUnif.glslType == 'sampler2D' &&
                      (param instanceof MaterialColorParam || param instanceof MaterialFloatParam) &&
                      param.getImage()) {
                      if (textureUnif && textureUnif.glslType == 'sampler2D') {
                          this.uniformBindings.push(new Sampler2DBinding(gl, glMaterial, param, textureUnif, unifs));
                      }
                  }
              }
          };
          const params = glMaterial.material.getParameters();
          for (const param of params) {
              bindParam(param);
          }
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      bind(renderstate) {
          for (const uniformBinding of this.uniformBindings) {
              uniformBinding.bind(renderstate);
          }
          return true;
      }
      /**
       * The unbind method.
       */
      unbind(renderstate) {
          for (const uniformBinding of this.uniformBindings) {
              uniformBinding.unbind(renderstate);
          }
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          for (const uniformBinding of this.uniformBindings) {
              uniformBinding.destroy();
          }
      }
  }

  /** Class representing a GL material.
   * @extends EventEmitter
   * @private
   */
  class GLMaterial extends EventEmitter {
      gl;
      material;
      glShader;
      shaderBindings;
      boundTexturesBeforeMaterial;
      /**
       * Create a GL material.
       * @param gl - The webgl rendering context.
       * @param material - The material value.
       * @param glShader - The glShader value.
       */
      constructor(gl, material, glShader) {
          super();
          this.gl = gl;
          this.material = material;
          this.glShader = glShader;
          this.shaderBindings = {};
          material.on('parameterValueChanged', () => this.emit('updated'));
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param warnMissingUnifs - The renderstate value.
       */
      bind(renderstate, warnMissingUnifs) {
          this.boundTexturesBeforeMaterial = renderstate.boundTextures;
          let shaderBinding = this.shaderBindings[renderstate.shaderkey];
          if (!shaderBinding) {
              const gl = this.gl;
              shaderBinding = new MaterialShaderBinding(gl, this, renderstate.unifs, warnMissingUnifs);
              this.shaderBindings[renderstate.shaderkey] = shaderBinding;
          }
          shaderBinding.bind(renderstate);
      }
      /**
       * The unbind method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      unbind(renderstate) {
          // Enable texture units to be re-used by resetting the count back
          // to what it was.
          // Note: we don't need to unbind each texture, as re-binding a new material
          // will overwrite the bindings made by this material.
          renderstate.boundTextures = this.boundTexturesBeforeMaterial;
      }
  }

  /** Class representing a GL CAD material library.
   * @ignore
   */
  class GLMaterialLibrary extends EventEmitter {
      renderer;
      materials = [];
      materialBindings = new Map();
      freeIndices = [];
      dirtyIndices = new Set();
      materialsAllocator = new Allocator1D();
      materialsTexture;
      /**
       * Create a GL CAD material library.
       * @param renderer - The renderer object
       */
      constructor(renderer) {
          super();
          this.renderer = renderer;
          this.materialsAllocator.on('dataReallocated', (event) => {
              // during allocation, a defragment might occur, which means
              // we need to re-upload some of our data.
              const id = event.id;
              this.dirtyIndices.add(id);
          });
      }
      /**
       * The addMaterial method.
       * @param material - The material object.
       * @return - The index of GLMaterial
       */
      addMaterial(material) {
          const binding = this.materialBindings.get(material);
          if (binding != undefined) {
              // Increment the ref count for the Material
              binding.refCount++;
              return binding.index;
          }
          const index = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.materials.length;
          this.materials[index] = material;
          const listenerIDs = {};
          const matData = material.getShaderClass().getPackedMaterialData(material);
          this.materialsAllocator.allocate(index, matData.length / 4);
          const parameterValueChanged = () => {
              this.dirtyIndices.add(index);
              this.emit('updated');
          };
          listenerIDs['parameterValueChanged'] = material.on('parameterValueChanged', parameterValueChanged);
          this.materialBindings.set(material, { index, refCount: 1, listenerIDs });
          this.dirtyIndices.add(index);
          return index;
      }
      /**
       * Given a material, generates a GLMaterial that manages the GPU state for the material.
       * @param material - The material value.
       * @return - The constructed GLMaterial.
       */
      getGLMaterial(material) {
          this.addMaterial(material);
          const binding = this.materialBindings.get(material);
          if (binding.glMaterial)
              return binding.glMaterial;
          const glShader = this.renderer.getOrCreateShader(material.getShaderName());
          const gl = this.renderer.gl;
          const glMaterial = new GLMaterial(gl, material, glShader);
          binding.listenerIDs['updated'] = glMaterial.on('updated', () => {
              this.renderer.requestRedraw();
          });
          binding.glMaterial = glMaterial;
          return glMaterial;
      }
      getMaterialAllocation(material) {
          const binding = this.materialBindings.get(material);
          if (binding != undefined) {
              return this.materialsAllocator.getAllocation(binding.index);
          }
          return undefined;
      }
      /**
       * The removeMaterial method.
       * @param material - The material object.
       */
      removeMaterial(material) {
          const binding = this.materialBindings.get(material);
          binding.refCount--;
          // If there are still refs to this geom. (GeomItems that use it)
          // then we keep it in the renderer.
          if (binding.refCount > 0) {
              return;
          }
          this.freeIndices.push(binding.index);
          this.materialsAllocator.deallocate(binding.index);
          this.materials[binding.index] = null;
          this.materialBindings.delete(material);
          if (binding.listenerIDs['updated'] && binding.glMaterial) {
              binding.glMaterial.off('updated', binding.listenerIDs['updated']);
          }
          if (binding.listenerIDs['parameterValueChanged']) {
              material.off('parameterValueChanged', binding.listenerIDs['parameterValueChanged']);
          }
          if (this.dirtyIndices.has(binding.index)) {
              this.dirtyIndices.delete(binding.index);
          }
      }
      /**
       * The uploadMaterials method.
       * @param renderstate - The render state for the current draw traversal
       */
      uploadMaterials(renderstate) {
          const gl = this.renderer.__gl;
          const materialsTextureSize = MathFunctions.nextPow2(Math.ceil(Math.sqrt(this.materialsAllocator.reservedSpace)));
          const unit = renderstate.boundTextures++;
          gl.activeTexture(gl.TEXTURE0 + unit);
          if (!this.materialsTexture) {
              this.materialsTexture = new GLTexture2D(this.renderer.__gl, {
                  format: 'RGBA',
                  type: 'FLOAT',
                  width: materialsTextureSize,
                  height: materialsTextureSize,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  mipMapped: false,
              });
              this.materialsTexture.clear();
          }
          else if (this.materialsTexture.width < materialsTextureSize) {
              this.materialsTexture.resize(materialsTextureSize, materialsTextureSize);
              for (let i = 0; i < this.materials.length; i++) {
                  if (this.materialsAllocator.getAllocation(i)) {
                      this.dirtyIndices.add(i);
                  }
              }
          }
          const tex = this.materialsTexture;
          const texWidth = this.materialsTexture.width;
          gl.bindTexture(gl.TEXTURE_2D, tex.glTex);
          this.dirtyIndices.forEach((index) => {
              const allocation = this.materialsAllocator.getAllocation(index);
              const material = this.materials[index];
              const matData = material.getShaderClass().getPackedMaterialData(material);
              const level = 0;
              const xoffset = allocation.start % texWidth;
              const height = 1;
              const rows = Math.ceil((xoffset + allocation.size) / texWidth);
              let consumed = 0;
              let remaining = allocation.size;
              let rowStart = xoffset;
              for (let i = 0; i < rows; i++) {
                  let width;
                  if (rowStart + remaining > texWidth) {
                      width = texWidth - rowStart;
                      rowStart = 0;
                  }
                  else {
                      width = remaining;
                  }
                  const x = (allocation.start + consumed) % texWidth;
                  const y = Math.floor((allocation.start + consumed) / texWidth);
                  const data = matData.subarray(consumed * 4, (consumed + width) * 4);
                  gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, tex.getFormat(), tex.getType(), data);
                  consumed += width;
                  remaining -= width;
              }
          });
          this.dirtyIndices = new Set();
          gl.bindTexture(gl.TEXTURE_2D, null);
          renderstate.boundTextures--;
      }
      /**
       * Updates the GPU state if any update is needed.
       * @param renderstate - The object tracking the current state of the renderer
       */
      update(renderstate) {
          if (this.dirtyIndices.size > 0)
              this.uploadMaterials(renderstate);
      }
      /**
       * The bind method.
       * @param renderstate - The renderstate param.
       * @return - The return value.
       */
      bind(renderstate) {
          if (this.dirtyIndices.size > 0)
              this.uploadMaterials(renderstate);
          if (!this.materialsTexture)
              return false;
          const { materialsTexture, materialsTextureSize } = renderstate.unifs;
          if (materialsTexture) {
              this.materialsTexture.bindToUniform(renderstate, materialsTexture);
              if (materialsTextureSize) {
                  const gl = this.renderer.gl;
                  gl.uniform2i(materialsTextureSize.location, this.materialsTexture.width, this.materialsTexture.height);
              }
          }
          return true;
      }
  }

  /** Class representing GL points.
   * @extends GLGeom
   * @private
   */
  class GLPoints extends GLGeom {
      /**
       * Create a GL point.
       * @param gl - The webgl rendering context.
       * @param points - The points value.
       */
      constructor(gl, points) {
          super(gl, points);
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          // Support drawing custom geometry per point.
          // e.g. the arrow shader.
          if (renderstate.shaderInstancedGeom) {
              gl.drawElementsInstanced(gl.TRIANGLES, renderstate.shaderInstancedGeom.numTriIndices, renderstate.shaderInstancedGeom.indexDataType, 0, this.numVertices);
          }
          else {
              gl.drawArrays(gl.POINTS, 0, this.numVertices);
          }
      }
      /**
       * The drawInstanced method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param instanceCount - The instanceCount value.
       */
      drawInstanced(renderstate, instanceCount) {
          const gl = this.__gl;
          gl.drawArraysInstanced(this.__gl.POINTS, 0, this.numVertices, instanceCount);
      }
  }

  const convertValue = (srcData, index) => {
      if (srcData instanceof Int16Array || srcData instanceof Uint16Array) {
          return MathFunctions.decode16BitFloat(srcData[index]);
      }
      else if (srcData instanceof Int16Array || srcData instanceof Uint16Array) {
          return MathFunctions.decode16BitFloat(srcData[index]);
      }
      return srcData[index];
  };
  const convertBuffer = (gl, attrData, attrDesc) => {
      const srcData = attrData.values;
      const tgtLength = attrData.count * attrDesc.dimension;
      // console.log('convertBuffer:', attrDesc.name, srcData)
      switch (attrDesc.dataType) {
          case gl.BYTE:
              if (srcData instanceof Int8Array)
                  return srcData;
              const tgt = new Int8Array(tgtLength);
              if (srcData instanceof Float32Array) {
                  srcData.forEach((value, i) => {
                      const tgtIdx = (i % attrData.dimension) + Math.floor(i / attrData.dimension) * attrDesc.dimension;
                      tgt[tgtIdx] = MathFunctions.remap(value, -1, 1, -127, 127);
                  });
              }
              return tgt;
          case gl.UNSIGNED_BYTE: {
              if (srcData instanceof Uint8Array)
                  return srcData;
              const tgt = new Uint8Array(tgtLength);
              if (srcData instanceof Float32Array) {
                  srcData.forEach((value, i) => {
                      const tgtIdx = (i % attrData.dimension) + Math.floor(i / attrData.dimension) * attrDesc.dimension;
                      tgt[tgtIdx] = MathFunctions.remap(value, 0, 1, 0, 255);
                  });
              }
              return tgt;
          }
          case gl.UNSIGNED_SHORT: {
              if (srcData instanceof Uint16Array)
                  return srcData;
              const tgt = new Uint16Array(tgtLength);
              for (let i = 0; i < attrData.count; i++) {
                  tgt.set(srcData.subarray(i * attrData.dimension, (i + 1) * attrData.dimension), i * attrDesc.dimension);
              }
              return tgt;
          }
          case gl.SHORT: {
              if (srcData instanceof Int16Array)
                  return srcData;
              const tgt = new Int16Array(tgtLength);
              for (let i = 0; i < attrData.count; i++) {
                  tgt.set(srcData.subarray(i * attrData.dimension, (i + 1) * attrData.dimension), i * attrDesc.dimension);
              }
              return tgt;
          }
          case gl.HALF_FLOAT: {
              if (srcData instanceof Uint16Array)
                  return srcData;
              if (srcData instanceof Float32Array) {
                  return MathFunctions.convertFloat32ArrayToUInt16Array(srcData);
              }
              throw 'Unable to convert from src data array';
          }
          case gl.FLOAT: {
              if (srcData instanceof Float32Array)
                  return srcData;
              const tgt = new Float32Array(tgtLength);
              if (srcData instanceof Uint16Array) {
                  for (let i = 0; i < srcData.length; i++) {
                      tgt[i] = MathFunctions.decode16BitFloat(srcData[i]);
                  }
              }
              return tgt;
          }
          default:
              throw `Unhandled attribute type: ${attrDesc.dataType} for ${srcData.constructor.name}`;
      }
  };

  /** Class representing GL lines.
   * @extends GLGeom
   * @private
   */
  class GLLines extends GLGeom {
      numSegIndices = -1;
      fatBuffersNeedUpload = true;
      numFatVertices = -1;
      fatBuffers = null;
      indexDataType = 0;
      /**
       * Create a GL line.
       * @param gl - The webgl rendering context.
       * @param lines - The geom value.
       */
      constructor(gl, lines) {
          super(gl, lines);
      }
      /**
       * The dirtyBuffers method.
       * @param opts - options passed when geomDataChanged is emitted. (Currently ony used by the FreehandLines tool)
       */
      dirtyBuffers(opts) {
          super.dirtyBuffers(opts);
          this.fatBuffersNeedUpload = true;
          this.emit('updated');
      }
      /**
       * The clearBuffers method.
       */
      clearBuffers() {
          const gl = this.__gl;
          gl.deleteBuffer(this.indexBuffer);
          this.indexBuffer = null;
          if (this.fatBuffers && this.fatBuffers.positionsTexture) {
              if (this.fatBuffers.positionsTexture) {
                  this.fatBuffers.positionsTexture.destroy();
                  this.fatBuffers.positionsTexture = null;
              }
              const segmentIndices = this.fatBuffers.glattrbuffers.segmentIndices;
              if (segmentIndices.buffer) {
                  gl.deleteBuffer(segmentIndices.buffer);
                  this.fatBuffers.glattrbuffers.segmentIndices = null;
              }
          }
          super.clearBuffers();
      }
      /**
       * The genFatBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      genFatBuffers(renderstate) {
          // if (!(this.geom instanceof Lines)
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers();
          const indices = geomBuffers.indices;
          const numVertsChanged = geomBuffers.numVertices != this.numFatVertices;
          if (!gl.__quadVertexIdsBuffer) {
              gl.setupInstancedQuad();
          }
          if (!this.fatBuffers) {
              this.fatBuffers = { drawCount: 0, positionsTexture: null, glattrbuffers: {} };
              this.fatBuffers.glattrbuffers.vertexIDs = gl.__quadattrbuffers.vertexIDs;
          }
          const unit = renderstate.boundTextures++;
          gl.activeTexture(this.__gl.TEXTURE0 + unit);
          this.fatBuffers.drawCount = indices.length / 2;
          const positions = geomBuffers.attrBuffers.positions;
          const lineThicknessAttr = geomBuffers.attrBuffers.lineThickness;
          const stride = 4; // The number of floats per draw item.
          const dataArray = new Float32Array(positions.count * stride);
          for (let i = 0; i < positions.count; i++) {
              dataArray[i * stride + 0] = convertValue(positions.values, i * 3 + 0);
              dataArray[i * stride + 1] = convertValue(positions.values, i * 3 + 1);
              dataArray[i * stride + 2] = convertValue(positions.values, i * 3 + 2);
              // The thickness of the line.
              if (lineThicknessAttr)
                  dataArray[i * stride + 3] = convertValue(lineThicknessAttr.values, i);
              else
                  dataArray[i * stride + 3] = 1.0;
          }
          if (numVertsChanged && this.fatBuffers.positionsTexture) {
              this.fatBuffers.positionsTexture.destroy();
              this.fatBuffers.positionsTexture = null;
          }
          if (!this.fatBuffers.positionsTexture) {
              this.fatBuffers.positionsTexture = new GLTexture2D(this.__gl, {
                  format: 'RGBA',
                  type: 'FLOAT',
                  width: positions.count,
                  /* each pixel has 4 floats*/
                  height: 1,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  data: dataArray,
                  mipMapped: false,
              });
          }
          else {
              this.fatBuffers.positionsTexture.bufferData(dataArray, positions.count, 1);
          }
          const makeIndices = () => {
              const indexArray = new Float32Array(indices.length);
              for (let i = 0; i < indices.length; i++) {
                  let seqentialIndex;
                  if (i % 2 == 0) {
                      seqentialIndex = i > 0 ? indices[i] == indices[i - 1] : indices[i] == indices[indices.length - 1];
                  }
                  else {
                      seqentialIndex = i < indices.length - 1 ? indices[i] == indices[i + 1] : indices[i] == indices[0];
                  }
                  // encode the flag into the indices values.
                  // this flag is decoded in GLSL.
                  indexArray[i] = (seqentialIndex ? 1 : 0) + indices[i] * 2;
              }
              return indexArray;
          };
          if (!this.fatBuffers.glattrbuffers.segmentIndices) {
              const indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, makeIndices(), gl.STATIC_DRAW);
              this.fatBuffers.glattrbuffers.segmentIndices = {
                  dataType: gl.FLOAT,
                  name: 'segmentIndices',
                  dimension: 2,
                  elementSize: 4,
                  normalized: false,
                  shared: false,
                  numValues: indices.length,
                  buffer: indexBuffer,
              };
          }
          else {
              if (!this.genBufferOpts || (this.genBufferOpts && this.genBufferOpts.topologyChanged)) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, this.fatBuffers.glattrbuffers.segmentIndices.buffer);
                  gl.bufferData(gl.ARRAY_BUFFER, makeIndices(), gl.STATIC_DRAW);
              }
          }
          gl.bindTexture(gl.TEXTURE_2D, null);
          renderstate.boundTextures--;
          this.numSegIndices = indices.length;
          this.numFatVertices = geomBuffers.numVertices;
          this.fatBuffersNeedUpload = false;
      }
      /**
       * The genBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      genBuffers(renderstate) {
          super.genBuffers(renderstate);
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers();
          const indices = geomBuffers.indices;
          // Note: the topology can change without the number of vertices changing
          // and vice versa.
          if (this.numSegIndices != indices.length) {
              gl.deleteBuffer(this.indexBuffer);
              this.indexBuffer = gl.createBuffer();
          }
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
          this.numSegIndices = indices.length;
          this.numVertices = geomBuffers.numVertices;
          if (indices instanceof Uint8Array)
              this.indexDataType = this.__gl.UNSIGNED_BYTE;
          if (indices instanceof Uint16Array)
              this.indexDataType = this.__gl.UNSIGNED_SHORT;
          if (indices instanceof Uint32Array)
              this.indexDataType = this.__gl.UNSIGNED_INT;
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      bind(renderstate) {
          const gl = this.__gl;
          const unifs = renderstate.unifs;
          const { LineThickness, geomType } = renderstate.unifs;
          if (geomType)
              this.__gl.uniform1i(geomType.location, 1 /*GeomType.LINES*/);
          if (LineThickness && gl.floatTexturesSupported) {
              if (this.fatBuffersNeedUpload)
                  this.genFatBuffers(renderstate); // (renderstate, true)
              const fatBuffers = this.fatBuffers;
              let shaderBinding = this.shaderBindings[renderstate.shaderkey];
              if (!shaderBinding) {
                  shaderBinding = generateShaderGeomBinding(this.__gl, renderstate.attrs, fatBuffers.glattrbuffers, gl.__quadIndexBuffer);
                  this.shaderBindings[renderstate.shaderkey] = shaderBinding;
              }
              shaderBinding.bind(renderstate);
              if (unifs.positionsTexture) {
                  fatBuffers.positionsTexture.bindToUniform(renderstate, unifs.positionsTexture);
                  gl.uniform1i(unifs.positionsTextureSize.location, fatBuffers.positionsTexture.width);
              }
              return true;
          }
          else {
              super.bind(renderstate);
              return true;
          }
      }
      // ////////////////////////////////
      // Drawing Lines Points.
      /**
       * The drawPoints method.
       */
      drawPoints() {
          this.__gl.drawArrays(this.__gl.POINTS, 0, this.geom.getNumVertices());
      }
      // ////////////////////////////////
      // Regular Drawing.
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          if (renderstate.unifs.LineThickness && gl.floatTexturesSupported) {
              gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, this.fatBuffers.drawCount);
              // Note: We don't have a solution for drawing fat lines to the geom data buffer.
          }
          else {
              gl.drawElements(this.__gl.LINES, this.numSegIndices, this.indexDataType, 0);
          }
      }
      /**
       * The drawInstanced method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param instanceCount - The instanceCount value.
       */
      drawInstanced(renderstate, instanceCount) {
          const gl = this.__gl;
          const { occluded } = renderstate.unifs;
          if (occluded) {
              gl.uniform1i(occluded.location, 0);
          }
          gl.drawElementsInstanced(this.__gl.LINES, this.numSegIndices, this.indexDataType, 0, instanceCount);
          if (occluded) {
              gl.uniform1i(occluded.location, 1);
              gl.depthFunc(gl.GREATER);
              gl.drawElementsInstanced(this.__gl.LINES, this.numSegIndices, this.indexDataType, 0, instanceCount);
              gl.depthFunc(gl.LEQUAL);
          }
      }
  }

  /** Class representing a GL mesh.
   * @extends GLGeom
   * @private
   */
  class GLCompoundGeom extends GLGeom {
      indexDataType = 0;
      drawCounts = {};
      /**
       * Create a GL mesh.
       * @param gl - The webgl rendering context.
       * @param compoundGeom - The CompoundGeom value.
       */
      constructor(gl, compoundGeom) {
          //@ts-ignore.
          super(gl, compoundGeom);
      }
      // /////////////////////////////////////
      // Buffers
      /**
       * The genBuffers method.
       */
      genBuffers(renderstate) {
          super.genBuffers(renderstate);
          const gl = this.__gl;
          const geomBuffers = this.geom.genBuffers();
          const indices = geomBuffers.indices;
          let elementSize = 0;
          if (indices instanceof Uint8Array) {
              this.indexDataType = this.__gl.UNSIGNED_BYTE;
              elementSize = 1;
          }
          else if (indices instanceof Uint16Array) {
              this.indexDataType = this.__gl.UNSIGNED_SHORT;
              elementSize = 2;
          }
          else if (indices instanceof Uint32Array) {
              this.indexDataType = this.__gl.UNSIGNED_INT;
              elementSize = 4;
          }
          this.numVertices = this.geom.getNumVertices();
          if (this.indexBuffer) {
              gl.deleteBuffer(this.indexBuffer);
          }
          this.indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geomBuffers.indices, gl.STATIC_DRAW);
          this.updateDrawIds(renderstate, geomBuffers, elementSize);
          this.buffersDirty = false;
      }
      updateDrawIds(renderstate, geomBuffers, elementSize) {
          const materials = geomBuffers.materials;
          const getMaterialAddr = (materialId) => {
              const material = materials[materialId];
              const materialAddr = renderstate.renderer.glMaterialLibrary.getMaterialAllocation(material);
              return materialAddr.start;
          };
          {
              if (geomBuffers.materialSubGeoms && false) {
                  for (let key in geomBuffers.materialSubGeoms) {
                      if (geomBuffers.materialSubGeoms[key].length > 0) {
                          const subGeoms = geomBuffers.materialSubGeoms[key];
                          const drawSubGeom = {
                              geomType: exports.GeomType[key],
                              offsets: new Int32Array(subGeoms.length),
                              counts: new Int32Array(subGeoms.length),
                              materialIds: new Uint8Array(subGeoms.length),
                          };
                          for (let i = 0; i < subGeoms.length; i++) {
                              drawSubGeom.offsets[i] = subGeoms[i].offset * elementSize;
                              drawSubGeom.counts[i] = subGeoms[i].count;
                              drawSubGeom.materialIds[i] = getMaterialAddr(subGeoms[i].materialId);
                          }
                          this.drawCounts[key] = drawSubGeom;
                      }
                  }
              }
              else {
                  for (let key in geomBuffers.counts) {
                      if (geomBuffers.counts[key] > 0) {
                          const drawSubGeom = {
                              geomType: exports.GeomType[key],
                              offsets: new Int32Array([geomBuffers.offsets[key] * elementSize]),
                              counts: new Int32Array([geomBuffers.counts[key]]),
                              materialIds: new Uint8Array(geomBuffers.counts.length),
                          };
                          this.drawCounts[key] = drawSubGeom;
                      }
                  }
              }
          }
      }
      /**
       * The updateBuffers method.
       * @param opts - The options object.
       */
      updateBuffers(renderstate) {
          this.__gl;
          if (this.numVertices != this.geom.getNumVertices()) {
              this.genBuffers(renderstate);
              return;
          }
          super.updateBuffers(renderstate);
          let elementSize = 0;
          if (this.indexDataType == this.__gl.UNSIGNED_BYTE)
              elementSize = 1;
          if (this.indexDataType == this.__gl.UNSIGNED_SHORT)
              elementSize = 2;
          if (this.indexDataType == this.__gl.UNSIGNED_INT)
              elementSize = 4;
          const geomBuffers = this.geom.genBuffers({ includeIndices: false });
          this.updateDrawIds(renderstate, geomBuffers, elementSize);
      }
      /**
       * The clearBuffers method.
       */
      clearBuffers() {
          const gl = this.__gl;
          gl.deleteBuffer(this.indexBuffer);
          this.indexBuffer = null;
          super.clearBuffers();
      }
      // ////////////////////////////////
      // Regular Drawing.
      /**
       * Draw an item to screen.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          this.drawInstanced(renderstate, 1);
      }
      /**
       * The drawInstanced method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param instanceCount - The instanceCount value.
       */
      drawInstanced(renderstate, instanceCount) {
          renderstate.pushGLStack('GLCompoundGeom.drawInstanced');
          const blendPointsAndLines = true;
          const gl = this.__gl;
          const { drawIds, geomType, outlineThickness, viewportSize, occluded } = renderstate.unifs;
          const depthFuncValue = gl.getParameter(gl.DEPTH_FUNC);
          let renderModeValue = null;
          let drawingOutlines = false;
          let drawingHiddenLines = false;
          if (renderstate instanceof ColorRenderState) {
              renderModeValue = renderstate.renderMode;
              const drawEdges = renderModeValue != 'flat-noedges' && renderModeValue != 'shaded-noedges' && renderModeValue != 'pbr-noedges';
              drawingOutlines =
                  outlineThickness &&
                      viewportSize &&
                      renderstate.outlineMethod == 'geometry' &&
                      renderstate.outlineThickness > 0 &&
                      drawEdges;
              // Note: multiple different rendermodes could potentially draw hidden line.
              drawingHiddenLines = renderModeValue == 'hiddenline' && occluded != null;
          }
          if (this.drawCounts['TRIANGLES']) {
              if (geomType)
                  gl.uniform1i(geomType.location, exports.GeomType.TRIANGLES);
              if (renderModeValue == 'hiddenline') {
                  // don't render surfaces
                  gl.colorMask(false, false, false, false);
              }
              // Always zero this value before drawing the faces, else the shader could think its drawing the outline.
              if (outlineThickness) {
                  gl.uniform1f(outlineThickness.location, 0);
              }
              const draw = this.drawCounts['TRIANGLES'];
              const instCounts = draw.counts.map(() => instanceCount);
              if (!gl.multiDrawElementsInstanced) {
                  for (let i = 0; i < draw.counts.length; i++) {
                      if (drawIds) {
                          gl.uniform2i(drawIds.location, i, draw.materialIds[i]);
                      }
                      this.__gl.drawElementsInstanced(gl.TRIANGLES, draw.counts[i], this.indexDataType, draw.offsets[i], instanceCount);
                  }
              }
              else {
                  gl.multiDrawElementsInstanced(gl.TRIANGLES, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
              }
              if (drawingOutlines) {
                  // Only draw font faces. BEcause all faces are drawn, it can make a mess to see the back faces through the front faces.
                  // e.g. we might see the triangles on the other side of a sphere rendered over the top of triangles on the near side.
                  renderstate.pushGLStack('GLCompoundGeom.drawingOutlines');
                  renderstate.glEnable(gl.CULL_FACE);
                  gl.cullFace(gl.FRONT);
                  // @ts-ignore
                  gl.uniform1f(outlineThickness.location, renderstate.outlineThickness * window.devicePixelRatio);
                  gl.uniform2f(viewportSize.location, renderstate.region[2] - renderstate.region[0], renderstate.region[3] - renderstate.region[1]);
                  if (renderModeValue == 'hiddenline') {
                      // start rendering surfaces again
                      gl.colorMask(true, true, true, true);
                  }
                  if (!gl.multiDrawElementsInstanced) {
                      for (let i = 0; i < draw.counts.length; i++) {
                          if (drawIds) {
                              gl.uniform2i(drawIds.location, i, draw.materialIds[i]);
                          }
                          this.__gl.drawElementsInstanced(gl.TRIANGLES, draw.counts[i], this.indexDataType, draw.offsets[i], instanceCount);
                      }
                  }
                  else {
                      gl.multiDrawElementsInstanced(gl.TRIANGLES, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
                  }
                  renderstate.popGLStack();
                  gl.cullFace(gl.BACK);
              }
          }
          if (renderstate instanceof ColorRenderState && blendPointsAndLines) {
              renderstate.glEnable(gl.BLEND);
              gl.blendEquation(gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
          }
          if (this.drawCounts['LINES']) {
              if (geomType)
                  gl.uniform1i(geomType.location, exports.GeomType.LINES);
              const draw = this.drawCounts['LINES'];
              const instCounts = draw.counts.map(() => instanceCount);
              if (!gl.multiDrawElementsInstanced) {
                  for (let i = 0; i < draw.counts.length; i++) {
                      if (drawIds) {
                          gl.uniform2i(drawIds.location, i, draw.materialIds[i]);
                      }
                      gl.drawElementsInstanced(gl.LINES, draw.counts[i], this.indexDataType, draw.offsets[i], instanceCount);
                  }
              }
              else {
                  gl.multiDrawElementsInstanced(gl.LINES, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
              }
              if (drawingHiddenLines) {
                  const { hiddenLineColor } = renderstate.unifs;
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  if (!gl.multiDrawElementsInstanced) {
                      for (let i = 0; i < draw.counts.length; i++) {
                          if (drawIds) {
                              gl.uniform2i(drawIds.location, i, draw.materialIds[i]);
                          }
                          gl.drawElementsInstanced(gl.LINES, draw.counts[i], this.indexDataType, draw.offsets[i], instanceCount);
                      }
                  }
                  else {
                      gl.multiDrawElementsInstanced(gl.LINES, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
                  }
                  // Restore defaults.
                  gl.depthFunc(depthFuncValue);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
          if (this.drawCounts['POINTS']) {
              if (geomType)
                  gl.uniform1i(geomType.location, exports.GeomType.POINTS);
              const draw = this.drawCounts['POINTS'];
              const instCounts = draw.counts.map(() => instanceCount);
              {
                  gl.multiDrawElementsInstanced(gl.POINTS, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
              }
              if (drawingHiddenLines) {
                  const { hiddenLineColor } = renderstate.unifs;
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  gl.multiDrawElementsInstanced(gl.POINTS, draw.counts, 0, this.indexDataType, draw.offsets, 0, instCounts, 0, draw.counts.length);
                  gl.depthFunc(depthFuncValue);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
          renderstate.popGLStack();
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          super.destroy();
          const gl = this.__gl;
          gl.deleteBuffer(this.indexBuffer);
          this.indexBuffer = null;
          // if (this.__wireframesVao)
          //     gl.deleteVertexArray(this.__wireframesVao);
          // if (this.__hardEdgesVao)
          //     gl.deleteVertexArray(this.__hardEdgesVao);
      }
  }

  var vert$i = "\n\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\nuniform vec2 srctextureDim;\nconst int border = 2;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * size * 2.0), 0.0, 1.0);\n\n  vec2 borderVec2 = vec2(float(border), float(border));\n  v_texCoord *= (srctextureDim + (borderVec2 * 2.0)) / srctextureDim;\n  v_texCoord -= borderVec2 / srctextureDim;\n}\n\n"; // eslint-disable-line

  var frag$h = "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D srctexture;\nuniform vec2 srctextureDim;\nuniform bool alphaFromLuminance;\nuniform bool invert;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  vec2 pixelCoord = v_texCoord*srctextureDim;\n  vec2 uv = v_texCoord;\n\n  // Wrap X coords\n  if (pixelCoord.x < 0.0) {\n    uv.x += 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n  else if (pixelCoord.x > srctextureDim.x) {\n    uv.x -= 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n\n  // Wrap Y coords\n  if (pixelCoord.y < 0.0) {\n    uv.y += 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n  else if (pixelCoord.y > srctextureDim.y) {\n    uv.y -= 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n\n  vec4 texel = texture2D(srctexture, uv);\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // TODO: check why we pre-multiply alphas here.\n  // fragColor = vec4(texel.rgb/texel.a, texel.a);\n\n  if (alphaFromLuminance) {\n    fragColor = vec4(texel.rgb, luminanceFromRGB(texel.rgb));\n  }\n  else {\n    fragColor = texel;\n  }\n  \n  if (invert) {\n    fragColor = vec4(1.0) - fragColor;\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  // eslint-disable-next-line require-jsdoc
  class AtlasLayoutShader extends GLShader {
      /**
       * Create an atlas layout shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'AtlasLayoutShader');
          this.setShaderStage('VERTEX_SHADER', vert$i);
          this.setShaderStage('FRAGMENT_SHADER', frag$h);
      }
  }

  /**
   * An Image Atlas lays out multiple smaller images within a larger image atlas, and tracks their positions.
   * @private
   */
  class GLImageAtlas extends GLRenderTarget {
      // protected __gl: WebGL12RenderingContext
      name;
      formatParam;
      typeParam;
      // clearColor: Color
      subImages; // GLTexture2D
      layoutNeedsRegeneration;
      asyncCount = 0;
      loaded = false;
      ready = false;
      layout = [];
      atlasLayoutTexture;
      layoutVec4s = [];
      atlasLayoutShaderBinding = null;
      atlasLayoutShader = null;
      /**
       * Create an image atlas..
       * @param gl - The webgl rendering context.
       * @param name - The name value.
       * @param format - The format value.
       * @param type - The type value.
       */
      constructor(gl, name, format = 'RGBA', type = 'FLOAT') {
          super(gl);
          this.name = name;
          this.formatParam = format;
          this.typeParam = type;
          this.clearColor = new Color(0, 0, 0, 0);
          this.subImages = [];
          this.layoutNeedsRegeneration = false;
          this.asyncCount = 0;
          this.loaded = false;
      }
      // eslint-disable-next-line require-jsdoc
      incAsyncCount(count = 1) {
          this.asyncCount += count;
          this.ready = false;
      }
      // eslint-disable-next-line require-jsdoc
      decAsyncCount() {
          if (this.asyncCount > 0) {
              this.asyncCount--;
              if (this.asyncCount == 0) {
                  this.loaded = true;
                  this.emit('loaded');
              }
          }
      }
      /**
       * The isLoaded method.
       * @return - The return value.
       */
      isLoaded() {
          return this.asyncCount == 0;
      }
      /**
       * The addSubImage method.
       * @param subImage - The subImage value.
       * @return - The return value.
       */
      // TODO: WebGLTexture is not handled here
      addSubImage(subImage) {
          if (subImage instanceof BaseImage) {
              const gltexture = new GLTexture2D(this.__gl, subImage);
              if (!subImage.isLoaded()) {
                  this.incAsyncCount();
                  subImage.on('loaded', () => {
                      this.decAsyncCount();
                  });
              }
              subImage.setMetadata('ImageAtlas_gltex', gltexture);
              gltexture.addRef(this);
              const updated = () => {
                  // TODO: Check to see if the new dimensions
                  // do not match the previous. If not, then we
                  // need to relayout. wE could also avlid a complete
                  // relaout by reremoving and re-adding this image.
                  this.layoutNeedsRegeneration = true;
                  this.renderAtlas();
              };
              subImage.on('updated', updated);
              this.subImages.push(gltexture);
          }
          else {
              const subImage_casted = subImage;
              subImage_casted.addRef(this); // subImage is a GLTexture2D
              this.subImages.push(subImage_casted);
          }
          this.layoutNeedsRegeneration = true;
          return this.subImages.length - 1;
      }
      /**
       * The removeSubImage method.
       * @param subImage - The subImage value.
       */
      removeSubImage(subImage) {
          let index;
          if (subImage instanceof BaseImage) {
              const gltext = subImage.getMetadata('ImageAtlas_gltex'); // TODO: refactor
              index = this.subImages.indexOf(gltext);
              subImage.deleteMetadata('ImageAtlas_gltex');
          }
          else {
              index = this.subImages.indexOf(subImage);
          }
          const gltexture = this.subImages[index];
          gltexture.removeRef(this);
          this.subImages.splice(index, 1);
          this.layoutNeedsRegeneration = true;
      }
      /**
       * The getSubImage method.
       * @param index - The index value.
       * @return - The image value.
       */
      getSubImage(index) {
          return this.subImages[index];
      }
      /**
       * The numSubImages method.
       * @return - The return value.
       */
      numSubImages() {
          if (this.layout)
              return this.layout.length;
          return this.subImages.length;
      }
      /**
       * The generateAtlasLayout method.
       */
      generateAtlasLayout(minTileSize) {
          if (this.subImages.length == 0) {
              this.layoutNeedsRegeneration = false;
              return;
          }
          const border = 2;
          // We must lay out the sub images in order of size.
          // else the paker might have trouble.
          const blocks = [];
          this.subImages.forEach((subImage, index) => {
              blocks.push({
                  w: subImage.width + border * 2,
                  h: subImage.height + border * 2,
                  area: subImage.width * subImage.height,
                  index,
              });
          });
          blocks.sort((a, b) => (a.area > b.area ? -1 : a.area < b.area ? 1 : 0));
          const packer = new GrowingPacker();
          packer.fit(blocks);
          this.layout = [];
          blocks.forEach((block, index) => {
              // const subImage = this.subImages[block.index]
              if (block.fit) {
                  this.layout[block.index] = {
                      pos: new Vec2(block.fit.x + border, block.fit.y + border),
                      size: new Vec2(block.w, block.h),
                  };
              }
              else {
                  console.warn('Unable to fit image');
              }
          });
          const width = packer.root.w;
          const height = packer.root.h;
          // console.log(this.name + " Atlas Texture size:" + width.toFixed() + ", " + height.toFixed());
          // Note: only RGBA Float textures can be rendered to on Firefox.(Not RGB)
          this.configure({
              width,
              height,
              format: this.typeParam == 'FLOAT' && this.formatParam == 'RGB' ? 'RGBA' : this.formatParam,
              type: this.typeParam,
              filter: 'LINEAR',
          });
          const gl = this.__gl;
          if (!gl.__quadVertexIdsBuffer)
              gl.setupInstancedQuad();
          if (!this.atlasLayoutShader) {
              this.atlasLayoutShader = new AtlasLayoutShader(this.__gl);
              const directives = [];
              if (gl.name == 'webgl2')
                  directives.push('#define ENABLE_ES3');
              const shaderComp = this.atlasLayoutShader.compileForTarget('GLImageAtlas', directives);
              this.atlasLayoutShaderBinding = generateShaderGeomBinding(this.__gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
          }
          const pixelsPerItem = 1;
          let size = Math.round(Math.sqrt(this.layout.length * pixelsPerItem) + 0.5);
          // Only support power 2 textures. Else we get strange corruption on some GPUs
          // in some scenes.
          size = MathFunctions.nextPow2(size);
          // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
          // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
          if (size % pixelsPerItem != 0)
              size += pixelsPerItem - (size % pixelsPerItem);
          if (!gl.floatTexturesSupported) {
              this.layoutVec4s = [];
              this.layout.forEach((layoutItem, index) => {
                  this.layoutVec4s[index] = [
                      layoutItem.pos.x / width,
                      layoutItem.pos.y / height,
                      layoutItem.size.x / width,
                      layoutItem.size.y / height,
                  ];
              });
          }
          else {
              const dataArray = new Float32Array(size * size * 4); /* each pixel has 4 floats*/
              for (let i = 0; i < this.layout.length; i++) {
                  const layoutItem = this.layout[i];
                  const array = dataArray.subarray(i * 4, (i + 1) * 4);
                  array[0] = layoutItem.pos.x / width;
                  array[1] = layoutItem.pos.y / height;
                  array[2] = layoutItem.size.x / width;
                  array[3] = layoutItem.size.y / height;
              }
              if (!this.atlasLayoutTexture || this.atlasLayoutTexture.width != size || this.atlasLayoutTexture.height != size) {
                  if (this.atlasLayoutTexture)
                      this.atlasLayoutTexture.destroy();
                  this.atlasLayoutTexture = new GLTexture2D(gl, {
                      format: 'RGBA',
                      type: 'FLOAT',
                      filter: 'NEAREST',
                      wrap: 'CLAMP_TO_EDGE',
                      mipMapped: false,
                      width: size,
                      height: size,
                      data: dataArray,
                  });
              }
              else {
                  this.atlasLayoutTexture.bufferData(dataArray, size, size);
              }
          }
          this.textureDesc[0] = this.width;
          this.textureDesc[1] = this.height;
          this.textureDesc[2] = this.atlasLayoutTexture.width;
          // this.textureDesc[3] // flags
          this.layoutNeedsRegeneration = false;
      }
      /**
       * The getLayoutData method.
       * @param index - The index value.
       * @return - The return value.
       */
      getLayoutData(index) {
          return this.layoutVec4s[index];
      }
      /**
       * The renderAtlas method.
       * @param cleanup - The cleanup value.
       * @param off - The off value.
       */
      renderAtlas(cleanup = false, off = 0) {
          if (this.subImages.length == 0) {
              return;
          }
          if (this.layoutNeedsRegeneration) {
              this.generateAtlasLayout();
          }
          const gl = this.__gl;
          const renderstate = new RenderState(gl);
          this.bindForWriting(renderstate, true);
          this.atlasLayoutShader.bind(renderstate, 'GLImageAtlas');
          this.atlasLayoutShaderBinding.bind(renderstate);
          const scl = new Vec2(1.0 / this.width, 1.0 / this.height);
          const unifs = renderstate.unifs;
          for (let j = off; j < this.subImages.length; j++) {
              const glimage = this.subImages[j];
              const layoutItem = this.layout[j];
              // Some images may not have fully loaded yet, so skip those.
              if (!glimage.bindToUniform(renderstate, unifs.srctexture))
                  continue;
              gl.uniform2fv(unifs.pos.location, layoutItem.pos.multiply(scl).asArray());
              gl.uniform2fv(unifs.size.location, layoutItem.size.multiply(scl).asArray());
              gl.uniform2f(unifs.srctextureDim.location, glimage.width, glimage.height);
              gl.uniform1i(unifs.alphaFromLuminance.location, glimage.alphaFromLuminance ? 1 : 0);
              gl.uniform1i(unifs.invert.location, glimage.invert ? 1 : 0);
              gl.drawQuad();
              // After rendering the texture, we can reuse the texture unit.
              renderstate.boundTextures--;
          }
          if (cleanup) {
              this.cleanup();
          }
          this.unbind(renderstate);
          // this.__fbo.unbind()
          this.emit('updated');
      }
      /**
       * The isReady method.
       * @return - The return value.
       */
      isReady() {
          return this.atlasLayoutTexture != undefined;
      }
      /**
       * The bindToUniform method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param unif - The WebGL uniform
       * @return - The return value.
       */
      bindToUniform(renderstate, unif) {
          super.bindToUniform(renderstate, unif);
          const unifs = renderstate.unifs;
          if (this.atlasLayoutTexture) {
              const atlasLayoutUnif = unifs[unif.name + '_layout'];
              if (atlasLayoutUnif)
                  this.atlasLayoutTexture.bindToUniform(renderstate, atlasLayoutUnif);
              const atlasDescUnif = unifs[unif.name + '_desc'];
              if (atlasDescUnif) {
                  this.__gl.uniform4fv(atlasDescUnif.location, this.textureDesc);
              }
          }
          else {
              const atlasDescUnif = unifs[unif.name + '_desc'];
              if (atlasDescUnif)
                  this.__gl.uniform4f(atlasDescUnif.location, 0, 0, 0, 0);
          }
          return true;
      }
      /**
       * The cleanup method.
       */
      cleanup() {
          for (const glimage of this.subImages) {
              glimage.removeRef(this);
          }
          this.subImages = [];
          this.destroy();
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          this.cleanup();
          super.destroy();
      }
  }

  /** Class representing GL points.
   * @extends GLGeom
   * @private
   */
  class GLFatPoints extends GLPoints {
      indexArray = new Int32Array(0);
      distances = new Float32Array(0);
      pointsAttributesTexture = null;
      texelsPerPoint = 1;
      prevSortCameraPos = new Vec3();
      threshold = 0;
      atlas = null;
      spriteCoords = null;
      /**
       * Create a GL point.
       * @param gl - The webgl rendering context.
       * @param points - The points value.
       */
      constructor(gl, points) {
          super(gl, points);
      }
      /**
       * The genBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      genBuffers(renderstate) {
          const gl = this.__gl;
          const points = this.geom;
          const geomBuffers = this.geom.genBuffers();
          this.numVertices = this.geom.getNumVertices();
          this.texelsPerPoint = 1;
          const positions = geomBuffers.attrBuffers.positions;
          const colors = geomBuffers.attrBuffers.colors;
          const sizes = geomBuffers.attrBuffers.sizes;
          if (colors) {
              this.texelsPerPoint = 2;
          }
          const spriteIndices = geomBuffers.attrBuffers.spriteIndices;
          const sprites = points.getParameter('Sprites');
          if (spriteIndices && sprites && sprites.value.length > 0) {
              this.texelsPerPoint = 3;
              this.atlas = new GLImageAtlas(gl, 'Sprites', 'RGBA', 'UNSIGNED_BYTE');
              this.atlas.clearColor = new Color(1, 1, 1, 0);
              const emitUpdated = (event) => this.emit('updated', event);
              this.atlas.on('loaded', emitUpdated);
              this.atlas.on('updated', emitUpdated);
              const images = sprites.value;
              images.forEach((image) => this.atlas.addSubImage(image));
              if (this.atlas.isLoaded()) {
                  this.atlas.renderAtlas();
              }
              else {
                  // Note: Maybe the atlas is already up to date. It should
                  // maintain its own coherencey by listening to the sub images.
                  this.atlas.on('loaded', () => {
                      this.atlas.renderAtlas();
                  });
              }
          }
          const size = MathFunctions.nextPow2(Math.round(Math.sqrt(this.numVertices) + 0.5));
          const data = new Float32Array(size * this.texelsPerPoint * size * 4);
          const stride = this.texelsPerPoint * 4;
          for (let i = 0; i < positions.count; i++) {
              data[i * stride + 0] = convertValue(positions.values, i * 3 + 0);
              data[i * stride + 1] = convertValue(positions.values, i * 3 + 1);
              data[i * stride + 2] = convertValue(positions.values, i * 3 + 2);
              if (sizes)
                  data[i * stride + 3] = sizes.values[i];
              else
                  data[i * stride + 3] = 1.0;
              if (colors) {
                  data.set(colors.values.subarray(i * 4, (i + 1) * 4), i * stride + 4);
              }
              if (spriteIndices) {
                  data[i * stride + 8] = spriteIndices.values[i];
              }
          }
          const width = size * this.texelsPerPoint;
          const height = size;
          this.pointsAttributesTexture = new GLTexture2D(gl, {
              format: gl.RGBA,
              type: gl.FLOAT,
              width,
              height,
              data,
              filter: gl.NEAREST,
              wrap: gl.CLAMP_TO_EDGE,
              mipMapped: false,
          });
          this.numVertices = geomBuffers.numVertices;
          this.buffersDirty = false;
      }
      /**
       * The updateBuffers method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      updateBuffers(renderstate) {
          if (this.numVertices != this.geom.getNumVertices()) {
              this.genBuffers(renderstate);
              return;
          }
          const geomBuffers = this.geom.genBuffers();
          const positions = geomBuffers.attrBuffers.positions;
          const sizes = geomBuffers.attrBuffers.sizes;
          const colors = geomBuffers.attrBuffers.colors;
          const spriteIndices = geomBuffers.attrBuffers.spriteIndices;
          // Only support power 2 textures. Else we get strange corruption on some GPUs
          // in some scenes.
          const size = MathFunctions.nextPow2(Math.round(Math.sqrt(geomBuffers.numVertices) + 0.5));
          const data = new Float32Array(size * this.texelsPerPoint * size * 4);
          const stride = this.texelsPerPoint * 4;
          for (let i = 0; i < positions.count; i++) {
              data[i * stride + 0] = convertValue(positions.values, i * 3 + 0);
              data[i * stride + 1] = convertValue(positions.values, i * 3 + 1);
              data[i * stride + 2] = convertValue(positions.values, i * 3 + 2);
              if (sizes)
                  data[i * stride + 3] = sizes.values[i];
              else
                  data[i * stride + 3] = 1.0;
              if (colors) {
                  data.set(colors.values.subarray(i * 4, (i + 1) * 4), i * stride + 4);
              }
              if (spriteIndices) {
                  data[i * stride + 8] = spriteIndices.values[i];
              }
          }
          const width = size * this.texelsPerPoint;
          const height = size;
          this.pointsAttributesTexture.populate(data, width, height);
          // Cache the size so we know later if it changed (see below)
          this.numVertices = geomBuffers.numVertices;
          this.buffersDirty = false;
      }
      /**
       * The sort method.
       * @param cameraPos - The cameraPos value.
       */
      sort(cameraPos) {
          const geomBuffers = this.geom.genBuffers();
          const positions = geomBuffers.attrBuffers.positions;
          this.distances = new Float32Array(positions.count);
          let bufferSizeChanged = false;
          if (this.indexArray.length != this.distances.length) {
              this.indexArray = new Int32Array(this.distances.length);
              bufferSizeChanged = true;
          }
          for (let i = 0; i < positions.count; i++) {
              const pos = new Vec3(positions.values[i * 3], positions.values[i * 3 + 1], positions.values[i * 3 + 2]);
              this.distances[i] = pos.distanceTo(cameraPos);
              this.indexArray[i] = i;
          }
          this.indexArray.sort((a, b) => {
              return this.distances[a] > this.distances[b] ? -1 : 1;
          });
          const gl = this.__gl;
          if (!this.glattrbuffers.drawIndices) {
              this.glattrbuffers.drawIndices = {
                  name: 'drawIndices',
                  dimension: 1,
                  elementSize: 4,
                  buffer: gl.createBuffer(),
                  dataType: gl.INT,
                  normalized: false,
                  shared: false,
                  numValues: positions.count,
              };
          }
          else if (bufferSizeChanged) {
              if (this.glattrbuffers.drawIndices.buffer)
                  gl.deleteBuffer(this.glattrbuffers.drawIndices.buffer);
              this.glattrbuffers.drawIndices.buffer = gl.createBuffer();
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, this.glattrbuffers.drawIndices.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.indexArray, gl.STATIC_DRAW);
          this.threshold = 0.0;
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      bind(renderstate) {
          if (this.buffersDirty)
              this.updateBuffers(renderstate);
          if (renderstate.attrs.drawIndices) {
              const cameraPos = renderstate.viewXfo.tr;
              const dist = cameraPos.distanceTo(this.prevSortCameraPos);
              // Avoid sorting if the camera did not move more than 3 meters.
              if (dist > this.threshold) {
                  this.sort(cameraPos);
                  this.prevSortCameraPos = cameraPos.clone();
                  if (this.distances.length > 1) {
                      const idx0 = this.indexArray[this.indexArray.length - 1];
                      const dist0 = this.distances[idx0];
                      this.threshold = dist0 * 0.25;
                  }
                  else {
                      this.threshold = 9999;
                  }
              }
          }
          let shaderBinding = this.shaderBindings[renderstate.shaderkey];
          if (!shaderBinding) {
              // Merge the points attrs with the quad attrs.
              const attrbuffers = Object.assign(this.glattrbuffers, renderstate.shaderInstancedGeom.attrBuffers);
              shaderBinding = generateShaderGeomBinding(this.__gl, renderstate.attrs, attrbuffers, renderstate.shaderInstancedGeom.indexBuffer);
              this.shaderBindings[renderstate.shaderkey] = shaderBinding;
          }
          shaderBinding.bind(renderstate);
          const { pointsAttributes, texelsPerPoint, atlasSprites } = renderstate.unifs;
          if (pointsAttributes) {
              this.pointsAttributesTexture.bindToUniform(renderstate, pointsAttributes);
              this.__gl.uniform1i(texelsPerPoint.location, this.texelsPerPoint);
          }
          const { geomType } = renderstate.unifs;
          if (geomType)
              this.__gl.uniform1i(geomType.location, 2 /*GeomType.POINTS*/);
          if (atlasSprites && this.atlas) {
              this.atlas.bindToUniform(renderstate, atlasSprites);
          }
          return true;
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          if (renderstate.shaderInstancedGeom) {
              gl.drawElementsInstanced(gl.TRIANGLES, renderstate.shaderInstancedGeom.numTriIndices, renderstate.shaderInstancedGeom.indexDataType, 0, this.numVertices);
          }
          else {
              gl.drawArrays(gl.POINTS, 0, this.numVertices);
          }
      }
  }

  /* eslint-disable guard-for-in */
  const resizeIntArray = (intArray, newSize) => {
      const newArray = new Int32Array(newSize);
      newArray.set(intArray);
      return newArray;
  };
  /** Class representing a GL geom.
   * @private
   */
  class GLGeomLibrary extends EventEmitter {
      renderer;
      __gl;
      freeGeomIndices = [];
      geoms = [];
      geomRefCounts = [];
      geomsDict = new Map();
      glGeomsDict = new Map();
      geomBuffersTmp = []; // for each geom, these are the buffer
      shaderAttrSpec = {};
      glattrbuffers = {};
      shaderBindings = {};
      attributesBufferNeedsRealloc = false;
      attributesBufferNeedsAlloc = [];
      attributesAllocator = new Allocator1D();
      dirtyGeomIndices = new Set();
      geomVertexOffsets = new Int32Array(1);
      geomVertexCounts = new Int32Array(1);
      numIndices = 0;
      indicesBufferNeedsRealloc = false;
      indicesAllocator = new Allocator1D();
      indicesCounts = new Int32Array(1);
      indicesOffsets = new Int32Array(1);
      indexBuffer = null;
      freeDataAfterUpload = false;
      __destroyed = false;
      geomEventHandlerIds = [];
      /**
       * Create a GLGeomLibrary.
       * @param renderer - The renderer object
       */
      constructor(renderer) {
          super();
          this.renderer = renderer;
          this.__gl = renderer.gl;
          // If the allocator ever resizes, then we need to re-upload everything.
          this.attributesAllocator.on('resized', () => {
              this.attributesBufferNeedsRealloc = true;
          });
          this.attributesAllocator.on('dataReallocated', (event) => {
              // during allocation, a defragment might occur, which means
              // we need to re-upload some of our data.
              const id = event.id;
              const allocation = event.allocation;
              this.dirtyGeomIndices.add(id);
              this.geomVertexOffsets[id] = allocation.start;
              this.geomVertexCounts[id] = allocation.size;
          });
          this.freeGeomIndices.push(0);
          // //////////////////////////////////////
          // Indices
          this.indicesAllocator.on('resized', () => {
              // 540M indices == 2Gb of indices, which is the maximum allows by WebGL.
              // This is because WebGL may accept JS arrays which can contain floating point indices.
              // After we have allocated More than 256 Mb of indices, we then force allocations to be limited
              // to the exact allocated space.
              if (Math.log2(this.indicesAllocator.reservedSpace) >= 29) {
                  if (Math.log2(this.indicesAllocator.allocatedSpace) >= 29) {
                      throw 'Indices buffer too big. WebGL cannot allocate index buffers more than 2Gb';
                  }
                  // console.log("this.indicesAllocator. capped to':", this.indicesAllocator.allocatedSpace + 1)
                  this.indicesAllocator.reservedSpace = (1 << 29) - 1;
              }
              this.indicesBufferNeedsRealloc = true;
          });
          this.indicesAllocator.on('dataReallocated', (event) => {
              // during allocation, a defragment might occur, which means
              // we need to re-upload some of our data.
              const id = event.id;
              this.dirtyGeomIndices.add(id);
          });
          // Allocate enough space for 1M verts to begin with. This avoids lots of small
          // copies when loading small files.
          const size = 2 << 19;
          this.reserveSpace(size, size * 2);
          // this.shaderAttrSpec['positions'] = genDataTypeDesc(this.__gl, 'Vec4f16')
          // this.shaderAttrSpec['normals'] = genDataTypeDesc(this.__gl, 'Vec4f8')
      }
      reserveSpace(attributeCount, vertexCount) {
          this.attributesAllocator.reservedSpace = attributeCount;
          this.indicesAllocator.reservedSpace = vertexCount;
          this.attributesBufferNeedsRealloc = true;
          this.indicesBufferNeedsRealloc = true;
      }
      /**
       * Given a BaseGeom, constructs the GLGeom that manages the state of the geometry in the GPU.
       * @param geom - The geom value.
       * @return - The return value.
       */
      constructGLGeom(geom) {
          let glgeom = this.glGeomsDict.get(geom);
          if (glgeom != undefined) {
              // Increment the ref count for the GLGeom
              // glgeom.addRef(this)
              return glgeom;
          }
          const gl = this.__gl;
          if (geom instanceof Mesh || geom instanceof MeshProxy) {
              glgeom = new GLMesh(gl, geom);
          }
          else if (geom instanceof Lines || geom instanceof LinesProxy) {
              glgeom = new GLLines(gl, geom);
          }
          else if (geom instanceof FatPoints) {
              glgeom = new GLFatPoints(gl, geom);
          }
          else if (geom instanceof Points || geom instanceof PointsProxy) {
              glgeom = new GLPoints(gl, geom);
          }
          else if (geom instanceof CompoundGeom) {
              glgeom = new GLCompoundGeom(gl, geom);
          }
          else {
              throw new Error('Unsupported geom type:' + geom.constructor.name);
          }
          this.glGeomsDict.set(geom, glgeom);
          glgeom.on('updated', () => {
              this.renderer.requestRedraw();
          });
          glgeom.addRef(this);
          return glgeom;
      }
      /**
       * Adds a geom to the GLGeomLibrary.
       *
       * @param geom - The geom to be managed by this GLGeomLibrary.
       * @return - The index of the geom in the GLGeomLibrary
       */
      addGeom(geom) {
          let index = this.geomsDict.get(geom);
          if (index != undefined) {
              // Increment the ref count for the GLGeom
              this.geomRefCounts[index]++;
              return index;
          }
          if (this.freeGeomIndices.length == 0) {
              const prevSize = this.geomVertexCounts.length;
              const newSize = prevSize * 2;
              this.geomVertexCounts = resizeIntArray(this.geomVertexCounts, newSize);
              this.geomVertexOffsets = resizeIntArray(this.geomVertexOffsets, newSize);
              this.indicesCounts = resizeIntArray(this.indicesCounts, newSize);
              this.indicesOffsets = resizeIntArray(this.indicesOffsets, newSize);
              for (let i = newSize - 1; i >= prevSize; i--) {
                  this.freeGeomIndices.push(i);
              }
          }
          index = this.freeGeomIndices.pop();
          this.geoms[index] = geom;
          this.geomRefCounts[index] = 1;
          this.geomsDict.set(geom, index);
          this.dirtyGeomIndices.add(index);
          this.geomVertexCounts[index] = 0;
          this.geomVertexOffsets[index] = 0;
          this.indicesCounts[index] = 0;
          this.indicesOffsets[index] = 0;
          const geomDataChanged = () => {
              this.dirtyGeomIndices.add(index);
              this.emit('updated');
          };
          const geomDataTopologyChanged = () => {
              this.dirtyGeomIndices.add(index);
              this.emit('updated');
          };
          const eventHandlerIds = {};
          eventHandlerIds.geomDataChanged = geom.on('geomDataChanged', geomDataChanged);
          eventHandlerIds.geomDataTopologyChanged = geom.on('geomDataTopologyChanged', geomDataTopologyChanged);
          if (geom instanceof CompoundGeom) {
              const glMaterialLibrary = this.renderer.glMaterialLibrary;
              geom.materials.forEach((material) => {
                  glMaterialLibrary.addMaterial(material);
              });
              eventHandlerIds.materialsChanged = geom.on('materialsChanged', () => {
                  geom.materials.forEach((material) => {
                      glMaterialLibrary.addMaterial(material);
                  });
                  this.emit('geomDataChanged', new IndexEvent(index));
                  this.emit('updated');
              });
          }
          this.geomEventHandlerIds[index] = eventHandlerIds;
          return index;
      }
      /**
       * Removes a Geom managed by this GLGeomLibrary.
       * @param geom - The geom to remove
       */
      removeGeom(geom) {
          const index = this.geomsDict.get(geom);
          if (index == undefined)
              throw new Error('geom does not exist in the GLGeomLibrary');
          this.geomRefCounts[index]--;
          // If there are still refs to this geom. (GeomItems that use it)
          // then we keep it in the renderer.
          if (this.geomRefCounts[index] > 0) {
              return;
          }
          // If the geom was never drawn, and we are already removing it, there may be no allocation.
          if (this.attributesAllocator.getAllocation(index)) {
              this.attributesAllocator.deallocate(index);
          }
          if (this.indicesAllocator.getAllocation(index)) {
              this.indicesAllocator.deallocate(index);
          }
          if (this.dirtyGeomIndices.has(index)) {
              this.dirtyGeomIndices.delete(index);
          }
          this.geomVertexCounts[index] = 0;
          this.geomVertexOffsets[index] = 0;
          this.geoms[index] = null;
          this.freeGeomIndices.push(index);
          this.geomsDict.delete(geom);
          delete this.geomBuffersTmp[index];
          this.indicesCounts[index] = 0;
          this.indicesOffsets[index] = 0;
          const eventHandlerIds = this.geomEventHandlerIds[index];
          geom.off('geomDataChanged', eventHandlerIds.geomDataChanged);
          geom.off('geomDataTopologyChanged', eventHandlerIds.geomDataTopologyChanged);
          if (geom instanceof CompoundGeom) {
              geom.off('materialsChanged', eventHandlerIds.materialsChanged);
          }
      }
      /**
       * Returns a Geom managed by this GLGeomLibrary.
       * @param index - The index of the geom to retrieve
       * @return - The return value.
       */
      getGeom(index) {
          return this.geoms[index];
      }
      /**
       * Returns a Geom managed by this GLGeomLibrary.
       * @param index - The index of the geom to retrieve
       * @return - The return value.
       */
      getGeomOffsetAndCount(index) {
          return [this.indicesOffsets[index], this.indicesCounts[index]];
      }
      /**
       * Returns a Geom managed by this GLGeomLibrary.
       * @param {number} index - The index of the geom to retrieve
       * @return {array} - The return value.
       */
      getGeomBuffers(index) {
          return this.geomBuffersTmp[index];
      }
      // /////////////////////////////////////
      // Buffers
      /**
       * Allocates space for the geomBuffers for the specified geometry
       * @param index - The index of the geom to upload
       */
      allocateBuffers(index) {
          const geom = this.geoms[index];
          if (!geom)
              return;
          const geomBuffers = geom.genBuffers();
          const numVerts = geomBuffers.numRenderVerts ? geomBuffers.numRenderVerts : geomBuffers.numVertices;
          if (this.geomVertexCounts[index] != numVerts) {
              if (numVerts == 0) {
                  this.attributesAllocator.deallocate(index);
                  this.geomVertexOffsets[index] = 0;
                  this.geomVertexCounts[index] = 0;
              }
              else {
                  const allocation = this.attributesAllocator.allocate(index, numVerts);
                  this.geomVertexOffsets[index] = allocation.start;
                  this.geomVertexCounts[index] = allocation.size;
              }
          }
          // eslint-disable-next-line guard-for-in
          for (const attrName in geomBuffers.attrBuffers) {
              // Removing these because multi-draw doesn't support textures anyway
              // so no need to upload texture coordinates.
              if (attrName == 'textureCoords' || attrName == 'texCoords')
                  continue;
              if (!this.shaderAttrSpec[attrName]) {
                  const attrData = geomBuffers.attrBuffers[attrName];
                  this.shaderAttrSpec[attrName] = genDataTypeDesc(this.__gl, attrData.dataType);
                  this.shaderAttrSpec[attrName].normalized = attrData.normalized;
                  this.attributesBufferNeedsAlloc.push(attrName);
              }
          }
          // //////////////////////////////////////
          // Indices
          if (geomBuffers.indices) {
              const numIndices = geomBuffers.indices.length;
              if (this.indicesCounts[index] != numIndices) {
                  if (numIndices == 0) {
                      this.indicesAllocator.deallocate(index);
                      this.indicesOffsets[index] = 0;
                      this.indicesCounts[index] = 0;
                  }
                  else {
                      const allocation = this.indicesAllocator.allocate(index, numIndices);
                      const elementSize = 4; //  Uint32Array for UNSIGNED_INT
                      this.indicesOffsets[index] = allocation.start * elementSize; // offset is in bytes
                      this.indicesCounts[index] = allocation.size;
                  }
              }
          }
          else {
              // Note: for non-indexed data, like Points, we provide
              // the vertex data as offset and count in the method
              // getGeomOffsetAndCount.
              this.indicesOffsets[index] = this.geomVertexOffsets[index];
              this.indicesCounts[index] = this.geomVertexCounts[index];
          }
          this.geomBuffersTmp[index] = geomBuffers;
      }
      /**
       * Generates the GPU buffers required to store all the geometries
       */
      genAttributesBuffers() {
          // eslint-disable-next-line guard-for-in
          for (const attrName in this.shaderAttrSpec) {
              this.genAttributesBuffer(attrName);
          }
          // Clear this list if it had anything in it.
          this.attributesBufferNeedsAlloc = [];
      }
      /**
       * Generates a single GPU buffer
       */
      genAttributesBuffer(attrName) {
          // Removing these because multi-draw doesn't support textures anyway
          // so no need to upload texture coordinates.
          if (attrName == 'textureCoords' || attrName == 'texCoords')
              return;
          const reservedSpace = this.attributesAllocator.reservedSpace;
          const gl = this.__gl;
          {
              const attrSpec = this.shaderAttrSpec[attrName];
              const numValues = reservedSpace * attrSpec.dimension;
              const attrBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, attrBuffer);
              const sizeInBytes = numValues * attrSpec.elementSize;
              gl.bufferData(gl.ARRAY_BUFFER, sizeInBytes, gl.STATIC_DRAW);
              if (this.glattrbuffers[attrName] && this.glattrbuffers[attrName].buffer) {
                  gl.bindBuffer(gl.COPY_WRITE_BUFFER, attrBuffer);
                  gl.bindBuffer(gl.COPY_READ_BUFFER, this.glattrbuffers[attrName].buffer);
                  gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, this.glattrbuffers[attrName].numValues * attrSpec.elementSize);
                  gl.deleteBuffer(this.glattrbuffers[attrName].buffer);
              }
              this.glattrbuffers[attrName] = {
                  name: attrName,
                  elementSize: attrSpec.elementSize,
                  buffer: attrBuffer,
                  dataType: attrSpec.dataType,
                  normalized: attrSpec.normalized,
                  numValues: numValues,
                  dimension: attrSpec.dimension,
                  shared: false,
              };
          }
      }
      genIndicesBuffers() {
          // //////////////////////////////////////
          // Indices
          const reservedSpace = this.indicesAllocator.reservedSpace;
          if (this.numIndices != reservedSpace) {
              const gl = this.__gl;
              const indexBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
              const elementSize = 4; //  Uint32Array for UNSIGNED_INT
              const sizeInBytes = reservedSpace * elementSize;
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sizeInBytes, gl.STATIC_DRAW);
              if (this.indexBuffer) {
                  gl.bindBuffer(gl.COPY_WRITE_BUFFER, indexBuffer);
                  gl.bindBuffer(gl.COPY_READ_BUFFER, this.indexBuffer);
                  gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, this.numIndices * elementSize);
                  gl.deleteBuffer(this.indexBuffer);
              }
              this.indexBuffer = indexBuffer;
              this.numIndices = reservedSpace;
          }
      }
      /**
       * The uploadBuffers method.
       * @param index - The index of the geom to upload
       */
      uploadBuffers(index) {
          const gl = this.__gl;
          // Note: when we allocate the buffers, we may resize the buffer, which
          // means we need to re-upload geoms that were not changed.
          let geomBuffers = this.geomBuffersTmp[index];
          if (!geomBuffers) {
              const geom = this.geoms[index];
              if (!geom)
                  return;
              geomBuffers = geom.genBuffers();
              this.geomBuffersTmp[index] = geomBuffers;
          }
          const count = this.geomVertexCounts[index];
          const numVerts = geomBuffers.numRenderVerts ? geomBuffers.numRenderVerts : geomBuffers.numVertices;
          if (count != numVerts) {
              throw new Error('Invalid allocation for this geom');
          }
          if (numVerts == 0) {
              const event = new IndexEvent(index);
              this.emit('geomDataChanged', event);
              return;
          }
          // eslint-disable-next-line guard-for-in
          for (const attrName in geomBuffers.attrBuffers) {
              const attrSpec = this.shaderAttrSpec[attrName];
              const attrData = geomBuffers.attrBuffers[attrName];
              const glattrbuffer = this.glattrbuffers[attrName];
              // Some geoms might not have all the attributes.
              // and some geoms have more attributes than others.
              if (!attrData || !glattrbuffer)
                  continue;
              gl.bindBuffer(gl.ARRAY_BUFFER, glattrbuffer.buffer);
              const elementSize = attrSpec.elementSize;
              const offsetInBytes = this.geomVertexOffsets[index] * elementSize * attrSpec.dimension;
              const values = convertBuffer(gl, attrData, attrSpec);
              gl.bufferSubData(gl.ARRAY_BUFFER, offsetInBytes, values);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          // //////////////////////////////////////
          // Indices
          // Note: we sometimes see geometries with zero vertices/indices which means
          // no allocation has yet been made. We can safely skip these.
          if (geomBuffers.indices && geomBuffers.indices.length > 0) {
              const indices = geomBuffers.indices;
              const allocation = this.indicesAllocator.getAllocation(index);
              if (allocation.size != indices.length) {
                  throw new Error('Invalid allocation for this geom');
              }
              const attributesAllocation = this.attributesAllocator.getAllocation(index);
              // The indices need to be offset so they they index the new attributes array.
              const offsettedIndices = new Uint32Array(allocation.size);
              for (let i = 0; i < indices.length; i++) {
                  offsettedIndices[i] = geomBuffers.indices[i] + attributesAllocation.start;
              }
              const gl = this.__gl;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
              const elementSize = 4; //  Uint32Array
              const offsetInBytes = allocation.start * elementSize;
              gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offsetInBytes, offsettedIndices);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
          if (this.freeDataAfterUpload) {
              const geom = this.geoms[index];
              geom.freeBuffers();
          }
          this.emit('geomDataChanged', new IndexEvent(index));
      }
      /**
       * Cleans the state of this GeomSet during rendering.
       */
      cleanGeomBuffers() {
          // First we allocate all memory needed to clean the GeomSet,
          // and then we start uploading all the data.
          this.dirtyGeomIndices.forEach((index) => {
              this.allocateBuffers(index);
          });
          if (this.attributesBufferNeedsRealloc || this.indicesBufferNeedsRealloc) {
              // If the geom buffers are re-allocated, we need to regenerate
              // all the shader bindings.
              this.resetBindings();
              if (this.attributesBufferNeedsRealloc) {
                  this.genAttributesBuffers();
                  this.attributesBufferNeedsRealloc = false;
              }
              if (this.indicesBufferNeedsRealloc) {
                  this.genIndicesBuffers();
                  this.indicesBufferNeedsRealloc = false;
              }
              // console.log('GLGeomLibrary MemoryAllocation:', this.calcMemoryAllocation())
          }
          else if (this.attributesBufferNeedsAlloc.length > 0) {
              // Sometimes new attributes are added after the main attributes.
              // e.g. Normals could be computed.
              // We now need to generate those missing buffers.
              this.attributesBufferNeedsAlloc.forEach((attrName) => {
                  this.genAttributesBuffer(attrName);
              });
              this.attributesBufferNeedsAlloc = [];
          }
          this.dirtyGeomIndices.forEach((index) => {
              this.uploadBuffers(index);
          });
          this.dirtyGeomIndices = new Set();
      }
      calcMemoryAllocation() {
          const summary = { attrs: {}, indices: {} };
          const MB = 1 << 20;
          for (const attrName in this.shaderAttrSpec) {
              const attrSpec = this.shaderAttrSpec[attrName];
              const reservedSpace = this.attributesAllocator.reservedSpace;
              const allocatedSpace = this.attributesAllocator.allocatedSpace;
              const numValues = reservedSpace * attrSpec.dimension;
              const sizeInBytes = numValues * attrSpec.elementSize;
              summary.attrs[attrName] = {
                  count: allocatedSpace,
                  MB: sizeInBytes / MB,
              };
          }
          const reservedSpace = this.indicesAllocator.reservedSpace;
          const allocatedSpace = this.indicesAllocator.allocatedSpace;
          const elementSize = 4; //  Uint32Array for UNSIGNED_INT
          const sizeInBytes = reservedSpace * elementSize;
          summary.indices = {
              count: allocatedSpace,
              MB: sizeInBytes / MB,
          };
          return summary;
      }
      // /////////////////////////////////////
      // Binding
      resetBindings() {
          for (const shaderkey in this.shaderBindings) {
              const shaderBinding = this.shaderBindings[shaderkey];
              shaderBinding.destroy();
          }
          this.shaderBindings = {};
      }
      /**
       * The bind method.
       * @param renderstate - The renderstate value.
       * @return - Returns true if binding was successful
       */
      bind(renderstate) {
          if (this.dirtyGeomIndices.size > 0) {
              this.cleanGeomBuffers();
          }
          const shaderkey = renderstate.glShader.getId() + renderstate.shaderkey;
          let shaderBinding = this.shaderBindings[shaderkey];
          if (!shaderBinding) {
              const gl = this.__gl;
              shaderBinding = generateShaderGeomBinding(gl, renderstate.attrs, this.glattrbuffers, this.indexBuffer);
              this.shaderBindings[shaderkey] = shaderBinding;
              if (SystemDesc.browserName == 'Safari' && SystemDesc.fullVersion == '15.4') {
                  // Hack to force the primitive restart index cache to be dirty...
                  // https://bugs.webkit.org/show_bug.cgi?id=239015
                  // - First draw updates the indexType to be correct (invalid enum -> draw buffer element type)
                  const gl = this.__gl;
                  gl.drawElements(gl.POINTS, 1, gl.UNSIGNED_INT, 0);
                  gl.drawElements(gl.LINES, 2, gl.UNSIGNED_INT, 0);
                  gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_INT, 0);
                  // - dummy subbuffer update marks the cache dirty
                  // bufferSubData an array of size 1 at the end of the current allocation.
                  const dummyIndices = new Uint32Array(1);
                  const elementSize = 4; //  Uint32Array
                  const offsetInBytes = this.indicesAllocator.allocatedSpace * elementSize;
                  gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offsetInBytes, dummyIndices);
              }
          }
          else {
              shaderBinding.bind(renderstate);
          }
          return true;
      }
      /**
       * The unbind method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      unbind(renderstate) {
          // Unbinding a geom is important as it puts back some important
          // GL state. (vertexAttribDivisor)
          const shaderkey = renderstate.glShader.getId() + renderstate.shaderkey;
          const shaderBinding = this.shaderBindings[shaderkey];
          if (shaderBinding) {
              shaderBinding.unbind(renderstate);
          }
      }
      // /////////////////////////////////////
      // Drawing
      /**
       * The clearBuffers method.
       */
      clearBuffers() {
          const gl = this.__gl;
          // eslint-disable-next-line guard-for-in
          for (const attrName in this.glattrbuffers) {
              const glbuffer = this.glattrbuffers[attrName];
              if (glbuffer.shared)
                  continue; /* This buffer is shared between geoms. do not destroy */
              gl.deleteBuffer(glbuffer.buffer);
          }
          this.glattrbuffers = {};
          if (this.indexBuffer) {
              gl.deleteBuffer(this.indexBuffer);
              this.indexBuffer = null;
          }
          // eslint-disable-next-line guard-for-in
          this.resetBindings();
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          // this.geoms.forEach((geom) => this.removeGeom(geom))
          this.clearBuffers();
          this.__destroyed = true;
          //  Note: PoTree listens to this event. If moved up into RefCounted, make sure it is still emitted.
          this.emit('destructing');
      }
  }

  const GLGeomItemChangeType = {
      GEOMITEM_CHANGED: 0,
      GEOM_CHANGED: 1,
      VISIBILITY_CHANGED: 2,
      HIGHLIGHT_CHANGED: 3,
  };
  const GLGeomItemFlags = {
      GEOMITEM_FLAG_CUTAWAY: 2,
      GEOMITEM_INVISIBLE_IN_GEOMDATA: 4,
      GEOMITEM_TRANSPARENT: 8, // 1<<3;
  };
  /** This class is responsible for managing a GeomItem within the renderer.
   * @private
   * @extends EventEmitter
   */
  class GLGeomItem extends EventEmitter {
      listenerIDs = {};
      // //referenced by other classes
      GLGeomItemSet;
      GLShaderGeomSets;
      gl;
      geomItem;
      geomItemId;
      geomId;
      materialId;
      supportInstancing;
      visible;
      shattered = false;
      culled = false;
      geomMatrixDirty = false;
      modelMatrixArray;
      geomData = [];
      highlightSubIndex = -1;
      /**
       * Create a GL geom item.
       * @param gl - The gl value.
       * @param geomItem - The geomItem value.
       * @param geomItemId - The geomItemId value.
       * @param geomId - The geomId value.
       * @param materialId - The materialId value.
       * @param supportInstancing - a boolean to disable instancing support on some mobile platforms
       */
      constructor(gl, geomItem, geomItemId, geomId, materialId, supportInstancing = false) {
          super();
          this.gl = gl;
          this.geomItem = geomItem;
          this.geomItemId = geomItemId;
          this.geomId = geomId;
          this.materialId = materialId;
          this.supportInstancing = supportInstancing;
          this.visible = this.geomItem.isVisible();
          this.listenerIDs['visibilityChanged'] = this.geomItem.on('visibilityChanged', (event) => {
              const wasVisible = !this.culled && this.visible;
              this.visible = event.visible;
              const isVisible = !this.culled && this.visible;
              if (wasVisible != isVisible) {
                  this.emit('visibilityChanged', new VisibilityChangedEvent(isVisible));
              }
          });
          if (geomItem instanceof CADBody)
              this.shattered = geomItem.shattered;
          this.listenerIDs['shatterStateChanged'] = this.geomItem.on('shatterStateChanged', (event) => {
              this.shattered = event.state;
              this.emit('shatterStateChanged', event);
          });
          if (!this.supportInstancing) {
              const highlightChanged = (event) => {
                  if (event.name) {
                      const highlightName = event.name;
                      const subGeomIndexIndex = highlightName.indexOf(':');
                      let subGeomIndices = [];
                      if (subGeomIndexIndex != -1) {
                          subGeomIndices = highlightName
                              .substring(subGeomIndexIndex + 1)
                              .split(',')
                              .map((v) => Number.parseInt(v));
                          this.highlightSubIndex = subGeomIndices[0];
                      }
                  }
                  else {
                      this.highlightSubIndex = -1;
                  }
              };
              this.listenerIDs['highlightChanged'] = this.geomItem.on('highlightChanged', highlightChanged);
          }
      }
      /**
       * The isVisible method.
       * @return - The return value.
       */
      isVisible() {
          return !this.culled && this.visible;
      }
      /**
       * Sets the additional culled value which controls visiblity
       * @param culled - True if culled, else false.
       */
      setCulled(culled) {
          const wasVisible = !this.culled && this.visible;
          this.culled = culled;
          const isVisible = !this.culled && this.visible;
          if (wasVisible != isVisible) {
              this.emit('visibilityChanged', new VisibilityChangedEvent(isVisible));
          }
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      bind(renderstate) {
          const gl = this.gl;
          const { highlightSubIndex, geomItemId } = renderstate.unifs;
          if (highlightSubIndex) {
              gl.uniform1i(highlightSubIndex.location, this.highlightSubIndex);
          }
          if (geomItemId) {
              gl.uniform1i(geomItemId.location, this.geomItemId);
          }
          return true;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          this.geomItem.off('visibilityChanged', this.listenerIDs['visibilityChanged']);
          if (!this.supportInstancing) {
              this.geomItem.off('highlightChanged', this.listenerIDs['highlightChanged']);
          }
      }
  }

  // eslint-disable-next-line require-jsdoc
  class ReductionShader extends GLShader {
      /**
       * Create an atlas layout shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'ReductionShader');
          this.setShaderStage('VERTEX_SHADER', `

precision highp float;

uniform int reductionTextureWidth;
uniform sampler2D geomDataTexture;

ivec2 texelCoordFromVertexId(){
  ivec2 texSize = textureSize(geomDataTexture, 0);
  return ivec2(
    gl_VertexID % texSize.x, 
    gl_VertexID / texSize.x
    );
}

vec2 pointPositionFromGeomItemId(int geomItemId){
  vec2 result = vec2(
    (float(geomItemId % reductionTextureWidth) + 0.5) / float(reductionTextureWidth), 
    (float(geomItemId / reductionTextureWidth) + 0.5) / float(reductionTextureWidth)
    );
  return vec2(-1.0, -1.0) + (result * 2.0);
}

void main()
{
  // Get the texel coordinate in the source geomdata buffer.
  // there is one point for every pixel in the geomdata texture.
  ivec2 texelCoord = texelCoordFromVertexId();
  int geomItemId = int(texelFetch(geomDataTexture, texelCoord, 0).g + 0.5);

  if (geomItemId > 0) {
    vec2 position = pointPositionFromGeomItemId(geomItemId);
    gl_Position = vec4(position, 0.0, 1.0);
    gl_PointSize = 1.0;
  } else {
    // Move it off screen
    gl_Position = vec4(-2.0, -2.0, 0.0, 1.0);
    gl_PointSize = 0.0;
  }
}

`);
          this.setShaderStage('FRAGMENT_SHADER', `
precision highp float;

#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif

void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  fragColor = vec4(1.0, 1.0, 1.0, 1.0);

#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}

`);
      }
  }

  var frag$g = "\nprecision highp float;\n#define GLSLIFY 1\n\n/* VS Outputs */\nvarying vec4 v_color;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int drawItemId = int(v_color.g);\n  fragColor = v_color;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$h = "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec4 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\n\nuniform highp int occlusionCulling;\nuniform sampler2D reductionDataTexture;\n\nimport 'transpose.glsl'\nimport 'GLSLUtils.glsl'\nimport 'stack-gl/transpose.glsl'\nimport 'stack-gl/inverse.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nconst int GEOMITEM_INVISIBLE_IN_GEOMDATA = 2; // 1<<1;\n\n/* VS Outputs */\nvarying vec4 v_color;\n\nvoid main(void) {\n\n  int drawItemId = getGeomItemId();\n  vec4 geomItemData  = getInstanceData(drawItemId);\n  int flags = int(geomItemData.r + 0.5);\n\n  if (occlusionCulling != 0) {\n    // Check if in the reduction texture, this item is already flagged as visible.\n    // Note: we only draw bboxes for those that have been flagged as invisible, but might\n    // be just off screen, or onscreen, but were culled in the previous update.\n    int isVisible = int(fetchTexel(reductionDataTexture, textureSize(reductionDataTexture, 0), drawItemId).r);\n    if (isVisible > 0) {\n      return;\n    }\n  }\n\n  vec4 bboxMin = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 6);\n  vec4 bboxMax = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 7);\n  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\n\n  if (occlusionCulling != 0) {\n    // TODO: The bounding box stochastic\n    v_color = vec4(0.0, float(drawItemId), 0.0, 1.0);\n  } else {\n    v_color = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 4);\n  }\n\n  vec4 pos = positions;\n  if (pos.x < 0.0) pos.x = bboxMin.x;\n  else if (pos.x > 0.0) pos.x = bboxMax.x;\n  if (pos.y < 0.0) pos.y = bboxMin.y;\n  else if (pos.y > 0.0) pos.y = bboxMax.y;\n  if (pos.z < 0.0) pos.z = bboxMin.z;\n  else if (pos.z > 0.0) pos.z = bboxMax.z;\n\n  gl_Position = viewProjectionMatrix * pos;\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class BoundingBoxShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'BoundingBoxShader');
          this.setShaderStage('VERTEX_SHADER', vert$h);
          this.setShaderStage('FRAGMENT_SHADER', frag$g);
      }
  }

  var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAndXNlIHN0cmljdCc7CgogIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqLw0KICBjb25zdCB2ZWMzX3N1YnRyYWN0ID0gKHZlYzEsIHZlYzIpID0+IHsNCiAgICByZXR1cm4gW3ZlYzFbMF0gLSB2ZWMyWzBdLCB2ZWMxWzFdIC0gdmVjMlsxXSwgdmVjMVsyXSAtIHZlYzJbMl1dDQogIH07DQogIGNvbnN0IHZlYzNfbGVuZ3RoID0gKHZlYykgPT4gew0KICAgIHJldHVybiBNYXRoLnNxcnQodmVjWzBdICogdmVjWzBdICsgdmVjWzFdICogdmVjWzFdICsgdmVjWzJdICogdmVjWzJdKQ0KICB9Ow0KICBjb25zdCB2ZWMyX3NjYWxlID0gKHZlYywgc2NsKSA9PiB7DQogICAgcmV0dXJuIFt2ZWNbMF0gKiBzY2wsIHZlY1sxXSAqIHNjbF0NCiAgfTsNCiAgY29uc3QgdmVjMl9sZW5ndGggPSAodmVjKSA9PiB7DQogICAgcmV0dXJuIE1hdGguc3FydCh2ZWNbMF0gKiB2ZWNbMF0gKyB2ZWNbMV0gKiB2ZWNbMV0pDQogIH07DQoNCiAgY29uc3QgcXVhdF9jb25qdWdhdGUgPSAocXVhdCkgPT4gew0KICAgIHJldHVybiBbLXF1YXRbMF0sIC1xdWF0WzFdLCAtcXVhdFsyXSwgcXVhdFszXV0NCiAgfTsNCiAgY29uc3QgcXVhdF9tdWx0aXBseSA9IChxdWF0MSwgcXVhdDIpID0+IHsNCiAgICBjb25zdCBheCA9IHF1YXQxWzBdOw0KICAgIGNvbnN0IGF5ID0gcXVhdDFbMV07DQogICAgY29uc3QgYXogPSBxdWF0MVsyXTsNCiAgICBjb25zdCBhdyA9IHF1YXQxWzNdOw0KICAgIGNvbnN0IGJ4ID0gcXVhdDJbMF07DQogICAgY29uc3QgYnkgPSBxdWF0MlsxXTsNCiAgICBjb25zdCBieiA9IHF1YXQyWzJdOw0KICAgIGNvbnN0IGJ3ID0gcXVhdDJbM107DQoNCiAgICByZXR1cm4gWw0KICAgICAgYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSwNCiAgICAgIGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosDQogICAgICBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LA0KICAgICAgYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBieiwNCiAgICBdDQogIH07DQogIGNvbnN0IHF1YXRfcm90YXRlVmVjMyA9IChxdWF0LCB2ZWMzKSA9PiB7DQogICAgY29uc3QgdnEgPSBbdmVjM1swXSwgdmVjM1sxXSwgdmVjM1syXSwgMC4wXTsNCiAgICBjb25zdCBwcSA9IHF1YXRfbXVsdGlwbHkocXVhdF9tdWx0aXBseShxdWF0LCB2cSksIHF1YXRfY29uanVnYXRlKHF1YXQpKTsNCiAgICByZXR1cm4gW3BxWzBdLCBwcVsxXSwgcHFbMl1dDQogIH07DQoNCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8NCiAgLy8gRnJ1c3R1bSBDdWxsaW5nIGRhdGEuDQogIGxldCBlbmFibGVPY2NsdXNpb25DdWxsaW5nID0gZmFsc2U7DQogIGNvbnN0IGdlb21JdGVtc0RhdGEgPSBbXTsNCiAgY29uc3Qgb3V0T2ZGcnVzdHVtID0gW107DQogIGxldCBmcnVzdHVtQ3VsbGVkQ291bnQgPSAwOw0KICBsZXQgbmV3bHlDdWxsZWQgPSBbXTsNCiAgbGV0IG5ld2x5VW5DdWxsZWQgPSBbXTsNCg0KICBsZXQgdmlzaWJsZUNvdW50ID0gMDsNCiAgY29uc3QgdG90YWxHZW9tU3RhdHMgPSB7DQogICAgdHJpYW5nbGVzOiAwLA0KICAgIGxpbmVzOiAwLA0KICAgIHBvaW50czogMCwNCiAgfTsNCiAgY29uc3QgdmlzaWJsZUdlb21TdGF0cyA9IHsNCiAgICB0cmlhbmdsZXM6IDAsDQogICAgbGluZXM6IDAsDQogICAgcG9pbnRzOiAwLA0KICB9Ow0KICBjb25zdCBnZW9tU3RhdHNfYWRkVG90YWwgPSAoZ2VvbVN0YXRzKSA9PiB7DQogICAgLy8gY29uc29sZS5sb2coJ2dlb21TdGF0c19hZGQ6JywgZ2VvbVN0YXRzLnRyaWFuZ2xlcywgdmlzaWJsZUdlb21TdGF0cy50cmlhbmdsZXMpDQogICAgdG90YWxHZW9tU3RhdHMudHJpYW5nbGVzICs9IGdlb21TdGF0cy50cmlhbmdsZXM7DQogICAgdG90YWxHZW9tU3RhdHMubGluZXMgKz0gZ2VvbVN0YXRzLmxpbmVzOw0KICAgIHRvdGFsR2VvbVN0YXRzLnBvaW50cyArPSBnZW9tU3RhdHMucG9pbnRzOw0KICB9Ow0KICBjb25zdCBnZW9tU3RhdHNfc3VidHJhY3RUb3RhbCA9IChnZW9tU3RhdHMpID0+IHsNCiAgICAvLyBjb25zb2xlLmxvZygnZ2VvbVN0YXRzX3N1YnRyYWN0OicsIGdlb21TdGF0cy50cmlhbmdsZXMsIHZpc2libGVHZW9tU3RhdHMudHJpYW5nbGVzKQ0KICAgIHRvdGFsR2VvbVN0YXRzLnRyaWFuZ2xlcyAtPSBnZW9tU3RhdHMudHJpYW5nbGVzOw0KICAgIHRvdGFsR2VvbVN0YXRzLmxpbmVzIC09IGdlb21TdGF0cy5saW5lczsNCiAgICB0b3RhbEdlb21TdGF0cy5wb2ludHMgLT0gZ2VvbVN0YXRzLnBvaW50czsNCiAgfTsNCiAgY29uc3QgZ2VvbVN0YXRzX2FkZCA9IChnZW9tU3RhdHMpID0+IHsNCiAgICAvLyBjb25zb2xlLmxvZygnZ2VvbVN0YXRzX2FkZDonLCBnZW9tU3RhdHMudHJpYW5nbGVzLCB2aXNpYmxlR2VvbVN0YXRzLnRyaWFuZ2xlcykNCiAgICB2aXNpYmxlQ291bnQrKzsNCiAgICB2aXNpYmxlR2VvbVN0YXRzLnRyaWFuZ2xlcyArPSBnZW9tU3RhdHMudHJpYW5nbGVzOw0KICAgIHZpc2libGVHZW9tU3RhdHMubGluZXMgKz0gZ2VvbVN0YXRzLmxpbmVzOw0KICAgIHZpc2libGVHZW9tU3RhdHMucG9pbnRzICs9IGdlb21TdGF0cy5wb2ludHM7DQogIH07DQogIGNvbnN0IGdlb21TdGF0c19zdWJ0cmFjdCA9IChnZW9tU3RhdHMpID0+IHsNCiAgICAvLyBjb25zb2xlLmxvZygnZ2VvbVN0YXRzX3N1YnRyYWN0OicsIGdlb21TdGF0cy50cmlhbmdsZXMsIHZpc2libGVHZW9tU3RhdHMudHJpYW5nbGVzKQ0KICAgIHZpc2libGVDb3VudC0tOw0KICAgIHZpc2libGVHZW9tU3RhdHMudHJpYW5nbGVzIC09IGdlb21TdGF0cy50cmlhbmdsZXM7DQogICAgdmlzaWJsZUdlb21TdGF0cy5saW5lcyAtPSBnZW9tU3RhdHMubGluZXM7DQogICAgdmlzaWJsZUdlb21TdGF0cy5wb2ludHMgLT0gZ2VvbVN0YXRzLnBvaW50czsNCiAgfTsNCg0KICBsZXQgY2FtZXJhUG9zOw0KICBsZXQgY2FtZXJhSW52T3JpOw0KICBsZXQgaXNPcnRob2dyYXBoaWMgPSBmYWxzZTsNCiAgbGV0IGZydXN0dW1IZWlnaHQgPSAwOw0KICBsZXQgZnJ1c3R1bVdpZHRoID0gMDsNCiAgbGV0IGZydXN0dW1IYWxmQW5nbGVYID0gMDsNCiAgbGV0IGZydXN0dW1IYWxmQW5nbGVZID0gMDsNCiAgbGV0IHNvbGlkQW5nbGVMaW1pdCA9IDAuMDA0Ow0KDQogIGNvbnN0IGN1bGwgPSAoaW5kZXgpID0+IHsNCiAgICBpZiAoIW91dE9mRnJ1c3R1bVtpbmRleF0pIHsNCiAgICAgIG91dE9mRnJ1c3R1bVtpbmRleF0gPSB0cnVlOw0KICAgICAgZnJ1c3R1bUN1bGxlZENvdW50Kys7DQogICAgICBuZXdseUN1bGxlZC5wdXNoKGluZGV4KTsNCg0KICAgICAgLy8gV2UgY291bGQgYmUgY3VsbGluZyBzb21ldGhpbmcgdGhhdCB3YXMgYWxyZWFkeQ0KICAgICAgLy8gbm90IHZpc2libGUgaW4gdGhlIG9jY2x1c2lvbiBidWZmZXIuDQogICAgICBpZiAoIWVuYWJsZU9jY2x1c2lvbkN1bGxpbmcgfHwgIW9jY2x1ZGVkW2luZGV4XSkgew0KICAgICAgICBnZW9tU3RhdHNfc3VidHJhY3QoZ2VvbUl0ZW1zRGF0YVtpbmRleF0uZ2VvbVN0YXRzKTsNCiAgICAgIH0NCiAgICB9DQogIH07DQogIGNvbnN0IHVuQ3VsbCA9IChpbmRleCkgPT4gew0KICAgIGlmIChvdXRPZkZydXN0dW1baW5kZXhdKSB7DQogICAgICBvdXRPZkZydXN0dW1baW5kZXhdID0gZmFsc2U7DQogICAgICBmcnVzdHVtQ3VsbGVkQ291bnQtLTsNCiAgICAgIG5ld2x5VW5DdWxsZWQucHVzaChpbmRleCk7DQoNCiAgICAgIC8vIE9jY2x1c2lvbiBjdWxsaW5nIGNhbiBvbmx5IGRldGVybWluZSBpZiBzb21ldGhpbmcgaXMgdmlzaWJsZQ0KICAgICAgLy8gbWVhbmluZyB0aGF0IHdlIGFzc3VtZSBpdCBpcyBub3QsIHVudGlsIGl0IHNob3dzIHVwIGluIHRoZSBvY2NsdXNpb24gYnVmZmVyLg0KICAgICAgLy8gT25jZSBpdCBhcHBlYXJzIGluIHRoZSBvY2NsdXNpb24gYnVmZmVyLCB3ZSBzdGFydCByZW5kZXJpbmcgaXQgYWdhaW4uDQogICAgICAvLyBTbywgd2hlbiBhbiBpdGVtIGNvbWVzIGJhY2sgaW50byB0aGUgZnJ1c3R1bSwgd2Ugc3RhcnQgcmVuZGVyaW5nIGl0cyBiYm94Lg0KICAgICAgLy8gVGhlbiBpZiB0aGUgYmJveCBpcyBzZWVuLCB3ZSB0aGVuIHN0YXJ0IHNob3dpbmcgaXQuDQogICAgICBpZiAoZW5hYmxlT2NjbHVzaW9uQ3VsbGluZyAmJiAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udHJhbnNwYXJlbnQpIHsNCiAgICAgICAgb2NjbHVkZWRbaW5kZXhdID0gdHJ1ZTsNCiAgICAgIH0gZWxzZSB7DQogICAgICAgIGdlb21TdGF0c19hZGQoZ2VvbUl0ZW1zRGF0YVtpbmRleF0uZ2VvbVN0YXRzKTsNCiAgICAgIH0NCiAgICB9DQogIH07DQoNCiAgY29uc3QgY2hlY2tHZW9tSXRlbSA9IChnZW9tSXRlbURhdGEpID0+IHsNCiAgICBpZiAoIWdlb21JdGVtRGF0YSB8fCAhY2FtZXJhUG9zKSByZXR1cm4NCiAgICBpZiAoIWdlb21JdGVtRGF0YS52aXNpYmxlKSB7DQogICAgICByZXR1cm4NCiAgICB9DQoNCiAgICAvLyBTb21lIGl0ZW1zLCBsaWtlIEhhbmRsZXMgYW5kIHRoZSBncmlkLCBvciBvciB0aGUgVlIgY29udHJvbGxlcnMgdGhhdCBzaG91bGQgbm90IGJlIGN1bGxlZC4NCiAgICBpZiAoIWdlb21JdGVtRGF0YS5jdWxsYWJsZSkgew0KICAgICAgdW5DdWxsKGdlb21JdGVtRGF0YS5pZCk7DQogICAgICByZXR1cm4NCiAgICB9DQogICAgY29uc3QgYm91bmRpbmdSYWRpdXMgPSBnZW9tSXRlbURhdGEuYm91bmRpbmdSYWRpdXM7DQoNCiAgICBpZiAoaXNPcnRob2dyYXBoaWMpIHsNCiAgICAgIC8vIEN1bGwgdmVyeSBzbWFsbCBpdGVtcw0KICAgICAgLy8gTm90ZTogd2hlbiBpbiBWUiwgdGhlIEZvViBiZWNvbWVzIHZlcnkgd2lkZSBhbmQgdGhlIHBpeGVsDQogICAgICAvLyBoZWlnaHQgdmFyaWVzLiBJdCBzZWVtcyBtb3JlIGNvbnNpc3RlbnQgdG8ganVzdCB1c2Ugc29saWRBbmdsZQ0KICAgICAgLy8gd2hpY2ggaXMgcmVzb2x1dGlvbiBpbnZhcmlhbnQuDQogICAgICBjb25zdCB2aGVpZ2h0ID0gYm91bmRpbmdSYWRpdXMgLyBmcnVzdHVtSGVpZ2h0Ow0KICAgICAgaWYgKHNvbGlkQW5nbGVMaW1pdCA+IDAgJiYgdmhlaWdodCA8IHNvbGlkQW5nbGVMaW1pdCkgew0KICAgICAgICBjdWxsKGdlb21JdGVtRGF0YS5pZCk7DQogICAgICAgIHJldHVybg0KICAgICAgfQ0KDQogICAgICAvLyBOb3cgd2UgY2hlY2sgaWYgdGhlIGl0ZW0gaXMgd2l0aGluIHRoZSB2aWV3IGZydXN0dW0uDQogICAgICAvLyBXZSBuZWVkIHRoZSBzb2xpZCBhbmdsZSBvZiB0aGUgaXRlbSBmb3IgZWFjaCBheGlzIChYICYgWSkNCiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBhdCB0aGUgY29ybmVycyBvZiB0aGUgc2NyZWVuLCB0aGUgb2JqZWN0IGlzIHNsaWdodGx5DQogICAgICAvLyBmdXJ0aGVyIGF3YXksIHNvIHRoZSBzb2xpZCBhbmdsZSBjYWxjdWxhdGVkIGFib3ZlIGdldHMgc21hbGxlci4NCiAgICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgaXRlbXMgd2l0aCBiaWcgYm91bmRpbmcgc3BoZXJlcyB0byBiZSBjdWxsZWQgdG9vIGVhcmx5DQogICAgICAvLyBhdCB0aGUgY29ybmVyIG9mIHRoZSBzY3JlZW4uDQogICAgICBjb25zdCB2ZWMgPSB2ZWMzX3N1YnRyYWN0KGdlb21JdGVtRGF0YS5wb3MsIGNhbWVyYVBvcyk7DQogICAgICBjb25zdCB2aWV3UG9zID0gcXVhdF9yb3RhdGVWZWMzKGNhbWVyYUludk9yaSwgdmVjKTsNCiAgICAgIGlmICgNCiAgICAgICAgTWF0aC5hYnModmlld1Bvc1swXSkgLSBib3VuZGluZ1JhZGl1cyA+IGZydXN0dW1XaWR0aCAqIDAuNSB8fA0KICAgICAgICBNYXRoLmFicyh2aWV3UG9zWzFdKSAtIGJvdW5kaW5nUmFkaXVzID4gZnJ1c3R1bUhlaWdodCAqIDAuNQ0KICAgICAgKSB7DQogICAgICAgIGN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsNCiAgICAgICAgcmV0dXJuDQogICAgICB9DQogICAgfSBlbHNlIHsNCiAgICAgIGNvbnN0IHZlYyA9IHZlYzNfc3VidHJhY3QoZ2VvbUl0ZW1EYXRhLnBvcywgY2FtZXJhUG9zKTsNCiAgICAgIGNvbnN0IGRpc3QgPSB2ZWMzX2xlbmd0aCh2ZWMpOw0KICAgICAgLy8gdW5DdWxsIGl0ZW1zIGNsb3NlIHRvIHRoZSB2aWV3Lg0KICAgICAgaWYgKGRpc3QgPCBib3VuZGluZ1JhZGl1cykgew0KICAgICAgICB1bkN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsNCiAgICAgICAgcmV0dXJuDQogICAgICB9DQogICAgICAvLyBDdWxsIHZlcnkgc21hbGwgaXRlbXMNCiAgICAgIC8vIE5vdGU6IHdoZW4gaW4gVlIsIHRoZSBGb1YgYmVjb21lcyB2ZXJ5IHdpZGUgYW5kIHRoZSBwaXhlbA0KICAgICAgLy8gaGVpZ2h0IHZhcmllcy4gSXQgc2VlbXMgbW9yZSBjb25zaXN0ZW50IHRvIGp1c3QgdXNlIHNvbGlkQW5nbGUNCiAgICAgIC8vIHdoaWNoIGlzIHJlc29sdXRpb24gaW52YXJpYW50Lg0KICAgICAgY29uc3Qgc29saWRBbmdsZSA9IE1hdGguYXNpbihib3VuZGluZ1JhZGl1cyAvIGRpc3QpOw0KICAgICAgaWYgKHNvbGlkQW5nbGVMaW1pdCA+IDAgJiYgc29saWRBbmdsZSA8IHNvbGlkQW5nbGVMaW1pdCkgew0KICAgICAgICBjdWxsKGdlb21JdGVtRGF0YS5pZCk7DQogICAgICAgIHJldHVybg0KICAgICAgfQ0KDQogICAgICAvLyBOb3cgd2UgY2hlY2sgaWYgdGhlIGl0ZW0gaXMgd2l0aGluIHRoZSB2aWV3IGZydXN0dW0uDQogICAgICAvLyBXZSBuZWVkIHRoZSBzb2xpZCBhbmdsZSBvZiB0aGUgaXRlbSBmb3IgZWFjaCBheGlzIChYICYgWSkNCiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBhdCB0aGUgY29ybmVycyBvZiB0aGUgc2NyZWVuLCB0aGUgb2JqZWN0IGlzIHNsaWdodGx5DQogICAgICAvLyBmdXJ0aGVyIGF3YXksIHNvIHRoZSBzb2xpZCBhbmdsZSBjYWxjdWxhdGVkIGFib3ZlIGdldHMgc21hbGxlci4NCiAgICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgaXRlbXMgd2l0aCBiaWcgYm91bmRpbmcgc3BoZXJlcyB0byBiZSBjdWxsZWQgdG9vIGVhcmx5DQogICAgICAvLyBhdCB0aGUgY29ybmVyIG9mIHRoZSBzY3JlZW4uDQogICAgICBjb25zdCB2aWV3UG9zID0gcXVhdF9yb3RhdGVWZWMzKGNhbWVyYUludk9yaSwgdmVjKTsNCiAgICAgIGNvbnN0IHZpZXdWZWNYWiA9IFt2aWV3UG9zWzBdLCB2aWV3UG9zWzJdXTsNCiAgICAgIGNvbnN0IHZpZXdWZWNZWiA9IFt2aWV3UG9zWzFdLCB2aWV3UG9zWzJdXTsNCiAgICAgIGNvbnN0IGRpc3RYID0gdmVjMl9sZW5ndGgodmlld1ZlY1haKTsNCiAgICAgIGNvbnN0IGRpc3RZID0gdmVjMl9sZW5ndGgodmlld1ZlY1laKTsNCiAgICAgIGNvbnN0IHNvbGlkQW5nbGVYWiA9IE1hdGguYXNpbihib3VuZGluZ1JhZGl1cyAvIGRpc3RYKTsNCiAgICAgIGNvbnN0IHNvbGlkQW5nbGVZWiA9IE1hdGguYXNpbihib3VuZGluZ1JhZGl1cyAvIGRpc3RZKTsNCiAgICAgIGNvbnN0IHZpZXdWZWNOb3JtWFogPSB2ZWMyX3NjYWxlKHZpZXdWZWNYWiwgMSAvIGRpc3RYKTsNCiAgICAgIGNvbnN0IHZpZXdWZWNOb3JtWVogPSB2ZWMyX3NjYWxlKHZpZXdWZWNZWiwgMSAvIGRpc3RZKTsNCg0KICAgICAgbGV0IHZpZXdBbmdsZTsNCiAgICAgIC8vIElmIGFuIGl0ZW0gaXMgYmVoaW5kIHRoZSB2aWV3ZXINCiAgICAgIGlmICh2aWV3UG9zWzJdID4gMCkgew0KICAgICAgICB2aWV3QW5nbGUgPSBbDQogICAgICAgICAgTWF0aC5QSSAtIE1hdGguYWJzKE1hdGguYXNpbih2aWV3VmVjTm9ybVhaWzBdKSkgLSBzb2xpZEFuZ2xlWFosDQogICAgICAgICAgTWF0aC5QSSAtIE1hdGguYWJzKE1hdGguYXNpbih2aWV3VmVjTm9ybVlaWzBdKSkgLSBzb2xpZEFuZ2xlWVosDQogICAgICAgIF07DQogICAgICB9IGVsc2Ugew0KICAgICAgICB2aWV3QW5nbGUgPSBbDQogICAgICAgICAgTWF0aC5hYnMoTWF0aC5hc2luKHZpZXdWZWNOb3JtWFpbMF0pKSAtIHNvbGlkQW5nbGVYWiwNCiAgICAgICAgICBNYXRoLmFicyhNYXRoLmFzaW4odmlld1ZlY05vcm1ZWlswXSkpIC0gc29saWRBbmdsZVlaLA0KICAgICAgICBdOw0KICAgICAgfQ0KICAgICAgLy8gY29uc29sZS5sb2coZ2VvbUl0ZW1EYXRhLmlkLCAnYW5nbGUgVG8gSXRlbTonLCBmcnVzdHVtSGFsZkFuZ2xlWCwgdmlld0FuZ2xlWzBdLCBmcnVzdHVtSGFsZkFuZ2xlWSwgdmlld0FuZ2xlWzFdKQ0KICAgICAgaWYgKHZpZXdBbmdsZVswXSA+IGZydXN0dW1IYWxmQW5nbGVYIHx8IHZpZXdBbmdsZVsxXSA+IGZydXN0dW1IYWxmQW5nbGVZKSB7DQogICAgICAgIGN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsNCiAgICAgICAgcmV0dXJuDQogICAgICB9DQogICAgfQ0KDQogICAgdW5DdWxsKGdlb21JdGVtRGF0YS5pZCk7DQogIH07DQoNCiAgY29uc3Qgb25WaWV3UG9ydENoYW5nZWQgPSAoZGF0YSwgcG9zdE1lc3NhZ2UpID0+IHsNCiAgICBpZiAoZGF0YS5pc09ydGhvZ3JhcGhpYykgew0KICAgICAgaXNPcnRob2dyYXBoaWMgPSB0cnVlOw0KICAgICAgZnJ1c3R1bUhlaWdodCA9IGRhdGEuZnJ1c3R1bUhlaWdodDsNCiAgICAgIGZydXN0dW1XaWR0aCA9IGRhdGEuZnJ1c3R1bVdpZHRoOw0KICAgIH0gZWxzZSB7DQogICAgICBpc09ydGhvZ3JhcGhpYyA9IGZhbHNlOw0KICAgICAgZnJ1c3R1bUhhbGZBbmdsZVggPSBkYXRhLmZydXN0dW1IYWxmQW5nbGVYOw0KICAgICAgZnJ1c3R1bUhhbGZBbmdsZVkgPSBkYXRhLmZydXN0dW1IYWxmQW5nbGVZOw0KICAgIH0NCg0KICAgIHNvbGlkQW5nbGVMaW1pdCA9IGRhdGEuc29saWRBbmdsZUxpbWl0Ow0KICAgIGlmIChjYW1lcmFQb3MgJiYgY2FtZXJhSW52T3JpKSB7DQogICAgICBnZW9tSXRlbXNEYXRhLmZvckVhY2goY2hlY2tHZW9tSXRlbSk7DQogICAgICBvbkRvbmVGcnVzdHVtQ3VsbChwb3N0TWVzc2FnZSk7DQogICAgfQ0KICB9Ow0KDQogIGNvbnN0IG9uVmlld0NoYW5nZWQgPSAoZGF0YSwgcG9zdE1lc3NhZ2UpID0+IHsNCiAgICBjYW1lcmFQb3MgPSBkYXRhLmNhbWVyYVBvczsNCiAgICBjYW1lcmFJbnZPcmkgPSBxdWF0X2Nvbmp1Z2F0ZShkYXRhLmNhbWVyYU9yaSk7DQogICAgc29saWRBbmdsZUxpbWl0ID0gZGF0YS5zb2xpZEFuZ2xlTGltaXQ7DQogICAgaWYgKGdlb21JdGVtc0RhdGEubGVuZ3RoID4gMCkgew0KICAgICAgZ2VvbUl0ZW1zRGF0YS5mb3JFYWNoKGNoZWNrR2VvbUl0ZW0pOw0KICAgICAgb25Eb25lRnJ1c3R1bUN1bGwocG9zdE1lc3NhZ2UpOw0KICAgIH0NCiAgfTsNCg0KICBsZXQgaW5GcnVzdHVtRHJhd0lkc0J1ZmZlclBvcHVsYXRlZCA9IGZhbHNlOw0KICBjb25zdCBnZW5lcmF0ZUluRnJ1c3R1bUluZGljZXMgPSAoKSA9PiB7DQogICAgbGV0IG9mZnNldCA9IDA7DQogICAgb3V0T2ZGcnVzdHVtLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gew0KICAgICAgaWYgKGluZGV4ID4gMCAmJiAhdmFsdWUgJiYgZ2VvbUl0ZW1zRGF0YVtpbmRleF0udmlzaWJsZSAmJiAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udHJhbnNwYXJlbnQpIG9mZnNldCsrOw0KICAgIH0pOw0KICAgIC8vIENyZWF0ZSBhIGZsb2F0IGFycmF5IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gaW5zdGFuY2VzDQogICAgLy8gYXR0cmlidXRlIHRvIHBhc3MgaW50byB0aGUgZHJhd2luZyBvZiB0aGUgYm91bmRpbmcgYm94ZXMuDQogICAgY29uc3QgaW5GcnVzdHVtSW5kaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0KTsNCiAgICBvZmZzZXQgPSAwOw0KICAgIG91dE9mRnJ1c3R1bS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHsNCiAgICAgIGlmIChpbmRleCA+IDAgJiYgIXZhbHVlICYmIGdlb21JdGVtc0RhdGFbaW5kZXhdLnZpc2libGUgJiYgIWdlb21JdGVtc0RhdGFbaW5kZXhdLnRyYW5zcGFyZW50KSB7DQogICAgICAgIGluRnJ1c3R1bUluZGljZXNbb2Zmc2V0XSA9IGluZGV4Ow0KICAgICAgICBvZmZzZXQrKzsNCiAgICAgIH0NCiAgICB9KTsNCiAgICByZXR1cm4gaW5GcnVzdHVtSW5kaWNlcw0KICB9Ow0KDQogIGNvbnN0IG9uRG9uZUZydXN0dW1DdWxsID0gKHBvc3RNZXNzYWdlKSA9PiB7DQogICAgaWYgKCFlbmFibGVPY2NsdXNpb25DdWxsaW5nKSB7DQogICAgICBjb25zdCBjb3VudEluRnJ1c3R1bSA9IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSAtIGZydXN0dW1DdWxsZWRDb3VudDsNCg0KICAgICAgcG9zdE1lc3NhZ2Uoew0KICAgICAgICB0eXBlOiAnQ3VsbFJlc3VsdHMnLA0KICAgICAgICBuZXdseUN1bGxlZCwNCiAgICAgICAgbmV3bHlVbkN1bGxlZCwNCiAgICAgICAgdmlzaWJsZTogY291bnRJbkZydXN0dW0sDQogICAgICAgIHRvdGFsOiBnZW9tSXRlbXNEYXRhLmxlbmd0aCAtIDEsDQogICAgICAgIHZpc2libGVHZW9tU3RhdHMsDQogICAgICAgIHRvdGFsR2VvbVN0YXRzLA0KICAgICAgfSk7DQogICAgfSBlbHNlIHsNCiAgICAgIC8vIGNvbnNvbGUubG9nKCdGcnVzdHVtQ3VsbFJlc3VsdHM6JywgJ25ld2x5Q3VsbGVkOicsIG5ld2x5Q3VsbGVkLCAnbmV3bHlVbkN1bGxlZDonLCBuZXdseVVuQ3VsbGVkLCBvdXRPZkZydXN0dW0pDQogICAgICAvLyBjb25zdCBjb3VudEluRnJ1c3R1bSA9IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSAtIGZydXN0dW1DdWxsZWRDb3VudA0KDQogICAgICAvLyBpZiAoY291bnRJbkZydXN0dW0gPiAzMDApIHsNCiAgICAgIC8vICAgY29uc29sZS5sb2coJ2NvdW50SW5GcnVzdHVtOicsIGNvdW50SW5GcnVzdHVtKQ0KICAgICAgLy8gfQ0KICAgICAgaWYgKG5ld2x5Q3VsbGVkLmxlbmd0aCA+IDAgfHwgbmV3bHlVbkN1bGxlZC5sZW5ndGggPiAwIHx8ICFpbkZydXN0dW1EcmF3SWRzQnVmZmVyUG9wdWxhdGVkKSB7DQogICAgICAgIGNvbnN0IGluRnJ1c3R1bUluZGljZXMgPSBnZW5lcmF0ZUluRnJ1c3R1bUluZGljZXMoKTsNCg0KICAgICAgICAvLyBXaGVuIG9jY2x1c2lvbiBjdWxsaW5nIGlzIG9uLCB3ZSBvbmx5IHVuY3VsbCBpdGVtcyBhZnRlciB0aGV5DQogICAgICAgIC8vIGFyZSBkZXRlY3RlZCBpbiB0aGUgb2NjbHVzaW9uIGJ1ZmZlci4gVHJhbnNwYXJlbnQgaXRlbXMgYXJlIG5vdA0KICAgICAgICAvLyByZW5kZXJlZCB0byB0aGUgb2NjbHVzaW9uIGJ1ZmZlciwgc28gbXVzdCBiZSB1bmN1bGxlZCBpbW1lZGlhdGVseS4NCiAgICAgICAgY29uc3QgbmV3bHlVbkN1bGxlZF90cmFuc3BhcmVudCA9IFtdOw0KICAgICAgICBuZXdseVVuQ3VsbGVkLmZvckVhY2goKGluZGV4KSA9PiB7DQogICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBnZW9tSXRlbXNEYXRhW2luZGV4XSAmJiBnZW9tSXRlbXNEYXRhW2luZGV4XS52aXNpYmxlICYmIGdlb21JdGVtc0RhdGFbaW5kZXhdLnRyYW5zcGFyZW50KSB7DQogICAgICAgICAgICBuZXdseVVuQ3VsbGVkX3RyYW5zcGFyZW50LnB1c2goaW5kZXgpOw0KICAgICAgICAgIH0NCiAgICAgICAgfSk7DQogICAgICAgIHBvc3RNZXNzYWdlKA0KICAgICAgICAgIHsNCiAgICAgICAgICAgIHR5cGU6ICdJbkZydXN0dW1JbmRpY2VzJywNCiAgICAgICAgICAgIG5ld2x5Q3VsbGVkLA0KICAgICAgICAgICAgbmV3bHlVbkN1bGxlZDogbmV3bHlVbkN1bGxlZF90cmFuc3BhcmVudCwNCiAgICAgICAgICAgIC8qIFdoZW4gb2NjbHVzaW9uIGN1bGxpbmcgaXMgcnVubmluZyx3ZSBvbmx5IGNvbnNpZGVyDQogICAgICAgICAgICBjdWxsaW5nIGNvbXBsZXRlZCBhZnRlciB0aGUgb2NjbHVzaW9uIGN1bGxpbmcgaXMgZG9uZS4NCiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVDb3VudCwNCiAgICAgICAgICAgIHRvdGFsOiBnZW9tSXRlbXNEYXRhLmxlbmd0aCAtIDEsDQogICAgICAgICAgICB2aXNpYmxlR2VvbVN0YXRzLA0KICAgICAgICAgICAgdG90YWxHZW9tU3RhdHMsKi8NCiAgICAgICAgICAgIGluRnJ1c3R1bUluZGljZXMsDQogICAgICAgICAgfSwNCiAgICAgICAgICBbaW5GcnVzdHVtSW5kaWNlcy5idWZmZXJdDQogICAgICAgICk7DQogICAgICAgIGluRnJ1c3R1bURyYXdJZHNCdWZmZXJQb3B1bGF0ZWQgPSB0cnVlOw0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgLy8gTm90ZTogdGhlIGluRnJ1c3R1bURyYXdJZHNCdWZmZXIgaXMgYWxyZWFkeSB1cCB0byBkYXRlIHdlIGNhbiBza2lwIHRoaXMuDQogICAgICAgIHBvc3RNZXNzYWdlKHsNCiAgICAgICAgICB0eXBlOiAnSW5GcnVzdHVtSW5kaWNlcycsDQogICAgICAgICAgbmV3bHlDdWxsZWQ6IFtdLA0KICAgICAgICAgIG5ld2x5VW5DdWxsZWQ6IFtdLA0KICAgICAgICAgIHZpc2libGU6IHZpc2libGVDb3VudCwNCiAgICAgICAgICB0b3RhbDogZ2VvbUl0ZW1zRGF0YS5sZW5ndGggLSAxLA0KICAgICAgICAgIHZpc2libGVHZW9tU3RhdHMsDQogICAgICAgICAgdG90YWxHZW9tU3RhdHMsDQogICAgICAgIH0pOw0KICAgICAgfQ0KICAgIH0NCg0KICAgIG5ld2x5Q3VsbGVkID0gW107DQogICAgbmV3bHlVbkN1bGxlZCA9IFtdOw0KICB9Ow0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIE9jY2x1c2lvbiBDdWxsaW5nIGRhdGEuDQogIGNvbnN0IG9jY2x1ZGVkID0gW107DQogIGNvbnN0IHByb2Nlc3NPY2NsdXNpb25EYXRhID0gKGRhdGEpID0+IHsNCiAgICBjb25zdCB2aXNpYmxlSXRlbXMgPSBkYXRhLnZpc2libGVJdGVtczsNCg0KICAgIGNvbnN0IG5ld2x5Q3VsbGVkID0gW107DQogICAgY29uc3QgbmV3bHlVbkN1bGxlZCA9IFtdOw0KICAgIHZpc2libGVJdGVtcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHsNCiAgICAgIGlmIChpbmRleCA9PSAwKSByZXR1cm4gZmFsc2UNCiAgICAgIGlmIChpbmRleCA+PSBnZW9tSXRlbXNEYXRhLmxlbmd0aCkgcmV0dXJuIHRydWUNCg0KICAgICAgY29uc3QgZ2VvbUl0ZW1EYXRhID0gZ2VvbUl0ZW1zRGF0YVtpbmRleF07DQogICAgICBpZiAoIWdlb21JdGVtRGF0YSB8fCAhZ2VvbUl0ZW1EYXRhLmN1bGxhYmxlIHx8ICFnZW9tSXRlbURhdGEudmlzaWJsZSB8fCBnZW9tSXRlbURhdGEudHJhbnNwYXJlbnQpIHJldHVybiBmYWxzZQ0KDQogICAgICBpZiAoIW91dE9mRnJ1c3R1bVtpbmRleF0pIHsNCiAgICAgICAgaWYgKHZhbHVlID09IDApIHsNCiAgICAgICAgICAvLyBOb3QgdHJhbnNwYXJlbnQgb2JqZWN0IGNhbiBub3QgYmUgb2NjbHVzaW9uIGN1bGxlZCwgYmVjYXVzZSB3ZSBkbyBub3QgcmVuZGVyIHRoZW0gdG8gdGhlDQogICAgICAgICAgLy8gb2NjbHVzaW9uIGJ1ZmZlci4gVGhpcyBtZWFucyB0aGV5IGNhbm5vdCBvY2NsdWRlLCBvciBiZSBjb25zaWRlcmVkIG9jY2x1ZGVkLg0KICAgICAgICAgIGlmICghb2NjbHVkZWRbaW5kZXhdKSB7DQogICAgICAgICAgICBvY2NsdWRlZFtpbmRleF0gPSB0cnVlOw0KICAgICAgICAgICAgbmV3bHlDdWxsZWQucHVzaChpbmRleCk7DQogICAgICAgICAgICBnZW9tU3RhdHNfc3VidHJhY3QoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7DQogICAgICAgICAgfQ0KICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgIGlmIChvY2NsdWRlZFtpbmRleF0pIHsNCiAgICAgICAgICAgIG9jY2x1ZGVkW2luZGV4XSA9IGZhbHNlOw0KICAgICAgICAgICAgbmV3bHlVbkN1bGxlZC5wdXNoKGluZGV4KTsNCiAgICAgICAgICAgIGdlb21TdGF0c19hZGQoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICB9DQogICAgfSk7DQogICAgLy8gTm90ZTogZXZlbiBpZiBvY2NsdXNpb24gY3VsbGluZyBkaWQgbnQgZmlsdGVyIG91dCBhbnkgbW9yZSBpdGVtcw0KICAgIC8vIHdlIG11c3QgZW1pdCB0aGlzIG1lc3NhZ2UgdG8gdGhlIG1haW5zIHdvcmtlciBzbyBpdCBrbm93cyB0aGF0IGN1bGxpbmcgaXMgY29tcGxldGVkLg0KICAgIHBvc3RNZXNzYWdlKHsNCiAgICAgIHR5cGU6ICdDdWxsUmVzdWx0cycsDQogICAgICBuZXdseUN1bGxlZCwNCiAgICAgIG5ld2x5VW5DdWxsZWQsDQogICAgICB2aXNpYmxlOiB2aXNpYmxlQ291bnQsDQogICAgICB0b3RhbDogZ2VvbUl0ZW1zRGF0YS5sZW5ndGggLSAxLA0KICAgICAgdmlzaWJsZUdlb21TdGF0cywNCiAgICAgIHRvdGFsR2VvbVN0YXRzLA0KICAgIH0pOw0KICB9Ow0KDQogIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vDQogIC8vIE1lc3NhZ2luZw0KICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGRhdGEsIHBvc3RNZXNzYWdlKSA9PiB7DQogICAgaWYgKGRhdGEudHlwZSA9PSAnSW5pdCcpIHsNCiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXplZCBDdWxsaW5nIFdvcmtlcicpOw0KICAgICAgZW5hYmxlT2NjbHVzaW9uQ3VsbGluZyA9IGRhdGEuZW5hYmxlT2NjbHVzaW9uQ3VsbGluZzsNCiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSAnVmlld3BvcnRDaGFuZ2VkJykgew0KICAgICAgb25WaWV3UG9ydENoYW5nZWQoZGF0YSwgcG9zdE1lc3NhZ2UpOw0KICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09ICdWaWV3Q2hhbmdlZCcpIHsNCiAgICAgIG9uVmlld0NoYW5nZWQoZGF0YSwgcG9zdE1lc3NhZ2UpOw0KICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09ICdVcGRhdGVHZW9tSXRlbXMnKSB7DQogICAgICBkYXRhLnJlbW92ZWRJdGVtSW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4gew0KICAgICAgICBjb25zdCBnZW9tSXRlbURhdGEgPSBnZW9tSXRlbXNEYXRhW2luZGV4XTsNCiAgICAgICAgaWYgKGdlb21JdGVtRGF0YSAmJiBnZW9tSXRlbURhdGEudmlzaWJsZSkgew0KICAgICAgICAgIGdlb21TdGF0c19zdWJ0cmFjdFRvdGFsKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOw0KICAgICAgICAgIGlmICghZW5hYmxlT2NjbHVzaW9uQ3VsbGluZyB8fCAhb2NjbHVkZWRbaW5kZXhdKSB7DQogICAgICAgICAgICBnZW9tU3RhdHNfc3VidHJhY3QoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGdlb21JdGVtc0RhdGFbaW5kZXhdID0gbnVsbDsNCiAgICAgICAgb3V0T2ZGcnVzdHVtW2luZGV4XSA9IHRydWU7DQogICAgICB9KTsNCiAgICAgIGRhdGEuZ2VvbUl0ZW1zLmZvckVhY2goKGdlb21JdGVtRGF0YSkgPT4gew0KICAgICAgICBjb25zdCBpbmRleCA9IGdlb21JdGVtRGF0YS5pZDsNCiAgICAgICAgLy8gTmV3IGdlb21zIGRlZmF1bHQgdG8gYmVpbmcgdW4tY3VsbGVkDQogICAgICAgIC8vIEV4aXN0aW5nIGdlb21zIHRoYXQgbWF5IGJlIGNoYW5naW5nIHN0YXRlLCBsaWtlIGNoYW5naW5nDQogICAgICAgIC8vIHZpc2liaWxpdHkgb3IgdHJhbnNmb3JtYXRpb25zIHNob3VsZCBzaW1wbHkgdXBkYXRlLg0KICAgICAgICBpZiAoIWdlb21JdGVtc0RhdGFbaW5kZXhdKSB7DQogICAgICAgICAgb3V0T2ZGcnVzdHVtW2luZGV4XSA9IGZhbHNlOw0KICAgICAgICAgIGlmIChnZW9tSXRlbURhdGEudmlzaWJsZSkgew0KICAgICAgICAgICAgZ2VvbVN0YXRzX2FkZFRvdGFsKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOw0KICAgICAgICAgICAgZ2VvbVN0YXRzX2FkZChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKTsNCiAgICAgICAgICB9DQogICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgLy8gYXJlIGVpdGhlciBhZGRpbmcgYSBuZXcgaXRlbSwgb3IgdW5oaWRpbmcgYW4gZXhpc3RpbmcgaXRlbS4NCiAgICAgICAgICBjb25zdCBiZWNvbWluZ1Zpc2libGUgPSAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udmlzaWJsZSAmJiBnZW9tSXRlbURhdGEudmlzaWJsZTsNCiAgICAgICAgICBjb25zdCBiZWNvbWluZ0luVmlzaWJsZSA9IGdlb21JdGVtc0RhdGFbaW5kZXhdLnZpc2libGUgJiYgIWdlb21JdGVtRGF0YS52aXNpYmxlOw0KICAgICAgICAgIGlmIChiZWNvbWluZ1Zpc2libGUpIHsNCiAgICAgICAgICAgIGdlb21TdGF0c19hZGRUb3RhbChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKTsNCiAgICAgICAgICAgIG91dE9mRnJ1c3R1bVtpbmRleF0gPSB0cnVlOw0KICAgICAgICAgICAgb2NjbHVkZWRbaW5kZXhdID0gZmFsc2U7DQogICAgICAgICAgICAvLyBpZiAoIW91dE9mRnJ1c3R1bVtpbmRleF0gJiYgIW9jY2x1ZGVkW2luZGV4XSkgew0KICAgICAgICAgICAgLy8gICBnZW9tU3RhdHNfYWRkKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpDQogICAgICAgICAgICAvLyB9DQogICAgICAgICAgfSBlbHNlIGlmIChiZWNvbWluZ0luVmlzaWJsZSkgew0KICAgICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0VG90YWwoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7DQogICAgICAgICAgICBpZiAoIW91dE9mRnJ1c3R1bVtpbmRleF0gJiYgKCFlbmFibGVPY2NsdXNpb25DdWxsaW5nIHx8ICFvY2NsdWRlZFtpbmRleF0pKSB7DQogICAgICAgICAgICAgIGdlb21TdGF0c19zdWJ0cmFjdChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIG91dE9mRnJ1c3R1bVtpbmRleF0gPSB0cnVlOw0KICAgICAgICAgICAgb2NjbHVkZWRbaW5kZXhdID0gZmFsc2U7DQogICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgIGNvbnN0IGJlY29taW5nVHJhbnNwYXJlbnQgPSAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udHJhbnNwYXJlbnQgJiYgZ2VvbUl0ZW1EYXRhLnRyYW5zcGFyZW50Ow0KICAgICAgICAgICAgY29uc3QgYmVjb21pbmdPcGFxdWUgPSBnZW9tSXRlbXNEYXRhW2luZGV4XS50cmFuc3BhcmVudCAmJiAhZ2VvbUl0ZW1EYXRhLnRyYW5zcGFyZW50Ow0KICAgICAgICAgICAgaWYgKGJlY29taW5nVHJhbnNwYXJlbnQpIHsNCiAgICAgICAgICAgICAgaWYgKGVuYWJsZU9jY2x1c2lvbkN1bGxpbmcgJiYgIW91dE9mRnJ1c3R1bVtpbmRleF0gJiYgb2NjbHVkZWRbaW5kZXhdKSB7DQogICAgICAgICAgICAgICAgLy8gSXRlbXMgYmVjb21pbmcgdHJhbnNwYXJlbnQgbXVzdCBiZSB1bmN1bGxlZCBpbW1lZGlhdGVseS4NCiAgICAgICAgICAgICAgICBuZXdseVVuQ3VsbGVkLnB1c2goaW5kZXgpOw0KICAgICAgICAgICAgICAgIGdlb21TdGF0c19hZGQoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmVjb21pbmdPcGFxdWUpIHsNCiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0JlY29taW5nIG9wYXF1ZTonLCBpbmRleCkNCiAgICAgICAgICAgICAgLy8gSXRlbXMgYmVjb21pbmcgdHJhbnNwYXJlbnQgbXVzdCBiZSB1bmN1bGxlZCBpbW1lZGlhdGVseS4NCiAgICAgICAgICAgICAgLy8gT2NjbHVzaW9uIGN1bGxpbmcgY2FuIG9ubHkgZGV0ZXJtaW5lIGlmIHNvbWV0aGluZyBpcyB2aXNpYmxlDQogICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhhdCB3ZSBhc3N1bWUgaXQgaXMgbm90LCB1bnRpbCBpdCBzaG93cyB1cCBpbiB0aGUgb2NjbHVzaW9uIGJ1ZmZlci4NCiAgICAgICAgICAgICAgLy8gT25jZSBpdCBhcHBlYXJzIGluIHRoZSBvY2NsdXNpb24gYnVmZmVyLCB3ZSBzdGFydCByZW5kZXJpbmcgaXQgYWdhaW4uDQogICAgICAgICAgICAgIC8vIFNvLCB3aGVuIGFuIGl0ZW0gY29tZXMgYmFjayBpbnRvIHRoZSBmcnVzdHVtLCB3ZSBzdGFydCByZW5kZXJpbmcgaXRzIGJib3guDQogICAgICAgICAgICAgIC8vIFRoZW4gaWYgdGhlIGJib3ggaXMgc2Vlbiwgd2UgdGhlbiBzdGFydCBzaG93aW5nIGl0Lg0KICAgICAgICAgICAgICBpZiAoZW5hYmxlT2NjbHVzaW9uQ3VsbGluZyAmJiAhb3V0T2ZGcnVzdHVtW2luZGV4XSkgew0KICAgICAgICAgICAgICAgIG9jY2x1ZGVkW2luZGV4XSA9IHRydWU7DQogICAgICAgICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0KGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIGdlb21JdGVtc0RhdGFbaW5kZXhdID0gZ2VvbUl0ZW1EYXRhOw0KICAgICAgICBjaGVja0dlb21JdGVtKGdlb21JdGVtc0RhdGFbaW5kZXhdKTsNCiAgICAgIH0pOw0KICAgICAgaW5GcnVzdHVtRHJhd0lkc0J1ZmZlclBvcHVsYXRlZCA9IGZhbHNlOw0KICAgICAgb25Eb25lRnJ1c3R1bUN1bGwocG9zdE1lc3NhZ2UpOw0KICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09ICdPY2NsdXNpb25EYXRhJykgew0KICAgICAgcHJvY2Vzc09jY2x1c2lvbkRhdGEoZGF0YSk7DQogICAgfQ0KICB9Ow0KDQogIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7DQogICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhLCBzZWxmLnBvc3RNZXNzYWdlKTsNCiAgfTsKCiAgZXhwb3J0cy5oYW5kbGVNZXNzYWdlID0gaGFuZGxlTWVzc2FnZTsKCiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTsKCiAgcmV0dXJuIGV4cG9ydHM7Cgp9KSh7fSk7Cgo=', null, false);
  /* eslint-enable */

  // See also: src\Renderer\Shaders\GLSL\drawItemId.glsl
  // const int pixelsPerItem = 8;
  const pixelsPerItem$1 = 8;

  // https://forum.babylonjs.com/t/speeding-up-readpixels/12739
  function clientWaitAsync(gl, sync, flags, interval_ms) {
      return new Promise((resolve, reject) => {
          function test() {
              const res = gl.clientWaitSync(sync, flags, 0);
              if (res == gl.WAIT_FAILED) {
                  reject();
                  return;
              }
              if (res == gl.TIMEOUT_EXPIRED) {
                  setTimeout(test, interval_ms);
                  return;
              }
              resolve();
          }
          test();
      });
  }
  async function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, 
  /* optional */ dstOffset = 0, 
  /* optional */ length = 0) {
      const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
      gl.flush();
      await clientWaitAsync(gl, sync, 0, 10);
      gl.deleteSync(sync);
      gl.bindBuffer(target, buffer);
      gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
      gl.bindBuffer(target, null);
      return dstBuffer;
  }
  async function readPixelsAsync(gl, x, y, w, h, format, type, dest) {
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
      gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
      gl.readPixels(x, y, w, h, format, type, 0);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
      gl.deleteBuffer(buf);
      return dest;
  }

  /**
   * @private
   * @extends {ProceduralMesh}
   */
  class BBoxOcclusionLinesCuboid extends Lines {
      constructor() {
          super();
          this.setNumVertices(8);
          const positions = this.getVertexAttribute('positions');
          positions.setValue(0, new Vec3(0.5, -0.5, 0.5));
          positions.setValue(1, new Vec3(0.5, 0.5, 0.5));
          positions.setValue(2, new Vec3(-0.5, 0.5, 0.5));
          positions.setValue(3, new Vec3(-0.5, -0.5, 0.5));
          positions.setValue(4, new Vec3(0.5, -0.5, -0.5));
          positions.setValue(5, new Vec3(0.5, 0.5, -0.5));
          positions.setValue(6, new Vec3(-0.5, 0.5, -0.5));
          positions.setValue(7, new Vec3(-0.5, -0.5, -0.5));
          //
          //      7*----------*6
          //     /   \  /   / |
          //  4*----------*5  |
          //   | \     /  |   |
          //   |   \ /    |   |
          //   |   / \3   |  /2
          //   | /     \  |/
          //  0*----------*1
          //
          this.setNumSegments(34);
          this.setSegmentVertexIndices(0, 0, 1);
          this.setSegmentVertexIndices(1, 0, 2);
          this.setSegmentVertexIndices(2, 0, 3);
          this.setSegmentVertexIndices(3, 0, 4);
          this.setSegmentVertexIndices(4, 0, 5);
          this.setSegmentVertexIndices(5, 0, 6);
          this.setSegmentVertexIndices(6, 0, 7);
          this.setSegmentVertexIndices(7, 1, 0);
          this.setSegmentVertexIndices(8, 1, 2);
          this.setSegmentVertexIndices(9, 1, 3);
          this.setSegmentVertexIndices(10, 1, 4);
          this.setSegmentVertexIndices(11, 1, 5);
          this.setSegmentVertexIndices(12, 1, 6);
          this.setSegmentVertexIndices(13, 1, 7);
          this.setSegmentVertexIndices(14, 2, 0);
          this.setSegmentVertexIndices(15, 2, 1);
          this.setSegmentVertexIndices(16, 2, 3);
          this.setSegmentVertexIndices(17, 2, 4);
          this.setSegmentVertexIndices(18, 2, 5);
          this.setSegmentVertexIndices(19, 2, 6);
          this.setSegmentVertexIndices(20, 2, 7);
          this.setSegmentVertexIndices(21, 3, 1);
          this.setSegmentVertexIndices(22, 3, 2);
          this.setSegmentVertexIndices(23, 3, 0);
          this.setSegmentVertexIndices(24, 3, 4);
          this.setSegmentVertexIndices(25, 3, 5);
          this.setSegmentVertexIndices(26, 3, 6);
          this.setSegmentVertexIndices(27, 3, 7);
          this.setSegmentVertexIndices(28, 4, 5);
          this.setSegmentVertexIndices(29, 4, 6);
          this.setSegmentVertexIndices(30, 4, 7);
          this.setSegmentVertexIndices(31, 5, 6);
          this.setSegmentVertexIndices(32, 5, 7);
          this.setSegmentVertexIndices(33, 6, 7);
      }
  }

  /** This base class supports various XR experiences via spcialized clases such as VRViewport and XRViewport.
   * @extends GLBaseViewport
   */
  class XRViewport extends GLBaseViewport {
      projectionMatricesUpdated;
      tick;
      stageTreeItem;
      stageScale;
      viewXfo = new Xfo();
      stageXfo = new Xfo();
      invStageXfo = new Xfo();
      invStageMatrix = new Mat4();
      region = [];
      session = null;
      refSpace;
      projectionMatrices = [];
      viewMatrices = [];
      cameraMatrices = [];
      sessionMode = 'immersive-vr';
      controllersMap = {};
      controllers = [];
      controllerPointerDownTime = [];
      /**
       * Create a VR viewport.
       * @param renderer - The renderer value.
       */
      constructor(renderer, sessionMode) {
          super(renderer);
          this.clickTime = 300;
          this.doubleClickTime = 300;
          this.sessionMode = sessionMode;
          // ////////////////////////////////////////////
          // Tree
          this.stageTreeItem = new TreeItem('VRStage');
          this.stageTreeItem.setVisible(false);
          this.__renderer.addTreeItem(this.stageTreeItem);
          // ////////////////////////////////////////////
          // Xfos
          const xfo = new Xfo();
          // Convert Y-Up to Z-Up.
          xfo.ori.setFromAxisAndAngle(new Vec3(1, 0, 0), Math.PI * 0.5);
          this.setXfo(xfo); // Reset the stage Xfo.
      }
      getRenderer() {
          return this.renderer;
      }
      /**
       * The getTreeItem method.
       * @return - The return value.
       */
      getTreeItem() {
          return this.stageTreeItem;
      }
      /**
       * The getXfo method.
       * @return - The return value.
       */
      getXfo() {
          return this.stageXfo;
      }
      /**
       * Sets the stage Xfo, which is the Xfo that transforms the user into the world.
       * The local displacement of the user within their volume is applied on top of this Xfo.
       * @param xfo - The xfo value.
       */
      setXfo(xfo) {
          this.stageXfo = xfo;
          this.stageTreeItem.globalXfoParam.value = xfo;
          this.invStageXfo = xfo.inverse();
          this.invStageMatrix = this.invStageXfo.toMat4();
          this.stageScale = xfo.sc.x;
      }
      /**
       * The getControllers method.
       * @return - The return value.
       */
      getControllers() {
          return this.controllers;
      }
      // //////////////////////////
      // Presenting
      /**
       * The isPresenting method.
       * @return - The return value.
       */
      isPresenting() {
          return this.session != null;
      }
      /**
       * Lanuches the session loop
       */
      startSession() {
          const onAnimationFrame = (t, frame) => {
              if (this.session) {
                  this.session.requestAnimationFrame(onAnimationFrame);
                  this.drawXRFrame(frame);
              }
          };
          this.session.requestAnimationFrame(onAnimationFrame);
      }
      /**
       * The stopPresenting method.
       */
      stopPresenting() {
          if (!this.session)
              return;
          this.session.end();
      }
      /**
       * The togglePresenting method.
       */
      togglePresenting() {
          if (this.session)
              this.stopPresenting();
          else
              this.startPresenting();
      }
      /**
       * The bindCullingViewport method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindCullingViewport(renderstate, fovY, projectionMatrixMat4) {
          renderstate.viewXfo = this.viewXfo;
          renderstate.viewScale = 1.0;
          renderstate.region = this.region;
          renderstate.cameraMatrix = renderstate.viewXfo.toMat4();
          const viewMatrixMat4 = renderstate.cameraMatrix.inverse();
          renderstate.viewport = this;
          // const frustumHPersp = Math.tan(fovY / 2.0) * flocalDist * 2.0
          // const frustumWPersp = frustumHPersp * aspect
          // const frustumHOrtho = this.camera.getFrustumHeight()
          // const frustumWOrtho = frustumHPersp * aspect
          // const viewportFrustum = Vec4(
          //   MathFunctions.lerp(frustumWPersp, frustumWOrtho, isOrthographic),
          //   MathFunctions.lerp(frustumHPersp, frustumHOrtho, isOrthographic),
          //   flocalDist,
          //   fovY
          // )
          const gl = this.__renderer.gl;
          renderstate.bindRendererUnifs = (unifs) => {
              const { cameraMatrix, viewMatrix, projectionMatrix, eye, isOrthographic } = unifs;
              if (cameraMatrix) {
                  gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
              }
              if (viewMatrix) {
                  gl.uniformMatrix4fv(viewMatrix.location, false, viewMatrixMat4.asArray());
              }
              if (projectionMatrix) {
                  gl.uniformMatrix4fv(projectionMatrix.location, false, projectionMatrixMat4.asArray());
              }
              if (eye) {
                  // for monocular rendering, we just render viewport 0
                  gl.uniform1i(eye.location, 0);
              }
              if (isOrthographic) {
                  // Left or right eye, when rendering stereo VR.
                  gl.uniform1i(isOrthographic.location, 0);
              }
              // if (viewportFrustum && this.viewportFrustum) {
              //   // Left or right eye, when rendering stereo VR.
              //   gl.uniform4f(
              //     viewportFrustum.location,
              //     this.viewportFrustum.x,
              //     this.viewportFrustum.y,
              //     this.viewportFrustum.z,
              //     this.viewportFrustum.w
              //   )
              // }
          };
          renderstate.bindViewports = (unifs, draw) => draw();
      }
      /**
       * The bindXRViewport method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindXRViewport(renderstate, viewports) {
          renderstate.viewXfo = this.viewXfo;
          renderstate.viewScale = 1.0;
          renderstate.region = this.region;
          renderstate.cameraMatrix = renderstate.viewXfo.toMat4();
          renderstate.viewport = this;
          const gl = this.__renderer.gl;
          renderstate.bindRendererUnifs = (unifs) => {
              // Note: the camera matrix should be the head position instead
              // of the eye position. The inverse(viewMatrix) can be used
              // when we want the eye pos.
              const { cameraMatrix } = unifs;
              if (cameraMatrix) {
                  gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
              }
          };
          renderstate.bindViewports = (unifs, draw) => {
              const { isOrthographic } = unifs;
              if (isOrthographic) {
                  gl.uniform1i(isOrthographic.location, 0);
              }
              viewports.forEach((vp, index) => {
                  let vp_region = vp.region;
                  gl.viewport(vp_region[0], vp_region[1], vp_region[2], vp_region[3]);
                  const { viewMatrix, projectionMatrix, eye } = unifs;
                  if (viewMatrix) {
                      gl.uniformMatrix4fv(viewMatrix.location, false, vp.viewMatrix.asArray());
                  }
                  if (projectionMatrix) {
                      gl.uniformMatrix4fv(projectionMatrix.location, false, vp.projectionMatrix.asArray());
                  }
                  if (eye) {
                      // Left or right eye, when rendering stereo VR.
                      gl.uniform1i(eye.location, index);
                  }
                  draw();
              });
          };
      }
  }

  /** Class representing a VR head.
   * @private
   */
  class XRHead {
      xrvp;
      treeItem;
      mat4;
      localXfo;
      hmdGeomItem;
      /**
       * Create a VR head.
       * @param xrvp - The VR viewport.
       * @param stageTreeItem - The stageTreeItem value.
       */
      constructor(xrvp, stageTreeItem) {
          this.xrvp = xrvp;
          this.treeItem = new TreeItem('XRHead');
          stageTreeItem.addChild(this.treeItem);
          this.mat4 = new Mat4();
          this.localXfo = new Xfo();
      }
      /**
       * The Set wether the HMB is visible in rendering or not. Used in spectator rendering.
       * @param state - The visibility value.
       */
      setVisible(state) {
          if (state && !this.hmdGeomItem) {
              const assetItem = this.xrvp.getAsset();
              if (!assetItem)
                  return;
              const hmdGeomItem = assetItem.getChildByName('HMD');
              if (!hmdGeomItem)
                  return;
              this.hmdGeomItem = hmdGeomItem.clone({ assetItem });
              if (this.hmdGeomItem) {
                  const quat = new Quat();
                  quat.setFromAxisAndAngle(new Vec3(0, 1, 0), Math.PI);
                  this.hmdGeomItem.localXfoParam.value = new Xfo(new Vec3(0, -0.035, -0.03), quat, new Vec3(0.001, 0.001, 0.001) // VRAsset units are in mm.
                  );
                  this.treeItem.addChild(this.hmdGeomItem, false);
              }
          }
          if (this.hmdGeomItem) {
              this.hmdGeomItem.visibleParam.value = state;
          }
      }
      /**
       * The update method.
       * @param pose - The pose value.
       */
      update(pose) {
          // Old
          // this.mat4.fromArray(pose.poseModelMatrix);
          // New
          this.mat4.fromArray(pose.transform.matrix);
          this.localXfo.setFromMat4(this.mat4);
          // const pos = pose.transform.position;
          // this.localXfo.tr.set(pos.x, pos.y,pos.z);
          // const ori = pose.transform.orientation;
          // this.localXfo.ori.set(ori.x, ori.y, ori.z, ori.x);
          this.treeItem.localXfoParam.value = this.localXfo;
      }
      /**
       * The getTreeItem method.
       * @return - The return value.
       */
      getTreeItem() {
          return this.treeItem;
      }
      /**
       * The getXfo method.
       * @return - The return value.
       */
      getXfo() {
          return this.localXfo;
      }
  }

  // const line = new Lines()
  // line.setNumVertices(2)
  // line.setNumSegments(1)
  // line.setSegmentVertexIndices(0, 0, 1)
  // const positions = <Vec3Attribute>line.getVertexAttribute('positions')
  // positions.setValue(0, new Vec3(0.0, 0.0, 0.0))
  // positions.setValue(1, new Vec3(0.0, 0.0, -1.0))
  // line.setBoundingBoxDirty()
  /** Class representing a VR controller.
   *
   * The XRController class wraps the XRInputSource provided by the WebXR API.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/XRInputSource
   *
   * The XRController provides a tree item that can be used to attach geometries to represenet
   * the controllers or tools that the user may have in thier hands.
   * ```javascript
   * renderer.getXRViewport().then((xrvp) => {
   *   xrvp.on('controllerAdded', (event) => {
   *     const controller = event.controller
   *
   *     // Configure the distance of the ray cast performed by the controller into the scene.
   *     // Note: setting to 0 disables ray casting.
   *     controller.raycastDist = 20.0
   *
   *     // Remove the green ball added by the VRViewManipulator.
   *     controller.tipItem.removeAllChildren()
   *
   *     // Add a visual indication of the ray.
   *     const pointerItem = new GeomItem('PointerRay', line, pointermat)
   *     pointerItem.setSelectable(false)
   *     const pointerXfo = new Xfo()
   *     pointerXfo.sc.set(1, 1, controller.raycastDist)
   *     pointerItem.localXfoParam.value = pointerXfo
   *     controller.tipItem.addChild(pointerItem, false)
   *
   *     // The tip items needs to be rotated down a little to make it
   *     // point in the right direction.
   *     const tipItemXfo = controller.tipItem.localXfoParam.value
   *     tipItemXfo.ori.setFromAxisAndAngle(new Vec3(1, 0, 0), -0.8)
   *     controller.tipItem.localXfoParam.value = tipItemXfo
   *
   *     controller.on('buttonPressed', (event) => {
   *       console.log('buttonPressed', event)
   *     })
   *     controller.on('buttonReleased', (event) => {
   *       console.log('buttonReleased', event)
   *     })
   *   })
   * })
   * ```
   *
   * **Events**
   * * **buttonPressed:** Emitted when the user presses any of the buttons aside from the trigger button.
   * * **buttonReleased:** Emitted when the user release any of the buttons aside from the trigger button.
   *
   *
   * @extends EventEmitter
   */
  class XRController extends EventEmitter {
      id;
      buttonPressed;
      xrvp;
      inputSource;
      pressedButtons = [];
      treeItem;
      tipItem;
      // The frequency of raycasting into the scene for this controller
      raycastTick = 5;
      raycastArea = 0.005;
      raycastDist = 0.04;
      pointerRay = new Ray();
      mat4;
      xfo;
      raycastAreaCache = 0;
      raycastDistCache = 0;
      rayCastRenderTargetProjMatrix = new Mat4();
      tick;
      hitTested;
      pointerOverItem;
      intersectionData;
      /**
       * Create a VR controller.
       * @param xrvp - The Vr viewport.
       * @param inputSource - The input source.
       * @param id - The id value.
       */
      constructor(xrvp, inputSource, id) {
          super();
          this.xrvp = xrvp;
          this.inputSource = inputSource;
          this.id = id;
          this.buttonPressed = false;
          this.inputSource.gamepad.buttons.forEach((button, index) => {
              if (index == 0)
                  return;
              this.pressedButtons[index] = button.pressed;
          });
          // /////////////////////////////////
          // Xfo
          this.mat4 = new Mat4();
          this.xfo = new Xfo();
          // this.setVisible(true);
          this.treeItem = new TreeItem('XRController:' + inputSource.handedness + id);
          // Controller coordinate system
          // X = Horizontal.
          // Y = Down through the knuckles.
          // Z = Towards handle base.
          if (!SystemDesc.isMobileDevice) {
              // A Vive or Oculus Controller
              this.tipItem = new TreeItem('Tip');
              // Note: the tip of the controller need to be off
              // the end of the controller. getGeomItemAtTip
              // now searches a grid in that area and so we need to
              // ensure that the grid does not touch the controller,
              // else it will return the controller geom from
              // the getGeomItemAtTip function
              const tipXfo = new Xfo();
              tipXfo.tr.set(0.0, -0.05, -0.13);
              // tilt the pointer down a little to be easier on the wrists.
              tipXfo.ori.setFromAxisAndAngle(new Vec3(1, 0, 0), Math.PI * -0.2);
              this.tipItem.localXfoParam.value = tipXfo;
              this.treeItem.addChild(this.tipItem, false);
              xrvp.stageTreeItem.addChild(this.treeItem);
              // const pointermat = new Material('pointermat', 'LinesShader')
              // pointermat.setSelectable(false)
              // pointermat.getParameter('BaseColor').value = new Color(1.2, 0, 0)
              // const pointerItem = new GeomItem('PointerRay', line, pointermat)
              // pointerItem.setSelectable(false)
              // const pointerXfo = new Xfo()
              // pointerXfo.sc.set(1, 1, this.raycastDist)
              // pointerItem.localXfoParam.value = pointerXfo
              // this.tipItem.addChild(pointerItem, false)
              if (inputSource.targetRayMode == 'tracked-pointer') {
                  // Once we have an input profile, we can determine the XR Device in use.
                  switch (inputSource.profiles[0]) {
                      case 'htc-vive':
                          localStorage.setItem('ZeaEngine_XRDevice', 'Vive');
                          break;
                      case 'oculus-touch':
                      case 'oculus-touch-v2':
                      case 'oculus-touch-v3':
                          localStorage.setItem('ZeaEngine_XRDevice', 'Oculus');
                          break;
                  }
                  //   // Use the fetchProfile method from the motionControllers library
                  //   // to find the appropriate glTF mesh path for this controller.
                  //   fetchProfile(inputSource, DEFAULT_PROFILES_PATH).then(({ profile, assetPath }) => {
                  //     // Typically if you wanted to animate the controllers in response
                  //     // to device inputs you'd create a new MotionController() instance
                  //     // here to handle the animation, but this sample will skip that
                  //     // and only display a static mesh for simplicity.
                  //     scene.inputRenderer.setControllerMesh(new Gltf2Node({ url: assetPath }), inputSource.handedness)
                  //   })
                  xrvp.loadHMDResources().then((assetItem) => {
                      if (!assetItem)
                          return;
                      const localXfo = new Xfo();
                      localXfo.ori.setFromAxisAndAngle(new Vec3(0, 1, 0), Math.PI);
                      localXfo.sc.set(0.001, 0.001, 0.001); // VRAsset units are in mm.
                      let srcControllerTree;
                      if (inputSource.profiles[0] == 'htc-vive') {
                          srcControllerTree = assetItem.getChildByName('Controller');
                          localXfo.tr.set(0, -0.035, -0.085);
                      }
                      else {
                          switch (inputSource.handedness) {
                              case 'left':
                                  srcControllerTree = assetItem.getChildByName('LeftController');
                                  localXfo.tr.set(0, -0.035, -0.085);
                                  localXfo.sc.scaleInPlace(0.85);
                                  break;
                              case 'right':
                                  srcControllerTree = assetItem.getChildByName('RightController');
                                  localXfo.tr.set(0, -0.035, -0.085);
                                  localXfo.sc.scaleInPlace(0.85);
                                  break;
                              case 'none':
                              default:
                                  srcControllerTree = assetItem.getChildByName('Controller');
                                  break;
                          }
                      }
                      if (srcControllerTree) {
                          const controllerTree = srcControllerTree.clone({ assetItem });
                          controllerTree.localXfoParam.value = localXfo;
                          this.treeItem.addChild(controllerTree, false);
                      }
                  });
              }
          }
          this.tick = 0;
      }
      /**
       * The getHandedness method.
       * @return - The return value.
       */
      getHandedness() {
          return this.inputSource.handedness;
      }
      /**
       * The getId method.
       * @return - The return value.
       */
      getId() {
          return this.id;
      }
      /**
       * The getTreeItem method.
       * @return - The return value.
       */
      getTreeItem() {
          return this.treeItem;
      }
      /**
       * The getTipItem method.
       * @return - The return value.
       */
      getTipItem() {
          return this.tipItem;
      }
      /**
       * The getTipXfo method.
       * @return - The return value.
       */
      getTipXfo() {
          return this.tipItem.globalXfoParam.value;
      }
      /**
       * The isButtonPressed method.
       * @return - The return value.
       */
      isButtonPressed() {
          return this.buttonPressed;
      }
      /**
       * The getControllerStageLocalXfo method.
       * @return - The return value.
       */
      getControllerStageLocalXfo() {
          return this.xfo;
      }
      /**
       * The getControllerTipStageLocalXfo method.
       * @return - The return value.
       */
      getControllerTipStageLocalXfo() {
          return this.xfo.multiply(this.tipItem.localXfoParam.value);
      }
      // ////////////////////////////////
      /**
       * The updatePose method.
       * @param refSpace - The refSpace value.
       * @param xrFrame - The xrFrame value.
       * @param inputSource - The inputSource value.
       */
      updatePose(refSpace, xrFrame, inputSource) {
          const inputPose = xrFrame.getPose(inputSource.gripSpace, refSpace);
          // We may not get a inputPose back in cases where the input source has lost
          // tracking or does not know where it is relative to the given frame
          // of reference.
          if (!inputPose || !inputPose.transform) {
              return;
          }
          this.mat4.fromArray(inputPose.transform.matrix);
          this.xfo.setFromMat4(this.mat4);
          // const pos = inputPose.transform.position;
          // this.xfo.tr.set(pos.x, pos.y,pos.z);
          // const ori = inputPose.transform.orientation;
          // this.xfo.ori.set(ori.x, ori.y, ori.z, ori.x);
          // //////////////////////////////
          this.treeItem.localXfoParam.value = this.xfo;
          // Reset the geom at tip so it will be recomputed if necessary
          this.hitTested = false;
          let rebindRenderTarget = false;
          // /////////////////////////////////
          // Simulate Pointer Enter/Leave Events.
          // Check for pointer over every Nth frame (at 90fps this should be fine.)
          if (this.raycastDist > 0.0 && this.raycastTick > 0 && this.tick % this.raycastTick == 0) {
              const intersectionData = this.getGeomItemAtTip();
              rebindRenderTarget = true;
              if (intersectionData != undefined) {
                  const event = new XRControllerEvent(this.xrvp, this, 0, this.buttonPressed ? 1 : 0);
                  event.intersectionData = intersectionData;
                  event.pointerRay = this.pointerRay;
                  if (intersectionData.geomItem != this.pointerOverItem) {
                      if (this.pointerOverItem) {
                          event.leftGeometry = this.pointerOverItem;
                          this.pointerOverItem.onPointerLeave(event);
                          if (event.propagating)
                              this.xrvp.emit('pointerLeaveGeom', event);
                      }
                      event.propagating = true;
                      this.pointerOverItem = intersectionData.geomItem;
                      this.pointerOverItem.onPointerEnter(event);
                      if (event.propagating)
                          this.xrvp.emit('pointerOverGeom', event);
                  }
                  // emit the pointer move event directly to the item.
                  intersectionData.geomItem.onPointerMove(event);
              }
              else if (this.pointerOverItem) {
                  const event = new XRControllerEvent(this.xrvp, this, 0, this.buttonPressed ? 1 : 0);
                  event.pointerRay = this.pointerRay;
                  event.leftGeometry = this.pointerOverItem;
                  this.pointerOverItem.onPointerLeave(event);
                  this.pointerOverItem = null;
              }
          }
          this.inputSource.gamepad.buttons.forEach((button, index) => {
              if (index == 0)
                  return;
              if (button.pressed && !this.pressedButtons[index]) {
                  this.pressedButtons[index] = true;
                  const event = new XRControllerEvent(this.xrvp, this, index, 1);
                  event.intersectionData = this.getGeomItemAtTip();
                  event.pointerRay = this.pointerRay;
                  this.emit('buttonPressed', event);
                  rebindRenderTarget = true;
              }
              else if (!button.pressed && this.pressedButtons[index]) {
                  this.pressedButtons[index] = false;
                  const event = new XRControllerEvent(this.xrvp, this, index, 0);
                  this.emit('buttonReleased', event);
              }
          });
          this.tick++;
          return rebindRenderTarget;
      }
      // ////////////////////////////////
      /**
       * The getGeomItemAtTip method.
       * @return - The return value.
       */
      getGeomItemAtTip() {
          if (this.hitTested)
              return this.intersectionData;
          this.hitTested = true;
          if (this.raycastDist == 0)
              return null;
          const renderer = this.xrvp.getRenderer();
          const xfo = this.tipItem.globalXfoParam.value.clone();
          xfo.sc.set(1, 1, 1);
          this.pointerRay.start = xfo.tr;
          this.pointerRay.dir = xfo.ori.getZaxis().negate();
          const dist = this.raycastDist * this.xrvp.stageScale;
          const area = this.raycastArea * this.xrvp.stageScale;
          if (dist != this.raycastDistCache || area != this.raycastAreaCache) {
              this.rayCastRenderTargetProjMatrix.setOrthographicMatrix(area * -0.5, area * 0.5, area * -0.5, area * 0.5, 0.0, dist);
              this.raycastDistCache = dist;
              this.raycastAreaCache = area;
          }
          this.intersectionData = renderer.raycastWithProjection(xfo, this.rayCastRenderTargetProjMatrix, this.pointerRay);
          return this.intersectionData;
      }
  }
  class VRController extends XRController {
  }

  /**
   * Class representing a view tool
   * @extends BaseTool
   */
  class XRViewManipulator extends BaseTool {
      enableViewScale = true;
      listenerIDs = {};
      controllerTriggersHeld = [];
      xrvp;
      vrControllerToolTip;
      vrControllerToolTipMat;
      grabPos;
      stageXfo__GrabStart;
      grabDir;
      grabDist;
      /**
       */
      constructor(xrvp) {
          super();
          this.xrvp = xrvp;
          this.vrControllerToolTip = new Cross(0.05);
          this.vrControllerToolTipMat = new Material('VRController Cross', 'LinesShader');
          this.vrControllerToolTipMat.getParameter('BaseColor').value = new Color('#03E3AC');
      }
      // /////////////////////////////////////
      //
      /**
       * Adds the icon to the tip of the VR Controller
       * @param event
       */
      /**
       * The activateTool method.
       */
      activateTool() {
          super.activateTool();
          const bindController = (controller) => {
              const geomItem = new GeomItem('XRViewManipulatorToolTip', this.vrControllerToolTip, this.vrControllerToolTipMat);
              geomItem.setSelectable(false);
              controller.getTipItem().removeAllChildren();
              controller.getTipItem().addChild(geomItem, false);
          };
          for (const controller of this.xrvp.getControllers()) {
              bindController(controller);
          }
          this.listenerIDs['controllerAdded'] = this.xrvp.on('controllerAdded', (event) => {
              bindController(event.controller);
          });
      }
      /**
       * The deactivateTool method.
       */
      deactivateTool() {
          super.deactivateTool();
          const unbindController = (controller) => {
              const geomItem = controller.getTipItem().getChildByName('XRViewManipulatorToolTip');
              controller.getTipItem().removeChildByHandle(geomItem);
          };
          for (const controller of this.xrvp.getControllers()) {
              unbindController(controller);
          }
          this.xrvp.off('controllerAdded', this.listenerIDs['controllerAdded']);
      }
      // ///////////////////////////////////
      // XRController events
      // eslint-disable-next-line require-jsdoc
      initMoveStage() {
          if (this.controllerTriggersHeld.length == 1) {
              this.grabPos = this.controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr.clone();
              this.stageXfo__GrabStart = this.xrvp.getXfo().clone();
          }
          else if (this.controllerTriggersHeld.length == 2) {
              const p0 = this.controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr;
              const p1 = this.controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr;
              this.grabDir = p1.subtract(p0);
              this.grabPos = p0.lerp(p1, 0.5);
              this.grabDir.y = 0.0;
              this.grabDist = this.grabDir.length();
              this.grabDir.scaleInPlace(1 / this.grabDist);
              this.stageXfo__GrabStart = this.xrvp.getXfo().clone();
          }
      }
      /**
       * The onXRControllerButtonDown method.
       * @param event - The event param.
       * @return The return value.
       */
      onXRControllerButtonDown(event) {
          if (event.button != 0)
              return;
          const index = this.controllerTriggersHeld.indexOf(event.controller);
          if (index == -1) {
              this.controllerTriggersHeld.push(event.controller);
              this.initMoveStage();
              event.stopPropagation();
              event.setCapture(this);
          }
      }
      /**
       * The onXRControllerButtonUp method.
       * @param event - The event param.
       * @return The return value.
       */
      onXRControllerButtonUp(event) {
          if (event.button != 0)
              return;
          const index = this.controllerTriggersHeld.indexOf(event.controller);
          if (index != -1) {
              this.controllerTriggersHeld.splice(index, 1);
              this.initMoveStage();
              event.stopPropagation();
              if (this.controllerTriggersHeld.length == 0) {
                  event.releaseCapture();
              }
          }
      }
      /**
       * The onVRControllerDoubleClicked method.
       * @param event - The event param.
       */
      onVRControllerDoubleClicked(event) {
          console.log('onVRControllerDoubleClicked:', this.controllerTriggersHeld.length);
          const stageXfo = this.xrvp.getXfo().clone();
          stageXfo.sc.set(1, 1, 1);
          this.xrvp.setXfo(stageXfo);
      }
      /**
       * The onVRPoseChanged method.
       * @param event - The event param.
       */
      onVRPoseChanged(event) {
          if (this.controllerTriggersHeld.length == 1) {
              const grabPos = this.controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr;
              const deltaXfo = new Xfo();
              deltaXfo.tr = this.grabPos.subtract(grabPos);
              // //////////////
              // Update the stage Xfo
              const stageXfo = this.stageXfo__GrabStart.multiply(deltaXfo);
              this.xrvp.setXfo(stageXfo);
          }
          else if (this.controllerTriggersHeld.length == 2) {
              const p0 = this.controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr;
              const p1 = this.controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr;
              const grabPos = p0.lerp(p1, 0.5);
              const grabDir = p1.subtract(p0);
              grabDir.y = 0.0;
              const grabDist = grabDir.length();
              // Sometimes we would get NaN values in the stage Xfo
              if (grabDist < 0.0001)
                  return;
              grabDir.scaleInPlace(1 / grabDist);
              const deltaXfo = new Xfo();
              // //////////////
              // Compute ori
              let angle = this.grabDir.angleTo(grabDir);
              if (this.grabDir.cross(grabDir).y > 0.0) {
                  angle = -angle;
              }
              deltaXfo.ori.rotateY(angle);
              const deltaTr = this.grabPos.subtract(grabPos);
              // Rotate around the point between the hands.
              const oriTrDelta = deltaXfo.ori.rotateVec3(this.grabPos);
              deltaXfo.tr.addInPlace(this.grabPos.subtract(oriTrDelta));
              // //////////////
              // Compute sc
              // Limit to a 10x change in scale per grab.
              if (this.enableViewScale) {
                  const sc = Math.max(Math.min(this.grabDist / grabDist, 10.0), 0.1);
                  // Avoid causing a scale that would make the user < 1.0 scale factor.
                  // if(stageSc < 1.0){
                  //     sc = 1.0 / this.stageXfo__GrabStart.sc.x;
                  // }
                  deltaXfo.sc.set(sc, sc, sc);
                  // Scale around the point between the hands.
                  const deltaSc = this.grabPos.scale(1.0 - sc);
                  deltaXfo.tr.addInPlace(deltaXfo.ori.rotateVec3(deltaSc));
                  deltaTr.scaleInPlace(sc);
              }
              // //////////////
              // Compute tr
              deltaXfo.tr.addInPlace(deltaXfo.ori.rotateVec3(deltaTr));
              // //////////////
              // Update the stage Xfo
              const stageXfo = this.stageXfo__GrabStart.multiply(deltaXfo);
              this.xrvp.setXfo(stageXfo);
          }
      }
      // ///////////////////////////////////
      // Pointer events
      /**
       * Event fired when a pointing device button is pressed while the pointer is over the tool.
       *
       * @param event - The event param.
       */
      onPointerDown(event) {
          if (event instanceof XRControllerEvent) {
              this.onXRControllerButtonDown(event);
          }
      }
      /**
       * Event fired when a pointing device is moved while the cursor's hotspot is inside it.
       *
       * @param event - The event param.
       */
      onPointerMove(event) {
          if (event instanceof XRPoseEvent) {
              this.onVRPoseChanged(event);
          }
      }
      /**
       * Event fired when a pointing device button is released while the pointer is over the tool.
       *
       * @param event - The event param.
       */
      onPointerUp(event) {
          if (event instanceof XRControllerEvent) {
              this.onXRControllerButtonUp(event);
          }
      }
      /**
       * Event fired when a pointing device button is double clicked on the tool.
       *
       * @param event - The event param.
       */
      onPointerDoubleClick(event) {
          if (event instanceof XRControllerEvent) {
              this.onVRControllerDoubleClicked(event);
          }
      }
  }

  /** This Viewport class is used for rendering stereoscopic views to VR controllers using the WebXR api.
   *  When the GLRenderer class detects a valid WebXF capable device is plugged in, this class is automatically
   *  instantiated ready for XR sessions
   *
   * **Events**
   * * **presentingChanged:** Emitted when presenting is started or stopped
   * * **controllerAdded:** Emitted when a new XR controller is detected.
   * * **viewChanged:** Emitted during presentation each time the frame is rendered.
   * * **pointerDoubleClick:** Emitted when the user double clicks with an XR pointer.
   * * **pointerDown:** Emitted when the user presses an XR pointer
   * * **pointerUp:** Emitted when the user releases an XR pointer
   *
   * @extends XRViewport
   */
  class VRViewport extends XRViewport {
      vrAsset;
      hmd = '';
      hmdAssetPromise;
      xrhead;
      /**
       * Create a VR viewport.
       * @param renderer - The renderer value.
       */
      constructor(renderer, sessionMode) {
          super(renderer, sessionMode);
          this.xrhead = new XRHead(this, this.stageTreeItem);
          this.setManipulator(new XRViewManipulator(this));
      }
      /**
       * The getAsset method.
       * @return - The return value.
       */
      getAsset() {
          return this.vrAsset;
      }
      /**
       * The getVRHead method.
       * @return - The return value.
       */
      getVRHead() {
          return this.xrhead;
      }
      /**
       * Returns the name of the HMD being used.
       * @return - The return value.
       */
      getHMDName() {
          return this.hmd;
      }
      /**
       * The loadHMDResources method.
       * @return - The return value.
       */
      loadHMDResources() {
          if (SystemDesc.isMobileDevice) {
              return Promise.resolve(null);
          }
          // If the HMD has changed, reset it.
          let hmd = localStorage.getItem('ZeaEngine_XRDevice');
          if (!hmd) {
              hmd = 'Oculus';
              localStorage.setItem('ZeaEngine_XRDevice', hmd);
          }
          if (this.hmd != hmd) {
              this.hmdAssetPromise = undefined;
          }
          else if (this.hmdAssetPromise)
              return this.hmdAssetPromise;
          this.hmd = hmd;
          this.hmdAssetPromise = new Promise((resolve, reject) => {
              // ////////////////////////////////////////////
              // Resources
              {
                  let hmdAssetId;
                  switch (hmd) {
                      case 'Vive':
                          hmdAssetId = 'ZeaEngine/Vive.vla';
                          break;
                      case 'Oculus':
                          hmdAssetId = 'ZeaEngine/Oculus.vla';
                          break;
                      default:
                          hmdAssetId = 'ZeaEngine/Vive.vla';
                          break;
                  }
                  if (!resourceLoader.commonResources[hmdAssetId]) {
                      // Cache the asset so if an avatar needs to display,
                      // it can use the same asset.
                      const asset = new VLAAsset(hmdAssetId);
                      asset.load(resourceLoader.systemUrls[hmdAssetId]);
                      resourceLoader.commonResources[hmdAssetId] = asset;
                  }
                  this.vrAsset = resourceLoader.getCommonResource(hmdAssetId);
                  const bind = () => {
                      const materialLibrary = this.vrAsset.getMaterialLibrary();
                      const materialNames = materialLibrary.getMaterialNames();
                      for (const name of materialNames) {
                          const material = materialLibrary.getMaterial(name);
                          if (material) {
                              material.setShaderName('SimpleSurfaceShader');
                          }
                      }
                      this.vrAsset.traverse((item) => {
                          item.setSelectable(false);
                      });
                      resolve(this.vrAsset);
                  };
                  if (this.vrAsset.isLoaded())
                      bind();
                  else
                      this.vrAsset.once('loaded', bind);
              }
          });
          return this.hmdAssetPromise;
      }
      /**
       * The startPresenting method.
       */
      startPresenting() {
          return new Promise((resolve, reject) => {
              // https://github.com/immersive-web/webxr/blob/master/explainer.md
              const startPresenting = () => {
                  navigator.xr
                      .requestSession('immersive-vr', {
                      // Our standing experience will require at least a local-floor
                      // reference space (which will be available even on 3DoF device)
                      // but can optionally make use of bounded-floor reference spaces
                      // when available.
                      requiredFeatures: ['local-floor'],
                      optionalFeatures: ['bounded-floor'],
                  })
                      .then((session) => {
                      const viewport = this.__renderer.getViewport();
                      if (viewport) {
                          const camera = viewport.getCamera();
                          const cameraXfo = camera.globalXfoParam.value;
                          // Convert Y-Up to Z-Up.
                          const stageXfo = new Xfo();
                          stageXfo.tr = cameraXfo.tr.clone();
                          stageXfo.tr.z -= 1.3; // assume sitting, and move the floor down a bit
                          const dir = cameraXfo.ori.getZaxis();
                          dir.z = 0;
                          dir.normalizeInPlace();
                          stageXfo.ori.setFromDirectionAndUpvector(dir, new Vec3(0, 0, 1));
                          this.setXfo(stageXfo);
                      }
                      session.addEventListener('end', () => {
                          this.stageTreeItem.setVisible(false);
                          this.session = null;
                          // Make sure the default fbo is bound.
                          // This addrsses an error generated by rendring directly after the session ends.
                          // INVALID_FRAMEBUFFER_OPERATION: clear: Cannot render to a XRWebGLLayer framebuffer outside of an XRSession animation frame callback.
                          const gl = this.__renderer.gl;
                          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                          this.emit('presentingChanged', new StateChangedEvent(false));
                      });
                      const onSelectStart = (event) => {
                          const controller = this.controllersMap[event.inputSource.handedness];
                          if (controller) {
                              controller.buttonPressed = true;
                              this.onPointerDown(new XRControllerEvent(this, controller, 0, 1));
                          }
                      };
                      const onSelectEnd = (ev) => {
                          const controller = this.controllersMap[ev.inputSource.handedness];
                          if (controller) {
                              controller.buttonPressed = false;
                              this.onPointerUp(new XRControllerEvent(this, controller, 0, 0));
                          }
                      };
                      const createVRController = (inputSource) => {
                          if (this.controllersMap[inputSource.handedness]) {
                              this.controllersMap[inputSource.handedness].inputSource = inputSource;
                              return;
                          }
                          const id = this.controllers.length;
                          console.log('creating controller:', inputSource.handedness, inputSource.profiles);
                          const controller = new XRController(this, inputSource, id);
                          this.controllersMap[inputSource.handedness] = controller;
                          this.controllers[id] = controller;
                          this.controllerPointerDownTime[id] = [];
                          controller.on('buttonPressed', (event) => {
                              this.onPointerDown(event);
                          });
                          controller.on('buttonReleased', (event) => {
                              this.onPointerUp(event);
                          });
                          const event = new ControllerAddedEvent(controller);
                          this.emit('controllerAdded', event);
                          return controller;
                      };
                      const onInputSourcesChange = (event) => {
                          // As input sources are connected if they are tracked-pointer devices
                          // look up which meshes should be associated with their profile and
                          // load as the controller model for that hand.
                          for (const inputSource of event.added) {
                              if (inputSource.profiles.length == 0)
                                  continue;
                              if (inputSource.profiles[0] == 'generic-touchscreen') ;
                              else {
                                  createVRController(inputSource);
                              }
                          }
                      };
                      session.addEventListener('selectstart', onSelectStart);
                      session.addEventListener('selectend', onSelectEnd);
                      session.addEventListener('inputsourceschange', onInputSourcesChange);
                      this.session = session;
                      // ////////////////////////////
                      // @ts-ignore - Note: We could install the webxr type definitions and remove this ignore.
                      const glLayer = new XRWebGLLayer(session, this.__gl);
                      session.updateRenderState({
                          baseLayer: glLayer,
                      });
                      this.width = glLayer.framebufferWidth;
                      this.height = glLayer.framebufferHeight;
                      this.region = [0, 0, this.width, this.height];
                      this.depthRange = [session.renderState.depthNear, session.renderState.depthFar];
                      this.resizeRenderTargets(this.width, this.height);
                      // ////////////////////////////
                      // eslint-disable-next-line require-jsdoc
                      const onRefSpaceCreated = (refSpace) => {
                          this.refSpace = refSpace;
                          this.stageTreeItem.setVisible(true);
                          this.emit('presentingChanged', new StateChangedEvent(true));
                          // In VR, we need to load the HMD so we can see
                          // our controllers.
                          this.loadHMDResources().then(() => {
                              this.startSession();
                              resolve();
                          });
                      };
                      // Attempt to get a 'bounded-floor' reference space, which will align
                      // the user's physical floor with Y=0 and provide boundaries that
                      // indicate where the user can safely walk.
                      session
                          .requestReferenceSpace('bounded-floor')
                          .catch((e) => {
                          console.warn(e.message);
                          // If a bounded reference space isn't supported, fall back to a
                          // local-floor reference space. This still provides a floor-relative
                          // space and will always be supported for immersive sessions. It
                          // will not, however, provide boundaries and generally expects the
                          // user to stand in one place. If the device doesn't have a way of
                          // determining the floor level (for example, with a 3DoF device)
                          // then it will return an emulated local-floor space, where the view
                          // is translated up by a static height so that the scene still
                          // renders in approximately the right place.
                          console.log('Falling back to local-floor reference space');
                          session.requestReferenceSpace('local-floor').then(onRefSpaceCreated);
                      })
                          .then((value) => {
                          if (value)
                              onRefSpaceCreated(value);
                      })
                          .catch((e) => {
                          console.warn(e.message);
                          reject(new Error('Unable to start XR Session:' + e.message));
                      });
                  })
                      .catch((e) => {
                      console.warn(e.message);
                  });
              };
              startPresenting();
          });
      }
      // //////////////////////////
      // Controllers
      /**
       * The updateControllers method.
       * @param xrFrame - The xrFrame value.
       * @param event - The pose changed event object that will be emitted for observers such as collab.
       */
      updateControllers(xrFrame) {
          let rebindRenderTarget = false;
          const inputSources = this.session.inputSources;
          for (let i = 0; i < inputSources.length; i++) {
              const inputSource = inputSources[i];
              // Note: This is to avoid a bug/feature in WebXR where initially the
              // controllers have no handedness specified, then suddenly
              // get handedness. We need the handedness before we can setup the controller.
              if (inputSource.profiles.length == 0)
                  return;
              if (!this.controllers[i]) {
                  console.warn('Missing controller');
                  continue;
                  // this.__createController(i, inputSource)
              }
              const res = this.controllers[i].updatePose(this.refSpace, xrFrame, inputSource);
              rebindRenderTarget = rebindRenderTarget || res;
          }
          return rebindRenderTarget;
      }
      /**
       * The drawXRFrame method.
       * @param xrFrame - The xrFrame value.
       */
      drawXRFrame(xrFrame) {
          const session = xrFrame.session;
          const layer = session.renderState.baseLayer;
          const pose = xrFrame.getViewerPose(this.refSpace);
          if (!pose) {
              // No pose available during XR present
              // Note: before the Headset is put on the pose is missing, or after it is taken off
              return;
          }
          const views = pose.views;
          if (!this.projectionMatricesUpdated) {
              this.projectionMatrices = [];
              this.viewMatrices = [];
              this.cameraMatrices = [];
              for (let i = 0; i < views.length; i++) {
                  const view = views[i];
                  const projMat = new Mat4();
                  projMat.fromArray(view.projectionMatrix);
                  this.projectionMatrices[i] = projMat;
                  this.viewMatrices[i] = new Mat4();
                  this.cameraMatrices[i] = new Mat4();
              }
              this.projectionMatricesUpdated = true;
          }
          const gl = this.__renderer.gl;
          this.depthRange = [session.renderState.depthNear, session.renderState.depthFar]; // TODO: check if this changes during session
          const renderstate = new ColorRenderState(this.__renderer.gl);
          renderstate.pushGLStack('VRViewport.drawXRFrame');
          renderstate.boundRendertarget = layer.framebuffer;
          renderstate.region = this.region;
          renderstate.depthRange = this.depthRange;
          renderstate.viewport = this;
          renderstate.xrviewport = this;
          const viewports = [];
          for (let i = 0; i < views.length; i++) {
              const view = views[i];
              this.viewMatrices[i].fromArray(view.transform.inverse.matrix);
              this.viewMatrices[i].multiplyInPlace(this.invStageMatrix);
              const vp = layer.getViewport(view);
              viewports.push({
                  viewMatrix: this.viewMatrices[i],
                  projectionMatrix: this.projectionMatrices[i],
                  region: [vp.x, vp.y, vp.width, vp.height],
                  isOrthographic: 0,
              });
          }
          this.xrhead.update(pose);
          const headXfo = this.xrhead.getTreeItem().globalXfoParam.value;
          const cameraMatrixMat4 = headXfo.toMat4();
          this.viewXfo = headXfo;
          renderstate.viewXfo = headXfo;
          renderstate.cameraMatrix = cameraMatrixMat4;
          renderstate.viewScale = this.stageScale;
          renderstate.region = this.region;
          renderstate.vrPresenting = true; // Some rendering is adjusted slightly in VR. e.g. Billboards
          this.updateControllers(xrFrame);
          // ///////////////////////
          // Prepare the pointerMove event.
          const event = new XRPoseEvent(this, this.viewXfo, this.controllers);
          if (event.getCapture()) {
              event.getCapture().onPointerMove(event);
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
          }
          if (this.manipulator && event.propagating) {
              this.manipulator.onPointerMove(event);
          }
          // ///////////////////////
          // Binding
          this.bindXRViewport(renderstate, viewports);
          // ///////////////////////
          // Drawing
          // If any of the controllers did some raycasting, then we need to rebind the
          // WebXR render target before we draw the scene.
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, renderstate.boundRendertarget);
          let col = this.backgroundColorParam.value.asArray();
          gl.clearColor(col[0], col[1], col[2], col[3]);
          gl.colorMask(true, true, true, true);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          this.draw(renderstate);
          renderstate.popGLStack();
          if (renderstate.stack.length != 0) {
              console.warn(' corrupt renderstate.stack.length:', renderstate.stack.length);
          }
          // ///////////////////////
          // Emit a signal for the shared session.
          const viewChangedEvent = new XRViewChangedEvent(renderstate.viewXfo);
          // TODO: better solution than setting members individually?
          viewChangedEvent.hmd = this.hmd;
          viewChangedEvent.controllers = this.controllers;
          viewChangedEvent.viewport = this;
          viewChangedEvent.xrviewport = this;
          this.emit('viewChanged', viewChangedEvent);
          this.tick++;
      }
      /**
       * Handler of the `pointerdown` event fired when the pointer device is initially pressed.
       *
       * @param event - The DOM event produced by a pointer
       */
      onPointerDown(event) {
          event.intersectionData = event.controller.getGeomItemAtTip();
          event.pointerRay = event.controller.pointerRay;
          // //////////////////////////////////////
          // Double Tap
          // First check for double tap handlers.
          // If the manipulator or the viewport handle that
          // then skip the 'pointerDown' event.
          const downTime = Date.now();
          if (downTime - this.controllerPointerDownTime[event.controller.id][event.button] < this.doubleClickTime) {
              this.emit('pointerDoubleClick', event);
              if (!event.propagating)
                  return;
              if (this.manipulator) {
                  this.manipulator.onPointerDoubleClick(event);
                  if (!event.propagating)
                      return;
              }
          }
          this.controllerPointerDownTime[event.controller.id][event.button] = downTime;
          // //////////////////////////////////////
          if (event.getCapture()) {
              event.getCapture().onPointerDown(event);
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
              if (!event.propagating)
                  return;
          }
          if (event.intersectionData != undefined) {
              event.intersectionData.geomItem.onPointerDown(event);
              if (!event.propagating)
                  return;
          }
          this.emit('pointerDown', event);
          if (!event.propagating)
              return;
          if (this.manipulator) {
              this.manipulator.onPointerDown(event);
          }
      }
      /**
       * Causes an event to occur when a user releases a mouse button over a element.
       *
       * @param event - The event that occurs.
       */
      onPointerUp(event) {
          event.pointerRay = event.controller.pointerRay;
          if (event.getCapture()) {
              event.getCapture().onPointerUp(event);
              // events are now always sent to the capture item first,
              // but can continue propagating to other items if no call
              // to event.stopPropagation() was made.
          }
          if (event.propagating) {
              event.intersectionData = event.controller.getGeomItemAtTip();
              if (event.intersectionData != undefined) {
                  event.intersectionData.geomItem.onPointerUp(event);
              }
          }
          if (event.propagating) {
              this.emit('pointerUp', event);
          }
          if (event.propagating) {
              if (this.manipulator) {
                  this.manipulator.onPointerUp(event);
              }
          }
          const pointerDownTime = this.controllerPointerDownTime[event.controller.id][event.button];
          const pointerUpTime = Date.now();
          if (pointerUpTime - pointerDownTime < this.clickTime) {
              event.propagating = true;
              if (event.intersectionData != undefined) {
                  event.intersectionData.geomItem.onPointerClick(event);
              }
              if (event.propagating) {
                  this.emit('pointerClick', event);
              }
              if (event.propagating && this.manipulator) {
                  this.manipulator.onPointerClick(event);
              }
          }
          this.controllerPointerDownTime[event.controller.id][event.button] = 0;
      }
  }

  /** This Viewport class is used for rendering stereoscopic views to VR controllers using the WebXR api.
   *  When the GLRenderer class detects a valid WebXF capable device is plugged in, this class is automatically
   *  instantiated ready for XR sessions
   *
   * **Events**
   * * **presentingChanged:** Emitted when presenting is started or stopped
   * * **controllerAdded:** Emitted when a new XR controller is detected.
   * * **viewChanged:** Emitted during presentation each time the frame is rendered.
   * * **pointerDoubleClick:** Emitted when the user double clicks with an XR pointer.
   * * **pointerDown:** Emitted when the user presses an XR pointer
   * * **pointerUp:** Emitted when the user releases an XR pointer
   *
   * @extends XRViewport
   */
  class ARViewport extends XRViewport {
      stageXfoSet = false;
      xrViewerSpace;
      xrHitTestSource;
      reticle;
      /**
       * Create a VR viewport.
       * @param renderer - The renderer value.
       */
      constructor(renderer, sessionMode) {
          super(renderer, sessionMode);
          const disc = new Disc(0.1, 24);
          const material = new FlatSurfaceMaterial('reticle');
          material.baseColorParam.value = new Color(0.75, 0.75, 0.75, 0.4);
          this.reticle = new GeomItem('reticle', disc, material);
          // Convert Y-Up to Z-Up.
          const xfo = new Xfo();
          // Convert Y-Up to Z-Up.
          xfo.ori.setFromAxisAndAngle(new Vec3(1, 0, 0), Math.PI * 0.5);
          this.reticle.geomOffsetXfoParam.value = xfo;
          this.stageTreeItem.addChild(this.reticle);
      }
      /**
       * The startPresenting method.
       */
      startPresenting() {
          return new Promise((resolve, reject) => {
              // https://github.com/immersive-web/webxr/blob/master/explainer.md
              const startPresenting = () => {
                  // @ts-ignore
                  navigator.xr
                      .requestSession('immersive-ar', { requiredFeatures: ['local', 'hit-test', 'anchors'] })
                      .then((session) => {
                      session.addEventListener('end', () => {
                          this.stageTreeItem.setVisible(false);
                          this.session = null;
                          this.emit('presentingChanged', new StateChangedEvent(false));
                      });
                      this.reticle.setVisible(true);
                      const onSelect = (event) => {
                          const hitTestResults = event.frame.getHitTestResults(this.xrHitTestSource);
                          if (hitTestResults.length > 0) {
                              const pose = hitTestResults[0].getPose(this.refSpace);
                              if (this.reticle.isVisible()) {
                                  if (!this.stageXfoSet) {
                                      this.stageXfo.tr = this.reticle.globalXfoParam.value.tr.negate();
                                      this.setXfo(this.stageXfo);
                                      this.stageXfoSet = true;
                                  }
                                  else {
                                      const pointerEvent = new XRPointerEvent(this, this.reticle.globalXfoParam.value, event, hitTestResults);
                                      this.emit('pointerPressed', pointerEvent);
                                  }
                              }
                              else {
                                  const localXfo = new Xfo();
                                  localXfo.setFromMat4(new Mat4(...pose.transform.matrix));
                                  const pointerEvent = new XRPointerEvent(this, this.stageXfo.multiply(localXfo), event, hitTestResults);
                                  this.emit('pointerPressed', pointerEvent);
                              }
                          }
                      };
                      session.addEventListener('select', onSelect);
                      this.session = session;
                      // ////////////////////////////
                      // @ts-ignore - Note: We could install the webxr type definitions and remove this ignore.
                      const glLayer = new XRWebGLLayer(session, this.__gl);
                      session.updateRenderState({
                          baseLayer: glLayer,
                      });
                      this.width = glLayer.framebufferWidth;
                      this.height = glLayer.framebufferHeight;
                      this.region = [0, 0, this.width, this.height];
                      this.depthRange = [session.renderState.depthNear, session.renderState.depthFar];
                      this.resizeRenderTargets(this.width, this.height);
                      // ////////////////////////////
                      // In this sample we want to cast a ray straight out from the viewer's
                      // position and render a reticle where it intersects with a real world
                      // surface. To do this we first get the viewer space, then create a
                      // hitTestSource that tracks it.
                      session.requestReferenceSpace('viewer').then((refSpace) => {
                          this.xrViewerSpace = refSpace;
                          session.requestHitTestSource({ space: this.xrViewerSpace }).then((hitTestSource) => {
                              this.xrHitTestSource = hitTestSource;
                          });
                      });
                      session.requestReferenceSpace('local').then((refSpace) => {
                          this.refSpace = refSpace;
                          this.stageTreeItem.setVisible(true);
                          this.emit('presentingChanged', new StateChangedEvent(true));
                          this.startSession();
                          resolve();
                      });
                  })
                      .catch((e) => {
                      console.warn(e.message);
                  });
              };
              startPresenting();
          });
      }
      /**
       * The drawXRFrame method.
       * @param xrFrame - The xrFrame value.
       */
      drawXRFrame(xrFrame) {
          const session = xrFrame.session;
          const layer = session.renderState.baseLayer;
          const pose = xrFrame.getViewerPose(this.refSpace);
          if (!pose) {
              // No pose available during XR present
              // Note: before the Headset is put on the pose is missing, or after it is taken off
              return;
          }
          if (this.xrHitTestSource && this.reticle.isVisible()) {
              const hitTestResults = xrFrame.getHitTestResults(this.xrHitTestSource);
              if (hitTestResults.length > 0) {
                  const hitPose = hitTestResults[0].getPose(this.refSpace);
                  const localXfo = new Xfo();
                  localXfo.setFromMat4(new Mat4(hitPose.transform.matrix));
                  this.reticle.localXfoParam.value = localXfo;
              }
          }
          const views = pose.views;
          if (!this.projectionMatricesUpdated) {
              this.projectionMatrices = [];
              this.viewMatrices = [];
              this.cameraMatrices = [];
              for (let i = 0; i < views.length; i++) {
                  const view = views[i];
                  const projMat = new Mat4();
                  projMat.fromArray(view.projectionMatrix);
                  this.projectionMatrices[i] = projMat;
                  this.viewMatrices[i] = new Mat4();
                  this.cameraMatrices[i] = new Mat4();
              }
              this.projectionMatricesUpdated = true;
          }
          this.depthRange = [session.renderState.depthNear, session.renderState.depthFar]; // TODO: check if this changes during session
          const renderstate = new ColorRenderState(this.__renderer.gl);
          renderstate.boundRendertarget = layer.framebuffer;
          renderstate.region = this.region;
          renderstate.viewport = this;
          renderstate.xrviewport = this;
          const viewports = [];
          // renderstate.boundRendertarget.vrfbo = true;
          for (let i = 0; i < views.length; i++) {
              const view = views[i];
              this.viewMatrices[i].fromArray(view.transform.inverse.matrix);
              // Note: the stage matrix
              this.viewMatrices[i].multiplyInPlace(this.invStageMatrix);
              // this.cameraMatrices[i].fromArray(view.transform.matrix);
              const vp = layer.getViewport(view);
              viewports.push({
                  viewMatrix: this.viewMatrices[i],
                  projectionMatrix: this.projectionMatrices[i],
                  region: [vp.x, vp.y, vp.width, vp.height],
                  isOrthographic: 0,
              });
          }
          this.viewXfo.setFromMat4(new Mat4(pose.transform.matrix));
          renderstate.viewXfo = this.stageXfo.multiply(this.viewXfo);
          renderstate.cameraMatrix = renderstate.viewXfo.toMat4();
          renderstate.viewScale = this.stageScale;
          renderstate.region = this.region;
          renderstate.vrPresenting = true; // Some rendering is adjusted slightly in VR. e.g. Billboards
          // ///////////////////////
          // Binding
          this.bindXRViewport(renderstate, viewports);
          this.draw(renderstate);
          {
              // ///////////////////////
              // Prepare the pointerMove event.
              const event = new XRPoseEvent(this, this.viewXfo);
              if (event.getCapture()) {
                  event.getCapture().onPointerMove(event);
                  // events are now always sent to the capture item first,
                  // but can continue propagating to other items if no call
                  // to event.stopPropagation() was made.
              }
              if (this.manipulator && event.propagating) {
                  this.manipulator.onPointerMove(event);
              }
          }
          // ///////////////////////
          // Emit a signal for the shared session.
          const viewChangedEvent = new XRViewChangedEvent(renderstate.viewXfo);
          // TODO: better solution than setting members individually?
          viewChangedEvent.viewport = this;
          viewChangedEvent.xrviewport = this;
          this.emit('viewChanged', viewChangedEvent);
          this.tick++;
      }
  }

  /* eslint-disable guard-for-in */
  /*
     drawGeomData(renderstate: GeomDataRenderState) {
  -    this.glMaterial.bind(renderstate, false)
  +    // this.glMaterial.bind(renderstate, false)
       for (const key in this.glGeomItemSets) {
         const glGeomItemSet = this.glGeomItemSets[key]
         glGeomItemSet.draw(renderstate)
       }
  -    this.glMaterial.unbind(renderstate)
  +    // this.glMaterial.unbind(renderstate)
     }
  */
  /** Class for managing all the GeomItems discovered in the SceneTree.
   * @private
   */
  class GLGeomItemLibrary extends EventEmitter {
      renderer;
      // Note: item 0 is always null.
      // The reduction shader reads pixel values, and assumes 0 is an empty pixel.
      glGeomItems = [null];
      glGeomItemEventHandlers = [];
      glGeomItemsMap = new Map();
      glGeomItemsIndexFreeList = [];
      dirtyItemIndices = new Set();
      // Items that have transform or bounding box changes and need to be updated in the worker.
      dirtyWorkerItemIndices = new Set();
      removedItemIndices = [];
      glGeomItemsTexture = null;
      enableFrustumCulling;
      xrViewport;
      xrPresenting = false;
      xrFovY = 0.0;
      xrProjectionMatrix = new Mat4();
      // Occlusion Culling
      enableOcclusionCulling;
      debugOcclusionBuffer = false;
      occlusionDataBuffer;
      occlusionImage;
      occlusionImageItem;
      reductionDataBuffer;
      bbox;
      reductionShader;
      boundingBoxShader;
      inFrustumIndicesCount = 0;
      drawIdsBufferDirty = false;
      inFrustumDrawIdsBuffer;
      reductionDataArray;
      occlusionDataBufferSizeFactor = window.devicePixelRatio;
      timer_query_ext = null;
      worker;
      /**
       * Create a GLGeomItemLibrary.
       * @param renderer - The renderer instance
       * @param options - The options object passed to the GLRenderer constructor.
       */
      constructor(renderer, options) {
          super();
          this.renderer = renderer;
          this.enableFrustumCulling = options.enableFrustumCulling || options.enableOcclusionCulling;
          // Note: while it would be possible to get Occlusion Culling working in WebGL1,
          // we would need to jump through a lot of hoops.
          // - setup a vertex attribute to emulate gl_VertexID (in the Reduction shader)
          // - implement bit masking so we can extract the geomItemId from the Uint8 geom data buffer.
          // - clean up all the code to not use the building % , << & operators
          // - pass uniform values for the texture sizes.
          const gl = this.renderer.gl;
          this.enableOcclusionCulling = options.enableOcclusionCulling && gl.name == 'webgl2';
          this.debugOcclusionBuffer = options.debugOcclusionBuffer ?? false;
          if (this.enableFrustumCulling) {
              this.setupCullingWorker(renderer);
          }
      }
      /**
       * Sets up the Culling Worker to start calculating frustum culling.
       * @param renderer - The renderer instance
       */
      setupCullingWorker(renderer) {
          this.worker = new WorkerFactory();
          // This is a mock web worker to use when testing.
          // this.worker = {
          //   postMessage: (message) => {
          //     handleMessage(message, (message) => {
          //       this.worker.onmessage({data: message })
          //     })
          //   },
          // }
          this.worker.postMessage({
              type: 'Init',
              enableOcclusionCulling: this.enableOcclusionCulling,
          });
          let workerReady = true;
          this.worker.onmessage = (message) => {
              if (message.data.type == 'InFrustumIndices') {
                  if (this.enableOcclusionCulling) {
                      // First full the items that the frustum culling removed.
                      if (message.data.newlyCulled) {
                          this.applyCullResults(message.data);
                      }
                      this.calculateOcclusionCulling(message.data.inFrustumIndices);
                  }
                  else {
                      this.applyCullResults(message.data);
                      this.emitCullingUpdateData(message.data);
                      workerReady = true;
                  }
              }
              else if (message.data.type == 'CullResults') {
                  this.applyCullResults(message.data);
                  this.emitCullingUpdateData(message.data);
                  workerReady = true;
              }
              else if (message.data.type == 'Done') {
                  // Used mostly to make our unit testing robust.
                  this.renderer.emit('CullingUpdated');
              }
              workerReady = true;
          };
          const viewportChanged = () => {
              const viewport = renderer.getViewport();
              const camera = renderer.getViewport().getCamera();
              const aspectRatio = viewport.getWidth() / viewport.getHeight();
              if (camera.isOrthographic()) {
                  const frustumHeight = camera.getFrustumHeight();
                  const frustumWidth = frustumHeight * aspectRatio;
                  this.worker.postMessage({
                      type: 'ViewportChanged',
                      frustumHeight,
                      frustumWidth,
                      isOrthographic: true,
                      solidAngleLimit: renderer.solidAngleLimit,
                  });
              }
              else {
                  const frustumHalfAngleY = camera.getFov() * 0.5;
                  const frustumHalfAngleX = Math.atan(Math.tan(frustumHalfAngleY) * aspectRatio);
                  this.worker.postMessage({
                      type: 'ViewportChanged',
                      frustumHalfAngleX,
                      frustumHalfAngleY,
                      isOrthographic: false,
                      solidAngleLimit: renderer.solidAngleLimit,
                  });
              }
          };
          renderer.on('resized', viewportChanged);
          const camera = renderer.getViewport().getCamera();
          camera.on('projectionParamChanged', (event) => {
              if (camera.isOrthographic()) {
                  viewportChanged();
              }
          });
          viewportChanged();
          renderer.once('xrViewportSetup', (event) => {
              this.xrViewport = event.xrViewport;
              const xrvp = event.xrViewport;
              xrvp.on('presentingChanged', (event) => {
                  this.xrPresenting = event.state;
                  if (event.state) {
                      cullFreq = 10;
                      let frustumHalfAngleX;
                      let frustumHalfAngleY;
                      if (xrvp instanceof VRViewport) {
                          // Note: We approximate the culling viewport to be
                          // a wider version of the 2 eye frustums merged together.
                          // Wider, so that items are considered visible before the are in view.
                          // Note each VR headset comes with its own FOV, and I can't seem to be
                          // able to get it from the WebXR API, so I am putting in some guesses
                          // based on this diagram: https://blog.mozvr.com/content/images/2016/02/human-visual-field.jpg
                          frustumHalfAngleX = MathFunctions.degToRad(62);
                          frustumHalfAngleY = MathFunctions.degToRad(50);
                      }
                      else if (xrvp instanceof ARViewport) {
                          // TODO: determine the frustum size for a phone.
                          const aspectRatio = xrvp.getWidth() / xrvp.getHeight();
                          frustumHalfAngleY = 62 * MathFunctions.degToRad(0.5);
                          frustumHalfAngleX = Math.atan(Math.tan(frustumHalfAngleY) * aspectRatio);
                      }
                      this.xrFovY = frustumHalfAngleY * 2.0;
                      const aspect = frustumHalfAngleY / frustumHalfAngleX;
                      // @ts-ignore
                      const near = xrvp.depthRange[0];
                      // @ts-ignore
                      const far = xrvp.depthRange[1];
                      this.xrProjectionMatrix.setPerspectiveMatrix(this.xrFovY, aspect, near, far);
                      this.worker.postMessage({
                          type: 'ViewportChanged',
                          frustumHalfAngleX,
                          frustumHalfAngleY,
                          isOrthographic: false,
                          solidAngleLimit: renderer.solidAngleLimit * 4,
                      });
                      this.occlusionDataBuffer.resize(Math.ceil(xrvp.getWidth() / 4), Math.ceil(xrvp.getWidth() / 4));
                  }
                  else {
                      cullFreq = 5;
                      viewportChanged();
                      // push the camera xfo to the worker.
                      forceViewChanged();
                  }
              });
          });
          let tick = 0;
          let cullFreq = 5;
          renderer.on('viewChanged', (event) => {
              // Calculate culling every Nth frame.
              if (workerReady) {
                  if (tick % cullFreq == 0) {
                      workerReady = false;
                      const pos = event.viewXfo.tr;
                      const ori = event.viewXfo.ori;
                      this.worker.postMessage({
                          type: 'ViewChanged',
                          cameraPos: pos.asArray(),
                          cameraOri: ori.asArray(),
                          solidAngleLimit: renderer.solidAngleLimit,
                      });
                  }
                  tick++;
              }
          });
          const forceViewChanged = () => {
              const camera = renderer.getViewport().getCamera();
              const viewXfo = camera.globalXfoParam.value;
              const pos = viewXfo.tr;
              const ori = viewXfo.ori;
              this.worker.postMessage({
                  type: 'ViewChanged',
                  cameraPos: pos.asArray(),
                  cameraOri: ori.asArray(),
                  solidAngleLimit: renderer.solidAngleLimit,
              });
          };
          // If a movement finishes, we should update the culling results
          // based on the last position. (we might have skipped it in the viewChanged handler above)
          renderer.getViewport().getCamera().on('movementFinished', forceViewChanged);
          // Initialize the view values on the worker.
          forceViewChanged();
          {
              // ////////////////////////////////////////
              // Occlusion Culling
              if (this.enableOcclusionCulling) {
                  const gl = this.renderer.gl;
                  // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query_webgl2/
                  // this.timer_query_ext = gl.getExtension('EXT_disjoint_timer_query_webgl2')
                  const occlusionDataBufferWidth = Math.ceil(this.renderer.getWidth() / this.occlusionDataBufferSizeFactor);
                  const occlusionDataBufferHeight = Math.ceil(this.renderer.getHeight() / this.occlusionDataBufferSizeFactor);
                  this.occlusionDataBuffer = new GLRenderTarget(gl, {
                      type: gl.FLOAT,
                      format: gl.RGBA,
                      minFilter: gl.NEAREST,
                      magFilter: gl.NEAREST,
                      width: occlusionDataBufferWidth,
                      height: occlusionDataBufferHeight,
                      depthType: gl.UNSIGNED_INT,
                      depthFormat: gl.DEPTH_COMPONENT,
                      depthInternalFormat: gl.DEPTH_COMPONENT24,
                  });
                  // this.occlusionDataBuffer.clearColor.set(0.1, 0, 0, 1)
                  this.renderer.on('resized', (event) => {
                      if (!this.xrPresenting) {
                          this.occlusionDataBuffer.resize(Math.ceil(event.width / this.occlusionDataBufferSizeFactor), Math.ceil(event.height / this.occlusionDataBufferSizeFactor));
                      }
                  });
                  // Do we resize the occlusion buffer to match the screen resolution of the HMD?
                  // So far we are not seeing great performance in XR with culling enabled.
                  // For some reason, reduction is already 10x more costly in VR with the same
                  // resolution occlusion buffer.
                  // renderer.once('xrViewportSetup', (event: XrViewportEvent) => {
                  //   console.log('xrViewportSetup')
                  //   const xrvp = event.xrViewport
                  //   xrvp.on('presentingChanged', (event: StateChangedEvent) => {
                  //     if (event.state) {
                  //       occlusionDataBufferSizeFactor = 0.2
                  //       this.occlusionDataBuffer.resize(
                  //         Math.ceil(xrvp.getWidth() / occlusionDataBufferSizeFactor),
                  //         Math.ceil(xrvp.getWidth() / occlusionDataBufferSizeFactor)
                  //       )
                  //     } else {
                  //       occlusionDataBufferSizeFactor = 1
                  //       this.occlusionDataBuffer.resize(
                  //         Math.ceil(this.renderer.getWidth() / occlusionDataBufferSizeFactor),
                  //         Math.ceil(this.renderer.getWidth() / occlusionDataBufferSizeFactor)
                  //       )
                  //     }
                  //     this.occlusionImage.setData(
                  //       this.occlusionDataBuffer.width,
                  //       this.occlusionDataBuffer.height,
                  //       this.occlusionDataBuffer.textureTargets[0]
                  //     )
                  //   })
                  // })
                  this.reductionDataBuffer = new GLRenderTarget(gl, {
                      type: gl.UNSIGNED_BYTE,
                      internalFormat: gl.R8,
                      format: gl.RED,
                      minFilter: gl.NEAREST,
                      magFilter: gl.NEAREST,
                      width: 1,
                      height: 1,
                      depthType: gl.UNSIGNED_SHORT,
                      depthFormat: gl.DEPTH_COMPONENT,
                      depthInternalFormat: gl.DEPTH_COMPONENT16,
                  });
                  this.bbox = new GLLines(gl, new BBoxOcclusionLinesCuboid());
                  this.reductionShader = new ReductionShader(gl);
                  this.boundingBoxShader = new BoundingBoxShader(gl);
                  this.boundingBoxShader.compileForTarget('GLGeomItemLibrary', this.renderer.directives);
                  this.inFrustumIndicesCount = 0;
              }
          }
      }
      /**
       * Handles applying the culling results received from the GLGeomItemLibraryCullingWorker
       * @param {object} data - The object containing the newlyCulled and newlyUnCulled results.
       */
      applyCullResults(data) {
          // return
          if (data.newlyCulled) {
              data.newlyCulled.forEach((index) => {
                  if (this.glGeomItems[index])
                      this.glGeomItems[index].setCulled(true);
              });
          }
          if (data.newlyUnCulled) {
              data.newlyUnCulled.forEach((index) => {
                  // console.log('newlyUnCulled:', this.glGeomItems[index].geomItem.getName())
                  if (this.glGeomItems[index])
                      this.glGeomItems[index].setCulled(false);
              });
          }
          this.renderer.requestRedraw();
      }
      /**
       * @private
       * @param data
       */
      emitCullingUpdateData(data) {
          // Used mostly to make our unit testing robust.
          // Also to help display render stats.
          // console.log(`visible: ${data.visible} / total: ${data.total}`)
          this.renderer.emit('CullingUpdated', {
              culled: data.newlyCulled?.length,
              unCulled: data.newlyUnCulled?.length,
              visible: data.visible,
              total: data.total,
              visibleGeomStats: data.visibleGeomStats,
              totalGeomStats: data.totalGeomStats,
          });
      }
      /**
       * Given the IDs of the items we know are in the frustum, setup an instanced attribute we can use
       * to render bounding boxes for these items if they do not show up in the initial GPU buffer.
       * @param {Float32Array} inFrustumIndices - The array of indices of items we know are in the frustum.
       */
      updateCulledDrawIDsBuffer(inFrustumIndices) {
          const gl = this.renderer.gl;
          if (!gl.floatTexturesSupported) {
              this.drawIdsBufferDirty = false;
              return;
          }
          if (this.inFrustumDrawIdsBuffer && this.inFrustumIndicesCount != inFrustumIndices.length) {
              gl.deleteBuffer(this.inFrustumDrawIdsBuffer);
              this.inFrustumDrawIdsBuffer = null;
          }
          if (!this.inFrustumDrawIdsBuffer) {
              this.inFrustumDrawIdsBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, inFrustumIndices, gl.STATIC_DRAW);
          this.inFrustumIndicesCount = inFrustumIndices.length;
          this.drawIdsBufferDirty = false;
          // Note: we get errors trying to read data back from images less than 4x4 pixels.
          const size = Math.max(4, MathFunctions.nextPow2(Math.round(Math.sqrt(this.glGeomItems.length) + 0.5)));
          if (this.reductionDataBuffer.width != size) {
              this.reductionDataBuffer.resize(size, size);
              this.reductionDataArray = new Uint8Array(size * size);
          }
      }
      /**
       * Calculate a further refinement of the culling by using the GPU to see which items are actually visible.
       * @param inFrustumIndices - The array of indices of items we know are in the frustum.
       */
      calculateOcclusionCulling(inFrustumIndices) {
          if (inFrustumIndices && inFrustumIndices.length > 0) {
              this.updateCulledDrawIDsBuffer(inFrustumIndices);
          }
          if (this.inFrustumIndicesCount == 0) {
              this.worker.postMessage({
                  type: 'OcclusionData',
                  visibleItems: [],
              });
              return;
          }
          const gl = this.renderer.gl;
          const renderstate = new GeomDataRenderState(gl);
          renderstate.pushGLStack('calculateOcclusionCulling');
          this.renderer.bindGLRenderer(renderstate);
          renderstate.directives = [...this.renderer.directives, '#define DRAW_GEOMDATA'];
          renderstate.floatGeomBuffer = true;
          renderstate.occlusionCulling = 1;
          if (this.xrPresenting) {
              this.xrViewport.bindCullingViewport(renderstate, this.xrFovY, this.xrProjectionMatrix);
          }
          else {
              this.renderer.getViewport().bindGLViewport(renderstate);
          }
          // this.renderer.drawSceneGeomData(renderstate)
          const drawSceneGeomData = (renderstate) => {
              this.occlusionDataBuffer.bindForWriting(renderstate, true);
              renderstate.glDisable(gl.BLEND);
              renderstate.glDisable(gl.CULL_FACE);
              renderstate.glEnable(gl.DEPTH_TEST);
              gl.depthFunc(gl.LESS);
              gl.depthMask(true);
              // For now, just rendering the main opaque geoms.
              const opaqueGeomsPass = this.renderer.getPass(0);
              opaqueGeomsPass.drawGeomData(renderstate);
              const linesPass = this.renderer.getPass(1);
              linesPass.drawGeomData(renderstate);
              // for (const key in this.__passes) {
              //   // Skip pass categories that do not match
              //   // the mask. E.g. we may not want to hit
              //   // "Overlay" geoms such as labels,
              //   // or we might be trying to move labels and don't
              //   // want to grab normal geoms.
              //   if ((Number.parseInt(key) & mask) == 0) continue
              //   const passSet = this.__passes[key]
              //   for (const pass of passSet) {
              //     if (pass.enabled) pass.drawGeomData(renderstate)
              //   }
              // }
              this.occlusionDataBuffer.unbindForWriting(renderstate);
          };
          // Draw one point for each pixel in the occlusion buffer.
          // This point will color a single pixel in the reduction buffer.
          const numReductionPoints = this.occlusionDataBuffer.width * this.occlusionDataBuffer.height;
          const ext = this.timer_query_ext;
          // Now perform a reduction to calculate the indices of visible items.
          const reduce = (renderstate, clear, query) => {
              this.reductionDataBuffer.bindForWriting(renderstate, clear);
              // The second time we reduce into the reductionDataBuffer, we want to
              // keep the values that were already there. The first reduction counted
              // the items visible after the scene was drawn. The second one adds items
              // visible due to the bounding boxes being visible.
              if (!clear) {
                  gl.enable(gl.BLEND);
                  gl.blendEquation(gl.FUNC_ADD);
                  gl.blendFunc(gl.SRC_COLOR, gl.DST_COLOR);
              }
              this.reductionShader.bind(renderstate);
              const { geomDataTexture, reductionTextureWidth } = renderstate.unifs;
              if (geomDataTexture)
                  this.occlusionDataBuffer.bindToUniform(renderstate, geomDataTexture);
              if (reductionTextureWidth)
                  gl.uniform1i(reductionTextureWidth.location, this.reductionDataBuffer.width);
              if (ext)
                  gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
              gl.drawArrays(gl.POINTS, 0, numReductionPoints);
              if (ext)
                  gl.endQuery(ext.TIME_ELAPSED_EXT);
              if (!clear) {
                  gl.disable(gl.BLEND);
              }
              this.reductionDataBuffer.unbindForWriting(renderstate);
          };
          const drawCulledBBoxes = () => {
              this.occlusionDataBuffer.bindForWriting(renderstate, false);
              // Now clear the color buffer, but not the depth buffer
              // and draw the bounding boxes of occluded items.
              // This means the second reduction only count fragments
              // rasterized by the bounding boxes, and not the initial
              // scene geometry.(which was counted in the first reduce)
              // Note: disable this code to see the full occlusion buffer in debugging.
              if (!this.debugOcclusionBuffer) {
                  gl.colorMask(true, true, true, true);
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT); // do _not_ clear depth.
              }
              this.boundingBoxShader.bind(renderstate, 'GLGeomItemLibrary');
              this.bbox.bind(renderstate);
              // Read each Matrix and Bbox settings from the Texture.
              const { instancesTexture, instancesTextureSize, instancedDraw, reductionDataTexture, occlusionCulling } = renderstate.unifs;
              this.glGeomItemsTexture.bindToUniform(renderstate, instancesTexture);
              gl.uniform1i(instancesTextureSize.location, this.glGeomItemsTexture.width);
              gl.uniform1i(instancedDraw.location, 1);
              this.reductionDataBuffer.bindColorTexture(renderstate, reductionDataTexture);
              // The instanced transform ids are bound as an instanced attribute.
              const location = renderstate.attrs.instancedIds.location;
              gl.enableVertexAttribArray(location);
              gl.bindBuffer(gl.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer);
              gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 1 * 4, 0);
              gl.vertexAttribDivisor(location, 1); // This makes it instanced
              // Now draw all the bounding boxes to make sure we catch anything.
              // Note: If the geometry is listed visibility buffer, we skip it.
              // Do this draws only the bounding boxes for non-visible geometries.
              renderstate.bindViewports(renderstate.unifs, () => {
                  this.bbox.drawInstanced(renderstate, this.inFrustumIndicesCount);
              });
              this.occlusionDataBuffer.unbindForWriting(renderstate);
          };
          let queryDrawScene;
          let queryReduceSceneGeoms;
          let queryDrawCulledBBoxes;
          let queryReduceBBoxes;
          if (ext) {
              queryDrawScene = gl.createQuery();
              gl.beginQuery(ext.TIME_ELAPSED_EXT, queryDrawScene);
          }
          drawSceneGeomData(renderstate);
          if (ext)
              gl.endQuery(ext.TIME_ELAPSED_EXT);
          // We render the scene geometry, reduce, then render
          // the boxes, reduce again. The bounding boxes displayed
          // are based on the results of the first reduce.
          if (ext)
              queryReduceSceneGeoms = gl.createQuery();
          reduce(renderstate, true, queryReduceSceneGeoms);
          if (ext) {
              queryDrawCulledBBoxes = gl.createQuery();
              gl.beginQuery(ext.TIME_ELAPSED_EXT, queryDrawCulledBBoxes);
          }
          //
          drawCulledBBoxes();
          // All rendering is done.
          renderstate.popGLStack();
          if (ext)
              gl.endQuery(ext.TIME_ELAPSED_EXT);
          if (ext)
              queryReduceBBoxes = gl.createQuery();
          reduce(renderstate, false, queryReduceBBoxes);
          const queryResults = {
              numReductionPoints,
          };
          const checkQuery = (name, query) => {
              const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
              const disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
              if (available && !disjoint) {
                  // See how much time the rendering of the object took in nanoseconds.
                  const timeElapsed = gl.getQueryParameter(query, gl.QUERY_RESULT);
                  queryResults[name] = timeElapsed / 1000000;
                  // Clean up the query object.
                  gl.deleteQuery(query);
              }
          };
          // //////////////////////////////////////////
          // Pull down the reduction values from the GPU for processing.
          const w = this.reductionDataBuffer.width;
          const h = this.reductionDataBuffer.height;
          const format = gl.RED;
          const type = gl.UNSIGNED_BYTE;
          this.reductionDataBuffer.bindForReading();
          readPixelsAsync(gl, 0, 0, w, h, format, type, this.reductionDataArray).then(() => {
              this.reductionDataBuffer.unbindForReading();
              if (ext) {
                  checkQuery('queryDrawScene', queryDrawScene);
                  checkQuery('queryDrawCulledBBoxes', queryDrawCulledBBoxes);
                  checkQuery('queryReduceSceneGeoms', queryReduceSceneGeoms);
                  checkQuery('queryReduceBBoxes', queryReduceBBoxes);
                  this.renderer.emit('occlusionCullingProfilingData', queryResults);
              }
              // console.log(this.reductionDataArray)
              // Now send the buffer to the worker, where it will determine what culling
              // needs to be applied on top of the frustum culling.
              this.worker.postMessage({
                  type: 'OcclusionData',
                  visibleItems: this.reductionDataArray,
              });
          });
      }
      /**
       * The addGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The index of GLGeomItem
       */
      addGeomItem(geomItem) {
          let index = this.glGeomItemsMap.get(geomItem);
          if (index != undefined) {
              // Increment the ref count for the GLGeom
              return this.glGeomItems[index];
          }
          // Use recycled indices if there are any available...
          if (this.glGeomItemsIndexFreeList.length > 0) {
              index = this.glGeomItemsIndexFreeList.pop();
          }
          else {
              index = this.glGeomItems.length;
              this.glGeomItems.push(null);
          }
          // If an item is removed and re-added immediately, we avoid removing the item from the culling worker.
          if (this.removedItemIndices.includes(index)) {
              this.removedItemIndices.splice(this.removedItemIndices.indexOf(index), 1);
          }
          this.dirtyItemIndices.add(index);
          // ///////////////////////////////////////////
          // Material
          const materialParam = geomItem.materialParam;
          let material = materialParam.value;
          // Add the material here so that when we populate the GeomItem texture.
          // the material already has an Id.
          let matIndex = this.renderer.glMaterialLibrary.addMaterial(material);
          const materialChanged = () => {
              // Ref count the materials in the material library.
              this.renderer.glMaterialLibrary.removeMaterial(material);
              material = materialParam.value;
              glGeomItem.materialId = this.renderer.glMaterialLibrary.addMaterial(material);
              workerItemDataChanged();
              geomItemChanged();
          };
          materialParam.on('valueChanged', materialChanged);
          // ///////////////////////////////////////////
          // GeomItem
          const gl = this.renderer.gl;
          const supportInstancing = material.getShaderClass().supportsInstancing();
          const geomIndex = -1;
          const glGeomItem = new GLGeomItem(gl, geomItem, index, geomIndex, matIndex, supportInstancing);
          const geomItemChanged = () => {
              if (this.dirtyItemIndices.has(index))
                  return;
              this.dirtyItemIndices.add(index);
              this.renderer.drawItemChanged();
          };
          geomItem.geomMatParam.on('valueChanged', geomItemChanged);
          geomItem.on('cutAwayChanged', geomItemChanged);
          geomItem.on('highlightChanged', geomItemChanged);
          geomItem.on('selectabilityChanged', geomItemChanged);
          geomItem.on('opacityChanged', geomItemChanged);
          const workerItemDataChanged = () => {
              if (this.enableFrustumCulling) {
                  if (!this.dirtyWorkerItemIndices.has(index)) {
                      this.dirtyWorkerItemIndices.add(index);
                      this.renderer.drawItemChanged();
                  }
              }
          };
          if (this.enableFrustumCulling) {
              this.dirtyWorkerItemIndices.add(index);
          }
          geomItem.on('visibilityChanged', workerItemDataChanged);
          geomItem.on('opacityChanged', workerItemDataChanged);
          geomItem.geomMatParam.on('valueChanged', workerItemDataChanged);
          geomItem.geomParam.on('boundingBoxChanged', workerItemDataChanged);
          this.glGeomItems[index] = glGeomItem;
          this.glGeomItemEventHandlers[index] = {
              geomItemChanged,
              materialChanged,
              workerItemDataChanged,
          };
          this.glGeomItemsMap.set(geomItem, index);
          // Note: before the renderer is disabled, this is a  no-op.
          this.renderer.requestRedraw();
          return glGeomItem;
      }
      /**
       * The removeGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      removeGeomItem(geomItem) {
          const index = this.glGeomItemsMap.get(geomItem);
          // This GeomItem may not yet have been added to the Renderer.
          // This may be because it is part of an asset that is still loading
          // and has not yet received its geometry.
          if (index == undefined)
              return null;
          const glGeomItem = this.glGeomItems[index];
          const material = geomItem.materialParam.value;
          this.renderer.glMaterialLibrary.removeMaterial(material);
          const handlers = this.glGeomItemEventHandlers[index];
          const materialParam = geomItem.materialParam;
          materialParam.off('valueChanged', handlers.materialChanged);
          geomItem.geomMatParam.off('valueChanged', handlers.geomItemChanged);
          geomItem.off('cutAwayChanged', handlers.geomItemChanged);
          geomItem.off('highlightChanged', handlers.geomItemChanged);
          geomItem.off('selectabilityChanged', handlers.geomItemChanged);
          // material.off('opacityChanged', handlers.geomItemChanged)
          geomItem.off('opacityChanged', handlers.geomItemChanged);
          geomItem.off('visibilityChanged', handlers.workerItemDataChanged);
          geomItem.geomMatParam.off('valueChanged', handlers.workerItemDataChanged);
          geomItem.off('opacityChanged', handlers.workerItemDataChanged);
          geomItem.geomParam.off('boundingBoxChanged', handlers.workerItemDataChanged);
          this.glGeomItems[index] = null;
          this.glGeomItemEventHandlers[index] = null;
          this.glGeomItemsIndexFreeList.push(index);
          this.glGeomItemsMap.delete(geomItem);
          this.removedItemIndices.push(index);
          if (this.dirtyWorkerItemIndices.has(index)) {
              this.dirtyWorkerItemIndices.delete(index);
          }
          this.renderer.requestRedraw();
          return glGeomItem;
      }
      /**
       * The getGeomItem method.
       * @param index - The index value.
       * @return - The GLGeomItem that wraps the provided GeomItem
       */
      getGeomItem(index) {
          if (index >= this.glGeomItems.length) {
              console.warn('Invalid Draw Item id:' + index + ' NumItems:' + (this.glGeomItems.length - 1));
              return undefined;
          }
          return this.glGeomItems[index]?.geomItem;
      }
      /**
       * The getGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The GLGeomItem that wraps the provided GeomItem
       */
      getGLGeomItem(geomItem) {
          const index = this.glGeomItemsMap.get(geomItem);
          if (index != undefined) {
              // Increment the ref count for the GLGeom
              return this.glGeomItems[index];
          }
          return null;
      }
      // ////////////////////////////////////////////////
      // Data Uploading
      /**
       * The populateDrawItemDataArray method.
       * @param index - The index of the item in the library.
       * @param subIndex - The index of the item within the block being uploaded.
       * @param dataArray - The dataArray value.
       * @private
       */
      populateDrawItemDataArray(index, subIndex, dataArray) {
          const glGeomItem = this.glGeomItems[index];
          // When an item is deleted, we allocate its index to the free list
          // and null this item in the array. skip over null items.
          if (!glGeomItem)
              return;
          const { geomItem, geomId } = glGeomItem;
          const material = geomItem.materialParam.value;
          const stride = pixelsPerItem$1 * 4; // The number of floats per draw item.
          const offset = subIndex * stride;
          // /////////////////////////
          // Geom Item Params
          let flags = 0;
          if (geomItem.isCutawayEnabled()) {
              flags |= GLGeomItemFlags.GEOMITEM_FLAG_CUTAWAY;
          }
          if (!geomItem.isSelectable()) {
              flags |= GLGeomItemFlags.GEOMITEM_INVISIBLE_IN_GEOMDATA;
          }
          if (!material.isOpaque() || !geomItem.isOpaque()) {
              flags |= GLGeomItemFlags.GEOMITEM_TRANSPARENT;
          }
          const pix0 = new Float32Array(dataArray.buffer, (offset + 0) * 4, 4);
          pix0[0] = flags;
          pix0[1] = geomItem.opacity;
          const allocation = this.renderer.glMaterialLibrary.getMaterialAllocation(material);
          if (allocation) {
              pix0[2] = allocation.start;
          }
          // Store the geomId for debugging purposes.
          // see: DEBUG_GEOM_ID
          pix0[4] = geomId;
          // /////////////////////////
          // Geom Matrix
          const mat4 = geomItem.geomMatParam.value;
          const pix1 = new Float32Array(dataArray.buffer, (offset + 1 * 4) * 4, 4);
          const pix2 = new Float32Array(dataArray.buffer, (offset + 2 * 4) * 4, 4);
          const pix3 = new Float32Array(dataArray.buffer, (offset + 3 * 4) * 4, 4);
          pix1.set([mat4.xAxis.x, mat4.yAxis.x, mat4.zAxis.x, mat4.translation.x]);
          pix2.set([mat4.xAxis.y, mat4.yAxis.y, mat4.zAxis.y, mat4.translation.y]);
          pix3.set([mat4.xAxis.z, mat4.yAxis.z, mat4.zAxis.z, mat4.translation.z]);
          // /////////////////////////
          // Highlight
          const pix4 = new Float32Array(dataArray.buffer, (offset + 4 * 4) * 4, 4);
          if (geomItem.isHighlighted()) {
              const highlight = geomItem.getHighlight();
              pix4.set([highlight.r, highlight.g, highlight.b, highlight.a]);
          }
          // /////////////////////////
          // Cutaway
          const pix5 = new Float32Array(dataArray.buffer, (offset + 5 * 4) * 4, 4);
          if (geomItem.isCutawayEnabled()) {
              const cutAwayVector = geomItem.getCutVector();
              const cutAwayDist = geomItem.getCutDist();
              // console.log(geomItem.getName(), geomItem.isCutawayEnabled(), flags, pix0.toString())
              pix5.set([cutAwayVector.x, cutAwayVector.y, cutAwayVector.z, cutAwayDist]);
          }
          // /////////////////////////
          // Bounding Box
          const bbox = geomItem.boundingBoxParam.value;
          const pix6 = new Float32Array(dataArray.buffer, (offset + 6 * 4) * 4);
          const pix7 = new Float32Array(dataArray.buffer, (offset + 7 * 4) * 4);
          pix6.set([bbox.p0.x, bbox.p0.y, bbox.p0.z, 0.0]);
          pix7.set([bbox.p1.x, bbox.p1.y, bbox.p1.z, 0.0]);
      }
      /**
       * Gathers data to pass to the culling worker.
       * @param geomItem - The GeomItem to gether the data for.
       * @param material - The material of GeomItem.
       * @param index - The index of the item to gether the data for.
       * @return - the JSON data that will be passed to the worker.
       */
      getCullingWorkerData(geomItem, index) {
          const bbox = geomItem.boundingBoxParam.value;
          const boundingRadius = bbox.size() * 0.5;
          const pos = bbox.center();
          const material = geomItem.materialParam.value;
          // Some items can't be culled. They should be flagged as overlay or not cullable
          const cullable = geomItem.cullable && !geomItem.isOverlay() && !material.getShaderClass().isOverlay();
          const transparent = !geomItem.isOpaque() || !material.isOpaque();
          const geomStats = {
              triangles: 0,
              lines: 0,
              points: 0,
          };
          const geom = geomItem.geomParam.value;
          if (geom instanceof CompoundGeom) {
              geomStats.triangles += geom.getNumTriangles();
              geomStats.lines += geom.getNumLineSegments();
              geomStats.points += geom.getNumPoints();
          }
          else if (geom instanceof Mesh || geom instanceof MeshProxy) {
              geomStats.triangles += geom.getNumTriangles();
          }
          else if (geom instanceof Lines || geom instanceof LinesProxy) {
              geomStats.lines += geom.getNumLineSegments();
          }
          else if (geom instanceof Points || geom instanceof PointsProxy) {
              geomStats.points += geom.getNumVertices();
          }
          else {
              throw new Error('Unsupported geom type:' + geom.constructor.name);
          }
          return {
              id: index,
              boundingRadius,
              pos: pos.asArray(),
              cullable,
              visible: geomItem.isVisible(),
              transparent,
              geomStats,
          };
      }
      /**
       * Any items that need to be updated on the worker are now pushed.
       */
      uploadGeomItemsToWorker() {
          if (this.enableFrustumCulling) {
              const geomItemsUpdateToCullingWorker = [];
              this.dirtyWorkerItemIndices.forEach((index) => {
                  const glGeomItem = this.glGeomItems[index];
                  // When an item is deleted, we allocate its index to the free list
                  // and null this item in the array. skip over null items.
                  if (!glGeomItem)
                      return;
                  const { geomItem } = glGeomItem;
                  const data = this.getCullingWorkerData(geomItem, index);
                  if (data)
                      geomItemsUpdateToCullingWorker.push(data);
              });
              // /////////////////////////
              // Update the culling worker
              this.worker.postMessage({
                  type: 'UpdateGeomItems',
                  geomItems: geomItemsUpdateToCullingWorker,
                  removedItemIndices: this.removedItemIndices,
              });
              this.dirtyWorkerItemIndices.clear();
              this.removedItemIndices = [];
          }
      }
      /**
       * The uploadGeomItems method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      uploadGeomItems(renderstate) {
          const gl = this.renderer.gl;
          if (!gl.floatTexturesSupported) {
              return;
          }
          let size = Math.round(Math.sqrt(this.glGeomItems.length * pixelsPerItem$1) + 0.5);
          // Only support power 2 textures. Else we get strange corruption on some GPUs
          // in some scenes.
          size = MathFunctions.nextPow2(size);
          // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
          // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
          if (size % pixelsPerItem$1 != 0)
              size += pixelsPerItem$1 - (size % pixelsPerItem$1);
          if (!this.glGeomItemsTexture) {
              this.glGeomItemsTexture = new GLTexture2D(gl, {
                  format: 'RGBA',
                  type: 'FLOAT',
                  width: size,
                  height: size,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  mipMapped: false,
              });
              this.glGeomItemsTexture.clear();
          }
          else if (this.glGeomItemsTexture.width != size) {
              this.glGeomItemsTexture.resize(size, size);
              this.dirtyItemIndices = new Set(Array((size * size) / pixelsPerItem$1)
                  .fill(0) // TODO: check, is 0 ok as an argument here?
                  .map((v, i) => i));
          }
          gl.bindTexture(gl.TEXTURE_2D, this.glGeomItemsTexture.glTex);
          const typeId = this.glGeomItemsTexture.getType();
          const dirtyItemIndices = Array.from(this.dirtyItemIndices);
          for (let i = 0; i < dirtyItemIndices.length; i++) {
              const indexStart = dirtyItemIndices[i];
              const yoffset = Math.floor((indexStart * pixelsPerItem$1) / size);
              let indexEnd = indexStart + 1;
              for (let j = i + 1; j < dirtyItemIndices.length; j++) {
                  const index = dirtyItemIndices[j];
                  if (Math.floor((index * pixelsPerItem$1) / size) != yoffset) {
                      break;
                  }
                  if (index != indexEnd) {
                      break;
                  }
                  indexEnd++;
              }
              // TODO: for contiguous blocks, we create larger arrays and populate
              // and upload them in one step.
              const uploadCount = indexEnd - indexStart;
              const xoffset = (indexStart * pixelsPerItem$1) % size;
              const width = pixelsPerItem$1 * uploadCount;
              const height = 1;
              const dataArray = new Float32Array(pixelsPerItem$1 * 4 * uploadCount); // 4==RGBA pixels.
              for (let j = indexStart; j < indexEnd; j++) {
                  this.populateDrawItemDataArray(j, j - indexStart, dataArray);
              }
              if (typeId == gl.FLOAT) {
                  this.glGeomItemsTexture.populate(dataArray, width, height, xoffset, yoffset, false);
              }
              else {
                  const unit16s = MathFunctions.convertFloat32ArrayToUInt16Array(dataArray);
                  this.glGeomItemsTexture.populate(unit16s, width, height, xoffset, yoffset, false);
              }
              i += uploadCount - 1;
          }
          this.removedItemIndices = [];
          this.dirtyItemIndices = new Set();
      }
      /**
       * Updates the GPU state if any update is needed.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bind(renderstate) {
          if (this.dirtyWorkerItemIndices.size > 0 || this.removedItemIndices.length > 0) {
              this.uploadGeomItemsToWorker();
          }
          if (this.dirtyItemIndices.size > 0) {
              this.uploadGeomItems(renderstate);
          }
          const gl = this.renderer.gl;
          const { instancesTexture, instancesTextureSize } = renderstate.unifs;
          if (instancesTexture) {
              this.glGeomItemsTexture.bindToUniform(renderstate, instancesTexture);
              gl.uniform1i(instancesTextureSize.location, this.glGeomItemsTexture.width);
          }
      }
  }

  var frag$f = "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float outlineThickness;\nuniform sampler2D highlightDataTexture;\n\nvarying vec2 v_texCoord;\n\nfloat M_PI = 3.141592653589793;\nfloat diff(vec4 pixelA, vec4 pixelB)\n{\n  return abs(pixelA.r - pixelB.r) + abs(pixelA.g - pixelB.g) + abs(pixelA.b - pixelB.b) + abs(pixelA.a - pixelB.a);\n}\n\n// find the first pixel which is not the same as the center pixel.\nvec4 RadialSearch(vec2 uv)\n{\n  vec2 texSize = vec2(textureSize(highlightDataTexture, 0));\n  ivec2 pixelCenterCoord = ivec2(uv * texSize);\n  vec4 pixelCenter = texelFetch(highlightDataTexture, pixelCenterCoord, 0);\n\n  vec3 offset = vec3((1.0 / texSize.x), (1.0 / texSize.y), 0.0);\n\n  vec4 result = pixelCenter;\n  float weights = 1.0;\n  float radius = 0.0;\n  int differentPixels = 0;\n  while (radius <= outlineThickness + 0.001) {\n    radius += 1.0;\n    \n    int samples = int(2.0 * M_PI * radius);\n    for (int i =0; i<samples; i++) {\n      float theta = (float(i) / float(samples)) * 2.0 * M_PI;\n      vec2 dir = vec2(radius * cos(theta) * offset.x, radius * sin(theta) * offset.y);\n      \n      ivec2 pixelCoord = ivec2((uv + dir) * texSize);\n      vec4 pixel = texelFetch(highlightDataTexture, pixelCoord, 0);\n      if ((pixel.r > 0.0 || pixel.g > 0.0 || pixel.b > 0.0)) {\n        if (diff(pixel, pixelCenter) > 0.1) differentPixels++;\n        // Blend the outer ring of pixels.\n        // Note: disabled because I ran out of time. We can blend off the highlight towards\n        // the edges to get a nicely anti-aliazed outline. \n        // float dist = length(vec2(pixelCoord) - vec2(pixelCenterCoord));\n        // float blendStart = max(1.0, outlineThickness - 0.5);\n        pixel.a = 1.0; //smoothstep(1.0, 0.0, dist - blendStart);\n\n        result += pixel;\n        weights += pixel.a;\n      }\n    }\n  }\n\n  // Note: at the boundary between 2 highlighted objects, we get a nice blending effect. \n  if (weights > 1.0) {\n    result = result / weights;\n  }\n\n  // If all the pixels found are the same as the center pixel, we just\n  // return the center pixel.\n  if (differentPixels == 0) {\n    return pixelCenter;\n  }\n\n  return result;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n    \n  vec4 outlineColor = RadialSearch(v_texCoord);\n  \n  if (outlineColor.a > 0.0001) {\n#ifndef ENABLE_ES3\n    gl_FragColor = outlineColor;\n#else\n    fragColor = outlineColor;\n#endif\n  }\n  else {\n    discard;\n  }\n}\n\n"; // eslint-disable-line

  var vert$g = "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class HighlightsShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'HighlightsShader');
          this.setShaderStage('VERTEX_SHADER', vert$g);
          this.setShaderStage('FRAGMENT_SHADER', frag$f);
      }
  }

  var frag$e = "\n#ifndef ENABLE_ES3\n#extension GL_EXT_frag_depth: enable\n#endif\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\nuniform vec2 depthRange;\n\nuniform float outlineThickness;\nuniform color outlineColor;\nuniform float outlineSensitivity;\nuniform float outlineDepthBias;\n\nvarying vec2 v_texCoord;\n\n// http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\nfloat LinearEyeDepth(float z_b) {\n  float z_n = 2.0 * z_b - 1.0;\n  float z_e = 2.0 * depthRange.x * depthRange.y / (depthRange.y + depthRange.x - z_n * (depthRange.y - depthRange.x));\n  return z_e;\n}\n\nfloat LogEyeDepth(float z_b) {\n  return depthRange.x + ((depthRange.y - depthRange.x) * z_b);\n}\n\n// https://www.vertexfragment.com/ramblings/unity-postprocessing-sobel-outline/#depth-based-outline\n// https://github.com/ssell/UnitySobelOutline/blob/2e1f4a5b4e703ae2c96aaf08d5518ce58abbaab9/Assets/Resources/Shaders/SobelOutlineHLSL.shader\n\nfloat SobelDepth(float ldc, float ldl, float ldr, float ldu, float ldd)\n{\n  return abs(ldl - ldc) +\n      abs(ldr - ldc) +\n      abs(ldu - ldc) +\n      abs(ldd - ldc);\n}\n\nfloat SobelSampleDepth(vec2 uv, vec3 offset)\n{\n  float pixelCenter = LinearEyeDepth(texture2D(depthTexture, uv).r);\n  float pixelLeft   = LinearEyeDepth(texture2D(depthTexture, uv - offset.xz).r);\n  float pixelRight  = LinearEyeDepth(texture2D(depthTexture, uv + offset.xz).r);\n  float pixelUp     = LinearEyeDepth(texture2D(depthTexture, uv + offset.zy).r);\n  float pixelDown   = LinearEyeDepth(texture2D(depthTexture, uv - offset.zy).r);\n\n  float  outlineDepthMultiplier = (1.0 / pixelCenter) * outlineSensitivity;\n\n  return SobelDepth(pixelCenter, pixelLeft, pixelRight, pixelUp, pixelDown) * outlineDepthMultiplier;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec3 offset = vec3((1.0 / screenSize.x), (1.0 / screenSize.y), 0.0) * outlineThickness;\n  float sobelDepth = SobelSampleDepth(v_texCoord, offset);\n  float sobelValue = pow(sobelDepth, outlineDepthBias);\n\n  float minEdgeValue = 0.25;\n  float maxEdgeValue = 0.55;\n  sobelDepth = smoothstep(minEdgeValue, maxEdgeValue, sobelValue);\n\n#ifdef ENABLE_ES3\n  fragColor = vec4(outlineColor.rgb, sobelDepth);\n#else\n  fragColor = vec4(mix(texture2D(colorTexture, v_texCoord).rgb, outlineColor.rgb, sobelDepth), 1.0);\n#ifdef  GL_EXT_frag_depth\n  gl_FragDepthEXT = texture2D(depthTexture, v_texCoord).r;\n#endif\n#endif\n\n  // float z = texture2D(depthTexture, v_texCoord).r;\n  // float near = depthRange.x * 2.0;    // the near plane\n  // float far = depthRange.y / 2.0;     // the far plane\n  // float c = (2.0 * near) / (far + near - z * (far - near));  // convert to linear values \n  // fragColor = vec4(vec3(c), 1.0);\n\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$f = "\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class SilhouetteShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'SilhouetteShader');
          this.setShaderStage('VERTEX_SHADER', vert$f);
          this.setShaderStage('FRAGMENT_SHADER', frag$e);
      }
  }

  /* eslint-disable guard-for-in */
  let activeGLRenderer;
  let pointerIsDown = false;
  let pointerLeft = false;
  const registeredPasses = [];
  // On Firefox, this provides better performance.
  // Portafill from 24FPS to 28fps....
  // https://hackmd.io/@jgilbert/HkwAQHKRr?type=view#Use-requestPostAnimationFrame-not-requestAnimationFrame
  let requestPostAnimationFrame;
  // @ts-ignore
  if (globalThis.requestPostAnimationFrame) {
      // @ts-ignore
      requestPostAnimationFrame = window.requestPostAnimationFrame;
  }
  else {
      // @ts-ignore
      requestPostAnimationFrame = function (callback) {
          requestAnimationFrame(() => {
              setTimeout(callback, 0);
          });
      };
  }
  /**
   * Class representing a GL base renderer.
   *
   * @extends ParameterOwner
   */
  class GLBaseRenderer extends ParameterOwner {
      #listenerIDs = new Map();
      directives = [];
      directivesHash;
      solidAngleLimit = 0.004;
      __gl;
      glcanvas = null;
      #scene = null;
      #shaderDirectives = {};
      #renderGeomDataFbosRequested = false;
      #shaders = {};
      #passes = {};
      #passAssignments = new Map();
      #passesRegistrationOrder = [];
      #viewports = [];
      #activeViewport = undefined;
      #continuousDrawing = false;
      #redrawRequested = false;
      #drawSuspensionLevel = 0;
      floatGeomBuffer = true;
      multiSampledScreenBuffer = false;
      xrViewportPresenting = false;
      xrViewport = undefined;
      #xrViewportPromise;
      glMaterialLibrary;
      glGeomItemLibrary;
      glGeomLibrary;
      highlightsShader;
      silhouetteShader;
      screenQuad = null;
      #resizeObserver;
      #onResizeCallback;
      /**
       * Create a GL base renderer.
       * @param $canvas - The canvas element.
       * @param options - The options value.
       */
      constructor($canvas, options = {}) {
          super();
          if (!SystemDesc.gpuDesc) {
              throw new Error('Unable to create renderer. WebGL not Supported');
          }
          // Function Bindings.
          this.requestRedraw = this.requestRedraw.bind(this);
          this.__gl = this.setupWebGL($canvas, options);
          const gl = this.__gl;
          this.highlightsShader = new HighlightsShader(gl);
          this.silhouetteShader = new SilhouetteShader(gl);
          this.screenQuad = new GLScreenQuad(this.__gl, this.directives);
          this.bindEventHandlers();
          const mainViewport = this.addViewport('main');
          mainViewport.debugGeomDataBuffer = options.debugGeomDataBuffer;
          mainViewport.debugOcclusionBuffer = options.debugOcclusionBuffer;
          this.glMaterialLibrary = new GLMaterialLibrary(this);
          this.glMaterialLibrary.on('updated', () => {
              this.requestRedraw();
          });
          this.glGeomLibrary = new GLGeomLibrary(this);
          this.glGeomLibrary.on('updated', () => {
              this.requestRedraw();
          });
          this.glGeomItemLibrary = new GLGeomItemLibrary(this, options);
          this.glGeomItemLibrary.on('updated', () => {
              this.requestRedraw();
          });
          registeredPasses.forEach((reg) => {
              // eslint-disable-next-line new-cap
              // @ts-ignore
              const pass = new reg.cls();
              this.addPass(pass, reg.passType);
          });
          // ////////////////////////////////////////////
          // WebXR
          this.#xrViewportPromise = new Promise((resolve, reject) => {
              if ((options.supportXR ?? true) && navigator.xr) {
                  const sessionMode = (options.xrMode ?? 'VR') == 'AR' ? 'immersive-ar' : 'immersive-vr';
                  const setupXRViewport = () => {
                      this.xrViewport = this.setupXRViewport(sessionMode);
                      let event = new XrViewportEvent(this.xrViewport);
                      this.emit('xrViewportSetup', event);
                      resolve(this.xrViewport);
                  };
                  navigator.xr
                      .isSessionSupported(sessionMode)
                      .then((isSupported) => {
                      if (isSupported) {
                          setupXRViewport();
                      }
                  })
                      .catch((reason) => {
                      console.warn('Unable to setup XR:' + reason);
                      reject('Unable to setup XR:' + reason);
                  });
              }
          });
      }
      /**
       * The setShaderPreprocessorDirective method.
       * @param name - The name value.
       * @param value - The value param.
       */
      setShaderPreprocessorDirective(name, value) {
          // const gl = this.__gl
          this.#shaderDirectives[name] = value;
          const directives = [];
          let str = '';
          // eslint-disable-next-line guard-for-in
          for (const key in this.#shaderDirectives) {
              const directive = this.#shaderDirectives[key];
              directives.push(directive);
              str += directive;
          }
          this.directives = directives;
          this.directivesHash = '' + StringFunctions.hashStr(str);
      }
      /**
       * Returns HTMLCanvasElement's width
       *
       * @return - The return value.
       */
      getWidth() {
          return this.glcanvas.width;
      }
      /**
       * Returns HTMLCanvasElement's Height
       * @return - The return value.
       */
      getHeight() {
          return this.glcanvas.height;
      }
      // //////////////////////////////////////
      // Viewports
      /**
       * Adds a new viewport(viewing region) to the scene.
       *
       * @param name - The name of the viewport.
       * @return - The return value.
       */
      addViewport(name) {
          // TODO: We may need to merge GLBaseRenderer into GLRenderer to avoid this nasty cast.
          const renderer = this;
          const vp = new GLViewport(renderer, name, this.getWidth(), this.getHeight());
          const updated = () => {
              this.requestRedraw();
          };
          const viewChanged = (data) => {
              if (!this.xrViewportPresenting) {
                  this.emit('viewChanged', data);
              }
          };
          vp.on('updated', updated);
          vp.on('viewChanged', viewChanged);
          this.#viewports.push(vp);
          this.#activeViewport = vp;
          return vp;
      }
      /**
       * Returns a viewport element by specifying its index in the list of viewports.
       *
       * @param index - The index value.
       * @return - The return value.
       */
      getViewport(index = 0) {
          return this.#viewports[index];
      }
      /**
       * Returns a viewport element under the specified XY coordinates.
       *
       * @param offsetX - The viewport offset in the X axis.
       * @param offsetY - The viewport offset in the Y axis.
       * @return - The return value.
       */
      getViewportAtPos(offsetX, offsetY) {
          for (const vp of this.#viewports) {
              const x = vp.getPosX();
              const y = vp.getPosY();
              const width = vp.getWidth();
              const height = vp.getHeight();
              if (offsetX >= x && offsetY >= y && offsetX <= width + x && offsetY <= height + y)
                  return vp;
          }
          return undefined;
      }
      /**
       * Sets as `active` the specified viewport.
       *
       * @param vp - The viewport.
       */
      activateViewport(vp) {
          if (this.#activeViewport == vp)
              return;
          this.#activeViewport = vp;
      }
      /**
       * Sets as ctive` the viewport under the specified XY coordinates.
       *
       * @param offsetX - The viewport offset in the X axis.
       * @param offsetY - The viewport offset in the Y axis.
       */
      activateViewportAtPos(offsetX, offsetY) {
          if (this.xrViewportPresenting)
              return;
          const vp = this.getViewportAtPos(offsetX, offsetY);
          if (vp && vp != this.#activeViewport)
              this.activateViewport(vp);
      }
      /**
       * Returns current active viewport.
       *
       * @return - The return value.
       */
      getActiveViewport() {
          return this.#activeViewport;
      }
      /**
       * The suspendDrawing method.
       */
      suspendDrawing() {
          this.#drawSuspensionLevel++;
      }
      /**
       * The resumeDrawing method.
       */
      resumeDrawing() {
          this.#drawSuspensionLevel--;
          if (this.#drawSuspensionLevel == 0) {
              this.renderGeomDataFbos();
              this.requestRedraw();
          }
      }
      /**
       * The renderGeomDataFbos method. Frame buffer (FBO).
       */
      renderGeomDataFbos() {
          if (this.#renderGeomDataFbosRequested == true)
              return;
          this.#renderGeomDataFbosRequested = true;
          const onAnimationFrame = () => {
              for (const vp of this.#viewports)
                  vp.invalidateGeomDataBuffer();
              this.#renderGeomDataFbosRequested = false;
          };
          requestPostAnimationFrame(onAnimationFrame);
      }
      // //////////////////////////////////////
      // Scene
      /**
       * Returns current scene(Environment where all assets live) object.
       *
       * @return - The return value.
       */
      getScene() {
          return this.#scene;
      }
      /**
       * Sets scene to the renderer.
       *
       * @param scene - The scene value.
       */
      setScene(scene) {
          this.#scene = scene;
          this.addTreeItem(this.#scene.getRoot());
          let event = new SceneSetEvent(this.#scene);
          this.emit('sceneSet', event);
      }
      /**
       * Adds tree items to the renderer, selecting the correct pass to delegate rendering too, and listens to future changes in the tree.
       *
       * @param treeItem - The tree item to add.
       */
      addTreeItem(treeItem) {
          // Note: we can have BaseItems in the tree now.
          if (!(treeItem instanceof TreeItem))
              return;
          const listenerIDs = {};
          let continueInSubTree = true;
          if (treeItem instanceof GeomItem) {
              const geomParam = treeItem.geomParam;
              if (geomParam.value == undefined) {
                  // we will add this geomItem once it receives its geom.
                  const geomAssigned = () => {
                      delete listenerIDs['Geometry.valueChanged'];
                      this.assignTreeItemToGLPass(treeItem);
                  };
                  listenerIDs['Geometry.valueChanged'] = geomParam.once('valueChanged', geomAssigned);
              }
              else {
                  continueInSubTree = this.assignTreeItemToGLPass(treeItem);
              }
          }
          else {
              continueInSubTree = this.assignTreeItemToGLPass(treeItem);
          }
          if (continueInSubTree) {
              // Traverse the tree adding items until we hit the leaves (which are usually GeomItems.)
              for (const childItem of treeItem.getChildren()) {
                  if (childItem)
                      this.addTreeItem(childItem);
              }
              listenerIDs['childAdded'] = treeItem.on('childAdded', (event) => {
                  this.addTreeItem(event.childItem);
              });
              listenerIDs['childRemoved'] = treeItem.on('childRemoved', (event) => {
                  this.removeTreeItem(event.childItem);
              });
          }
          listenerIDs['visibilityChanged'] = treeItem.on('visibilityChanged', (event) => {
              this.renderGeomDataFbos();
          });
          this.#listenerIDs.set(treeItem, listenerIDs);
          this.renderGeomDataFbos();
      }
      /**
       * Searches through the passes and finds the appropriate pass to draw the given tree items.
       *
       * @param treeItem - The tree item to assign.
       */
      assignTreeItemToGLPass(treeItem) {
          if (treeItem instanceof GeomItem) {
              const geomItem = treeItem;
              this.glGeomItemLibrary.addGeomItem(geomItem);
          }
          for (let i = this.#passesRegistrationOrder.length - 1; i >= 0; i--) {
              const pass = this.#passesRegistrationOrder[i];
              const rargs = {
                  continueInSubTree: true,
              };
              const handled = pass.itemAddedToScene(treeItem, rargs);
              if (handled) {
                  this.#passAssignments.set(treeItem, pass);
                  return rargs.continueInSubTree;
              }
          }
          return true;
      }
      /**
       * Remove tree items from the scene.
       *
       * @param treeItem - The tree item to remove.
       */
      removeTreeItem(treeItem) {
          // Note: we can have BaseItems in the tree now.
          if (!(treeItem instanceof TreeItem))
              return;
          const listenerIDs = this.#listenerIDs.get(treeItem);
          this.#listenerIDs.delete(treeItem);
          treeItem.off('visibilityChanged', listenerIDs['visibilityChanged']);
          const pass = this.#passAssignments.get(treeItem);
          if (pass != undefined) {
              const rargs = {
                  continueInSubTree: true,
              };
              pass.itemRemovedFromScene(treeItem, rargs);
              this.#passAssignments.delete(treeItem);
          }
          // Note: if 'continueInSubTree' was false when adding the
          //  item to the tree these listeners were never bound.
          const continueInSubTree = listenerIDs['childAdded'] != undefined && listenerIDs['childRemoved'] != undefined;
          if (continueInSubTree) {
              treeItem.off('childAdded', listenerIDs['childAdded']);
              treeItem.off('childRemoved', listenerIDs['childRemoved']);
              // Traverse the tree adding items till we hit the leaves (which are usually GeomItems).
              for (const childItem of treeItem.getChildren()) {
                  if (childItem)
                      this.removeTreeItem(childItem);
              }
          }
          if (treeItem instanceof GeomItem) {
              const geomItem = treeItem;
              if (listenerIDs['Geometry.valueChanged']) {
                  const geomParam = treeItem.geomParam;
                  geomParam.off('valueChanged', listenerIDs['Geometry.valueChanged']);
              }
              this.glGeomItemLibrary.removeGeomItem(geomItem);
          }
          this.renderGeomDataFbos();
      }
      // ///////////////////////
      // Renderer Setup
      /**
       * Getter for gl.
       */
      get gl() {
          return this.__gl;
      }
      /**
       * The getGL method.
       * @return - The return value.
       */
      getGL() {
          return this.__gl;
      }
      /**
       * Handle the canvas's parent resizing.
       *
       * @param newWidth - The new width of the canvas.
       * @param newHeight - The new height of the canvas.
       *
       * @private
       */
      handleResize(newWidth, newHeight) {
          if (this.xrViewportPresenting) {
              return;
          }
          const width = Math.round(Math.max(4, newWidth) * window.devicePixelRatio);
          const height = Math.round(Math.max(4, newHeight) * window.devicePixelRatio);
          if (this.glcanvas.width != width || this.glcanvas.height != height) {
              this.glcanvas.width = width;
              this.glcanvas.height = height;
              this.#viewports.forEach((viewport) => {
                  viewport.resize(width, height);
              });
              const event = new ResizedEvent(width, height);
              this.emit('resized', event);
              this.requestRedraw();
          }
      }
      /**
       * Returns host div of the canvas element.
       *
       * @return - The return value.
       */
      getDiv() {
          return this.glcanvas.parentElement;
      }
      /**
       * Setups the WebGL configuration for the renderer, specifying the canvas element where our
       * @private
       * @param $canvas - The $canvas element.
       * @param webglOptions - The webglOptions value.
       */
      setupWebGL($canvas, options = {}) {
          const { tagName } = $canvas;
          if (!['DIV', 'CANVAS'].includes(tagName)) {
              throw new Error('Only CANVAS and DIV are valid root elements.');
          }
          const rootIsDiv = tagName === 'DIV';
          this.glcanvas = $canvas;
          if (rootIsDiv) {
              console.warn('@GLBaseRenderer#setupWebGL.', 'Using a DIV as root element is deprecated.', 'Use a CANVAS instead.', 'See: https://docs.zea.live/zea-engine/#/getting-started/get-started-with-engine?id=basic-setup');
              this.glcanvas = document.createElement('canvas');
              $canvas.appendChild(this.glcanvas);
          }
          else {
              this.glcanvas = $canvas;
          }
          this.glcanvas.style['touch-action'] = 'none';
          this.glcanvas.style['user-select'] = 'none';
          this.glcanvas.style['-webkit-user-select'] = 'none';
          this.glcanvas.style['-webkit-touch-callout'] = 'none';
          this.glcanvas.parentElement.style.position = 'relative';
          // Now scrollbars can appear causing the content size to change,
          // causing an infinite loop of resizing.
          this.glcanvas.parentElement.style.overflow = 'hidden';
          this.glcanvas.style.width = '100%';
          this.glcanvas.style.height = '100%';
          this.glcanvas.style.position = 'absolute';
          // Rapid resizing of the canvas would cause issues with WebGL.
          // FrameBuffer objects would end up all black. So here we throttle
          // the resizing of the canvas to ensure 2 resize commands are not
          // closer than 100ms appart.
          const throttledResize = throttle((entries) => {
              if (!this.__gl)
                  return;
              if (this.__gl.isContextLost()) {
                  console.warn('WebGL Context Lost');
                  return;
              }
              if (!Array.isArray(entries) || !entries.length)
                  return;
              for (const entry of entries) {
                  if (!entry.contentRect)
                      return;
                  const displayWidth = Math.round(entry.contentRect.width);
                  const displayHeight = Math.round(entry.contentRect.height);
                  this.handleResize(displayWidth, displayHeight);
              }
          }, 500);
          this.#onResizeCallback = () => {
              // The ResizeObserver below will miss zoom changes, while this
              // resize event catches them. Both may be triggered by window
              // resizes, but the throttle function ensures we don't resize
              // needlessly.
              const entries = [
                  {
                      contentRect: {
                          width: this.glcanvas.parentElement.clientWidth,
                          height: this.glcanvas.parentElement.clientHeight,
                      },
                  },
              ];
              throttledResize(entries);
          };
          window.addEventListener('resize', this.#onResizeCallback);
          // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
          this.#resizeObserver = new ResizeObserver(throttledResize);
          try {
              // only call us of the number of device pixels changed
              // @ts-ignore
              this.#resizeObserver.observe(this.glcanvas.parentNode, { box: 'device-pixel-content-box' });
          }
          catch (ex) {
              // device-pixel-content-box is not supported so fallback to this
              // @ts-ignore
              this.#resizeObserver.observe(this.glcanvas.parentNode, { box: 'content-box' });
          }
          this.handleResize(this.glcanvas.parentElement.clientWidth, this.glcanvas.parentElement.clientHeight);
          const disablingOnMacOsChrome = SystemDesc.OS === 'macOS' && SystemDesc.browserName === 'Chrome';
          const disablingOnMobileSafari = SystemDesc.isIOSDevice;
          const webglOptions = {};
          webglOptions.preserveDrawingBuffer = true; // Note: The unit tests all render black if this is false
          webglOptions.antialias = disablingOnMacOsChrome || disablingOnMobileSafari ? false : options.antialias ?? true;
          webglOptions.depth = true;
          webglOptions.stencil = true;
          webglOptions.alpha = options.alpha ?? true;
          webglOptions.premultipliedAlpha = options.premultipliedAlpha ?? false;
          // Detect if an XR Compatible device is plugged in and automatically enable XR.
          if (navigator.xr || options.supportXR) {
              webglOptions.xrCompatible = true;
          }
          this.multiSampledScreenBuffer = webglOptions.antialias;
          // Most applications of our engine will prefer the high-performance context by default.
          webglOptions.powerPreference = options.powerPreference || 'high-performance';
          const gl = create3DContext(this.glcanvas, webglOptions);
          if (!gl)
              alert('Unable to create WebGL context. WebGL not supported.');
          if (gl.name == 'webgl2') {
              this.setShaderPreprocessorDirective('ENABLE_ES3', '#define ENABLE_ES3');
          }
          if (gl.floatTexturesSupported) {
              this.setShaderPreprocessorDirective('ENABLE_FLOAT_TEXTURES', '#define ENABLE_FLOAT_TEXTURES');
          }
          {
              // Note: disabling multi-draw on Chrome on OsX as it runs incredibly slowly.
              const disableOnChromeAndMacOS = SystemDesc.browserName == 'Chrome' && SystemDesc.OS === 'macOS';
              if (disableOnChromeAndMacOS && options.disableMultiDraw != false) {
                  console.warn('Disabling multi-draw on Chrome on OsX due to performance issues.', SystemDesc);
              }
              const shouldDisableMultiDraw = options.disableMultiDraw || disableOnChromeAndMacOS;
              const ext = gl.name == 'webgl2' ? gl.getExtension('WEBGL_multi_draw') : null;
              if (ext && (!shouldDisableMultiDraw || options.disableMultiDraw == false)) {
                  gl.multiDrawArrays = ext.multiDrawArraysWEBGL.bind(ext);
                  gl.multiDrawElements = ext.multiDrawElementsWEBGL.bind(ext);
                  gl.multiDrawElementsInstanced = ext.multiDrawElementsInstancedWEBGL.bind(ext);
                  gl.multiDrawArraysInstanced = ext.multiDrawArraysInstancedWEBGL.bind(ext);
              }
              else {
                  this.setShaderPreprocessorDirective('EMULATE_MULTI_DRAW', '#define EMULATE_MULTI_DRAW');
              }
          }
          // Note: Mobile devices don't provide much support for reading data back from float textures,
          // and checking compatibility is patchy at best.
          // Note: We are now pushing on high-end mobile devices.
          // Galaxy and above. We need this. We need to accurately determine
          // if the float buffer is not supported.
          if (SystemDesc.browserName == 'Safari' && gl.name == 'webgl') {
              this.floatGeomBuffer = false;
          }
          else {
              this.floatGeomBuffer = options.floatGeomBuffer != undefined ? options.floatGeomBuffer : gl.floatTexturesSupported;
          }
          gl.floatGeomBuffer = this.floatGeomBuffer;
          return gl;
      }
      /**
       * Binds IO event handlers to the canvas
       */
      bindEventHandlers() {
          // ////////////////////////////////
          // Setup event handlers
          const isValidCanvas = () => this.getWidth() > 0 && this.getHeight();
          /** Mouse Events Start */
          // Mobile devices emulate mouse events after emitting touch events
          // which causes double taps and other weirdness.
          const isMobileDeviceMouseEvent = (event) => {
              if (SystemDesc.isMobileDevice) {
                  // console.warn('Mobile device is triggering mouse event:', event.type)
                  return true;
              }
              return false;
          };
          this.glcanvas.addEventListener('mousedown', (event) => {
              if (isMobileDeviceMouseEvent()) {
                  return;
              }
              const pointerEvent = new ZeaMouseEvent(event, this.glcanvas.getBoundingClientRect());
              pointerIsDown = true;
              activeGLRenderer = this;
              this.activateViewportAtPos(pointerEvent.rendererX, pointerEvent.rendererY);
              const viewport = this.getActiveViewport();
              if (viewport) {
                  viewport.onPointerDown(pointerEvent);
              }
              pointerLeft = false;
          });
          document.addEventListener('mouseup', (event) => {
              if (isMobileDeviceMouseEvent()) {
                  return;
              }
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              const pointerEvent = new ZeaMouseEvent(event, this.glcanvas.getBoundingClientRect());
              pointerIsDown = false;
              const viewport = this.getActiveViewport();
              if (viewport) {
                  viewport.onPointerUp(pointerEvent);
              }
              if (pointerLeft) {
                  if (viewport) {
                      viewport.onPointerLeave(pointerEvent);
                  }
                  activeGLRenderer = undefined;
              }
          });
          document.addEventListener('mousemove', (event) => {
              if (isMobileDeviceMouseEvent()) {
                  return;
              }
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              const pointerEvent = new ZeaMouseEvent(event, this.glcanvas.getBoundingClientRect());
              if (!pointerIsDown)
                  this.activateViewportAtPos(pointerEvent.rendererX, pointerEvent.rendererY);
              const viewport = this.getActiveViewport();
              if (viewport) {
                  viewport.onPointerMove(pointerEvent);
              }
          });
          this.glcanvas.addEventListener('mouseenter', (event) => {
              if (isMobileDeviceMouseEvent()) {
                  return;
              }
              if (!pointerIsDown) {
                  activeGLRenderer = this;
                  const pointerEvent = new ZeaMouseEvent(event, this.glcanvas.getBoundingClientRect());
                  this.activateViewportAtPos(pointerEvent.rendererX, pointerEvent.rendererY);
                  if (!pointerIsDown) {
                      const viewport = this.getActiveViewport();
                      if (viewport) {
                          viewport.onPointerEnter(pointerEvent);
                      }
                  }
                  pointerLeft = false;
              }
          });
          this.glcanvas.addEventListener('mouseleave', (event) => {
              if (isMobileDeviceMouseEvent()) {
                  return;
              }
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              const pointerEvent = new ZeaMouseEvent(event, this.glcanvas.getBoundingClientRect());
              if (!pointerIsDown) {
                  const viewport = this.getActiveViewport();
                  if (viewport) {
                      viewport.onPointerLeave(pointerEvent);
                  }
                  activeGLRenderer = undefined;
              }
              else {
                  pointerLeft = true;
              }
          });
          document.addEventListener('contextmenu', (event) => {
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              // prevent context menu from being displayed when right clicking on the viewport.
              // Note: we allow context menus for other items.
              event.preventDefault();
              event.stopPropagation();
          });
          /** Mouse Events End */
          /** Touch Events Start */
          this.glcanvas.addEventListener('touchstart', (event) => {
              activeGLRenderer = this;
              const viewport = this.getActiveViewport();
              const pointerEvent = new ZeaTouchEvent(event, this.glcanvas.getBoundingClientRect());
              viewport.onPointerDown(pointerEvent);
          }, { passive: true });
          this.glcanvas.addEventListener('touchend', (event) => {
              const viewport = this.getActiveViewport();
              const pointerEvent = new ZeaTouchEvent(event, this.glcanvas.getBoundingClientRect());
              viewport.onPointerUp(pointerEvent);
          }, { passive: true });
          this.glcanvas.addEventListener('touchmove', (event) => {
              const viewport = this.getActiveViewport();
              const pointerEvent = new ZeaTouchEvent(event, this.glcanvas.getBoundingClientRect());
              viewport.onPointerMove(pointerEvent);
          }, { passive: true });
          this.glcanvas.addEventListener('touchcancel', (event) => {
              const viewport = this.getActiveViewport();
              const pointerEvent = new ZeaTouchEvent(event, this.glcanvas.getBoundingClientRect());
              viewport.onTouchCancel(pointerEvent);
          }, { passive: true });
          /** Touch Events End */
          const onWheel = (event) => {
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              if (activeGLRenderer) {
                  const pointerEvent = new ZeaWheelEvent(event, this.glcanvas.getBoundingClientRect());
                  const vp = activeGLRenderer.getActiveViewport();
                  if (vp) {
                      vp.onWheel(pointerEvent);
                  }
              }
          };
          /** DOMMouseScroll is for mozilla. */
          window.addEventListener('wheel', onWheel, { passive: false });
          document.addEventListener('keydown', (event) => {
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              const keyboardEvent = new ZeaKeyboardEvent(event);
              const vp = activeGLRenderer.getActiveViewport();
              if (vp) {
                  vp.onKeyDown(keyboardEvent);
              }
          });
          document.addEventListener('keyup', (event) => {
              if (activeGLRenderer != this || !isValidCanvas())
                  return;
              const keyboardEvent = new ZeaKeyboardEvent(event);
              const vp = activeGLRenderer.getActiveViewport();
              if (vp) {
                  vp.onKeyUp(keyboardEvent);
              }
          });
      }
      /**
       * Returns canvas that was used to generate the gl context.
       *
       * @return - The return value.
       */
      getGLCanvas() {
          return this.glcanvas;
      }
      /**
       * Frames the specified viewport to the entire scene.
       * > See also: ${Viewport#frameView}
       * @param viewportIndex - The viewportIndex value. If multiple viewports are configured, a viewport index will need to be provided.
       * @param duration - The duration of time to apply the frame. A value of 0 specifies an instantaneous movement of the camera.
       * @param frameBorder - The variable to use to provide an empty space around the border for geometries.
       */
      frameAll(viewportIndex = 0, duration = 0, frameBorder = 0.1) {
          this.#viewports[viewportIndex].frameView([this.#scene.getRoot()], duration, frameBorder);
      }
      // ///////////////////////
      // Render Items Setup
      /**
       * A factory function used to construct new shader objects. If that specified shader has already been constructed, it returns the existing shader.
       * @param shaderName - The shader name.
       * @return - The return value.
       */
      getOrCreateShader(shaderName) {
          let glShader = this.#shaders[shaderName];
          if (!glShader) {
              glShader = Registry.constructClass(shaderName);
              if (!glShader)
                  console.error('@GLBaseRenderer#getOrCreateShader - Shader not registered with the Registry:', shaderName);
              glShader.setGLContext(this.__gl);
              this.#shaders[shaderName] = glShader;
          }
          return glShader;
      }
      /**
       * The addPass method.
       * @param pass - The pass value.
       * @param passType - The passType value.
       * @param updateIndices - The updateIndices value.
       * @return - The return value.
       */
      addPass(pass, passType = -1) {
          if (passType == -1)
              passType = pass.getPassType();
          if (!this.#passes[passType])
              this.#passes[passType] = [];
          let index = 0;
          for (const key in this.#passes) {
              if (key == passType.toString())
                  break;
              index += this.#passes[key].length;
          }
          index += this.#passes[passType].length;
          pass.on('updated', (event) => {
              this.requestRedraw();
              // If a pass is requesting an update, it is because geometry or
              // visibility is changing and the geom data Fbo will also be out
              // of date.
              this.renderGeomDataFbos();
          });
          // @ts-ignore TODO: Merge GLRenderer and GLBaseRenderer.
          pass.init(this, index);
          this.#passes[passType].push(pass);
          // Now update all the  subsequent pass indices because the
          // indices after will have changed.
          let offset = 0;
          for (const key in this.#passes) {
              const passSet = this.#passes[key];
              passSet.forEach((pass, index) => {
                  pass.setPassIndex(offset + index);
              });
              offset += passSet.length;
          }
          this.#passesRegistrationOrder.push(pass);
          this.requestRedraw();
          return index;
      }
      /**
       * The getPass method.
       * @param index - The index value.
       * @return - The return value.
       */
      getPass(index) {
          let offset = 0;
          for (const key in this.#passes) {
              const passSet = this.#passes[key];
              if (index - offset < passSet.length)
                  return passSet[index - offset];
              offset += passSet.length;
          }
          return undefined;
      }
      /**
       * Find a pass given a class type. Used by the GPViewport to find the GLOverlayPass.
       * @param index - The index value.
       * @return - The return value.
       */
      findPassIndex(cls) {
          let offset = 0;
          for (const key in this.#passes) {
              const passSet = this.#passes[key];
              for (let i = 0; i < passSet.length; i++) {
                  if (passSet[i] instanceof cls)
                      return offset;
                  offset++;
              }
          }
          return -1;
      }
      // ///////////////////////
      // VR Setup
      /**
       * The setupXRViewport method.
       */
      setupXRViewport(sessionMode) {
          // Always get the last display. Additional displays are added at the end.(e.g. [Polyfill, HMD])
          const xrvp = sessionMode == 'immersive-ar' ? new ARViewport(this, sessionMode) : new VRViewport(this, sessionMode);
          const emitViewChanged = (event) => {
              this.emit('viewChanged', event);
          };
          xrvp.on('presentingChanged', (event) => {
              const state = event.state;
              // Note: the WebXREmulator does a double emit and this causes issues.
              if (this.xrViewportPresenting == state)
                  return;
              this.xrViewportPresenting = state;
              if (state) {
                  // Let the passes know that VR is starting.
                  // They can do things like optimize shaders.
                  for (const key in this.#passes) {
                      const passSet = this.#passes[key];
                      for (const pass of passSet) {
                          pass.startPresenting();
                      }
                  }
                  xrvp.on('viewChanged', emitViewChanged);
              }
              else {
                  xrvp.off('viewChanged', emitViewChanged);
                  this.emit('updated');
                  for (const key in this.#passes) {
                      const passSet = this.#passes[key];
                      for (const pass of passSet) {
                          pass.stopPresenting();
                      }
                  }
                  const viewXfo = this.getViewport().getCamera().globalXfoParam.value;
                  const event = new ViewChangedEvent('CameraAndPointer', viewXfo);
                  this.emit('viewChanged', event);
                  this.requestRedraw();
              }
          });
          return xrvp;
      }
      /**
       * The getVRViewport method.
       * @return - The return value.
       */
      getVRViewport() {
          return this.xrViewport;
      }
      /**
       * The getXRViewport method.
       * @return - The return value.
       */
      getXRViewport() {
          return this.#xrViewportPromise;
      }
      /**
       * The isXRViewportPresenting method.
       * @return - The return value.
       */
      isXRViewportPresenting() {
          return this.xrViewportPresenting;
      }
      // //////////////////////////
      // Rendering
      /**
       * The isContinuouslyDrawing method.
       * @return - The return value.
       */
      isContinuouslyDrawing() {
          return this.#continuousDrawing;
      }
      /**
       * The startContinuousDrawing method.
       */
      startContinuousDrawing() {
          if (this.isContinuouslyDrawing() || this.xrViewportPresenting)
              return;
          const onAnimationFrame = () => {
              const renderstate = new ColorRenderState(this.gl);
              if (this.#continuousDrawing && !this.xrViewportPresenting)
                  window.requestAnimationFrame(onAnimationFrame);
              for (const vp of this.#viewports)
                  vp.draw(renderstate);
          };
          this.#continuousDrawing = true;
          requestPostAnimationFrame(onAnimationFrame);
      }
      /**
       * The stopContinuousDrawing method.
       */
      stopContinuousDrawing() {
          this.#continuousDrawing = false;
      }
      /**
       * The toggleContinuousDrawing method.
       */
      toggleContinuousDrawing() {
          if (!this.#continuousDrawing) {
              this.startContinuousDrawing();
          }
          else {
              this.stopContinuousDrawing();
          }
      }
      /**
       * The drawItemChanged method.
       */
      drawItemChanged() {
          for (const vp of this.#viewports)
              vp.invalidateGeomDataBuffer();
          this.requestRedraw();
      }
      /**
       * Request a single redraw, usually in response to a signal/event.
       * @return - The return value.
       */
      requestRedraw() {
          // If a redraw has already been requested, then simply return and wait.
          if (!this.__gl ||
              this.#redrawRequested ||
              this.#continuousDrawing ||
              this.xrViewportPresenting ||
              this.#drawSuspensionLevel > 0) {
              return false;
          }
          if (this.__gl.isContextLost()) {
              console.warn('WebGL Context Lost');
              return false;
          }
          const onAnimationFrame = () => {
              this.#redrawRequested = false;
              const renderstate = new ColorRenderState(this.gl);
              for (const vp of this.#viewports) {
                  vp.draw(renderstate);
              }
              if (renderstate.stack.length != 0) {
                  console.warn(' corrupt renderstate.stack.length:', renderstate.stack.length);
              }
          };
          requestPostAnimationFrame(onAnimationFrame);
          this.#redrawRequested = true;
          return true;
      }
      /**
       * Forces a redraw of the viewports
       */
      forceRender() {
          if (!this.#redrawRequested) {
              console.warn('@GlBaseRenderer#forceRender - Scene is not dirty');
              return;
          }
          this.#redrawRequested = false;
          const renderstate = new ColorRenderState(this.gl);
          for (const vp of this.#viewports) {
              vp.draw(renderstate);
          }
      }
      /**
       * The bindGLRenderer method.
       * @param renderstate - The renderstate value.
       */
      bindGLRenderer(renderstate) {
          renderstate.gl = this.__gl;
          renderstate.renderer = this;
          renderstate.directives = this.directives;
          renderstate.directivesHash = this.directivesHash;
      }
      /**
       * The drawScene method.
       * @param renderstate - The renderstate value.
       */
      drawScene(renderstate) {
          // Bind already called by GLRenderer.
          renderstate.directives = [...this.directives, '#define DRAW_COLOR'];
          for (const key in this.#passes) {
              const passSet = this.#passes[key];
              for (const pass of passSet) {
                  if (pass.enabled)
                      pass.draw(renderstate);
              }
          }
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The renderstate value.
       */
      drawHighlightedGeoms(renderstate) {
          this.bindGLRenderer(renderstate);
          renderstate.directives = [...this.directives, '#define DRAW_HIGHLIGHT'];
          for (const key in this.#passes) {
              const passSet = this.#passes[key];
              for (const pass of passSet) {
                  if (pass.enabled)
                      pass.drawHighlightedGeoms(renderstate);
              }
          }
      }
      /**
       * The drawSceneGeomData method.
       * @param renderstate - The renderstate value.
       * @param mask - The mask value
       */
      drawSceneGeomData(renderstate, mask = 255) {
          renderstate.pushGLStack('GLBaseRenderer.drawSceneGeomData');
          renderstate.glEnable(this.__gl.DEPTH_TEST);
          renderstate.glEnable(this.__gl.CULL_FACE);
          this.bindGLRenderer(renderstate);
          renderstate.directives = [...this.directives, '#define DRAW_GEOMDATA'];
          renderstate.floatGeomBuffer = this.floatGeomBuffer;
          for (const key in this.#passes) {
              // Skip pass categories that do not match
              // the mask. E.g. we may not want to hit
              // "Overlay" geoms such as labels,
              // or we might be trying to move labels and don't
              // want to grab normal geoms.
              if ((Number.parseInt(key) & mask) == 0)
                  continue;
              const passSet = this.#passes[key];
              for (const pass of passSet) {
                  if (pass.enabled)
                      pass.drawGeomData(renderstate);
              }
          }
          renderstate.popGLStack();
      }
      // ////////////////////////////////////////
      // Static Methods
      /**
       * The registerPass method.
       * @param cls - The cls value.
       * @param passType - The passType value.
       */
      static registerPass(cls, passType) {
          registeredPasses.push({ cls, passType });
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy(loseContext = true) {
          this.#resizeObserver.disconnect();
          window.removeEventListener('resize', this.#onResizeCallback);
          if (loseContext) {
              const ext = this.__gl.getExtension('WEBGL_lose_context');
              if (ext)
                  ext.loseContext();
          }
      }
  }

  var frag$d = "\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\n\nimport 'GLSLUtils.glsl'\nimport 'Hammersley.glsl'\nimport 'ImportanceSampleGGX.glsl'\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n  float a = roughness;\n  float k = (a * a) / 2.0;\n\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0;\n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if (NdotL > 0.0)\n    {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1.0 - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  A /= float(SAMPLE_COUNT);\n  B /= float(SAMPLE_COUNT);\n  return vec2(A, B);\n}\n\nout vec2 fragColor;\nvoid main(void) {\n  vec2 integratedBRDF = IntegrateBRDF(v_texCoord.x, v_texCoord.y);\n  fragColor = integratedBRDF;\n}\n\n"; // eslint-disable-line

  var vert$e = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** Shader for convolving Environment maps.
   * @extends GLShader
   * @private
   */
  class PreComputeBRDFShader extends GLShader {
      /**
       * Create a GL renderer.
       * @param gl - The options value.
       */
      constructor(gl) {
          super(gl, 'PreComputeBRDFShader');
          this.setShaderStage('VERTEX_SHADER', vert$e);
          this.setShaderStage('FRAGMENT_SHADER', frag$d);
      }
  }

  var frag$c = "\nprecision highp float;\n#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'convolve-helpers.glsl'\n\nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 irradiance = vec3(0.0);\n\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  float nrSamples = 0.0; \n  for(float phi = 0.0; phi < 2.0 * PI; phi += SAMPLE_DELTA)\n  {\n    for(float theta = 0.0; theta < 0.5 * PI; theta += SAMPLE_DELTA)\n    {\n      // spherical to cartesian (in tangent space)\n      // from spherical coordinates to cartesian coordinates\n      vec3 H = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n      // tangent space to world\n      vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\n      irradiance += sampleEnvMap(normalize(sampleVec)).rgb * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n  }\n  irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n  fragColor = vec4(irradiance, 1.0);\n}\n"; // eslint-disable-line

  var vert$d = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** Shader for convolving Environment maps.
   * @extends GLShader
   * @private
   */
  class ConvolveIrradianceShader extends GLShader {
      /**
       * Create a GL renderer.
       * @param gl - The options value.
       */
      constructor(gl) {
          super(gl, 'ConvolveIrradianceShader');
          this.setShaderStage('VERTEX_SHADER', vert$d);
          this.setShaderStage('FRAGMENT_SHADER', frag$c);
      }
  }

  var vert$c = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"; // eslint-disable-line

  var frag$b = "precision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'ImportanceSampleGGX.glsl'\nimport 'convolve-helpers.glsl'\nimport 'Hammersley.glsl'\n  \n  \nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 R = N;\n  vec3 V = R;\n\n  float totalWeight = 0.0;   \n  vec3 prefilteredColor = vec3(0.0);     \n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(dot(N, L), 0.0);\n    if (NdotL > 0.0)\n    {\n      prefilteredColor += sampleEnvMap(L).rgb * NdotL;\n      totalWeight      += NdotL;\n    }\n  }\n  prefilteredColor = prefilteredColor / totalWeight;\n\n  fragColor = vec4(prefilteredColor, 1.0);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** Shader for convolving Environment maps.
   * @extends GLShader
   * @private
   */
  class ConvolveSpecularShader extends GLShader {
      /**
       * Create a GL renderer.
       * @param gl - The options value.
       */
      constructor(gl) {
          super(gl, 'ConvolveSpecularShader');
          this.setShaderStage('VERTEX_SHADER', vert$c);
          this.setShaderStage('FRAGMENT_SHADER', frag$b);
      }
  }

  /** Class representing a GL probe.
   * @private
   */
  class GLProbe extends EventEmitter {
      __gl;
      maxFragmentShaderTextureUnits;
      textureType;
      textureDesc;
      __convolved;
      __fbos;
      brdfLUTTexture;
      irradianceCubeTex;
      specularCubetex;
      /**
       * Create a GL probe.
       * @param gl - The webgl rendering context.
       * @param name - The name value.
       */
      constructor(gl, name) {
          super();
          this.__gl = gl;
          const gl_casted = gl;
          this.maxFragmentShaderTextureUnits = gl.getParameter(this.__gl.MAX_TEXTURE_IMAGE_UNITS);
          if (!gl_casted.__quadVertexIdsBuffer)
              gl_casted.setupInstancedQuad();
          this.textureType = 1; // Default 2d 8 bit texture image texture.
          this.textureDesc = [0, 0, 0, 0]; // To be populated by derived classes.
          this.__convolved = false;
          this.__fbos = [];
      }
      /**
       * The convolveProbe method.
       * @param srcGLTex - The srcGLTex value.
       */
      convolveProbe(srcGLTex) {
          const gl = this.__gl;
          const renderstate = new RenderState(gl);
          renderstate.directives = ['#define ENABLE_ES3', '#define ENABLE_FLOAT_TEXTURES'];
          // Note: in testing we are running on the Google SwiftShader emulated GPU.
          if (SystemDesc.deviceCategory == 'Low') {
              renderstate.directives.push('#define SAMPLE_DELTA 0.1');
              renderstate.directives.push('#define SAMPLE_COUNT 64u');
          }
          else if (SystemDesc.deviceCategory == 'Medium') {
              renderstate.directives.push('#define SAMPLE_DELTA 0.08');
              renderstate.directives.push('#define SAMPLE_COUNT 256u');
          }
          else {
              renderstate.directives.push('#define SAMPLE_DELTA 0.025');
              renderstate.directives.push('#define SAMPLE_COUNT 1024u');
          }
          this.brdfLUTTexture = gl.createTexture();
          // pre-allocate enough memory for the LUT texture.
          gl.bindTexture(gl.TEXTURE_2D, this.brdfLUTTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG16F, 512, 512, 0, gl.RG, gl.FLOAT, null);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          const brdfShader = new PreComputeBRDFShader(this.__gl);
          const brdfShaderComp = brdfShader.compileForTarget('GLProbe', renderstate.directives);
          const brdfShaderBinding = generateShaderGeomBinding(this.__gl, brdfShaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
          const brdfFboId = gl.createFramebuffer();
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, brdfFboId);
          gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.brdfLUTTexture, 0);
          brdfShader.bind(renderstate);
          brdfShaderBinding.bind(renderstate);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.viewport(0, 0, 512, 512);
          gl.drawQuad();
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
          gl.deleteFramebuffer(brdfFboId);
          brdfShader.unbind(renderstate);
          brdfShader.destroy();
          // ////////////////////////////////////////////
          // ConvolveIrradianceShader Shader
          {
              const convolveIrradianceShader = new ConvolveIrradianceShader(this.__gl);
              const convolveIrradianceShaderComp = convolveIrradianceShader.compileForTarget('GLProbe', renderstate.directives);
              const convolveIrradianceShaderBinding = generateShaderGeomBinding(this.__gl, convolveIrradianceShaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
              convolveIrradianceShader.bind(renderstate, 'GLProbe');
              convolveIrradianceShaderBinding.bind(renderstate);
              const unifs = renderstate.unifs;
              srcGLTex.bindToUniform(renderstate, unifs.envMap);
              // ////////////////////////////////////////////
              // Irradiance Cube
              const size = 64;
              this.irradianceCubeTex = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.irradianceCubeTex);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
              // Resize all the faces first.
              for (let i = 0; i < 6; i++) {
                  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, null);
              }
              // Attach one face of cube map
              const irradianceFboId = gl.createFramebuffer();
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, irradianceFboId);
              for (let i = 0; i < 6; ++i) {
                  gl.uniform1i(unifs.faceId.location, i);
                  gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.irradianceCubeTex, 0);
                  gl.viewport(0, 0, size, size); // Match the viewport to the texture size
                  gl.clearColor(1, 0, 0, 1);
                  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                  gl.drawQuad();
              }
              gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
              gl.deleteFramebuffer(irradianceFboId);
              // Note: without the mipmaps, te cube sampling seems a big broken.
              // No colors.
              gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          }
          // ////////////////////////////////////////////
          // Specular Cube Pyramid
          {
              const convolverShader = new ConvolveSpecularShader(this.__gl);
              const covolverShaderComp = convolverShader.compileForTarget('GLProbe', renderstate.directives);
              const covolverShaderBinding = generateShaderGeomBinding(this.__gl, covolverShaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
              convolverShader.bind(renderstate, 'GLProbe');
              covolverShaderBinding.bind(renderstate);
              const unifs = renderstate.unifs;
              srcGLTex.bindToUniform(renderstate, unifs.envMap);
              this.specularCubetex = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.specularCubetex);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
              // Resize all the faces first.
              const size = 256;
              for (let i = 0; i < 6; i++) {
                  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA32F, size, size, 0, gl.RGBA, gl.FLOAT, null);
              }
              gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
              // gl.enable(gl.TEXTURE_CUBE_MAP_SEAMLESS) // not supported in webgl
              const maxMipLevels = 5;
              for (let mip = 0; mip < maxMipLevels; ++mip) {
                  // resize framebuffer according to mip-level size.
                  const mipWidth = size * Math.pow(0.5, mip);
                  const mipHeight = size * Math.pow(0.5, mip);
                  // Attach one face of cube map
                  const fboId = gl.createFramebuffer();
                  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fboId);
                  gl.viewport(0, 0, mipWidth, mipHeight); // Match the viewport to the texture size
                  const roughness = mip / (maxMipLevels - 1);
                  gl.uniform1f(unifs.roughness.location, roughness);
                  for (let i = 0; i < 6; ++i) {
                      gl.uniform1i(unifs.faceId.location, i);
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.specularCubetex, mip);
                      gl.drawQuad();
                  }
                  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                  gl.deleteFramebuffer(fboId);
              }
              convolverShader.destroy();
          }
          this.__convolved = true;
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param unif - The WebGL uniform
       * @return - Returns true if the Probe was successfully bound.
       */
      bind(renderstate) {
          const gl = this.__gl;
          const { irradianceMap, prefilterMap, brdfLUT, envMapFlags } = renderstate.unifs;
          if (!this.__convolved) {
              // By default, all the texture units are bound to unit:0
              // So if a shader contains cube maps, and they are left on unit 0
              // and also the shader contains regular textures, and they are also left on unit 0
              // then we get errors saying:
              // GL_INVALID_OPERATION: Two textures of different types use the same sampler location.
              // So bind to an unused texture unit...
              if (irradianceMap) {
                  gl.uniform1i(irradianceMap.location, this.maxFragmentShaderTextureUnits - 1);
              }
              if (prefilterMap) {
                  gl.uniform1i(prefilterMap.location, this.maxFragmentShaderTextureUnits - 1);
              }
              if (envMapFlags) {
                  gl.uniform1i(envMapFlags.location, -1);
              }
              return false;
          }
          // Note: a cube map can never be bound to texture unit 0.
          // This is because if any other samplers are left unbound
          // (e.g. a diffuse sampler left unbound because no diffuse texture is assigned)
          // then the texture unit binding defaults to 0.
          // If the cube map is then bound to unit 0, then we get the error message:
          // GL_INVALID_OPERATION: Two textures of different types use the same sampler location.
          // Ths simple workaround here is to bind the BRDF Lut first, which is a TEXTURE_2D, and the cube maps
          // to other units:(1 & 2).
          // This error started occuring when we moved PBR binding to the shader instead of in the renderer.
          // See: StandardSurfaceShader.bind
          if (brdfLUT) {
              const unit = renderstate.boundTextures++;
              gl.activeTexture(this.__gl.TEXTURE0 + unit);
              gl.bindTexture(gl.TEXTURE_2D, this.brdfLUTTexture);
              gl.uniform1i(brdfLUT.location, unit);
          }
          if (irradianceMap) {
              const unit = renderstate.boundTextures++;
              const texId = this.__gl.TEXTURE0 + unit;
              gl.activeTexture(texId);
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.irradianceCubeTex);
              gl.uniform1i(irradianceMap.location, unit);
          }
          if (prefilterMap) {
              const unit = renderstate.boundTextures++;
              const texId = this.__gl.TEXTURE0 + unit;
              gl.activeTexture(texId);
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.specularCubetex);
              gl.uniform1i(prefilterMap.location, unit);
          }
          if (envMapFlags) {
              gl.uniform1i(envMapFlags.location, 0);
          }
          return true;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          // super.destroy()
      }
  }

  var frag$a = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\nimport 'constants.glsl'\n\nuniform float focus;\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#define ENABLE_INLINE_GAMMACORRECTION\n\n#define ENV_MAP_LATLONG 0\n#define ENV_MAP_OCT 1\n#define ENV_MAP_CUBE 2\n#define ENV_MAP_irradianceMap 8\n#define ENV_MAP_prefilterMap 3\n#define ENV_MAP_STEREO_LATLONG 4\n#define ENV_MAP_DUALFISHEYE 5\n#define ENV_MAP_SH 6\n#define ENV_MAP_BRDF_LUT 7\n\n#define ENV_MAPTYPE ENV_MAP_OCT\n\n#if (ENV_MAPTYPE == ENV_MAP_LATLONG)  \n\nimport 'envmap-equirect.glsl'\n\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(dir));\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  return vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_OCT)  \n\nimport 'envmap-octahedral.glsl'\n\nuniform sampler2D   envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(normalize(dir));\n  if (false) {\n    vec4 texel = texture2D(envMap, uv);\n    return vec4(texel.rgb/texel.a, 1.0);\n  }\n  else {\n    return texture2D(envMap, uv) * exposure;\n  }\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_CUBE)\n\nuniform samplerCube cubeMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(cubeMap, dir, 0.0);// * exposure;\n  // return textureLod(cubeMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_irradianceMap)\n\nuniform samplerCube irradianceMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(irradianceMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_prefilterMap)\n\nuniform samplerCube prefilterMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(prefilterMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_STEREO_LATLONG)  \n\nimport 'envmap-equirect.glsl'\nuniform int eye;// L = 0, R = 1;\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));\n  uv.y *= 0.5;\n  if (eye == 1) {\n    uv.y += 0.5;\n  }\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_DUALFISHEYE)\n\nimport 'envmap-dualfisheye.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dualfisheyeUVsFromDir(dir);\n  return texture2D(backgroundImage, uv) * exposure;\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_SH)\n\nimport 'SHCoeffs.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n\treturn vec4(sampleSHCoeffs(dir) * exposure, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_BRDF_LUT)\n\nuniform sampler2D brdfLUT;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture2D(brdfLUT, v_texCoord);\n}\n#endif\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = sampleEnvMap(normalize(v_worldDir));\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$b = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\nimport 'inverse.glsl'\nimport 'transpose.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID() * 2.0;\n  v_texCoord = position * 0.5 + 0.5;\n\n  mat4 inverseProjection = inverse(projectionMatrix);\n  mat3 inverseModelview = transpose(mat3(viewMatrix));\n\n  // transform from the normalized device coordinates back to the view space\n  vec3 unprojected = (inverseProjection * vec4(position, 0, 1)).xyz;\n\n  // transfrom from the view space back to the world space\n  // and use it as a sampling vector\n  v_worldDir = inverseModelview * unprojected;\n\n  gl_Position = vec4(position, 0, 1);\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class EnvMapShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'EnvMapShader');
          this.setShaderStage('VERTEX_SHADER', vert$b);
          this.setShaderStage('FRAGMENT_SHADER', frag$a);
      }
  }

  /** Class representing a GL environment map.
   * @extends GLProbe
   * @private
   */
  class GLEnvMap extends GLProbe {
      __renderer;
      __envMap;
      __backgroundFocus;
      __srcGLTex = null;
      __envMapShader = null;
      __envMapShaderBinding = null;
      __lodPyramid;
      /**
       * Create a GL env map.
       * @param renderer - The renderer value.
       * @param envMap - The environment map.
       */
      constructor(renderer, envMap) {
          super(renderer.gl, 'EnvMap');
          this.__renderer = renderer;
          this.__envMap = envMap;
          this.__backgroundFocus = 0.0;
          if (this.__envMap.isLoaded()) {
              this.init();
          }
          else {
              this.__envMap.once('loaded', (event) => {
                  this.init();
              });
          }
      }
      get glTex() {
          return this.__srcGLTex;
      }
      /**
       * @private
       */
      init() {
          const gl = this.__renderer.gl;
          if (!gl.__quadVertexIdsBuffer)
              gl.setupInstancedQuad();
          this.__srcGLTex = new GLHDRImage(gl, this.__envMap);
          this.__envMapShader = new EnvMapShader(gl);
          const envMapShaderComp = this.__envMapShader.compileForTarget('GLEnvMap', ['#define ENABLE_ES3']);
          this.__envMapShaderBinding = generateShaderGeomBinding(gl, envMapShaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
          const headlightParam = this.__envMap.headlightModeParam;
          const updateHeadlightModeFlag = () => {
              const ENVMAP_FLAG_HEADLIGHT = 1; // 1<<0;
              if (headlightParam.value) {
                  this.textureDesc[3] |= ENVMAP_FLAG_HEADLIGHT;
              }
              else {
                  this.textureDesc[3] &= ~ENVMAP_FLAG_HEADLIGHT;
              }
          };
          updateHeadlightModeFlag();
          headlightParam.on('valueChanged', () => {
              updateHeadlightModeFlag();
              this.emit('updated');
          });
          this.convolveProbe(this.__srcGLTex);
          this.emit('updated');
      }
      /**
       * The getEnvMap method.
       * @return - The return value.
       */
      getEnvMap() {
          return this.__envMap;
      }
      /**
       * The getBackgroundFocus method.
       * @return - The return value.
       */
      getBackgroundFocus() {
          return this.__backgroundFocus;
      }
      /**
       * The setBackgroundFocus method.
       * @param val - The val param.
       */
      setBackgroundFocus(val) {
          this.__backgroundFocus = val;
          this.__renderer.requestRedraw();
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.__envMap.isLoaded()) {
              const gl = this.__gl;
              {
                  // /////////////////
                  this.__envMapShader.bind(renderstate, 'GLEnvMap');
                  const unifs = renderstate.unifs;
                  const { envMap, focus, exposure } = renderstate.unifs;
                  if (envMap) {
                      this.__srcGLTex.bindToUniform(renderstate, envMap);
                  }
                  if (focus)
                      gl.uniform1f(focus.location, this.__backgroundFocus);
                  if (exposure)
                      gl.uniform1f(exposure.location, renderstate.exposure);
                  this.__envMapShaderBinding.bind(renderstate);
                  gl.depthMask(false);
                  renderstate.bindViewports(unifs, () => {
                      gl.drawQuad();
                  });
                  gl.depthMask(true);
              }
          }
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          super.destroy();
          if (this.__srcGLTex)
              this.__srcGLTex.destroy();
      }
  }

  const ALL_PASSES = PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY;
  // TODO: move this fn somewhere
  /** Class representing a GL renderer.
   * @extends GLBaseRenderer
   */
  class GLRenderer extends GLBaseRenderer {
      #exposure = 1.0;
      #gamma = 2.2;
      #glEnvMap = null;
      #glBackgroundMap;
      #displayEnvironment;
      highlightOutlineThickness = 1;
      renderMode = 'pbr';
      outlineMethod = 'geometry';
      outlineThickness = 0;
      outlineColor = new Color(0.15, 0.15, 0.15, 1);
      hiddenLineColor = new Color(0.15, 0.15, 0.15, 0.0);
      outlineSensitivity = 2;
      outlineDepthBias = 0.7;
      #rayCastDist;
      #rayCastArea;
      #rayCastRenderTarget = null;
      #backgroundMapShader = null;
      #backgroundMapShaderBinding = null;
      #rayCastRenderTargetProjMatrix = new Mat4();
      /**
       * Create a GL renderer.
       * @param $canvas - The $canvas value.
       * @param options - The dictionary of options.
       */
      constructor($canvas, options = {}) {
          // use HTMLCanvasElement?
          super($canvas, options);
          // ///////////////////////
          // Renderer Setup
          this.#exposure = 1.0;
          this.#gamma = 2.2;
          this.#displayEnvironment = true;
          this.#rayCastDist = 0;
          this.#rayCastArea = 0;
          this.setShaderPreprocessorDirective('ENABLE_GAMMACORRECTION', '#define ENABLE_INLINE_GAMMACORRECTION');
          if (!options.disableTextures) {
              this.setShaderPreprocessorDirective('ENABLE_TEXTURES', '#define ENABLE_TEXTURES');
          }
          if (options.debugGeomIds) {
              this.setShaderPreprocessorDirective('DEBUG_GEOM_ID', '#define DEBUG_GEOM_ID');
          }
      }
      /**
       * The __bindEnvMap method.
       * @param env - The env value.
       * @private
       */
      __bindEnvMap(env) {
          const gl = this.__gl;
          if (env instanceof EnvMap) {
              // Note: Safari doesn't support rendering to floating
              // point textures, so our PBR lighting pipeline doesn't work.
              if (gl.name !== 'webgl2') {
                  return;
              }
              if (env.type === 'FLOAT') {
                  this.setShaderPreprocessorDirective('ENABLE_PBR', '#define ENABLE_PBR');
                  this.#glEnvMap = new GLEnvMap(this, env);
              }
              // } else if (env.isStreamAtlas()) { // TODO: are these two lines still needed?
              //   this.#glEnvMap = new GLImageStream(gl, env)
              // else {
              //   this.#glEnvMap = new GLTexture2D(this.__gl, env)
              // }
          }
          else {
              // Note: The difference between an EnvMap and a BackgroundMap, is that
              // An EnvMap must be HDR, and can be convolved for reflections.
              // A Background map can be simply an image.
              const backgroundMap = env;
              if (backgroundMap.type === 'HDR') {
                  this.#glBackgroundMap = new GLHDRImage(this.__gl, backgroundMap); // todo: is this cast ok?
              }
              else {
                  this.#glBackgroundMap = new GLTexture2D(this.__gl, backgroundMap);
              }
              this.#glBackgroundMap.on('loaded', () => {
                  this.requestRedraw();
              });
              this.#glBackgroundMap.on('updated', () => {
                  this.requestRedraw();
              });
              if (!this.#backgroundMapShader) {
                  if (!gl.__quadVertexIdsBuffer)
                      gl.setupInstancedQuad();
                  this.#backgroundMapShader = new EnvMapShader(this.__gl);
                  // switch (backgroundMap.getMapping()) {
                  //   case 'octahedral':
                  //     break
                  //   case 'latlong':
                  //     break
                  //   case 'steriolatlong':
                  //     break
                  //   case 'dualfisheye':
                  //     break
                  //   case 'uv':
                  //   default:
                  //     break
                  // }
                  const shaderComp = this.#backgroundMapShader.compileForTarget('key', []);
                  this.#backgroundMapShaderBinding = generateShaderGeomBinding(this.__gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
              }
              // console.warn('Unsupported EnvMap:' + env)
              return;
          }
          this.#glEnvMap.on('loaded', (event) => {
              this.requestRedraw();
          });
          this.#glEnvMap.on('updated', (event) => {
              this.requestRedraw();
          });
          const event = new EnvMapAssignedEvent(this.#glEnvMap);
          this.emit('envMapAssigned', event);
      }
      /**
       * The setScene method.
       * @param scene - The scene value.
       */
      setScene(scene) {
          const envMapParam = scene.envMapParam;
          if (envMapParam.value != undefined) {
              this.__bindEnvMap(envMapParam.value);
          }
          envMapParam.on('valueChanged', () => {
              this.__bindEnvMap(envMapParam.value);
          });
          const displayEnvMapParam = scene.displayEnvMapParam;
          this.#displayEnvironment = displayEnvMapParam.value;
          displayEnvMapParam.on('valueChanged', () => {
              this.#displayEnvironment = displayEnvMapParam.value;
              this.requestRedraw();
          });
          super.setScene(scene);
      }
      /**
       * The addViewport method.
       * @param name - The name value.
       * @return - The return value.
       */
      addViewport(name) {
          const vp = super.addViewport(name);
          return vp;
      }
      // //////////////////////////
      // GUI
      /**
       * Getter for exposure.
       * @return exposure
       */
      get exposure() {
          return this.#exposure;
      }
      /**
       * Setter for exposure.
       * @param val - The val value.
       */
      set exposure(val) {
          this.#exposure = val;
          this.requestRedraw();
      }
      /**
       * Getter for gamma.
       */
      get gamma() {
          return this.#gamma;
      }
      /**
       * Setter for gamma.
       * @param val - The val value.
       */
      set gamma(val) {
          this.#gamma = val;
          this.requestRedraw();
      }
      /**
       * Getter for displayEnvironment.
       */
      get displayEnvironment() {
          return this.#displayEnvironment;
      }
      /**
       * Setter for displayEnvironment.
       * @param val - The val value.
       */
      set displayEnvironment(val) {
          this.#displayEnvironment = val;
          this.requestRedraw();
      }
      // //////////////////////////
      // Raycasting
      bindRaycastViewport(renderstate, viewXfo, projectionMatrixMat4) {
          const region = [0, 0, 3, 3];
          renderstate.viewXfo = viewXfo;
          renderstate.cameraMatrix = viewXfo.toMat4();
          renderstate.viewScale = 1.0;
          renderstate.region = region;
          const viewMatrixMat4 = renderstate.cameraMatrix.inverse();
          const gl = this.gl;
          renderstate.bindRendererUnifs = (unifs) => {
              const { cameraMatrix, viewMatrix, projectionMatrix, eye, isOrthographic, viewportFrustum } = unifs;
              if (cameraMatrix) {
                  gl.uniformMatrix4fv(cameraMatrix.location, false, renderstate.cameraMatrix.asArray());
              }
              if (viewMatrix) {
                  gl.uniformMatrix4fv(viewMatrix.location, false, viewMatrixMat4.asArray());
              }
              if (projectionMatrix) {
                  gl.uniformMatrix4fv(projectionMatrix.location, false, projectionMatrixMat4.asArray());
              }
              if (eye) {
                  gl.uniform1i(eye.location, 0);
              }
              if (isOrthographic) {
                  gl.uniform1i(isOrthographic.location, 1);
              }
          };
          renderstate.bindViewports = (unifs, draw) => draw();
      }
      /**
       * Ray casting is implemented by rendering a small image from the position of the ray, and capturing geometries detected in the resulting image.
       * This method takes a Ray value, and uses that base the ray cast operation.
       *
       * @param ray - The ray to use in the raycast.
       * @param dist - The maximum distance to cast the ray
       * @param area - The area to use for the ray
       * @param mask - The mask to filter our certain pass types. Can be PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY
       * @return - The object containing the ray cast results.
       */
      raycastWithRay(ray, dist, area = 0.01, mask = ALL_PASSES) {
          const xfo = new Xfo();
          xfo.setLookAt(ray.start, ray.start.add(ray.dir), new Vec3(0, 0, 1));
          return this.raycast(xfo, ray, dist, area, mask);
      }
      /**
       * Ray casting is implemented by rendering a small image from the position of the ray, and capturing geometries detected in the resulting image.
       * This method takes an Xfo value, and uses that base the ray cast operation.
       *
       * @param xfo - The xfo to use in the raycast.
       * @param dist - The maximum distance to cast the ray
       * @param area - The area to use for the ray
       * @param mask - The mask to filter our certain pass types. Can be PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY
       * @return - The object containing the ray cast results.
       */
      raycastWithXfo(xfo, dist, area = 0.01, mask = ALL_PASSES) {
          const ray = new Ray(xfo.tr, xfo.ori.getZaxis().negate());
          return this.raycast(xfo, ray, dist, area, mask);
      }
      /**
       * Ray casting is implemented by rendering a small image from the position of the ray, and capturing geometries detected in the resulting image.
       *
       * @private
       *
       * @param xfo - The xfo to use in the raycast.
       * @param ray - The ray to use in the raycast.
       * @param dist - The maximum distance to cast the ray
       * @param area - The area to use for the ray
       * @param mask - The mask to filter our certain pass types. Can be PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY
       * @return - The object containing the ray cast results.
       */
      raycast(xfo, ray, dist, area = 0.01, mask = ALL_PASSES) {
          if (this.#rayCastDist != dist || this.#rayCastArea != area) {
              this.#rayCastRenderTargetProjMatrix.setOrthographicMatrix(area * -0.5, area * 0.5, area * -0.5, area * 0.5, 0.0, dist);
              this.#rayCastDist = dist;
              this.#rayCastArea = area;
          }
          return this.raycastWithProjection(xfo, this.#rayCastRenderTargetProjMatrix, ray, mask);
      }
      /**
       * Ray casting is implemented by rendering a small image from the position of the ray, and capturing geometries detected in the resulting image.
       *
       * @private
       *
       * @param viewXfo - The xfo to use in the raycast.
       * @param projectionMatrix - The projectionMatrix to use in the raycast.
       * @param ray - The ray to use in the raycast.
       * @param mask - The mask to filter our certain pass types. Can be PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY
       * @return - The object containing the ray cast results.
       */
      raycastWithProjection(viewXfo, projectionMatrix, ray, mask = ALL_PASSES) {
          const renderstate = new GeomDataRenderState(this.__gl);
          this.bindRaycastViewport(renderstate, viewXfo, projectionMatrix);
          const gl = this.__gl;
          if (!this.#rayCastRenderTarget) {
              this.#rayCastRenderTarget = new GLRenderTarget(gl, {
                  type: gl.FLOAT,
                  format: gl.RGBA,
                  filter: gl.NEAREST,
                  createDepthTexture: true,
                  width: 3,
                  height: 3,
                  numColorChannels: 1,
              });
          }
          this.#rayCastRenderTarget.bindForWriting(renderstate, true);
          gl.enable(gl.CULL_FACE);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.depthMask(true);
          this.drawSceneGeomData(renderstate, mask);
          gl.finish();
          this.#rayCastRenderTarget.unbindForWriting();
          this.#rayCastRenderTarget.bindForReading();
          const geomDatas = new Float32Array(4 * 9);
          gl.readPixels(0, 0, 3, 3, gl.RGBA, gl.FLOAT, geomDatas);
          this.#rayCastRenderTarget.unbindForReading();
          // ////////////////////////////////////
          // We have a 3x3 grid of pixels, and we
          // scan them to find if any geom was in the
          // frustum.
          // Starting with the center pixel (4),
          // then left and right (3, 5)
          // Then top bottom (1, 7)
          const checkPixel = (id) => geomDatas[id * 4 + 3] != 0;
          const dataPixels = [4, 3, 5, 1, 7];
          let geomData;
          for (const pixelID of dataPixels) {
              if (checkPixel(pixelID)) {
                  geomData = geomDatas.subarray(pixelID * 4, pixelID * 4 + 4);
                  break;
              }
          }
          if (!geomData)
              return null;
          // Mask the pass id to be only the first 6 bits of the integer.
          const passId = Math.round(geomData[0]) & (64 - 1);
          const geomItemAndDist = this.getPass(passId)?.getGeomItemAndDist(geomData);
          if (geomItemAndDist) {
              const intersectionPos = ray.start.add(ray.dir.scale(geomItemAndDist.dist));
              return {
                  pointerRay: ray,
                  intersectionPos,
                  geomItem: geomItemAndDist.geomItem,
                  componentId: -1,
                  dist: geomItemAndDist.dist,
                  geomData,
              };
          }
          else {
              return null;
          }
      }
      /**
       *
       * @private
       *
       * @param xfo - The ray to use in the raycast.
       * @param ray - The ray to use in the raycast.
       * @param dist - The maximum distance to cast the ray
       * @param area - The area to use for the ray
       * @param mask - The mask to filter our certain pass types. Can be PassType.OPAQUE | PassType.TRANSPARENT | PassType.OVERLAY
       * @return - The object containing the ray cast results.
       */
      raycastCluster(xfo, ray, dist, area = 0.01, mask = ALL_PASSES) {
          const gl = this.__gl;
          const renderstate = new GeomDataRenderState(this.__gl);
          this.bindRaycastViewport(renderstate, xfo, this.#rayCastRenderTargetProjMatrix);
          if (!this.#rayCastRenderTarget) {
              this.#rayCastRenderTarget = new GLRenderTarget(gl, {
                  type: 'FLOAT',
                  format: 'RGBA',
                  filter: 'NEAREST',
                  createDepthTexture: true,
                  width: 3,
                  height: 3,
                  numColorChannels: 1,
              });
              this.#rayCastRenderTargetProjMatrix = new Mat4();
          }
          if (this.#rayCastDist != dist || this.#rayCastArea != area) {
              this.#rayCastRenderTargetProjMatrix.setOrthographicMatrix(area * -0.5, area * 0.5, area * -0.5, area * 0.5, 0.0, dist);
              this.#rayCastDist = dist;
              this.#rayCastArea = area;
          }
          this.#rayCastRenderTarget.bindForWriting(renderstate, true);
          gl.enable(gl.CULL_FACE);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.depthMask(true);
          this.drawSceneGeomData(renderstate, mask);
          gl.finish();
          this.#rayCastRenderTarget.unbindForWriting();
          this.#rayCastRenderTarget.bindForReading();
          const geomDatas = new Float32Array(4 * 9);
          gl.readPixels(0, 0, 3, 3, gl.RGBA, gl.FLOAT, geomDatas);
          this.#rayCastRenderTarget.unbindForReading();
          // ////////////////////////////////////
          // We have a 3x3 grid of pixels, and we
          // scan them to find if any geom was in the
          // frustum.
          // Note: we return every intersection, because even multiple intersections
          // on the same geometry will be at different distances.
          // This method is often used to get an average distance.
          const checkPixel = (id) => geomDatas[id * 4 + 3] != 0;
          const result = [];
          for (let i = 0; i < 9; i++) {
              if (checkPixel(i)) {
                  const geomData = geomDatas.subarray(i * 4, i * 4 + 4);
                  // Mask the pass id to be only the first 6 bits of the integer.
                  const passId = Math.round(geomData[0]) & (64 - 1);
                  const pass = this.getPass(passId);
                  if (pass) {
                      const geomItemAndDist = pass.getGeomItemAndDist(geomData);
                      if (geomItemAndDist) {
                          const intersectionPos = ray.start.add(ray.dir.scale(geomItemAndDist.dist));
                          result.push({
                              pointerRay: ray,
                              intersectionPos,
                              geomItem: geomItemAndDist.geomItem,
                              componentId: -1,
                              dist: geomItemAndDist.dist,
                              geomData,
                          });
                      }
                  }
              }
          }
          return result;
      }
      // //////////////////////////
      // Rendering
      /**
       * The drawBackground method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawBackground(renderstate) {
          if (this.#glBackgroundMap && this.#backgroundMapShader && this.#backgroundMapShaderBinding) {
              if (!this.#glBackgroundMap.isLoaded())
                  return;
              const gl = this.__gl;
              gl.depthMask(false);
              this.#backgroundMapShader.bind(renderstate);
              const unifs = renderstate.unifs;
              this.#glBackgroundMap.bindToUniform(renderstate, unifs.backgroundImage);
              this.#backgroundMapShaderBinding.bind(renderstate);
              gl.drawQuad();
          }
          else if (this.#glEnvMap && this.#glEnvMap.draw /* Note: video env maps cannot be drawn directly.*/) {
              this.#glEnvMap.draw(renderstate);
          }
      }
      /**
       * The bindGLRenderer method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      bindGLRenderer(renderstate) {
          super.bindGLRenderer(renderstate);
          if (renderstate instanceof ColorRenderState) {
              renderstate.envMap = this.#glEnvMap;
              renderstate.exposure = this.#exposure;
              renderstate.renderMode = this.renderMode;
              renderstate.outlineThickness = this.outlineThickness;
              renderstate.outlineColor = this.outlineColor;
              renderstate.hiddenLineColor = this.hiddenLineColor;
              renderstate.outlineMethod = this.outlineMethod;
              renderstate.screenQuad = this.screenQuad;
          }
      }
      /**
       * The drawScene method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawScene(renderstate) {
          this.bindGLRenderer(renderstate);
          if (this.#displayEnvironment)
              this.drawBackground(renderstate);
          super.drawScene(renderstate);
          // console.log("Draw Calls:" + renderstate['drawCalls']);
      }
  }

  /** This class abstracts the rendering of a collection of geometries to screen.
   * @extends EventEmitter
   * @private
   */
  class GLGeomItemSetMultiDraw extends EventEmitter {
      renderer;
      gl;
      glGeomItems = [];
      glGeomIdsMapping = {};
      glgeomItemEventHandlers = [];
      freeIndices = [];
      // The last camera position from which the data was sorted
      viewPos = new Vec3();
      // Mapping from the array of glGeomItems, to the actual rendering
      // order. When rendering transparent geoms, we sort this array.
      // Mapping from the array of glGeomItems, to the actual rendering
      // order. When rendering transparent geoms, we sort this array.
      drawElementCounts = new Int32Array(0);
      drawElementOffsets = new Int32Array(0);
      highlightElementCounts = new Int32Array(0);
      highlightElementOffsets = new Int32Array(0);
      drawOrderToIndex = [];
      indexToDrawIndex = [];
      drawIdsArray = new Float32Array(0);
      drawIdsBufferDirty = true;
      drawIdsTexture = null;
      highlightedItems = [];
      highlightedIdsArray = null;
      highlightedIdsTexture = null;
      highlightedIdsBufferDirty = false;
      // When a geometry changes, we update offset and count the values.
      dirtyGeomIndices = new Set();
      /**
       * Create a GL geom item set.
       * @param renderer - The renderer object.
       */
      constructor(renderer) {
          super();
          this.renderer = renderer;
          this.gl = renderer.gl;
          this.renderer.glGeomLibrary.on('geomDataChanged', (event) => {
              const geomItemIndices = this.glGeomIdsMapping[event.index];
              if (geomItemIndices != undefined) {
                  this.dirtyGeomIndices.add(event.index);
              }
          });
      }
      /**
       * The addGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       */
      addGLGeomItem(glGeomItem) {
          const index = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.glGeomItems.length;
          // Note: we now allocate the draw index right away.
          // Visibility only controls the element count value
          this.indexToDrawIndex[index] = this.drawOrderToIndex.length;
          this.drawOrderToIndex.push(index);
          const eventHandlers = {};
          // //////////////////////////////
          // Visibility
          eventHandlers.visibilityChanged = (event) => {
              const drawIndex = this.indexToDrawIndex[index];
              if (event.visible) {
                  const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId);
                  this.drawElementCounts[drawIndex] = offsetAndCount[1];
              }
              else {
                  this.drawElementCounts[drawIndex] = 0;
              }
              this.emit('updated');
          };
          glGeomItem.on('visibilityChanged', eventHandlers.visibilityChanged);
          // //////////////////////////////
          // Highlighted
          if (glGeomItem.geomItem.isHighlighted()) {
              this.highlightedItems.push(glGeomItem);
              this.highlightedIdsBufferDirty = true;
          }
          eventHandlers.highlightChanged = (event) => {
              if (event && event.name) {
                  // Note: highlightChanged is fired when the color changes
                  // or another highlight is added over the top. We avoid
                  // adding the same index again here. (TODO: use Set?)
                  if (this.highlightedItems.includes(glGeomItem))
                      return;
                  this.highlightedItems.push(glGeomItem);
              }
              else {
                  this.highlightedItems.splice(this.highlightedItems.indexOf(glGeomItem), 1);
              }
              // console.log("highlightChanged:", glGeomItem.geomItem.getName(), glGeomItem.geomItem.isHighlighted(), this.highlightedItems)
              this.highlightedIdsBufferDirty = true;
              this.emit('updated');
          };
          glGeomItem.geomItem.on('highlightChanged', eventHandlers.highlightChanged);
          // //////////////////////////////
          // Geometry
          const geomParam = glGeomItem.geomItem.geomParam;
          let geom = geomParam.value;
          glGeomItem.geomId = this.renderer.glGeomLibrary.addGeom(geom);
          // Keep track of which geomitems use which geoms, so we can update the offset and count array if they change.
          if (!this.glGeomIdsMapping[glGeomItem.geomId]) {
              this.glGeomIdsMapping[glGeomItem.geomId] = [index];
          }
          else {
              this.glGeomIdsMapping[glGeomItem.geomId].push(index);
          }
          this.glGeomItems[index] = glGeomItem;
          this.glgeomItemEventHandlers[index] = eventHandlers;
          this.drawIdsBufferDirty = true;
          this.emit('updated');
      }
      /**
       * The removeGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       */
      removeGLGeomItem(glGeomItem) {
          const index = this.glGeomItems.indexOf(glGeomItem);
          const geom = this.renderer.glGeomLibrary.getGeom(glGeomItem.geomId);
          this.renderer.glGeomLibrary.removeGeom(geom);
          const geomItemIndices = this.glGeomIdsMapping[glGeomItem.geomId];
          geomItemIndices.splice(geomItemIndices.indexOf(index), 1);
          if (geomItemIndices.length == 0) {
              delete this.glGeomIdsMapping[glGeomItem.geomId];
              if (this.dirtyGeomIndices.has(glGeomItem.geomId))
                  this.dirtyGeomIndices.delete(glGeomItem.geomId);
          }
          const eventHandlers = this.glgeomItemEventHandlers[index];
          glGeomItem.geomItem.off('highlightChanged', eventHandlers.highlightChanged);
          glGeomItem.off('visibilityChanged', eventHandlers.visibilityChanged);
          this.glGeomItems[index] = null;
          this.glgeomItemEventHandlers[index] = null;
          this.drawIdsArray[index] = 0;
          this.drawElementOffsets[index] = 0;
          this.drawElementCounts[index] = 0;
          this.freeIndices.push(index);
          if (glGeomItem.isVisible()) {
              // Note: as items are removed, the indexToDrawIndex values get broken and must be updated.
              const drawIndex = this.drawOrderToIndex.indexOf(index);
              this.drawOrderToIndex.splice(drawIndex, 1);
              this.indexToDrawIndex[index] = -1;
              this.drawElementCounts[drawIndex] = 0;
              this.drawIdsBufferDirty = true;
          }
          if (glGeomItem.geomItem.isHighlighted()) {
              const highlightIndex = this.highlightedItems.indexOf(glGeomItem);
              this.highlightedItems.splice(highlightIndex, 1);
              this.highlightedIdsBufferDirty = true;
          }
          this.emit('updated');
      }
      // ////////////////////////////////////
      // Draw Ids
      cleanGeomIds() {
          // When a geometry changes, we update offset and count the values.
          // Note: this method is quite expensive.
          // (taking up 80% of the time to load the GPU in the Memory test before it was refactored)
          // The cost is probably in the "drawOrderToIndex.indexOf(index)" call below.
          // Most of the time, we are adding/removing GeomItems. The geoms rarely change
          // independently.
          // We run this method in the rare occurrence that a geom changes, and not its GeomItem.
          this.dirtyGeomIndices.forEach((geomId) => {
              const geomItemIndices = this.glGeomIdsMapping[geomId];
              if (geomItemIndices != undefined) {
                  const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(geomId);
                  geomItemIndices.forEach((index) => {
                      const glGeomItem = this.glGeomItems[index];
                      if (glGeomItem.isVisible()) {
                          const drawIndex = this.indexToDrawIndex[index];
                          this.drawElementOffsets[drawIndex] = offsetAndCount[0];
                          this.drawElementCounts[drawIndex] = offsetAndCount[1];
                          this.drawIdsArray[drawIndex] = glGeomItem.geomItemId;
                          const highlightIndex = this.highlightedItems.indexOf(glGeomItem);
                          if (highlightIndex != -1) {
                              this.highlightElementOffsets[highlightIndex] = offsetAndCount[0];
                              this.highlightElementCounts[highlightIndex] = offsetAndCount[1];
                          }
                      }
                  });
              }
          });
          this.dirtyGeomIndices = new Set();
      }
      /**
       * The updateDrawIDsBuffer method.
       * @param renderstate - The object used to track state changes during rendering.
       */
      updateDrawIDsBuffer(renderstate) {
          {
              if (!this.drawIdsArray || this.drawOrderToIndex.length > this.drawIdsArray.length) {
                  this.drawIdsArray = new Float32Array(this.drawOrderToIndex.length);
                  // Note: the +1 here is to avoid an exception thrown on Safari if the offsets and counts are
                  // exactly the size of the number of drawn items. (a bug in the validation).
                  this.drawElementOffsets = new Int32Array(this.drawOrderToIndex.length + 1);
                  this.drawElementCounts = new Int32Array(this.drawOrderToIndex.length + 1);
              }
              this.drawOrderToIndex.forEach((itemIndex, drawIndex) => {
                  const glGeomItem = this.glGeomItems[itemIndex];
                  if (!glGeomItem)
                      return;
                  const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId);
                  this.drawElementOffsets[drawIndex] = offsetAndCount[0];
                  this.drawElementCounts[drawIndex] = glGeomItem.isVisible() ? offsetAndCount[1] : 0;
                  this.drawIdsArray[drawIndex] = glGeomItem.geomItemId;
                  // Note: as items are removed, these indices must be updated.
                  this.indexToDrawIndex[itemIndex] = drawIndex;
              });
              this.dirtyGeomIndices = new Set();
          }
          const gl = this.renderer.gl;
          const unit = renderstate.boundTextures++;
          gl.activeTexture(gl.TEXTURE0 + unit);
          const drawIdsTextureSize = MathFunctions.nextPow2(Math.ceil(Math.sqrt(this.drawOrderToIndex.length))) * 2;
          if (!this.drawIdsTexture) {
              this.drawIdsTexture = new GLTexture2D(this.gl, {
                  format: gl.name == 'webgl2' ? 'RED' : 'ALPHA',
                  type: 'FLOAT',
                  width: drawIdsTextureSize,
                  height: drawIdsTextureSize,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  mipMapped: false,
              });
          }
          else if (this.drawIdsTexture.width < drawIdsTextureSize || this.drawIdsTexture.height < drawIdsTextureSize) {
              this.drawIdsTexture.resize(drawIdsTextureSize, drawIdsTextureSize);
          }
          {
              const tex = this.drawIdsTexture;
              const texWidth = this.drawIdsTexture.width;
              gl.bindTexture(gl.TEXTURE_2D, tex.glTex);
              const level = 0;
              const xoffset = 0;
              const height = 1;
              const format = tex.getFormat();
              const type = tex.getType();
              const rows = Math.ceil((xoffset + this.drawOrderToIndex.length) / texWidth);
              let consumed = 0;
              let remaining = this.drawOrderToIndex.length;
              let rowStart = xoffset;
              for (let i = 0; i < rows; i++) {
                  let width;
                  if (rowStart + remaining > texWidth) {
                      width = texWidth - rowStart;
                      rowStart = 0;
                  }
                  else {
                      width = remaining;
                  }
                  const x = consumed % texWidth;
                  const y = Math.floor(consumed / texWidth);
                  const data = this.drawIdsArray.subarray(consumed, consumed + width);
                  gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data);
                  consumed += width;
                  remaining -= width;
              }
          }
          gl.bindTexture(gl.TEXTURE_2D, null);
          renderstate.boundTextures--;
          this.drawIdsBufferDirty = false;
      }
      // ////////////////////////////////////
      // Selected Items
      /**
       * The updateHighlightedIDsBuffer method.
       * @param renderstate - The object used to track state changes during rendering.
       */
      updateHighlightedIDsBuffer(renderstate) {
          if (this.highlightedIdsBufferDirty) {
              if (!this.highlightedIdsArray || this.highlightedItems.length > this.highlightedIdsArray.length) {
                  this.highlightedIdsArray = new Float32Array(this.highlightedItems.length);
                  // Note: the +1 here is to avoid an exception thrown on Safari if the offsets and counts are
                  // exactly the size of the number of drawn items. (a bug in the validation).
                  this.highlightElementOffsets = new Int32Array(this.highlightedItems.length + 1);
                  this.highlightElementCounts = new Int32Array(this.highlightedItems.length + 1);
              }
              // Collect all visible geom ids into the instanceIds array.
              // Note: the draw count can be less than the number of instances
              // we re-use the same buffer and simply invoke fewer draw calls.
              this.highlightedItems.forEach((glGeomItem, index) => {
                  this.highlightedIdsArray[index] = glGeomItem.geomItemId;
                  const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId);
                  this.highlightElementOffsets[index] = offsetAndCount[0];
                  this.highlightElementCounts[index] = offsetAndCount[1];
              });
              for (let i = this.highlightedItems.length; i < this.highlightElementCounts.length; i++) {
                  this.highlightElementOffsets[i] = 0;
                  this.highlightElementCounts[i] = 0;
              }
              this.highlightedIdsBufferDirty = false;
          }
          const gl = this.renderer.gl;
          const unit = renderstate.boundTextures++;
          gl.activeTexture(gl.TEXTURE0 + unit);
          const highlightIdsTextureSize = MathFunctions.nextPow2(Math.ceil(Math.sqrt(this.highlightedItems.length)));
          if (!this.highlightedIdsTexture) {
              this.highlightedIdsTexture = new GLTexture2D(this.gl, {
                  format: gl.name == 'webgl2' ? 'RED' : 'ALPHA',
                  type: 'FLOAT',
                  width: highlightIdsTextureSize,
                  height: highlightIdsTextureSize,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  mipMapped: false,
              });
          }
          else if (this.highlightedIdsTexture.width < highlightIdsTextureSize ||
              this.highlightedIdsTexture.height < highlightIdsTextureSize) {
              this.highlightedIdsTexture.resize(highlightIdsTextureSize, highlightIdsTextureSize);
          }
          {
              const tex = this.highlightedIdsTexture;
              const texWidth = this.highlightedIdsTexture.width;
              gl.bindTexture(gl.TEXTURE_2D, tex.glTex);
              const level = 0;
              const xoffset = 0;
              const height = 1;
              const format = tex.getFormat();
              const type = tex.getType();
              const rows = Math.ceil((xoffset + this.highlightedIdsArray.length) / texWidth);
              let consumed = 0;
              let remaining = this.highlightedIdsArray.length;
              let rowStart = xoffset;
              for (let i = 0; i < rows; i++) {
                  let width;
                  if (rowStart + remaining > texWidth) {
                      width = texWidth - rowStart;
                      rowStart = 0;
                  }
                  else {
                      width = remaining;
                  }
                  const x = consumed % texWidth;
                  const y = Math.floor(consumed / texWidth);
                  const data = this.highlightedIdsArray.subarray(consumed, consumed + width);
                  gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data);
                  consumed += width;
                  remaining -= width;
              }
          }
          gl.bindTexture(gl.TEXTURE_2D, null);
          renderstate.boundTextures--;
      }
      // ////////////////////////////////////
      // Drawing
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer(renderstate);
          }
          else if (this.dirtyGeomIndices.size > 0) {
              this.cleanGeomIds();
          }
          // Note: updateDrawIDsBuffer first, as this avoids a case where the buffers stay dirty
          // because the last item was removed.
          if (this.drawIdsArray.length == 0) {
              return;
          }
          if (this.drawIdsTexture) {
              const { drawIdsTexture } = renderstate.unifs;
              this.drawIdsTexture.bindToUniform(renderstate, drawIdsTexture);
          }
          this.bindAndRender(renderstate, this.drawElementCounts, this.drawElementOffsets, this.drawOrderToIndex.length);
      }
      /**
       * The drawHighlighted method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlighted(renderstate) {
          if (this.highlightedItems.length == 0) {
              return;
          }
          if (this.highlightedIdsBufferDirty) {
              this.updateHighlightedIDsBuffer(renderstate);
          }
          if (this.highlightedIdsTexture) {
              const { drawIdsTexture } = renderstate.unifs;
              this.highlightedIdsTexture.bindToUniform(renderstate, drawIdsTexture);
          }
          this.bindAndRender(renderstate, this.highlightElementCounts, this.highlightElementOffsets, this.highlightedItems.length);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer(renderstate);
          }
          // Note: updateDrawIDsBuffer first, as this avoids a case where the buffers stay dirty
          // because the last item was removed.
          if (this.drawOrderToIndex.length == 0) {
              return;
          }
          if (this.drawIdsTexture) {
              const { drawIdsTexture } = renderstate.unifs;
              this.drawIdsTexture.bindToUniform(renderstate, drawIdsTexture);
          }
          this.bindAndRender(renderstate, this.drawElementCounts, this.drawElementOffsets, this.drawOrderToIndex.length);
      }
      /**
       * The bindAndRender method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param counts - the counts for each element drawn in by this draw call.
       * @param offsets - the offsets for each element drawn in by this draw call.
       * @private
       */
      bindAndRender(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          const unifs = renderstate.unifs;
          // Specify an instanced draw to the shader so it knows how
          // to retrieve the modelmatrix.
          if (unifs.instancedDraw) {
              gl.uniform1i(renderstate.unifs.instancedDraw.location, 1);
          }
          renderstate.bindViewports(unifs, () => {
              this.multiDraw(renderstate, counts, offsets, drawCount);
          });
      }
      /**
       * Sorts the drawn items in order furthest to nearest when rendering transparent objects.
       * @param viewPos - The position of the camera that we are sorting relative to.
       */
      sortItems(viewPos) {
          const distances = new Float32Array(this.drawOrderToIndex.length);
          this.drawOrderToIndex.forEach((itemIndex) => {
              const glGeomItem = this.glGeomItems[itemIndex];
              if (glGeomItem) {
                  const bbox = glGeomItem.geomItem.boundingBoxParam.value;
                  // Calculate the disance to the surface of the bounding sphere.
                  // TODO: calculate the distance the nearest point on the bounding box.
                  const center = bbox.center();
                  const size = bbox.size();
                  const dist = center.distanceTo(viewPos) - size;
                  distances[itemIndex] = dist;
              }
          });
          this.drawOrderToIndex.sort((a, b) => distances[b] - distances[a]);
          this.drawOrderToIndex.forEach((itemIndex, drawIndex) => {
              const glGeomItem = this.glGeomItems[itemIndex];
              if (glGeomItem) {
                  this.drawIdsArray[drawIndex] = glGeomItem.geomItemId;
                  this.indexToDrawIndex[itemIndex] = drawIndex;
              }
          });
          // Force the re-generation of the draw ids texture using the new ordering.
          this.drawIdsBufferDirty = true;
          this.viewPos = viewPos;
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          if (this.drawIdsTexture) {
              this.drawIdsTexture.destroy();
          }
          if (this.highlightedIdsTexture) {
              this.highlightedIdsTexture.destroy();
          }
          this.emit('destructing');
      }
  }

  /** Class representing a GL mesh.
   * @extends GLGeom
   * @private
   */
  class GLPointsItemSet extends GLGeomItemSetMultiDraw {
      /**
       * Draw an item to screen.
       * @param renderstate - The object tracking the current state of the renderer
       * @param drawIds - the draw id for each element drawn in by this draw call.
       * @param counts - the geom element count for each element drawn in by this draw call.
       * @param offsets - the geom element offset for each element drawn in by this draw call.
       * @param drawCount - the number of active draw calls for this invocation
       */
      multiDraw(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          if (gl.multiDrawArrays) {
              gl.multiDrawArrays(gl.POINTS, offsets, 0, counts, 0, drawCount);
          }
          else {
              const { drawId } = renderstate.unifs;
              for (let i = 0; i < drawCount; i++) {
                  gl.uniform1i(drawId.location, i);
                  gl.drawArrays(gl.POINTS, offsets[i], counts[i]);
              }
          }
      }
  }

  /** Class representing a GL mesh.
   * @extends GLGeom
   * @private
   */
  class GLLinesItemSet extends GLGeomItemSetMultiDraw {
      /**
       * Draw an item to screen.
       * @param renderstate - The object tracking the current state of the renderer
       * @param drawIds - the draw id for each element drawn in by this draw call.
       * @param counts - the geom element count for each element drawn in by this draw call.
       * @param offsets - the geom element offset for each element drawn in by this draw call.
       * @param drawCount - the number of active draw calls for this invocation
       */
      multiDraw(renderstate, counts, offsets, drawCount) {
          const { occluded, hiddenLineColor } = renderstate.unifs;
          // @ts-ignore
          const drawingHiddenLines = 
          // @ts-ignore
          renderstate.hiddenLineColor &&
              // @ts-ignore
              renderstate.hiddenLineColor.a > 0 &&
              occluded &&
              hiddenLineColor;
          const gl = this.gl;
          if (gl.multiDrawArrays) {
              gl.multiDrawElements(gl.LINES, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
              if (drawingHiddenLines) {
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  gl.multiDrawElements(gl.LINES, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
                  gl.depthFunc(gl.LEQUAL);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
          else {
              const { drawId } = renderstate.unifs;
              for (let i = 0; i < drawCount; i++) {
                  gl.uniform1i(drawId.location, i);
                  gl.drawElements(gl.LINES, counts[i], gl.UNSIGNED_INT, offsets[i]);
              }
              if (drawingHiddenLines) {
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  for (let i = 0; i < drawCount; i++) {
                      gl.uniform1i(drawId.location, i);
                      gl.drawElements(gl.LINES, counts[i], gl.UNSIGNED_INT, offsets[i]);
                  }
                  gl.depthFunc(gl.LEQUAL);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
      }
  }

  var GeomType$1;
  (function (GeomType) {
      GeomType[GeomType["TRIANGLES"] = 0] = "TRIANGLES";
      GeomType[GeomType["LINES"] = 1] = "LINES";
      GeomType[GeomType["POINTS"] = 2] = "POINTS";
  })(GeomType$1 || (GeomType$1 = {}));
  /** Class representing a GL mesh.
   * @extends GLGeom
   * @private
   */
  class GLMeshItemSet extends GLGeomItemSetMultiDraw {
      /**
       * Draw an item to screen.
       * @param renderstate - The object tracking the current state of the renderer
       * @param drawIds - the draw id for each element drawn in by this draw call.
       * @param counts - the geom element count for each element drawn in by this draw call.
       * @param offsets - the geom element offset for each element drawn in by this draw call.
       * @param drawCount - the number of active draw calls for this invocation
       */
      multiDraw(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          const multiDrawMeshes = () => {
              if (gl.multiDrawElements) {
                  gl.multiDrawElements(gl.TRIANGLES, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
              }
              else {
                  const { drawId } = renderstate.unifs;
                  for (let i = 0; i < drawCount; i++) {
                      gl.uniform1i(drawId.location, i);
                      gl.drawElements(gl.TRIANGLES, counts[i], gl.UNSIGNED_INT, offsets[i]);
                  }
              }
          };
          const { geomType, outlineThickness, viewportSize, renderMode } = renderstate.unifs;
          const renderModeValue = renderstate instanceof ColorRenderState && renderMode ? renderstate.renderMode : null;
          const drawingOutlines = renderstate instanceof ColorRenderState &&
              outlineThickness &&
              viewportSize &&
              renderstate.outlineMethod == 'geometry' &&
              renderstate.outlineThickness > 0 &&
              renderModeValue != 'flat-noedges' &&
              renderModeValue != 'pbr-noedges';
          const drawingWireframeOutlines = drawingOutlines && renderModeValue == 'wireframe';
          if (drawingWireframeOutlines) {
              gl.enable(gl.STENCIL_TEST);
              gl.clearStencil(0);
              gl.clear(gl.STENCIL_BUFFER_BIT);
              gl.stencilOpSeparate(gl.FRONT, gl.DECR_WRAP, gl.DECR_WRAP, gl.DECR_WRAP);
              gl.stencilOpSeparate(gl.BACK, gl.INCR_WRAP, gl.INCR_WRAP, gl.INCR_WRAP);
              gl.stencilFunc(gl.ALWAYS, 0, 0xff);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.disable(gl.DEPTH_TEST);
              gl.depthMask(false);
              gl.colorMask(false, false, false, false);
              // @ts-ignore
          }
          else if (renderModeValue == 'hiddenline') {
              // Note: only the standard surface shader exposes the 'renderMode' uniform,
              // so this prevents other shaders from being skippped.
              // e.g. PMI data shoudl show up normally in wireframe mode and it is rendered using the FlatSurfaceShader.
              // don't render surfaces
              // Note: Make sure to render alpha channel
              gl.colorMask(false, false, false, true);
          }
          if (geomType)
              gl.uniform1i(geomType.location, GeomType$1.TRIANGLES);
          // Always zero this value before drawing the faces, else the shader could think its drawing the outline.
          if (outlineThickness) {
              gl.uniform1f(outlineThickness.location, 0);
          }
          multiDrawMeshes();
          if (drawingOutlines) {
              const colorRenderState = renderstate;
              // Only draw font faces. BEcause all faces are drawn, it can make a mess to see the back faces through the front faces.
              // e.g. we might see the triangles on the other side of a sphere rendered over the top of triangles on the near side.
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.FRONT);
              // @ts-ignore
              gl.uniform1f(outlineThickness.location, colorRenderState.outlineThickness * window.devicePixelRatio);
              gl.uniform2f(viewportSize.location, renderstate.region[2] - renderstate.region[0], renderstate.region[3] - renderstate.region[1]);
              // @ts-ignore
              if (renderModeValue == 'hiddenline') {
                  // start rendering surfaces again
                  gl.colorMask(true, true, true, true);
              }
              if (!drawingWireframeOutlines) {
                  gl.enable(gl.BLEND);
                  gl.blendEquation(gl.FUNC_ADD);
                  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
              }
              multiDrawMeshes();
              gl.disable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              if (drawingWireframeOutlines) {
                  gl.enable(gl.DEPTH_TEST);
                  gl.depthMask(true);
                  gl.colorMask(true, true, true, true);
                  gl.stencilFunc(gl.NOTEQUAL, 0x0, 0xff);
                  gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                  // Blend the outline over the existing geometry.
                  {
                      gl.enable(gl.BLEND);
                      gl.blendEquation(gl.FUNC_ADD);
                      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                  }
                  // cache the previously bound shader.
                  const shader = colorRenderState.glShader;
                  const shaderKey = colorRenderState.shaderkey;
                  const screenQuad = colorRenderState.screenQuad;
                  screenQuad.bindShader(colorRenderState);
                  screenQuad.draw(colorRenderState, colorRenderState.outlineColor);
                  // Re-bind the previously bound geomdata shader.
                  shader.bind(colorRenderState, shaderKey);
                  this.renderer.glGeomItemLibrary.bind(colorRenderState);
                  this.renderer.glGeomLibrary.bind(colorRenderState);
                  this.renderer.glMaterialLibrary.bind(colorRenderState);
                  gl.disable(gl.STENCIL_TEST);
              }
          }
      }
  }

  /** This class abstracts the rendering of a collection of geometries to screen.
   * @extends EventEmitter
   * @private
   */
  class GLGeomItemSet extends EventEmitter {
      gl;
      glGeom;
      id;
      glGeomItems;
      glgeomItems_freeIndices;
      glgeomItemEventHandlers;
      drawIdsArray = null;
      drawIdsBuffer = null;
      drawIdsBufferDirty;
      highlightedIdsArray = null;
      highlightedIdsBuffer = null;
      highlightedIdsBufferDirty;
      visibleItems;
      highlightedItems;
      /**
       * Create a GL geom item set.
       * @param gl - The webgl rendering context.
       * @param glGeom - The glGeom value.
       */
      constructor(gl, glGeom) {
          super();
          this.gl = gl;
          this.glGeom = glGeom;
          this.id = glGeom ? glGeom.getGeom().getId() : this.getId();
          this.glGeomItems = [];
          this.glgeomItems_freeIndices = [];
          this.glgeomItemEventHandlers = [];
          this.drawIdsArray = null;
          this.drawIdsBuffer = null;
          this.drawIdsBufferDirty = true;
          this.highlightedIdsArray = null;
          this.highlightedIdsBuffer = null;
          this.highlightedIdsBufferDirty = true;
          this.visibleItems = [];
          this.highlightedItems = [];
      }
      /**
       * The getGLGeom method.
       * @return - The return value.
       */
      getGLGeom() {
          return this.glGeom;
      }
      /**
       * The getDrawCount method.
       * @return - The return value.
       */
      getDrawCount() {
          return this.visibleItems.length;
      }
      /**
       * The addGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       */
      addGLGeomItem(glGeomItem) {
          let index;
          if (this.glgeomItems_freeIndices.length > 0) {
              index = this.glgeomItems_freeIndices.pop();
          }
          else {
              index = this.glGeomItems.length;
              this.glGeomItems.push(null);
          }
          if (glGeomItem.geomItem.isVisible()) {
              this.visibleItems.push(index);
              const event = new CountChangedEvent(1, this.visibleItems.length);
              this.emit('drawCountChanged', event);
          }
          if (glGeomItem.geomItem.isHighlighted()) {
              this.highlightedItems.push(index);
              this.highlightedIdsBufferDirty = true;
          }
          const eventHandlers = {};
          eventHandlers.highlightChanged = (event) => {
              if (glGeomItem.geomItem.isHighlighted()) {
                  // Note: highlightChanged is fired when the color changes
                  // or another highlight is added over the top. We avoid
                  // adding the same index again here. (TODO: use Set?)
                  if (this.highlightedItems.includes(index))
                      return;
                  this.highlightedItems.push(index);
                  const event = new CountChangedEvent(1, this.highlightedItems.length);
                  this.emit('highlightedCountChanged', event);
              }
              else {
                  this.highlightedItems.splice(this.highlightedItems.indexOf(index), 1);
                  const event = new CountChangedEvent(-1, this.highlightedItems.length);
                  this.emit('highlightedCountChanged', event);
              }
              // console.log("highlightChanged:", glGeomItem.geomItem.getName(), glGeomItem.geomItem.isHighlighted(), this.highlightedItems)
              this.highlightedIdsBufferDirty = true;
          };
          glGeomItem.geomItem.on('highlightChanged', eventHandlers.highlightChanged);
          eventHandlers.visibilityChanged = (event) => {
              const visible = event.visible;
              if (visible) {
                  this.visibleItems.push(index);
                  const event = new CountChangedEvent(1, this.visibleItems.length);
                  this.emit('drawCountChanged', event);
              }
              else {
                  this.visibleItems.splice(this.visibleItems.indexOf(index), 1);
                  const event = new CountChangedEvent(-1, this.visibleItems.length);
                  this.emit('drawCountChanged', event);
              }
              this.drawIdsBufferDirty = true;
          };
          glGeomItem.geomItem.on('visibilityChanged', eventHandlers.visibilityChanged);
          this.glGeomItems[index] = glGeomItem;
          this.glgeomItemEventHandlers[index] = eventHandlers;
          this.drawIdsBufferDirty = true;
          glGeomItem.GLGeomItemSet = this;
      }
      /**
       * The removeGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       */
      removeGLGeomItem(glGeomItem) {
          const index = this.glGeomItems.indexOf(glGeomItem);
          const eventHandlers = this.glgeomItemEventHandlers[index];
          glGeomItem.geomItem.off('highlightChanged', eventHandlers.highlightChanged);
          glGeomItem.geomItem.off('visibilityChanged', eventHandlers.visibilityChanged);
          this.glGeomItems[index] = null;
          this.glgeomItemEventHandlers[index] = null;
          glGeomItem.GLGeomItemSet = null;
          this.glgeomItems_freeIndices.push(index);
          if (glGeomItem.geomItem.isVisible()) {
              this.visibleItems.splice(this.visibleItems.indexOf(index), 1);
              const event = new CountChangedEvent(-1, this.visibleItems.length);
              this.emit('drawCountChanged', event);
          }
          if (glGeomItem.geomItem.isHighlighted()) {
              this.highlightedItems.splice(this.highlightedItems.indexOf(index), 1);
              const event = new CountChangedEvent(-1, this.highlightedItems.length);
              this.emit('highlightedCountChanged', event);
          }
          this.drawIdsBufferDirty = true;
          // console.log("removeGLGeomItem:", glGeomItem.geomItem.getName(), this.glGeomItems.length)
          if (this.glGeomItems.length == this.glgeomItems_freeIndices.length) {
              this.destroy();
          }
      }
      // ////////////////////////////////////
      // Instance Ids
      /**
       * The updateDrawIDsBuffer method.
       * The culling system will specify a subset of the total number of items for
       * drawing.
       */
      updateDrawIDsBuffer() {
          const gl = this.gl;
          if (!gl.floatTexturesSupported) {
              this.drawIdsBufferDirty = false;
              return;
          }
          if (this.drawIdsBuffer && this.glGeomItems.length != this.drawIdsArray.length) {
              this.gl.deleteBuffer(this.drawIdsBuffer);
              this.drawIdsBuffer = null;
          }
          if (!this.drawIdsBuffer) {
              this.drawIdsBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.drawIdsBuffer);
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, this.drawIdsBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.getDrawIdsArray(), gl.STATIC_DRAW);
          this.drawIdsBufferDirty = false;
      }
      /**
       * The getDrawIdsArray method.
       * @return - The drawIds for each GeomItem packed into a Float32Array
       */
      getDrawIdsArray() {
          if (this.drawIdsBufferDirty) {
              if (!this.drawIdsArray || this.glGeomItems.length != this.drawIdsArray.length) {
                  this.drawIdsArray = new Float32Array(this.glGeomItems.length);
              }
              // Collect all visible geom ids into the instanceIds array.
              // Note: the draw count can be less than the number of instances
              // we re-use the same buffer and simply invoke fewer draw calls.
              this.visibleItems.forEach((index, tgtIndex) => {
                  this.drawIdsArray[tgtIndex] = this.glGeomItems[index].geomItemId;
              });
              this.drawIdsBufferDirty = false;
          }
          return this.drawIdsArray;
      }
      // ////////////////////////////////////
      // Selected Items
      /**
       * The updateHighlightedIDsBuffer method.
       */
      updateHighlightedIDsBuffer() {
          const gl = this.gl;
          if (!gl.floatTexturesSupported) {
              this.highlightedIdsBufferDirty = false;
              return;
          }
          if (this.highlightedIdsBuffer && this.glGeomItems.length > this.highlightedIdsArray.length) {
              this.gl.deleteBuffer(this.highlightedIdsBuffer);
              this.highlightedIdsBuffer = null;
          }
          if (!this.highlightedIdsBuffer) {
              this.highlightedIdsBuffer = gl.createBuffer();
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, this.highlightedIdsBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.getHighlightedIdsArray(), gl.STATIC_DRAW);
          this.highlightedIdsBufferDirty = false;
      }
      /**
       * The getHighlightedIdsArray method.
       * @return - The drawIds for each GeomItem packed into a Float32Array
       */
      getHighlightedIdsArray() {
          if (this.highlightedIdsBufferDirty) {
              if (!this.highlightedIdsArray || this.highlightedItems.length > this.highlightedIdsArray.length) {
                  this.highlightedIdsArray = new Float32Array(this.glGeomItems.length);
              }
              // Collect all visible geom ids into the instanceIds array.
              // Note: the draw count can be less than the number of instances
              // we re-use the same buffer and simply invoke fewer draw calls.
              this.highlightedItems.forEach((index, tgtIndex) => {
                  this.highlightedIdsArray[tgtIndex] = this.glGeomItems[index].geomItemId;
              });
              this.highlightedIdsBufferDirty = false;
          }
          return this.highlightedIdsArray;
      }
      // ////////////////////////////////////
      // Drawing
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.visibleItems.length == 0) {
              return;
          }
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer();
          }
          this.bindAndRender(renderstate, this.visibleItems, this.drawIdsBuffer);
      }
      /**
       * The drawHighlighted method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlighted(renderstate) {
          if (this.highlightedItems.length == 0) {
              return;
          }
          if (this.highlightedIdsBufferDirty) {
              this.updateHighlightedIDsBuffer();
          }
          this.bindAndRender(renderstate, this.highlightedItems, this.highlightedIdsBuffer);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (this.visibleItems.length == 0) {
              return;
          }
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer();
          }
          this.bindAndRender(renderstate, this.visibleItems, this.drawIdsBuffer);
      }
      bindAndRender(renderstate, itemIndices, drawIdsBuffer) {
          const gl = this.gl;
          const unifs = renderstate.unifs;
          // Lazy unbinding. We can have situations where we have many materials
          // all bound to the same geom. e.g. lots of billboards
          // We can avoid the expensive re-binding of geoms with a simple check.
          if (renderstate.glGeom != this.glGeom) {
              this.glGeom.bind(renderstate);
              renderstate.glGeom = this.glGeom;
          }
          if (!gl.floatTexturesSupported || !gl.drawElementsInstanced || !renderstate.supportsInstancing) {
              if (renderstate.unifs.instancedDraw) {
                  gl.uniform1i(renderstate.unifs.instancedDraw.location, 0);
              }
              itemIndices.forEach((index) => {
                  this.glGeomItems[index].bind(renderstate);
                  renderstate.bindViewports(unifs, () => {
                      this.glGeom.draw(renderstate);
                  });
              });
          }
          else {
              // console.log("draw:"+ this.drawIdsArray);
              // Specify an instanced draw to the shader so it knows how
              // to retrieve the modelmatrix.
              if (renderstate.unifs.instancedDraw) {
                  gl.uniform1i(renderstate.unifs.instancedDraw.location, 1);
              }
              // The instanced transform ids are bound as an instanced attribute.
              const location = renderstate.attrs.instancedIds.location;
              gl.enableVertexAttribArray(location);
              gl.bindBuffer(gl.ARRAY_BUFFER, drawIdsBuffer);
              gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 1 * 4, 0);
              gl.vertexAttribDivisor(location, 1); // This makes it instanced
              renderstate.bindViewports(unifs, () => {
                  this.glGeom.drawInstanced(renderstate, itemIndices.length);
              });
          }
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          if (this.drawIdsBuffer) {
              this.gl.deleteBuffer(this.drawIdsBuffer);
              this.drawIdsBuffer = null;
          }
          if (this.highlightedIdsBuffer) {
              this.gl.deleteBuffer(this.highlightedIdsBuffer);
              this.highlightedIdsBuffer = null;
          }
          this.emit('destructing');
      }
  }

  var vert$a = "\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;  //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, -1.0, 1.0);\n}\n"; // eslint-disable-line

  var frag$9 = "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\n\nuniform float growth;\n\nvarying vec2 v_texCoord;\n\nbool sampleNeiPixel(vec2 fragCoord, inout vec4 res) {\n  res = texture2D(colorTexture, fragCoord/screenSize);\n  if (res.a > 0.0) {\n    return true;\n  }\n  return false;\n}\n\nvec4 samplePixels(vec2 fragCoord) {\n  vec4 res = vec4(0.0);\n  \n  if (sampleNeiPixel(fragCoord, res)) return res; // M\n  \n  // Search surrounding pixels for geoms\n  if (sampleNeiPixel(fragCoord+vec2( 1, 0), res)) return res; // E\n  if (sampleNeiPixel(fragCoord+vec2(-1, 0), res)) return res; // W\n  if (sampleNeiPixel(fragCoord+vec2( 0, 1), res)) return res; // N\n  if (sampleNeiPixel(fragCoord+vec2( 0,-1), res)) return res; // S\n  if (sampleNeiPixel(fragCoord+vec2( 1, 1), res)) return res; // NW\n  if (sampleNeiPixel(fragCoord+vec2(-1, 1), res)) return res; // NE\n  if (sampleNeiPixel(fragCoord+vec2( 1,-1), res)) return res; // SW\n  if (sampleNeiPixel(fragCoord+vec2(-1,-1), res)) return res; // SE\n  \n  return res;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = samplePixels(gl_FragCoord.xy);\n  if (fragColor.a < 0.0001) {\n    discard; \n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class FattenLinesShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'FattenLinesShader');
          this.setShaderStage('VERTEX_SHADER', vert$a);
          this.setShaderStage('FRAGMENT_SHADER', frag$9);
      }
  }

  const deepEquals = (arr0, arr1) => {
      return arr0.length == arr1.length && !arr0.some((v, index) => v != arr1[index]);
  };
  var GeomType;
  (function (GeomType) {
      GeomType[GeomType["TRIANGLES"] = 0] = "TRIANGLES";
      GeomType[GeomType["LINES"] = 1] = "LINES";
      GeomType[GeomType["POINTS"] = 2] = "POINTS";
  })(GeomType || (GeomType = {}));
  /** This class abstracts the rendering of a collection of geometries to screen.
   * @extends EventEmitter
   * @private
   */
  class GLGeomItemSetMultiDrawCompoundGeom extends EventEmitter {
      renderer;
      gl;
      glGeomItems = [];
      glGeomIdsMapping = {};
      glgeomItemEventHandlers = [];
      freeIndices = [];
      // protected visibleItems: GLGeomItem[] = []
      dirtyGeomItems = new Set();
      drawIdsBufferDirty = true;
      // protected drawCounts: Record<string, number> = {}
      drawIdsArraysAllocators = {};
      drawIdsArrays = {};
      drawIdsTextures = {};
      drawElementCounts = {};
      drawElementOffsets = {};
      drawOrderToIndex = [];
      indexToDrawIndex = [];
      // As transparent geometries are re-sorted, the allocations are moved around
      // This array stores the new start position of each geometries allocation.
      // Note: sorting is disabled untill we fix all remaining issues.
      // protected indexToOffsets: Record<string, number[]> = {}
      highlightedItems = {};
      highlightedIdsArraysAllocators = {};
      // protected highlightedDrawCounts: Record<string, number> = {}
      highlightElementCounts = {};
      highlightElementOffsets = {};
      highlightedIdsArray = {};
      highlightedIdsTextures = {};
      dirtyHighlightedGeomItems = new Set();
      highlightedIdsBufferDirty = true;
      linesGeomDataBuffer = null;
      fattenLinesShader = null;
      quad = null;
      fbo = null;
      /**
       * Create a GL geom item set.
       * @param {GLBaseRenderer} renderer - The renderer object.
       */
      constructor(renderer) {
          super();
          this.renderer = renderer;
          this.gl = renderer.gl;
          this.renderer.glGeomLibrary.on('geomDataChanged', (event) => {
              const geomItemIndices = this.glGeomIdsMapping[event.index];
              if (geomItemIndices != undefined) {
                  geomItemIndices.forEach((index) => {
                      this.dirtyGeomItems.add(index);
                      if (!this.drawIdsBufferDirty) {
                          this.drawIdsBufferDirty = true;
                          this.emit('updated');
                      }
                  });
              }
          });
      }
      addItemToHighlight(index, highlightName) {
          // Check to see if the highlight key contains
          // a subGeomIndex at the end separated by a ':'
          const subGeomIndexIndex = highlightName.indexOf(':');
          let subGeomIndices = [];
          if (subGeomIndexIndex != -1) {
              subGeomIndices = highlightName
                  .substring(subGeomIndexIndex + 1)
                  .split(',')
                  .map((v) => Number.parseInt(v));
          }
          // Note: highlightChanged is fired when the color changes
          // or another highlight is added over the top. We avoid
          // adding the same index again here. (TODO: use Set?)
          if (this.highlightedItems[index] && deepEquals(this.highlightedItems[index], subGeomIndices))
              return;
          this.highlightedItems[index] = subGeomIndices;
          this.highlightedIdsBufferDirty = true;
          this.emit('updated');
      }
      /**
       * The addGLGeomItem method.
       * @param {GLGeomItem} glGeomItem - The glGeomItem value.
       */
      addGLGeomItem(glGeomItem) {
          const index = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.glGeomItems.length;
          const eventHandlers = {};
          // //////////////////////////////
          // Visibility
          if (glGeomItem.visible) {
              this.indexToDrawIndex[index] = this.drawOrderToIndex.length;
              this.drawOrderToIndex.push(index);
              this.dirtyGeomItems.add(index);
          }
          eventHandlers.visibilityChanged = (event) => {
              this.dirtyGeomItems.add(index);
              this.drawIdsBufferDirty = true;
              if (event.visible) {
                  // If the item is becoming visible for the firs time, we need to
                  // assign a drawOrder index.
                  const drawIndex = this.indexToDrawIndex[index];
                  if (drawIndex == undefined || drawIndex == -1) {
                      this.indexToDrawIndex[index] = this.drawOrderToIndex.length;
                      this.drawOrderToIndex.push(index);
                  }
              }
              this.emit('updated');
          };
          glGeomItem.on('visibilityChanged', eventHandlers.visibilityChanged);
          // //////////////////////////////
          // Highlighted
          if (glGeomItem.geomItem.isHighlighted()) {
              this.addItemToHighlight(index, glGeomItem.geomItem.getHighlightName());
          }
          eventHandlers.highlightChanged = (event) => {
              if (event && event.name) {
                  this.addItemToHighlight(index, event.name);
              }
              else {
                  delete this.highlightedItems[index];
                  // console.log("highlightChanged:", glGeomItem.geomItem.getName(), glGeomItem.geomItem.isHighlighted(), this.highlightedItems)
                  this.highlightedIdsBufferDirty = true;
                  this.emit('updated');
              }
          };
          glGeomItem.geomItem.on('highlightChanged', eventHandlers.highlightChanged);
          // //////////////////////////////
          // ShatterState
          eventHandlers.shatterStateChanged = (event) => {
              // const geomBuffers = this.renderer.glGeomLibrary.getGeomBuffers(glGeomItem.geomId)
              // if (geomBuffers.materials.length == 0)
              {
                  this.dirtyGeomItems.add(index);
                  this.drawIdsBufferDirty = true;
                  // We need the new GeomData Fbos written so we can
                  // detect these subgeoms.
                  this.renderer.renderGeomDataFbos();
              }
          };
          glGeomItem.on('shatterStateChanged', eventHandlers.shatterStateChanged);
          // //////////////////////////////
          // Geometry
          const geomParam = glGeomItem.geomItem.geomParam;
          let geom = geomParam.value;
          glGeomItem.geomId = this.renderer.glGeomLibrary.addGeom(geom);
          // Keep track of which geomitems use which geoms, so we can update the offset and count array if they change.
          if (!this.glGeomIdsMapping[glGeomItem.geomId]) {
              this.glGeomIdsMapping[glGeomItem.geomId] = [index];
          }
          else {
              this.glGeomIdsMapping[glGeomItem.geomId].push(index);
          }
          this.glGeomItems[index] = glGeomItem;
          this.glgeomItemEventHandlers[index] = eventHandlers;
          this.drawIdsBufferDirty = true;
          this.emit('updated');
      }
      /**
       * The removeGLGeomItem method.
       * @param {GLGeomItem} glGeomItem - The glGeomItem value.
       */
      removeGLGeomItem(glGeomItem) {
          const index = this.glGeomItems.indexOf(glGeomItem);
          const geomItemIndices = this.glGeomIdsMapping[glGeomItem.geomId];
          geomItemIndices.splice(geomItemIndices.indexOf(index), 1);
          if (geomItemIndices.length == 0) {
              delete this.glGeomIdsMapping[glGeomItem.geomId];
          }
          const geom = glGeomItem.geomItem.geomParam.value;
          this.renderer.glGeomLibrary.removeGeom(geom);
          const eventHandlers = this.glgeomItemEventHandlers[index];
          glGeomItem.geomItem.off('highlightChanged', eventHandlers.highlightChanged);
          glGeomItem.off('visibilityChanged', eventHandlers.visibilityChanged);
          this.glGeomItems[index] = null;
          this.glgeomItemEventHandlers[index] = null;
          this.freeIndices.push(index);
          if (this.dirtyGeomItems.has(index)) {
              this.dirtyGeomItems.delete(index);
          }
          // Clear any drawing allocations.
          for (let key in this.drawIdsArraysAllocators) {
              const prevAllocation = this.drawIdsArraysAllocators[key].getAllocation(index);
              if (prevAllocation) {
                  for (let i = 0; i < prevAllocation.size; i++) {
                      this.drawElementOffsets[key][prevAllocation.start + i] = 0;
                      this.drawElementCounts[key][prevAllocation.start + i] = 0;
                  }
                  this.drawIdsArraysAllocators[key].deallocate(index);
              }
          }
          if (glGeomItem.isVisible()) {
              const drawIndex = this.drawOrderToIndex.indexOf(index);
              this.drawOrderToIndex.splice(drawIndex, 1);
              this.indexToDrawIndex[index] = -1;
              this.drawIdsBufferDirty = true;
          }
          if (glGeomItem.geomItem.isHighlighted()) {
              delete this.highlightedItems[index];
              this.highlightedIdsBufferDirty = true;
          }
          this.emit('updated');
      }
      // ////////////////////////////////////
      // Draw Ids
      // ////////////////////////////////////
      // Instance Ids
      /**
       * The updateDrawIDsBuffer method.
       * @param {RenderState} renderstate - The object used to track state changes during rendering.
       */
      updateDrawIDsBuffer(renderstate) {
          this.dirtyGeomItems.forEach((index) => {
              const glGeomItem = this.glGeomItems[index];
              if (!glGeomItem)
                  return;
              // Note: culled geoms should still be allocated.
              // unculling/changing visiblity only changes the count value from zero to the actual value.
              {
                  const geom = this.renderer.glGeomLibrary.getGeom(glGeomItem.geomId);
                  const geomBuffers = geom.genBuffers();
                  // Here we calculate how many draws for each type of geometry, each
                  // compound goem needs. We then allocate the space we have specified.
                  let drawCounts = {};
                  if (glGeomItem.shattered) {
                      // for shattered geoms, we draw once for each subgeom for each element type
                      for (let key in geomBuffers.subGeomCounts) {
                          drawCounts[key] = geomBuffers.subGeomCounts[key].length;
                      }
                  }
                  else {
                      // for non-shattered geoms, we just draw once for each element type per GeomItem.
                      for (let key in geomBuffers.materialSubGeoms) {
                          drawCounts[key] = geomBuffers.materialSubGeoms[key].length;
                      }
                  }
                  for (let key in drawCounts) {
                      const drawCount = drawCounts[key];
                      let allocator = this.drawIdsArraysAllocators[key];
                      if (!allocator) {
                          allocator = new Allocator1D();
                          this.drawIdsArraysAllocators[key] = allocator;
                      }
                      else {
                          // This happens when an item drawing changes. e.g. it becomes shattered.
                          const prevAllocation = allocator.getAllocation(index);
                          if (prevAllocation) {
                              if (prevAllocation.size == drawCount)
                                  continue;
                              // Zero the previous allocation to remove any rendering.
                              for (let i = 0; i < prevAllocation.size; i++) {
                                  this.drawElementCounts[key][prevAllocation.start + i] = 0;
                              }
                          }
                      }
                      allocator.allocate(index, drawCount);
                  }
              }
          });
          for (let key in this.drawIdsArraysAllocators) {
              const allocator = this.drawIdsArraysAllocators[key];
              // Note: the - 1 here is to avoid an exception thrown on Safari if the offsets and counts are
              // exactly the size of the number of drawn items. (a bug in the validation).
              if (!this.drawElementCounts[key] || allocator.reservedSpace > this.drawElementCounts[key].length - 1) {
                  const drawIdsArray = new Float32Array(allocator.reservedSpace * 4); // one RGBA pixel per drawn geometry.
                  // Note: the +1 here is to avoid an exception thrown on Safari if the offsets and counts are
                  // exactly the size of the number of drawn items. (a bug in the validation).
                  const drawElementOffsets = new Int32Array(allocator.reservedSpace + 1);
                  const drawElementCounts = new Int32Array(allocator.reservedSpace + 1);
                  if (this.drawElementCounts[key]) {
                      drawIdsArray.set(this.drawIdsArrays[key], 0);
                      drawElementOffsets.set(this.drawElementOffsets[key], 0);
                      drawElementCounts.set(this.drawElementCounts[key], 0);
                  }
                  this.drawIdsArrays[key] = drawIdsArray;
                  this.drawElementOffsets[key] = drawElementOffsets;
                  this.drawElementCounts[key] = drawElementCounts;
              }
          }
          const elementSize = 4; //  Uint32Array for UNSIGNED_INT
          this.dirtyGeomItems.forEach((itemIndex) => {
              const glGeomItem = this.glGeomItems[itemIndex];
              if (!glGeomItem)
                  return;
              const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId);
              const geomBuffers = this.renderer.glGeomLibrary.getGeomBuffers(glGeomItem.geomId);
              // If an item is invisible, we allocate values, but set all count values to zero
              const visible = glGeomItem.isVisible();
              if (glGeomItem.shattered) {
                  let subIndex = 0;
                  const addSubGeoms = (offsets, counts, type) => {
                      const allocator = this.drawIdsArraysAllocators[type];
                      const drawIdsArray = this.drawIdsArrays[type];
                      const drawElementOffsets = this.drawElementOffsets[type];
                      const drawElementCounts = this.drawElementCounts[type];
                      const allocation = allocator.getAllocation(itemIndex);
                      if (!allocation)
                          return;
                      const materials = geomBuffers.materials;
                      // if (!this.indexToOffsets[type]) this.indexToOffsets[type] = []
                      // this.indexToOffsets[type][itemIndex] = allocation.start
                      for (let i = 0; i < offsets.length; i++) {
                          // The draw id within this element type. (e.g. TRIANGLES, LINES, POINTS)
                          const drawId = allocation.start + i;
                          drawElementOffsets[drawId] = offsetAndCount[0] + offsets[i] * elementSize;
                          drawElementCounts[drawId] = visible ? counts[i] : 0;
                          drawIdsArray[drawId * 4 + 0] = glGeomItem.geomItemId;
                          // Note: a zero value means no sub-geom was being drawn.
                          drawIdsArray[drawId * 4 + 1] = subIndex + 1;
                          // Note: subGeomMaterialIndices is Uint8Array, and 0 means no custom
                          // material is assigned to the subGeom.
                          // Subtract 1 to get the actual material id.
                          if (materials.length > 0 && geomBuffers.subGeomMaterialIndices[i] > 0) {
                              const materialId = geomBuffers.subGeomMaterialIndices[i] - 1;
                              const material = geomBuffers.materials[materialId];
                              const materialAddr = this.renderer.glMaterialLibrary.getMaterialAllocation(material);
                              drawIdsArray[drawId * 4 + 2] = materialAddr.start;
                          }
                          else {
                              drawIdsArray[drawId * 4 + 2] = 0.0;
                          }
                          drawIdsArray[drawId * 4 + 3] = 0; // spare
                          subIndex++;
                      }
                  };
                  addSubGeoms(geomBuffers.subGeomOffsets['TRIANGLES'], geomBuffers.subGeomCounts['TRIANGLES'], 'TRIANGLES');
                  addSubGeoms(geomBuffers.subGeomOffsets['LINES'], geomBuffers.subGeomCounts['LINES'], 'LINES');
                  addSubGeoms(geomBuffers.subGeomOffsets['POINTS'], geomBuffers.subGeomCounts['POINTS'], 'POINTS');
              }
              else {
                  const addSubGeoms = (subGeoms, type) => {
                      const allocator = this.drawIdsArraysAllocators[type];
                      const drawIdsArray = this.drawIdsArrays[type];
                      const drawElementOffsets = this.drawElementOffsets[type];
                      const drawElementCounts = this.drawElementCounts[type];
                      const allocation = allocator.getAllocation(itemIndex);
                      if (!allocation)
                          return;
                      const materials = geomBuffers.materials;
                      // if (!this.indexToOffsets[type]) this.indexToOffsets[type] = []
                      // this.indexToOffsets[type][itemIndex] = allocation.start
                      for (let i = 0; i < subGeoms.length; i++) {
                          const subGeom = subGeoms[i];
                          // The draw id within this element type. (e.g. TRIANGLES, LINES, POINTS)
                          const drawId = allocation.start + i;
                          drawElementOffsets[drawId] = offsetAndCount[0] + subGeom.offset * elementSize;
                          drawElementCounts[drawId] = visible ? subGeom.count : 0;
                          drawIdsArray[drawId * 4 + 0] = glGeomItem.geomItemId;
                          // Note: a zero value means no sub-geom was being drawn.
                          drawIdsArray[drawId * 4 + 1] = 0;
                          if (materials.length > 0 && subGeom.materialId >= 0 && geomBuffers.materials[subGeom.materialId]) {
                              const material = geomBuffers.materials[subGeom.materialId];
                              const materialAddr = this.renderer.glMaterialLibrary.getMaterialAllocation(material);
                              drawIdsArray[drawId * 4 + 2] = materialAddr.start;
                          }
                          else {
                              drawIdsArray[drawId * 4 + 2] = 0.0;
                          }
                          drawIdsArray[drawId * 4 + 3] = 0; // spare
                      }
                  };
                  for (let key in geomBuffers.materialSubGeoms) {
                      const allocator = this.drawIdsArraysAllocators[key];
                      const allocation = allocator.getAllocation(itemIndex);
                      if (!allocation)
                          continue;
                      const subGeoms = geomBuffers.materialSubGeoms[key];
                      addSubGeoms(subGeoms, key);
                  }
              }
          });
          const gl = this.renderer.gl;
          let regen = false;
          const updateDrawIdsTexture = (key) => {
              const drawIdsArray = this.drawIdsArrays[key];
              let drawIdsTexture = this.drawIdsTextures[key];
              const reservedSpaceDrawCount = this.drawIdsArraysAllocators[key].reservedSpace;
              const unit = renderstate.boundTextures++;
              gl.activeTexture(gl.TEXTURE0 + unit);
              const drawIdsTextureSize = MathFunctions.nextPow2(Math.ceil(Math.sqrt(reservedSpaceDrawCount)));
              if (!drawIdsTexture) {
                  drawIdsTexture = new GLTexture2D(this.gl, {
                      format: 'RGBA',
                      type: 'FLOAT',
                      width: drawIdsTextureSize,
                      height: drawIdsTextureSize,
                      filter: 'NEAREST',
                      wrap: 'CLAMP_TO_EDGE',
                      mipMapped: false,
                  });
                  this.drawIdsTextures[key] = drawIdsTexture;
                  regen = true;
              }
              else if (drawIdsTexture.width < drawIdsTextureSize || drawIdsTexture.height < drawIdsTextureSize) {
                  drawIdsTexture.resize(drawIdsTextureSize, drawIdsTextureSize);
                  for (let i = 0; i < this.drawOrderToIndex.length; i++)
                      this.dirtyGeomItems.add(i);
                  regen = true;
              }
              {
                  const tex = drawIdsTexture;
                  const texWidth = drawIdsTexture.width;
                  gl.bindTexture(gl.TEXTURE_2D, tex.glTex);
                  const level = 0;
                  const xoffset = 0;
                  const height = 1;
                  const format = tex.getFormat();
                  const type = tex.getType();
                  if (regen) {
                      const drawCount = this.drawIdsArraysAllocators[key].allocatedSpace;
                      const rows = Math.ceil((xoffset + drawCount) / texWidth);
                      let consumed = 0;
                      let remaining = drawCount;
                      let rowStart = xoffset;
                      for (let i = 0; i < rows; i++) {
                          let width;
                          if (rowStart + remaining > texWidth) {
                              width = texWidth - rowStart;
                              rowStart = 0;
                          }
                          else {
                              width = remaining;
                          }
                          const x = consumed % texWidth;
                          const y = Math.floor(consumed / texWidth);
                          const data = drawIdsArray.subarray(consumed * 4, (consumed + width) * 4);
                          if (data.length != width * 4) {
                              throw new Error('Invalid drawIds subarray :' + data.length + ' width:' + width);
                          }
                          gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data);
                          consumed += width;
                          remaining -= width;
                      }
                  }
                  else {
                      const allocator = this.drawIdsArraysAllocators[key];
                      this.dirtyGeomItems.forEach((itemIndex) => {
                          // const glGeomItem = this.glGeomItems[itemIndex]!
                          // if (!glGeomItem /* || !glGeomItem.isVisible()*/) return
                          const allocation = allocator.getAllocation(itemIndex);
                          if (!allocation)
                              return;
                          const start = allocation.start;
                          const drawCount = allocation.size;
                          const xoffset = start % texWidth;
                          const rows = Math.ceil((xoffset + drawCount) / texWidth);
                          let consumed = 0;
                          let remaining = drawCount;
                          let rowStart = xoffset;
                          for (let i = 0; i < rows; i++) {
                              let width;
                              if (rowStart + remaining > texWidth) {
                                  width = texWidth - rowStart;
                                  rowStart = 0;
                              }
                              else {
                                  width = remaining;
                              }
                              const x = (start + consumed) % texWidth;
                              const y = Math.floor((start + consumed) / texWidth);
                              const data = drawIdsArray.subarray((start + consumed) * 4, (start + consumed + width) * 4);
                              if (data.length != width * 4) {
                                  throw new Error('Invalid drawIds subarray :' + data.length + ' width:' + width);
                              }
                              gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data);
                              consumed += width;
                              remaining -= width;
                          }
                      });
                  }
              }
              gl.bindTexture(gl.TEXTURE_2D, null);
              renderstate.boundTextures--;
          };
          for (let key in this.drawIdsArrays) {
              // TODO: Only re-upload the dirty items.
              updateDrawIdsTexture(key);
          }
          this.dirtyGeomItems = new Set();
          this.drawIdsBufferDirty = false;
      }
      // ////////////////////////////////////
      // Selected Items
      /**
       * The updateHighlightedIDsBuffer method.
       * @param {RenderState} renderstate - The object used to track state changes during rendering.
       */
      updateHighlightedIDsBuffer(renderstate) {
          if (this.highlightedIdsBufferDirty) {
              // Clear all previous highlight buffers.
              // Note: we could considerably simplify the following code if we don't plan on
              // incrementally updating the highlight code.
              this.highlightedIdsArraysAllocators = {};
              this.highlightedIdsArray = {};
              this.highlightElementOffsets = {};
              this.highlightElementCounts = {};
              for (let key in this.highlightedItems) {
                  const index = Number.parseInt(key);
                  const subGeomIndices = this.highlightedItems[key];
                  const glGeomItem = this.glGeomItems[index];
                  const geomBuffers = this.renderer.glGeomLibrary.getGeomBuffers(glGeomItem.geomId);
                  let drawCounts = {
                      TRIANGLES: 0,
                      LINES: 0,
                      POINTS: 0,
                  };
                  if (subGeomIndices.length > 0) {
                      // for shattered geoms, we draw once for each subgeom for each element type
                      subGeomIndices.forEach((subGeomIndex) => {
                          if (subGeomIndex < geomBuffers.subGeomCounts['TRIANGLES'].length)
                              drawCounts['TRIANGLES'] += 1;
                          else {
                              const linesSubGeomIndex = subGeomIndex - geomBuffers.subGeomCounts['TRIANGLES'].length;
                              if (linesSubGeomIndex < geomBuffers.subGeomCounts['LINES'].length)
                                  drawCounts['LINES'] += 1;
                              else {
                                  const pointsSubGeomIndex = linesSubGeomIndex - geomBuffers.subGeomCounts['LINES'].length;
                                  if (pointsSubGeomIndex < geomBuffers.subGeomCounts['POINTS'].length)
                                      drawCounts['POINTS'] += 1;
                              }
                          }
                      });
                  }
                  else {
                      // for non-shattered geoms, we just draw once for each element type per GeomItem.
                      for (let key in geomBuffers.counts) {
                          if (geomBuffers.counts[key] > 0)
                              drawCounts[key] = 1;
                      }
                  }
                  for (let key in drawCounts) {
                      const drawCount = drawCounts[key];
                      if (drawCount == 0)
                          continue;
                      if (!this.highlightedIdsArraysAllocators[key]) {
                          this.highlightedIdsArraysAllocators[key] = new Allocator1D();
                      }
                      this.highlightedIdsArraysAllocators[key].allocate(index, drawCount);
                  }
              }
              // let regen = false
              for (let key in this.highlightedIdsArraysAllocators) {
                  const allocator = this.highlightedIdsArraysAllocators[key];
                  // Note: the - 1 here is to avoid an exception thrown on Safari if the offsets and counts are
                  // exactly the size of the number of drawn items. (a bug in the validation).
                  if (!this.highlightElementCounts[key] ||
                      allocator.reservedSpace > this.highlightElementCounts[key].length - 1) {
                      // if (this.highlightElementCounts[key] && allocator.reservedSpace > this.highlightElementCounts[key].length - 1) regen = true
                      this.highlightedIdsArray[key] = new Float32Array(allocator.reservedSpace * 4); // one RGBA pixel per drawn geometry.
                      // Note: the +1 here is to avoid an exception thrown on Safari if the offsets and counts are
                      // exactly the size of the number of drawn items. (a bug in the validation).
                      this.highlightElementOffsets[key] = new Int32Array(allocator.reservedSpace + 1);
                      this.highlightElementCounts[key] = new Int32Array(allocator.reservedSpace + 1);
                  }
              }
              const elementSize = 4; //  Uint32Array for UNSIGNED_INT
              for (let key in this.highlightedItems) {
                  const itemIndex = Number.parseInt(key);
                  const subGeomIndices = this.highlightedItems[key];
                  const glGeomItem = this.glGeomItems[itemIndex];
                  const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId);
                  const geomBuffers = this.renderer.glGeomLibrary.getGeomBuffers(glGeomItem.geomId);
                  if (subGeomIndices.length != 0) {
                      // let subIndex = 0
                      subGeomIndices.forEach((subGeomIndex, index) => {
                          const addSubGeom = (offsets, counts, type, subIndex) => {
                              const allocator = this.highlightedIdsArraysAllocators[type];
                              const drawIdsArray = this.highlightedIdsArray[type];
                              const drawElementOffsets = this.highlightElementOffsets[type];
                              const drawElementCounts = this.highlightElementCounts[type];
                              const allocation = allocator.getAllocation(itemIndex);
                              // for (let i = 0; i < offsets.length; i++) {
                              const drawId = allocation.start + index;
                              drawElementOffsets[drawId] = offsetAndCount[0] + offsets[subIndex] * elementSize;
                              drawElementCounts[drawId] = counts[subIndex];
                              drawIdsArray[drawId * 4 + 0] = glGeomItem.geomItemId;
                              drawIdsArray[drawId * 4 + 1] = subGeomIndex + 1;
                              drawIdsArray[drawId * 4 + 2] = 0.0; // materialId
                              drawIdsArray[drawId * 4 + 3] = 0.0; // spare
                          };
                          if (subGeomIndex < geomBuffers.subGeomCounts['TRIANGLES'].length) {
                              addSubGeom(geomBuffers.subGeomOffsets['TRIANGLES'], geomBuffers.subGeomCounts['TRIANGLES'], 'TRIANGLES', subGeomIndex);
                          }
                          else {
                              const linesSubGeomIndex = subGeomIndex - geomBuffers.subGeomCounts['TRIANGLES'].length;
                              if (linesSubGeomIndex < geomBuffers.subGeomCounts['LINES'].length) {
                                  addSubGeom(geomBuffers.subGeomOffsets['LINES'], geomBuffers.subGeomCounts['LINES'], 'LINES', linesSubGeomIndex);
                              }
                              else {
                                  const pointsSubGeomIndex = linesSubGeomIndex - geomBuffers.subGeomCounts['LINES'].length;
                                  if (pointsSubGeomIndex < geomBuffers.subGeomCounts['POINTS'].length) {
                                      addSubGeom(geomBuffers.subGeomOffsets['POINTS'], geomBuffers.subGeomCounts['POINTS'], 'POINTS', pointsSubGeomIndex);
                                  }
                              }
                          }
                      });
                  }
                  else {
                      for (let key in geomBuffers.offsets) {
                          const count = geomBuffers.counts[key];
                          if (count == 0)
                              continue;
                          const offset = geomBuffers.offsets[key];
                          const allocator = this.highlightedIdsArraysAllocators[key];
                          const allocation = allocator.getAllocation(itemIndex);
                          const drawId = allocation.start;
                          this.highlightElementOffsets[key][drawId] = offsetAndCount[0] + offset * elementSize;
                          this.highlightElementCounts[key][drawId] = count;
                          this.highlightedIdsArray[key][drawId * 4 + 0] = glGeomItem.geomItemId;
                      }
                  }
              }
              this.highlightedIdsBufferDirty = false;
          }
          const gl = this.renderer.gl;
          const updateDrawIdsTexture = (key) => {
              const drawIdsArray = this.highlightedIdsArray[key];
              if (!drawIdsArray || drawIdsArray.length == 0)
                  return;
              let drawIdsTexture = this.highlightedIdsTextures[key];
              const reservedSpaceDrawCount = this.highlightedIdsArraysAllocators[key].reservedSpace;
              const unit = renderstate.boundTextures++;
              gl.activeTexture(gl.TEXTURE0 + unit);
              const drawIdsTextureSize = MathFunctions.nextPow2(Math.ceil(Math.sqrt(reservedSpaceDrawCount)));
              if (!drawIdsTexture) {
                  drawIdsTexture = new GLTexture2D(this.gl, {
                      format: 'RGBA',
                      type: 'FLOAT',
                      width: drawIdsTextureSize,
                      height: drawIdsTextureSize,
                      filter: 'NEAREST',
                      wrap: 'CLAMP_TO_EDGE',
                      mipMapped: false,
                  });
                  this.highlightedIdsTextures[key] = drawIdsTexture;
              }
              else if (drawIdsTexture.width < drawIdsTextureSize || drawIdsTexture.height < drawIdsTextureSize) {
                  drawIdsTexture.resize(drawIdsTextureSize, drawIdsTextureSize);
              }
              {
                  const tex = drawIdsTexture;
                  const texWidth = drawIdsTexture.width;
                  gl.bindTexture(gl.TEXTURE_2D, tex.glTex);
                  const level = 0;
                  const xoffset = 0;
                  const height = 1;
                  const format = tex.getFormat();
                  const type = tex.getType();
                  const drawCount = this.highlightedIdsArraysAllocators[key].allocatedSpace;
                  const rows = Math.ceil((xoffset + drawCount) / texWidth);
                  let consumed = 0;
                  let remaining = drawCount;
                  let rowStart = xoffset;
                  for (let i = 0; i < rows; i++) {
                      let width;
                      if (rowStart + remaining > texWidth) {
                          width = texWidth - rowStart;
                          rowStart = 0;
                      }
                      else {
                          width = remaining;
                      }
                      const x = consumed % texWidth;
                      const y = Math.floor(consumed / texWidth);
                      const data = drawIdsArray.subarray(consumed * 4, (consumed + width) * 4);
                      if (data.length != width * 4) {
                          throw new Error('Invalid drawIds subarray :' + data.length + ' width:' + width);
                      }
                      gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data);
                      consumed += width;
                      remaining -= width;
                  }
              }
              gl.bindTexture(gl.TEXTURE_2D, null);
              renderstate.boundTextures--;
          };
          for (let key in this.highlightedIdsArray) {
              // TODO: Only re-upload the dirty items.
              updateDrawIdsTexture(key);
          }
      }
      // ////////////////////////////////////
      // Drawing
      /**
       * The draw method.
       * @param {RenderState} renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.drawOrderToIndex.length == 0) {
              return;
          }
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer(renderstate);
          }
          renderstate.pushGLStack('GLGeomItemSetMultiDrawCompoundGeom.draw');
          const drawIdsArray = this.drawIdsArrays;
          const counts = this.drawElementCounts;
          const offsets = this.drawElementOffsets;
          const drawIdsTextures = this.drawIdsTextures;
          const allocators = this.drawIdsArraysAllocators;
          const gl = this.gl;
          const unifs = renderstate.unifs;
          const depthFuncValue = gl.getParameter(gl.DEPTH_FUNC);
          const { drawIdsTexture, geomType, outlineThickness, viewportSize, occluded, renderMode } = renderstate.unifs;
          const renderModeValue = renderstate instanceof ColorRenderState && renderMode ? renderstate.renderMode : null;
          const drawEdges = renderModeValue != 'flat-noedges' && renderModeValue != 'shaded-noedges' && renderModeValue != 'pbr-noedges';
          const drawingOutlines = renderstate instanceof ColorRenderState &&
              outlineThickness &&
              viewportSize &&
              renderstate.outlineMethod == 'geometry' &&
              renderstate.outlineThickness > 0 &&
              drawEdges;
          const drawingWireframeOutlines = drawingOutlines && renderModeValue == 'wireframe';
          // @ts-ignore
          const drawingHiddenLines = 
          // @ts-ignore
          renderstate.hiddenLineColor &&
              // @ts-ignore
              renderstate.hiddenLineColor.a > 0 &&
              occluded;
          if (drawingWireframeOutlines) {
              gl.enable(gl.STENCIL_TEST);
              gl.clearStencil(0);
              gl.clear(gl.STENCIL_BUFFER_BIT);
              gl.stencilOpSeparate(gl.FRONT, gl.DECR_WRAP, gl.DECR_WRAP, gl.DECR_WRAP);
              gl.stencilOpSeparate(gl.BACK, gl.INCR_WRAP, gl.INCR_WRAP, gl.INCR_WRAP);
              gl.stencilFunc(gl.ALWAYS, 0, 0xff);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.disable(gl.DEPTH_TEST);
              gl.depthMask(false);
              gl.colorMask(false, false, false, false);
          }
          else if (renderModeValue == 'hiddenline') {
              // don't render surfaces. But render alpha channel
              gl.colorMask(false, false, false, true);
          }
          else {
              // Compound Geoms should always be rendered double sided
              // so we can correctly render cutting planes.
              // Note: We needed this because the FlatSurfaceShader turns on culling
              // when it unbinds which then affects the rendering of other items like this.
              // An issue is logged to clean this up.
              // https://github.com/ZeaInc/zea-engine/issues/699
              gl.disable(gl.CULL_FACE);
          }
          if (drawIdsArray['TRIANGLES'] && allocators['TRIANGLES'].allocatedSpace > 0) {
              drawIdsTextures['TRIANGLES'].bindToUniform(renderstate, drawIdsTexture);
              if (geomType)
                  gl.uniform1i(geomType.location, GeomType.TRIANGLES);
              // Always zero this value before drawing the faces, else the shader could think its drawing the outline.
              if (outlineThickness) {
                  gl.uniform1f(outlineThickness.location, 0);
              }
              renderstate.bindViewports(unifs, () => {
                  this.multiDrawMeshes(renderstate, counts['TRIANGLES'], offsets['TRIANGLES'], allocators['TRIANGLES'].allocatedSpace);
              });
              if (drawingOutlines) {
                  // Only draw font faces. BEcause all faces are drawn, it can make a mess to see the back faces through the front faces.
                  // e.g. we might see the triangles on the other side of a sphere rendered over the top of triangles on the near side.
                  gl.enable(gl.CULL_FACE);
                  gl.cullFace(gl.FRONT);
                  gl.uniform1f(outlineThickness.location, this.renderer.outlineThickness * window.devicePixelRatio);
                  gl.uniform2f(viewportSize.location, renderstate.region[2] - renderstate.region[0], renderstate.region[3] - renderstate.region[1]);
                  if (renderModeValue == 'hiddenline') {
                      // start rendering surfaces again
                      gl.colorMask(true, true, true, true);
                  }
                  if (!drawingWireframeOutlines) {
                      renderstate.glEnable(gl.BLEND);
                      gl.blendEquation(gl.FUNC_ADD);
                      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                  }
                  renderstate.bindViewports(unifs, () => {
                      this.multiDrawMeshes(renderstate, counts['TRIANGLES'], offsets['TRIANGLES'], allocators['TRIANGLES'].allocatedSpace);
                  });
                  gl.disable(gl.CULL_FACE);
                  gl.cullFace(gl.BACK);
                  if (drawingWireframeOutlines) {
                      gl.enable(gl.DEPTH_TEST);
                      gl.depthMask(true);
                      gl.colorMask(true, true, true, true);
                      gl.stencilFunc(gl.NOTEQUAL, 0x0, 0xff);
                      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                      {
                          renderstate.glEnable(gl.BLEND);
                          gl.blendEquation(gl.FUNC_ADD);
                          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                      }
                      // cache the previously bound shader.
                      const shader = renderstate.glShader;
                      const shaderKey = renderstate.shaderkey;
                      const screenQuad = this.renderer.screenQuad;
                      screenQuad.bindShader(renderstate);
                      screenQuad.draw(renderstate, this.renderer.outlineColor);
                      // Re-bind the previously bound geomdata shader.
                      shader.bind(renderstate, shaderKey);
                      this.renderer.glGeomItemLibrary.bind(renderstate);
                      this.renderer.glGeomLibrary.bind(renderstate);
                      this.renderer.glMaterialLibrary.bind(renderstate);
                      gl.disable(gl.STENCIL_TEST);
                  }
              }
              else {
                  renderstate.glEnable(gl.BLEND);
                  gl.blendEquation(gl.FUNC_ADD);
                  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
              }
          }
          if (drawEdges && drawIdsArray['LINES'] && allocators['LINES'].allocatedSpace > 0) {
              drawIdsTextures['LINES'].bindToUniform(renderstate, drawIdsTexture);
              if (geomType)
                  gl.uniform1i(geomType.location, GeomType.LINES);
              renderstate.bindViewports(unifs, () => {
                  this.multiDrawLines(renderstate, counts['LINES'], offsets['LINES'], allocators['LINES'].allocatedSpace);
              });
              if (drawingHiddenLines) {
                  const { hiddenLineColor } = renderstate.unifs;
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  renderstate.bindViewports(unifs, () => {
                      this.multiDrawLines(renderstate, counts['LINES'], offsets['LINES'], allocators['LINES'].allocatedSpace);
                  });
                  // Restore defaults.
                  gl.depthFunc(depthFuncValue);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
          if (drawIdsArray['POINTS'] && allocators['POINTS'].allocatedSpace > 0) {
              drawIdsTextures['POINTS'].bindToUniform(renderstate, drawIdsTexture);
              if (geomType)
                  gl.uniform1i(geomType.location, GeomType.POINTS);
              renderstate.bindViewports(unifs, () => {
                  this.multiDrawPoints(renderstate, counts['POINTS'], offsets['POINTS'], allocators['POINTS'].allocatedSpace);
              });
              if (drawingHiddenLines) {
                  const { hiddenLineColor } = renderstate.unifs;
                  gl.uniform1i(occluded.location, 1);
                  // @ts-ignore
                  gl.uniform4fv(hiddenLineColor.location, renderstate.hiddenLineColor.asArray());
                  gl.depthFunc(gl.GREATER);
                  gl.depthMask(false);
                  renderstate.bindViewports(unifs, () => {
                      this.multiDrawPoints(renderstate, counts['POINTS'], offsets['POINTS'], allocators['POINTS'].allocatedSpace);
                  });
                  gl.depthFunc(depthFuncValue);
                  gl.depthMask(true);
                  gl.uniform1i(occluded.location, 0);
              }
          }
          // Reset to drawing triangles in case the shader is used
          // to draw a regular mesh next.
          if (geomType)
              gl.uniform1i(geomType.location, 0);
          renderstate.popGLStack();
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (this.drawIdsBufferDirty) {
              this.updateDrawIDsBuffer(renderstate);
          }
          renderstate.pushGLStack('GLGeomItemSetMultiDrawCompoundGeom.drawGeomData');
          const gl = this.renderer.gl;
          const unifs = renderstate.unifs;
          const { drawIdsTexture, geomType } = unifs;
          const counts = this.drawElementCounts;
          const offsets = this.drawElementOffsets;
          const drawIdsTextures = this.drawIdsTextures;
          const allocators = this.drawIdsArraysAllocators;
          const drawIdsArray = this.drawIdsArrays;
          if (this.renderer.renderMode != 'wireframe') {
              renderstate.bindViewports(unifs, () => {
                  if (drawIdsArray['TRIANGLES'] && allocators['TRIANGLES'].allocatedSpace > 0) {
                      drawIdsTextures['TRIANGLES'].bindToUniform(renderstate, drawIdsTexture);
                      if (geomType)
                          gl.uniform1i(geomType.location, GeomType.TRIANGLES);
                      this.multiDrawMeshes(renderstate, counts['TRIANGLES'], offsets['TRIANGLES'], allocators['TRIANGLES'].allocatedSpace);
                  }
              });
          }
          //  Note: lines in VR are not fattened...
          const enableLineFattening = true;
          if (renderstate.geomDataFbo && enableLineFattening) {
              if (!this.linesGeomDataBuffer) {
                  this.linesGeomDataBuffer = new GLTexture2D(gl, {
                      type: this.renderer.floatGeomBuffer ? 'FLOAT' : 'UNSIGNED_BYTE',
                      format: 'RGBA',
                      filter: 'NEAREST',
                      width: 1,
                      height: 2,
                  });
                  this.fattenLinesShader = new FattenLinesShader(gl);
                  this.quad = new GLMesh(gl, new Plane(1, 1));
              }
              const geomDataFbo = renderstate.geomDataFbo;
              const width = geomDataFbo.width;
              const height = geomDataFbo.height;
              if (this.linesGeomDataBuffer.width != width || this.linesGeomDataBuffer.height != height) {
                  if (this.fbo) {
                      gl.deleteFramebuffer(this.fbo);
                      this.fbo = null;
                  }
                  this.linesGeomDataBuffer.resize(width, height);
                  this.fbo = gl.createFramebuffer();
                  const colorTex = this.linesGeomDataBuffer.glTex;
                  const depthBuffer = geomDataFbo.depthTexture; // Share the existing depth buffer.
                  if (gl.name == 'webgl2') {
                      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo);
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTex, 0);
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthBuffer, 0);
                  }
                  else {
                      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTex, 0);
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthBuffer, 0);
                  }
                  checkFramebuffer(gl, width, height);
              }
              else {
                  if (gl.name == 'webgl2')
                      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo);
                  else
                      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
              }
              gl.colorMask(true, true, true, true);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT); // do not clear depth
          }
          renderstate.bindViewports(unifs, () => {
              if (drawIdsArray['LINES'] && allocators['LINES'].allocatedSpace > 0) {
                  drawIdsTextures['LINES'].bindToUniform(renderstate, drawIdsTexture);
                  if (geomType)
                      gl.uniform1i(geomType.location, GeomType.LINES);
                  // When debugging the lines geomdata buffer, we can enable this line to make lines draw yellow.
                  // const { passId } = renderstate.unifs
                  // if (passId) {
                  //   gl.uniform1i(passId.location, 99)
                  // }
                  this.multiDrawLines(renderstate, counts['LINES'], offsets['LINES'], allocators['LINES'].allocatedSpace);
              }
              if (drawIdsArray['POINTS'] && allocators['POINTS'].allocatedSpace > 0) {
                  drawIdsTextures['POINTS'].bindToUniform(renderstate, drawIdsTexture);
                  if (geomType)
                      gl.uniform1i(geomType.location, GeomType.POINTS);
                  this.multiDrawPoints(renderstate, counts['POINTS'], offsets['POINTS'], allocators['POINTS'].allocatedSpace);
              }
          });
          if (this.linesGeomDataBuffer && renderstate.geomDataFbo && enableLineFattening) {
              renderstate.boundRendertarget = null;
              renderstate.geomDataFbo.bindForWriting(renderstate);
              // cache the previously bound shader.
              const geomDataShader = renderstate.glShader;
              const geomDataShaderKey = renderstate.shaderkey;
              this.fattenLinesShader.bind(renderstate);
              gl.disable(gl.DEPTH_TEST);
              const { colorTexture, screenSize } = renderstate.unifs;
              this.linesGeomDataBuffer.bindToUniform(renderstate, colorTexture);
              const geomDataFbo = renderstate.geomDataFbo;
              gl.uniform2f(screenSize.location, geomDataFbo.width, geomDataFbo.height);
              this.quad.bindAndDraw(renderstate);
              gl.enable(gl.DEPTH_TEST);
              // Re-bind the previously bound geomdata shader.
              geomDataShader.bind(renderstate, geomDataShaderKey);
              this.renderer.glGeomItemLibrary.bind(renderstate);
              this.renderer.glGeomLibrary.bind(renderstate);
              this.renderer.glMaterialLibrary.bind(renderstate);
          }
          renderstate.popGLStack();
      }
      /**
       * The drawHighlighted method.
       * @param {HighlightRenderState} renderstate - The object tracking the current state of the renderer
       */
      drawHighlighted(renderstate) {
          if (Object.keys(this.highlightedItems).length == 0) {
              return;
          }
          if (this.highlightedIdsBufferDirty) {
              this.updateHighlightedIDsBuffer(renderstate);
          }
          renderstate.pushGLStack('GLGeomItemSetMultiDrawCompoundGeom.drawHighlighted');
          const drawIdsArray = this.highlightedIdsArray;
          const counts = this.highlightElementCounts;
          const offsets = this.highlightElementOffsets;
          const drawIdsTextures = this.highlightedIdsTextures;
          const allocators = this.highlightedIdsArraysAllocators;
          const unifs = renderstate.unifs;
          const gl = this.renderer.gl;
          // Compound Geoms should always be rendered double sided
          // so we can correctly render cutting planes.
          // Note: We needed this because the FlatSurfaceShader turns on culling
          // when it unbinds which then affects the rendering of other items like this.
          // An issue is logged to clean this up.
          // https://github.com/ZeaInc/zea-engine/issues/699
          renderstate.glDisable(gl.CULL_FACE);
          const { drawIdsTexture, geomType } = renderstate.unifs;
          renderstate.bindViewports(unifs, () => {
              if (drawIdsArray['TRIANGLES'] && allocators['TRIANGLES'].allocatedSpace > 0) {
                  drawIdsTextures['TRIANGLES'].bindToUniform(renderstate, drawIdsTexture);
                  if (geomType)
                      gl.uniform1i(geomType.location, GeomType.TRIANGLES);
                  this.multiDrawMeshes(renderstate, counts['TRIANGLES'], offsets['TRIANGLES'], allocators['TRIANGLES'].allocatedSpace);
              }
              if (drawIdsArray['LINES'] && allocators['LINES'].allocatedSpace > 0) {
                  drawIdsTextures['LINES'].bindToUniform(renderstate, drawIdsTexture);
                  if (geomType)
                      gl.uniform1i(geomType.location, GeomType.LINES);
                  this.multiDrawLines(renderstate, counts['LINES'], offsets['LINES'], allocators['LINES'].allocatedSpace);
              }
              if (drawIdsArray['POINTS'] && allocators['POINTS'].allocatedSpace > 0) {
                  drawIdsTextures['POINTS'].bindToUniform(renderstate, drawIdsTexture);
                  if (geomType)
                      gl.uniform1i(geomType.location, GeomType.POINTS);
                  this.multiDrawPoints(renderstate, counts['POINTS'], offsets['POINTS'], allocators['POINTS'].allocatedSpace);
              }
          });
          // Reset to drawing triangles in case the shader is used
          // to draw a regular mesh next.
          if (geomType)
              gl.uniform1i(geomType.location, 0);
          renderstate.popGLStack();
      }
      multiDrawMeshes(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          if (gl.multiDrawElements) {
              gl.multiDrawElements(gl.TRIANGLES, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
          }
          else {
              const { drawId } = renderstate.unifs;
              for (let i = 0; i < drawCount; i++) {
                  gl.uniform1i(drawId.location, i);
                  gl.drawElements(gl.TRIANGLES, counts[i], gl.UNSIGNED_INT, offsets[i]);
              }
          }
      }
      multiDrawLines(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          if (gl.multiDrawElements) {
              gl.multiDrawElements(gl.LINES, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
          }
          else {
              const { drawId } = renderstate.unifs;
              for (let i = 0; i < drawCount; i++) {
                  gl.uniform1i(drawId.location, i);
                  gl.drawElements(gl.LINES, counts[i], gl.UNSIGNED_INT, offsets[i]);
              }
          }
      }
      multiDrawPoints(renderstate, counts, offsets, drawCount) {
          const gl = this.gl;
          if (gl.multiDrawElements) {
              gl.multiDrawElements(gl.POINTS, counts, 0, gl.UNSIGNED_INT, offsets, 0, drawCount);
          }
          else {
              const { drawId } = renderstate.unifs;
              for (let i = 0; i < drawCount; i++) {
                  gl.uniform1i(drawId.location, i);
                  gl.drawElements(gl.POINTS, counts[i], gl.UNSIGNED_INT, offsets[i]);
              }
          }
      }
      // /**
      //  * Draw an item to screen.
      //  * @param {RenderState} renderstate - The object tracking the current state of the renderer
      //  * @param {Float32Array} drawIds - the draw id for each element drawn in by this draw call.
      //  * @param {Int32Array} counts - the geom element count for each element drawn in by this draw call.
      //  * @param {Int32Array} offsets - the geom element offset for each element drawn in by this draw call.
      //  * @param {number} drawCount - the number of active draw calls for this invocation
      //  */
      // abstract multiDraw(
      //   renderstate: RenderState,
      //   drawIds: Float32Array,
      //   counts: Int32Array,
      //   offsets: Int32Array,
      //   drawCount: number
      // ): void
      /**
       * Sorts the drawn items in order furthest to nearest when rendering transparent objects.
       * @param {Vec3} viewPos - The position of the camera that we are sorting relative to.
       */
      sortItems(viewPos) {
          if (this.drawIdsBufferDirty) {
              return;
          }
          // The sorting breaks the tellescope dataset is strange ways.
          // disabling for now.
          return;
          /*
          const distances: Float32Array = new Float32Array(this.drawOrderToIndex.length)
          this.drawOrderToIndex.forEach((itemIndex) => {
            const glGeomItem = this.glGeomItems[itemIndex]
            if (glGeomItem) {
              const bbox = glGeomItem.geomItem.boundingBoxParam.value
              // Calculate the disance to the surface of the bounding sphere.
              // TODO: calculate the distance the nearest point on the bounding box.
              const center = bbox.center()
              const size = bbox.size()
              const dist = center.distanceTo(viewPos) - size
      
              distances[itemIndex] = dist
            }
          })
          this.drawOrderToIndex.sort((a, b) => distances[b] - distances[a])
      
          // Now we re-create the drawElementCounts arrays according to the order of the drawn GLGeomItems.
          // Note: We draw the TRIANGLES, then LINES, then POINTS. We can't draw lines behind transparent geoms.
          // We could simply not bother sorting the lines and points.
          const gl = this.gl
          const drawElementCounts: Record<string, Int32Array> = {}
          const drawElementOffsets: Record<string, Int32Array> = {}
          if (this.drawElementCounts.TRIANGLES) {
            drawElementCounts.TRIANGLES = new Int32Array(this.drawElementCounts.TRIANGLES.length + 1)
            drawElementOffsets.TRIANGLES = new Int32Array(this.drawElementOffsets.TRIANGLES.length + 1)
          }
          if (this.drawElementCounts.TRIANGLES) {
            drawElementCounts.LINES = new Int32Array(this.drawElementCounts.LINES.length + 1)
            drawElementOffsets.LINES = new Int32Array(this.drawElementOffsets.LINES.length + 1)
          }
          if (this.drawElementCounts.POINTS) {
            drawElementCounts.POINTS = new Int32Array(this.drawElementCounts.POINTS.length + 1)
            drawElementOffsets.POINTS = new Int32Array(this.drawElementOffsets.POINTS.length + 1)
          }
      
          const drawOffsets: Record<string, number> = {
            TRIANGLES: 0,
            LINES: 0,
            POINTS: 0,
          }
          const elementSize = 4 //  Uint32Array for UNSIGNED_INT
          this.drawOrderToIndex.forEach((itemIndex, drawIndex) => {
            const glGeomItem = this.glGeomItems[itemIndex]
            if (glGeomItem) {
              for (let key in this.drawIdsArraysAllocators) {
                const drawOffset = drawOffsets[key]
                const allocation = this.drawIdsArraysAllocators[key].getAllocation(itemIndex)
                if (!allocation) continue
      
                const geomBuffers = this.renderer.glGeomLibrary.getGeomBuffers(glGeomItem.geomId)
                const offsetAndCount = this.renderer.glGeomLibrary.getGeomOffsetAndCount(glGeomItem.geomId)
                if (allocation.size > 1) {
                  for (let i = 0; i < allocation.size; i++) {
                    const drawId = drawOffset + i
                    drawElementCounts[key][drawId] = glGeomItem.culled ? 0 : geomBuffers.subGeomCounts[key][i]
                    drawElementOffsets[key][drawId] = offsetAndCount[0] + geomBuffers.offsets[key] * elementSize
                  }
                } else {
                  drawElementCounts[key][drawOffset] = glGeomItem.culled ? 0 : geomBuffers.counts[key]
                  drawElementOffsets[key][drawOffset] = offsetAndCount[0] + geomBuffers.offsets[key] * elementSize
                }
                if (!this.indexToOffsets[key]) this.indexToOffsets[key] = []
                this.indexToOffsets[key][itemIndex] = drawOffset
      
                ////////////////////////////////////////
                //
                const drawIdsArray = this.drawIdsArrays[key]
                let drawIdsTexture = this.drawIdsTextures[key]
                const tex = drawIdsTexture
                const texWidth = drawIdsTexture.width
                gl.bindTexture(gl.TEXTURE_2D, tex.glTex)
                const level = 0
                const height = 1
                const format = tex.getFormat()
                const type = tex.getType()
      
                const startSrc = allocation.start
                const startTgt = drawOffset
                const drawCount = allocation.size
      
                const xoffset = startTgt % texWidth
                const rows = Math.ceil((xoffset + drawCount) / texWidth)
                let consumed = 0
                let remaining = drawCount
                let rowStart = xoffset
                for (let i = 0; i < rows; i++) {
                  let width
                  if (rowStart + remaining > texWidth) {
                    width = texWidth - rowStart
                    rowStart = 0
                  } else {
                    width = remaining
                  }
                  const x = (startTgt + consumed) % texWidth
                  const y = Math.floor((startTgt + consumed) / texWidth)
                  const data = drawIdsArray.subarray((startSrc + consumed) * 4, (startSrc + consumed + width) * 4)
                  if (data.length != width * 4) {
                    throw new Error('Invalid drawIds subarray :' + data.length + ' width:' + width)
                  }
                  gl.texSubImage2D(gl.TEXTURE_2D, level, x, y, width, height, format, type, data)
      
                  consumed += width
                  remaining -= width
                }
                drawOffsets[key] += allocation.size
              }
              this.indexToDrawIndex[itemIndex] = drawIndex
            }
          })
          this.drawElementCounts = drawElementCounts
          this.drawElementOffsets = drawElementOffsets
      
          gl.bindTexture(gl.TEXTURE_2D, null)
          */
      }
      /**
       * The destroy is called by the system to cause explicit resources cleanup.
       * Users should never need to call this method directly.
       */
      destroy() {
          for (let key in this.drawIdsTextures) {
              this.drawIdsTextures[key].destroy();
          }
          for (let key in this.highlightedIdsTextures) {
              this.highlightedIdsTextures[key].destroy();
          }
          this.emit('destructing');
      }
  }

  /* eslint-disable guard-for-in */
  /** Class representing GL shader materials.
   * @private
   */
  class GLShaderGeomSets extends EventEmitter {
      renderer;
      gl;
      glShader;
      glGeomItemSets = {};
      /**
       * Create a GL shader material.
       * @param pass - The pass that owns this object.
       * @param gl - The glShader value.
       * @param shaders - The shader value.
       */
      constructor(renderer, gl, glShader) {
          super();
          this.renderer = renderer;
          this.gl = gl;
          this.glShader = glShader;
      }
      /**
       * Given a GeomItem, constructs the GLGeomItemSet that handles drawing that type of geometry.
       * @param geom - The geomitem value.
       * @return - The return value.
       * */
      getOrCreateGLGeomItemSet(geom) {
          let glGeomItemSet;
          if (geom instanceof CompoundGeom) {
              if (this.glGeomItemSets['CompoundGeom'])
                  return this.glGeomItemSets['CompoundGeom'];
              glGeomItemSet = new GLGeomItemSetMultiDrawCompoundGeom(this.renderer);
              this.glGeomItemSets['CompoundGeom'] = glGeomItemSet;
          }
          else if (geom instanceof Mesh || geom instanceof MeshProxy) {
              if (this.glGeomItemSets['GLMesh'])
                  return this.glGeomItemSets['GLMesh'];
              glGeomItemSet = new GLMeshItemSet(this.renderer);
              this.glGeomItemSets['GLMesh'] = glGeomItemSet;
          }
          else if (geom instanceof Lines || geom instanceof LinesProxy) {
              if (this.glGeomItemSets['GLLines'])
                  return this.glGeomItemSets['GLLines'];
              glGeomItemSet = new GLLinesItemSet(this.renderer);
              this.glGeomItemSets['GLLines'] = glGeomItemSet;
          }
          else if (geom instanceof Points || geom instanceof PointsProxy) {
              if (this.glGeomItemSets['GLPoints'])
                  return this.glGeomItemSets['GLPoints'];
              glGeomItemSet = new GLPointsItemSet(this.renderer);
              this.glGeomItemSets['GLPoints'] = glGeomItemSet;
          }
          else {
              throw new Error('Unsupported geom type:' + geom.constructor.name);
          }
          glGeomItemSet.on('updated', () => {
              this.emit('updated');
          });
          return glGeomItemSet;
      }
      /**
       * The addGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       */
      addGLGeomItem(glGeomItem) {
          const geom = glGeomItem.geomItem.geomParam.value;
          const glGeomItemSet = this.getOrCreateGLGeomItemSet(geom);
          glGeomItem.GLGeomItemSet = glGeomItemSet;
          glGeomItemSet.addGLGeomItem(glGeomItem);
      }
      /**
       *  Called by the GLPass to remove an item from this GLShaderGeomSets object.
       * @param glGeomItem - The glGeomItem value.
       */
      removeGLGeomItem(glGeomItem) {
          const glGeomItemSet = glGeomItem.GLGeomItemSet;
          glGeomItemSet.removeGLGeomItem(glGeomItem);
          glGeomItem.GLGeomItemSet = null;
      }
      /**
       * Binds one of its shaders for rendering, and also the other textures and values needed.
       * @param glShader - The shader to bind
       * @param renderstate - The render state for the current draw traversal
       * @param key - The key to use to cache the shader binding.
       * @private
       */
      bindShader(glShader, renderstate, key) {
          const gl = this.gl;
          // to force the re-compliation of a shader with different
          // directives, we supply a different key.
          if (!glShader.isCompiledForTarget(key)) {
              if (gl.multiDrawElements) {
                  renderstate.directives.push('#define ENABLE_MULTI_DRAW\n#extension GL_ANGLE_multi_draw : enable');
              }
              else {
                  renderstate.directives.push('#define ENABLE_MULTI_DRAW');
              }
              glShader.compileForTarget(key, renderstate.directives);
              renderstate.directives.pop();
          }
          if (!glShader.bind(renderstate, key)) {
              throw new Error('Unable to bind shader:' + glShader);
          }
          this.renderer.glGeomItemLibrary.bind(renderstate);
          this.renderer.glGeomLibrary.bind(renderstate);
          this.renderer.glMaterialLibrary.bind(renderstate);
      }
      /**
       * Draws all elements, binding the shader and continuing into the GLGLGeomSetGeomItemSets
       * @param renderstate - The render state for the current draw traversal
       */
      draw(renderstate) {
          this.bindShader(this.glShader, renderstate, 'multidraw-draw');
          for (const elementType in this.glGeomItemSets) {
              this.glGeomItemSets[elementType].draw(renderstate);
          }
          this.glShader.unbind(renderstate);
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) {
          this.bindShader(this.glShader, renderstate, 'multidraw-highlight');
          for (const elementType in this.glGeomItemSets) {
              this.glGeomItemSets[elementType].drawHighlighted(renderstate);
          }
          this.glShader.unbind(renderstate);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          this.bindShader(this.glShader, renderstate, 'multidraw-geomdata');
          const gl = renderstate.gl;
          const { passId } = renderstate.unifs;
          if (passId) {
              gl.uniform1i(passId.location, renderstate.passIndex);
          }
          for (const elementType in this.glGeomItemSets) {
              this.glGeomItemSets[elementType].drawGeomData(renderstate);
          }
          this.glShader.unbind(renderstate);
      }
      /**
       * Sorts the drawn items in order furthest to nearest when rendering transparent objects.
       * @param viewPos - The position of the camera that we are sorting relative to.
       */
      sortItems(viewPos) {
          // Note: sorting here will not sort geometries of different types.
          // this is a flawed solution that only sorts geomemtries of the same
          // time and same shader against each other. Given that this is the data 99% o
          // of the time, this is an acceptable tradeoff
          for (const elementType in this.glGeomItemSets) {
              this.glGeomItemSets[elementType].sortItems(viewPos);
          }
      }
  }

  /* eslint-disable guard-for-in */
  /** Class representing GL material geom item sets.
   * @private
   */
  class GLMaterialGeomItemSets extends EventEmitter {
      pass;
      gl;
      glMaterial;
      glGeomItemSets = new Map();
      listenerIds = {};
      drawCount = 0;
      /**
       * Create a GL material geom item set.
       * @param pass - The pass that owns the GLMaterialGeomItemSets.
       * @param glMaterial - The glMaterial value.
       */
      constructor(pass, glMaterial) {
          super();
          this.pass = pass;
          this.gl = pass.renderer.gl;
          if (glMaterial) {
              this.glMaterial = glMaterial;
              const material = glMaterial.material;
              const opacityChanged = () => {
                  material.off('opacityChanged', opacityChanged);
                  this.glGeomItemSets.forEach((glGeomItemSet) => {
                      for (const glGeomItem of glGeomItemSet.glGeomItems) {
                          const geomItem = glGeomItem.geomItem;
                          this.pass.removeGeomItem(geomItem);
                          this.pass.renderer.assignTreeItemToGLPass(geomItem);
                      }
                  });
              };
              this.listenerIds['material.opacityChanged'] = material.on('opacityChanged', opacityChanged);
          }
      }
      /**
       * The addGLGeomItem method.
       * @param glGeomItem - The glGeomItem value.
       * @param glGeom - The glGeomItem value.
       * @private
       */
      addGLGeomItem(glGeomItem, glGeom) {
          let geomItemSet = this.glGeomItemSets.get(glGeom);
          if (!geomItemSet) {
              geomItemSet = new GLGeomItemSet(this.gl, glGeom);
              this.addGeomItemSet(geomItemSet);
          }
          geomItemSet.addGLGeomItem(glGeomItem);
      }
      /**
       * The drawCountChanged method.
       * @param event - The change value.
       * @private
       */
      drawCountChanged(event) {
          this.drawCount += event.change;
          this.emit('updated');
      }
      /**
       * The addGeomItemSet method.
       * @param glGeomItemSet - The glGeomItemSet value.
       */
      addGeomItemSet(glGeomItemSet) {
          this.glGeomItemSets.set(glGeomItemSet.getGLGeom(), glGeomItemSet);
          const listenerID = glGeomItemSet.on('drawCountChanged', (event) => {
              this.drawCountChanged(event);
          });
          glGeomItemSet.once('destructing', () => {
              glGeomItemSet.off('drawCountChanged', listenerID);
              this.glGeomItemSets.delete(glGeomItemSet.getGLGeom());
              if (this.glGeomItemSets.size == 0 && this.glMaterial) {
                  // Remove the listeners.
                  const material = this.glMaterial.material;
                  material.off('opacityChanged', this.listenerIds['material.opacityChanged']);
                  this.emit('destructing');
              }
          });
      }
      /**
       * Draws all elements, binding the shader and continuing into the GLGeomItemSet
       * @param renderstate - The render state for the current draw traversal
       */
      draw(renderstate) {
          if (this.drawCount == 0)
              return;
          const warnMissingUnifs = true;
          if (this.glMaterial)
              this.glMaterial.bind(renderstate, warnMissingUnifs);
          this.glGeomItemSets.forEach((glGeomItemSet) => {
              glGeomItemSet.draw(renderstate);
          });
          if (this.glMaterial)
              this.glMaterial.unbind(renderstate);
      }
      /**
       * The drawHighlighted method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlighted(renderstate) {
          if (this.glMaterial)
              this.glMaterial.bind(renderstate, false);
          this.glGeomItemSets.forEach((glGeomItemSet) => {
              glGeomItemSet.drawHighlighted(renderstate);
          });
          if (this.glMaterial)
              this.glMaterial.unbind(renderstate);
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (this.glMaterial)
              this.glMaterial.bind(renderstate, false);
          this.glGeomItemSets.forEach((glGeomItemSet) => {
              glGeomItemSet.drawGeomData(renderstate);
          });
          if (this.glMaterial)
              this.glMaterial.unbind(renderstate);
      }
  }

  /** Class representing GL shader materials.
   * @private
   */
  class GLShaderMaterials extends EventEmitter {
      gl;
      pass;
      glShader;
      // to force the re-compliation of a shader with different
      // directives, we supply a different key.
      glShaderKey = '';
      glShaderGeomDataKey = '';
      glShaderHighlightKey = '';
      glMaterialGeomItemSets = new Map();
      /**
       * Create a GL shader material.
       * @param gl - The WebGL Context value.
       * @param pass - The pass that owns this GLShaderMaterials object.
       * @param shaders - The shaders value.
       */
      constructor(gl, pass, glShader) {
          super();
          this.gl = gl;
          this.pass = pass;
          this.glShader = glShader;
          this.glShaderKey = 'draw';
          this.glShaderGeomDataKey = 'geomdata';
          this.glShaderHighlightKey = 'highlight';
      }
      getOrCreateGLMaterialGeomItemSets(key) {
          let glMaterialGeomItemSets = this.glMaterialGeomItemSets.get(key);
          if (!glMaterialGeomItemSets) {
              glMaterialGeomItemSets = new GLMaterialGeomItemSets(this.pass, key);
              this.addMaterialGeomItemSets(key, glMaterialGeomItemSets);
          }
          return glMaterialGeomItemSets;
      }
      addGLGeomItem(glGeomItem, glGeom, glMaterial) {
          // Non textured materails do not need to be bound separately as all the
          // uniform values come from the material texture.
          if (!glMaterial.material.isTextured()) {
              const glMaterialGeomItemSets = this.getOrCreateGLMaterialGeomItemSets(null);
              glMaterialGeomItemSets.addGLGeomItem(glGeomItem, glGeom);
          }
          else {
              const glMaterialGeomItemSets = this.getOrCreateGLMaterialGeomItemSets(glMaterial);
              glMaterialGeomItemSets.addGLGeomItem(glGeomItem, glGeom);
          }
      }
      addMaterialGeomItemSets(glMaterial, glMaterialGeomItemSets) {
          this.glMaterialGeomItemSets.set(glMaterial, glMaterialGeomItemSets);
          const updated = () => {
              this.emit('updated');
          };
          const destructing = () => {
              glMaterialGeomItemSets.off('updated', updated);
              glMaterialGeomItemSets.off('destructing', destructing);
              this.glMaterialGeomItemSets.delete(glMaterial);
              if (this.glMaterialGeomItemSets.size == 0) {
                  // TODO: clean up the shader...
                  this.emit('destructing');
              }
          };
          glMaterialGeomItemSets.on('updated', updated);
          glMaterialGeomItemSets.on('destructing', destructing);
      }
      /**
       * The removeMaterialGeomItemSets method.
       * @param glMaterialGeomItemSets - The glMaterialGeomItemSets value.
       */
      removeMaterialGeomItemSets(glMaterial) {
          this.glMaterialGeomItemSets.delete(glMaterial);
      }
      /**
       * Draws all elements, binding the shader and continuing into the GLMaterialGeomItemSets
       * @param renderstate - The render state for the current draw traversal
       */
      draw(renderstate) {
          const glShader = this.glShader;
          if (!this.glShader.bind(renderstate, this.glShaderKey))
              return;
          this.pass.renderer.glGeomItemLibrary.bind(renderstate);
          this.pass.renderer.glMaterialLibrary.bind(renderstate);
          this.glMaterialGeomItemSets.forEach((glMaterialGeomItemSet) => {
              glMaterialGeomItemSet.draw(renderstate);
          });
          glShader.unbind(renderstate);
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) {
          if (!this.glShader.bind(renderstate, this.glShaderHighlightKey))
              return;
          this.pass.renderer.glGeomItemLibrary.bind(renderstate);
          this.pass.renderer.glMaterialLibrary.bind(renderstate);
          this.glMaterialGeomItemSets.forEach((glMaterialGeomItemSet) => {
              glMaterialGeomItemSet.drawHighlighted(renderstate);
          });
          this.glShader.unbind(renderstate);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (!this.glShader.bind(renderstate, this.glShaderGeomDataKey))
              return;
          this.pass.renderer.glGeomItemLibrary.bind(renderstate);
          this.pass.renderer.glMaterialLibrary.bind(renderstate);
          const gl = this.gl;
          const { passId } = renderstate.unifs;
          if (passId) {
              gl.uniform1i(passId.location, renderstate.passIndex);
          }
          this.glMaterialGeomItemSets.forEach((glMaterialGeomItemSet) => {
              glMaterialGeomItemSet.drawGeomData(renderstate);
          });
          this.glShader.unbind(renderstate);
      }
  }

  var frag$8 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards;\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#endif // DRAW_GEOMDATA\n\nconst int cols_per_instance = 7;\n\nvec4 getHilightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 6);\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int instanceID = int(v_instanceID);\n  vec4 imageColor = texture2D(atlasBillboards, v_texCoord) * v_tint;\n  imageColor.a *= v_alpha;\n  if(imageColor.a < 0.1)\n    discard;\n\n#if defined(DRAW_COLOR)\n  fragColor = imageColor;\n  // fragColor.r = 1.0;\n  // fragColor.a = 1.0;\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, v_instanceID, 0.0, isOrthographic, 0);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHilightColor(instanceID);\n  // Skip unhilighting labels.\n  if(fragColor.r < 0.001 && fragColor.g < 0.001 && fragColor.b < 0.001)\n    discard;\n#endif // DRAW_HIGHLIGHT\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$9 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\nuniform vec4 viewportFrustum;\n\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n// A sorted attribute of instance Ids so we draw from back to front.\ninstancedattribute float instanceIds;\n\nimport 'transpose.glsl'\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards_layout;\nuniform vec4 atlasBillboards_desc;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\nconst int cols_per_instance = 7;\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n  // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 3);\n}\nvec4 getPivot(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 4);\n}\nvec4 getTintColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 5);\n}\n\n#else\n\nuniform vec4 atlasBillboards_desc;\n\nuniform mat4 modelMatrix;\nuniform vec2 pivot;\nuniform vec4 billboardData;\nuniform vec4 tintColor;\nuniform vec4 layoutData;\n\n#endif\n\nuniform int inVR;\n\nmat4 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  // vec3 rr = vec3(sin(roll), 0.0, cos(roll));\n  vec3 rr = vec3(0.0, 0.0, 1.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat4(vec4(uu, 0.0), vec4(vv, 0.0), vec4(ww, 0.0), vec4(origin, 1.0));\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n  int instanceID = int(instanceIds);\n  v_instanceID = float(instanceID) + 0.25;\n\n  mat4 modelMatrix = getModelMatrix(instanceID);\n  vec2 pivot = getPivot(instanceID).xy;\n  vec4 billboardData = getInstanceData(instanceID);\n  vec4 layoutData = fetchTexel(atlasBillboards_layout, int(atlasBillboards_desc.z), int(billboardData.z));\n  v_tint = getTintColor(instanceID);\n\n#else\n\n  v_tint = tintColor;\n\n#endif\n\n  vec2 quadVertex = getQuadVertexPositionFromID();\n  \n  vec2 pos = quadVertex + vec2(0.5, 0.0) - pivot;\n  v_texCoord = vec2(quadVertex.x, -quadVertex.y) + 0.5;\n  v_alpha = billboardData.w;\n  v_texCoord *= layoutData.zw;\n  v_texCoord += layoutData.xy;\n\n  float scl = billboardData.x;\n  float width = layoutData.z * atlasBillboards_desc.x * scl;\n  float height = layoutData.w * atlasBillboards_desc.y * scl;\n  int flags = int(billboardData.y);\n\n  // Use cross platform bit flags methods\n  bool alignedToCamera = testFlag(flags, 4); // flag = 1<<2\n  bool drawOnTop = testFlag(flags, 8); // flag = 1 << 3\n  bool fixedSizeOnscreen = testFlag(flags, 16); // flag = 1 << 4\n\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  // Note: items in front of the camera will have a negative value here.\n  float sc = 1.0;\n  if (fixedSizeOnscreen) {\n    if (isOrthographic > 0){\n      // At a distance of 1, we should match the orthographic and perspective sizes.\n      // Calculate the size of the handle in perpective projection at 1 meter.\n      // With a 24mm camera, the Fov is 46.4 degrees, or 0.8098327729253689 radians.\n      // (0.81 / 2.0) * focalDist * 2.0\n      // The frustum height at 1m is 0.81.\n      sc = viewportFrustum.y / 0.8098327;\n    } else {\n      sc = -modelViewMatrix[3][2];\n      \n      if (inVR == 1) {\n        // During XR sessions, there is a scaling applied to the view matrix\n        // which causes a distortion to the line width. We extract that scale here\n        // and use to correct the distortion.\n        // See also: FatPointsShader\n        vec3 viewZ = modelViewMatrix[2].xyz;\n        float viewScale = length(viewZ);\n        sc /= viewScale;\n      }\n    }\n  }\n  \n  mat4 modelViewProjectionMatrix;\n  if (alignedToCamera) {\n    if (inVR == 0) {\n      gl_Position = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      gl_Position += vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 0.0);\n      v_viewPos = gl_Position.xyz;\n      gl_Position = projectionMatrix * gl_Position;\n    } else {\n      vec3 cameraPos = vec3(cameraMatrix[3][0], cameraMatrix[3][1], cameraMatrix[3][2]);\n      vec3 billboardPos = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n      mat4 lookAt = calcLookAtMatrix(billboardPos, cameraPos, 0.0);\n      mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * lookAt;\n      gl_Position = modelViewProjectionMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0);\n      v_viewPos = (modelViewMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0)).xyz;\n    }\n  }\n  else {\n    modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0);\n    v_viewPos = (modelViewMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0)).xyz;\n  }\n\n  // Use cross platform bit flags methods\n  if (drawOnTop) {\n    if (isOrthographic > 0){\n      gl_Position.z = mix(gl_Position.z, -1.0, 0.5);\n    } else {\n      gl_Position.z = mix(gl_Position.z, -gl_Position.z, 0.5);\n    }\n  }\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class BillboardShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'BillboardShader');
          this.setShaderStage('VERTEX_SHADER', vert$9);
          this.setShaderStage('FRAGMENT_SHADER', frag$8);
      }
  }

  var vert$8 = "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 projectionCenter;\n\nimport 'transpose.glsl'\nimport 'GLSLUtils.glsl'\nimport 'stack-gl/transpose.glsl'\nimport 'stack-gl/inverse.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n \nvoid main()\n{\n  int geomItemId = getGeomItemId();\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n\n  gl_Position = modelViewProjectionMatrix * pos;\n\n  vec4 worldPos = modelMatrix * pos;\n  v_worldDir = worldPos.xyz - projectionCenter;\n}\n\n"; // eslint-disable-line

  var OctahedralEnvProjectionFrag = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'envmap-octahedral.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\nuniform sampler2D envMap;\nuniform int envMapLoaded;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(dir);\n  vec4 texel = texture2D(envMap, vec2(uv.x, 1.0 - uv.y));\n  return vec4(texel.rgb/texel.a, 1.0); // TODO: Check this line. Do we need it?\n}\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  if (envMapLoaded == 0)  {\n    discard;\n    return;\n  }\n\n  fragColor = sampleEnvMap(normalize(v_worldDir));\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  class EnvProjectionShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'EnvProjectionShader');
          this.setShaderStage('VERTEX_SHADER', vert$8);
          this.setShaderStage('FRAGMENT_SHADER', OctahedralEnvProjectionFrag);
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key value.
       * @return - The return value.
       */
      bind(renderstate, key) {
          super.bind(renderstate, key);
          if (renderstate instanceof ColorRenderState) {
              const colorRenderState = renderstate;
              const gl = this.__gl;
              const { envMap, envMapLoaded, exposure } = renderstate.unifs;
              if (colorRenderState.envMap && colorRenderState.envMap.glTex) {
                  // colorRenderState.envMap.bind(colorRenderState)
                  colorRenderState.envMap.glTex.bindToUniform(renderstate, envMap);
                  gl.uniform1i(envMapLoaded.location, 1);
              }
              else {
                  gl.uniform1i(envMapLoaded.location, 0);
              }
              if (exposure) {
                  gl.uniform1f(exposure.location, colorRenderState.exposure);
              }
          }
          return true;
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return false;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$9;
      }
  }
  const material$9 = new EnvProjectionMaterial();
  Registry.register('EnvProjectionShader', EnvProjectionShader);

  var frag$7 = "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform color BaseColor;\nuniform float Opacity;\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'GLSLBits.glsl'\nimport 'geomItemFlags.glsl'\n\nuniform int passId;\n\n#if defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  int geomItemId = int(v_geomItemId + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData  = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (length(planeNormal) > 0.5) {\n      if (cutaway(v_worldPos, planeNormal, planeDist)) {\n          discard;\n          return;\n      }\n    } else {\n      if (testGeometryMask(v_viewPos)) {\n        discard;\n        return;\n      }\n    }\n  }\n\n#if defined(DRAW_COLOR)\n  int debugLevel = 0;\n  if (debugLevel == 0) {\n\n    vec3 viewVector = mat3(cameraMatrix) * normalize(-v_viewPos);\n    vec3 normal = mat3(cameraMatrix) * v_viewNormal;\n    float NdotV = dot(normalize(normal), normalize(viewVector));\n\n    // Modulate the lighting using the texture coord so the line looks round.\n    NdotV *= cos((v_texCoord.x - 0.5) * 2.0);\n\n    vec4 color = BaseColor * NdotV;\n    fragColor = vec4(color.rgb, BaseColor.a * Opacity * treeItemOpacity);\n  }\n  else {\n    fragColor = vec4(v_texCoord.x, 0.0, 0.0, 1.0);\n  }\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n\n  float dist = length(v_viewPos);\n  fragColor.r = float(passId); \n  fragColor.g = float(v_drawItemID);\n  fragColor.b = 0.0;// TODO: store poly-id or something.\n  fragColor.a = dist;\n    \n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_geomItemId);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$7 = "\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec2 segmentIndices;\nattribute float vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform int geomItemId;\nint getGeomItemId() {\n  return geomItemId;\n}\n\nuniform sampler2D positionsTexture;\nuniform int positionsTextureSize;\n\nuniform float LineThickness;\nuniform float Overlay;\n\nimport 'calcFatLinesViewPos.glsl'\n\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\n\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData = getInstanceData(geomItemId);\n\n  int vertexID = int(vertexIDs);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec3 pos;\n  v_viewPos       = calcFatLinesViewPos(vertexID, modelViewMatrix, v_viewNormal, v_texCoord, pos);\n  v_worldPos      = (modelMatrix * vec4(pos, 1.0)).xyz;\n  v_drawItemID    = float(getGeomItemId());\n\n  gl_Position     = projectionMatrix * vec4(v_viewPos, 1.0);\n\n  if (isOrthographic > 0){\n    gl_Position.z -= mix(gl_Position.z, -1.0, Overlay);\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, Overlay);\n  }\n\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** Shader for drawing Fat lines
   * @extends GLShader
   * @private
   */
  class FatLinesShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'FatLinesShader');
          this.setShaderStage('VERTEX_SHADER', vert$7);
          this.setShaderStage('FRAGMENT_SHADER', frag$7);
      }
      bind(renderstate, key) {
          if (super.bind(renderstate, key)) {
              renderstate.supportsInstancing = false;
              return true;
          }
          return false;
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return false;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$8;
      }
  }
  const material$8 = new FatLinesMaterial('FatLinesShader_template');
  Registry.register('FatLinesShader', FatLinesShader);

  var vert$6 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'geomItemFlags.glsl'\nimport 'materialparams.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos = (modelViewMatrix * pos);\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = viewPos.xyz;\n#ifdef ENABLE_TEXTURES\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  //////////////////////////////////////////////\n  // Overlay\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float overlay = materialValue1.x;\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n\n  //////////////////////////////////////////////\n  \n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"; // eslint-disable-line

  var frag$6 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\nimport 'geomItemFlags.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // We can make geoms invisible to hide them. \n  // Avoid drawing GeomData for geoms that are completely transparent.\n  if (treeItemOpacity < 0.001) {\n    discard;\n    return;\n  }\n  \n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (length(planeNormal) > 0.5) {\n      if (cutaway(v_worldPos, planeNormal, planeDist)) {\n          discard;\n          return;\n      }\n    } else {\n      if (testGeometryMask(v_viewPos)) {\n        discard;\n        return;\n      }\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n\n#ifdef ENABLE_TEXTURES\n  getTextureColorValue(baseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif // ENABLE_TEXTURES\n\n  baseColor.a *= treeItemOpacity;\n\n#if defined(DRAW_COLOR)\n\n  //////////////////////////////////////////////\n  fragColor = baseColor;\n\n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (occlusionCulling == 0) {\n    // When not occlusion culling, we don't render non-selectable objects.\n    //When occlusion culling, we want to draw all the geom data for all objects.\n    if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n      discard;\n      return;\n    }\n  }\n  else {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n\n  fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, flags);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemIds.x);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  class FlatSurfaceShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'FlatSurfaceShader');
          this.setShaderStage('VERTEX_SHADER', vert$6);
          this.setShaderStage('FRAGMENT_SHADER', frag$6);
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key value.
       * @return - The return value.
       */
      bind(renderstate, key) {
          super.bind(renderstate, key);
          renderstate.pushGLStack('FlatSurfaceShader.bind');
          // Note: The GLTransparentGeoms pass only  renders the font faces of objects because for complex geoms, this makes sense
          // but flat surfaces should be double sided, as they are almost always labels, or UI elements.
          const gl = this.__gl;
          renderstate.glDisable(gl.CULL_FACE);
          return true;
      }
      /**
       * The unbind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @return - The return value.
       */
      unbind(renderstate) {
          super.unbind(renderstate);
          renderstate.popGLStack();
          return true;
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          const overlayParam = material.getParameter('Overlay');
          if (overlayParam)
              matData[4] = overlayParam.getValue();
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$7;
      }
  }
  const material$7 = new FlatSurfaceMaterial('FlatSurfaceShader_template');
  Registry.register('FlatSurfaceShader', FlatSurfaceShader);

  var vert$5 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'materialparams.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n\n  v_viewPos = viewPos.xyz;\n  gl_Position = projectionMatrix * viewPos;\n\n  //////////////////////////////////////////////\n  // Overlay\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float overlay = materialValue1.y;\n   \n#if defined(DRAW_GEOMDATA)\n  float _overlay = mix(overlay, 1.0, 0.0001);\n#else\n  float _overlay = overlay;\n#endif\n\n  if (isOrthographic > 0){\n    gl_Position.z -= _overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, _overlay);\n  }\n  \n  vec4 pos = vec4(positions, 1.);\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"; // eslint-disable-line

  var frag$5 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'materialparams.glsl'\nimport 'geomItemFlags.glsl'\n\n#if defined(DRAW_COLOR)\n\nuniform int occluded;\nuniform vec4 hiddenLineColor;\n\n#elif defined(DRAW_GEOMDATA)\n\nuniform int isOrthographic;\nimport 'surfaceGeomData.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int geomItemId = int(v_geomItemId + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (length(planeNormal) > 0.5) {\n      if (cutaway(v_worldPos, planeNormal, planeDist)) {\n          discard;\n          return;\n      }\n    } else {\n      if (testGeometryMask(v_viewPos)) {\n        discard;\n        return;\n      }\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 BaseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  vec4 matValue2 = getMaterialValue(materialCoords, 2);\n  float Opacity  = matValue1.r;\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  fragColor = BaseColor;\n  \n  if (occluded == 1) {\n    fragColor = hiddenLineColor;\n  }\n\n  fragColor.a *= Opacity * treeItemOpacity;\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  \n  fragColor = setFragColor_geomData(v_viewPos, v_geomItemId, 0.0, isOrthographic, flags);\n  \n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  fragColor = getHighlightColor(geomItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class LinesShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'LinesShader');
          this.setShaderStage('VERTEX_SHADER', vert$5);
          this.setShaderStage('FRAGMENT_SHADER', frag$5);
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          // Note: By avoiding calling this value 'Opacity', the lines will not be considered 'Transparent'
          // Lines do not need to be depth sorted....
          matData[4] = material.getParameter('Opacity').value;
          matData[5] = material.getParameter('Overlay').value;
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$6;
      }
  }
  const material$6 = new LinesMaterial('LinesShader_template');
  Registry.register('LinesShader', LinesShader);

  var frag$4 = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'materialparams.glsl'\nimport 'geomItemFlags.glsl'\nimport 'surfaceGeomData.glsl'\n\n#if defined(DRAW_GEOMDATA)\n\nimport 'GLSLBits.glsl'\nuniform highp int isOrthographic;\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n/* VS Outputs */\nvarying vec2 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize     = baseColor.a * matValue1.r;\n  float overlay       = matValue1.g;\n\n  fragColor = baseColor;\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n\n  fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, 0);\n\n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  fragColor = getHighlightColor(geomItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert$4 = "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'materialparams.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n/* VS Outputs */\nvarying vec2 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_drawItemIds.x = float(geomItemId);\n  v_drawItemIds.y = float(gl_VertexID);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n  gl_Position = projectionMatrix * viewPos;\n  \n\n  //////////////////////////////////////////////\n  // Material\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize = materialValue1.x;\n  float overlay = materialValue1.y;\n\n  //////////////////////////////////////////////\n\n  // Note: as of 22/01/2021 gl_PointSize has stopped working again...\n  // It is working again now in Chrome\n  gl_PointSize = pointSize * 1.0 / length(viewPos.xyz);\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n  \n  v_viewPos = -viewPos.xyz;\n}\n"; // eslint-disable-line

  class PointsShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'PointsShader');
          this.setShaderStage('VERTEX_SHADER', vert$4);
          this.setShaderStage('FRAGMENT_SHADER', frag$4);
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          matData[4] = material.getParameter('PointSize').value;
          matData[5] = material.getParameter('Overlay').value;
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$5;
      }
  }
  const material$5 = new PointsMaterial('PointsShader_template');
  Registry.register('PointsShader', PointsShader);

  var vert$3 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\ninstancedattribute int drawIndices;\nuniform sampler2D pointsAttributes;\nuniform int texelsPerPoint;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'GLSLUtils.glsl' \nimport 'inverse.glsl'\nimport 'drawItemTexture.glsl'\nimport 'geomItemId.glsl'\nimport 'modelMatrix.glsl'\nimport 'quadVertexFromID.glsl'\nimport 'materialparams.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_texCoord;\nvarying vec3 v_viewPos;\nvarying vec4 v_color;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  vec2 quadPointPos = getQuadVertexPositionFromID();\n  v_texCoord.xy = vec2(quadPointPos.x, -quadPointPos.y) + 0.5;\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  ivec2 texSize = textureSize(pointsAttributes, 0);\n  int texelIndex = drawIndices * texelsPerPoint;\n  ivec2 texelCoord = ivec2(\n    texelIndex % texSize.x, \n    texelIndex / texSize.x\n  );\n  vec4 texel0 = texelFetch(pointsAttributes, texelCoord, 0);\n\n  vec3 pos = texel0.xyz;\n  float size = texel0.w;\n\n  if (texelsPerPoint >= 2) {\n    vec4 texel1 = texelFetch(pointsAttributes, ivec2(texelCoord.x + 1, texelCoord.y), 0);\n    v_color = texel1;\n  } else {\n    v_color = vec4(1., 1., 1., 1.);\n  }\n\n  if (texelsPerPoint >= 3) {\n    vec4 texel2 = texelFetch(pointsAttributes, ivec2(texelCoord.x + 2, texelCoord.y), 0);\n    v_texCoord.z = texel2.x;\n  } else {\n    v_texCoord.z = -1.0;\n  }\n  \n  //////////////////////////////////////////////\n  // Material\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize = materialValue1.r * size;\n  float overlay = materialValue1.b;\n\n  vec4 viewPos = modelViewMatrix * vec4(pos, 1.0);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatLinesShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n  viewPos += vec4(vec3(quadPointPos, 0.0) * pointSize * viewScale, 0.);\n\n  // Generate a quad which is 0.5 * PointSize closer towards\n  // us. This allows points to be visualized even if snug on \n  // a surface. (else they get fully clipped)\n  viewPos.z += 0.5 * pointSize;\n\n  v_drawItemIds.x = float(geomItemId);\n  v_drawItemIds.y = float(drawIndices);\n  v_viewPos = -viewPos.xyz;\n  \n  gl_Position = projectionMatrix * viewPos;\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n}\n"; // eslint-disable-line

  var frag$3 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'constants.glsl'\nimport 'GLSLUtils.glsl'\nimport 'materialparams.glsl'\n\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\nuniform int highlightSubIndex;\n\nuniform sampler2D atlasSprites;\nuniform sampler2D atlasSprites_layout;\nuniform vec4 atlasSprites_desc;\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_texCoord;\nvarying vec3 v_viewPos;\nvarying vec4 v_color;\n\nvec4 sampleSpriteAtlas(int spriteCoord) {\n  ivec2 atlasSpritesSize = textureSize(atlasSprites_layout, 0);\n  // round to an integer, and avoid floating point issues by adding a small value\n  ivec2 texelCoord = ivec2(\n    spriteCoord % atlasSpritesSize.x, \n    spriteCoord / atlasSpritesSize.x\n  );\n  vec4 layoutData = fetchTexel(atlasSprites_layout, atlasSpritesSize, spriteCoord);\n  vec2 spriteTexCoord = v_texCoord.xy;\n  spriteTexCoord *= layoutData.zw;\n  spriteTexCoord += layoutData.xy;\n  return texture2D(atlasSprites, spriteTexCoord);\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n#if defined(DRAW_COLOR)\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize     = matValue1.r;\n  float borderWidth   = matValue1.g;\n\n  if (v_texCoord.z > -0.5) {\n    int spriteCoord = int(v_texCoord.z + 0.1);\n    baseColor = sampleSpriteAtlas(spriteCoord) * v_color;\n    if (baseColor.a < 0.0001) discard;\n  } else {\n    \n    float dist = length(v_texCoord.xy - 0.5);\n    if (dist > 0.5) discard;\n\n    if (dist > 0.5 - (borderWidth * 0.5))\n      baseColor = vec4(0.,0.,0.,1.);\n    else {\n      baseColor = baseColor * v_color;\n      ivec2 texSize = textureSize(BaseColorTex, 0);\n      if (texSize.x == 1 && texSize.y > 1) {\n        vec4 gradient = texture2D(BaseColorTex, vec2(0.5, dist * 2.0));\n        baseColor *= gradient;\n      }\n    }\n  }\n\n  fragColor = baseColor;\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, 0);\n#elif defined(DRAW_HIGHLIGHT)\n  if (highlightSubIndex != -1 && int(v_drawItemIds.y + 0.5) != highlightSubIndex) discard;\n  fragColor = setFragColor_highlight(v_drawItemIds.x);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  class FatPointsShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'FatPointsShader');
          this.setShaderStage('VERTEX_SHADER', vert$3);
          this.setShaderStage('FRAGMENT_SHADER', frag$3);
      }
      bind(renderstate, key) {
          if (super.bind(renderstate, key)) {
              renderstate.supportsInstancing = false;
              const gl = this.__gl;
              if (!gl.__quadVertexIdsBuffer)
                  gl.setupInstancedQuad();
              renderstate.shaderInstancedGeom = {
                  attrBuffers: gl.__quadattrbuffers,
                  indexBuffer: gl.__quadIndexBuffer,
                  indexDataType: gl.UNSIGNED_BYTE,
                  numVertices: 4,
                  numTriIndices: 6,
              };
              renderstate.supportsInstancing = false;
              return true;
          }
          return false;
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          matData[4] = material.getParameter('PointSize').value;
          matData[5] = material.getParameter('BorderWidth').value;
          matData[6] = material.getParameter('Overlay').value;
          return matData;
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return false;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$4;
      }
  }
  const material$4 = new FatPointsMaterial('FatPointsShader_template');
  Registry.register('FatPointsShader', FatPointsShader);

  var frag$2 = "precision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\nimport 'geomItemFlags.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\n\n#if defined(DRAW_COLOR)\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\nuniform sampler2D OpacityTex;\nuniform int OpacityTexType;\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n#endif // ENABLE_TEXTURES\n\nimport 'computeViewNormal.glsl'\n  \n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int elemId = int(v_drawItemIds.y + 0.5);\n  int perFaceMaterialId = int(v_drawItemIds.z);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // We can make geoms invisible to hide them. \n  // Avoid drawing GeomData for geoms that are completely transparent.\n  if (treeItemOpacity < 0.001 && !testFlag(flags, GEOMITEM_MASK)) {\n    discard;\n    return;\n  }\n  \n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (length(planeNormal) > 0.5) {\n      if (cutaway(v_worldPos, planeNormal, planeDist)) {\n          discard;\n          return;\n      }\n    } else {\n      if (testGeometryMask(v_viewPos)) {\n        discard;\n        return;\n      }\n    }\n  }\n\n#if defined(DRAW_COLOR)\n\n  //////////////////////////////////////////////\n  // Normals\n  \n  vec3 viewNormal;\n  if (length(v_viewNormal) < 0.1) {\n    viewNormal = computeViewNormal(v_viewPos);\n  } else {\n    viewNormal = normalize(v_viewNormal);\n  }\n  vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n  \n  vec3 viewVector;\n  if (isOrthographic == 0)\n    viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n  else \n    viewVector = vec3(-cameraMatrix[2][0], -cameraMatrix[2][1], -cameraMatrix[2][2]);\n  \n  //////////////////////////////////////////////\n  // Material\n\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  vec4 baseColor      = getMaterialValue(materialCoords, 0);\n  vec4 matValue1      = getMaterialValue(materialCoords, 1);\n  float opacity       = baseColor.a * matValue1.r;\n  float emission      = matValue1.g;\n\n#ifdef ENABLE_TEXTURES\n  getTextureColorValue(baseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  getTextureLuminanceValue(opacity, OpacityTex, OpacityTexType, v_textureCoord);\n  getTextureLuminanceValue(emission, EmissiveStrengthTex, EmissiveStrengthTexType, v_textureCoord);\n#endif\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY) && !gl_FrontFacing) {\n    fragColor = baseColor;\n  } else {\n    // Hacky simple irradiance. \n    float ndotv = dot(normal, viewVector);\n    if (ndotv < 0.0) {\n      normal = -normal;\n      ndotv = dot(normal, viewVector);\n\n      // Note: these 2 lines can be used to debug inverted meshes.\n      //baseColor = vec4(1.0, 0.0, 0.0, 1.0);\n      //ndotv = 1.0;\n    }\n\n    fragColor = vec4((ndotv * baseColor.rgb) + (emission * baseColor.rgb), opacity);\n  }\n\n  // Note: the 'treeItemOpacity' is not an input to the lighting, \n  // as we want to also blend off the specular reflections to make an object\n  // fade away to nothing. (not become a transparent glass object).\n  fragColor.a *= treeItemOpacity;\n\n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (occlusionCulling == 0) {\n    // When not occlusion culling, we don't render non-selectable objects.\n    //When occlusion culling, we want to draw all the geom data for all objects.\n    if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n      discard;\n      return;\n    }\n  }\n  else {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n  \n  fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, flags);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemIds.x);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}"; // eslint-disable-line

  var vert$2 = "precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewPos       = -viewPos.xyz;\n  v_viewNormal    = normalMatrix * normals; // Note: we normalize in the fragment shader.\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** A simple shader with no support for PBR or textures
   * @ignore
   */
  class SimpleSurfaceShader extends GLShader {
      /**
       * Create a SimpleSurfaceShader
       * @param gl - gl context
       */
      constructor(gl) {
          super(gl, 'SimpleSurfaceShader');
          this.setShaderStage('VERTEX_SHADER', vert$2);
          this.setShaderStage('FRAGMENT_SHADER', frag$2);
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          matData[4] = material.getParameter('Opacity').value;
          matData[5] = material.getParameter('EmissiveStrength').value;
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$3;
      }
  }
  const material$3 = new SimpleSurfaceMaterial('SimpleSurfaceShader_template');
  Registry.register('SimpleSurfaceShader', SimpleSurfaceShader);

  var vert$1 = "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n// Now that we render multiple types of geometry from a single shader\n// we need to know what kind of geometry it is...\nuniform int geomType;\n\nuniform float outlineThickness;\nuniform vec2 viewportSize;\n\n// should be imported by bottom 3\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\n\nimport 'geomItemId.glsl'\nimport 'geomType.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'geomItemFlags.glsl'\nimport 'materialparams.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#if defined(DRAW_COLOR)\n#elif defined(DRAW_GEOMDATA)\n#elif defined(DRAW_HIGHLIGHT)\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData = getInstanceData(geomItemId);\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n  v_viewPos       = -viewPos.xyz;\n  v_worldPos      = (modelMatrix * pos).xyz;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewNormal    = normalMatrix * normals; // Note: we normalize in the fragment shader.\n  \n  // offset slightly the lines and points to make them clearly defined.\n  // This ensures that lines drawn over surfaces are solid and not clipped\n  // at all by the surface.\n  if (geomType == TRIANGLES) {\n    if (outlineThickness > 0.00001) {\n      vec2 screenNormal = v_viewNormal.xy;\n      gl_Position.xy += normalize(screenNormal) * ((2.0 / viewportSize) * outlineThickness) * gl_Position.w;\n    }\n  }\n  \n  //////////////////////////////////////////////\n  // Overlay\n  float viewDepth = v_viewPos.z;\n    \n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue2 = getMaterialValue(materialCoords, 2);\n  vec4 materialValue5 = getMaterialValue(materialCoords, 5);\n  float overlay = materialValue2.b;\n  float pointSize = materialValue5.r;\n\n  if (geomType == TRIANGLES) {\n  }\n  else if (geomType == LINES) { // start 'LINES'\n  // Note: this value has been determined to be the smallest possible value\n  // that still makes the lines render over faces consistently\n    overlay += 0.000001 / viewDepth;\n  } // end 'LINES'\n  else if (geomType == POINTS) { // start 'POINTS'\n    // Fixed size on screen points.\n    gl_PointSize = pointSize;\n    overlay += 0.000005 / viewDepth;\n  }  // end 'POINTS'\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n}\n"; // eslint-disable-line

  var frag$1 = "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl' \nimport 'cutaways.glsl'\nimport 'geometryMask.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\nimport 'GLSLBits.glsl'\nimport 'geomItemFlags.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n// Now that we render multiple types of geometry from a single shader\n// we need to know what kind of geometry it is...\nuniform int geomType;\nimport 'geomType.glsl'\n\nuniform int isOrthographic;\n\n#if defined(DRAW_COLOR)\n\nuniform int renderMode;\nuniform int occluded;\nuniform float outlineThickness;\nuniform vec4 hiddenLineColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n\nuniform sampler2D AmbientOcclusionTex;\nuniform int AmbientOcclusionTexType;\n\n#ifdef ENABLE_PBR\nuniform sampler2D RoughnessTex;\nuniform int RoughnessTexType;\n\nuniform sampler2D MetallicTex;\nuniform int MetallicTexType;\n\nuniform sampler2D ReflectanceTex;\nuniform int ReflectanceTexType;\n\nuniform sampler2D NormalTex;\nuniform int NormalTexType;\n#endif // ENABLE_PBR\n\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n\n#endif // ENABLE_TEXTURES\n\nimport 'PBRSurfaceRadiance.glsl'\n\n#ifdef ENABLE_PBR\nmat3 cotangentFrame( in vec3 normal, in vec3 pos, in vec2 texCoord ) {\n  // https://stackoverflow.com/questions/5255806/how-to-calculate-tangent-and-binormal\n  vec3 n = normal;\n  // derivations of the fragment position\n  vec3 pos_dx = dFdx( pos );\n  vec3 pos_dy = dFdy( pos );\n  // derivations of the texture coordinate\n  vec2 texC_dx = dFdx( texCoord );\n  vec2 texC_dy = dFdy( texCoord );\n  // tangent vector and binormal vector\n  vec3 t = -(texC_dy.y * pos_dx - texC_dx.y * pos_dy);\n  vec3 b = -(texC_dx.x * pos_dy - texC_dy.x * pos_dx);\n\n  t = t - n * dot( t, n ); // orthonormalization ot the tangent vectors\n  b = b - n * dot( b, n ); // orthonormalization of the binormal vectors to the normal vector\n  b = b - t * dot( b, t ); // orthonormalization of the binormal vectors to the tangent vector\n  mat3 tbn = mat3( normalize(t), normalize(b), n );\n\n  return tbn;\n}\n#endif\n\nimport 'computeViewNormal.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n\nimport 'surfaceGeomData.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\nimport 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n  #ifndef ENABLE_ES3\n    vec4 fragColor;\n  #endif\n  \n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int elemId = int(v_drawItemIds.y + 0.5);\n  int perFaceMaterialId = int(v_drawItemIds.z);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // We can make geoms invisible to hide them. \n  // Avoid drawing GeomData for geoms that are completely transparent.\n  if (treeItemOpacity < 0.001) {\n    discard;\n    return;\n  }\n  \n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (length(planeNormal) > 0.5) {\n      if (cutaway(v_worldPos, planeNormal, planeDist)) {\n          discard;\n          return;\n      }\n    } else {\n      if (testGeometryMask(v_viewPos)) {\n        discard;\n        return;\n      }\n    }\n  }\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  \n#if defined(DRAW_COLOR)\n\n  if (geomType == TRIANGLES) { // start 'TRIANGLES'\n\n    //////////////////////////////////////////////\n    // Normals\n    vec3 viewNormal;\n    if (length(v_viewNormal) < 0.1) {\n      viewNormal = computeViewNormal(v_viewPos);\n    } else {\n      viewNormal = normalize(v_viewNormal);\n    }\n    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n    \n    vec3 viewVector;\n    if (isOrthographic == 0)\n      viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n    else \n      viewVector = vec3(cameraMatrix[2][0], cameraMatrix[2][1], cameraMatrix[2][2]);\n      \n    if (dot(normal, viewVector) < 0.0) {\n      normal = -normal;\n      // Note: this line can be used to debug inverted meshes.\n      //material.baseColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    //////////////////////////////////////////////\n    // Material\n\n    MaterialParams material;\n\n    vec4 matValue0      = getMaterialValue(materialCoords, 0);\n    vec4 matValue1      = getMaterialValue(materialCoords, 1);\n    vec4 matValue2      = getMaterialValue(materialCoords, 2);\n\n    vec4 baseColor = matValue0;\n    float opacity = matValue2.g;\n    material.baseColor     = baseColor.rgb;\n    material.ambientOcclusion = matValue1.r;\n    material.metallic      = matValue1.g;\n    material.roughness     = matValue1.b;\n    material.reflectance   = matValue1.a;\n\n    material.emission      = matValue2.r;\n    material.opacity       = opacity * baseColor.a;\n\n#ifdef ENABLE_TEXTURES\n\n    // Planar YZ projection for texturing, repeating every meter.\n    // vec2 texCoord       = v_worldPos.xz * 0.2;\n    vec2 texCoord          = v_textureCoord;\n\n    getTextureColorValue(baseColor, BaseColorTex, BaseColorTexType, texCoord);\n    getTextureLuminanceValue(material.ambientOcclusion, AmbientOcclusionTex, AmbientOcclusionTexType, texCoord);\n    \n    material.baseColor     = baseColor.rgb;\n    material.opacity       = opacity * baseColor.a;\n\n#ifdef ENABLE_PBR\n\n    getTextureLuminanceValue(material.metallic, MetallicTex, MetallicTexType, texCoord);\n    getTextureLuminanceValue(material.roughness, RoughnessTex, RoughnessTexType, texCoord);\n\n    // TODO: Communicate that this tex contains the roughness as well.\n    if (MetallicTexType != 0) {\n      vec4 metallicRoughness = texture2D(MetallicTex, texCoord);\n      material.roughness = metallicRoughness.g;\n      material.metallic = metallicRoughness.b;\n    }\n\n    getTextureLuminanceValue(material.reflectance, ReflectanceTex, ReflectanceTexType, texCoord);\n#endif // ENABLE_PBR\n\n    getTextureLuminanceValue(material.emission, EmissiveStrengthTex, EmissiveStrengthTexType, texCoord);\n#endif // ENABLE_TEXTURES\n\n#ifdef ENABLE_TEXTURES\n#ifdef ENABLE_PBR\n    if (NormalTexType != 0) {\n      mat3 tbn = cotangentFrame(normal, viewVector, texCoord);\n      normal = normalize(tbn * (texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0));\n    }\n#endif // ENABLE_PBR\n#endif // ENABLE_TEXTURES\n\n    if (outlineThickness > 0.00001) {\n      vec4 edgeColor      = getMaterialValue(materialCoords, 3);\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      float opacity       = matValue2.g;\n\n      edgeColor.a = edgeColor.a * opacity * treeItemOpacity;\n      \n      fragColor = edgeColor;\n    } else {\n      \n      if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY) && !gl_FrontFacing) {\n        fragColor = vec4(material.baseColor, material.opacity);\n      }\n      else if (renderMode == 1) { // Flat\n        fragColor = vec4(material.baseColor, material.opacity);\n      } else if (renderMode == 2) { // Shaded\n        // simple irradiance. \n        float ndotv = dot(normal, viewVector);\n        fragColor = vec4((ndotv * material.baseColor) + (material.emission * material.baseColor), material.opacity);\n      } else if (renderMode == 3) { // PBR\n        fragColor = pbrSurfaceRadiance(material, normal, viewVector);\n      }\n      \n      // Note: the 'treeItemOpacity' is not an input to the PBR lighting, \n      // as we want to also blend off the specular reflections to make an object\n      // fade away to nothing. (not become a transparent glass object).\n      fragColor.a *= treeItemOpacity;\n\n      // Debugging code to help understand what might be happening in the shader.\n      // fragColor = vec4(texture2D(NormalTex, texCoord).rgb, 1.0);\n      // fragColor = metallicRoughness;\n      // fragColor = vec4(material.baseColor, 1.0);;\n      // fragColor = vec4(vec3(material.metallic), 1.0);;\n      // fragColor = vec4(vec3(material.roughness), 1.0);;\n      // fragColor = vec4(vec3(material.ambientOcclusion), 1.0);\n    }\n\n  } // end 'TRIANGLES'\n  else if (geomType == LINES) { // start 'LINES'\n    if (occluded == 1) {\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      float opacity       = matValue2.g;\n      fragColor = hiddenLineColor;\n      fragColor.a = hiddenLineColor.a * opacity * treeItemOpacity;\n    } else {\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      vec4 edgeColor      = getMaterialValue(materialCoords, 3);\n      float opacity       = matValue2.g;\n      float edgeWeight    = matValue2.a;\n      edgeColor.a = edgeColor.a * edgeWeight * opacity * treeItemOpacity;\n      fragColor = edgeColor;\n    }\n  } // end 'LINES'\n  else if (geomType == POINTS) { // start 'POINTS'\n    vec4 pointColor     = getMaterialValue(materialCoords, 4);\n    vec4 matValue2      = getMaterialValue(materialCoords, 2);\n    float opacity       = matValue2.g;\n    pointColor.a = pointColor.a * opacity * treeItemOpacity;\n    fragColor = pointColor;\n  }  // end 'POINTS'\n  \n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n  if (occlusionCulling == 0) {\n    // When not occlusion culling, we don't render non-selectable objects.\n    //When occlusion culling, we want to draw all the geom data for all objects.\n    if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n      discard;\n      return;\n    }\n  }\n  else {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n\n  fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, flags);\n   \n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHighlightColor(geomItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n\n}"; // eslint-disable-line

  /* eslint-disable require-jsdoc */
  /** A standard shader handling Opaque and transparent items and PBR rendering.
   * @extends GLShader
   * @private
   */
  class StandardSurfaceShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'StandardSuraceShader');
          this.setShaderStage('VERTEX_SHADER', vert$1);
          this.setShaderStage('FRAGMENT_SHADER', frag$1);
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key value.
       * @return - The return value.
       */
      bind(renderstate, key) {
          super.bind(renderstate, key);
          if (renderstate instanceof ColorRenderState) {
              const colorRenderState = renderstate;
              const gl = this.__gl;
              if (colorRenderState.envMap) {
                  colorRenderState.envMap.bind(colorRenderState);
              }
              const { exposure, renderMode } = colorRenderState.unifs;
              if (exposure) {
                  gl.uniform1f(exposure.location, colorRenderState.exposure);
              }
              if (colorRenderState.renderMode && renderMode) {
                  if (colorRenderState.renderMode == 'flat' || colorRenderState.renderMode == 'flat-noedges') {
                      gl.uniform1i(renderMode.location, 1);
                  }
                  else if (colorRenderState.renderMode == 'shaded' || colorRenderState.renderMode == 'shaded-noedges') {
                      gl.uniform1i(renderMode.location, 2);
                  }
                  else if (colorRenderState.renderMode == 'pbr' || colorRenderState.renderMode == 'pbr-noedges') {
                      gl.uniform1i(renderMode.location, 3);
                  }
              }
          }
          return true;
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(24);
          const baseColorParam = material.getParameter('BaseColor');
          let baseColor;
          if (baseColorParam instanceof MaterialColorParam && baseColorParam.colorSpace == exports.ColorSpace.Gamma) {
              baseColor = baseColorParam.value.toLinear();
          }
          else {
              baseColor = baseColorParam.value;
          }
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          matData[4] = material.getParameter('AmbientOcclusion').value;
          matData[5] = material.getParameter('Metallic').value;
          matData[6] = material.getParameter('Roughness').value;
          matData[7] = material.getParameter('Reflectance').value;
          matData[8] = material.getParameter('EmissiveStrength').value;
          matData[9] = material.getParameter('Opacity').value;
          matData[10] = material.getParameter('Overlay').value;
          matData[11] = material.getParameter('EdgeWeight').value;
          const edgeColor = material.getParameter('EdgeColor').value;
          matData[12] = edgeColor.r;
          matData[13] = edgeColor.g;
          matData[14] = edgeColor.b;
          matData[15] = edgeColor.a;
          const pointColor = material.getParameter('PointColor').value;
          matData[16] = pointColor.r;
          matData[17] = pointColor.g;
          matData[18] = pointColor.b;
          matData[19] = pointColor.a;
          matData[20] = material.getParameter('PointSize').value;
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$2;
      }
  }
  const material$2 = new StandardSurfaceMaterial('StandardSurfaceShader_template');
  Registry.register('StandardSurfaceShader', StandardSurfaceShader);
  Registry.register('TransparentSurfaceShader', StandardSurfaceShader);

  /* eslint-disable require-jsdoc */
  /** A simple shader with no support for PBR or textures
   * @ignore
   */
  class VertexColorShader extends GLShader {
      /**
       * Create a VertexColorShader
       * @param gl - gl context
       */
      constructor(gl) {
          super(gl, 'VertexColorShader');
          this.setShaderStage('VERTEX_SHADER', `precision highp float;


    attribute vec3 positions;
    attribute vec3 normals;
    #ifdef ENABLE_TEXTURES
    attribute vec2 texCoords;
    #endif
    attribute vec4 colors;
    
    uniform mat4 viewMatrix;
    uniform mat4 projectionMatrix;
    
    import 'GLSLUtils.glsl'
    import 'transpose.glsl'
    import 'inverse.glsl'
    import 'geomItemId.glsl'
    import 'drawItemTexture.glsl'
    import 'modelMatrix.glsl'
    
    /* VS Outputs */
    varying vec4 v_drawItemIds;
    varying vec4 v_geomItemData;
    varying vec3 v_viewPos;
    varying vec3 v_viewNormal;
    varying vec4 v_vertexColors;
    #ifdef ENABLE_TEXTURES
    varying vec2 v_textureCoord;
    #endif
    varying vec3 v_worldPos;
    
    void main(void) {
      v_drawItemIds = getDrawItemIds();
      int geomItemId = int(v_drawItemIds.x + 0.5);
      v_geomItemData  = getInstanceData(geomItemId);
      v_vertexColors = colors;
      
      mat4 modelMatrix = getModelMatrix(geomItemId);
      mat4 modelViewMatrix = viewMatrix * modelMatrix;
    
      vec4 pos = vec4(positions, 1.);
      vec4 viewPos    = modelViewMatrix * pos;
      gl_Position     = projectionMatrix * viewPos;
    
      mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));
      v_viewPos       = -viewPos.xyz;
      v_viewNormal    = normalMatrix * normals; // Note: we normalize in the fragment shader.
    
    #ifdef ENABLE_TEXTURES
      v_textureCoord  = texCoords;
      // v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y
    #endif
    
      v_worldPos      = (modelMatrix * pos).xyz;
    }
    `);
          this.setShaderStage('FRAGMENT_SHADER', `precision highp float;

    import 'GLSLUtils.glsl'
    import 'drawItemTexture.glsl'
    import 'cutaways.glsl'
    import 'geometryMask.glsl'
    import 'gamma.glsl'
    import 'materialparams.glsl'
    import 'geomItemFlags.glsl'
    
    #ifdef DEBUG_GEOM_ID
    import 'debugColors.glsl'
    #endif
    
    /* VS Outputs */
    varying vec4 v_drawItemIds;
    varying vec4 v_geomItemData;
    varying vec3 v_viewPos;
    varying vec3 v_viewNormal;
    varying vec4 v_vertexColors;
    #ifdef ENABLE_TEXTURES
    varying vec2 v_textureCoord;
    #endif
    varying vec3 v_worldPos;
    /* VS Outputs */
    
    uniform mat4 cameraMatrix;
    uniform int isOrthographic;
    
    #ifdef ENABLE_ES3
        out vec4 fragColor;
    #endif
    
    
    #if defined(DRAW_COLOR)
    
    import 'computeViewNormal.glsl'
      
    // end DRAW_COLOR
    #elif defined(DRAW_GEOMDATA)
      import 'surfaceGeomData.glsl'
    #elif defined(DRAW_HIGHLIGHT)
      import 'surfaceHighlight.glsl'
    #endif // DRAW_HIGHLIGHT
    
    
    void main(void) {
    #ifndef ENABLE_ES3
      vec4 fragColor;
    #endif
      int geomItemId = int(v_drawItemIds.x + 0.5);
      int elemId = int(v_drawItemIds.y + 0.5);
      int perFaceMaterialId = int(v_drawItemIds.z);
      int flags = int(v_geomItemData.x + 0.5);
      float treeItemOpacity = v_geomItemData.y;
    
      // We can make geoms invisible to hide them. 
      // Avoid drawing GeomData for geoms that are completely transparent.
      if (treeItemOpacity < 0.001) {
        discard;
        return;
      }
      
      // Cutaways
      if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) 
      {
        vec4 cutAwayData   = getCutaway(geomItemId);
        vec3 planeNormal = cutAwayData.xyz;
        float planeDist = cutAwayData.w;
        if (length(planeNormal) > 0.5) {
          if (cutaway(v_worldPos, planeNormal, planeDist)) {
              discard;
              return;
          }
        } else {
          if (testGeometryMask(v_viewPos)) {
            discard;
            return;
          }
        }
      }
    
    #if defined(DRAW_COLOR)
    
      if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY) && !gl_FrontFacing) {
        fragColor = cutColor;
        return;
      } else {

        //////////////////////////////////////////////
        // Normals
        
        vec3 viewNormal;
        if (length(v_viewNormal) < 0.1) {
          viewNormal = computeViewNormal(v_viewPos);
        } else {
          viewNormal = normalize(v_viewNormal);
        }
        vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);
        
        vec3 viewVector;
        if (isOrthographic == 0)
          viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));
        else 
          viewVector = vec3(-cameraMatrix[2][0], -cameraMatrix[2][1], -cameraMatrix[2][2]);
        
        //////////////////////////////////////////////
        // Material
      
        vec4 baseColor = v_vertexColors;
      
        // Hacky simple irradiance. 
        float ndotv = dot(normal, viewVector);
        if (ndotv < 0.0) {
          normal = -normal;
          ndotv = dot(normal, viewVector);
      
          // Note: these 2 lines can be used to debug inverted meshes.
          //baseColor = vec4(1.0, 0.0, 0.0, 1.0);
          //ndotv = 1.0;
        }

        fragColor = vec4((ndotv * baseColor.rgb), 1.0);
      }
    
      // Note: the 'treeItemOpacity' is not an input to the lighting, 
      // as we want to also blend off the specular reflections to make an object
      // fade away to nothing. (not become a transparent glass object).
      fragColor.a *= treeItemOpacity;
    
    
    #ifdef DEBUG_GEOM_ID
      // ///////////////////////
      // Debug Draw ID (this correlates to GeomID within a GLGeomSet)
      float geomId = v_geomItemData.w;
      fragColor.rgb = getDebugColor(geomId);
      // ///////////////////////
    #endif
    
    #ifdef ENABLE_INLINE_GAMMACORRECTION
      fragColor.rgb = toGamma(fragColor.rgb);
    #endif
    
    #elif defined(DRAW_GEOMDATA)
      if (occlusionCulling == 0) {
        // When not occlusion culling, we don't render non-selectable objects.
        //When occlusion culling, we want to draw all the geom data for all objects.
        if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {
          discard;
          return;
        }
      }
      else {
        // Transparent geoms do not render to the occlusion buffer
        if (testFlag(flags, GEOMITEM_TRANSPARENT)) {
          discard;
          return;
        }
      }
      fragColor = setFragColor_geomData(v_viewPos, v_drawItemIds.x, v_drawItemIds.y, isOrthographic, 0);
    #elif defined(DRAW_HIGHLIGHT)
      fragColor = setFragColor_highlight(v_drawItemIds.x);
    #endif // DRAW_HIGHLIGHT
    
    #ifndef ENABLE_ES3
      gl_FragColor = fragColor;
    #endif
    }`);
      }
      /**
       * The bind method.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key value.
       * @return - The return value.
       */
      bind(renderstate, key) {
          super.bind(renderstate, key);
          if (renderstate instanceof ColorRenderState) {
              const gl = this.__gl;
              const { cutColor } = renderstate.unifs;
              if (cutColor) {
                  gl.uniform4f(cutColor.location, 0.3, 0, 0, 1);
              }
          }
          return true;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material$1;
      }
      /**
       * The supportsInstancing method.
       * @return - return false for shaders that cannot be rendered in instanced mode.
       */
      static supportsInstancing() {
          return false;
      }
  }
  const material$1 = new VertexColorMaterial('VertexColorShader_template');
  Registry.register('VertexColorShader', VertexColorShader);

  var frag = "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\n\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\nimport 'geomItemFlags.glsl'\n\n#if defined(DRAW_COLOR)\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n#endif // DRAW_COLOR\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  \n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n    vec2 materialCoords = v_geomItemData.zw;\n    vec4 baseColor = getMaterialValue(materialCoords, 0);\n\n  #ifdef ENABLE_TEXTURES\n    getTextureColorValue(baseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  #endif\n\n    fragColor = baseColor;\n\n  #ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n  #endif\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(vec3(0,0,0), v_geomItemId, 0.0, isOrthographic, 0);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_geomItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"; // eslint-disable-line

  var vert = "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n\n  gl_Position = (modelMatrix * vec4(positions, 1.0));\n\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n"; // eslint-disable-line

  class ScreenSpaceShader extends GLShader {
      /**
       * Create a GL shader.
       * @param gl - The webgl rendering context.
       */
      constructor(gl) {
          super(gl, 'ScreenSpaceShader');
          this.setShaderStage('VERTEX_SHADER', vert);
          this.setShaderStage('FRAGMENT_SHADER', frag);
      }
      static isOverlay() {
          return true;
      }
      /**
       * The getPackedMaterialData method.
       * @param material - The material param.
       * @return - The return value.
       */
      static getPackedMaterialData(material) {
          const matData = new Float32Array(8);
          const baseColor = material.getParameter('BaseColor').value;
          matData[0] = baseColor.r;
          matData[1] = baseColor.g;
          matData[2] = baseColor.b;
          matData[3] = baseColor.a;
          return matData;
      }
      /**
       * Each shader provides a template material that each material instance is
       * based on. The shader specifies the parameters needed by the shader, and
       * the material provides values to the shader during rendering.
       * @return - The template material value.
       */
      static getMaterialTemplate() {
          return material;
      }
  }
  const material = new ScreenSpaceMaterial('ScreenSpaceShader_template');
  Registry.register('ScreenSpaceShader', ScreenSpaceShader);

  /** This class abstracts the rendering of a collection of geometries to screen.
   * @extends GLPass
   */
  class GLStandardGeomsPass extends GLPass {
      materials = new Map();
      listenerIDs = new Map();
      /**
       * Create a GL pass.
       */
      constructor() {
          super();
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLRenderer
       */
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
      }
      /**
       * The itemAddedToScene method is called on each pass when a new item
       * is added to the scene, and the renderer must decide how to render it.
       * It allows Passes to select geometries to handle the drawing of.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * The object contains a parameter 'continueInSubTree', which can be set to false,
       * so the subtree of this node will not be traversed after this node is handled.
       * @return - Returns true if the item is now added to the pass.
       */
      itemAddedToScene(treeItem, rargs) {
          if (treeItem instanceof GeomItem) {
              const geomItem = treeItem;
              {
                  {
                      if (this.filterGeomItem(geomItem)) {
                          this.addGeomItem(geomItem);
                          return true;
                      }
                      else {
                          return false;
                      }
                  }
              }
          }
          else {
              return false;
          }
      }
      /**
       * The itemRemovedFromScene method is called on each pass when aa item
       * is removed to the scene, and the pass must handle cleaning up any resources.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * @return - The return value.
       */
      itemRemovedFromScene(treeItem, rargs) {
          if (treeItem instanceof GeomItem) {
              this.removeGeomItem(treeItem);
              return true;
          }
          return false;
      }
      /**
       * The filterGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      filterGeomItem(geomItem) {
          return true;
      }
      /**
       * Checks the material to see if it is opaque.
       * @param material - The geomItem value.
       * @return - The return value.
       */
      checkMaterial(material) {
          return true;
      }
      /**
       * The addGeomItem method.
       * @param geomItem - The geomItem value.
       */
      addGeomItem(geomItem) {
          const listenerIDs = {};
          this.listenerIDs.set(geomItem, listenerIDs);
          // ////////////////////////////////////
          // Tracking Material Transparency changes...
          // In the case that a geometry material changes, we may need to
          // select a different pass. e.g. if the new material is transparent.
          const reassignPass = () => {
              this.removeGeomItem(geomItem);
              this.renderer.assignTreeItemToGLPass(geomItem);
          };
          listenerIDs['materialParam.valueChanged'] = geomItem.materialParam.on('valueChanged', reassignPass);
          listenerIDs['geomParam.valueChanged'] = geomItem.geomParam.on('valueChanged', reassignPass);
          const opacityChanged = (event) => {
              if (event.isOpaqueStateChanged) {
                  reassignPass();
              }
          };
          const material = geomItem.materialParam.value;
          this.materials.set(geomItem, material);
          listenerIDs['geomItem.opacityChanged'] = geomItem.on('opacityChanged', opacityChanged);
          listenerIDs['material.opacityChanged'] = material.on('opacityChanged', opacityChanged);
      }
      /**
       * The removeGeomItem method.
       * @param geomItem - The geomItem value.
       */
      removeGeomItem(geomItem) {
          const listenerIDs = this.listenerIDs.get(geomItem);
          this.listenerIDs.delete(geomItem);
          geomItem.materialParam.off('valueChanged', listenerIDs['materialParam.valueChanged']);
          geomItem.geomParam.off('valueChanged', listenerIDs['geomParam.valueChanged']);
          const material = this.materials.get(geomItem);
          this.materials.delete(geomItem);
          geomItem.off('opacityChanged', listenerIDs['geomItem.opacityChanged']);
          material.off('opacityChanged', listenerIDs['material.opacityChanged']);
      }
      /**
       * The constructShader method.
       * Given a material, generate the various shaders required to render objects
       * using this material. There should always be at least a single glShader
       * and optionally a glgeomdatashader for rendering the goem data buffer
       * and a glselectedshader for rendering selection hilghlights
       * @param shaderName - The name of the base shader.
       * @return - The object containing the shader instances.
       */
      constructShader(shaderName) {
          const glShader = this.__renderer.getOrCreateShader(shaderName);
          return glShader;
      }
      /**
       * The getGeomItemAndDist method.
       * @param geomData - The geomData value.
       * @return - The return value.
       */
      getGeomItemAndDist(geomData) {
          let itemId;
          let componentId = -1;
          let dist;
          if (geomData instanceof Float32Array) {
              itemId = Math.round(geomData[1]);
              componentId = Math.round(geomData[2]);
              dist = geomData[3];
          }
          else {
              itemId = geomData[0] + ((geomData[1] & 63) << 8);
              dist = MathFunctions.decode16BitFloatFrom2xUInt8(geomData.slice(2, 3));
          }
          const geomItem = this.renderer.glGeomItemLibrary.getGeomItem(itemId);
          if (geomItem) {
              return {
                  geomItem,
                  componentId,
                  dist,
              };
          }
          return undefined;
      }
  }

  /** Class representing a GL opaque geoms pass.
   * @extends GLStandardGeomsPass
   * @private
   */
  class GLOpaqueGeomsPass extends GLStandardGeomsPass {
      glShaderMaterials = new Map();
      glShaderGeomSets = new Map();
      /**
       * Create a GL opaque geoms pass.
       */
      constructor() {
          super();
          // Optimized Render Tree
          // Structured like so for efficient render traversial.
          // {GLShaders}[GLMaterials][GLGeoms][GLGeomItems]
      }
      /**
       * Returns the pass type. OPAQUE passes are always rendered first, followed by TRANSPARENT passes, and finally OVERLAY.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.OPAQUE;
      }
      // ///////////////////////////////////
      // Bind to Render Tree
      /**
       * The filterGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      filterGeomItem(geomItem) {
          const material = geomItem.materialParam.value;
          return geomItem.isOpaque() && material.isOpaque();
      }
      /**
       * Checks the material to see if it is opaque.
       * @param material - The geomItem value.
       * @return - The return value.
       */
      checkMaterial(material) {
          return material.isOpaque();
      }
      /**
       * Removes the GeomITem from this pass, and then asks the renderer to re-add it.
       * @param geomItem - The geomItem value.
       */
      removeAndReAddGeomItem(geomItem) {
          this.removeGeomItem(geomItem);
          this.__renderer.assignTreeItemToGLPass(geomItem);
      }
      /**
       * The addGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      addGeomItem(geomItem) {
          super.addGeomItem(geomItem);
          const materialParam = geomItem.materialParam;
          const material = materialParam.value;
          const glGeomItem = this.renderer.glGeomItemLibrary.getGLGeomItem(geomItem);
          const gl = this.__gl;
          if (gl.multiDrawElementsInstanced && glGeomItem.supportInstancing && !material.isTextured()) {
              this.addGeomItemToMultiDraw(geomItem, glGeomItem);
          }
          else {
              this.addGeomItemToConventionalDraw(geomItem, glGeomItem);
          }
      }
      addGeomItemToMultiDraw(geomItem, glGeomItem) {
          const materialParam = geomItem.materialParam;
          const material = materialParam.value;
          const shaderName = material.getShaderName();
          const shader = this.__renderer.getOrCreateShader(shaderName);
          let glShaderGeomSets = this.glShaderGeomSets.get(shader);
          if (!glShaderGeomSets) {
              glShaderGeomSets = new GLShaderGeomSets(this.__renderer, this.__gl, shader);
              glShaderGeomSets.on('updated', () => {
                  this.__renderer.requestRedraw();
              });
              this.glShaderGeomSets.set(shader, glShaderGeomSets);
          }
          glShaderGeomSets.addGLGeomItem(glGeomItem);
          glGeomItem.GLShaderGeomSets = glShaderGeomSets;
          this.emit('updated');
      }
      addGeomItemToConventionalDraw(geomItem, glGeomItem) {
          const materialParam = geomItem.materialParam;
          const material = materialParam.value;
          const glGeomLibrary = this.renderer.glGeomLibrary;
          const glGeom = glGeomLibrary.constructGLGeom(geomItem.geomParam.value);
          // ////////////////////////////////////
          // Shaders
          const shaderName = material.getShaderName();
          const glMaterial = this.renderer.glMaterialLibrary.getGLMaterial(material);
          const glShader = glMaterial.glShader;
          let glShaderMaterials = this.glShaderMaterials.get(glShader);
          if (!glShaderMaterials) {
              const shader = this.constructShader(shaderName);
              glShaderMaterials = new GLShaderMaterials(this.__gl, this, shader);
              this.glShaderMaterials.set(glShader, glShaderMaterials);
              glShaderMaterials.on('updated', () => {
                  this.__renderer.requestRedraw();
              });
          }
          glShaderMaterials.addGLGeomItem(glGeomItem, glGeom, glMaterial);
          return;
      }
      /**
       * The removeGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      removeGeomItem(geomItem) {
          super.removeGeomItem(geomItem);
          const glGeomItem = this.renderer.glGeomItemLibrary.getGLGeomItem(geomItem);
          if (glGeomItem.GLShaderGeomSets) {
              const glShaderGeomSets = glGeomItem.GLShaderGeomSets;
              glShaderGeomSets.removeGLGeomItem(glGeomItem);
              glGeomItem.GLShaderGeomSets = null;
              return;
          }
          if (glGeomItem.GLGeomItemSet) {
              const glGeomItemSet = glGeomItem.GLGeomItemSet;
              glGeomItemSet.removeGLGeomItem(glGeomItem);
              glGeomItem.GLGeomItemSet = null;
              return;
          }
          return;
      }
      /**
       * The removeMaterial method.
       * @param material - The material value.
       */
      removeMaterial(material) {
          const glMaterial = this.renderer.glMaterialLibrary.getGLMaterial(material);
          const glShader = glMaterial.glShader;
          const glShaderMaterials = this.glShaderMaterials.get(glShader);
          glShaderMaterials.removeMaterialGeomItemSets(glMaterial);
      }
      /**
       * The traverseTreeAndDraw method.
       * @param renderstate - The renderstate value.
       * @private
       */
      traverseTreeAndDraw(renderstate) {
          // eslint-disable-next-line guard-for-in
          this.glShaderGeomSets.forEach((glShaderGeomSet) => {
              glShaderGeomSet.draw(renderstate);
          });
          this.glShaderMaterials.forEach((glShaderMaterials) => {
              glShaderMaterials.draw(renderstate);
          });
          if (renderstate.glGeom) {
              renderstate.glGeom.unbind(renderstate);
          }
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          renderstate.pushGLStack('GLOpaqueGeomsPass.drawGeomData');
          renderstate.glDisable(gl.BLEND);
          renderstate.glEnable(gl.DEPTH_TEST);
          // gl.disable(gl.BLEND)
          // Note: our zcad files can contain surfaces with flipped normals.
          // This is due to re-using geoms on various sides of a mesh, while applying
          // a -1 scale on one of the axes to flip. We need 2-sided rendering enabled
          // by default.
          {
              // 2-sided rendering.
              // gl.disable(gl.CULL_FACE)
              renderstate.glDisable(gl.CULL_FACE);
          }
          // gl.enable(gl.DEPTH_TEST)
          gl.depthFunc(gl.LEQUAL);
          gl.depthMask(true);
          this.traverseTreeAndDraw(renderstate);
          const renderer = this.renderer;
          if (renderer.outlineThickness > 0 && renderer.outlineMethod == 'image') {
              renderstate.viewport.drawSilhouettes(renderstate);
          }
          renderstate.popGLStack();
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) {
          const gl = this.__gl;
          gl.disable(gl.CULL_FACE); // 2-sided rendering.
          this.glShaderGeomSets.forEach((glShaderGeomSet) => {
              glShaderGeomSet.drawHighlightedGeoms(renderstate);
          });
          this.glShaderMaterials.forEach((glShaderMaterials) => {
              glShaderMaterials.drawHighlightedGeoms(renderstate);
          });
          if (renderstate.glGeom) {
              renderstate.glGeom.unbind(renderstate);
          }
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          renderstate.passIndex = this.passIndex;
          const gl = this.__gl;
          gl.disable(gl.BLEND);
          gl.disable(gl.CULL_FACE);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.depthMask(true);
          this.glShaderGeomSets.forEach((glShaderGeomSet) => {
              glShaderGeomSet.drawGeomData(renderstate);
          });
          this.glShaderMaterials.forEach((glShaderMaterials) => {
              glShaderMaterials.drawGeomData(renderstate);
          });
          if (renderstate.glGeom) {
              renderstate.glGeom.unbind(renderstate);
          }
      }
  }
  GLRenderer.registerPass(GLOpaqueGeomsPass, PassType.OPAQUE);

  /** Class representing a GL opaque geoms pass.
   * @extends GLOpaqueGeomsPass
   * @private
   */
  class GLLinesPass extends GLOpaqueGeomsPass {
      linesGeomDataBuffer = null;
      fattenLinesShader = null;
      quad = null;
      fbo = null;
      /**
       * Create a GL opaque geoms pass.
       */
      constructor() {
          super();
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLBAseRenderer
       */
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
      }
      /**
       * The filterGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      filterGeomItem(geomItem) {
          const geom = geomItem.geomParam.value;
          if (geom instanceof Lines || geom instanceof LinesProxy || geom instanceof Points || geom instanceof PointsProxy) {
              return true;
          }
          return false;
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          renderstate.pushGLStack('GLLinesPass.draw');
          renderstate.glEnable(gl.BLEND);
          renderstate.glEnable(gl.DEPTH_TEST);
          // gl.enable(gl.BLEND)
          // gl.enable(gl.DEPTH_TEST)
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
          gl.depthFunc(gl.LEQUAL);
          gl.depthMask(true);
          this.traverseTreeAndDraw(renderstate);
          // gl.disable(gl.BLEND)
          renderstate.popGLStack();
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          const gl = this.__gl;
          //  Note: lines in VR are not fattened...
          if (renderstate.geomDataFbo && !renderstate.occlusionCulling) {
              renderstate.pushGLStack('GLLinesPass.drawGeomData');
              if (!this.linesGeomDataBuffer) {
                  this.linesGeomDataBuffer = new GLTexture2D(gl, {
                      type: this.__renderer.floatGeomBuffer ? 'FLOAT' : 'UNSIGNED_BYTE',
                      format: 'RGBA',
                      filter: 'NEAREST',
                      width: 1,
                      height: 2,
                  });
                  this.fattenLinesShader = new FattenLinesShader(gl);
                  this.quad = new GLMesh(gl, new Plane(1, 1));
              }
              const geomDataFbo = renderstate.geomDataFbo;
              const width = geomDataFbo.width;
              const height = geomDataFbo.height;
              if (this.linesGeomDataBuffer.width != width || this.linesGeomDataBuffer.height != height) {
                  if (this.fbo) {
                      gl.deleteFramebuffer(this.fbo);
                      this.fbo = null;
                  }
                  this.linesGeomDataBuffer.resize(width, height);
                  this.fbo = gl.createFramebuffer();
                  const colorTex = this.linesGeomDataBuffer.glTex;
                  const depthBuffer = geomDataFbo.depthTexture; // Share the existing depth buffer.
                  if (gl.name == 'webgl2') {
                      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo);
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTex, 0);
                      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthBuffer, 0);
                  }
                  else {
                      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTex, 0);
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthBuffer, 0);
                  }
                  checkFramebuffer(gl, width, height);
              }
              else {
                  if (gl.name == 'webgl2')
                      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.fbo);
                  else
                      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
              }
              gl.colorMask(true, true, true, true);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
          }
          super.drawGeomData(renderstate);
          if (renderstate.geomDataFbo && !renderstate.occlusionCulling) {
              renderstate.popGLStack();
              // Re-bind the FBo.
              // Note: bindForWriting tries to cache the previously bound Fbo, which is actually
              // the geomDataFbo. So we need to null here to avoid that.
              // I did work on making the renderstate track the bound Fbo, so it would do it more
              // elegantly than this, but it was a big change.
              renderstate.boundRendertarget = null;
              renderstate.geomDataFbo.bindForWriting(renderstate);
              this.fattenLinesShader.bind(renderstate);
              const { colorTexture, screenSize } = renderstate.unifs;
              this.linesGeomDataBuffer.bindToUniform(renderstate, colorTexture);
              const geomDataFbo = renderstate.geomDataFbo;
              gl.uniform2f(screenSize.location, geomDataFbo.width, geomDataFbo.height);
              this.quad.bindAndDraw(renderstate);
          }
      }
  }
  GLRenderer.registerPass(GLLinesPass, PassType.OPAQUE);

  /** Class representing a GL transparent geoms pass.
   * @extends GLStandardGeomsPass
   * @private
   */
  class GLTransparentGeomsPass extends GLStandardGeomsPass {
      itemCount = 0;
      glShaderGeomSets = {}; // GLShaderGeomSets
      transparentItems = [];
      transparentItemIndices = new Map();
      freeList = [];
      visibleItems = [];
      prevSortCameraPos = new Vec3(999, 999, 999);
      sortCameraMovementDistance = 0.25; // meters
      reSort = false;
      /**
       * Create GL transparent geoms pass.
       */
      constructor() {
          super();
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLBAseRenderer
       */
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
      }
      /**
       * Returns the pass type. OPAQUE passes are always rendered first, followed by TRANSPARENT passes, and finally OVERLAY.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.TRANSPARENT;
      }
      /**
       * The init method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      filterGeomItem(geomItem) {
          const geom = geomItem.geomParam.value;
          if (geom instanceof Lines || geom instanceof Points || geom instanceof PointsProxy || geom instanceof LinesProxy)
              return false;
          const material = geomItem.materialParam.value;
          return !geomItem.isOpaque() || !material.isOpaque();
      }
      /**
       * When an item visibility changes, we trigger this method, as new items become visible
       */
      resortNeeded() {
          this.reSort = true;
      }
      /**
       * The addGeomItem method.
       * @param geomItem - The geomItem value.
       */
      addGeomItem(geomItem) {
          super.addGeomItem(geomItem);
          this.itemCount++;
          const listenerIDs = this.listenerIDs.get(geomItem);
          const material = geomItem.materialParam.value;
          const shaderName = material.getShaderName();
          const glShader = this.constructShader(shaderName);
          if (!material.isTextured()) {
              if (material.getShaderClass().supportsInstancing()) {
                  let glShaderGeomSets = this.glShaderGeomSets[shaderName];
                  if (!glShaderGeomSets) {
                      glShaderGeomSets = new GLShaderGeomSets(this.__renderer, this.__gl, glShader);
                      glShaderGeomSets.on('updated', () => {
                          this.renderer.requestRedraw();
                      });
                      this.glShaderGeomSets[shaderName] = glShaderGeomSets;
                  }
                  const glGeomItem = this.renderer.glGeomItemLibrary.getGLGeomItem(geomItem);
                  glShaderGeomSets.addGLGeomItem(glGeomItem);
                  listenerIDs['glGeomItem.visibilityChanged'] = glGeomItem.on('visibilityChanged', () => {
                      this.resortNeeded();
                  });
                  this.emit('updated');
                  glGeomItem.GLShaderGeomSets = glShaderGeomSets;
                  // force a reSort.
                  this.reSort = true;
                  return;
              }
          }
          const glGeom = this.renderer.glGeomLibrary.constructGLGeom(geomItem.geomParam.value);
          // const glGeomItem = this.constructGLGeomItem(geomItem)
          const glGeomItem = this.renderer.glGeomItemLibrary.getGLGeomItem(geomItem);
          if (!glGeomItem)
              throw new Error('glGeomItem not found for geomItem:' + geomItem.getName());
          // @todo - make sure we remove materials and GeomItems from the base pass.
          // This code will leak memory for these classes as we are not cleaning them up.
          const glMaterial = this.renderer.glMaterialLibrary.getGLMaterial(material);
          // ////////////////////////////////////
          // Tracking visibility changes.
          const visibilityChanged = (event) => {
              if (event.visible) {
                  this.visibleItems.push(item);
              }
              else {
                  const index = this.visibleItems.indexOf(item);
                  this.visibleItems.splice(index, 1);
              }
              this.reSort = true;
          };
          listenerIDs['glGeomItem.visibilityChanged'] = glGeomItem.on('visibilityChanged', visibilityChanged);
          // ////////////////////////////////////
          // Tracking GeomMat changes.
          listenerIDs['GeomMat.valueChanged'] = geomItem.geomMatParam.on('valueChanged', () => {
              this.reSort = true;
          });
          const item = {
              geomItem,
              glShader,
              glGeom,
              glMaterial,
              glGeomItem,
              material,
              dist: 0,
          };
          let itemindex;
          if (this.freeList.length > 0)
              itemindex = this.freeList.pop();
          else
              itemindex = this.transparentItems.length;
          this.transparentItems[itemindex] = item;
          this.transparentItemIndices.set(geomItem, itemindex);
          if (geomItem.isVisible()) {
              this.visibleItems.push(item);
          }
          // force a reSort.
          this.reSort = true;
      }
      /**
       * The removeGeomItem method.
       * @param geomItem - The geomItem value.
       */
      removeGeomItem(geomItem) {
          this.itemCount--;
          const listenerIDs = this.listenerIDs.get(geomItem);
          super.removeGeomItem(geomItem);
          const glGeomItem = this.renderer.glGeomItemLibrary.getGLGeomItem(geomItem);
          if (!glGeomItem)
              throw new Error('glGeomItem not found for geomItem:' + geomItem.getName());
          glGeomItem.off('visibilityChanged', listenerIDs['glGeomItem.visibilityChanged']);
          if (glGeomItem.GLShaderGeomSets) {
              const glShaderGeomSets = glGeomItem.GLShaderGeomSets;
              glShaderGeomSets.removeGLGeomItem(glGeomItem);
              glGeomItem.GLShaderGeomSets = null;
          }
          else {
              const itemindex = this.transparentItemIndices.get(geomItem);
              const item = this.transparentItems[itemindex];
              this.transparentItemIndices.delete(geomItem);
              this.transparentItems[itemindex] = null;
              this.freeList.push(itemindex);
              const visibleindex = this.visibleItems.indexOf(item);
              if (visibleindex != -1)
                  this.visibleItems.splice(visibleindex, 1);
          }
          this.emit('updated');
          return true;
      }
      /**
       * Sorts the drawn items in order furthest to nearest when rendering transparent objects.
       * @param viewPos - The position of the camera that we are sorting relative to.
       */
      sortItems(viewPos) {
          // eslint-disable-next-line guard-for-in
          for (const shaderName in this.glShaderGeomSets) {
              this.glShaderGeomSets[shaderName].sortItems(viewPos);
          }
          for (const transparentItem of this.visibleItems) {
              const mat4 = transparentItem.glGeomItem.geomItem.geomMatParam.value;
              transparentItem.dist = mat4.translation.distanceTo(viewPos);
          }
          this.visibleItems.sort((a, b) => (a.dist > b.dist ? -1 : a.dist < b.dist ? 1 : 0));
          this.reSort = false;
      }
      /**
       * Draw n individual item, binding the shader and material if necessary.
       * @param renderstate - current renderstad
       * @param transparentItem - current item to render
       * @param cache - cache tracking which material/shader is currently bound.
       */
      drawItem(renderstate, transparentItem, cache) {
          if (cache.currentGLMaterial != transparentItem.glMaterial) {
              cache.currentGLMaterial = transparentItem.glMaterial;
              cache.currentGLMaterial.bind(renderstate, false);
          }
          if (cache.currentGLGeom != transparentItem.glGeom) {
              cache.currentGLGeom = transparentItem.glGeom;
              cache.currentGLGeom.bind(renderstate);
          }
          const glGeomItem = transparentItem.glGeomItem;
          glGeomItem.bind(renderstate);
          renderstate.bindViewports(renderstate.unifs, () => {
              cache.currentGLGeom.draw(renderstate);
          });
      }
      /**
       * The _drawItems method.
       * @param renderstate - The object tracking the current state of the renderer
       * @private
       */
      _drawItems(renderstate) {
          // Note: sorting here will not sort geometries of different types.
          // this is a flawed solution that only sorts geomemtries of the same
          // time and same shader against each other. Given that this is the data 99% o
          // of the time, this is an acceptable tradeoff
          // eslint-disable-next-line guard-for-in
          for (const shaderName in this.glShaderGeomSets) {
              this.glShaderGeomSets[shaderName].draw(renderstate);
          }
          const cache = {
              currentglShader: null,
              currentGLMaterial: null,
              currentGLGeom: null,
          };
          for (const transparentItem of this.visibleItems) {
              const glShader = transparentItem.glShader;
              if (cache.currentglShader != glShader) {
                  // Some passes, like the depth pass, bind custom uniforms.
                  // Note: No 'unbind' here before binding the next shader.
                  // That is to support a simple hack. LinesShader enables blend
                  // each time it is bound, and then disables on unbind.
                  if (!glShader.bind(renderstate, 'color')) {
                      continue;
                  }
                  // Specify an non-instanced draw to the shader
                  const gl = this.__gl;
                  const unifs = renderstate.unifs;
                  if (unifs.instancedDraw) {
                      gl.uniform1i(unifs.instancedDraw.location, 0);
                  }
                  // Note: this disables the attribute location, which must be enabled again for
                  // the next geom, which might use a different attribute location.
                  // e.g.
                  // one shader might specify attributes ['positions', 'instancedIds]
                  // another  might specify attributes ['positions', 'texCoords' 'instancedIds]
                  // In this case, we should re-enabled location 2 and then disable 3.
                  // if (renderstate.attrs.instancedIds && renderstate.attrs.instancedIds.location != -1) {
                  //   gl.disableVertexAttribArray(renderstate.attrs.instancedIds.location)
                  // }
                  this.renderer.glGeomItemLibrary.bind(renderstate);
                  this.renderer.glGeomLibrary.bind(renderstate);
                  this.renderer.glMaterialLibrary.bind(renderstate);
                  cache.currentglShader = glShader;
              }
              this.drawItem(renderstate, transparentItem, cache);
          }
          if (cache.currentglShader)
              cache.currentglShader.unbind(renderstate);
          // if (cache.currentGLGeom) cache.currentGLGeom.unbind(renderstate)
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.itemCount == 0)
              return;
          const gl = this.__gl;
          const viewPos = renderstate.viewXfo.tr;
          // Avoid sorting if the camera did not move more than the specified tolerance.
          if (this.reSort || viewPos.distanceTo(this.prevSortCameraPos) > this.sortCameraMovementDistance) {
              this.sortItems(viewPos);
              this.prevSortCameraPos = viewPos;
              if (renderstate.xrviewport) {
                  // Adapt the sort tolerance to the focal distance.
                  // In a tiny scene, we want to sort more frequently.
                  this.sortCameraMovementDistance = renderstate.viewScale * 0.2;
              }
              else if (renderstate.viewport) {
                  // Adapt the sort tolerance to the focal distance.
                  // In a tiny scene, we want to sort more frequently.
                  const camera = renderstate.viewport.getCamera(); // TODO: check if this cast is correct.
                  this.sortCameraMovementDistance = camera.getFocalDistance() * 0.3;
              }
          }
          renderstate.pushGLStack('GLTransparentGeomsPass.draw');
          renderstate.glEnable(gl.BLEND);
          renderstate.glEnable(gl.DEPTH_TEST);
          renderstate.glEnable(gl.CULL_FACE);
          // gl.enable(gl.DEPTH_TEST)
          // gl.enable(gl.BLEND)
          gl.depthFunc(gl.LESS);
          gl.blendEquation(gl.FUNC_ADD);
          // Complex transparent surfaces require multiple passes.
          // First the multiply pass tints the background color, simulating
          // light passing through the surface, and then the add layer
          // adds new color to the backbuffer to simulate light bouncing off
          // the surface.
          // TODO: Optimise this system.
          // After depth sorting, we should split the items into 2 groups.
          // Multiply items, and Add  items. (Many items will be in both)
          // Then we can simply check if we have any multiply items here
          // before rendering all items.
          // for Multiply pass, we can use front and back surfaces to calculate depth and how much
          // of the background layer to let through.
          // gl.disable(gl.CULL_FACE)
          // gl.blendFunc(gl.DST_COLOR, gl.ZERO) // For multiply, select this.
          // this._drawItems(renderstate)
          // for the Add
          renderstate.pass = 'ADD';
          // https://google.github.io/filament/Filament.html#lighting/transparencyandtranslucencylighting/transparency
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
          // Only draw font faces. BEcause all faces are drawn, it can make a mess to see the back faces through the front faces.
          // e.g. we might see the triangles on the other side of a sphere rendered over the top of triangles on the near side.
          // gl.enable(gl.CULL_FACE)
          gl.cullFace(gl.BACK);
          this._drawItems(renderstate);
          // gl.disable(gl.BLEND)
          // gl.depthMask(true)
          renderstate.popGLStack();
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) {
          const gl = this.__gl;
          gl.disable(gl.CULL_FACE); // 2-sided rendering.
          // eslint-disable-next-line guard-for-in
          for (const shaderName in this.glShaderGeomSets) {
              this.glShaderGeomSets[shaderName].drawHighlightedGeoms(renderstate);
          }
          const cache = {
              currentglShader: null,
              currentGLMaterial: null,
              currentGLGeom: null,
          };
          for (const transparentItem of this.visibleItems) {
              if (!transparentItem.geomItem.isHighlighted())
                  continue;
              const glShader = transparentItem.glShader;
              if (cache.currentglShader != glShader) {
                  // Some passes, like the depth pass, bind custom uniforms.
                  if (!glShader.bind(renderstate, 'highlight')) {
                      continue;
                  }
                  cache.currentglShader = glShader;
                  const { floatGeomBuffer, passId, instancedDraw } = renderstate.unifs;
                  if (floatGeomBuffer) {
                      gl.uniform1i(floatGeomBuffer.location, gl.floatGeomBuffer ? 1 : 0);
                  }
                  if (passId) {
                      gl.uniform1i(passId.location, this.passIndex);
                  }
                  if (instancedDraw) {
                      gl.uniform1i(instancedDraw.location, 0);
                  }
                  this.renderer.glGeomItemLibrary.bind(renderstate);
              }
              this.drawItem(renderstate, transparentItem, cache);
          }
          if (cache.currentglShader)
              cache.currentglShader.unbind(renderstate);
          if (cache.currentGLGeom)
              cache.currentGLGeom.unbind(renderstate);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          const gl = this.__gl;
          renderstate.pushGLStack('GLTransparentGeomsPass.drawGeomData');
          renderstate.glEnable(gl.DEPTH_TEST);
          renderstate.glEnable(gl.CULL_FACE);
          // eslint-disable-next-line guard-for-in
          for (const shaderName in this.glShaderGeomSets) {
              this.glShaderGeomSets[shaderName].drawGeomData(renderstate);
          }
          const cache = {
              currentglShader: null,
              currentGLMaterial: null,
              currentGLGeom: null,
          };
          for (const transparentItem of this.visibleItems) {
              if (!transparentItem.glGeomItem.geomItem.isSelectable())
                  continue;
              const glShader = transparentItem.glShader;
              if (!glShader) {
                  continue;
              }
              if (cache.currentglShader != glShader) {
                  // Some passes, like the depth pass, bind custom uniforms.
                  if (!glShader.bind(renderstate, 'geomdata')) {
                      continue;
                  }
                  cache.currentglShader = glShader;
                  const { floatGeomBuffer, passId, instancedDraw } = renderstate.unifs;
                  if (floatGeomBuffer) {
                      gl.uniform1i(floatGeomBuffer.location, gl.floatGeomBuffer ? 1 : 0);
                  }
                  if (passId) {
                      gl.uniform1i(passId.location, this.passIndex);
                  }
                  if (instancedDraw) {
                      gl.uniform1i(instancedDraw.location, 0);
                  }
                  this.renderer.glGeomItemLibrary.bind(renderstate);
              }
              this.drawItem(renderstate, transparentItem, cache);
          }
          if (cache.currentGLGeom)
              cache.currentGLGeom.unbind(renderstate);
          if (cache.currentglShader)
              cache.currentglShader.unbind(renderstate);
          renderstate.popGLStack();
      }
  }
  GLRenderer.registerPass(GLTransparentGeomsPass, PassType.TRANSPARENT);

  const pixelsPerItem = 7; // The number of pixels per draw item.
  /** Class representing a GL billboards pass.
   * @extends GLPass
   * @private
   */
  class GLBillboardsPass extends GLPass {
      billboards;
      dirtyBillboards;
      freeIndices;
      drawCount;
      threshold;
      updateRequested;
      prevSortCameraPos;
      atlas = null;
      indexArrayUpdateNeeded = false;
      instanceIdsBuffer = null;
      indexArray = new Float32Array(0);
      glshader = null;
      shaderComp = {};
      shaderBinding = null;
      modelMatrixArray = [];
      billboardDataArray = []; // TODO: map vs array? refactor
      tintColorArray = [];
      width = 0;
      drawItemsTexture = null;
      /**
       * Create a GL billboards pass.
       */
      constructor() {
          super();
          this.billboards = [];
          this.dirtyBillboards = new Set();
          this.freeIndices = [];
          this.drawCount = 0;
          this.threshold = 0.0;
          this.updateRequested = false;
          this.prevSortCameraPos = new Vec3();
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLBAseRenderer
       */
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
          // TODO: this.atlas = new GLImageAtlas(this.renderer.gl, 'Billboards', 'RGBA', 'UNSIGNED_BYTE', [1, 1, 1, 0]) // TODO: Check if last arg was for color
          this.atlas = new GLImageAtlas(this.renderer.gl, 'Billboards', 'RGBA', 'UNSIGNED_BYTE');
          this.atlas.clearColor = new Color(1, 1, 1, 0);
          const emitUpdated = (event) => this.emit('updated', event);
          this.atlas.on('loaded', emitUpdated);
          this.atlas.on('updated', emitUpdated);
      }
      /**
       * Returns the pass type. OPAQUE passes are always rendered first, followed by TRANSPARENT passes, and finally OVERLAY.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.TRANSPARENT;
      }
      /**
       * The itemAddedToScene method is called on each pass when a new item
       * is added to the scene, and the renderer must decide how to render it.
       * It allows Passes to select geometries to handle the drawing of.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * The object contains a parameter 'continueInSubTree', which can be set to false,
       * so the subtree of this node will not be traversed after this node is handled.
       * @return - The return value.
       */
      itemAddedToScene(treeItem, rargs) {
          if (treeItem instanceof BillboardItem) {
              this.addBillboard(treeItem);
              return true;
          }
          return false;
      }
      /**
       * The itemRemovedFromScene method is called on each pass when aa item
       * is removed to the scene, and the pass must handle cleaning up any resources.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * @return - The return value.
       */
      itemRemovedFromScene(treeItem, rargs) {
          if (treeItem instanceof BillboardItem) {
              this.removeBillboard(treeItem);
              return true;
          }
          return false;
      }
      // ///////////////////////////////////
      // Bind to Render Tree
      /**
       * The addBillboard method.
       * @param billboard - The billboard value.
       */
      addBillboard(billboard) {
          const imageParam = billboard.imageParam;
          const image = imageParam.value;
          if (!image) {
              imageParam.on('valueChanged', () => this.addBillboard(billboard));
              return;
          }
          let index;
          if (this.freeIndices.length > 0)
              index = this.freeIndices.pop();
          else
              index = this.billboards.length;
          const imageIndex = this.atlas.addSubImage(image);
          billboard.setMetadata('GLBillboardsPass_Index', index);
          const visibilityChanged = () => {
              if (billboard.isVisible()) {
                  this.drawCount++;
                  // The billboard Xfo might have changed while it was
                  // not visible. We need to update here.
                  this.dirtyBillboards.add(index);
              }
              else
                  this.drawCount--;
              this.reqUpdateIndexArray();
          };
          billboard.on('visibilityChanged', visibilityChanged);
          const updateBillboard = () => {
              if (billboard.isVisible()) {
                  this.dirtyBillboards.add(index);
                  this.emit('updated');
              }
          };
          billboard.globalXfoParam.on('valueChanged', updateBillboard);
          billboard.alphaParam.on('valueChanged', updateBillboard);
          billboard.on('highlightChanged', updateBillboard);
          if (billboard.isVisible())
              this.drawCount++;
          this.billboards[index] = {
              billboard,
              imageIndex,
              visibilityChanged,
              updateBillboard,
          };
          this.indexArrayUpdateNeeded = true;
          this.requestUpdate();
      }
      /**
       * The removeBillboard method.
       * @param billboard - The billboard value.
       */
      removeBillboard(billboard) {
          const index = billboard.getMetadata('GLBillboardsPass_Index');
          if (index == -1) {
              console.warn('Billboard already removed.');
              return;
          }
          const billboardData = this.billboards[index];
          // Currently we are getting errors when trying to re-generate the Fbo
          // after removing and then adding images back to the atlas.
          // I don't have time to figure it out, so simply adding images
          // to the atlas. (for the Zahner demo)
          // Eventually we need to clean up the atlas, so debug this using the
          // survey-point-calibration 190528_Dummy_Srvy_Data.vlexe test
          const image = billboardData.billboard.imageParam.value;
          this.atlas.removeSubImage(image);
          billboard.off('visibilityChanged', billboardData.visibilityChanged);
          billboard.off('highlightChanged', billboardData.updateBillboard);
          billboard.globalXfoParam.off('valueChanged', billboardData.updateBillboard);
          billboard.alphaParam.off('valueChanged', billboardData.updateBillboard);
          this.billboards[index] = null;
          this.freeIndices.push(index);
          if (billboard.isVisible())
              this.drawCount--;
          this.indexArrayUpdateNeeded = true;
          this.requestUpdate();
      }
      /**
       * The populateBillboardDataArray method.
       * @param billboardData - The billboardData value.
       * @param index - The index value.
       * @param dataArray - The dataArray value.
       * @private
       */
      populateBillboardDataArray(billboardData, index, dataArray) {
          const billboard = billboardData.billboard;
          const mat4 = billboard.globalXfoParam.value.toMat4();
          const ppm = billboard.pixelsPerMeterParam.value;
          const pivot = billboard.pivotParam.value;
          const scale = 1 / ppm;
          // Until webgl2 is standard, we will avoid using bit flags.
          // instead, we will use decimals.
          let flags = 0;
          if (billboard.alignedToCameraParam.value)
              flags |= 1 << 2;
          if (billboard.drawOnTopParam.value)
              flags |= 1 << 3;
          if (billboard.fixedSizeOnscreenParam.value)
              flags |= 1 << 4;
          const alpha = billboard.alphaParam.value;
          const color = billboard.colorParam.value;
          const offset = index * pixelsPerItem * 4;
          const col0 = new Float32Array(dataArray.buffer, offset * 4, 4);
          const col1 = new Float32Array(dataArray.buffer, (offset + 4) * 4, 4);
          const col2 = new Float32Array(dataArray.buffer, (offset + 8) * 4, 4);
          const col3 = new Float32Array(dataArray.buffer, (offset + 12) * 4, 4);
          col0.set([mat4.xAxis.x, mat4.yAxis.x, mat4.zAxis.x, mat4.translation.x]);
          col1.set([mat4.xAxis.y, mat4.yAxis.y, mat4.zAxis.y, mat4.translation.y]);
          col2.set([mat4.xAxis.z, mat4.yAxis.z, mat4.zAxis.z, mat4.translation.z]);
          col3.set([scale, flags, billboardData.imageIndex, alpha]);
          const col4 = new Float32Array(dataArray.buffer, (offset + 16) * 4, 4);
          col4.set([pivot.x, pivot.y, 0, 0]);
          const col5 = new Float32Array(dataArray.buffer, (offset + 20) * 4, 4);
          col5.set([color.r, color.g, color.b, color.a]);
          // /////////////////////////
          // Highlight
          if (billboard.isHighlighted()) {
              const highlight = billboard.getHighlight();
              const col6 = new Float32Array(dataArray.buffer, (offset + 24) * 4, 4);
              col6.set([highlight.r, highlight.g, highlight.b, highlight.a]);
          }
      }
      /**
       * The requestUpdate method.
       * @private
       */
      requestUpdate() {
          if (!this.updateRequested) {
              this.updateRequested = true;
              this.emit('updated');
          }
      }
      /**
       * The reqUpdateIndexArray method.
       * @private
       */
      reqUpdateIndexArray() {
          if (this.indexArrayUpdateNeeded)
              return;
          this.indexArrayUpdateNeeded = true;
          this.emit('updated');
      }
      // eslint-disable-next-line require-jsdoc
      updateIndexArray() {
          const gl = this.__gl;
          // Note: When the camera moves, this array is sorted and re-upload.
          if (this.indexArray && this.indexArray.length != this.drawCount) {
              gl.deleteBuffer(this.instanceIdsBuffer);
              this.instanceIdsBuffer = null;
          }
          this.indexArray = new Float32Array(this.drawCount);
          let offset = 0;
          for (let i = 0; i < this.billboards.length; i++) {
              if (this.billboards[i] && this.billboards[i].billboard.isVisible()) {
                  this.indexArray[offset] = i;
                  offset++;
              }
          }
          if (!this.instanceIdsBuffer)
              this.instanceIdsBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceIdsBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.indexArray, gl.STATIC_DRAW);
          this.indexArrayUpdateNeeded = false;
      }
      /**
       * The updateBillboards method.
       * @param renderstate - The object tracking the current state of the renderer
       * @private
       */
      updateBillboards(renderstate) {
          const doIt = () => {
              if (this.indexArrayUpdateNeeded)
                  this.updateIndexArray();
              const gl = this.__gl;
              if (!this.glshader) {
                  if (!gl.__quadVertexIdsBuffer) {
                      gl.setupInstancedQuad();
                  }
                  this.glshader = new BillboardShader(gl);
                  const shaderComp = this.glshader.compileForTarget('GLBillboardsPass', renderstate.directives);
                  this.shaderBinding = generateShaderGeomBinding(gl, shaderComp.attrs, gl.__quadattrbuffers, gl.__quadIndexBuffer);
              }
              // Note: Maybe the atlas is already up to date. It should
              // maintain its own coherencey by listening to the sub images.
              this.atlas.renderAtlas();
              if (!gl.floatTexturesSupported || !gl.drawElementsInstanced) {
                  this.modelMatrixArray = [];
                  this.billboardDataArray = [];
                  this.tintColorArray = [];
                  this.indexArray.forEach((index) => {
                      // if (index == -1) return;
                      const billboardData = this.billboards[index];
                      const billboard = billboardData.billboard;
                      const mat4 = billboard.globalXfoParam.value.toMat4();
                      const ppm = billboard.pixelsPerMeterParam.value;
                      const scale = 1 / ppm;
                      let flags = 0;
                      if (billboard.alignedToCameraParam.value)
                          flags |= 1 << 2;
                      if (billboard.drawOnTopParam.value)
                          flags |= 1 << 3;
                      if (billboard.fixedSizeOnscreenParam.value)
                          flags |= 1 << 4;
                      const alpha = billboard.alphaParam.value;
                      const color = billboard.colorParam.value;
                      this.modelMatrixArray[index] = mat4.asArray();
                      this.billboardDataArray[index] = [scale, flags, billboardData.imageIndex, alpha];
                      this.tintColorArray[index] = [color.r, color.g, color.b, color.a];
                  });
                  this.updateRequested = false;
                  return;
              }
              let size = Math.round(Math.sqrt((this.billboards.length - this.freeIndices.length) * pixelsPerItem) + 0.5);
              // Note: the following few lines need a cleanup.
              // We should be using power of 2 textures. The problem is that pot texture sizes don't
              // align with the 6 pixels per draw item. So we need to upload a slightly bigger texture
              // but upload the 'usable' size.
              // Only support power 2 textures. Else we get strange corruption on some GPUs
              // in some scenes.
              // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
              // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
              // size = Math.nextPow2(size);
              if (size % pixelsPerItem != 0)
                  size += pixelsPerItem - (size % pixelsPerItem);
              this.width = size;
              // if((this.width % pixelsPerItem) != 0)
              //     this.width -= (this.width % pixelsPerItem);
              if (!this.drawItemsTexture) {
                  const params = {
                      format: 'RGBA',
                      type: 'FLOAT',
                      width: size,
                      height: size,
                      filter: 'NEAREST',
                      wrap: 'CLAMP_TO_EDGE',
                      mipMapped: false,
                  };
                  this.drawItemsTexture = new GLTexture2D(gl, params);
                  this.drawItemsTexture.clear();
              }
              else {
                  this.drawItemsTexture.resize(size, size);
              }
              this.indexArray.forEach((index) => {
                  if (index != -1)
                      this.updateBillboard(index);
              });
              this.updateRequested = false;
          };
          if (this.atlas.isLoaded()) {
              doIt();
          }
          else {
              this.atlas.on('loaded', doIt);
          }
      }
      /**
       * The updateBillboard method.
       * @param index - The index of the Billboard to update .
       * @private
       */
      updateBillboard(index) {
          if (this.drawCount == 0 || !this.drawItemsTexture) {
              return;
          }
          const billboardData = this.billboards[index];
          if (!billboardData.billboard.isVisible())
              return;
          const gl = this.__gl;
          const dataArray = new Float32Array(pixelsPerItem * 4);
          this.populateBillboardDataArray(billboardData, 0, dataArray);
          gl.bindTexture(gl.TEXTURE_2D, this.drawItemsTexture.glTex);
          const xoffset = (index * pixelsPerItem) % this.width;
          const yoffset = Math.floor((index * pixelsPerItem) / this.width);
          const width = pixelsPerItem;
          const height = 1;
          const type = this.drawItemsTexture.getType();
          const format = this.drawItemsTexture.getFormat();
          if (type == gl.FLOAT) {
              gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, format, type, dataArray);
          }
          else {
              const unit16s = MathFunctions.convertFloat32ArrayToUInt16Array(dataArray);
              gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, format, type, unit16s);
          }
      }
      /**
       * The sort method.
       * @param cameraPos - The cameraPos value.
       */
      sort(cameraPos) {
          for (const billboardData of this.billboards) {
              const { billboard } = billboardData;
              if (billboard && billboard.isVisible()) {
                  const xfo = billboard.globalXfoParam.value;
                  billboardData.dist = xfo.tr.distanceTo(cameraPos);
              }
          }
          this.indexArray.sort((a, b) => {
              if (a == -1)
                  return 1;
              if (b == -1)
                  return -1;
              return this.billboards[a].dist > this.billboards[b].dist
                  ? -1
                  : this.billboards[a].dist < this.billboards[b].dist
                      ? 1
                      : 0;
          });
          const gl = this.__gl;
          if (gl.floatTexturesSupported && this.instanceIdsBuffer) {
              gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceIdsBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, this.indexArray, gl.STATIC_DRAW);
          }
      }
      /**
       * Invoke the drawing of each item, compiling the shader using the provided key.
       * @param renderstate - The object tracking the current state of the renderer
       * @param key - The key to cache the compiler results against.
       */
      __draw(renderstate, key) {
          const gl = this.__gl;
          if (!this.glshader)
              return;
          this.glshader.bind(renderstate, key);
          this.shaderBinding.bind(renderstate);
          const unifs = renderstate.unifs;
          const { atlasBillboards, passId, floatGeomBuffer, inVR } = renderstate.unifs;
          if (atlasBillboards) {
              this.atlas.bindToUniform(renderstate, atlasBillboards);
          }
          if (floatGeomBuffer && renderstate instanceof GeomDataRenderState) {
              gl.uniform1i(floatGeomBuffer.location, renderstate.floatGeomBuffer ? 1 : 0);
          }
          if (passId) {
              gl.uniform1i(passId.location, this.passIndex);
          }
          if (inVR) {
              gl.uniform1i(inVR.location, renderstate.vrPresenting ? 1 : 0);
          }
          if (!gl.floatTexturesSupported || !gl.drawElementsInstanced) {
              const { modelMatrix, billboardData, tintColor, layoutData } = renderstate.unifs;
              const len = this.indexArray.length;
              for (let i = 0; i < len; i++) {
                  gl.uniformMatrix4fv(modelMatrix.location, false, this.modelMatrixArray[i]);
                  gl.uniform4fv(billboardData.location, this.billboardDataArray[i]);
                  gl.uniform4fv(tintColor.location, this.tintColorArray[i]);
                  gl.uniform4fv(layoutData.location, this.atlas.getLayoutData(this.billboards[i].imageIndex));
                  renderstate.bindViewports(unifs, () => {
                      gl.drawQuad();
                  });
              }
          }
          else {
              const { instancesTexture, instancesTextureSize } = renderstate.unifs;
              this.drawItemsTexture.bindToUniform(renderstate, instancesTexture);
              gl.uniform1i(instancesTextureSize.location, this.width);
              {
                  // The instance billboard ids are bound as an instanced attribute.
                  const location = renderstate.attrs.instanceIds.location;
                  gl.enableVertexAttribArray(location);
                  gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceIdsBuffer);
                  gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 4, 0);
                  gl.vertexAttribDivisor(location, 1); // This makes it instanced
              }
              renderstate.bindViewports(unifs, () => {
                  gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, this.drawCount);
              });
          }
      }
      /**
       * The sort method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.drawCount == 0)
              return;
          if (this.updateRequested) {
              this.updateBillboards(renderstate);
          }
          if (this.dirtyBillboards.size > 0) {
              this.dirtyBillboards.forEach((index) => {
                  this.updateBillboard(index);
              });
              this.dirtyBillboards.clear();
          }
          if (this.indexArrayUpdateNeeded)
              this.updateIndexArray();
          if (!this.glshader)
              return;
          const cameraPos = renderstate.viewXfo.tr;
          const dist = cameraPos.distanceTo(this.prevSortCameraPos);
          // Avoid sorting if the camera did not move more than 3 meters.
          if (dist > this.threshold) {
              this.sort(cameraPos);
              this.prevSortCameraPos = cameraPos.clone();
              if (this.drawCount > 1) {
                  const idx0 = this.indexArray[this.indexArray.length - 1];
                  const idx1 = this.indexArray[this.indexArray.length - 2];
                  const billboard0 = this.billboards[idx0].billboard;
                  const billboard1 = this.billboards[idx1].billboard;
                  const tr0 = billboard0.globalXfoParam.value.tr;
                  const tr1 = billboard1.globalXfoParam.value.tr;
                  this.threshold = tr0.distanceTo(tr1);
              }
              else {
                  this.threshold = 9999;
              }
          }
          const gl = this.__gl;
          gl.depthMask(false);
          gl.disable(gl.CULL_FACE);
          gl.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
          this.__draw(renderstate, 'DRAW_COLOR');
          gl.disable(gl.BLEND);
          gl.depthMask(true);
      }
      /**
       * The drawHighlightedGeoms method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawHighlightedGeoms(renderstate) {
          if (this.drawCount == 0)
              return;
          this.__draw(renderstate, 'DRAW_HIGHLIGHT');
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          if (this.drawCount == 0)
              return;
          this.__draw(renderstate, 'DRAW_GEOMDATA');
      }
      /**
       * The getGeomItemAndDist method.
       * @param geomData - The geomData value.
       * @return - The return value.
       */
      getGeomItemAndDist(geomData) {
          let itemId;
          let dist;
          if (geomData instanceof Float32Array) {
              itemId = Math.round(geomData[1]);
              dist = geomData[3];
          }
          else {
              itemId = geomData[0] + ((geomData[1] & 63) << 8);
              dist = MathFunctions.decode16BitFloatFrom2xUInt8(geomData.slice(2, 3));
          }
          if (itemId >= this.billboards.length) {
              console.warn('Invalid Draw Item id:' + itemId + ' NumBillboards:' + (this.billboards.length - 1));
              return undefined;
          }
          return {
              geomItem: this.billboards[itemId].billboard,
              componentId: 0,
              dist,
          };
      }
  }
  GLRenderer.registerPass(GLBillboardsPass, PassType.TRANSPARENT);

  /** Class representing a GL overlay pass.
   * @extends GLOpaqueGeomsPass
   */
  class GLOverlayPass extends GLOpaqueGeomsPass {
      /**
       * Create a GL overlay pass.
       * @param name - The name value.
       */
      constructor() {
          super();
      }
      /**
       * Returns the pass type. OPAQUE passes are always rendered first, followed by TRANSPARENT passes, and finally OVERLAY.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.OVERLAY;
      }
      // ///////////////////////////////////
      // Bind to Render Tree
      /**
       * The filterGeomItem method.
       * @param geomItem - The geomItem value.
       * @return - The return value.
       */
      filterGeomItem(geomItem) {
          if (geomItem.isOverlay())
              return true;
          const shaderClass = geomItem.materialParam.value.getShaderClass();
          if (shaderClass) {
              if (shaderClass.isOverlay())
                  return true;
          }
          return false;
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          const gl = this.__gl;
          // Clear the depth buffer so handls are always drawn over the top.
          gl.clear(gl.DEPTH_BUFFER_BIT);
          {
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
          }
          gl.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          renderstate.pass = 'ADD';
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE); // For add
          this.traverseTreeAndDraw(renderstate);
          gl.disable(gl.BLEND);
          // gl.enable(gl.DEPTH_TEST);
      }
      /**
       * The drawGeomData method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      drawGeomData(renderstate) {
          const gl = this.__gl;
          // Clear the depth buffer so handls are always drawn over the top.
          gl.clear(gl.DEPTH_BUFFER_BIT);
          gl.enable(gl.CULL_FACE);
          gl.cullFace(gl.BACK);
          gl.enable(gl.BLEND);
          gl.blendEquation(gl.FUNC_ADD);
          renderstate.pass = 'ADD';
          gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE); // For add
          super.drawGeomData(renderstate);
          gl.disable(gl.BLEND);
          gl.enable(gl.DEPTH_TEST);
      }
  }
  GLRenderer.registerPass(GLOverlayPass, PassType.OVERLAY);
  // We register the overlay pass here so that the GLViewport can
  // find it in the GLRebderer,
  // Note: We can't simply import the class into the GLViewpoirt as that
  // is a circular import.
  Registry.register('GLOverlayPass', GLOverlayPass);

  /** Class representing a GL treeItems pass.
   * @extends GLPass
   * @private
   */
  class GLBoundingBoxPass extends GLPass {
      boxes = [];
      dirtyBoxes = new Set();
      freeIndices = [];
      idToIndex = new Map();
      drawCount = 0;
      indexArrayUpdateNeeded = false;
      __updateRequested = false;
      glgeom;
      glshader;
      __modelMatrixArray = [];
      __treeItemDataArray = [];
      __tintColorArray = [];
      __instanceIdsBuffer;
      __indexArray = new Float32Array(0);
      __drawItemsTexture;
      width = 0;
      /**
       * Create a GL treeItems pass.
       */
      constructor() {
          super();
      }
      /**
       * The getPassType method.
       * @return - The pass type value.
       */
      getPassType() {
          return PassType.OPAQUE;
      }
      /**
       * The init method.
       * @param renderer - The renderer value.
       * @param passIndex - The index of the pass in the GLBAseRenderer
       */
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
          const gl = this.__renderer.gl;
          this.glgeom = new GLLines(gl, new LinesCuboid(1, 1, 1));
          this.glshader = new BoundingBoxShader(gl);
      }
      /**
       * The itemAddedToScene method is called on each pass when a new item
       * is added to the scene, and the renderer must decide how to render it.
       * It allows Passes to select geometries to handle the drawing of.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * The object contains a parameter 'continueInSubTree', which can be set to false,
       * so the subtree of this node will not be traversed after this node is handled.
       * @return - The return value.
       */
      itemAddedToScene(treeItem, rargs) {
          // if (treeItem instanceof TreeItem) {
          //   this.bindTreeItem(treeItem)
          //   return false
          // }
          return false;
      }
      /**
       * The itemRemovedFromScene method is called on each pass when aa item
       * is removed to the scene, and the pass must handle cleaning up any resources.
       * @param treeItem - The treeItem value.
       * @param rargs - Extra return values are passed back in this object.
       * @return - The return value.
       */
      itemRemovedFromScene(treeItem, rargs) {
          // if (treeItem instanceof TreeItem) {
          //   this.unbindTreeItem(treeItem)
          //   return true
          // }
          return false;
      }
      // ///////////////////////////////////
      // Bind to Render Tree
      /**
       * Adds tree items to the renderer, selecting the correct pass to delegate rendering too, and listens to future changes in the tree.
       *
       * @param treeItem - The tree item to add.
       */
      addTreeItem(treeItem, continueIntoSubTree = true) {
          // Note: we can have BaseItems in the tree now.
          if (!(treeItem instanceof TreeItem))
              return;
          this.bindTreeItem(treeItem);
          if (continueIntoSubTree) {
              // Traverse the tree adding items until we hit the leaves (which are usually GeomItems.)
              for (const childItem of treeItem.getChildren()) {
                  if (childItem)
                      this.addTreeItem(childItem);
              }
              treeItem.on('childAdded', (event) => {
                  this.addTreeItem(event.childItem);
              });
              treeItem.on('childRemoved', (event) => {
                  this.unbindTreeItem(event.childItem);
              });
          }
      }
      /**
       * The bindTreeItem method.
       * @param treeItem - The treeItem value.
       */
      bindTreeItem(treeItem) {
          let index;
          let index_check = this.freeIndices.pop();
          if (index_check)
              index = index_check;
          else
              index = this.boxes.length;
          this.idToIndex.set(treeItem, index);
          const visibilityChanged = () => {
              if (treeItem.isVisible()) {
                  this.drawCount++;
                  // The treeItem Xfo might have changed while it was
                  // not visible. We need to update here.
                  this.dirtyBoxes.add(index);
              }
              else
                  this.drawCount--;
              this.indexArrayUpdateNeeded = true;
          };
          treeItem.on('visibilityChanged', visibilityChanged);
          const xfoChanged = () => {
              if (treeItem.isVisible()) {
                  this.dirtyBoxes.add(index);
                  this.emit('updated');
              }
          };
          treeItem.globalXfoParam.on('valueChanged', xfoChanged);
          treeItem.boundingBoxParam.on('valueChanged', xfoChanged);
          if (treeItem.isVisible())
              this.drawCount++;
          // TODO: make this a type
          this.boxes[index] = {
              treeItem,
              visibilityChanged,
              xfoChanged,
          };
          this.indexArrayUpdateNeeded = true;
          this.__updateRequested = true;
          this.emit('updated');
      }
      /**
       * The unbindTreeItem method.
       * @param treeItem - The treeItem value.
       */
      unbindTreeItem(treeItem) {
          if (!this.idToIndex.has(treeItem)) {
              console.warn('Billboard already removed.');
              return;
          }
          const index = this.idToIndex.get(treeItem);
          const treeItemData = this.boxes[index];
          treeItem.off('visibilityChanged', treeItemData.visibilityChanged);
          treeItem.globalXfoParam.off('valueChanged', treeItemData.xfoChanged);
          treeItem.boundingBoxParam.off('valueChanged', treeItemData.xfoChanged);
          this.boxes[index] = null;
          this.freeIndices.push(index);
          if (treeItem.isVisible())
              this.drawCount--;
          this.indexArrayUpdateNeeded = true;
          this.__updateRequested = true;
          this.__updateBoxes();
          this.emit('updated');
      }
      /**
       * The __populateBoxesDataArray method.
       * @param treeItemData - The treeItemData value.
       * @param index - The index value.
       * @param dataArray - The dataArray value.
       * @private
       */
      __populateBoxesDataArray(treeItemData, index, dataArray) {
          const treeItem = treeItemData.treeItem;
          let color;
          let mat4;
          if (treeItem instanceof GeomItem) {
              color = new Color(1, 0, 0, 1);
              mat4 = treeItem.geomMatParam.value;
          }
          else {
              color = new Color(0, 0, 1, 1);
              mat4 = treeItem.globalXfoParam.value.toMat4();
          }
          const bbox = treeItem.boundingBoxParam.value;
          const offset = index * pixelsPerItem$1 * 4;
          const pixel0 = new Float32Array(dataArray.buffer, offset * 4, 4);
          const pixel1 = new Float32Array(dataArray.buffer, (offset + 4) * 4, 4);
          const pixel2 = new Float32Array(dataArray.buffer, (offset + 8) * 4, 4);
          const pixel3 = new Float32Array(dataArray.buffer, (offset + 12) * 4, 4);
          const pixel4 = new Float32Array(dataArray.buffer, (offset + 16) * 4, 4);
          // const pixel5 = new Float32Array(dataArray.buffer, (offset + 20) * 4, 4)
          const pixel6 = new Float32Array(dataArray.buffer, (offset + 24) * 4, 4);
          const pixel7 = new Float32Array(dataArray.buffer, (offset + 28) * 4, 4);
          let flags = 0;
          pixel0.set([flags, 0, 0, 0]);
          pixel1.set([mat4.xAxis.x, mat4.yAxis.x, mat4.zAxis.x, mat4.translation.x]);
          pixel2.set([mat4.xAxis.y, mat4.yAxis.y, mat4.zAxis.y, mat4.translation.y]);
          pixel3.set([mat4.xAxis.z, mat4.yAxis.z, mat4.zAxis.z, mat4.translation.z]);
          pixel4.set([color.r, color.g, color.b, color.a]);
          pixel6.set([bbox.p0.x, bbox.p0.y, bbox.p0.z, 0.0]);
          pixel7.set([bbox.p1.x, bbox.p1.y, bbox.p1.z, 0.0]);
      }
      // eslint-disable-next-line require-jsdoc
      __updateIndexArray() {
          const gl = this.__gl;
          // Note: When the camera moves, this array is sorted and re-upload.
          if (this.__indexArray && this.__indexArray.length != this.drawCount) {
              gl.deleteBuffer(this.__instanceIdsBuffer);
              this.__instanceIdsBuffer = undefined;
          }
          this.__indexArray = new Float32Array(this.drawCount);
          let offset = 0;
          for (let i = 0; i < this.boxes.length; i++) {
              if (this.boxes[i] && this.boxes[i].treeItem.isVisible()) {
                  this.__indexArray[offset] = i;
                  offset++;
              }
          }
          if (!this.__instanceIdsBuffer)
              this.__instanceIdsBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.__instanceIdsBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.__indexArray, gl.STATIC_DRAW);
          this.indexArrayUpdateNeeded = false;
      }
      /**
       * The __updateBoxes method.
       * @private
       */
      __updateBoxes() {
          if (this.indexArrayUpdateNeeded)
              this.__updateIndexArray();
          const gl = this.__renderer.gl;
          let size = Math.round(Math.sqrt((this.boxes.length - this.freeIndices.length) * pixelsPerItem$1) + 0.5);
          // Note: the following few lines need a cleanup.
          // We should be using power of 2 textures. The problem is that pot texture sizes don't
          // align with the 6 pixels per draw item. So we need to upload a slightly bigger texture
          // but upload the 'usable' size.
          // Only support power 2 textures. Else we get strange corruption on some GPUs
          // in some scenes.
          // Size should be a multiple of pixelsPerItem, so each geom item is always contiguous
          // in memory. (makes updating a lot easier. See __updateItemInstanceData below)
          // size = Math.nextPow2(size);
          if (size % pixelsPerItem$1 != 0)
              size += pixelsPerItem$1 - (size % pixelsPerItem$1);
          this.width = size;
          // if((this.width % pixelsPerItem) != 0)
          //     this.width -= (this.width % pixelsPerItem);
          if (!this.__drawItemsTexture) {
              this.__drawItemsTexture = new GLTexture2D(gl, {
                  format: 'RGBA',
                  type: 'FLOAT',
                  width: size,
                  height: size,
                  filter: 'NEAREST',
                  wrap: 'CLAMP_TO_EDGE',
                  mipMapped: false,
              });
              this.__drawItemsTexture.clear();
          }
          else {
              this.__drawItemsTexture.resize(size, size);
          }
          this.__indexArray.forEach((index) => {
              if (index != -1)
                  this.__updateBox(index);
          });
          this.__updateRequested = false;
      }
      /**
       * The __updateBoxes method.
       * @param index - The index value.
       * @private
       */
      __updateBox(index) {
          if (this.drawCount == 0 || !this.__drawItemsTexture) {
              return;
          }
          const treeItemData = this.boxes[index];
          if (!treeItemData.treeItem.isVisible())
              return;
          const gl = this.__gl;
          const dataArray = new Float32Array(pixelsPerItem$1 * 4);
          this.__populateBoxesDataArray(treeItemData, 0, dataArray);
          gl.bindTexture(gl.TEXTURE_2D, this.__drawItemsTexture.glTex);
          const xoffset = (index * pixelsPerItem$1) % this.width;
          const yoffset = Math.floor((index * pixelsPerItem$1) / this.width);
          const width = pixelsPerItem$1;
          const height = 1;
          const type = this.__drawItemsTexture.getType();
          const format = this.__drawItemsTexture.getFormat();
          if (type == gl.FLOAT) {
              gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, format, type, dataArray);
          }
          else {
              const unit16s = MathFunctions.convertFloat32ArrayToUInt16Array(dataArray);
              gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, format, type, unit16s);
          }
      }
      /**
       * The sort method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.drawCount == 0) {
              return;
          }
          if (this.__updateRequested) {
              this.__updateBoxes();
          }
          if (this.dirtyBoxes.size > 0) {
              this.dirtyBoxes.forEach((index) => {
                  this.__updateBox(index);
              });
              this.dirtyBoxes.clear();
          }
          if (this.indexArrayUpdateNeeded)
              this.__updateIndexArray();
          const gl = this.__gl;
          // gl.disable(gl.CULL_FACE)
          // gl.enable(gl.BLEND)
          // gl.blendEquation(gl.FUNC_ADD)
          // gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE)
          this.glshader.bind(renderstate);
          this.glgeom.bind(renderstate);
          const unifs = renderstate.unifs;
          if (!gl.floatTexturesSupported || !gl.drawElementsInstanced) {
              const len = this.__indexArray.length;
              for (let i = 0; i < len; i++) {
                  renderstate.bindViewports(unifs, () => {
                      gl.drawQuad();
                  });
              }
          }
          else {
              this.__drawItemsTexture.bindToUniform(renderstate, unifs.instancesTexture);
              gl.uniform1i(unifs.instancesTextureSize.location, this.width);
              {
                  // The instance transform ids are bound as an instanced attribute.
                  const location = renderstate.attrs.instancedIds.location;
                  gl.enableVertexAttribArray(location);
                  gl.bindBuffer(gl.ARRAY_BUFFER, this.__instanceIdsBuffer);
                  gl.vertexAttribPointer(location, 1, gl.FLOAT, false, 4, 0);
                  gl.vertexAttribDivisor(location, 1); // This makes it instanced
              }
              gl.uniform1i(unifs.instancedDraw.location, 1);
              renderstate.bindViewports(unifs, () => {
                  this.glgeom.drawInstanced(renderstate, this.drawCount);
              });
          }
          // gl.disable(gl.BLEND)
      }
  }

  class GLMaskGeomsPass extends GLOpaqueGeomsPass {
      frontRenderTarget;
      backRenderTarget;
      itemCount = 0;
      drawMaskGeoms = false;
      init(renderer, passIndex) {
          super.init(renderer, passIndex);
          const gl = renderer.gl;
          this.frontRenderTarget = new GLRenderTarget(gl, {
              numColorChannels: 0,
              minFilter: gl.NEAREST,
              magFilter: gl.NEAREST,
              width: 4,
              height: 4,
              depthType: gl.UNSIGNED_SHORT,
              depthFormat: gl.DEPTH_COMPONENT,
              depthInternalFormat: gl.DEPTH_COMPONENT16,
          });
          this.frontRenderTarget.clearColor = new Color(0, 0, 0, 0);
          this.backRenderTarget = new GLRenderTarget(gl, {
              numColorChannels: 0,
              minFilter: gl.NEAREST,
              magFilter: gl.NEAREST,
              width: 4,
              height: 4,
              depthType: gl.UNSIGNED_SHORT,
              depthFormat: gl.DEPTH_COMPONENT,
              depthInternalFormat: gl.DEPTH_COMPONENT16,
          });
          this.backRenderTarget.clearColor = new Color(0, 0, 0, 0);
      }
      filterGeomItem(geomItem) {
          const material = geomItem.materialParam.value;
          if (material instanceof MaskMaterial) {
              return true;
          }
          return false;
      }
      /**
       * The addGeomItem method.
       * @param geomItem - The geomItem value.
       */
      addGeomItem(geomItem) {
          super.addGeomItem(geomItem);
          this.itemCount++;
      }
      /**
       * The removeGeomItem method.
       * @param geomItem - The geomItem value.
       */
      removeGeomItem(geomItem) {
          super.removeGeomItem(geomItem);
          this.itemCount--;
      }
      /**
       * The draw method.
       * @param renderstate - The object tracking the current state of the renderer
       */
      draw(renderstate) {
          if (this.itemCount == 0)
              return;
          renderstate.pushGLStack('GLMaskGeomsPass.draw');
          const gl = this.__gl;
          if (this.drawMaskGeoms) {
              renderstate.glEnable(gl.BLEND);
              gl.blendEquation(gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
              this.traverseTreeAndDraw(renderstate);
              renderstate.glDisable(gl.BLEND);
              gl.clear(gl.DEPTH_BUFFER_BIT);
          }
          const width = renderstate.region[2];
          const height = renderstate.region[3];
          if (width != this.frontRenderTarget.width || height != this.frontRenderTarget.height) {
              this.frontRenderTarget.resize(width, height);
              this.backRenderTarget.resize(width, height);
          }
          gl.depthFunc(gl.LESS);
          gl.depthMask(true);
          renderstate.glEnable(gl.DEPTH_TEST);
          this.frontRenderTarget.bindForWriting(renderstate, true);
          this.traverseTreeAndDraw(renderstate);
          this.frontRenderTarget.unbindForWriting(renderstate);
          this.backRenderTarget.bindForWriting(renderstate, true);
          // Here we invert the depth range to make the front buffer
          gl.depthFunc(gl.GREATER);
          gl.clearDepth(0);
          gl.clear(gl.DEPTH_BUFFER_BIT);
          gl.cullFace(gl.FRONT);
          this.traverseTreeAndDraw(renderstate);
          this.backRenderTarget.unbindForWriting(renderstate);
          gl.clearDepth(1);
          gl.depthFunc(gl.LESS);
          gl.cullFace(gl.BACK);
          renderstate.geometryMaskTextures = [this.frontRenderTarget.depthTexture, this.backRenderTarget.depthTexture];
          renderstate.popGLStack();
      }
      drawGeomData(renderstate) {
          // We do not want to draw the masks to the GeomData buffer
          // else it will interfere with picking objects in the scene.
      }
  }
  GLRenderer.registerPass(GLMaskGeomsPass, PassType.PRE);

  //@ts-ignore
  console.log(`Zea Engine v${version}`);
  const libsRegistry = new LibsRegistry(version);

  exports.Allocation1D = Allocation1D;
  exports.Allocator1D = Allocator1D;
  exports.AngleParameter = AngleParameter;
  exports.AssetItem = AssetItem;
  exports.AssetLoadContext = AssetLoadContext;
  exports.Attribute = Attribute;
  exports.BaseClass = BaseClass;
  exports.BaseEvent = BaseEvent;
  exports.BaseGeom = BaseGeom;
  exports.BaseGeomItem = BaseGeomItem;
  exports.BaseGroup = BaseGroup;
  exports.BaseImage = BaseImage;
  exports.BaseItem = BaseItem;
  exports.BaseProxy = BaseProxy;
  exports.BaseTool = BaseTool;
  exports.BillboardItem = BillboardItem;
  exports.BillboardShader = BillboardShader;
  exports.BinReader = BinReader;
  exports.BinWriter = BinWriter;
  exports.BooleanOperatorInput = BooleanOperatorInput;
  exports.BooleanOperatorOutput = BooleanOperatorOutput;
  exports.BooleanParameter = BooleanParameter;
  exports.Box2 = Box2;
  exports.Box2Parameter = Box2Parameter;
  exports.Box3 = Box3;
  exports.Box3Parameter = Box3Parameter;
  exports.CADAssembly = CADAssembly;
  exports.CADAsset = CADAsset;
  exports.CADBody = CADBody;
  exports.CADPart = CADPart;
  exports.Camera = Camera;
  exports.CameraManipulator = CameraManipulator;
  exports.ChildAddedEvent = ChildAddedEvent;
  exports.Circle = Circle;
  exports.Color = Color;
  exports.ColorAttribute = ColorAttribute;
  exports.ColorOperatorInput = ColorOperatorInput;
  exports.ColorOperatorOutput = ColorOperatorOutput;
  exports.ColorParameter = ColorParameter;
  exports.ColorRenderState = ColorRenderState;
  exports.CompoundGeom = CompoundGeom;
  exports.Cone = Cone;
  exports.ControllerAddedEvent = ControllerAddedEvent;
  exports.CountChangedEvent = CountChangedEvent;
  exports.Cross = Cross;
  exports.Cuboid = Cuboid;
  exports.CuttingPlane = CuttingPlane;
  exports.Cylinder = Cylinder;
  exports.DataImage = DataImage;
  exports.Disc = Disc;
  exports.EnvMap = EnvMap;
  exports.EnvMapAssignedEvent = EnvMapAssignedEvent;
  exports.EnvMapShader = EnvMapShader;
  exports.EnvProjectionMaterial = EnvProjectionMaterial;
  exports.EnvProjectionShader = EnvProjectionShader;
  exports.EulerAngles = EulerAngles;
  exports.EventEmitter = EventEmitter;
  exports.FRAMEBUFFER = FRAMEBUFFER;
  exports.FatLinesMaterial = FatLinesMaterial;
  exports.FatLinesShader = FatLinesShader;
  exports.FatPoints = FatPoints;
  exports.FatPointsMaterial = FatPointsMaterial;
  exports.FatPointsShader = FatPointsShader;
  exports.FileImage = FileImage;
  exports.FileImage2D = FileImage2D;
  exports.FlatSurfaceMaterial = FlatSurfaceMaterial;
  exports.FlatSurfaceShader = FlatSurfaceShader;
  exports.Float32 = Float32;
  exports.Float32ArrayParameter = Float32ArrayParameter;
  exports.Frustum = Frustum;
  exports.GIFImage = GIFImage;
  exports.GLBaseRenderer = GLBaseRenderer;
  exports.GLBaseViewport = GLBaseViewport;
  exports.GLBillboardsPass = GLBillboardsPass;
  exports.GLBoundingBoxPass = GLBoundingBoxPass;
  exports.GLCADPass = GLCADPass;
  exports.GLFbo = GLFbo;
  exports.GLGeom = GLGeom;
  exports.GLGeomItem = GLGeomItem;
  exports.GLGeomItemChangeType = GLGeomItemChangeType;
  exports.GLGeomItemFlags = GLGeomItemFlags;
  exports.GLGeomItemSet = GLGeomItemSet;
  exports.GLGeomItemSetMultiDraw = GLGeomItemSetMultiDraw;
  exports.GLGeomItemSetMultiDrawCompoundGeom = GLGeomItemSetMultiDrawCompoundGeom;
  exports.GLLines = GLLines;
  exports.GLLinesItemSet = GLLinesItemSet;
  exports.GLLinesPass = GLLinesPass;
  exports.GLMaskGeomsPass = GLMaskGeomsPass;
  exports.GLMaterial = GLMaterial;
  exports.GLMaterialGeomItemSets = GLMaterialGeomItemSets;
  exports.GLMesh = GLMesh;
  exports.GLMeshItemSet = GLMeshItemSet;
  exports.GLOpaqueGeomsPass = GLOpaqueGeomsPass;
  exports.GLOverlayPass = GLOverlayPass;
  exports.GLPass = GLPass;
  exports.GLPoints = GLPoints;
  exports.GLPointsItemSet = GLPointsItemSet;
  exports.GLRenderTarget = GLRenderTarget;
  exports.GLRenderer = GLRenderer;
  exports.GLShader = GLShader;
  exports.GLShaderGeomSets = GLShaderGeomSets;
  exports.GLShaderMaterials = GLShaderMaterials;
  exports.GLStandardGeomsPass = GLStandardGeomsPass;
  exports.GLTexture2D = GLTexture2D;
  exports.GLTransparentGeomsPass = GLTransparentGeomsPass;
  exports.GLViewport = GLViewport;
  exports.GROUP_XFO_MODES = GROUP_XFO_MODES;
  exports.GeomDataRenderState = GeomDataRenderState;
  exports.GeomItem = GeomItem;
  exports.GeomLibrary = GeomLibrary;
  exports.GeometryParameter = GeometryParameter;
  exports.Grid = Grid;
  exports.GridTreeItem = GridTreeItem;
  exports.GrowingPacker = GrowingPacker;
  exports.HDRImage = HDRImage;
  exports.HighlightRenderState = HighlightRenderState;
  exports.IGeomShaderBinding = IGeomShaderBinding;
  exports.ImageParameter = ImageParameter;
  exports.IndexDBCache = IndexDBCache;
  exports.IndexEvent = IndexEvent;
  exports.InstanceItem = InstanceItem;
  exports.IntersectionData = IntersectionData;
  exports.ItemEvent = ItemEvent;
  exports.ItemSetParameter = ItemSetParameter;
  exports.KeyboardEvent = KeyboardEvent;
  exports.KinematicGroup = KinematicGroup;
  exports.LDRImage = LDRImage;
  exports.LDRVideo = LDRVideo;
  exports.Label = Label;
  exports.LabelManager = LabelManager;
  exports.Lines = Lines;
  exports.LinesCuboid = LinesCuboid;
  exports.LinesMaterial = LinesMaterial;
  exports.LinesProxy = LinesProxy;
  exports.LinesShader = LinesShader;
  exports.LinesSphere = LinesSphere;
  exports.ListParameter = ListParameter;
  exports.MaskMaterial = MaskMaterial;
  exports.Mat3 = Mat3;
  exports.Mat3OperatorInput = Mat3OperatorInput;
  exports.Mat3OperatorOutput = Mat3OperatorOutput;
  exports.Mat3Parameter = Mat3Parameter;
  exports.Mat4 = Mat4;
  exports.Mat4OperatorInput = Mat4OperatorInput;
  exports.Mat4OperatorOutput = Mat4OperatorOutput;
  exports.Mat4Parameter = Mat4Parameter;
  exports.Material = Material;
  exports.MaterialColorParam = MaterialColorParam;
  exports.MaterialFloatParam = MaterialFloatParam;
  exports.MaterialGroup = MaterialGroup;
  exports.MaterialLibrary = MaterialLibrary;
  exports.MaterialParameter = MaterialParameter;
  exports.MathFunctions = MathFunctions;
  exports.Mesh = Mesh;
  exports.MeshProxy = MeshProxy;
  exports.MultiChoiceParameter = MultiChoiceParameter;
  exports.NameChangedEvent = NameChangedEvent;
  exports.NumberOperatorInput = NumberOperatorInput;
  exports.NumberOperatorOutput = NumberOperatorOutput;
  exports.NumberParameter = NumberParameter;
  exports.ObjAsset = ObjAsset;
  exports.OpacityStateChangedEvent = OpacityStateChangedEvent;
  exports.Operator = Operator;
  exports.OperatorInput = OperatorInput;
  exports.OperatorOutput = OperatorOutput;
  exports.PMIItem = PMIItem;
  exports.PMIView = PMIView;
  exports.POINTER_TYPES = POINTER_TYPES;
  exports.Parameter = Parameter;
  exports.ParameterAddedEvent = ParameterAddedEvent;
  exports.ParameterOwner = ParameterOwner;
  exports.ParameterRemovedEvent = ParameterRemovedEvent;
  exports.PassType = PassType;
  exports.Plane = Plane;
  exports.PlaneType = PlaneType;
  exports.PointGrid = PointGrid;
  exports.Points = Points;
  exports.PointsMaterial = PointsMaterial;
  exports.PointsProxy = PointsProxy;
  exports.PointsShader = PointsShader;
  exports.ProceduralLines = ProceduralLines;
  exports.ProceduralMesh = ProceduralMesh;
  exports.ProceduralPoints = ProceduralPoints;
  exports.ProgressEvent = ProgressEvent;
  exports.Quat = Quat;
  exports.QuatOperatorInput = QuatOperatorInput;
  exports.QuatOperatorOutput = QuatOperatorOutput;
  exports.QuatParameter = QuatParameter;
  exports.RGBA = RGBA;
  exports.RangeLoadedEvent = RangeLoadedEvent;
  exports.Ray = Ray;
  exports.Rect = Rect;
  exports.RefCounted = RefCounted;
  exports.Registry = Registry;
  exports.RenderState = RenderState;
  exports.ResizedEvent = ResizedEvent;
  exports.ResourceLoader = ResourceLoader;
  exports.SInt16 = SInt16;
  exports.SInt32 = SInt32;
  exports.SInt8 = SInt8;
  exports.Scene = Scene;
  exports.SceneSetEvent = SceneSetEvent;
  exports.ScreenQuadShader = ScreenQuadShader;
  exports.ScreenSpaceMaterial = ScreenSpaceMaterial;
  exports.ScreenSpaceShader = ScreenSpaceShader;
  exports.SelectabilityChangedEvent = SelectabilityChangedEvent;
  exports.SelectedEvent = SelectedEvent;
  exports.SelectionSet = SelectionSet;
  exports.ShaderLibrary = ShaderLibrary;
  exports.ShaderNameChangedEvent = ShaderNameChangedEvent;
  exports.SimpleSurfaceMaterial = SimpleSurfaceMaterial;
  exports.SimpleSurfaceShader = SimpleSurfaceShader;
  exports.Sphere = Sphere;
  exports.SphereType = SphereType;
  exports.StandardSurfaceMaterial = StandardSurfaceMaterial;
  exports.StandardSurfaceShader = StandardSurfaceShader;
  exports.StateChangedEvent = StateChangedEvent;
  exports.StreamFileParsedEvent = StreamFileParsedEvent;
  exports.StringFunctions = StringFunctions;
  exports.StringListParameter = StringListParameter;
  exports.StringParameter = StringParameter;
  exports.StructParameter = StructParameter;
  exports.SystemDesc = SystemDesc;
  exports.TexturedChangedEvent = TexturedChangedEvent;
  exports.Torus = Torus;
  exports.Touch = Touch;
  exports.TreeItem = TreeItem;
  exports.TreeItemParameter = TreeItemParameter;
  exports.UInt16 = UInt16;
  exports.UInt32 = UInt32;
  exports.UInt8 = UInt8;
  exports.UnpackHDRShader = UnpackHDRShader;
  exports.VLAAsset = VLAAsset;
  exports.VRController = VRController;
  exports.VRViewport = VRViewport;
  exports.Vec2 = Vec2;
  exports.Vec2Attribute = Vec2Attribute;
  exports.Vec2OperatorInput = Vec2OperatorInput;
  exports.Vec2OperatorOutput = Vec2OperatorOutput;
  exports.Vec2Parameter = Vec2Parameter;
  exports.Vec3 = Vec3;
  exports.Vec3Attribute = Vec3Attribute;
  exports.Vec3OperatorInput = Vec3OperatorInput;
  exports.Vec3OperatorOutput = Vec3OperatorOutput;
  exports.Vec3Parameter = Vec3Parameter;
  exports.Vec4 = Vec4;
  exports.Vec4Attribute = Vec4Attribute;
  exports.Vec4OperatorInput = Vec4OperatorInput;
  exports.Vec4OperatorOutput = Vec4OperatorOutput;
  exports.Vec4Parameter = Vec4Parameter;
  exports.Version = Version;
  exports.VertexColorMaterial = VertexColorMaterial;
  exports.VertexColorShader = VertexColorShader;
  exports.VideoStreamImage2D = VideoStreamImage2D;
  exports.ViewChangedEvent = ViewChangedEvent;
  exports.VisibilityChangedEvent = VisibilityChangedEvent;
  exports.XRController = XRController;
  exports.XRControllerEvent = XRControllerEvent;
  exports.XRHead = XRHead;
  exports.XRPointerEvent = XRPointerEvent;
  exports.XRPoseEvent = XRPoseEvent;
  exports.XRViewChangedEvent = XRViewChangedEvent;
  exports.XRViewManipulator = XRViewManipulator;
  exports.XRViewport = XRViewport;
  exports.XRef = XRef;
  exports.Xfo = Xfo;
  exports.XfoOperatorInput = XfoOperatorInput;
  exports.XfoOperatorOutput = XfoOperatorOutput;
  exports.XfoParameter = XfoParameter;
  exports.XrViewportEvent = XrViewportEvent;
  exports.ZeaKeyboardEvent = ZeaKeyboardEvent;
  exports.ZeaMouseEvent = ZeaMouseEvent;
  exports.ZeaPointerEvent = ZeaPointerEvent;
  exports.ZeaTouchEvent = ZeaTouchEvent;
  exports.ZeaUIEvent = ZeaUIEvent;
  exports.ZeaWheelEvent = ZeaWheelEvent;
  exports.checkFramebuffer = checkFramebuffer;
  exports.create3DContext = create3DContext;
  exports.genDataTypeDesc = genDataTypeDesc;
  exports.generateShaderGeomBinding = generateShaderGeomBinding;
  exports.getFileFolder = getFileFolder;
  exports.labelManager = labelManager;
  exports.libsRegistry = libsRegistry;
  exports.loadBinfile = loadBinfile;
  exports.loadJSONfile = loadJSONfile;
  exports.loadTextfile = loadTextfile;
  exports.loadXMLfile = loadXMLfile;
  exports.resourceLoader = resourceLoader;
  exports.shaderLibrary = shaderLibrary;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
